{"files":[{"patch":"@@ -53,1 +53,1 @@\n-public class BenchmarkParams extends BenchmarkParamsL4 {\n+public class BenchmarkParams extends BenchmarkParamsL3 {\n@@ -56,13 +56,0 @@\n-    \/**\n-     * Do the class hierarchy trick to evade false sharing, and check if it's working in runtime.\n-     * @see org.openjdk.jmh.infra.Blackhole description for the rationale\n-     *\/\n-    static {\n-        Utils.check(BenchmarkParams.class, \"benchmark\", \"generatedTarget\", \"synchIterations\");\n-        Utils.check(BenchmarkParams.class, \"threads\", \"threadGroups\", \"forks\", \"warmupForks\");\n-        Utils.check(BenchmarkParams.class, \"warmup\", \"measurement\");\n-        Utils.check(BenchmarkParams.class, \"mode\", \"params\");\n-        Utils.check(BenchmarkParams.class, \"timeUnit\", \"opsPerInvocation\");\n-        Utils.check(BenchmarkParams.class, \"jvm\", \"jvmArgs\");\n-    }\n-\n@@ -90,25 +77,0 @@\n-abstract class BenchmarkParamsL4 extends BenchmarkParamsL3 {\n-    private static final long serialVersionUID = -2409216922027695385L;\n-\n-    private int markerEnd;\n-    public BenchmarkParamsL4(String benchmark, String generatedTarget, boolean synchIterations,\n-                             int threads, int[] threadGroups, Collection<String> threadGroupLabels,\n-                             int forks, int warmupForks,\n-                             IterationParams warmup, IterationParams measurement,\n-                             Mode mode, WorkloadParams params,\n-                             TimeUnit timeUnit, int opsPerInvocation,\n-                             String jvm, Collection<String> jvmArgs,\n-                             String jdkVersion, String vmName, String vmVersion, String jmhVersion,\n-                             TimeValue timeout) {\n-        super(benchmark, generatedTarget, synchIterations,\n-                threads, threadGroups, threadGroupLabels,\n-                forks, warmupForks,\n-                warmup, measurement,\n-                mode, params,\n-                timeUnit, opsPerInvocation,\n-                jvm, jvmArgs,\n-                jdkVersion, vmName, vmVersion, jmhVersion,\n-                timeout);\n-    }\n-}\n-\n@@ -156,1 +118,1 @@\n-abstract class BenchmarkParamsL1 extends BenchmarkParamsL0 {\n+abstract class BenchmarkParamsL1 {\n@@ -175,5 +137,1 @@\n-abstract class BenchmarkParamsL0 {\n-    private int markerBegin;\n-}\n-\n-abstract class BenchmarkParamsL2 extends BenchmarkParamsL1 implements Serializable, Comparable<BenchmarkParams> {\n+abstract class BenchmarkParamsL2 implements Serializable, Comparable<BenchmarkParams> {\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/infra\/BenchmarkParams.java","additions":3,"deletions":45,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -38,5 +38,1 @@\n-abstract class BlackholeL0 {\n-    private int markerBegin;\n-}\n-\n-abstract class BlackholeL1 extends BlackholeL0 {\n+abstract class BlackholeL1 {\n@@ -144,4 +140,0 @@\n-abstract class BlackholeL4 extends BlackholeL3 {\n-    private int markerEnd;\n-}\n-\n@@ -155,1 +147,1 @@\n-public final class Blackhole extends BlackholeL4 {\n+public final class Blackhole extends BlackholeL3 {\n@@ -264,10 +256,0 @@\n-\n-        Utils.check(Blackhole.class, \"b1\", \"b2\");\n-        Utils.check(Blackhole.class, \"bool1\", \"bool2\");\n-        Utils.check(Blackhole.class, \"c1\", \"c2\");\n-        Utils.check(Blackhole.class, \"s1\", \"s2\");\n-        Utils.check(Blackhole.class, \"i1\", \"i2\");\n-        Utils.check(Blackhole.class, \"l1\", \"l2\");\n-        Utils.check(Blackhole.class, \"f1\", \"f2\");\n-        Utils.check(Blackhole.class, \"d1\", \"d2\");\n-        Utils.check(Blackhole.class, \"obj1\");\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/infra\/Blackhole.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -33,10 +33,1 @@\n-public final class Control extends ControlL4 {\n-\n-    \/**\n-     * Do the class hierarchy trick to evade false sharing, and check if it's working in runtime.\n-     * @see org.openjdk.jmh.infra.Blackhole description for the rationale\n-     *\/\n-    static {\n-        Utils.check(Control.class, \"startMeasurement\", \"stopMeasurement\");\n-    }\n-\n+public final class Control extends ControlL3 {\n@@ -45,5 +36,1 @@\n-abstract class ControlL0 {\n-    private int markerBegin;\n-}\n-\n-abstract class ControlL1 extends ControlL0 {\n+abstract class ControlL1 {\n@@ -100,5 +87,0 @@\n-\n-abstract class ControlL4 extends ControlL3 {\n-    private int markerEnd;\n-}\n-\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/infra\/Control.java","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-public final class IterationParams extends IterationParamsL4 {\n+public final class IterationParams extends IterationParamsL3 {\n@@ -51,4 +51,0 @@\n-    static {\n-        Utils.check(IterationParams.class, \"type\", \"count\", \"timeValue\", \"batchSize\");\n-    }\n-\n@@ -59,10 +55,0 @@\n-\n-abstract class IterationParamsL4 extends IterationParamsL3 {\n-    private static final long serialVersionUID = 9079354621906758255L;\n-\n-    private int markerEnd;\n-    public IterationParamsL4(IterationType type, int count, TimeValue time, int batchSize) {\n-        super(type, count, time, batchSize);\n-    }\n-}\n-\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/infra\/IterationParams.java","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-public final class ThreadParams extends ThreadParamsL4 {\n+public final class ThreadParams extends ThreadParamsL3 {\n@@ -43,8 +43,0 @@\n-    static {\n-        Utils.check(ThreadParams.class, \"threadIdx\", \"threadCount\");\n-        Utils.check(ThreadParams.class, \"groupIdx\", \"groupCount\");\n-        Utils.check(ThreadParams.class, \"subgroupIdx\", \"subgroupCount\");\n-        Utils.check(ThreadParams.class, \"groupThreadIdx\", \"groupThreadCount\");\n-        Utils.check(ThreadParams.class, \"subgroupThreadIdx\", \"subgroupThreadCount\");\n-    }\n-\n@@ -203,5 +195,1 @@\n-abstract class ThreadParamsL0 {\n-    private int markerBegin;\n-}\n-\n-abstract class ThreadParamsL1 extends ThreadParamsL0 {\n+abstract class ThreadParamsL1 {\n@@ -272,10 +260,0 @@\n-\n-abstract class ThreadParamsL4 extends ThreadParamsL3 {\n-    private int markerEnd;\n-\n-    public ThreadParamsL4(int threadIdx, int threadCount, int groupIdx, int groupCount, int subgroupIdx, int subgroupCount,\n-                          int groupThreadIdx, int groupThreadCount, int subgroupThreadIdx, int subgroupThreadCount) {\n-        super(threadIdx, threadCount, groupIdx, groupCount, subgroupIdx, subgroupCount,\n-                groupThreadIdx, groupThreadCount, subgroupThreadIdx, subgroupThreadCount);\n-    }\n-}\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/infra\/ThreadParams.java","additions":2,"deletions":24,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -40,19 +40,1 @@\n-public class InfraControl extends InfraControlL4 {\n-\n-    \/**\n-     * Do the class hierarchy trick to evade false sharing, and check if it's working in runtime.\n-     * @see org.openjdk.jmh.infra.Blackhole description for the rationale\n-     *\/\n-    static {\n-        Utils.check(InfraControl.class, \"isDone\", \"isFailing\");\n-        Utils.check(InfraControl.class, \"volatileSpoiler\");\n-        Utils.check(InfraControl.class, \"preSetup\", \"preTearDown\");\n-        Utils.check(InfraControl.class, \"firstIteration\");\n-        Utils.check(InfraControl.class, \"lastIteration\");\n-        Utils.check(InfraControl.class, \"shouldYield\");\n-        Utils.check(InfraControl.class, \"warmupVisited\", \"warmdownVisited\");\n-        Utils.check(InfraControl.class, \"warmupShouldWait\", \"warmdownShouldWait\");\n-        Utils.check(InfraControl.class, \"warmupDone\", \"warmdownDone\");\n-        Utils.check(InfraControl.class, \"benchmarkParams\", \"iterationParams\");\n-        Utils.check(InfraControl.class, \"shouldSynchIterations\", \"threads\");\n-    }\n+public class InfraControl extends InfraControlL3 {\n@@ -128,5 +110,1 @@\n-abstract class InfraControlL0 {\n-    private int markerBegin;\n-}\n-\n-abstract class InfraControlL1 extends InfraControlL0 {\n+abstract class InfraControlL1 {\n@@ -295,13 +273,0 @@\n-\n-abstract class InfraControlL4 extends InfraControlL3 {\n-    private int markerEnd;\n-\n-    public InfraControlL4(BenchmarkParams benchmarkParams, IterationParams iterationParams,\n-                          CountDownLatch preSetup, CountDownLatch preTearDown,\n-                          boolean firstIteration, boolean lastIteration,\n-                          boolean shouldYield,\n-                          Control notifyControl) {\n-        super(benchmarkParams, iterationParams, preSetup, preTearDown, firstIteration, lastIteration, shouldYield, notifyControl);\n-    }\n-}\n-\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/runner\/InfraControl.java","additions":2,"deletions":37,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -41,12 +41,0 @@\n-    private static final Unsafe U;\n-\n-    static {\n-        try {\n-            Field unsafe = Unsafe.class.getDeclaredField(\"theUnsafe\");\n-            unsafe.setAccessible(true);\n-            U = (Unsafe) unsafe.get(null);\n-        } catch (NoSuchFieldException | IllegalAccessException e) {\n-            throw new IllegalStateException(e);\n-        }\n-    }\n-\n@@ -363,29 +351,0 @@\n-    public static void check(Class<?> klass, String... fieldNames) {\n-        for (String fieldName : fieldNames) {\n-            check(klass, fieldName);\n-        }\n-    }\n-\n-    public static void check(Class<?> klass, String fieldName) {\n-        final long requiredGap = 128;\n-        long markerBegin = getOffset(klass, \"markerBegin\");\n-        long markerEnd = getOffset(klass, \"markerEnd\");\n-        long off = getOffset(klass, fieldName);\n-        if (markerEnd - off < requiredGap || off - markerBegin < requiredGap) {\n-            throw new IllegalStateException(\"Consistency check failed for \" + fieldName + \", off = \" + off + \", markerBegin = \" + markerBegin + \", markerEnd = \" + markerEnd);\n-        }\n-    }\n-\n-    public static long getOffset(Class<?> klass, String fieldName) {\n-        do {\n-            try {\n-                Field f = klass.getDeclaredField(fieldName);\n-                return U.objectFieldOffset(f);\n-            } catch (NoSuchFieldException e) {\n-                \/\/ whatever, will try superclass\n-            }\n-            klass = klass.getSuperclass();\n-        } while (klass != null);\n-        throw new IllegalStateException(\"Can't find field \\\"\" + fieldName + \"\\\"\");\n-    }\n-\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/util\/Utils.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"modified"}]}