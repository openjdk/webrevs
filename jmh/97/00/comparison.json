{"files":[{"patch":"@@ -195,1 +195,1 @@\n-    protected final int opsPerInvocation;\n+    protected int opsPerInvocation;\n@@ -329,0 +329,8 @@\n+    \/**\n+     * Sets operations per invocation.\n+     * @param opsPerInvocation the number of operations per invocation\n+     *\/\n+    public void setOpsPerInvocation(int opsPerInvocation) {\n+        this.opsPerInvocation = opsPerInvocation;\n+    }\n+\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/infra\/BenchmarkParams.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2015, Oracle America, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ *  * Redistributions of source code must retain the above copyright notice,\n+ *    this list of conditions and the following disclaimer.\n+ *\n+ *  * Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in the\n+ *    documentation and\/or other materials provided with the distribution.\n+ *\n+ *  * Neither the name of Oracle nor the names of its contributors may be used\n+ *    to endorse or promote products derived from this software without\n+ *    specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+ * THE POSSIBILITY OF SUCH DAMAGE.\n+ *\/\n+package org.openjdk.jmh.samples;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.BenchmarkParams;\n+import org.openjdk.jmh.infra.Blackhole;\n+import org.openjdk.jmh.profile.LinuxPerfNormProfiler;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(5)\n+@State(Scope.Benchmark)\n+public class JMHSample_40_InfraParamNormalization {\n+\n+    \/*\n+     * This sample serves a dual purposes:\n+     *\n+     * First, it shows how to adjust opsPerSample from within the benchmarked project.\n+     * A correct opsPerSample normalizes all performance numbers and makes interpretation\n+     * of the benchmark results much simpler. In many cases this cannot be reasonably set\n+     * via annotations (not constant \/ known at compile time) nor by the java API (Runner\n+     * does not allow to set that on per-benchmark basis).\n+     *\n+     * Second, it serves as a warning against using shortish branching patterns that are\n+     * constant across invocations. As this benchmark demonstrates, modern CPU can memorize\n+     * surprisingly long branching patterns from one invocation to the next.\n+     *\n+     * This works via the branch history table. If our branch is taken half of the time,\n+     * and the branching pattern repeats every size 1000 times (i.e. it is the same for\n+     * each invocation and each invocation hits the branch 1000 times), then it is enough\n+     * to know the last 10 branch outcomes to identify our position in the sequence and\n+     * therefore almost perfectly predict the next branch outcome. This is the same way\n+     * that e.g. genomic sequences are reconstructed from short reads.\n+     *\n+     * Cf e.g. https:\/\/discourse.julialang.org\/t\/psa-microbenchmarks-remember-branch-history\/17436\n+     *\/\n+\n+    byte[] bytes;\n+\n+    @Param({\"100\", \"1000\", \"5000\", \"10000\", \"100000\"})\n+    int size;\n+\n+    @Setup\n+    public void setup(BenchmarkParams params) {\n+        bytes = new byte[size];\n+        Random random = new Random(1234);\n+        random.nextBytes(bytes);\n+        params.setOpsPerInvocation(size);\n+    }\n+\n+    @Benchmark\n+    public void memorizePattern(Blackhole bh1, Blackhole bh2) {\n+        for (byte v : bytes) {\n+            if (v > 0) {\n+                bh1.consume(v);\n+            } else {\n+                bh2.consume(v);\n+            }\n+        }\n+    }\n+\n+\n+    \/*\n+        There is a substantial difference in performance for these benchmarks!\n+\n+        We see that the i9-9900K has a 20 cycle branch-miss penalty, can almost perfectly\n+        memorize patterns of length 5k, and cannot memorize patterns of length 100k.\n+\n+        Benchmark                                                                     (size)  Mode  Cnt   Score    Error  Units\n+        JMHSample_40_InfraParamNormalization.memorizePattern                             100  avgt   15   0.279 ±  0.001  ns\/op\n+        JMHSample_40_InfraParamNormalization.memorizePattern:branch-misses:u             100  avgt    3  ≈ 10⁻⁴            #\/op\n+        JMHSample_40_InfraParamNormalization.memorizePattern:branches:u                  100  avgt    3   1.476 ±  0.065   #\/op\n+        JMHSample_40_InfraParamNormalization.memorizePattern:cycles:u                    100  avgt    3   1.328 ±  0.080   #\/op\n+        JMHSample_40_InfraParamNormalization.memorizePattern                            1000  avgt   15   0.249 ±  0.001  ns\/op\n+        JMHSample_40_InfraParamNormalization.memorizePattern:branch-misses:u            1000  avgt    3  ≈ 10⁻³            #\/op\n+        JMHSample_40_InfraParamNormalization.memorizePattern:branches:u                 1000  avgt    3   1.371 ±  0.126   #\/op\n+        JMHSample_40_InfraParamNormalization.memorizePattern:cycles:u                   1000  avgt    3   1.179 ±  0.034   #\/op\n+        JMHSample_40_InfraParamNormalization.memorizePattern                            5000  avgt   15   0.297 ±  0.028  ns\/op\n+        JMHSample_40_InfraParamNormalization.memorizePattern:branch-misses:u            5000  avgt    3   0.011 ±  0.140   #\/op\n+        JMHSample_40_InfraParamNormalization.memorizePattern:branches:u                 5000  avgt    3   1.370 ±  0.024   #\/op\n+        JMHSample_40_InfraParamNormalization.memorizePattern:cycles:u                   5000  avgt    3   1.407 ±  2.656   #\/op\n+        JMHSample_40_InfraParamNormalization.memorizePattern                           10000  avgt   15   1.147 ±  0.127  ns\/op\n+        JMHSample_40_InfraParamNormalization.memorizePattern:branch-misses:u           10000  avgt    3   0.180 ±  0.587   #\/op\n+        JMHSample_40_InfraParamNormalization.memorizePattern:branches:u                10000  avgt    3   1.370 ±  0.073   #\/op\n+        JMHSample_40_InfraParamNormalization.memorizePattern:cycles:u                  10000  avgt    3   5.441 ± 11.936   #\/op\n+        JMHSample_40_InfraParamNormalization.memorizePattern                          100000  avgt   15   2.589 ±  0.011  ns\/op\n+        JMHSample_40_InfraParamNormalization.memorizePattern:branch-misses:u          100000  avgt    3   0.491 ±  0.021   #\/op\n+        JMHSample_40_InfraParamNormalization.memorizePattern:branches:u               100000  avgt    3   1.371 ±  0.024   #\/op\n+        JMHSample_40_InfraParamNormalization.memorizePattern:cycles:u                 100000  avgt    3  12.239 ±  0.450   #\/op\n+     *\/\n+\n+\n+    \/*\n+     * ============================== HOW TO RUN THIS TEST: ====================================\n+     *\n+     * You can run this test:\n+     *\n+     * a) Via the command line:\n+     *    $ mvn clean install\n+     *    $ java -jar .\/target\/benchmarks.jar JMHSample_40_InfraParamNormalization -prof perfnorm -f 3\n+     *\n+     * b) Via the Java API:\n+     *    (see the JMH homepage for possible caveats when running from IDE:\n+     *      http:\/\/openjdk.java.net\/projects\/code-tools\/jmh\/)\n+     *\/\n+    public static void main(String[] args) throws RunnerException {\n+        Options opt = new OptionsBuilder()\n+                .include(\".*\" + JMHSample_40_InfraParamNormalization.class.getSimpleName() + \".*\")\n+                .addProfiler(LinuxPerfNormProfiler.class)\n+                .build();\n+\n+        new Runner(opt).run();\n+    }\n+\n+}\n","filename":"jmh-samples\/src\/main\/java\/org\/openjdk\/jmh\/samples\/JMHSample_40_InfraParamNormalization.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"}]}