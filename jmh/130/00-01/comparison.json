{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import org.junit.Rule;\n@@ -31,1 +30,0 @@\n-import org.junit.rules.TemporaryFolder;\n@@ -46,2 +44,1 @@\n-    @Rule\n-    public TemporaryFolder temporaryFolder = new TemporaryFolder();\n+    private static final File TMP_DIR = new File(System.getProperty(\"java.io.tmpdir\"));\n@@ -113,8 +110,12 @@\n-        File expectedFile = new File(temporaryFolder.getRoot(), \"results.trace\");\n-        Options opts = new OptionsBuilder()\n-                .include(Fixtures.getTestMask(this.getClass()))\n-                .addProfiler(XCTraceAsmProfiler.class,\n-                        \"savePerfBin=true;savePerfBinToFile=\" + expectedFile.getAbsolutePath())\n-                .build();\n-        new Runner(opts).runSingle();\n-        Assert.assertTrue(\"Results were not copied\", expectedFile.isDirectory());\n+        File expectedFile = new File(TMP_DIR, \"results.trace\");\n+        try {\n+            Options opts = new OptionsBuilder()\n+                    .include(Fixtures.getTestMask(this.getClass()))\n+                    .addProfiler(XCTraceAsmProfiler.class,\n+                            \"savePerfBin=true;savePerfBinToFile=\" + expectedFile.getAbsolutePath())\n+                    .build();\n+            new Runner(opts).runSingle();\n+            Assert.assertTrue(\"Results were not copied\", expectedFile.isDirectory());\n+        } finally {\n+            expectedFile.delete();\n+        }\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/profilers\/XCTraceAsmProfilerTest.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.jmh.it.profilers;\n-\n-import org.junit.Assert;\n-import org.junit.Assume;\n-import org.junit.Test;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Warmup;\n-import org.openjdk.jmh.infra.Blackhole;\n-import org.openjdk.jmh.it.Fixtures;\n-import org.openjdk.jmh.profile.ProfilerException;\n-import org.openjdk.jmh.profile.XCTraceAsmProfiler;\n-import org.openjdk.jmh.profile.XCTraceNormProfiler;\n-import org.openjdk.jmh.runner.Runner;\n-import org.openjdk.jmh.runner.RunnerException;\n-import org.openjdk.jmh.runner.options.Options;\n-import org.openjdk.jmh.runner.options.OptionsBuilder;\n-\n-import java.util.concurrent.TimeUnit;\n-\n-@Warmup(iterations = 1, time = 1, timeUnit = TimeUnit.SECONDS)\n-@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n-@Fork(1)\n-public class XCTraceNormProfilerTest {\n-    @Benchmark\n-    public void benchmark() { Blackhole.consumeCPU(10); }\n-\n-    @Test\n-    public void smokeTest() throws RunnerException {\n-        try {\n-            new XCTraceAsmProfiler(\"template=Time Profile\");\n-        } catch (ProfilerException e) {\n-            Assume.assumeTrue(\"Profiler is not supported or cannot be enabled, skipping test\", false);\n-        }\n-\n-        Options opts = new OptionsBuilder()\n-                .include(Fixtures.getTestMask(this.getClass()))\n-                .addProfiler(XCTraceNormProfiler.class,\n-                        \"template=Time Profile\")\n-                .build();\n-        try {\n-            new Runner(opts).runSingle();\n-        } catch (Exception e) {\n-            Assert.assertTrue(e.getMessage().contains(\n-                    \"Table \\\"counters-profile\\\" was not found in the trace results.\"));\n-        }\n-    }\n-}\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/profilers\/XCTraceNormProfilerTest.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -180,1 +180,0 @@\n-        BUILT_IN.put(\"xctracenorm\", XCTraceNormProfiler.class);\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/profile\/ProfilerFactory.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -77,1 +79,1 @@\n-    private String instrument;\n+    private final String instrument;\n@@ -98,0 +100,2 @@\n+            } else {\n+                instrument = null;\n@@ -111,1 +115,4 @@\n-                .withOptionalArg().ofType(String.class).defaultsTo(\"Time Profiler\");\n+                .withOptionalArg()\n+                .describedAs(\"string\")\n+                .ofType(String.class)\n+                .defaultsTo(\"Time Profiler\");\n@@ -115,1 +122,3 @@\n-                .withOptionalArg().ofType(String.class);\n+                .withOptionalArg()\n+                .describedAs(\"string\")\n+                .ofType(String.class);\n@@ -117,1 +126,4 @@\n-                .withRequiredArg().ofType(Boolean.class).defaultsTo(true);\n+                .withRequiredArg()\n+                .describedAs(\"bool\")\n+                .ofType(Boolean.class)\n+                .defaultsTo(true);\n@@ -129,1 +141,1 @@\n-            throw new IllegalStateException(\"Profiling results does not contain table supported by this profiler.\");\n+            throw new IllegalStateException(\"Profiling results does not contain tables supported by this profiler.\");\n@@ -132,0 +144,4 @@\n+            String supportedSchemas = Stream.of(XCTraceTableHandler.ProfilingTableType.values())\n+                    .map(t -> t.tableName)\n+                    .sorted()\n+                    .collect(Collectors.joining(\", \"));\n@@ -133,1 +149,2 @@\n-                    \"please specify which one to use using \\\"table\\\" option\");\n+                    \"please make sure a template you chose produces only a single table with one of the following \" +\n+                    \"schemas: \" + supportedSchemas);\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/profile\/XCTraceAsmProfiler.java","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1,328 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.jmh.profile;\n-\n-import joptsimple.OptionParser;\n-import joptsimple.OptionSet;\n-import joptsimple.OptionSpec;\n-import org.openjdk.jmh.infra.BenchmarkParams;\n-import org.openjdk.jmh.results.*;\n-import org.openjdk.jmh.util.FileUtils;\n-import org.openjdk.jmh.util.TempFile;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.List;\n-\n-\/**\n- * macOS perfnorm profiler based on xctrace utility shipped with Xcode Instruments.\n- * Depending on the chosen tracing configuration, so-called template, xctrace may sample PMU counters\n- * using either timer interrupts, or PMU interrupts.\n- * <p>\n- * The profiling process consists of several steps:\n- * 1) launching a program that needs to be profiled using `xctrace record` command; in case of success,\n- * the output of this step is a \"trace-file\", which is in fact a directory containing multiple files\n- * representing the recorded trace, the trace may contain multiple resulting tables, depending on the template;\n- * 2) inspecting a recorded trace to check if it contains a table supported by the profiler; this information\n- * could be obtained from the trace's table of contents (`xctrace export --toc`);\n- * 3) extracting the table with profiling results from the trace file using `xctrace export` and parsing it\n- * to extract individual samples.\n- * <p>\n- * `xctrace export` extracts data only in XML format, thus both the table of contents and the table\n- * with profiling results need to be parsed as XML documents.\n- * <p>\n- * This profiler currently supports only one table type: counters-profile.\n- * Such tables are generated by the CPU Counters instrument performing sampling either by\n- * timer interrupts, or interrupts generated by a PMU counter, depending on particular configuration.\n- * <p>\n- * Tracing configuration, or template, mentioned earlier is a file that could be configured and saved\n- * using Instruments application. Unfortunately, there is no other way to set it up.\n- * <p>\n- * There's no builtin template that could be used with this profiler, thus the template had to be configured and saved\n- * by a user before running the profiler.\n- * <p>\n- * TODO:\n- * - support other instruments to collect information about virtual memory, context switches, etc.\n- *\/\n-public class XCTraceNormProfiler implements ExternalProfiler {\n-    private static final XCTraceTableHandler.ProfilingTableType SUPPORTED_TABLE_TYPE\n-            = XCTraceTableHandler.ProfilingTableType.COUNTERS_PROFILE;\n-    \/\/ Counter names may vary depending on particular CPU,\n-    \/\/ but these names are the most popular (see files in \/usr\/share\/kpep).\n-    \/\/ On Arm-based CPUs names (in fact, aliases) are usually Instructions and Cycles,\n-    \/\/ on x86-64 CPUs names are usually INST_ALL and ReferenceCycles.\n-    private static final String[] INSTRUCTIONS_COUNTERS = new String[]{\"Instructions\", \"INST_ALL\"};\n-    private static final String[] CYCLES_COUNTERS = new String[]{\"Cycles\", \"ReferenceCycles\", \"CORE_ACTIVE_CYCLE\"};\n-    private final String tracingTemplate;\n-    private final Path temporaryFolder;\n-    private final TempFile outputFile;\n-\n-    private final long delayMs;\n-    private final long lengthMs;\n-    private final boolean shouldFixStartTime;\n-\n-    public XCTraceNormProfiler(String initLine) throws ProfilerException {\n-        OptionParser parser = new OptionParser();\n-        parser.formatHelpWith(new ProfilerOptionFormatter(XCTraceNormProfiler.class.getName()));\n-\n-        OptionSpec<String> templateOpt = parser.accepts(\"template\", \"Name of or path to Instruments template. \" +\n-                        \"Use `xctrace list templates` to view available templates. \" +\n-                        \"Only templates with \\\"CPU Counters\\\" instrument are supported at the moment.\")\n-                .withRequiredArg().ofType(String.class);\n-        OptionSpec<Integer> optDelay = parser.accepts(\"delay\",\n-                        \"Delay collection for a given time, in milliseconds; -1 to detect automatically.\")\n-                .withRequiredArg().ofType(Integer.class).describedAs(\"ms\").defaultsTo(-1);\n-        OptionSpec<Integer> optLength = parser.accepts(\"length\",\n-                        \"Do the collection for a given time, in milliseconds; -1 to detect automatically.\")\n-                .withRequiredArg().ofType(Integer.class).describedAs(\"ms\").defaultsTo(-1);\n-        OptionSpec<Boolean> correctOpt = parser.accepts(\"fixStartTime\",\n-                        \"Fix the start time by the time it took to launch.\")\n-                .withRequiredArg().ofType(Boolean.class).defaultsTo(true);\n-\n-\n-        OptionSet options = ProfilerUtils.parseInitLine(initLine, parser);\n-        tracingTemplate = options.valueOf(templateOpt);\n-        delayMs = options.valueOf(optDelay);\n-        lengthMs = options.valueOf(optLength);\n-        shouldFixStartTime = options.valueOf(correctOpt);\n-\n-        XCTraceSupport.checkXCTraceWorks();\n-\n-        try {\n-            temporaryFolder = XCTraceSupport.createTemporaryDirectoryName();\n-            outputFile = FileUtils.weakTempFile(\"xctrace-out.xml\");\n-        } catch (IOException e) {\n-            throw new ProfilerException(e.getMessage());\n-        }\n-    }\n-\n-    private static XCTraceTableHandler.XCTraceTableDesc findTableDescription(XCTraceTableOfContentsHandler tocHandler) {\n-        XCTraceTableHandler.XCTraceTableDesc tableDesc = tocHandler.getSupportedTables()\n-                .stream()\n-                .filter(t -> t.getTableType() == SUPPORTED_TABLE_TYPE)\n-                .findFirst()\n-                .orElseThrow(() -> new IllegalStateException(\"Table \\\"\" + SUPPORTED_TABLE_TYPE.tableName +\n-                        \"\\\" was not found in the trace results.\"));\n-        if (tableDesc.counters().isEmpty() && tableDesc.getTriggerType() == XCTraceTableHandler.TriggerType.TIME) {\n-            throw new IllegalStateException(\"Results does not contain any events.\");\n-        }\n-        return tableDesc;\n-    }\n-\n-    @Override\n-    public Collection<String> addJVMInvokeOptions(BenchmarkParams params) {\n-        return XCTraceSupport.recordCommandPrefix(temporaryFolder.toAbsolutePath().toString(),\n-                null, tracingTemplate);\n-    }\n-\n-    @Override\n-    public Collection<String> addJVMOptions(BenchmarkParams params) {\n-        return Collections.emptyList();\n-    }\n-\n-    @Override\n-    public void beforeTrial(BenchmarkParams benchmarkParams) {\n-        temporaryFolder.toFile().mkdirs();\n-    }\n-\n-    @Override\n-    public Collection<? extends Result> afterTrial(BenchmarkResult br, long pid, File stdOut, File stdErr) {\n-        try {\n-            return processResults(br);\n-        } finally {\n-            XCTraceSupport.removeDirectory(temporaryFolder);\n-        }\n-    }\n-\n-    private Collection<? extends Result> processResults(BenchmarkResult br) {\n-        BenchmarkResultMetaData md = br.getMetadata();\n-        if (md == null) {\n-            return Collections.emptyList();\n-        }\n-        long measurementsDurationMs = md.getStopTime() - md.getMeasurementTime();\n-        if (measurementsDurationMs == 0L) {\n-            return Collections.emptyList();\n-        }\n-        double opsThroughput = md.getMeasurementOps() \/ (double) measurementsDurationMs;\n-\n-        Path traceFile = XCTraceSupport.findTraceFile(temporaryFolder);\n-        XCTraceSupport.exportTableOfContents(traceFile.toAbsolutePath().toString(), outputFile.getAbsolutePath());\n-\n-        XCTraceTableOfContentsHandler tocHandler = new XCTraceTableOfContentsHandler();\n-        tocHandler.parse(outputFile.file());\n-        XCTraceTableHandler.XCTraceTableDesc tableDesc = findTableDescription(tocHandler);\n-        XCTraceSupport.exportTable(traceFile.toAbsolutePath().toString(), outputFile.getAbsolutePath(),\n-                SUPPORTED_TABLE_TYPE);\n-\n-        \/*\n-         * BenchmarkResultMetaData captures the time when a fork was launched.\n-         * xctrace saves timestamps relative to the start of the tracing process.\n-         * It may take a considerable time to start xctrace (up to several seconds in some cases), so we\n-         * can't directly use measurementDelayMs.\n-         * However, xctrace trace's table of contents contains the timestamp corresponding to\n-         * the actual traced process start time. It could be used to correct measurementDelayMs.\n-         *\n-         *               \/<-- delta -->\/\n-         *              \/             \/\n-         *  time -------|-------------|------------------------------|----------->\n-         *              |             |                              |\n-         *       *fork launched*      |                     *measurements started*\n-         *        getStartTime()      |                      getMeasurementTime()\n-         *                      xctrace started java\n-         *                    tocHandler.getRecordStartMs()\n-         *\/\n-        long timeCorrectionMs = 0;\n-        if (shouldFixStartTime) {\n-            timeCorrectionMs = tocHandler.getRecordStartMs() - md.getStartTime();\n-        }\n-        long skipMs = delayMs;\n-        if (skipMs == -1L) {\n-            skipMs = ProfilerUtils.measurementDelayMs(br);\n-        }\n-        skipMs -= timeCorrectionMs;\n-        long durationMs = lengthMs;\n-        if (durationMs == -1L) {\n-            durationMs = ProfilerUtils.measuredTimeMs(br);\n-        }\n-\n-        long skipNs = skipMs * 1000000;\n-        long durationNs = durationMs * 1000000;\n-\n-        AggregatedEvents aggregator = new AggregatedEvents(tableDesc);\n-        new XCTraceTableProfileHandler(SUPPORTED_TABLE_TYPE, sample -> {\n-            if (sample.getTimeFromStartNs() <= skipNs || sample.getTimeFromStartNs() > skipNs + durationNs) {\n-                return;\n-            }\n-\n-            aggregator.add(sample);\n-        }).parse(outputFile.file());\n-\n-        if (aggregator.eventsCount == 0) {\n-            return Collections.emptyList();\n-        }\n-\n-        Collection<Result<?>> results = new ArrayList<>();\n-        {\n-            Double insts = null;\n-            String instsName = null;\n-            for (String name : INSTRUCTIONS_COUNTERS) {\n-                if ((insts = aggregator.getCountOrNull(name)) != null) {\n-                    instsName = name;\n-                    break;\n-                }\n-            }\n-            Double cycles = null;\n-            String cyclesName = null;\n-            for (String name : CYCLES_COUNTERS) {\n-                if ((cycles = aggregator.getCountOrNull(name)) != null) {\n-                    cyclesName = name;\n-                    break;\n-                }\n-            }\n-            if (insts != null && cycles != null && insts != 0.0 && cycles != 0.0) {\n-                results.add(new ScalarResult(\"CPI\", cycles \/ insts,\n-                        cyclesName + \"\/\" + instsName, AggregationPolicy.AVG));\n-                results.add(new ScalarResult(\"IPC\", insts \/ cycles,\n-                        instsName + \"\/\" + cyclesName, AggregationPolicy.AVG));\n-            }\n-        }\n-\n-        aggregator.normalizeByThroughput(opsThroughput);\n-\n-        for (int i = 0; i < tableDesc.counters().size(); i++) {\n-            String event = tableDesc.counters().get(i);\n-            results.add(new ScalarResult(event, aggregator.eventValues[i],\n-                    \"#\/op\", AggregationPolicy.AVG));\n-        }\n-        if (tableDesc.getTriggerType() == XCTraceTableHandler.TriggerType.PMI) {\n-            results.add(new ScalarResult(tableDesc.triggerEvent(),\n-                    aggregator.eventValues[aggregator.eventValues.length - 1],\n-                    \"#\/op\", AggregationPolicy.AVG));\n-        }\n-        return results;\n-    }\n-\n-    @Override\n-    public boolean allowPrintOut() {\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean allowPrintErr() {\n-        return false;\n-    }\n-\n-    @Override\n-    public String getDescription() {\n-        return \"macOS xctrace (Instruments) PMU counter statistics, normalized by operation count\";\n-    }\n-\n-    private static class AggregatedEvents {\n-        final List<String> eventNames;\n-        final double[] eventValues;\n-        long eventsCount = 0;\n-\n-        long minTimestampMs = Long.MAX_VALUE;\n-        long maxTimestampMs = Long.MIN_VALUE;\n-\n-        public AggregatedEvents(XCTraceTableHandler.XCTraceTableDesc tableDesc) {\n-            List<String> names = new ArrayList<>(tableDesc.counters());\n-            names.add(tableDesc.triggerEvent());\n-            eventNames = Collections.unmodifiableList(names);\n-            eventValues = new double[eventNames.size()];\n-        }\n-\n-        void add(XCTraceTableProfileHandler.XCTraceSample sample) {\n-            long[] counters = sample.getPmcCounters();\n-            for (int i = 0; i < counters.length; i++) {\n-                eventValues[i] += counters[i];\n-            }\n-            eventValues[eventValues.length - 1] = sample.getWeight();\n-            minTimestampMs = Math.min(minTimestampMs, sample.getTimeFromStartNs());\n-            maxTimestampMs = Math.max(maxTimestampMs, sample.getTimeFromStartNs());\n-            eventsCount++;\n-        }\n-\n-        void normalizeByThroughput(double throughput) {\n-            if (maxTimestampMs == minTimestampMs) {\n-                throw new IllegalStateException(\"Min and max timestamps are the same.\");\n-            }\n-            double timeSpanMs = (maxTimestampMs - minTimestampMs) \/ 1e6;\n-            for (int i = 0; i < eventValues.length; i++) {\n-                eventValues[i] = eventValues[i] \/ timeSpanMs \/ throughput;\n-            }\n-        }\n-\n-        Double getCountOrNull(String event) {\n-            int idx = eventNames.indexOf(event);\n-            if (idx == -1) return null;\n-            return eventValues[idx];\n-        }\n-    }\n-}\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/profile\/XCTraceNormProfiler.java","additions":0,"deletions":328,"binary":false,"changes":328,"status":"deleted"},{"patch":"@@ -52,1 +52,0 @@\n-    static final String PMC_EVENTS = \"pmc-events\";\n@@ -125,1 +124,0 @@\n-        private final List<String> counters;\n@@ -130,1 +128,1 @@\n-                         List<String> counters, String trigger, long threshold) {\n+                         String trigger, long threshold) {\n@@ -133,1 +131,0 @@\n-            this.counters = counters;\n@@ -139,1 +136,1 @@\n-            this(tableType, XCTraceTableHandler.TriggerType.UNKNOWN, Collections.emptyList(), \"\", -1);\n+            this(tableType, XCTraceTableHandler.TriggerType.UNKNOWN, \"\", -1);\n@@ -150,4 +147,0 @@\n-        public List<String> counters() {\n-            return counters;\n-        }\n-\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/profile\/XCTraceTableHandler.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.stream.Collectors;\n@@ -47,11 +46,0 @@\n-    private static List<String> parseEvents(Attributes attributes) {\n-        String events = attributes.getValue(XCTraceTableHandler.PMC_EVENTS);\n-        \/\/ TODO: support names with whitespaces inside\n-        return Arrays.stream(events.split(\" \")).map(e -> {\n-                    if (!e.startsWith(\"\\\"\") && !e.endsWith(\"\\\"\")) return e;\n-                    if (e.startsWith(\"\\\"\") && e.endsWith(\"\\\"\")) return e.substring(1, e.length() - 1);\n-                    throw new IllegalStateException(\"Can't parse pmc-events: \" + events);\n-                }).filter(e -> !e.isEmpty())\n-                .collect(Collectors.toList());\n-    }\n-\n@@ -119,1 +107,1 @@\n-                parseEvents(attributes), pmiEvent, threshold);\n+                pmiEvent, threshold);\n@@ -127,1 +115,1 @@\n-                parseEvents(attributes), XCTraceTableProfileHandler.XCTraceSample.TIME_SAMPLE_TRIGGER_NAME, threshold);\n+                XCTraceTableProfileHandler.XCTraceSample.TIME_SAMPLE_TRIGGER_NAME, threshold);\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/profile\/XCTraceTableOfContentsHandler.java","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -202,6 +202,0 @@\n-            case XCTraceTableHandler.PMC_EVENTS:\n-                pushCachedOrNew(attributes, id -> {\n-                    setNeedParseCharacters(true);\n-                    return new ValueHolder<long[]>(id);\n-                });\n-                break;\n@@ -249,4 +243,0 @@\n-            case XCTraceTableHandler.PMC_EVENTS:\n-                ValueHolder<long[]> events = popAndUpdateEvents();\n-                currentSample.setPmcCounters(events.value);\n-                break;\n@@ -339,8 +329,0 @@\n-        public long[] getPmcCounters() {\n-            return samples;\n-        }\n-\n-        public void setPmcCounters(long[] samples) {\n-            this.samples = samples;\n-        }\n-\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/profile\/XCTraceTableProfileHandler.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -57,3 +57,0 @@\n-        assertEquals(Arrays.asList(\n-                \"L1D_CACHE_MISS_LD\", \"MEM_LOAD_RETIRED.L1_HIT\"\n-        ), table.counters());\n@@ -75,3 +72,0 @@\n-        assertEquals(Arrays.asList(\n-                \"INST_ALL\", \"CORE_ACTIVE_CYCLE\", \"INST_BRANCH\"\n-        ), table.counters());\n","filename":"jmh-core\/src\/test\/java\/org\/openjdk\/jmh\/profile\/XCTraceTableOfContentsHandlerTest.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -99,2 +99,0 @@\n-        assertArrayEquals(\"PMC-counters for row \" + rowIndex,\n-                (long[]) expectedRow[5], actualRow.getPmcCounters());\n","filename":"jmh-core\/src\/test\/java\/org\/openjdk\/jmh\/profile\/XCTraceTableProfileHandlerTest.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}