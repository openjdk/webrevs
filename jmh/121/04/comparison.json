{"files":[{"patch":"@@ -41,0 +41,5 @@\n+    - name: Set up async-profiler (Linux)\n+      run: |\n+        curl -L https:\/\/github.com\/async-profiler\/async-profiler\/releases\/download\/v3.0\/async-profiler-3.0-linux-x64.tar.gz | tar xzf -\n+        echo \"LD_LIBRARY_PATH=$LD_LIBRARY_PATH:`pwd`\/async-profiler-3.0-linux-x64\/lib\/\" >> $GITHUB_ENV\n+      if: (runner.os == 'Linux')\n","filename":".github\/workflows\/pre-integration.yml","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jmh.it.profilers;\n+\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Test;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.it.Fixtures;\n+import org.openjdk.jmh.profile.AsyncProfiler;\n+import org.openjdk.jmh.profile.ProfilerException;\n+import org.openjdk.jmh.results.Result;\n+import org.openjdk.jmh.results.RunResult;\n+import org.openjdk.jmh.results.TextResult;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.io.File;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+@Fork(2)\n+public class AsyncProfilerForkTest extends AbstractHotspotProfilerTest {\n+\n+    private Map<String, Result> run(String mode) throws RunnerException {\n+        try {\n+            new AsyncProfiler(\"\");\n+        } catch (ProfilerException e) {\n+            Assume.assumeNoException(\"Could not load async-profiler\", e);\n+        }\n+\n+        Options opts = new OptionsBuilder()\n+                .include(Fixtures.getTestMask(this.getClass()))\n+                .addProfiler(AsyncProfiler.class, \"output=\" + mode)\n+                .build();\n+\n+        RunResult rr = new Runner(opts).runSingle();\n+\n+        return rr.getSecondaryResults();\n+    }\n+\n+    @Test\n+    public void text() throws RunnerException {\n+        Map<String, Result> sr = run(\"text\");\n+\n+        Collection<? extends File> files = ((AsyncProfiler.FileResult) sr.get(\"async-summary\")).getFiles();\n+        Assert.assertEquals(3, files.size());\n+        for (File file : files) {\n+            Assert.assertTrue(file.length() > 10);\n+        }\n+\n+        TextResult text = (TextResult) sr.get(\"async-text\");\n+        Assert.assertTrue(text.extendedInfo().length() > 10);\n+    }\n+\n+    @Test\n+    public void collapsed() throws RunnerException {\n+        Map<String, Result> sr = run(\"collapsed\");\n+\n+        Collection<? extends File> files = ((AsyncProfiler.FileResult) sr.get(\"async-collapsed\")).getFiles();\n+        Assert.assertEquals(3, files.size());\n+        for (File file : files) {\n+            Assert.assertTrue(file.length() > 10);\n+        }\n+    }\n+\n+    @Test\n+    public void flamegraph() throws RunnerException {\n+        Map<String, Result> sr = run(\"flamegraph\");\n+\n+        Collection<? extends File> files = ((AsyncProfiler.FileResult) sr.get(\"async-flamegraph\")).getFiles();\n+        Assert.assertEquals(6, files.size());\n+        for (File file : files) {\n+            Assert.assertTrue(file.length() > 10);\n+        }\n+    }\n+\n+    @Test\n+    public void jfr() throws RunnerException {\n+        Map<String, Result> sr = run(\"jfr\");\n+        Collection<? extends File> files = ((AsyncProfiler.FileResult) sr.get(\"async-jfr\")).getFiles();\n+        Assert.assertEquals(3, files.size());\n+        for (File file : files) {\n+            Assert.assertTrue(file.length() > 10);\n+        }\n+    }\n+}\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/profilers\/AsyncProfilerForkTest.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.jmh.it.profilers;\n+\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Test;\n+import org.openjdk.jmh.it.Fixtures;\n+import org.openjdk.jmh.profile.AsyncProfiler;\n+import org.openjdk.jmh.profile.ProfilerException;\n+import org.openjdk.jmh.results.Result;\n+import org.openjdk.jmh.results.RunResult;\n+import org.openjdk.jmh.results.TextResult;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+\n+import java.io.File;\n+import java.util.Collection;\n+import java.util.Map;\n+\n+public class AsyncProfilerTest extends AbstractHotspotProfilerTest {\n+\n+    private Map<String, Result> run(String mode) throws RunnerException {\n+        try {\n+            new AsyncProfiler(\"\");\n+        } catch (ProfilerException e) {\n+            Assume.assumeNoException(\"Could not load async-profiler\", e);\n+        }\n+\n+        Options opts = new OptionsBuilder()\n+                .include(Fixtures.getTestMask(this.getClass()))\n+                .addProfiler(AsyncProfiler.class, \"output=\" + mode)\n+                .build();\n+\n+        RunResult rr = new Runner(opts).runSingle();\n+\n+        return rr.getSecondaryResults();\n+    }\n+\n+    @Test\n+    public void text() throws RunnerException {\n+        Map<String, Result> sr = run(\"text\");\n+\n+        Collection<? extends File> files = ((AsyncProfiler.FileResult) sr.get(\"async-summary\")).getFiles();\n+        Assert.assertEquals(1, files.size());\n+        File single = files.iterator().next();\n+        Assert.assertTrue(single.length() > 10);\n+\n+        TextResult text = (TextResult) sr.get(\"async-text\");\n+        Assert.assertTrue(text.extendedInfo().length() > 10);\n+    }\n+\n+    @Test\n+    public void collapsed() throws RunnerException {\n+        Map<String, Result> sr = run(\"collapsed\");\n+\n+        Collection<? extends File> files = ((AsyncProfiler.FileResult) sr.get(\"async-collapsed\")).getFiles();\n+        Assert.assertEquals(1, files.size());\n+        File single = files.iterator().next();\n+        Assert.assertTrue(single.length() > 10);\n+    }\n+\n+    @Test\n+    public void flamegraph() throws RunnerException {\n+        Map<String, Result> sr = run(\"flamegraph\");\n+\n+        Collection<? extends File> files = ((AsyncProfiler.FileResult) sr.get(\"async-flamegraph\")).getFiles();\n+        Assert.assertEquals(2, files.size());\n+        for (File file : files) {\n+            Assert.assertTrue(file.length() > 10);\n+        }\n+    }\n+\n+    @Test\n+    public void jfr() throws RunnerException {\n+        Map<String, Result> sr = run(\"jfr\");\n+        Collection<? extends File> files = ((AsyncProfiler.FileResult) sr.get(\"async-jfr\")).getFiles();\n+        Assert.assertEquals(1, files.size());\n+        File single = files.iterator().next();\n+        Assert.assertTrue(single.length() > 10);\n+    }\n+}\n","filename":"jmh-core-it\/src\/test\/java\/org\/openjdk\/jmh\/it\/profilers\/AsyncProfilerTest.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -33,0 +33,2 @@\n+import org.openjdk.jmh.results.AggregationPolicy;\n+import org.openjdk.jmh.results.Aggregator;\n@@ -36,0 +38,1 @@\n+import org.openjdk.jmh.results.ResultRole;\n@@ -42,3 +45,13 @@\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.util.*;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.StandardCopyOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n@@ -71,1 +84,0 @@\n-    private final LinkedHashSet<File> generated = new LinkedHashSet<>();\n@@ -334,1 +346,1 @@\n-            execute(\"start,\" + profilerConfig + \",file=\" + outputFile(\"jfr-%s.jfr\").getAbsolutePath());\n+            execute(\"start,\" + profilerConfig + \",file=\" + jfrOutputFile().getAbsolutePath());\n@@ -346,1 +358,1 @@\n-                return Collections.singletonList(stopAndDump());\n+                return stopAndDump();\n@@ -363,1 +375,1 @@\n-    private TextResult stopAndDump() {\n+    private List<Result<?>> stopAndDump() {\n@@ -366,2 +378,1 @@\n-        StringWriter sw = new StringWriter();\n-        PrintWriter pw = new PrintWriter(sw);\n+        List<Result<?>> results = new ArrayList<>();\n@@ -378,0 +389,1 @@\n+                        StringBuilder text = new StringBuilder();\n@@ -379,1 +391,1 @@\n-                            pw.println(line);\n+                            text.append(line).append(System.lineSeparator());\n@@ -381,0 +393,1 @@\n+                        results.add(new TextResult(text.toString(), \"async-text\"));\n@@ -384,0 +397,1 @@\n+                    results.add(new FileResult(\"async-summary\", Collections.singletonList(out)));\n@@ -386,1 +400,3 @@\n-                    dump(outputFile(\"collapsed-%s.csv\"), \"collapsed\");\n+                    File collapsedFile = outputFile(\"collapsed-%s.csv\");\n+                    dump(collapsedFile, \"collapsed\");\n+                    results.add(new FileResult(\"async-collapsed\", Collections.singletonList(collapsedFile)));\n@@ -392,1 +408,3 @@\n-                        dump(outputFile(\"flame-%s-forward.\" + ext), \"flamegraph\");\n+                        File flameForward = outputFile(\"flame-%s-forward.\" + ext);\n+                        dump(flameForward, \"flamegraph\");\n+                        results.add(new FileResult(\"async-flamegraph\", Collections.singletonList(flameForward)));\n@@ -395,1 +413,3 @@\n-                        dump(outputFile(\"flame-%s-reverse.\" + ext), \"flamegraph,reverse\");\n+                        File flameReverse = outputFile(\"flame-%s-reverse.\" + ext);\n+                        dump(flameReverse, \"flamegraph,reverse\");\n+                        results.add(new FileResult(\"async-flamegraph\", Collections.singletonList(flameReverse)));\n@@ -399,1 +419,3 @@\n-                    dump(outputFile(\"tree-%s.html\"), \"tree\");\n+                    File treeFile = outputFile(\"tree-%s.html\");\n+                    dump(treeFile, \"tree\");\n+                    results.add(new FileResult(\"async-tree\", Collections.singletonList(treeFile)));\n@@ -403,0 +425,1 @@\n+                    results.add(new FileResult(\"async-jfr\", Collections.singletonList(jfrOutputFile())));\n@@ -407,9 +430,1 @@\n-        pw.println(\"Async profiler results:\");\n-        for (File file : generated) {\n-            pw.print(\"  \");\n-            pw.println(file.getPath());\n-        }\n-        pw.flush();\n-        pw.close();\n-\n-        return new TextResult(sw.toString(), \"async\");\n+        return results;\n@@ -422,0 +437,4 @@\n+    private File jfrOutputFile() {\n+        return outputFile(\"jfr-%s.jfr\");\n+    }\n+\n@@ -423,3 +442,1 @@\n-        File output = new File(trialOutDir, String.format(fileNameFormat, outputFilePrefix));\n-        generated.add(output);\n-        return output;\n+        return new File(trialOutDir, String.format(fileNameFormat, outputFilePrefix));\n@@ -538,1 +555,22 @@\n-        return Collections.emptyList();\n+        List<FileResult> moved = new ArrayList<>();\n+        for (String label : Arrays.asList(\"async-summary\", \"async-collapsed\", \"async-flamegraph\", \"async-tree\", \"async-jfr\")) {\n+            FileResult result = (FileResult) br.getSecondaryResults().remove(label);\n+            if (result != null) {\n+                moved.add(new FileResult(result.getLabel(), result.files.stream()\n+                        .flatMap(f -> Stream.of(f, addDiscriminator(f, pid)))\n+                        .collect(Collectors.toList())));\n+            }\n+        }\n+        return moved;\n+    }\n+\n+    private File addDiscriminator(File original, long pid) {\n+        String originalName = original.getPath();\n+        int extIndex = originalName.lastIndexOf('.');\n+        File newFile = new File(originalName.substring(0, extIndex) + \".\" + pid + originalName.substring(extIndex));\n+        try {\n+            Files.copy(original.toPath(), newFile.toPath(), StandardCopyOption.REPLACE_EXISTING);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        return newFile;\n@@ -625,0 +663,47 @@\n+\n+    public final static class FileResult extends Result<FileResult> {\n+        private final List<File> files;\n+\n+        FileResult(String label, List<File> files) {\n+            super(ResultRole.SECONDARY, label, of(Double.NaN), \"---\", AggregationPolicy.AVG);\n+            this.files = files;\n+        }\n+\n+        @Override\n+        protected Aggregator<FileResult> getThreadAggregator() {\n+            return new FileAggregator();\n+        }\n+\n+        @Override\n+        protected Aggregator<FileResult> getIterationAggregator() {\n+            return new FileAggregator();\n+        }\n+\n+        public Collection<? extends File> getFiles() {\n+            return files;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Files: \" + files;\n+        }\n+\n+        @Override\n+        public String extendedInfo() {\n+            StringBuilder builder = new StringBuilder(\"Async profiler results:\").append(System.lineSeparator());\n+            for (File file : files) {\n+                builder.append(\"  \").append(file.getPath()).append(System.lineSeparator());\n+            }\n+            return builder.toString();\n+        }\n+\n+        private static class FileAggregator implements Aggregator<FileResult> {\n+            @Override\n+            public FileResult aggregate(Collection<FileResult> results) {\n+                return new FileResult(results.iterator().next().getLabel(), results.stream()\n+                        .flatMap(r -> r.files.stream())\n+                        .distinct()\n+                        .collect(Collectors.toList()));\n+            }\n+        }\n+    }\n","filename":"jmh-core\/src\/main\/java\/org\/openjdk\/jmh\/profile\/AsyncProfiler.java","additions":112,"deletions":27,"binary":false,"changes":139,"status":"modified"}]}