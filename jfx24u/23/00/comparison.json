{"files":[{"patch":"@@ -3,1 +3,1 @@\n-** version 3.45.3.  By combining all the individual C code files into this\n+** version 3.49.1.  By combining all the individual C code files into this\n@@ -21,1 +21,3 @@\n-** 8653b758870e6ef0c98d46b3ace27849054a.\n+** 873d4e274b4988d260ba8354a9718324a1c2 with changes in files:\n+**\n+**\n@@ -23,0 +25,1 @@\n+#ifndef SQLITE_AMALGAMATION\n@@ -259,4 +262,7 @@\n-#if GCC_VERSION>=7000000\n-# define deliberate_fall_through __attribute__((fallthrough));\n-#else\n-# define deliberate_fall_through\n+#if defined(__has_attribute)\n+#  if __has_attribute(fallthrough)\n+#    define deliberate_fall_through __attribute__((fallthrough));\n+#  endif\n+#endif\n+#if !defined(deliberate_fall_through)\n+#  define deliberate_fall_through\n@@ -462,3 +468,3 @@\n-#define SQLITE_VERSION        \"3.45.3\"\n-#define SQLITE_VERSION_NUMBER 3045003\n-#define SQLITE_SOURCE_ID      \"2024-04-15 13:34:05 8653b758870e6ef0c98d46b3ace27849054af85da891eb121e9aaa537f1e8355\"\n+#define SQLITE_VERSION        \"3.49.1\"\n+#define SQLITE_VERSION_NUMBER 3049001\n+#define SQLITE_SOURCE_ID      \"2025-02-18 13:38:58 873d4e274b4988d260ba8354a9718324a1c26187a4ab4c1cc0227c03d0f10e70\"\n@@ -968,0 +974,7 @@\n+**\n+** The SQLITE_IOCAP_SUBPAGE_READ property means that it is ok to read\n+** from the database file in amounts that are not a multiple of the\n+** page size and that do not begin at a page boundary.  Without this\n+** property, SQLite is careful to only do full-page reads and write\n+** on aligned pages, with the one exception that it will do a sub-page\n+** read of the first page to access the database header.\n@@ -984,0 +997,1 @@\n+#define SQLITE_IOCAP_SUBPAGE_READ           0x00008000\n@@ -1080,1 +1094,1 @@\n-** xLock() is always on of SHARED, RESERVED, PENDING, or EXCLUSIVE, never\n+** xLock() is always one of SHARED, RESERVED, PENDING, or EXCLUSIVE, never\n@@ -1084,1 +1098,1 @@\n-*  If the lock is already at or below the requested lock state, then the call\n+** If the lock is already at or below the requested lock state, then the call\n@@ -1088,2 +1102,2 @@\n-** PENDING, or EXCLUSIVE lock on the file.  It returns true\n-** if such a lock exists and false otherwise.\n+** PENDING, or EXCLUSIVE lock on the file.  It returns, via its output\n+** pointer parameter, true if such a lock exists and false otherwise.\n@@ -1130,0 +1144,1 @@\n+** <li> [SQLITE_IOCAP_SUBPAGE_READ]\n@@ -1407,0 +1422,5 @@\n+** <li>[[SQLITE_FCNTL_NULL_IO]]\n+** The [SQLITE_FCNTL_NULL_IO] opcode sets the low-level file descriptor\n+** or file handle for the [sqlite3_file] object such that it will no longer\n+** read or write to the database file.\n+**\n@@ -1560,0 +1580,1 @@\n+#define SQLITE_FCNTL_NULL_IO                43\n@@ -2512,1 +2533,9 @@\n-** can be passed as the second argument to the [sqlite3_db_config()] interface.\n+** can be passed as the second parameter to the [sqlite3_db_config()] interface.\n+**\n+** The [sqlite3_db_config()] interface is a var-args functions.  It takes a\n+** variable number of parameters, though always at least two.  The number of\n+** parameters passed into sqlite3_db_config() depends on which of these\n+** constants is given as the second parameter.  This documentation page\n+** refers to parameters beyond the second as \"arguments\".  Thus, when this\n+** page says \"the N-th argument\" it means \"the N-th parameter past the\n+** configuration option\" or \"the (N+2)-th parameter to sqlite3_db_config()\".\n@@ -2524,2 +2553,8 @@\n-** <dd> ^This option takes three additional arguments that determine the\n-** [lookaside memory allocator] configuration for the [database connection].\n+** <dd> The SQLITE_DBCONFIG_LOOKASIDE option is used to adjust the\n+** configuration of the lookaside memory allocator within a database\n+** connection.\n+** The arguments to the SQLITE_DBCONFIG_LOOKASIDE option are <i>not<\/i>\n+** in the [DBCONFIG arguments|usual format].\n+** The SQLITE_DBCONFIG_LOOKASIDE option takes three arguments, not two,\n+** so that a call to [sqlite3_db_config()] that uses SQLITE_DBCONFIG_LOOKASIDE\n+** should have a total of five parameters.\n@@ -2548,1 +2583,2 @@\n-** [foreign key constraints].  There should be two additional arguments.\n+** [foreign key constraints].  This is the same setting that is\n+** enabled or disabled by the [PRAGMA foreign_keys] statement.\n@@ -2570,1 +2606,1 @@\n-** triggers in the main database schema or in the schemas of ATTACH-ed\n+** triggers in the main database schema or in the schemas of [ATTACH]-ed\n@@ -2576,1 +2612,1 @@\n-** There should be two additional arguments.\n+** There must be two additional arguments.\n@@ -2595,1 +2631,1 @@\n-** There should be two additional arguments.\n+** There must be two additional arguments.\n@@ -2610,1 +2646,1 @@\n-** There should be two additional arguments.\n+** There must be two additional arguments.\n@@ -2624,5 +2660,9 @@\n-** schema.  ^The sole argument is a pointer to a constant UTF8 string\n-** which will become the new schema name in place of \"main\".  ^SQLite\n-** does not make a copy of the new main schema name string, so the application\n-** must ensure that the argument passed into this DBCONFIG option is unchanged\n-** until after the database connection closes.\n+** schema.  This option does not follow the\n+** [DBCONFIG arguments|usual SQLITE_DBCONFIG argument format].\n+** This option takes exactly one additional argument so that the\n+** [sqlite3_db_config()] call has a total of three parameters.  The\n+** extra argument must be a pointer to a constant UTF8 string which\n+** will become the new schema name in place of \"main\".  ^SQLite does\n+** not make a copy of the new main schema name string, so the application\n+** must ensure that the argument passed into SQLITE_DBCONFIG MAINDBNAME\n+** is unchanged until after the database connection closes.\n@@ -2633,8 +2673,11 @@\n-** <dd> Usually, when a database in wal mode is closed or detached from a\n-** database handle, SQLite checks if this will mean that there are now no\n-** connections at all to the database. If so, it performs a checkpoint\n-** operation before closing the connection. This option may be used to\n-** override this behavior. The first parameter passed to this operation\n-** is an integer - positive to disable checkpoints-on-close, or zero (the\n-** default) to enable them, and negative to leave the setting unchanged.\n-** The second parameter is a pointer to an integer\n+** <dd> Usually, when a database in [WAL mode] is closed or detached from a\n+** database handle, SQLite checks if if there are other connections to the\n+** same database, and if there are no other database connection (if the\n+** connection being closed is the last open connection to the database),\n+** then SQLite performs a [checkpoint] before closing the connection and\n+** deletes the WAL file.  The SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE option can\n+** be used to override that behavior. The first argument passed to this\n+** operation (the third parameter to [sqlite3_db_config()]) is an integer\n+** which is positive to disable checkpoints-on-close, or zero (the default)\n+** to enable them, and negative to leave the setting unchanged.\n+** The second argument (the fourth parameter) is a pointer to an integer\n@@ -2801,1 +2844,1 @@\n-** by default.  This option takes two arguments: an integer and a pointer to\n+** by default. <p>This option takes two arguments: an integer and a pointer to\n@@ -2815,1 +2858,1 @@\n-** same as setting [PRAGMA reverse_unordered_selects].  This option takes\n+** same as setting [PRAGMA reverse_unordered_selects]. <p>This option takes\n@@ -2824,0 +2867,50 @@\n+** [[SQLITE_DBCONFIG_ENABLE_ATTACH_CREATE]]\n+** <dt>SQLITE_DBCONFIG_ENABLE_ATTACH_CREATE<\/dt>\n+** <dd>The SQLITE_DBCONFIG_ENABLE_ATTACH_CREATE option enables or disables\n+** the ability of the [ATTACH DATABASE] SQL command to create a new database\n+** file if the database filed named in the ATTACH command does not already\n+** exist.  This ability of ATTACH to create a new database is enabled by\n+** default.  Applications can disable or reenable the ability for ATTACH to\n+** create new database files using this DBCONFIG option.<p>\n+** This option takes two arguments which are an integer and a pointer\n+** to an integer.  The first argument is 1, 0, or -1 to enable, disable, or\n+** leave unchanged the attach-create flag, respectively.  If the second\n+** argument is not NULL, then 0 or 1 is written into the integer that the\n+** second argument points to depending on if the attach-create flag is set\n+** after processing the first argument.\n+** <\/dd>\n+**\n+** [[SQLITE_DBCONFIG_ENABLE_ATTACH_WRITE]]\n+** <dt>SQLITE_DBCONFIG_ENABLE_ATTACH_WRITE<\/dt>\n+** <dd>The SQLITE_DBCONFIG_ENABLE_ATTACH_WRITE option enables or disables the\n+** ability of the [ATTACH DATABASE] SQL command to open a database for writing.\n+** This capability is enabled by default.  Applications can disable or\n+** reenable this capability using the current DBCONFIG option.  If the\n+** the this capability is disabled, the [ATTACH] command will still work,\n+** but the database will be opened read-only.  If this option is disabled,\n+** then the ability to create a new database using [ATTACH] is also disabled,\n+** regardless of the value of the [SQLITE_DBCONFIG_ENABLE_ATTACH_CREATE]\n+** option.<p>\n+** This option takes two arguments which are an integer and a pointer\n+** to an integer.  The first argument is 1, 0, or -1 to enable, disable, or\n+** leave unchanged the ability to ATTACH another database for writing,\n+** respectively.  If the second argument is not NULL, then 0 or 1 is written\n+** into the integer to which the second argument points, depending on whether\n+** the ability to ATTACH a read\/write database is enabled or disabled\n+** after processing the first argument.\n+** <\/dd>\n+**\n+** [[SQLITE_DBCONFIG_ENABLE_COMMENTS]]\n+** <dt>SQLITE_DBCONFIG_ENABLE_COMMENTS<\/dt>\n+** <dd>The SQLITE_DBCONFIG_ENABLE_COMMENTS option enables or disables the\n+** ability to include comments in SQL text.  Comments are enabled by default.\n+** An application can disable or reenable comments in SQL text using this\n+** DBCONFIG option.<p>\n+** This option takes two arguments which are an integer and a pointer\n+** to an integer.  The first argument is 1, 0, or -1 to enable, disable, or\n+** leave unchanged the ability to use comments in SQL text,\n+** respectively.  If the second argument is not NULL, then 0 or 1 is written\n+** into the integer that the second argument points to depending on if\n+** comments are allowed in SQL text after processing the first argument.\n+** <\/dd>\n+**\n@@ -2825,0 +2918,19 @@\n+**\n+** [[DBCONFIG arguments]] <h3>Arguments To SQLITE_DBCONFIG Options<\/h3>\n+**\n+** <p>Most of the SQLITE_DBCONFIG options take two arguments, so that the\n+** overall call to [sqlite3_db_config()] has a total of four parameters.\n+** The first argument (the third parameter to sqlite3_db_config()) is a integer.\n+** The second argument is a pointer to an integer.  If the first argument is 1,\n+** then the option becomes enabled.  If the first integer argument is 0, then the\n+** option is disabled.  If the first argument is -1, then the option setting\n+** is unchanged.  The second argument, the pointer to an integer, may be NULL.\n+** If the second argument is not NULL, then a value of 0 or 1 is written into\n+** the integer to which the second argument points, depending on whether the\n+** setting is disabled or enabled after applying any changes specified by\n+** the first argument.\n+**\n+** <p>While most SQLITE_DBCONFIG options use the argument format\n+** described in the previous paragraph, the [SQLITE_DBCONFIG_MAINDBNAME]\n+** and [SQLITE_DBCONFIG_LOOKASIDE] options are different.  See the\n+** documentation of those exceptional options for details.\n@@ -2846,1 +2958,4 @@\n-#define SQLITE_DBCONFIG_MAX                   1019 \/* Largest DBCONFIG *\/\n+#define SQLITE_DBCONFIG_ENABLE_ATTACH_CREATE  1020 \/* int int* *\/\n+#define SQLITE_DBCONFIG_ENABLE_ATTACH_WRITE   1021 \/* int int* *\/\n+#define SQLITE_DBCONFIG_ENABLE_COMMENTS       1022 \/* int int* *\/\n+#define SQLITE_DBCONFIG_MAX                   1022 \/* Largest DBCONFIG *\/\n@@ -2938,1 +3053,1 @@\n-** and that if the number of rows modified by the most recent INSERT, UPDATE\n+** and that if the number of rows modified by the most recent INSERT, UPDATE,\n@@ -2942,0 +3057,4 @@\n+** For the purposes of this interface, a CREATE TABLE AS SELECT statement\n+** does not count as an INSERT, UPDATE or DELETE statement and hence the rows\n+** added to the new table by the CREATE TABLE AS SELECT statement are not\n+** counted.\n@@ -3621,2 +3740,2 @@\n-** CAPI3REF: Tracing And Profiling Functions\n-** METHOD: sqlite3\n+** CAPI3REF: Deprecated Tracing And Profiling Functions\n+** DEPRECATED\n@@ -3886,2 +4005,2 @@\n-** In other words, the database behaves has if\n-** [sqlite3_extended_result_codes(db,1)] where called on the database\n+** In other words, the database behaves as if\n+** [sqlite3_extended_result_codes(db,1)] were called on the database\n@@ -4501,0 +4620,10 @@\n+**\n+** [[SQLITE_PREPARE_DONT_LOG]] <dt>SQLITE_PREPARE_DONT_LOG<\/dt>\n+** <dd>The SQLITE_PREPARE_DONT_LOG flag prevents SQL compiler\n+** errors from being sent to the error log defined by\n+** [SQLITE_CONFIG_LOG].  This can be used, for example, to do test\n+** compiles to see if some SQL syntax is well-formed, without generating\n+** messages on the global error log when it is not.  If the test compile\n+** fails, the sqlite3_prepare_v3() call returns the same error indications\n+** with or without this flag; it just omits the call to [sqlite3_log()] that\n+** logs the error.\n@@ -4506,0 +4635,1 @@\n+#define SQLITE_PREPARE_DONT_LOG                0x10\n@@ -4538,2 +4668,4 @@\n-** first zero terminator. ^If nByte is positive, then it is the\n-** number of bytes read from zSql.  ^If nByte is zero, then no prepared\n+** first zero terminator. ^If nByte is positive, then it is the maximum\n+** number of bytes read from zSql.  When nByte is positive, zSql is read\n+** up to the first zero terminator or until the nByte bytes have been read,\n+** whichever comes first.  ^If nByte is zero, then no prepared\n@@ -4545,0 +4677,2 @@\n+** Note that nByte measure the length of the input in bytes, not\n+** characters, even for the UTF-16 interfaces.\n@@ -5915,1 +6049,1 @@\n-** SQL functions that invokes [sqlite3_value_subtype()] should have this\n+** All SQL functions that invoke [sqlite3_value_subtype()] should have this\n@@ -5931,0 +6065,9 @@\n+**\n+** [[SQLITE_SELFORDER1]] <dt>SQLITE_SELFORDER1<\/dt><dd>\n+** The SQLITE_SELFORDER1 flag indicates that the function is an aggregate\n+** that internally orders the values provided to the first argument.  The\n+** ordered-set aggregate SQL notation with a single ORDER BY term can be\n+** used to invoke this function.  If the ordered-set aggregate notation is\n+** used on a function that lacks this flag, then an error is raised. Note\n+** that the ordered-set aggregate syntax is only available if SQLite is\n+** built using the -DSQLITE_ENABLE_ORDERED_SET_AGGREGATES compile-time option.\n@@ -5939,0 +6082,1 @@\n+#define SQLITE_SELFORDER1       0x002000000\n@@ -6136,1 +6280,1 @@\n-** Every [application-defined SQL function] that invoke this interface\n+** Every [application-defined SQL function] that invokes this interface\n@@ -7203,0 +7347,6 @@\n+** Whether the update hook is invoked before or after the\n+** corresponding change is currently unspecified and may differ\n+** depending on the type of change. Do not rely on the order of the\n+** hook call with regards to the final result of the operation which\n+** triggers the hook.\n+**\n@@ -7737,3 +7887,5 @@\n-** mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -\n-** SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite\n-** assumes that the strategy may visit at most one row.\n+** mask of SQLITE_INDEX_SCAN_* flags. One such flag is\n+** [SQLITE_INDEX_SCAN_HEX], which if set causes the [EXPLAIN QUERY PLAN]\n+** output to show the idxNum has hex instead of as decimal.  Another flag is\n+** SQLITE_INDEX_SCAN_UNIQUE, which if set indicates that the query plan will\n+** return at most one row.\n@@ -7803,1 +7955,3 @@\n-#define SQLITE_INDEX_SCAN_UNIQUE      1     \/* Scan visits at most 1 row *\/\n+#define SQLITE_INDEX_SCAN_UNIQUE 0x00000001 \/* Scan visits at most 1 row *\/\n+#define SQLITE_INDEX_SCAN_HEX    0x00000002 \/* Display idxNum as hex *\/\n+                                            \/* in EXPLAIN QUERY PLAN *\/\n@@ -8640,0 +8794,1 @@\n+#define SQLITE_TESTCTRL_GETOPT                  16\n@@ -8659,1 +8814,1 @@\n-#define SQLITE_TESTCTRL_USELONGDOUBLE           34\n+#define SQLITE_TESTCTRL_USELONGDOUBLE           34  \/* NOT USED *\/\n@@ -8673,1 +8828,1 @@\n-** The sqlite3_keyword_name(N,Z,L) interface finds the N-th keyword and\n+** The sqlite3_keyword_name(N,Z,L) interface finds the 0-based N-th keyword and\n@@ -9635,0 +9790,10 @@\n+**\n+** <b>Alternatives To Using The Backup API<\/b>\n+**\n+** Other techniques for safely creating a consistent backup of an SQLite\n+** database include:\n+**\n+** <ul>\n+** <li> The [VACUUM INTO] command.\n+** <li> The [sqlite3_rsync] utility program.\n+** <\/ul>\n@@ -10252,8 +10417,7 @@\n-** order, as long as rows with the same values in all \"aOrderBy\" columns\n-** are adjacent.)^  ^(Furthermore, only a single row for each particular\n-** combination of values in the columns identified by the \"aOrderBy\" field\n-** needs to be returned.)^  ^It is always ok for two or more rows with the same\n-** values in all \"aOrderBy\" columns to be returned, as long as all such rows\n-** are adjacent.  ^The virtual table may, if it chooses, omit extra rows\n-** that have the same value for all columns identified by \"aOrderBy\".\n-** ^However omitting the extra rows is optional.\n+** order, as long as rows with the same values in all columns identified\n+** by \"aOrderBy\" are adjacent.)^  ^(Furthermore, when two or more rows\n+** contain the same values for all columns identified by \"colUsed\", all but\n+** one such row may optionally be omitted from the result.)^\n+** The virtual table is not required to omit rows that are duplicates\n+** over the \"colUsed\" columns, but if the virtual table can do that without\n+** too much extra effort, it could potentially help the query to run faster.\n@@ -10262,5 +10426,10 @@\n-** ^(If the sqlite3_vtab_distinct() interface returns 3, that means\n-** that the query planner needs only distinct rows but it does need the\n-** rows to be sorted.)^ ^The virtual table implementation is free to omit\n-** rows that are identical in all aOrderBy columns, if it wants to, but\n-** it is not required to omit any rows.  This mode is used for queries\n+** ^(If the sqlite3_vtab_distinct() interface returns 3, that means the\n+** virtual table must return rows in the order defined by \"aOrderBy\" as\n+** if the sqlite3_vtab_distinct() interface had returned 0.  However if\n+** two or more rows in the result have the same values for all columns\n+** identified by \"colUsed\", then all but one such row may optionally be\n+** omitted.)^  Like when the return value is 2, the virtual table\n+** is not required to omit rows that are duplicates over the \"colUsed\"\n+** columns, but if the virtual table can do that without\n+** too much extra effort, it could potentially help the query to run faster.\n+** This mode is used for queries\n@@ -10270,0 +10439,17 @@\n+** <p>The following table summarizes the conditions under which the\n+** virtual table is allowed to set the \"orderByConsumed\" flag based on\n+** the value returned by sqlite3_vtab_distinct().  This table is a\n+** restatement of the previous four paragraphs:\n+**\n+** <table border=1 cellspacing=0 cellpadding=10 width=\"90%\">\n+** <tr>\n+** <td valign=\"top\">sqlite3_vtab_distinct() return value\n+** <td valign=\"top\">Rows are returned in aOrderBy order\n+** <td valign=\"top\">Rows with the same value in all aOrderBy columns are adjacent\n+** <td valign=\"top\">Duplicates over all colUsed columns may be omitted\n+** <tr><td>0<td>yes<td>yes<td>no\n+** <tr><td>1<td>no<td>yes<td>no\n+** <tr><td>2<td>no<td>yes<td>yes\n+** <tr><td>3<td>yes<td>yes<td>yes\n+** <\/table>\n+**\n@@ -10813,0 +10999,8 @@\n+** If a read-transaction is opened by this function, then it is guaranteed\n+** that the returned snapshot object may not be invalidated by a database\n+** writer or checkpointer until after the read-transaction is closed. This\n+** is not guaranteed if a read-transaction is already open when this\n+** function is called. In that case, any subsequent write or checkpoint\n+** operation on the database may invalidate the returned snapshot handle,\n+** even while the read-transaction remains open.\n+**\n@@ -10970,2 +11164,3 @@\n-** The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory\n-** that is a serialization of the S database on [database connection] D.\n+** The sqlite3_serialize(D,S,P,F) interface returns a pointer to\n+** memory that is a serialization of the S database on\n+** [database connection] D.  If S is a NULL pointer, the main database is used.\n@@ -11121,2 +11316,0 @@\n-# undef SQLITE_OMIT_WAL\n-# define SQLITE_OMIT_WAL 1\/* because it requires shared memory APIs *\/\n@@ -11134,1 +11327,1 @@\n-#endif \/* SQLITE3_H *\/\n+\/* #endif for SQLITE3_H will be added by mksqlite3.tcl *\/\n@@ -12314,0 +12507,24 @@\n+\/*\n+** CAPI3REF: Add A Single Change To A Changegroup\n+** METHOD: sqlite3_changegroup\n+**\n+** This function adds the single change currently indicated by the iterator\n+** passed as the second argument to the changegroup object. The rules for\n+** adding the change are just as described for [sqlite3changegroup_add()].\n+**\n+** If the change is successfully added to the changegroup, SQLITE_OK is\n+** returned. Otherwise, an SQLite error code is returned.\n+**\n+** The iterator must point to a valid entry when this function is called.\n+** If it does not, SQLITE_ERROR is returned and no change is added to the\n+** changegroup. Additionally, the iterator must not have been opened with\n+** the SQLITE_CHANGESETAPPLY_INVERT flag. In this case SQLITE_ERROR is also\n+** returned.\n+*\/\n+SQLITE_API int sqlite3changegroup_add_change(\n+  sqlite3_changegroup*,\n+  sqlite3_changeset_iter*\n+);\n+\n+\n+\n@@ -13118,2 +13335,2 @@\n-**   Return a copy of the context pointer the extension function was\n-**   registered with.\n+**   Return a copy of the pUserData pointer passed to the xCreateFunction()\n+**   API when the extension function was registered.\n@@ -13301,0 +13518,4 @@\n+**   In all cases, matches are visited in (column ASC, offset ASC) order.\n+**   i.e. all those in column 0, sorted by offset, followed by those in\n+**   column 1, etc.\n+**\n@@ -13357,3 +13578,1 @@\n-**   bytes. This API is not available if the specified token matches a\n-**   prefix query term. In that case both output variables are always set\n-**   to 0.\n+**   bytes.\n@@ -13365,0 +13584,17 @@\n+**   This API may be slow in some cases if the token identified by parameters\n+**   iIdx and iToken matched a prefix token in the query. In most cases, the\n+**   first call to this API for each prefix token in the query is forced\n+**   to scan the portion of the full-text index that matches the prefix\n+**   token to collect the extra data required by this API. If the prefix\n+**   token matches a large number of token instances in the document set,\n+**   this may be a performance problem.\n+**\n+**   If the user knows in advance that a query may use this API for a\n+**   prefix token, FTS5 may be configured to collect all required data as part\n+**   of the initial querying of the full-text index, avoiding the second scan\n+**   entirely. This also causes prefix queries that do not use this API to\n+**   run more slowly and use more memory. FTS5 may be configured in this way\n+**   either on a per-table basis using the [FTS5 insttoken | 'insttoken']\n+**   option, or on a per-query basis using the\n+**   [fts5_insttoken | fts5_insttoken()] user function.\n+**\n@@ -13367,0 +13603,23 @@\n+**\n+** xColumnLocale(pFts5, iIdx, pzLocale, pnLocale)\n+**   If parameter iCol is less than zero, or greater than or equal to the\n+**   number of columns in the table, SQLITE_RANGE is returned.\n+**\n+**   Otherwise, this function attempts to retrieve the locale associated\n+**   with column iCol of the current row. Usually, there is no associated\n+**   locale, and output parameters (*pzLocale) and (*pnLocale) are set\n+**   to NULL and 0, respectively. However, if the fts5_locale() function\n+**   was used to associate a locale with the value when it was inserted\n+**   into the fts5 table, then (*pzLocale) is set to point to a nul-terminated\n+**   buffer containing the name of the locale in utf-8 encoding. (*pnLocale)\n+**   is set to the size in bytes of the buffer, not including the\n+**   nul-terminator.\n+**\n+**   If successful, SQLITE_OK is returned. Or, if an error occurs, an\n+**   SQLite error code is returned. The final value of the output parameters\n+**   is undefined in this case.\n+**\n+** xTokenize_v2:\n+**   Tokenize text using the tokenizer belonging to the FTS5 table. This\n+**   API is the same as the xTokenize() API, except that it allows a tokenizer\n+**   locale to be specified.\n@@ -13369,1 +13628,1 @@\n-  int iVersion;                   \/* Currently always set to 3 *\/\n+  int iVersion;                   \/* Currently always set to 4 *\/\n@@ -13411,0 +13670,9 @@\n+\n+  \/* Below this point are iVersion>=4 only *\/\n+  int (*xColumnLocale)(Fts5Context*, int iCol, const char **pz, int *pn);\n+  int (*xTokenize_v2)(Fts5Context*,\n+    const char *pText, int nText,      \/* Text to tokenize *\/\n+    const char *pLocale, int nLocale,  \/* Locale to pass to tokenizer *\/\n+    void *pCtx,                        \/* Context passed to xToken() *\/\n+    int (*xToken)(void*, int, const char*, int, int, int)       \/* Callback *\/\n+  );\n@@ -13431,1 +13699,1 @@\n-**   pointer provided by the application when the fts5_tokenizer object\n+**   pointer provided by the application when the fts5_tokenizer_v2 object\n@@ -13455,1 +13723,1 @@\n-**   The second argument indicates the reason that FTS5 is requesting\n+**   The third argument indicates the reason that FTS5 is requesting\n@@ -13479,0 +13747,7 @@\n+**   The sixth and seventh arguments passed to xTokenize() - pLocale and\n+**   nLocale - are a pointer to a buffer containing the locale to use for\n+**   tokenization (e.g. \"en_US\") and its size in bytes, respectively. The\n+**   pLocale buffer is not nul-terminated. pLocale may be passed NULL (in\n+**   which case nLocale is always 0) to indicate that the tokenizer should\n+**   use its default locale.\n+**\n@@ -13502,0 +13777,24 @@\n+**   If the tokenizer is registered using an fts5_tokenizer_v2 object,\n+**   then the xTokenize() method has two additional arguments - pLocale\n+**   and nLocale. These specify the locale that the tokenizer should use\n+**   for the current request. If pLocale and nLocale are both 0, then the\n+**   tokenizer should use its default locale. Otherwise, pLocale points to\n+**   an nLocale byte buffer containing the name of the locale to use as utf-8\n+**   text. pLocale is not nul-terminated.\n+**\n+** FTS5_TOKENIZER\n+**\n+** There is also an fts5_tokenizer object. This is an older, deprecated,\n+** version of fts5_tokenizer_v2. It is similar except that:\n+**\n+**  <ul>\n+**    <li> There is no \"iVersion\" field, and\n+**    <li> The xTokenize() method does not take a locale argument.\n+**  <\/ul>\n+**\n+** Legacy fts5_tokenizer tokenizers must be registered using the\n+** legacy xCreateTokenizer() function, instead of xCreateTokenizer_v2().\n+**\n+** Tokenizer implementations registered using either API may be retrieved\n+** using both xFindTokenizer() and xFindTokenizer_v2().\n+**\n@@ -13610,0 +13909,27 @@\n+typedef struct fts5_tokenizer_v2 fts5_tokenizer_v2;\n+struct fts5_tokenizer_v2 {\n+  int iVersion;             \/* Currently always 2 *\/\n+\n+  int (*xCreate)(void*, const char **azArg, int nArg, Fts5Tokenizer **ppOut);\n+  void (*xDelete)(Fts5Tokenizer*);\n+  int (*xTokenize)(Fts5Tokenizer*,\n+      void *pCtx,\n+      int flags,            \/* Mask of FTS5_TOKENIZE_* flags *\/\n+      const char *pText, int nText,\n+      const char *pLocale, int nLocale,\n+      int (*xToken)(\n+        void *pCtx,         \/* Copy of 2nd argument to xTokenize() *\/\n+        int tflags,         \/* Mask of FTS5_TOKEN_* flags *\/\n+        const char *pToken, \/* Pointer to buffer containing token *\/\n+        int nToken,         \/* Size of token in bytes *\/\n+        int iStart,         \/* Byte offset of token within input text *\/\n+        int iEnd            \/* Byte offset of end of token within input text *\/\n+      )\n+  );\n+};\n+\n+\/*\n+** New code should use the fts5_tokenizer_v2 type to define tokenizer\n+** implementations. The following type is included for legacy applications\n+** that still use it.\n+*\/\n@@ -13629,0 +13955,1 @@\n+\n@@ -13648,1 +13975,1 @@\n-  int iVersion;                   \/* Currently always set to 2 *\/\n+  int iVersion;                   \/* Currently always set to 3 *\/\n@@ -13675,0 +14002,19 @@\n+\n+  \/* APIs below this point are only available if iVersion>=3 *\/\n+\n+  \/* Create a new tokenizer *\/\n+  int (*xCreateTokenizer_v2)(\n+    fts5_api *pApi,\n+    const char *zName,\n+    void *pUserData,\n+    fts5_tokenizer_v2 *pTokenizer,\n+    void (*xDestroy)(void*)\n+  );\n+\n+  \/* Find an existing tokenizer *\/\n+  int (*xFindTokenizer_v2)(\n+    fts5_api *pApi,\n+    const char *zName,\n+    void **ppUserData,\n+    fts5_tokenizer_v2 **ppTokenizer\n+  );\n@@ -13688,0 +14034,1 @@\n+#endif \/* SQLITE3_H *\/\n@@ -13733,0 +14080,1 @@\n+#define SQLITE_MIN_LENGTH 30   \/* Minimum value for the length limit *\/\n@@ -13798,0 +14146,4 @@\n+**\n+** This value has a hard upper limit of 32767 due to storage\n+** constraints (it needs to fit inside a i16).  We keep it\n+** lower than that to prevent abuse.\n@@ -13800,1 +14152,1 @@\n-# define SQLITE_MAX_FUNCTION_ARG 127\n+# define SQLITE_MAX_FUNCTION_ARG 1000\n@@ -14317,0 +14669,2 @@\n+#define SQLITE_DIGIT_SEPARATOR '_'\n+\n@@ -14482,126 +14836,126 @@\n-#define TK_MATCH                           46\n-#define TK_LIKE_KW                         47\n-#define TK_BETWEEN                         48\n-#define TK_IN                              49\n-#define TK_ISNULL                          50\n-#define TK_NOTNULL                         51\n-#define TK_NE                              52\n-#define TK_EQ                              53\n-#define TK_GT                              54\n-#define TK_LE                              55\n-#define TK_LT                              56\n-#define TK_GE                              57\n-#define TK_ESCAPE                          58\n-#define TK_ID                              59\n-#define TK_COLUMNKW                        60\n-#define TK_DO                              61\n-#define TK_FOR                             62\n-#define TK_IGNORE                          63\n-#define TK_INITIALLY                       64\n-#define TK_INSTEAD                         65\n-#define TK_NO                              66\n-#define TK_KEY                             67\n-#define TK_OF                              68\n-#define TK_OFFSET                          69\n-#define TK_PRAGMA                          70\n-#define TK_RAISE                           71\n-#define TK_RECURSIVE                       72\n-#define TK_REPLACE                         73\n-#define TK_RESTRICT                        74\n-#define TK_ROW                             75\n-#define TK_ROWS                            76\n-#define TK_TRIGGER                         77\n-#define TK_VACUUM                          78\n-#define TK_VIEW                            79\n-#define TK_VIRTUAL                         80\n-#define TK_WITH                            81\n-#define TK_NULLS                           82\n-#define TK_FIRST                           83\n-#define TK_LAST                            84\n-#define TK_CURRENT                         85\n-#define TK_FOLLOWING                       86\n-#define TK_PARTITION                       87\n-#define TK_PRECEDING                       88\n-#define TK_RANGE                           89\n-#define TK_UNBOUNDED                       90\n-#define TK_EXCLUDE                         91\n-#define TK_GROUPS                          92\n-#define TK_OTHERS                          93\n-#define TK_TIES                            94\n-#define TK_GENERATED                       95\n-#define TK_ALWAYS                          96\n-#define TK_MATERIALIZED                    97\n-#define TK_REINDEX                         98\n-#define TK_RENAME                          99\n-#define TK_CTIME_KW                       100\n-#define TK_ANY                            101\n-#define TK_BITAND                         102\n-#define TK_BITOR                          103\n-#define TK_LSHIFT                         104\n-#define TK_RSHIFT                         105\n-#define TK_PLUS                           106\n-#define TK_MINUS                          107\n-#define TK_STAR                           108\n-#define TK_SLASH                          109\n-#define TK_REM                            110\n-#define TK_CONCAT                         111\n-#define TK_PTR                            112\n-#define TK_COLLATE                        113\n-#define TK_BITNOT                         114\n-#define TK_ON                             115\n-#define TK_INDEXED                        116\n-#define TK_STRING                         117\n-#define TK_JOIN_KW                        118\n-#define TK_CONSTRAINT                     119\n-#define TK_DEFAULT                        120\n-#define TK_NULL                           121\n-#define TK_PRIMARY                        122\n-#define TK_UNIQUE                         123\n-#define TK_CHECK                          124\n-#define TK_REFERENCES                     125\n-#define TK_AUTOINCR                       126\n-#define TK_INSERT                         127\n-#define TK_DELETE                         128\n-#define TK_UPDATE                         129\n-#define TK_SET                            130\n-#define TK_DEFERRABLE                     131\n-#define TK_FOREIGN                        132\n-#define TK_DROP                           133\n-#define TK_UNION                          134\n-#define TK_ALL                            135\n-#define TK_EXCEPT                         136\n-#define TK_INTERSECT                      137\n-#define TK_SELECT                         138\n-#define TK_VALUES                         139\n-#define TK_DISTINCT                       140\n-#define TK_DOT                            141\n-#define TK_FROM                           142\n-#define TK_JOIN                           143\n-#define TK_USING                          144\n-#define TK_ORDER                          145\n-#define TK_GROUP                          146\n-#define TK_HAVING                         147\n-#define TK_LIMIT                          148\n-#define TK_WHERE                          149\n-#define TK_RETURNING                      150\n-#define TK_INTO                           151\n-#define TK_NOTHING                        152\n-#define TK_FLOAT                          153\n-#define TK_BLOB                           154\n-#define TK_INTEGER                        155\n-#define TK_VARIABLE                       156\n-#define TK_CASE                           157\n-#define TK_WHEN                           158\n-#define TK_THEN                           159\n-#define TK_ELSE                           160\n-#define TK_INDEX                          161\n-#define TK_ALTER                          162\n-#define TK_ADD                            163\n-#define TK_WINDOW                         164\n-#define TK_OVER                           165\n-#define TK_FILTER                         166\n-#define TK_COLUMN                         167\n-#define TK_AGG_FUNCTION                   168\n-#define TK_AGG_COLUMN                     169\n-#define TK_TRUEFALSE                      170\n-#define TK_ISNOT                          171\n+#define TK_ISNOT                           46\n+#define TK_MATCH                           47\n+#define TK_LIKE_KW                         48\n+#define TK_BETWEEN                         49\n+#define TK_IN                              50\n+#define TK_ISNULL                          51\n+#define TK_NOTNULL                         52\n+#define TK_NE                              53\n+#define TK_EQ                              54\n+#define TK_GT                              55\n+#define TK_LE                              56\n+#define TK_LT                              57\n+#define TK_GE                              58\n+#define TK_ESCAPE                          59\n+#define TK_ID                              60\n+#define TK_COLUMNKW                        61\n+#define TK_DO                              62\n+#define TK_FOR                             63\n+#define TK_IGNORE                          64\n+#define TK_INITIALLY                       65\n+#define TK_INSTEAD                         66\n+#define TK_NO                              67\n+#define TK_KEY                             68\n+#define TK_OF                              69\n+#define TK_OFFSET                          70\n+#define TK_PRAGMA                          71\n+#define TK_RAISE                           72\n+#define TK_RECURSIVE                       73\n+#define TK_REPLACE                         74\n+#define TK_RESTRICT                        75\n+#define TK_ROW                             76\n+#define TK_ROWS                            77\n+#define TK_TRIGGER                         78\n+#define TK_VACUUM                          79\n+#define TK_VIEW                            80\n+#define TK_VIRTUAL                         81\n+#define TK_WITH                            82\n+#define TK_NULLS                           83\n+#define TK_FIRST                           84\n+#define TK_LAST                            85\n+#define TK_CURRENT                         86\n+#define TK_FOLLOWING                       87\n+#define TK_PARTITION                       88\n+#define TK_PRECEDING                       89\n+#define TK_RANGE                           90\n+#define TK_UNBOUNDED                       91\n+#define TK_EXCLUDE                         92\n+#define TK_GROUPS                          93\n+#define TK_OTHERS                          94\n+#define TK_TIES                            95\n+#define TK_GENERATED                       96\n+#define TK_ALWAYS                          97\n+#define TK_MATERIALIZED                    98\n+#define TK_REINDEX                         99\n+#define TK_RENAME                         100\n+#define TK_CTIME_KW                       101\n+#define TK_ANY                            102\n+#define TK_BITAND                         103\n+#define TK_BITOR                          104\n+#define TK_LSHIFT                         105\n+#define TK_RSHIFT                         106\n+#define TK_PLUS                           107\n+#define TK_MINUS                          108\n+#define TK_STAR                           109\n+#define TK_SLASH                          110\n+#define TK_REM                            111\n+#define TK_CONCAT                         112\n+#define TK_PTR                            113\n+#define TK_COLLATE                        114\n+#define TK_BITNOT                         115\n+#define TK_ON                             116\n+#define TK_INDEXED                        117\n+#define TK_STRING                         118\n+#define TK_JOIN_KW                        119\n+#define TK_CONSTRAINT                     120\n+#define TK_DEFAULT                        121\n+#define TK_NULL                           122\n+#define TK_PRIMARY                        123\n+#define TK_UNIQUE                         124\n+#define TK_CHECK                          125\n+#define TK_REFERENCES                     126\n+#define TK_AUTOINCR                       127\n+#define TK_INSERT                         128\n+#define TK_DELETE                         129\n+#define TK_UPDATE                         130\n+#define TK_SET                            131\n+#define TK_DEFERRABLE                     132\n+#define TK_FOREIGN                        133\n+#define TK_DROP                           134\n+#define TK_UNION                          135\n+#define TK_ALL                            136\n+#define TK_EXCEPT                         137\n+#define TK_INTERSECT                      138\n+#define TK_SELECT                         139\n+#define TK_VALUES                         140\n+#define TK_DISTINCT                       141\n+#define TK_DOT                            142\n+#define TK_FROM                           143\n+#define TK_JOIN                           144\n+#define TK_USING                          145\n+#define TK_ORDER                          146\n+#define TK_GROUP                          147\n+#define TK_HAVING                         148\n+#define TK_LIMIT                          149\n+#define TK_WHERE                          150\n+#define TK_RETURNING                      151\n+#define TK_INTO                           152\n+#define TK_NOTHING                        153\n+#define TK_FLOAT                          154\n+#define TK_BLOB                           155\n+#define TK_INTEGER                        156\n+#define TK_VARIABLE                       157\n+#define TK_CASE                           158\n+#define TK_WHEN                           159\n+#define TK_THEN                           160\n+#define TK_ELSE                           161\n+#define TK_INDEX                          162\n+#define TK_ALTER                          163\n+#define TK_ADD                            164\n+#define TK_WINDOW                         165\n+#define TK_OVER                           166\n+#define TK_FILTER                         167\n+#define TK_COLUMN                         168\n+#define TK_AGG_FUNCTION                   169\n+#define TK_AGG_COLUMN                     170\n+#define TK_TRUEFALSE                      171\n@@ -14609,2 +14963,2 @@\n-#define TK_UMINUS                         173\n-#define TK_UPLUS                          174\n+#define TK_UPLUS                          173\n+#define TK_UMINUS                         174\n@@ -14619,2 +14973,4 @@\n-#define TK_SPACE                          183\n-#define TK_ILLEGAL                        184\n+#define TK_QNUMBER                        183\n+#define TK_SPACE                          184\n+#define TK_COMMENT                        185\n+#define TK_ILLEGAL                        186\n@@ -14629,0 +14985,1 @@\n+#include <ctype.h>\n@@ -14649,1 +15006,2 @@\n-# define LONGDOUBLE_TYPE sqlite_int64\n+# define fabs(X) ((X)<0?-(X):(X))\n+# define sqlite3IsOverflow(X) 0\n@@ -14824,3 +15182,0 @@\n-#ifndef LONGDOUBLE_TYPE\n-# define LONGDOUBLE_TYPE long double\n-#endif\n@@ -14873,0 +15228,2 @@\n+#define LOGEST_MIN (-32768)\n+#define LOGEST_MAX (32767)\n@@ -14882,1 +15239,1 @@\n-      (defined(__APPLE__) && defined(__POWERPC__)) ||                     \\\n+      (defined(__APPLE__) && defined(__ppc__)) ||                         \\\n@@ -15143,1 +15500,1 @@\n-** 0x00000002   Solver\n+** 0x00000002   Solver (Use 0x40000 for less detail)\n@@ -15150,1 +15507,1 @@\n-** 0x00000080   WhereLoop cost adjustements\n+** 0x00000080   WhereLoop cost adjustments\n@@ -15162,0 +15519,2 @@\n+** 0x00040000   Solver overview messages\n+** 0x00080000   Star-query heuristic\n@@ -15326,0 +15685,1 @@\n+typedef struct Subquery Subquery;\n@@ -15799,0 +16159,16 @@\n+#define isWalMode(x) ((x)==PAGER_JOURNALMODE_WAL)\n+\n+\/*\n+** The argument to this macro is a file descriptor (type sqlite3_file*).\n+** Return 0 if it is not open, or non-zero (but not 1) if it is.\n+**\n+** This is so that expressions can be written as:\n+**\n+**   if( isOpen(pPager->jfd) ){ ...\n+**\n+** instead of\n+**\n+**   if( pPager->jfd->pMethods ){ ...\n+*\/\n+#define isOpen(pFd) ((pFd)->pMethods!=0)\n+\n@@ -16208,0 +16584,3 @@\n+#ifdef SQLITE_DEBUG\n+SQLITE_PRIVATE int sqlite3BtreeClosesWithCursor(Btree*,BtCursor*);\n+#endif\n@@ -16299,0 +16678,1 @@\n+  sqlite3_value *aCnt,  \/* OUT: entry counts for each btree in aRoot[] *\/\n@@ -16425,0 +16805,14 @@\n+typedef struct SubrtnSig SubrtnSig;\n+\n+\/*\n+** A signature for a reusable subroutine that materializes the RHS of\n+** an IN operator.\n+*\/\n+struct SubrtnSig {\n+  int selId;          \/* SELECT-id for the SELECT statement on the RHS *\/\n+  u8 bComplete;       \/* True if fully coded and available for reusable *\/\n+  char *zAff;         \/* Affinity of the overall IN expression *\/\n+  int iTable;         \/* Ephemeral table generated by the subroutine *\/\n+  int iAddr;          \/* Subroutine entry address *\/\n+  int regReturn;      \/* Register used to hold return address *\/\n+};\n@@ -16453,0 +16847,1 @@\n+    SubrtnSig *pSubrtnSig; \/* Used when p4type is P4_SUBRTNSIG *\/\n@@ -16520,0 +16915,1 @@\n+#define P4_SUBRTNSIG  (-17) \/* P4 is a SubrtnSig pointer *\/\n@@ -16569,1 +16965,1 @@\n-#define OP_Init            8 \/* jump, synopsis: Start at P2                *\/\n+#define OP_Init            8 \/* jump0, synopsis: Start at P2               *\/\n@@ -16572,3 +16968,3 @@\n-#define OP_InitCoroutine  11 \/* jump                                       *\/\n-#define OP_Yield          12 \/* jump                                       *\/\n-#define OP_MustBeInt      13 \/* jump                                       *\/\n+#define OP_InitCoroutine  11 \/* jump0                                      *\/\n+#define OP_Yield          12 \/* jump0                                      *\/\n+#define OP_MustBeInt      13 \/* jump0                                      *\/\n@@ -16582,4 +16978,4 @@\n-#define OP_SeekLT         21 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_SeekLE         22 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_SeekGE         23 \/* jump, synopsis: key=r[P3@P4]               *\/\n-#define OP_SeekGT         24 \/* jump, synopsis: key=r[P3@P4]               *\/\n+#define OP_SeekLT         21 \/* jump0, synopsis: key=r[P3@P4]              *\/\n+#define OP_SeekLE         22 \/* jump0, synopsis: key=r[P3@P4]              *\/\n+#define OP_SeekGE         23 \/* jump0, synopsis: key=r[P3@P4]              *\/\n+#define OP_SeekGT         24 \/* jump0, synopsis: key=r[P3@P4]              *\/\n@@ -16591,1 +16987,1 @@\n-#define OP_SeekRowid      30 \/* jump, synopsis: intkey=r[P3]               *\/\n+#define OP_SeekRowid      30 \/* jump0, synopsis: intkey=r[P3]              *\/\n@@ -16593,2 +16989,2 @@\n-#define OP_Last           32 \/* jump                                       *\/\n-#define OP_IfSmaller      33 \/* jump                                       *\/\n+#define OP_Last           32 \/* jump0                                      *\/\n+#define OP_IfSizeBetween  33 \/* jump                                       *\/\n@@ -16597,1 +16993,1 @@\n-#define OP_Rewind         36 \/* jump                                       *\/\n+#define OP_Rewind         36 \/* jump0                                      *\/\n@@ -16609,1 +17005,1 @@\n-#define OP_Program        48 \/* jump                                       *\/\n+#define OP_Program        48 \/* jump0                                      *\/\n@@ -16611,10 +17007,10 @@\n-#define OP_IsNull         50 \/* jump, same as TK_ISNULL, synopsis: if r[P1]==NULL goto P2 *\/\n-#define OP_NotNull        51 \/* jump, same as TK_NOTNULL, synopsis: if r[P1]!=NULL goto P2 *\/\n-#define OP_Ne             52 \/* jump, same as TK_NE, synopsis: IF r[P3]!=r[P1] *\/\n-#define OP_Eq             53 \/* jump, same as TK_EQ, synopsis: IF r[P3]==r[P1] *\/\n-#define OP_Gt             54 \/* jump, same as TK_GT, synopsis: IF r[P3]>r[P1] *\/\n-#define OP_Le             55 \/* jump, same as TK_LE, synopsis: IF r[P3]<=r[P1] *\/\n-#define OP_Lt             56 \/* jump, same as TK_LT, synopsis: IF r[P3]<r[P1] *\/\n-#define OP_Ge             57 \/* jump, same as TK_GE, synopsis: IF r[P3]>=r[P1] *\/\n-#define OP_ElseEq         58 \/* jump, same as TK_ESCAPE                    *\/\n-#define OP_IfPos          59 \/* jump, synopsis: if r[P1]>0 then r[P1]-=P3, goto P2 *\/\n+#define OP_IfPos          50 \/* jump, synopsis: if r[P1]>0 then r[P1]-=P3, goto P2 *\/\n+#define OP_IsNull         51 \/* jump, same as TK_ISNULL, synopsis: if r[P1]==NULL goto P2 *\/\n+#define OP_NotNull        52 \/* jump, same as TK_NOTNULL, synopsis: if r[P1]!=NULL goto P2 *\/\n+#define OP_Ne             53 \/* jump, same as TK_NE, synopsis: IF r[P3]!=r[P1] *\/\n+#define OP_Eq             54 \/* jump, same as TK_EQ, synopsis: IF r[P3]==r[P1] *\/\n+#define OP_Gt             55 \/* jump, same as TK_GT, synopsis: IF r[P3]>r[P1] *\/\n+#define OP_Le             56 \/* jump, same as TK_LE, synopsis: IF r[P3]<=r[P1] *\/\n+#define OP_Lt             57 \/* jump, same as TK_LT, synopsis: IF r[P3]<r[P1] *\/\n+#define OP_Ge             58 \/* jump, same as TK_GE, synopsis: IF r[P3]>=r[P1] *\/\n+#define OP_ElseEq         59 \/* jump, same as TK_ESCAPE                    *\/\n@@ -16639,1 +17035,1 @@\n-#define OP_Variable       78 \/* synopsis: r[P2]=parameter(P1,P4)           *\/\n+#define OP_Variable       78 \/* synopsis: r[P2]=parameter(P1)              *\/\n@@ -16663,11 +17059,11 @@\n-#define OP_BitAnd        102 \/* same as TK_BITAND, synopsis: r[P3]=r[P1]&r[P2] *\/\n-#define OP_BitOr         103 \/* same as TK_BITOR, synopsis: r[P3]=r[P1]|r[P2] *\/\n-#define OP_ShiftLeft     104 \/* same as TK_LSHIFT, synopsis: r[P3]=r[P2]<<r[P1] *\/\n-#define OP_ShiftRight    105 \/* same as TK_RSHIFT, synopsis: r[P3]=r[P2]>>r[P1] *\/\n-#define OP_Add           106 \/* same as TK_PLUS, synopsis: r[P3]=r[P1]+r[P2] *\/\n-#define OP_Subtract      107 \/* same as TK_MINUS, synopsis: r[P3]=r[P2]-r[P1] *\/\n-#define OP_Multiply      108 \/* same as TK_STAR, synopsis: r[P3]=r[P1]*r[P2] *\/\n-#define OP_Divide        109 \/* same as TK_SLASH, synopsis: r[P3]=r[P2]\/r[P1] *\/\n-#define OP_Remainder     110 \/* same as TK_REM, synopsis: r[P3]=r[P2]%r[P1] *\/\n-#define OP_Concat        111 \/* same as TK_CONCAT, synopsis: r[P3]=r[P2]+r[P1] *\/\n-#define OP_OpenRead      112 \/* synopsis: root=P2 iDb=P3                   *\/\n+#define OP_OpenRead      102 \/* synopsis: root=P2 iDb=P3                   *\/\n+#define OP_BitAnd        103 \/* same as TK_BITAND, synopsis: r[P3]=r[P1]&r[P2] *\/\n+#define OP_BitOr         104 \/* same as TK_BITOR, synopsis: r[P3]=r[P1]|r[P2] *\/\n+#define OP_ShiftLeft     105 \/* same as TK_LSHIFT, synopsis: r[P3]=r[P2]<<r[P1] *\/\n+#define OP_ShiftRight    106 \/* same as TK_RSHIFT, synopsis: r[P3]=r[P2]>>r[P1] *\/\n+#define OP_Add           107 \/* same as TK_PLUS, synopsis: r[P3]=r[P1]+r[P2] *\/\n+#define OP_Subtract      108 \/* same as TK_MINUS, synopsis: r[P3]=r[P2]-r[P1] *\/\n+#define OP_Multiply      109 \/* same as TK_STAR, synopsis: r[P3]=r[P1]*r[P2] *\/\n+#define OP_Divide        110 \/* same as TK_SLASH, synopsis: r[P3]=r[P2]\/r[P1] *\/\n+#define OP_Remainder     111 \/* same as TK_REM, synopsis: r[P3]=r[P2]%r[P1] *\/\n+#define OP_Concat        112 \/* same as TK_CONCAT, synopsis: r[P3]=r[P2]+r[P1] *\/\n@@ -16675,2 +17071,2 @@\n-#define OP_BitNot        114 \/* same as TK_BITNOT, synopsis: r[P2]= ~r[P1] *\/\n-#define OP_OpenDup       115\n+#define OP_OpenDup       114\n+#define OP_BitNot        115 \/* same as TK_BITNOT, synopsis: r[P2]= ~r[P1] *\/\n@@ -16678,2 +17074,2 @@\n-#define OP_String8       117 \/* same as TK_STRING, synopsis: r[P2]='P4'    *\/\n-#define OP_OpenEphemeral 118 \/* synopsis: nColumn=P2                       *\/\n+#define OP_OpenEphemeral 117 \/* synopsis: nColumn=P2                       *\/\n+#define OP_String8       118 \/* same as TK_STRING, synopsis: r[P2]='P4'    *\/\n@@ -16714,2 +17110,2 @@\n-#define OP_Real          153 \/* same as TK_FLOAT, synopsis: r[P2]=P4       *\/\n-#define OP_DropTrigger   154\n+#define OP_DropTrigger   153\n+#define OP_Real          154 \/* same as TK_FLOAT, synopsis: r[P2]=P4       *\/\n@@ -16763,0 +17159,1 @@\n+#define OPFLG_JUMP0       0x80  \/* jump0:  P2 might be zero *\/\n@@ -16765,4 +17162,4 @@\n-\/*   8 *\/ 0x01, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x01,\\\n-\/*  16 *\/ 0x03, 0x03, 0x01, 0x12, 0x01, 0x49, 0x49, 0x49,\\\n-\/*  24 *\/ 0x49, 0x01, 0x49, 0x49, 0x49, 0x49, 0x49, 0x49,\\\n-\/*  32 *\/ 0x41, 0x01, 0x41, 0x41, 0x41, 0x01, 0x41, 0x41,\\\n+\/*   8 *\/ 0x81, 0x01, 0x01, 0x81, 0x83, 0x83, 0x01, 0x01,\\\n+\/*  16 *\/ 0x03, 0x03, 0x01, 0x12, 0x01, 0xc9, 0xc9, 0xc9,\\\n+\/*  24 *\/ 0xc9, 0x01, 0x49, 0x49, 0x49, 0x49, 0xc9, 0x49,\\\n+\/*  32 *\/ 0xc1, 0x01, 0x41, 0x41, 0xc1, 0x01, 0x41, 0x41,\\\n@@ -16770,2 +17167,2 @@\n-\/*  48 *\/ 0x01, 0x01, 0x03, 0x03, 0x0b, 0x0b, 0x0b, 0x0b,\\\n-\/*  56 *\/ 0x0b, 0x0b, 0x01, 0x03, 0x03, 0x03, 0x01, 0x41,\\\n+\/*  48 *\/ 0x81, 0x01, 0x03, 0x03, 0x03, 0x0b, 0x0b, 0x0b,\\\n+\/*  56 *\/ 0x0b, 0x0b, 0x0b, 0x01, 0x03, 0x03, 0x01, 0x41,\\\n@@ -16776,1 +17173,1 @@\n-\/*  96 *\/ 0x00, 0x00, 0x10, 0x10, 0x00, 0x40, 0x26, 0x26,\\\n+\/*  96 *\/ 0x00, 0x00, 0x10, 0x10, 0x00, 0x40, 0x40, 0x26,\\\n@@ -16778,1 +17175,1 @@\n-\/* 112 *\/ 0x40, 0x00, 0x12, 0x40, 0x40, 0x10, 0x40, 0x00,\\\n+\/* 112 *\/ 0x26, 0x00, 0x40, 0x12, 0x40, 0x40, 0x10, 0x00,\\\n@@ -16783,1 +17180,1 @@\n-\/* 152 *\/ 0x00, 0x10, 0x00, 0x00, 0x06, 0x10, 0x00, 0x04,\\\n+\/* 152 *\/ 0x00, 0x00, 0x10, 0x00, 0x06, 0x10, 0x00, 0x04,\\\n@@ -16804,1 +17201,1 @@\n-#define SQLITE_PREPARE_MASK     0x0f  \/* Mask of public flags *\/\n+#define SQLITE_PREPARE_MASK     0x1f  \/* Mask of public flags *\/\n@@ -16930,0 +17327,2 @@\n+SQLITE_PRIVATE void sqlite3MemSetArrayInt64(sqlite3_value *aMem, int iIdx, i64 val);\n+\n@@ -17517,27 +17916,0 @@\n-#ifdef SQLITE_USER_AUTHENTICATION\n-\/*\n-** Information held in the \"sqlite3\" database connection object and used\n-** to manage user authentication.\n-*\/\n-typedef struct sqlite3_userauth sqlite3_userauth;\n-struct sqlite3_userauth {\n-  u8 authLevel;                 \/* Current authentication level *\/\n-  int nAuthPW;                  \/* Size of the zAuthPW in bytes *\/\n-  char *zAuthPW;                \/* Password used to authenticate *\/\n-  char *zAuthUser;              \/* User name used to authenticate *\/\n-};\n-\n-\/* Allowed values for sqlite3_userauth.authLevel *\/\n-#define UAUTH_Unknown     0     \/* Authentication not yet checked *\/\n-#define UAUTH_Fail        1     \/* User authentication failed *\/\n-#define UAUTH_User        2     \/* Authenticated as a normal user *\/\n-#define UAUTH_Admin       3     \/* Authenticated as an administrator *\/\n-\n-\/* Functions used only by user authorization logic *\/\n-SQLITE_PRIVATE int sqlite3UserAuthTable(const char*);\n-SQLITE_PRIVATE int sqlite3UserAuthCheckLogin(sqlite3*,const char*,u8*);\n-SQLITE_PRIVATE void sqlite3UserAuthInit(sqlite3*);\n-SQLITE_PRIVATE void sqlite3CryptFunc(sqlite3_context*,int,sqlite3_value**);\n-\n-#endif \/* SQLITE_USER_AUTHENTICATION *\/\n-\n@@ -17547,7 +17919,2 @@\n-#ifdef SQLITE_USER_AUTHENTICATION\n-  typedef int (*sqlite3_xauth)(void*,int,const char*,const char*,const char*,\n-                               const char*, const char*);\n-#else\n-  typedef int (*sqlite3_xauth)(void*,int,const char*,const char*,const char*,\n-                               const char*);\n-#endif\n+typedef int (*sqlite3_xauth)(void*,int,const char*,const char*,const char*,\n+                             const char*);\n@@ -17714,3 +18081,0 @@\n-#ifdef SQLITE_USER_AUTHENTICATION\n-  sqlite3_userauth auth;        \/* User authentication information *\/\n-#endif\n@@ -17780,0 +18144,3 @@\n+#define SQLITE_AttachCreate   HI(0x00010) \/* ATTACH allowed to create new dbs *\/\n+#define SQLITE_AttachWrite    HI(0x00020) \/* ATTACH allowed to open for write *\/\n+#define SQLITE_Comments       HI(0x00040) \/* Enable SQL comments *\/\n@@ -17820,1 +18187,1 @@\n-#define SQLITE_PushDown       0x00001000 \/* The push-down optimization *\/\n+#define SQLITE_PushDown       0x00001000 \/* WHERE-clause push-down opt *\/\n@@ -17838,0 +18205,2 @@\n+#define SQLITE_OrderBySubq    0x10000000 \/* ORDER BY in subquery helps outer *\/\n+#define SQLITE_StarQuery      0x20000000 \/* Heurists for star queries *\/\n@@ -17874,1 +18243,1 @@\n-  i8 nArg;             \/* Number of arguments.  -1 means unlimited *\/\n+  i16 nArg;            \/* Number of arguments.  -1 means unlimited *\/\n@@ -18393,2 +18762,1 @@\n-#define TF_StatsUsed      0x00000100 \/* Query planner decisions affected by\n-                                     ** Index.aiRowLogEst[] values *\/\n+#define TF_MaybeReanalyze 0x00000100 \/* Maybe run ANALYZE on this table *\/\n@@ -18826,0 +19194,1 @@\n+#ifndef NDEBUG\n@@ -18829,0 +19198,5 @@\n+#else\n+#define AggInfoColumnReg(A,I)  ((A)->iFirstReg+(I))\n+#define AggInfoFuncReg(A,I)    \\\n+                      ((A)->iFirstReg+(A)->nColumn+(I))\n+#endif\n@@ -19009,1 +19383,1 @@\n-               \/*   0x80000000 \/\/ Available *\/\n+#define EP_SubtArg  0x80000000 \/* Is argument to SQLITE_SUBTYPE function *\/\n@@ -19162,1 +19536,0 @@\n-  u8 eU4;          \/* Which element of a.u4 is valid *\/\n@@ -19165,4 +19538,0 @@\n-    union {\n-      int idx;          \/* Index in some Table.aCol[] of a column named zName *\/\n-      Expr *pExpr;      \/* Expr to implement a USING variable -- NOT USED *\/\n-    } u4;\n@@ -19180,0 +19549,10 @@\n+\/*\n+** Details of the implementation of a subquery.\n+*\/\n+struct Subquery {\n+  Select *pSelect;  \/* A SELECT statement used in place of a table name *\/\n+  int addrFillSub;  \/* Address of subroutine to initialize a subquery *\/\n+  int regReturn;    \/* Register holding return address of addrFillSub *\/\n+  int regResult;    \/* Registers holding results of a co-routine *\/\n+};\n+\n@@ -19192,1 +19571,10 @@\n-** Union member validity:\n+** Aggressive use of \"union\" helps keep the size of the object small.  This\n+** has been shown to boost performance, in addition to saving memory.\n+** Access to union elements is gated by the following rules which should\n+** always be checked, either by an if-statement or by an assert().\n+**\n+**    Field              Only access if this is true\n+**    ---------------    -----------------------------------\n+**    u1.zIndexedBy      fg.isIndexedBy\n+**    u1.pFuncArg        fg.isTabFunc\n+**    u1.nRow            !fg.isTabFunc  && !fg.isIndexedBy\n@@ -19194,4 +19582,13 @@\n-**    u1.zIndexedBy          fg.isIndexedBy && !fg.isTabFunc\n-**    u1.pFuncArg            fg.isTabFunc   && !fg.isIndexedBy\n-**    u2.pIBIndex            fg.isIndexedBy && !fg.isCte\n-**    u2.pCteUse             fg.isCte       && !fg.isIndexedBy\n+**    u2.pIBIndex        fg.isIndexedBy\n+**    u2.pCteUse         fg.isCte\n+**\n+**    u3.pOn             !fg.isUsing\n+**    u3.pUsing          fg.isUsing\n+**\n+**    u4.zDatabase       !fg.fixedSchema && !fg.isSubquery\n+**    u4.pSchema         fg.fixedSchema\n+**    u4.pSubq           fg.isSubquery\n+**\n+** See also the sqlite3SrcListDelete() routine for assert() statements that\n+** check invariants on the fields of this object, especially the flags\n+** inside the fg struct.\n@@ -19200,2 +19597,0 @@\n-  Schema *pSchema;  \/* Schema to which this item is fixed *\/\n-  char *zDatabase;  \/* Name of database holding this table *\/\n@@ -19204,5 +19599,1 @@\n-  Table *pTab;      \/* An SQL table corresponding to zName *\/\n-  Select *pSelect;  \/* A SELECT statement used in place of a table name *\/\n-  int addrFillSub;  \/* Address of subroutine to manifest a subquery *\/\n-  int regReturn;    \/* Register holding return address of addrFillSub *\/\n-  int regResult;    \/* Registers holding results of a co-routine *\/\n+  Table *pSTab;     \/* Table object for zName. Mnemonic: Srcitem-TABle *\/\n@@ -19213,0 +19604,1 @@\n+    unsigned isSubquery :1;    \/* True if this term is a subquery *\/\n@@ -19225,0 +19617,3 @@\n+    unsigned rowidUsed :1;     \/* The ROWID of this table is referenced *\/\n+    unsigned fixedSchema :1;   \/* Uses u4.pSchema, not u4.zDatabase *\/\n+    unsigned hadSchema :1;     \/* Had u4.zDatabase before u4.pSchema *\/\n@@ -19227,4 +19622,0 @@\n-  union {\n-    Expr *pOn;        \/* fg.isUsing==0 =>  The ON clause of a join *\/\n-    IdList *pUsing;   \/* fg.isUsing==1 =>  The USING clause of a join *\/\n-  } u3;\n@@ -19235,0 +19626,1 @@\n+    u32 nRow;            \/* Number of rows in a VALUES clause *\/\n@@ -19240,0 +19632,9 @@\n+  union {\n+    Expr *pOn;        \/* fg.isUsing==0 =>  The ON clause of a join *\/\n+    IdList *pUsing;   \/* fg.isUsing==1 =>  The USING clause of a join *\/\n+  } u3;\n+  union {\n+    Schema *pSchema;  \/* Schema to which this item is fixed *\/\n+    char *zDatabase;  \/* Name of database holding this table *\/\n+    Subquery *pSubq;  \/* Description of a subquery *\/\n+  } u4;\n@@ -19299,1 +19700,1 @@\n-                        \/*     0x2000    not currently used *\/\n+#define WHERE_KEEP_ALL_JOINS   0x2000 \/* Do not do the omit-noop-join opt *\/\n@@ -19371,1 +19772,1 @@\n-#define NC_Complex   0x002000 \/* True if a function or subquery seen *\/\n+\/*                   0x002000 \/\/ available for reuse *\/\n@@ -19492,1 +19893,1 @@\n-#define SF_PushDown      0x1000000 \/* SELECT has be modified by push-down opt *\/\n+#define SF_PushDown      0x1000000 \/* Modified by WHERE-clause push-down opt *\/\n@@ -19497,0 +19898,1 @@\n+#define SF_Correlated   0x20000000 \/* True if references the outer context *\/\n@@ -19498,2 +19900,4 @@\n-\/* True if S exists and has SF_NestedFrom *\/\n-#define IsNestedFrom(S) ((S)!=0 && ((S)->selFlags&SF_NestedFrom)!=0)\n+\/* True if SrcItem X is a subquery that has SF_NestedFrom *\/\n+#define IsNestedFrom(X) \\\n+   ((X)->fg.isSubquery && \\\n+    ((X)->u4.pSubq->pSelect->selFlags&SF_NestedFrom)!=0)\n@@ -19529,1 +19933,5 @@\n-**                     results.  Used to implement \"IN (SELECT ...)\".\n+**                     results.  if pDest->iSDParm2 is positive, then it is\n+**                     a register holding a Bloom filter for the IN operator\n+**                     that should be populated in addition to the\n+**                     pDest->iSDParm table.  This SRT is used to\n+**                     implement \"IN (SELECT ...)\".\n@@ -19736,0 +20144,2 @@\n+  u8 bHasWith;         \/* True if statement contains WITH *\/\n+  u8 mSubrtnSig;       \/* mini Bloom filter on available SubrtnSig.selId *\/\n@@ -19814,1 +20224,0 @@\n-#ifndef SQLITE_OMIT_EXPLAIN\n@@ -19816,1 +20225,0 @@\n-#endif\n@@ -20031,1 +20439,1 @@\n-** An objected used to accumulate the text of a string where we\n+** An object used to accumulate the text of a string where we\n@@ -20045,1 +20453,1 @@\n-#define SQLITE_PRINTF_MALLOCED 0x04  \/* True if xText is allocated space *\/\n+#define SQLITE_PRINTF_MALLOCED 0x04  \/* True if zText is allocated space *\/\n@@ -20123,1 +20531,0 @@\n-  u8 bUseLongDouble;                \/* Make use of long double *\/\n@@ -20415,0 +20822,3 @@\n+SQLITE_PRIVATE Select *sqlite3MultiValues(Parse *pParse, Select *pLeft, ExprList *pRow);\n+SQLITE_PRIVATE void sqlite3MultiValuesEnd(Parse *pParse, Select *pVal);\n+\n@@ -20495,9 +20905,0 @@\n-\/*\n-** The ctype.h header is needed for non-ASCII systems.  It is also\n-** needed by FTS3 when FTS3 is included in the amalgamation.\n-*\/\n-#if !defined(SQLITE_ASCII) || \\\n-    (defined(SQLITE_ENABLE_FTS3) && defined(SQLITE_AMALGAMATION))\n-# include <ctype.h>\n-#endif\n-\n@@ -20732,0 +21133,1 @@\n+SQLITE_PRIVATE void sqlite3DequoteNumber(Parse*, Expr*);\n@@ -20762,1 +21164,1 @@\n-SQLITE_PRIVATE void sqlite3ExprDeferredDelete(Parse*, Expr*);\n+SQLITE_PRIVATE int sqlite3ExprDeferredDelete(Parse*, Expr*);\n@@ -20881,0 +21283,3 @@\n+SQLITE_PRIVATE void sqlite3SubqueryDelete(sqlite3*,Subquery*);\n+SQLITE_PRIVATE Select *sqlite3SubqueryDetach(sqlite3*,SrcItem*);\n+SQLITE_PRIVATE int sqlite3SrcItemAttachSubquery(Parse*, SrcItem*, Select*, int);\n@@ -20930,0 +21335,1 @@\n+SQLITE_PRIVATE void sqlite3ExprToRegister(Expr *pExpr, int iReg);\n@@ -20985,2 +21391,1 @@\n-SQLITE_PRIVATE int sqlite3ExprIsConstant(Expr*);\n-SQLITE_PRIVATE int sqlite3ExprIsConstantNotJoin(Expr*);\n+SQLITE_PRIVATE int sqlite3ExprIsConstant(Parse*,Expr*);\n@@ -20989,2 +21394,1 @@\n-SQLITE_PRIVATE int sqlite3ExprIsTableConstant(Expr*,int);\n-SQLITE_PRIVATE int sqlite3ExprIsSingleTableConstraint(Expr*,const SrcList*,int);\n+SQLITE_PRIVATE int sqlite3ExprIsSingleTableConstraint(Expr*,const SrcList*,int,int);\n@@ -20994,1 +21398,1 @@\n-SQLITE_PRIVATE int sqlite3ExprIsInteger(const Expr*, int*);\n+SQLITE_PRIVATE int sqlite3ExprIsInteger(const Expr*, int*, Parse*);\n@@ -21122,1 +21526,1 @@\n-SQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *pData, int nChar);\n+SQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *pData, int nByte, int nChar);\n@@ -21175,0 +21579,1 @@\n+#if !defined(SQLITE_OMIT_BLOB_LITERAL)\n@@ -21176,0 +21581,1 @@\n+#endif\n@@ -22106,0 +22512,3 @@\n+#ifdef SQLITE_ENABLE_ORDERED_SET_AGGREGATES\n+  \"ENABLE_ORDERED_SET_AGGREGATES\",\n+#endif\n@@ -22575,3 +22984,0 @@\n-#ifdef SQLITE_USER_AUTHENTICATION\n-  \"USER_AUTHENTICATION\",\n-#endif\n@@ -22853,1 +23259,0 @@\n-   sizeof(LONGDOUBLE_TYPE)>8, \/* bUseLongDouble *\/\n@@ -23277,0 +23682,1 @@\n+  u8  bScopy;         \/* The pScopyFrom of some other Mem *might* point here *\/\n@@ -23426,1 +23832,1 @@\n-  u8 argc;                \/* Number of arguments *\/\n+  u16 argc;               \/* Number of arguments *\/\n@@ -23573,0 +23979,1 @@\n+  Mem oldipk;                     \/* Memory cell holding \"old\" IPK value *\/\n@@ -23576,0 +23983,1 @@\n+  sqlite3_value **apDflt;         \/* Array of default values, if required *\/\n@@ -24222,1 +24630,0 @@\n-  char rawS;          \/* Raw numeric value stored in s *\/\n@@ -24225,4 +24632,6 @@\n-  char validTZ;       \/* True (1) if tz is valid *\/\n-  char tzSet;         \/* Timezone was set explicitly *\/\n-  char isError;       \/* An overflow has occurred *\/\n-  char useSubsec;     \/* Display subsecond precision *\/\n+  char nFloor;            \/* Days to implement \"floor\" *\/\n+  unsigned rawS      : 1; \/* Raw numeric value stored in s *\/\n+  unsigned isError   : 1; \/* An overflow has occurred *\/\n+  unsigned useSubsec : 1; \/* Display subsecond precision *\/\n+  unsigned isUtc     : 1; \/* Time is known to be UTC *\/\n+  unsigned isLocal   : 1; \/* Time is known to be localtime *\/\n@@ -24326,0 +24735,2 @@\n+    p->isLocal = 0;\n+    p->isUtc = 1;\n@@ -24338,1 +24749,0 @@\n-  p->tzSet = 1;\n@@ -24371,0 +24781,3 @@\n+      \/* Truncate to avoid problems with sub-milliseconds\n+      ** rounding. https:\/\/sqlite.org\/forum\/forumpost\/766a2c9231 *\/\n+      if( ms>0.999 ) ms = 0.999;\n@@ -24382,1 +24795,0 @@\n-  p->validTZ = (p->tz!=0)?1:0;\n@@ -24421,2 +24833,2 @@\n-  A = Y\/100;\n-  B = 2 - A + (A\/4);\n+  A = (Y+4800)\/100;\n+  B = 38 - A + (A\/4);\n@@ -24429,1 +24841,1 @@\n-    if( p->validTZ ){\n+    if( p->tz ){\n@@ -24433,1 +24845,3 @@\n-      p->validTZ = 0;\n+      p->tz = 0;\n+      p->isUtc = 1;\n+      p->isLocal = 0;\n@@ -24438,0 +24852,23 @@\n+\/*\n+** Given the YYYY-MM-DD information current in p, determine if there\n+** is day-of-month overflow and set nFloor to the number of days that\n+** would need to be subtracted from the date in order to bring the\n+** date back to the end of the month.\n+*\/\n+static void computeFloor(DateTime *p){\n+  assert( p->validYMD || p->isError );\n+  assert( p->D>=0 && p->D<=31 );\n+  assert( p->M>=0 && p->M<=12 );\n+  if( p->D<=28 ){\n+    p->nFloor = 0;\n+  }else if( (1<<p->M) & 0x15aa ){\n+    p->nFloor = 0;\n+  }else if( p->M!=2 ){\n+    p->nFloor = (p->D==31);\n+  }else if( p->Y%4!=0 || (p->Y%100==0 && p->Y%400!=0) ){\n+    p->nFloor = p->D - 28;\n+  }else{\n+    p->nFloor = p->D - 29;\n+  }\n+}\n+\n@@ -24476,1 +24913,2 @@\n-  if( p->validTZ ){\n+  computeFloor(p);\n+  if( p->tz ){\n@@ -24482,0 +24920,3 @@\n+\n+static void clearYMD_HMS_TZ(DateTime *p);  \/* Forward declaration *\/\n+\n@@ -24491,0 +24932,3 @@\n+    p->isUtc = 1;\n+    p->isLocal = 0;\n+    clearYMD_HMS_TZ(p);\n@@ -24574,1 +25018,1 @@\n-  int Z, A, B, C, D, E, X1;\n+  int Z, alpha, A, B, C, D, E, X1;\n@@ -24585,2 +25029,2 @@\n-    A = (int)((Z - 1867216.25)\/36524.25);\n-    A = Z + 1 + A - (A\/4);\n+    alpha = (int)((Z + 32044.75)\/36524.25) - 52;\n+    A = Z + 1 + alpha - ((alpha+100)\/4) + 25;\n@@ -24629,1 +25073,1 @@\n-  p->validTZ = 0;\n+  p->tz = 0;\n@@ -24761,1 +25205,1 @@\n-  p->validTZ = 0;\n+  p->tz = 0;\n@@ -24781,6 +25225,6 @@\n-  { 6, \"second\", 4.6427e+14,       1.0  },\n-  { 6, \"minute\", 7.7379e+12,      60.0  },\n-  { 4, \"hour\",   1.2897e+11,    3600.0  },\n-  { 3, \"day\",    5373485.0,    86400.0  },\n-  { 5, \"month\",  176546.0,   2592000.0  },\n-  { 4, \"year\",   14713.0,   31536000.0  },\n+  \/* 0 *\/ { 6, \"second\",   4.6427e+14,         1.0  },\n+  \/* 1 *\/ { 6, \"minute\",   7.7379e+12,        60.0  },\n+  \/* 2 *\/ { 4, \"hour\",     1.2897e+11,      3600.0  },\n+  \/* 3 *\/ { 3, \"day\",      5373485.0,      86400.0  },\n+  \/* 4 *\/ { 5, \"month\",    176546.0,     2592000.0  },\n+  \/* 5 *\/ { 4, \"year\",     14713.0,     31536000.0  },\n@@ -24818,0 +25262,3 @@\n+**     +\/-YYYY-MM-DD HH:MM:SS.SSS\n+**     ceiling\n+**     floor\n@@ -24824,0 +25271,1 @@\n+**     auto\n@@ -24826,0 +25274,2 @@\n+**     subsec\n+**     subsecond\n@@ -24856,0 +25306,31 @@\n+    case 'c': {\n+      \/*\n+      **    ceiling\n+      **\n+      ** Resolve day-of-month overflow by rolling forward into the next\n+      ** month.  As this is the default action, this modifier is really\n+      ** a no-op that is only included for symmetry.  See \"floor\".\n+      *\/\n+      if( sqlite3_stricmp(z, \"ceiling\")==0 ){\n+        computeJD(p);\n+        clearYMD_HMS_TZ(p);\n+        rc = 0;\n+        p->nFloor = 0;\n+      }\n+      break;\n+    }\n+    case 'f': {\n+      \/*\n+      **    floor\n+      **\n+      ** Resolve day-of-month overflow by rolling back to the end of the\n+      ** previous month.\n+      *\/\n+      if( sqlite3_stricmp(z, \"floor\")==0 ){\n+        computeJD(p);\n+        p->iJD -= p->nFloor*86400000;\n+        clearYMD_HMS_TZ(p);\n+        rc = 0;\n+      }\n+      break;\n+    }\n@@ -24882,1 +25363,3 @@\n-        rc = toLocaltime(p, pCtx);\n+        rc = p->isLocal ? SQLITE_OK : toLocaltime(p, pCtx);\n+        p->isUtc = 0;\n+        p->isLocal = 1;\n@@ -24907,1 +25390,1 @@\n-        if( p->tzSet==0 ){\n+        if( p->isUtc==0 ){\n@@ -24930,1 +25413,2 @@\n-          p->tzSet = 1;\n+          p->isUtc = 1;\n+          p->isLocal = 0;\n@@ -24950,1 +25434,1 @@\n-        p->validTZ = 0;\n+        p->tz = 0;\n@@ -24990,1 +25474,1 @@\n-      p->validTZ = 0;\n+      p->tz = 0;\n@@ -25061,0 +25545,1 @@\n+        computeFloor(p);\n@@ -25107,1 +25592,1 @@\n-      if( n>10 || n<3 ) break;\n+      if( n<3 || n>10 ) break;\n@@ -25112,0 +25597,1 @@\n+      p->nFloor = 0;\n@@ -25119,1 +25605,1 @@\n-              assert( strcmp(aXformType[i].zName,\"month\")==0 );\n+              assert( strcmp(aXformType[4].zName,\"month\")==0 );\n@@ -25125,0 +25611,1 @@\n+              computeFloor(p);\n@@ -25131,1 +25618,1 @@\n-              assert( strcmp(aXformType[i].zName,\"year\")==0 );\n+              assert( strcmp(aXformType[5].zName,\"year\")==0 );\n@@ -25133,0 +25620,1 @@\n+              assert( p->M>=0 && p->M<=12 );\n@@ -25134,0 +25622,1 @@\n+              computeFloor(p);\n@@ -25387,0 +25876,47 @@\n+\/*\n+** Compute the number of days after the most recent January 1.\n+**\n+** In other words, compute the zero-based day number for the\n+** current year:\n+**\n+**   Jan01 = 0,  Jan02 = 1, ..., Jan31 = 30, Feb01 = 31, ...\n+**   Dec31 = 364 or 365.\n+*\/\n+static int daysAfterJan01(DateTime *pDate){\n+  DateTime jan01 = *pDate;\n+  assert( jan01.validYMD );\n+  assert( jan01.validHMS );\n+  assert( pDate->validJD );\n+  jan01.validJD = 0;\n+  jan01.M = 1;\n+  jan01.D = 1;\n+  computeJD(&jan01);\n+  return (int)((pDate->iJD-jan01.iJD+43200000)\/86400000);\n+}\n+\n+\/*\n+** Return the number of days after the most recent Monday.\n+**\n+** In other words, return the day of the week according\n+** to this code:\n+**\n+**   0=Monday, 1=Tuesday, 2=Wednesday, ..., 6=Sunday.\n+*\/\n+static int daysAfterMonday(DateTime *pDate){\n+  assert( pDate->validJD );\n+  return (int)((pDate->iJD+43200000)\/86400000) % 7;\n+}\n+\n+\/*\n+** Return the number of days after the most recent Sunday.\n+**\n+** In other words, return the day of the week according\n+** to this code:\n+**\n+**   0=Sunday, 1=Monday, 2=Tues, ..., 6=Saturday\n+*\/\n+static int daysAfterSunday(DateTime *pDate){\n+  assert( pDate->validJD );\n+  return (int)((pDate->iJD+129600000)\/86400000) % 7;\n+}\n+\n@@ -25392,1 +25928,2 @@\n-**   %d  day of month\n+**   %d  day of month  01-31\n+**   %e  day of month  1-31\n@@ -25394,0 +25931,3 @@\n+**   %F  ISO date.  YYYY-MM-DD\n+**   %G  ISO year corresponding to %V 0000-9999.\n+**   %g  2-digit ISO year corresponding to %V 00-99\n@@ -25395,1 +25935,3 @@\n-**   %j  day of year 000-366\n+**   %k  hour  0-24  (leading zero converted to space)\n+**   %I  hour 01-12\n+**   %j  day of year 001-366\n@@ -25397,0 +25939,1 @@\n+**   %l  hour  1-12  (leading zero converted to space)\n@@ -25399,0 +25942,3 @@\n+**   %p  \"am\" or \"pm\"\n+**   %P  \"AM\" or \"PM\"\n+**   %R  time as HH:MM\n@@ -25401,2 +25947,6 @@\n-**   %w  day of week 0-6  Sunday==0\n-**   %W  week of year 00-53\n+**   %T  time as HH:MM:SS\n+**   %u  day of week 1-7  Monday==1, Sunday==7\n+**   %w  day of week 0-6  Sunday==0, Monday==1\n+**   %U  week of year 00-53  (First Sunday is start of week 01)\n+**   %V  week of year 01-53  (First week containing Thursday is week 01)\n+**   %W  week of year 00-53  (First Monday is start of week 01)\n@@ -25439,1 +25989,1 @@\n-      case 'f': {\n+      case 'f': {  \/* Fractional seconds.  (Non-standard) *\/\n@@ -25441,1 +25991,1 @@\n-        if( s>59.999 ) s = 59.999;\n+        if( NEVER(s>59.999) ) s = 59.999;\n@@ -25449,0 +25999,15 @@\n+      case 'G': \/* Fall thru *\/\n+      case 'g': {\n+        DateTime y = x;\n+        assert( y.validJD );\n+        \/* Move y so that it is the Thursday in the same week as x *\/\n+        y.iJD += (3 - daysAfterMonday(&x))*86400000;\n+        y.validYMD = 0;\n+        computeYMD(&y);\n+        if( cf=='g' ){\n+          sqlite3_str_appendf(&sRes, \"%02d\", y.Y%100);\n+        }else{\n+          sqlite3_str_appendf(&sRes, \"%04d\", y.Y);\n+        }\n+        break;\n+      }\n@@ -25462,16 +26027,2 @@\n-      case 'W': \/* Fall thru *\/\n-      case 'j': {\n-        int nDay;             \/* Number of days since 1st day of year *\/\n-        DateTime y = x;\n-        y.validJD = 0;\n-        y.M = 1;\n-        y.D = 1;\n-        computeJD(&y);\n-        nDay = (int)((x.iJD-y.iJD+43200000)\/86400000);\n-        if( cf=='W' ){\n-          int wd;   \/* 0=Monday, 1=Tuesday, ... 6=Sunday *\/\n-          wd = (int)(((x.iJD+43200000)\/86400000)%7);\n-          sqlite3_str_appendf(&sRes,\"%02d\",(nDay+7-wd)\/7);\n-        }else{\n-          sqlite3_str_appendf(&sRes,\"%03d\",nDay+1);\n-        }\n+      case 'j': {  \/* Day of year.  Jan01==1, Jan02==2, and so forth *\/\n+        sqlite3_str_appendf(&sRes,\"%03d\",daysAfterJan01(&x)+1);\n@@ -25480,1 +26031,1 @@\n-      case 'J': {\n+      case 'J': {  \/* Julian day number.  (Non-standard) *\/\n@@ -25523,3 +26074,3 @@\n-      case 'u': \/* Fall thru *\/\n-      case 'w': {\n-        char c = (char)(((x.iJD+129600000)\/86400000) % 7) + '0';\n+      case 'u':    \/* Day of week.  1 to 7.  Monday==1, Sunday==7 *\/\n+      case 'w': {  \/* Day of week.  0 to 6.  Sunday==0, Monday==1 *\/\n+        char c = (char)daysAfterSunday(&x) + '0';\n@@ -25530,0 +26081,20 @@\n+      case 'U': {  \/* Week num. 00-53. First Sun of the year is week 01 *\/\n+        sqlite3_str_appendf(&sRes,\"%02d\",\n+              (daysAfterJan01(&x)-daysAfterSunday(&x)+7)\/7);\n+        break;\n+      }\n+      case 'V': {  \/* Week num. 01-53. First week with a Thur is week 01 *\/\n+        DateTime y = x;\n+        \/* Adjust y so that is the Thursday in the same week as x *\/\n+        assert( y.validJD );\n+        y.iJD += (3 - daysAfterMonday(&x))*86400000;\n+        y.validYMD = 0;\n+        computeYMD(&y);\n+        sqlite3_str_appendf(&sRes,\"%02d\", daysAfterJan01(&y)\/7+1);\n+        break;\n+      }\n+      case 'W': {  \/* Week num. 00-53. First Mon of the year is week 01 *\/\n+        sqlite3_str_appendf(&sRes,\"%02d\",\n+           (daysAfterJan01(&x)-daysAfterMonday(&x)+7)\/7);\n+        break;\n+      }\n@@ -25676,3 +26247,1 @@\n-  d1.validYMD = 0;\n-  d1.validHMS = 0;\n-  d1.validTZ = 0;\n+  clearYMD_HMS_TZ(&d1);\n@@ -25747,0 +26316,30 @@\n+#if !defined(SQLITE_OMIT_DATETIME_FUNCS) && defined(SQLITE_DEBUG)\n+\/*\n+**   datedebug(...)\n+**\n+** This routine returns JSON that describes the internal DateTime object.\n+** Used for debugging and testing only.  Subject to change.\n+*\/\n+static void datedebugFunc(\n+  sqlite3_context *context,\n+  int argc,\n+  sqlite3_value **argv\n+){\n+  DateTime x;\n+  if( isDate(context, argc, argv, &x)==0 ){\n+    char *zJson;\n+    zJson = sqlite3_mprintf(\n+      \"{iJD:%lld,Y:%d,M:%d,D:%d,h:%d,m:%d,tz:%d,\"\n+      \"s:%.3f,validJD:%d,validYMS:%d,validHMS:%d,\"\n+      \"nFloor:%d,rawS:%d,isError:%d,useSubsec:%d,\"\n+      \"isUtc:%d,isLocal:%d}\",\n+      x.iJD, x.Y, x.M, x.D, x.h, x.m, x.tz,\n+      x.s, x.validJD, x.validYMD, x.validHMS,\n+      x.nFloor, x.rawS, x.isError, x.useSubsec,\n+      x.isUtc, x.isLocal);\n+    sqlite3_result_text(context, zJson, -1, sqlite3_free);\n+  }\n+}\n+#endif \/* !SQLITE_OMIT_DATETIME_FUNCS && SQLITE_DEBUG *\/\n+\n+\n@@ -25762,0 +26361,3 @@\n+#ifdef SQLITE_DEBUG\n+    PURE_DATE(datedebug,        -1, 0, 0, datedebugFunc ),\n+#endif\n@@ -28830,0 +29432,3 @@\n+**\n+** Because these routines raise false-positive alerts in TSAN, disable\n+** them (make them always return 1) when compiling with TSAN.\n@@ -28832,0 +29437,5 @@\n+# if defined(__has_feature)\n+#   if __has_feature(thread_sanitizer)\n+      p = 0;\n+#   endif\n+# endif\n@@ -28836,0 +29446,5 @@\n+# if defined(__has_feature)\n+#   if __has_feature(thread_sanitizer)\n+      p = 0;\n+#   endif\n+# endif\n@@ -28839,1 +29454,1 @@\n-#endif\n+#endif \/* NDEBUG *\/\n@@ -30177,0 +30792,18 @@\n+#ifdef SQLITE_DEBUG\n+\/*\n+** This routine is called whenever an out-of-memory condition is seen,\n+** It's only purpose to to serve as a breakpoint for gdb or similar\n+** code debuggers when working on out-of-memory conditions, for example\n+** caused by PRAGMA hard_heap_limit=N.\n+*\/\n+static SQLITE_NOINLINE void test_oom_breakpoint(u64 n){\n+  static u64 nOomFault = 0;\n+  nOomFault += n;\n+  \/* The assert() is never reached in a human lifetime.  It  is here mostly\n+  ** to prevent code optimizers from optimizing out this function. *\/\n+  assert( (nOomFault>>32) < 0xffffffff );\n+}\n+#else\n+# define test_oom_breakpoint(X)   \/* No-op for production builds *\/\n+#endif\n+\n@@ -30203,0 +30836,1 @@\n+          test_oom_breakpoint(1);\n@@ -30491,0 +31125,1 @@\n+        test_oom_breakpoint(1);\n@@ -31393,1 +32028,0 @@\n-        if( xtype==etGENERIC && precision>0 ) precision--;\n@@ -31400,0 +32034,2 @@\n+          assert( precision>0 );\n+          precision--;\n@@ -31706,2 +32342,5 @@\n-          if( pItem->zDatabase ){\n-            sqlite3_str_appendall(pAccum, pItem->zDatabase);\n+          if( pItem->fg.fixedSchema==0\n+           && pItem->fg.isSubquery==0\n+           && pItem->u4.zDatabase!=0\n+          ){\n+            sqlite3_str_appendall(pAccum, pItem->u4.zDatabase);\n@@ -31713,2 +32352,2 @@\n-        }else{\n-          Select *pSel = pItem->pSelect;\n+        }else if( ALWAYS(pItem->fg.isSubquery) ){\/* Because of tag-20240424-1 *\/\n+          Select *pSel = pItem->u4.pSubq->pSelect;\n@@ -31718,0 +32357,4 @@\n+          }else if( pSel->selFlags & SF_MultiValue ){\n+            assert( !pItem->fg.isTabFunc && !pItem->fg.isIndexedBy );\n+            sqlite3_str_appendf(pAccum, \"%u-ROW VALUES CLAUSE\",\n+                                pItem->u1.nRow);\n@@ -31789,0 +32432,1 @@\n+  if( ExprHasProperty(pExpr, EP_FromDDL) ) return;\n@@ -32493,3 +33137,5 @@\n-    if( pItem->pTab ){\n-      sqlite3_str_appendf(&x, \" tab=%Q nCol=%d ptr=%p used=%llx\",\n-           pItem->pTab->zName, pItem->pTab->nCol, pItem->pTab, pItem->colUsed);\n+    if( pItem->pSTab ){\n+      sqlite3_str_appendf(&x, \" tab=%Q nCol=%d ptr=%p used=%llx%s\",\n+           pItem->pSTab->zName, pItem->pSTab->nCol, pItem->pSTab,\n+           pItem->colUsed,\n+           pItem->fg.rowidUsed ? \"+rowid\" : \"\");\n@@ -32513,1 +33159,4 @@\n-      sqlite3_str_appendf(&x, \" CteUse=0x%p\", pItem->u2.pCteUse);\n+      static const char *aMat[] = {\",MAT\", \"\", \",NO-MAT\"};\n+      sqlite3_str_appendf(&x, \" CteUse=%d%s\",\n+                          pItem->u2.pCteUse->nUse,\n+                          aMat[pItem->u2.pCteUse->eM10d]);\n@@ -32516,1 +33165,1 @@\n-      sqlite3_str_appendf(&x, \" ON\");\n+      sqlite3_str_appendf(&x, \" isOn\");\n@@ -32524,0 +33173,3 @@\n+    if( pItem->fg.fixedSchema )    sqlite3_str_appendf(&x, \" fixedSchema\");\n+    if( pItem->fg.hadSchema )      sqlite3_str_appendf(&x, \" hadSchema\");\n+    if( pItem->fg.isSubquery )     sqlite3_str_appendf(&x, \" isSubquery\");\n@@ -32528,1 +33180,1 @@\n-    if( pItem->pSelect ) n++;\n+    if( pItem->fg.isSubquery ) n++;\n@@ -32534,3 +33186,4 @@\n-    if( pItem->pSelect ){\n-      if( pItem->pTab ){\n-        Table *pTab = pItem->pTab;\n+    if( pItem->fg.isSubquery ){\n+      assert( n==1 );\n+      if( pItem->pSTab ){\n+        Table *pTab = pItem->pSTab;\n@@ -32539,2 +33192,2 @@\n-      assert( (int)pItem->fg.isNestedFrom == IsNestedFrom(pItem->pSelect) );\n-      sqlite3TreeViewSelect(pView, pItem->pSelect, (--n)>0);\n+      assert( (int)pItem->fg.isNestedFrom == IsNestedFrom(pItem) );\n+      sqlite3TreeViewSelect(pView, pItem->u4.pSubq->pSelect, 0);\n@@ -32582,1 +33235,1 @@\n-      if( p->pSrc && p->pSrc->nSrc ) n++;\n+      if( p->pSrc && p->pSrc->nSrc && p->pSrc->nAlloc ) n++;\n@@ -32608,1 +33261,1 @@\n-    if( p->pSrc && p->pSrc->nSrc ){\n+    if( p->pSrc && p->pSrc->nSrc && p->pSrc->nAlloc ){\n@@ -32644,1 +33297,1 @@\n-        sqlite3TreeViewItem(pView, \"OFFSET\", (n--)>0);\n+        sqlite3TreeViewItem(pView, \"OFFSET\", 0);\n@@ -33116,1 +33769,2 @@\n-      sqlite3TreeViewLine(pView, \"RAISE %s(%Q)\", zType, pExpr->u.zToken);\n+      sqlite3TreeViewLine(pView, \"RAISE %s\", zType);\n+      sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);\n@@ -33196,0 +33850,1 @@\n+      u8 sortFlags = pList->a[i].fg.sortFlags;\n@@ -33198,1 +33853,1 @@\n-      if( j || zName ){\n+      if( j || zName || sortFlags ){\n@@ -33219,1 +33874,6 @@\n-          fprintf(stdout, \"iOrderByCol=%d\", j);\n+          fprintf(stdout, \"iOrderByCol=%d \", j);\n+        }\n+        if( sortFlags & KEYINFO_ORDER_DESC ){\n+          fprintf(stdout, \"DESC \");\n+        }else if( sortFlags & KEYINFO_ORDER_BIGNULL ){\n+          fprintf(stdout, \"NULLS-LAST\");\n@@ -33225,1 +33885,1 @@\n-      if( j || zName ){\n+      if( j || zName || sortFlags ){\n@@ -33262,15 +33922,1 @@\n-      if( pList->eU4==EU4_NONE ){\n-        fprintf(stdout, \"%s\\n\", zName);\n-      }else if( pList->eU4==EU4_IDX ){\n-        fprintf(stdout, \"%s (%d)\\n\", zName, pList->a[i].u4.idx);\n-      }else{\n-        assert( pList->eU4==EU4_EXPR );\n-        if( pList->a[i].u4.pExpr==0 ){\n-          fprintf(stdout, \"%s (pExpr=NULL)\\n\", zName);\n-        }else{\n-          fprintf(stdout, \"%s\\n\", zName);\n-          sqlite3TreeViewPush(&pView, i<pList->nId-1);\n-          sqlite3TreeViewExpr(pView, pList->a[i].u4.pExpr, 0);\n-          sqlite3TreeViewPop(&pView);\n-        }\n-      }\n+      fprintf(stdout, \"%s\\n\", zName);\n@@ -33586,0 +34232,4 @@\n+**\n+** See Also:\n+**\n+**     sqlite3ShowWhereTerm() in where.c\n@@ -34188,1 +34838,1 @@\n-    while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){            \\\n+    while( zIn<zTerm && (*zIn & 0xc0)==0x80 ){             \\\n@@ -34566,1 +35216,1 @@\n-** zIn is a UTF-16 encoded unicode string at least nChar characters long.\n+** zIn is a UTF-16 encoded unicode string at least nByte bytes long.\n@@ -34568,1 +35218,2 @@\n-** in pZ.  nChar must be non-negative.\n+** in pZ.  nChar must be non-negative.  Surrogate pairs count as a single\n+** character.\n@@ -34570,1 +35221,1 @@\n-SQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *zIn, int nChar){\n+SQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *zIn, int nByte, int nChar){\n@@ -34573,0 +35224,1 @@\n+  unsigned char const *zEnd = &z[nByte-1];\n@@ -34576,1 +35228,1 @@\n-  while( n<nChar ){\n+  while( n<nChar && ALWAYS(z<=zEnd) ){\n@@ -34579,1 +35231,1 @@\n-    if( c>=0xd8 && c<0xdc && z[0]>=0xdc && z[0]<0xe0 ) z += 2;\n+    if( c>=0xd8 && c<0xdc && z<=zEnd && z[0]>=0xdc && z[0]<0xe0 ) z += 2;\n@@ -34945,0 +35597,38 @@\n+\/*\n+** Expression p is a QNUMBER (quoted number). Dequote the value in p->u.zToken\n+** and set the type to INTEGER or FLOAT. \"Quoted\" integers or floats are those\n+** that contain '_' characters that must be removed before further processing.\n+*\/\n+SQLITE_PRIVATE void sqlite3DequoteNumber(Parse *pParse, Expr *p){\n+  assert( p!=0 || pParse->db->mallocFailed );\n+  if( p ){\n+    const char *pIn = p->u.zToken;\n+    char *pOut = p->u.zToken;\n+    int bHex = (pIn[0]=='0' && (pIn[1]=='x' || pIn[1]=='X'));\n+    int iValue;\n+    assert( p->op==TK_QNUMBER );\n+    p->op = TK_INTEGER;\n+    do {\n+      if( *pIn!=SQLITE_DIGIT_SEPARATOR ){\n+        *pOut++ = *pIn;\n+        if( *pIn=='e' || *pIn=='E' || *pIn=='.' ) p->op = TK_FLOAT;\n+      }else{\n+        if( (bHex==0 && (!sqlite3Isdigit(pIn[-1]) || !sqlite3Isdigit(pIn[1])))\n+         || (bHex==1 && (!sqlite3Isxdigit(pIn[-1]) || !sqlite3Isxdigit(pIn[1])))\n+        ){\n+          sqlite3ErrorMsg(pParse, \"unrecognized token: \\\"%s\\\"\", p->u.zToken);\n+        }\n+      }\n+    }while( *pIn++ );\n+    if( bHex ) p->op = TK_INTEGER;\n+\n+    \/* tag-20240227-a: If after dequoting, the number is an integer that\n+    ** fits in 32 bits, then it must be converted into EP_IntValue.  Other\n+    ** parts of the code expect this.  See also tag-20240227-b. *\/\n+    if( p->op==TK_INTEGER && sqlite3GetInt32(p->u.zToken, &iValue) ){\n+      p->u.iValue = iValue;\n+      p->flags |= EP_IntValue;\n+    }\n+  }\n+}\n+\n@@ -35122,0 +35812,2 @@\n+  u64 s2;          \/* round-tripped significand *\/\n+  double rr[2];\n@@ -35224,1 +35916,1 @@\n-  while( e>0 && s<(LARGEST_UINT64\/10) ){\n+  while( e>0 && s<((LARGEST_UINT64-0x7ff)\/10) ){\n@@ -35233,19 +35925,6 @@\n-  if( e==0 ){\n-    *pResult = s;\n-  }else if( sqlite3Config.bUseLongDouble ){\n-    LONGDOUBLE_TYPE r = (LONGDOUBLE_TYPE)s;\n-    if( e>0 ){\n-      while( e>=100  ){ e-=100; r *= 1.0e+100L; }\n-      while( e>=10   ){ e-=10;  r *= 1.0e+10L;  }\n-      while( e>=1    ){ e-=1;   r *= 1.0e+01L;  }\n-    }else{\n-      while( e<=-100 ){ e+=100; r *= 1.0e-100L; }\n-      while( e<=-10  ){ e+=10;  r *= 1.0e-10L;  }\n-      while( e<=-1   ){ e+=1;   r *= 1.0e-01L;  }\n-    }\n-    assert( r>=0.0 );\n-    if( r>+1.7976931348623157081452742373e+308L ){\n-#ifdef INFINITY\n-      *pResult = +INFINITY;\n-#else\n-      *pResult = 1.0e308*10.0;\n+  rr[0] = (double)s;\n+  assert( sizeof(s2)==sizeof(rr[0]) );\n+#ifdef SQLITE_DEBUG\n+  rr[1] = 18446744073709549568.0;\n+  memcpy(&s2, &rr[1], sizeof(s2));\n+  assert( s2==0x43efffffffffffffLL );\n@@ -35253,7 +35932,3 @@\n-    }else{\n-      *pResult = (double)r;\n-    }\n-  }else{\n-    double rr[2];\n-    u64 s2;\n-    rr[0] = (double)s;\n+  \/* Largest double that can be safely converted to u64\n+  **         vvvvvvvvvvvvvvvvvvvvvv   *\/\n+  if( rr[0]<=18446744073709549568.0 ){\n@@ -35261,3 +35936,0 @@\n-#if defined(_MSC_VER) && _MSC_VER<1700\n-    if( s2==0x8000000000000000LL ){ s2 = 2*(u64)(0.5*rr[0]); }\n-#endif\n@@ -35265,26 +35937,30 @@\n-    if( e>0 ){\n-      while( e>=100  ){\n-        e -= 100;\n-        dekkerMul2(rr, 1.0e+100, -1.5902891109759918046e+83);\n-      }\n-      while( e>=10   ){\n-        e -= 10;\n-        dekkerMul2(rr, 1.0e+10, 0.0);\n-      }\n-      while( e>=1    ){\n-        e -= 1;\n-        dekkerMul2(rr, 1.0e+01, 0.0);\n-      }\n-    }else{\n-      while( e<=-100 ){\n-        e += 100;\n-        dekkerMul2(rr, 1.0e-100, -1.99918998026028836196e-117);\n-      }\n-      while( e<=-10  ){\n-        e += 10;\n-        dekkerMul2(rr, 1.0e-10, -3.6432197315497741579e-27);\n-      }\n-      while( e<=-1   ){\n-        e += 1;\n-        dekkerMul2(rr, 1.0e-01, -5.5511151231257827021e-18);\n-      }\n+  }else{\n+    rr[1] = 0.0;\n+  }\n+  assert( rr[1]<=1.0e-10*rr[0] );  \/* Equal only when rr[0]==0.0 *\/\n+\n+  if( e>0 ){\n+    while( e>=100  ){\n+      e -= 100;\n+      dekkerMul2(rr, 1.0e+100, -1.5902891109759918046e+83);\n+    }\n+    while( e>=10   ){\n+      e -= 10;\n+      dekkerMul2(rr, 1.0e+10, 0.0);\n+    }\n+    while( e>=1    ){\n+      e -= 1;\n+      dekkerMul2(rr, 1.0e+01, 0.0);\n+    }\n+  }else{\n+    while( e<=-100 ){\n+      e += 100;\n+      dekkerMul2(rr, 1.0e-100, -1.99918998026028836196e-117);\n+    }\n+    while( e<=-10  ){\n+      e += 10;\n+      dekkerMul2(rr, 1.0e-10, -3.6432197315497741579e-27);\n+    }\n+    while( e<=-1   ){\n+      e += 1;\n+      dekkerMul2(rr, 1.0e-01, -5.5511151231257827021e-18);\n@@ -35292,2 +35968,0 @@\n-    *pResult = rr[0]+rr[1];\n-    if( sqlite3IsNaN(*pResult) ) *pResult = 1e300*1e300;\n@@ -35295,0 +35969,2 @@\n+  *pResult = rr[0]+rr[1];\n+  if( sqlite3IsNaN(*pResult) ) *pResult = 1e300*1e300;\n@@ -35598,4 +36274,7 @@\n-** Round the decimal representation to n significant digits if\n-** n is positive.  Or round to -n signficant digits after the\n-** decimal point if n is negative.  No rounding is performed if\n-** n is zero.\n+** If iRound<=0 then round to -iRound significant digits to the\n+** the left of the decimal point, or to a maximum of mxRound total\n+** significant digits.\n+**\n+** If iRound>0 round to min(iRound,mxRound) significant digits total.\n+**\n+** mxRound must be positive.\n@@ -35612,0 +36291,2 @@\n+  double rr[2];\n+\n@@ -35614,0 +36295,1 @@\n+  assert( mxRound>0 );\n@@ -35640,0 +36322,8 @@\n+  **\n+  ** Use Dekker-style double-double computation to increase the\n+  ** precision.\n+  **\n+  ** The error terms on constants like 1.0e+100 computed using the\n+  ** decimal extension, for example as follows:\n+  **\n+  **   SELECT decimal_exp(decimal_sub('1.0e+100',decimal(1.0e+100)));\n@@ -35641,10 +36331,14 @@\n-  if( sqlite3Config.bUseLongDouble ){\n-    LONGDOUBLE_TYPE rr = r;\n-    if( rr>=1.0e+19 ){\n-      while( rr>=1.0e+119L ){ exp+=100; rr *= 1.0e-100L; }\n-      while( rr>=1.0e+29L  ){ exp+=10;  rr *= 1.0e-10L;  }\n-      while( rr>=1.0e+19L  ){ exp++;    rr *= 1.0e-1L;   }\n-    }else{\n-      while( rr<1.0e-97L   ){ exp-=100; rr *= 1.0e+100L; }\n-      while( rr<1.0e+07L   ){ exp-=10;  rr *= 1.0e+10L;  }\n-      while( rr<1.0e+17L   ){ exp--;    rr *= 1.0e+1L;   }\n+  rr[0] = r;\n+  rr[1] = 0.0;\n+  if( rr[0]>9.223372036854774784e+18 ){\n+    while( rr[0]>9.223372036854774784e+118 ){\n+      exp += 100;\n+      dekkerMul2(rr, 1.0e-100, -1.99918998026028836196e-117);\n+    }\n+    while( rr[0]>9.223372036854774784e+28 ){\n+      exp += 10;\n+      dekkerMul2(rr, 1.0e-10, -3.6432197315497741579e-27);\n+    }\n+    while( rr[0]>9.223372036854774784e+18 ){\n+      exp += 1;\n+      dekkerMul2(rr, 1.0e-01, -5.5511151231257827021e-18);\n@@ -35652,1 +36346,0 @@\n-    v = (u64)rr;\n@@ -35654,38 +36347,11 @@\n-    \/* If high-precision floating point is not available using \"long double\",\n-    ** then use Dekker-style double-double computation to increase the\n-    ** precision.\n-    **\n-    ** The error terms on constants like 1.0e+100 computed using the\n-    ** decimal extension, for example as follows:\n-    **\n-    **   SELECT decimal_exp(decimal_sub('1.0e+100',decimal(1.0e+100)));\n-    *\/\n-    double rr[2];\n-    rr[0] = r;\n-    rr[1] = 0.0;\n-    if( rr[0]>9.223372036854774784e+18 ){\n-      while( rr[0]>9.223372036854774784e+118 ){\n-        exp += 100;\n-        dekkerMul2(rr, 1.0e-100, -1.99918998026028836196e-117);\n-      }\n-      while( rr[0]>9.223372036854774784e+28 ){\n-        exp += 10;\n-        dekkerMul2(rr, 1.0e-10, -3.6432197315497741579e-27);\n-      }\n-      while( rr[0]>9.223372036854774784e+18 ){\n-        exp += 1;\n-        dekkerMul2(rr, 1.0e-01, -5.5511151231257827021e-18);\n-      }\n-    }else{\n-      while( rr[0]<9.223372036854774784e-83  ){\n-        exp -= 100;\n-        dekkerMul2(rr, 1.0e+100, -1.5902891109759918046e+83);\n-      }\n-      while( rr[0]<9.223372036854774784e+07  ){\n-        exp -= 10;\n-        dekkerMul2(rr, 1.0e+10, 0.0);\n-      }\n-      while( rr[0]<9.22337203685477478e+17  ){\n-        exp -= 1;\n-        dekkerMul2(rr, 1.0e+01, 0.0);\n-      }\n+    while( rr[0]<9.223372036854774784e-83  ){\n+      exp -= 100;\n+      dekkerMul2(rr, 1.0e+100, -1.5902891109759918046e+83);\n+    }\n+    while( rr[0]<9.223372036854774784e+07  ){\n+      exp -= 10;\n+      dekkerMul2(rr, 1.0e+10, 0.0);\n+    }\n+    while( rr[0]<9.22337203685477478e+17  ){\n+      exp -= 1;\n+      dekkerMul2(rr, 1.0e+01, 0.0);\n@@ -35693,1 +36359,0 @@\n-    v = rr[1]<0.0 ? (u64)rr[0]-(u64)(-rr[1]) : (u64)rr[0]+(u64)rr[1];\n@@ -35695,1 +36360,1 @@\n-\n+  v = rr[1]<0.0 ? (u64)rr[0]-(u64)(-rr[1]) : (u64)rr[0]+(u64)rr[1];\n@@ -36466,98 +37131,0 @@\n-\/*\n-** High-resolution hardware timer used for debugging and testing only.\n-*\/\n-#if defined(VDBE_PROFILE)  \\\n- || defined(SQLITE_PERFORMANCE_TRACE) \\\n- || defined(SQLITE_ENABLE_STMT_SCANSTATUS)\n-\/************** Include hwtime.h in the middle of util.c *********************\/\n-\/************** Begin file hwtime.h ******************************************\/\n-\/*\n-** 2008 May 27\n-**\n-** The author disclaims copyright to this source code.  In place of\n-** a legal notice, here is a blessing:\n-**\n-**    May you do good and not evil.\n-**    May you find forgiveness for yourself and forgive others.\n-**    May you share freely, never taking more than you give.\n-**\n-******************************************************************************\n-**\n-** This file contains inline asm code for retrieving \"high-performance\"\n-** counters for x86 and x86_64 class CPUs.\n-*\/\n-#ifndef SQLITE_HWTIME_H\n-#define SQLITE_HWTIME_H\n-\n-\/*\n-** The following routine only works on Pentium-class (or newer) processors.\n-** It uses the RDTSC opcode to read the cycle count value out of the\n-** processor and returns that value.  This can be used for high-res\n-** profiling.\n-*\/\n-#if !defined(__STRICT_ANSI__) && \\\n-    (defined(__GNUC__) || defined(_MSC_VER)) && \\\n-    (defined(i386) || defined(__i386__) || defined(_M_IX86))\n-\n-  #if defined(__GNUC__)\n-\n-  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n-     unsigned int lo, hi;\n-     __asm__ __volatile__ (\"rdtsc\" : \"=a\" (lo), \"=d\" (hi));\n-     return (sqlite_uint64)hi << 32 | lo;\n-  }\n-\n-  #elif defined(_MSC_VER)\n-\n-  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){\n-     __asm {\n-        rdtsc\n-        ret       ; return value at EDX:EAX\n-     }\n-  }\n-\n-  #endif\n-\n-#elif !defined(__STRICT_ANSI__) && (defined(__GNUC__) && defined(__x86_64__))\n-\n-  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n-     unsigned int lo, hi;\n-     __asm__ __volatile__ (\"rdtsc\" : \"=a\" (lo), \"=d\" (hi));\n-     return (sqlite_uint64)hi << 32 | lo;\n-  }\n-\n-#elif !defined(__STRICT_ANSI__) && (defined(__GNUC__) && defined(__ppc__))\n-\n-  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n-      unsigned long long retval;\n-      unsigned long junk;\n-      __asm__ __volatile__ (\"\\n\\\n-          1:      mftbu   %1\\n\\\n-                  mftb    %L0\\n\\\n-                  mftbu   %0\\n\\\n-                  cmpw    %0,%1\\n\\\n-                  bne     1b\"\n-                  : \"=r\" (retval), \"=r\" (junk));\n-      return retval;\n-  }\n-\n-#else\n-\n-  \/*\n-  ** asm() is needed for hardware timing support.  Without asm(),\n-  ** disable the sqlite3Hwtime() routine.\n-  **\n-  ** sqlite3Hwtime() is only used for some obscure debugging\n-  ** and analysis configurations, not in any deliverable, so this\n-  ** should not be a great loss.\n-  *\/\n-SQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); }\n-\n-#endif\n-\n-#endif \/* !defined(SQLITE_HWTIME_H) *\/\n-\n-\/************** End of hwtime.h **********************************************\/\n-\/************** Continuing where we left off in util.c ***********************\/\n-#endif\n-\n@@ -36884,1 +37451,1 @@\n-    \/*  33 *\/ \"IfSmaller\"        OpHelp(\"\"),\n+    \/*  33 *\/ \"IfSizeBetween\"    OpHelp(\"\"),\n@@ -36901,10 +37468,10 @@\n-    \/*  50 *\/ \"IsNull\"           OpHelp(\"if r[P1]==NULL goto P2\"),\n-    \/*  51 *\/ \"NotNull\"          OpHelp(\"if r[P1]!=NULL goto P2\"),\n-    \/*  52 *\/ \"Ne\"               OpHelp(\"IF r[P3]!=r[P1]\"),\n-    \/*  53 *\/ \"Eq\"               OpHelp(\"IF r[P3]==r[P1]\"),\n-    \/*  54 *\/ \"Gt\"               OpHelp(\"IF r[P3]>r[P1]\"),\n-    \/*  55 *\/ \"Le\"               OpHelp(\"IF r[P3]<=r[P1]\"),\n-    \/*  56 *\/ \"Lt\"               OpHelp(\"IF r[P3]<r[P1]\"),\n-    \/*  57 *\/ \"Ge\"               OpHelp(\"IF r[P3]>=r[P1]\"),\n-    \/*  58 *\/ \"ElseEq\"           OpHelp(\"\"),\n-    \/*  59 *\/ \"IfPos\"            OpHelp(\"if r[P1]>0 then r[P1]-=P3, goto P2\"),\n+    \/*  50 *\/ \"IfPos\"            OpHelp(\"if r[P1]>0 then r[P1]-=P3, goto P2\"),\n+    \/*  51 *\/ \"IsNull\"           OpHelp(\"if r[P1]==NULL goto P2\"),\n+    \/*  52 *\/ \"NotNull\"          OpHelp(\"if r[P1]!=NULL goto P2\"),\n+    \/*  53 *\/ \"Ne\"               OpHelp(\"IF r[P3]!=r[P1]\"),\n+    \/*  54 *\/ \"Eq\"               OpHelp(\"IF r[P3]==r[P1]\"),\n+    \/*  55 *\/ \"Gt\"               OpHelp(\"IF r[P3]>r[P1]\"),\n+    \/*  56 *\/ \"Le\"               OpHelp(\"IF r[P3]<=r[P1]\"),\n+    \/*  57 *\/ \"Lt\"               OpHelp(\"IF r[P3]<r[P1]\"),\n+    \/*  58 *\/ \"Ge\"               OpHelp(\"IF r[P3]>=r[P1]\"),\n+    \/*  59 *\/ \"ElseEq\"           OpHelp(\"\"),\n@@ -36929,1 +37496,1 @@\n-    \/*  78 *\/ \"Variable\"         OpHelp(\"r[P2]=parameter(P1,P4)\"),\n+    \/*  78 *\/ \"Variable\"         OpHelp(\"r[P2]=parameter(P1)\"),\n@@ -36953,11 +37520,11 @@\n-    \/* 102 *\/ \"BitAnd\"           OpHelp(\"r[P3]=r[P1]&r[P2]\"),\n-    \/* 103 *\/ \"BitOr\"            OpHelp(\"r[P3]=r[P1]|r[P2]\"),\n-    \/* 104 *\/ \"ShiftLeft\"        OpHelp(\"r[P3]=r[P2]<<r[P1]\"),\n-    \/* 105 *\/ \"ShiftRight\"       OpHelp(\"r[P3]=r[P2]>>r[P1]\"),\n-    \/* 106 *\/ \"Add\"              OpHelp(\"r[P3]=r[P1]+r[P2]\"),\n-    \/* 107 *\/ \"Subtract\"         OpHelp(\"r[P3]=r[P2]-r[P1]\"),\n-    \/* 108 *\/ \"Multiply\"         OpHelp(\"r[P3]=r[P1]*r[P2]\"),\n-    \/* 109 *\/ \"Divide\"           OpHelp(\"r[P3]=r[P2]\/r[P1]\"),\n-    \/* 110 *\/ \"Remainder\"        OpHelp(\"r[P3]=r[P2]%r[P1]\"),\n-    \/* 111 *\/ \"Concat\"           OpHelp(\"r[P3]=r[P2]+r[P1]\"),\n-    \/* 112 *\/ \"OpenRead\"         OpHelp(\"root=P2 iDb=P3\"),\n+    \/* 102 *\/ \"OpenRead\"         OpHelp(\"root=P2 iDb=P3\"),\n+    \/* 103 *\/ \"BitAnd\"           OpHelp(\"r[P3]=r[P1]&r[P2]\"),\n+    \/* 104 *\/ \"BitOr\"            OpHelp(\"r[P3]=r[P1]|r[P2]\"),\n+    \/* 105 *\/ \"ShiftLeft\"        OpHelp(\"r[P3]=r[P2]<<r[P1]\"),\n+    \/* 106 *\/ \"ShiftRight\"       OpHelp(\"r[P3]=r[P2]>>r[P1]\"),\n+    \/* 107 *\/ \"Add\"              OpHelp(\"r[P3]=r[P1]+r[P2]\"),\n+    \/* 108 *\/ \"Subtract\"         OpHelp(\"r[P3]=r[P2]-r[P1]\"),\n+    \/* 109 *\/ \"Multiply\"         OpHelp(\"r[P3]=r[P1]*r[P2]\"),\n+    \/* 110 *\/ \"Divide\"           OpHelp(\"r[P3]=r[P2]\/r[P1]\"),\n+    \/* 111 *\/ \"Remainder\"        OpHelp(\"r[P3]=r[P2]%r[P1]\"),\n+    \/* 112 *\/ \"Concat\"           OpHelp(\"r[P3]=r[P2]+r[P1]\"),\n@@ -36965,2 +37532,2 @@\n-    \/* 114 *\/ \"BitNot\"           OpHelp(\"r[P2]= ~r[P1]\"),\n-    \/* 115 *\/ \"OpenDup\"          OpHelp(\"\"),\n+    \/* 114 *\/ \"OpenDup\"          OpHelp(\"\"),\n+    \/* 115 *\/ \"BitNot\"           OpHelp(\"r[P2]= ~r[P1]\"),\n@@ -36968,2 +37535,2 @@\n-    \/* 117 *\/ \"String8\"          OpHelp(\"r[P2]='P4'\"),\n-    \/* 118 *\/ \"OpenEphemeral\"    OpHelp(\"nColumn=P2\"),\n+    \/* 117 *\/ \"OpenEphemeral\"    OpHelp(\"nColumn=P2\"),\n+    \/* 118 *\/ \"String8\"          OpHelp(\"r[P2]='P4'\"),\n@@ -37004,2 +37571,2 @@\n-    \/* 153 *\/ \"Real\"             OpHelp(\"r[P2]=P4\"),\n-    \/* 154 *\/ \"DropTrigger\"      OpHelp(\"\"),\n+    \/* 153 *\/ \"DropTrigger\"      OpHelp(\"\"),\n+    \/* 154 *\/ \"Real\"             OpHelp(\"r[P2]=P4\"),\n@@ -38245,1 +38812,1 @@\n-#  define HAVE_FCHMOD\n+#  define HAVE_FCHMOD 1\n@@ -38354,1 +38921,1 @@\n-#ifndef SQLITE_DISABLE_DIRSYNC\n+#if !defined(SQLITE_DISABLE_DIRSYNC) && !defined(_AIX)\n@@ -39327,0 +39894,3 @@\n+  **\n+  ** Forum post 3f13857fa4062301 reports that the Android SDK may use\n+  ** int-type return, depending on its version.\n@@ -39328,1 +39898,2 @@\n-#if defined(STRERROR_R_CHAR_P) || defined(__USE_GNU)\n+#if (defined(STRERROR_R_CHAR_P) || defined(__USE_GNU)) \\\n+  && !defined(ANDROID) && !defined(__ANDROID__)\n@@ -39692,1 +40263,1 @@\n-      assert( pInode->nLock==0 );\n+      \/* assert( pInode->nLock==0 ); <-- Not true if unix-excl READONLY used *\/\n@@ -40307,7 +40878,4 @@\n-** file by this or any other process. If such a lock is held, set *pResOut\n-** to a non-zero value otherwise *pResOut is set to zero.  The return value\n-** is set to SQLITE_OK unless an I\/O error occurs during lock checking.\n-**\n-** In dotfile locking, either a lock exists or it does not.  So in this\n-** variation of CheckReservedLock(), *pResOut is set to true if any lock\n-** is held on the file and false if the file is unlocked.\n+** file by this or any other process. If the caller holds a SHARED\n+** or greater lock when it is called, then it is assumed that no other\n+** client may hold RESERVED. Or, if the caller holds no lock, then it\n+** is assumed another client holds RESERVED if the lock-file exists.\n@@ -40316,2 +40884,0 @@\n-  int rc = SQLITE_OK;\n-  int reserved = 0;\n@@ -40319,1 +40885,0 @@\n-\n@@ -40322,5 +40887,7 @@\n-  assert( pFile );\n-  reserved = osAccess((const char*)pFile->lockingContext, 0)==0;\n-  OSTRACE((\"TEST WR-LOCK %d %d %d (dotlock)\\n\", pFile->h, rc, reserved));\n-  *pResOut = reserved;\n-  return rc;\n+  if( pFile->eFileLock>=SHARED_LOCK ){\n+    *pResOut = 0;\n+  }else{\n+    *pResOut = osAccess((const char*)pFile->lockingContext, 0)==0;\n+  }\n+  OSTRACE((\"TEST WR-LOCK %d %d %d (dotlock)\\n\", pFile->h, 0, *pResOut));\n+  return SQLITE_OK;\n@@ -40496,2 +41063,1 @@\n-  int rc = SQLITE_OK;\n-  int reserved = 0;\n+#ifdef SQLITE_DEBUG\n@@ -40499,0 +41065,3 @@\n+#else\n+  UNUSED_PARAMETER(id);\n+#endif\n@@ -40503,0 +41072,1 @@\n+  assert( pFile->eFileLock<=SHARED_LOCK );\n@@ -40504,31 +41074,14 @@\n-  \/* Check if a thread in this process holds such a lock *\/\n-  if( pFile->eFileLock>SHARED_LOCK ){\n-    reserved = 1;\n-  }\n-\n-  \/* Otherwise see if some other process holds it. *\/\n-  if( !reserved ){\n-    \/* attempt to get the lock *\/\n-    int lrc = robust_flock(pFile->h, LOCK_EX | LOCK_NB);\n-    if( !lrc ){\n-      \/* got the lock, unlock it *\/\n-      lrc = robust_flock(pFile->h, LOCK_UN);\n-      if ( lrc ) {\n-        int tErrno = errno;\n-        \/* unlock failed with an error *\/\n-        lrc = SQLITE_IOERR_UNLOCK;\n-        storeLastErrno(pFile, tErrno);\n-        rc = lrc;\n-      }\n-    } else {\n-      int tErrno = errno;\n-      reserved = 1;\n-      \/* someone else might have it reserved *\/\n-      lrc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);\n-      if( IS_LOCK_ERROR(lrc) ){\n-        storeLastErrno(pFile, tErrno);\n-        rc = lrc;\n-      }\n-    }\n-  }\n-  OSTRACE((\"TEST WR-LOCK %d %d %d (flock)\\n\", pFile->h, rc, reserved));\n+  \/* The flock VFS only ever takes exclusive locks (see function flockLock).\n+  ** Therefore, if this connection is holding any lock at all, no other\n+  ** connection may be holding a RESERVED lock. So set *pResOut to 0\n+  ** in this case.\n+  **\n+  ** Or, this connection may be holding no lock. In that case, set *pResOut to\n+  ** 0 as well. The caller will then attempt to take an EXCLUSIVE lock on the\n+  ** db in order to roll the hot journal back. If there is another connection\n+  ** holding a lock, that attempt will fail and an SQLITE_BUSY returned to\n+  ** the user. With other VFS, we try to avoid this, in order to allow a reader\n+  ** to proceed while a writer is preparing its transaction. But that won't\n+  ** work with the flock VFS - as it always takes EXCLUSIVE locks - so it is\n+  ** not a problem in this case.  *\/\n+  *pResOut = 0;\n@@ -40536,8 +41089,1 @@\n-#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORS\n-  if( (rc & 0xff) == SQLITE_IOERR ){\n-    rc = SQLITE_OK;\n-    reserved=1;\n-  }\n-#endif \/* SQLITE_IGNORE_FLOCK_LOCK_ERRORS *\/\n-  *pResOut = reserved;\n-  return rc;\n+  return SQLITE_OK;\n@@ -42015,1 +42561,1 @@\n-#ifndef SQLITE_OMIT_WAL\n+#if !defined(SQLITE_WASI) && !defined(SQLITE_OMIT_WAL)\n@@ -42040,0 +42586,5 @@\n+    case SQLITE_FCNTL_NULL_IO: {\n+      osClose(pFile->h);\n+      pFile->h = -1;\n+      return SQLITE_OK;\n+    }\n@@ -42142,1 +42693,1 @@\n-#ifndef SQLITE_OMIT_WAL\n+#if !defined(SQLITE_WASI) && !defined(SQLITE_OMIT_WAL)\n@@ -42181,0 +42732,1 @@\n+    pFd->deviceCharacteristics |= SQLITE_IOCAP_SUBPAGE_READ;\n@@ -42231,1 +42783,1 @@\n-        ((pFile->sectorSize \/ 512 * SQLITE_IOCAP_ATOMIC512) << 1) - 2 |\n+        (((pFile->sectorSize \/ 512 * SQLITE_IOCAP_ATOMIC512) << 1) - 2) |\n@@ -42239,1 +42791,1 @@\n-        ((pFile->sectorSize \/ 512 * SQLITE_IOCAP_ATOMIC512) << 1) - 2 |\n+        (((pFile->sectorSize \/ 512 * SQLITE_IOCAP_ATOMIC512) << 1) - 2) |\n@@ -42315,1 +42867,1 @@\n-#ifndef SQLITE_OMIT_WAL\n+#if !defined(SQLITE_WASI) && !defined(SQLITE_OMIT_WAL)\n@@ -44426,0 +44978,1 @@\n+        UnixUnusedFd *pReadonly = 0;\n@@ -44431,1 +44984,7 @@\n-        fd = robust_open(zName, openFlags, openMode);\n+        pReadonly = findReusableFd(zName, flags);\n+        if( pReadonly ){\n+          fd = pReadonly->fd;\n+          sqlite3_free(pReadonly);\n+        }else{\n+          fd = robust_open(zName, openFlags, openMode);\n+        }\n@@ -49913,0 +50472,5 @@\n+    case SQLITE_FCNTL_NULL_IO: {\n+      (void)osCloseHandle(pFile->h);\n+      pFile->h = NULL;\n+      return SQLITE_OK;\n+    }\n@@ -49974,1 +50538,1 @@\n-  return SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN |\n+  return SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN | SQLITE_IOCAP_SUBPAGE_READ |\n@@ -51362,1 +51926,1 @@\n-  int eType = flags&0xFFFFFF00;  \/* Type of file to open *\/\n+  int eType = flags&0x0FFF00;  \/* Type of file to open *\/\n@@ -54393,0 +54957,1 @@\n+  assert( EIGHT_BYTE_ALIGNMENT( pPgHdr->pExtra ) );\n@@ -55139,1 +55704,2 @@\n-      pX->page.pExtra = &pX[1];\n+      pX->page.pExtra = (u8*)pX + ROUND8(sizeof(*pX));\n+      assert( EIGHT_BYTE_ALIGNMENT( pX->page.pExtra ) );\n@@ -55276,1 +55842,2 @@\n-    p->page.pExtra = &p[1];\n+    p->page.pExtra = (u8*)p + ROUND8(sizeof(*p));\n+    assert( EIGHT_BYTE_ALIGNMENT( p->page.pExtra ) );\n@@ -57560,14 +58127,0 @@\n-\/*\n-** The argument to this macro is a file descriptor (type sqlite3_file*).\n-** Return 0 if it is not open, or non-zero (but not 1) if it is.\n-**\n-** This is so that expressions can be written as:\n-**\n-**   if( isOpen(pPager->jfd) ){ ...\n-**\n-** instead of\n-**\n-**   if( pPager->jfd->pMethods ){ ...\n-*\/\n-#define isOpen(pFd) ((pFd)->pMethods!=0)\n-\n@@ -57579,3 +58132,4 @@\n-**   * the database file is open,\n-**   * there are no dirty pages in the cache, and\n-**   * the desired page is not currently in the wal file.\n+**   (1)  the database file is open\n+**   (2)  the VFS for the database is able to do unaligned sub-page reads\n+**   (3)  there are no dirty pages in the cache, and\n+**   (4)  the desired page is not currently in the wal file.\n@@ -57584,2 +58138,4 @@\n-  if( pPager->fd->pMethods==0 ) return 0;\n-  if( sqlite3PCacheIsDirty(pPager->pPCache) ) return 0;\n+  assert( pPager!=0 );\n+  assert( pPager->fd!=0 );\n+  if( pPager->fd->pMethods==0 ) return 0;  \/* Case (1) *\/\n+  if( sqlite3PCacheIsDirty(pPager->pPCache) ) return 0; \/* Failed (3) *\/\n@@ -57590,1 +58146,1 @@\n-    return iRead==0;\n+    if( iRead ) return 0;  \/* Case (4) *\/\n@@ -57593,0 +58149,5 @@\n+  assert( pPager->fd->pMethods->xDeviceCharacteristics!=0 );\n+  if( (pPager->fd->pMethods->xDeviceCharacteristics(pPager->fd)\n+        & SQLITE_IOCAP_SUBPAGE_READ)==0 ){\n+    return 0; \/* Case (2) *\/\n+  }\n@@ -58851,1 +59412,1 @@\n-      || (pPager->exclusiveMode && pPager->journalMode!=PAGER_JOURNALMODE_WAL)\n+      || (pPager->exclusiveMode && pPager->journalMode<PAGER_JOURNALMODE_WAL)\n@@ -60835,0 +61396,1 @@\n+    assert( EIGHT_BYTE_ALIGNMENT( p->pExtra ) );\n@@ -64618,1 +65180,1 @@\n-** frame consists of a 24-byte frame-header followed by a <page-size> bytes\n+** frame consists of a 24-byte frame-header followed by <page-size> bytes\n@@ -65115,0 +65677,1 @@\n+  int bGetSnapshot;          \/* Transaction opened for sqlite3_get_snapshot() *\/\n@@ -67007,1 +67570,1 @@\n-** by the connenction, is consistent with the Wal.readLock, Wal.writeLock\n+** by the connection, is consistent with the Wal.readLock, Wal.writeLock\n@@ -67559,3 +68122,0 @@\n-  u32 mxReadMark;                 \/* Largest aReadMark[] value *\/\n-  int mxI;                        \/* Index of largest aReadMark[] value *\/\n-  int i;                          \/* Loop counter *\/\n@@ -67563,1 +68123,0 @@\n-  u32 mxFrame;                    \/* Wal frame to lock to *\/\n@@ -67669,1 +68228,6 @@\n-  if( !useWal && AtomicLoad(&pInfo->nBackfill)==pWal->hdr.mxFrame\n+  {\n+    u32 mxReadMark;               \/* Largest aReadMark[] value *\/\n+    int mxI;                      \/* Index of largest aReadMark[] value *\/\n+    int i;                        \/* Loop counter *\/\n+    u32 mxFrame;                  \/* Wal frame to lock to *\/\n+    if( !useWal && AtomicLoad(&pInfo->nBackfill)==pWal->hdr.mxFrame\n@@ -67671,1 +68235,1 @@\n-   && (pWal->pSnapshot==0 || pWal->hdr.mxFrame==0)\n+     && ((pWal->bGetSnapshot==0 && pWal->pSnapshot==0) || pWal->hdr.mxFrame==0)\n@@ -67673,23 +68237,28 @@\n-  ){\n-    \/* The WAL has been completely backfilled (or it is empty).\n-    ** and can be safely ignored.\n-    *\/\n-    rc = walLockShared(pWal, WAL_READ_LOCK(0));\n-    walShmBarrier(pWal);\n-    if( rc==SQLITE_OK ){\n-      if( memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr)) ){\n-        \/* It is not safe to allow the reader to continue here if frames\n-        ** may have been appended to the log before READ_LOCK(0) was obtained.\n-        ** When holding READ_LOCK(0), the reader ignores the entire log file,\n-        ** which implies that the database file contains a trustworthy\n-        ** snapshot. Since holding READ_LOCK(0) prevents a checkpoint from\n-        ** happening, this is usually correct.\n-        **\n-        ** However, if frames have been appended to the log (or if the log\n-        ** is wrapped and written for that matter) before the READ_LOCK(0)\n-        ** is obtained, that is not necessarily true. A checkpointer may\n-        ** have started to backfill the appended frames but crashed before\n-        ** it finished. Leaving a corrupt image in the database file.\n-        *\/\n-        walUnlockShared(pWal, WAL_READ_LOCK(0));\n-        return WAL_RETRY;\n+    ){\n+      \/* The WAL has been completely backfilled (or it is empty).\n+      ** and can be safely ignored.\n+      *\/\n+      rc = walLockShared(pWal, WAL_READ_LOCK(0));\n+      walShmBarrier(pWal);\n+      if( rc==SQLITE_OK ){\n+        if( memcmp((void *)walIndexHdr(pWal), &pWal->hdr,sizeof(WalIndexHdr)) ){\n+          \/* It is not safe to allow the reader to continue here if frames\n+          ** may have been appended to the log before READ_LOCK(0) was obtained.\n+          ** When holding READ_LOCK(0), the reader ignores the entire log file,\n+          ** which implies that the database file contains a trustworthy\n+          ** snapshot. Since holding READ_LOCK(0) prevents a checkpoint from\n+          ** happening, this is usually correct.\n+          **\n+          ** However, if frames have been appended to the log (or if the log\n+          ** is wrapped and written for that matter) before the READ_LOCK(0)\n+          ** is obtained, that is not necessarily true. A checkpointer may\n+          ** have started to backfill the appended frames but crashed before\n+          ** it finished. Leaving a corrupt image in the database file.\n+          *\/\n+          walUnlockShared(pWal, WAL_READ_LOCK(0));\n+          return WAL_RETRY;\n+        }\n+        pWal->readLock = 0;\n+        return SQLITE_OK;\n+      }else if( rc!=SQLITE_BUSY ){\n+        return rc;\n@@ -67697,4 +68266,0 @@\n-      pWal->readLock = 0;\n-      return SQLITE_OK;\n-    }else if( rc!=SQLITE_BUSY ){\n-      return rc;\n@@ -67702,1 +68267,0 @@\n-  }\n@@ -67704,8 +68268,8 @@\n-  \/* If we get this far, it means that the reader will want to use\n-  ** the WAL to get at content from recent commits.  The job now is\n-  ** to select one of the aReadMark[] entries that is closest to\n-  ** but not exceeding pWal->hdr.mxFrame and lock that entry.\n-  *\/\n-  mxReadMark = 0;\n-  mxI = 0;\n-  mxFrame = pWal->hdr.mxFrame;\n+    \/* If we get this far, it means that the reader will want to use\n+    ** the WAL to get at content from recent commits.  The job now is\n+    ** to select one of the aReadMark[] entries that is closest to\n+    ** but not exceeding pWal->hdr.mxFrame and lock that entry.\n+    *\/\n+    mxReadMark = 0;\n+    mxI = 0;\n+    mxFrame = pWal->hdr.mxFrame;\n@@ -67713,10 +68277,2 @@\n-  if( pWal->pSnapshot && pWal->pSnapshot->mxFrame<mxFrame ){\n-    mxFrame = pWal->pSnapshot->mxFrame;\n-  }\n-#endif\n-  for(i=1; i<WAL_NREADER; i++){\n-    u32 thisMark = AtomicLoad(pInfo->aReadMark+i); SEH_INJECT_FAULT;\n-    if( mxReadMark<=thisMark && thisMark<=mxFrame ){\n-      assert( thisMark!=READMARK_NOT_USED );\n-      mxReadMark = thisMark;\n-      mxI = i;\n+    if( pWal->pSnapshot && pWal->pSnapshot->mxFrame<mxFrame ){\n+      mxFrame = pWal->pSnapshot->mxFrame;\n@@ -67724,4 +68280,1 @@\n-  }\n-  if( (pWal->readOnly & WAL_SHM_RDONLY)==0\n-   && (mxReadMark<mxFrame || mxI==0)\n-  ){\n+#endif\n@@ -67729,4 +68282,4 @@\n-      rc = walLockExclusive(pWal, WAL_READ_LOCK(i), 1);\n-      if( rc==SQLITE_OK ){\n-        AtomicStore(pInfo->aReadMark+i,mxFrame);\n-        mxReadMark = mxFrame;\n+      u32 thisMark = AtomicLoad(pInfo->aReadMark+i); SEH_INJECT_FAULT;\n+      if( mxReadMark<=thisMark && thisMark<=mxFrame ){\n+        assert( thisMark!=READMARK_NOT_USED );\n+        mxReadMark = thisMark;\n@@ -67734,4 +68287,0 @@\n-        walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);\n-        break;\n-      }else if( rc!=SQLITE_BUSY ){\n-        return rc;\n@@ -67740,5 +68289,20 @@\n-  }\n-  if( mxI==0 ){\n-    assert( rc==SQLITE_BUSY || (pWal->readOnly & WAL_SHM_RDONLY)!=0 );\n-    return rc==SQLITE_BUSY ? WAL_RETRY : SQLITE_READONLY_CANTINIT;\n-  }\n+    if( (pWal->readOnly & WAL_SHM_RDONLY)==0\n+     && (mxReadMark<mxFrame || mxI==0)\n+    ){\n+      for(i=1; i<WAL_NREADER; i++){\n+        rc = walLockExclusive(pWal, WAL_READ_LOCK(i), 1);\n+        if( rc==SQLITE_OK ){\n+          AtomicStore(pInfo->aReadMark+i,mxFrame);\n+          mxReadMark = mxFrame;\n+          mxI = i;\n+          walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);\n+          break;\n+        }else if( rc!=SQLITE_BUSY ){\n+          return rc;\n+        }\n+      }\n+    }\n+    if( mxI==0 ){\n+      assert( rc==SQLITE_BUSY || (pWal->readOnly & WAL_SHM_RDONLY)!=0 );\n+      return rc==SQLITE_BUSY ? WAL_RETRY : SQLITE_READONLY_CANTINIT;\n+    }\n@@ -67746,4 +68310,4 @@\n-  (void)walEnableBlockingMs(pWal, nBlockTmout);\n-  rc = walLockShared(pWal, WAL_READ_LOCK(mxI));\n-  walDisableBlocking(pWal);\n-  if( rc ){\n+    (void)walEnableBlockingMs(pWal, nBlockTmout);\n+    rc = walLockShared(pWal, WAL_READ_LOCK(mxI));\n+    walDisableBlocking(pWal);\n+    if( rc ){\n@@ -67751,3 +68315,3 @@\n-    if( rc==SQLITE_BUSY_TIMEOUT ){\n-      *pCnt |= WAL_RETRY_BLOCKED_MASK;\n-    }\n+      if( rc==SQLITE_BUSY_TIMEOUT ){\n+        *pCnt |= WAL_RETRY_BLOCKED_MASK;\n+      }\n@@ -67755,1 +68319,1 @@\n-    assert( rc!=SQLITE_BUSY_TIMEOUT );\n+      assert( rc!=SQLITE_BUSY_TIMEOUT );\n@@ -67757,47 +68321,48 @@\n-    assert( (rc&0xFF)!=SQLITE_BUSY||rc==SQLITE_BUSY||rc==SQLITE_BUSY_TIMEOUT );\n-    return (rc&0xFF)==SQLITE_BUSY ? WAL_RETRY : rc;\n-  }\n-  \/* Now that the read-lock has been obtained, check that neither the\n-  ** value in the aReadMark[] array or the contents of the wal-index\n-  ** header have changed.\n-  **\n-  ** It is necessary to check that the wal-index header did not change\n-  ** between the time it was read and when the shared-lock was obtained\n-  ** on WAL_READ_LOCK(mxI) was obtained to account for the possibility\n-  ** that the log file may have been wrapped by a writer, or that frames\n-  ** that occur later in the log than pWal->hdr.mxFrame may have been\n-  ** copied into the database by a checkpointer. If either of these things\n-  ** happened, then reading the database with the current value of\n-  ** pWal->hdr.mxFrame risks reading a corrupted snapshot. So, retry\n-  ** instead.\n-  **\n-  ** Before checking that the live wal-index header has not changed\n-  ** since it was read, set Wal.minFrame to the first frame in the wal\n-  ** file that has not yet been checkpointed. This client will not need\n-  ** to read any frames earlier than minFrame from the wal file - they\n-  ** can be safely read directly from the database file.\n-  **\n-  ** Because a ShmBarrier() call is made between taking the copy of\n-  ** nBackfill and checking that the wal-header in shared-memory still\n-  ** matches the one cached in pWal->hdr, it is guaranteed that the\n-  ** checkpointer that set nBackfill was not working with a wal-index\n-  ** header newer than that cached in pWal->hdr. If it were, that could\n-  ** cause a problem. The checkpointer could omit to checkpoint\n-  ** a version of page X that lies before pWal->minFrame (call that version\n-  ** A) on the basis that there is a newer version (version B) of the same\n-  ** page later in the wal file. But if version B happens to like past\n-  ** frame pWal->hdr.mxFrame - then the client would incorrectly assume\n-  ** that it can read version A from the database file. However, since\n-  ** we can guarantee that the checkpointer that set nBackfill could not\n-  ** see any pages past pWal->hdr.mxFrame, this problem does not come up.\n-  *\/\n-  pWal->minFrame = AtomicLoad(&pInfo->nBackfill)+1; SEH_INJECT_FAULT;\n-  walShmBarrier(pWal);\n-  if( AtomicLoad(pInfo->aReadMark+mxI)!=mxReadMark\n-   || memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr))\n-  ){\n-    walUnlockShared(pWal, WAL_READ_LOCK(mxI));\n-    return WAL_RETRY;\n-  }else{\n-    assert( mxReadMark<=pWal->hdr.mxFrame );\n-    pWal->readLock = (i16)mxI;\n+      assert((rc&0xFF)!=SQLITE_BUSY||rc==SQLITE_BUSY||rc==SQLITE_BUSY_TIMEOUT);\n+      return (rc&0xFF)==SQLITE_BUSY ? WAL_RETRY : rc;\n+    }\n+    \/* Now that the read-lock has been obtained, check that neither the\n+    ** value in the aReadMark[] array or the contents of the wal-index\n+    ** header have changed.\n+    **\n+    ** It is necessary to check that the wal-index header did not change\n+    ** between the time it was read and when the shared-lock was obtained\n+    ** on WAL_READ_LOCK(mxI) was obtained to account for the possibility\n+    ** that the log file may have been wrapped by a writer, or that frames\n+    ** that occur later in the log than pWal->hdr.mxFrame may have been\n+    ** copied into the database by a checkpointer. If either of these things\n+    ** happened, then reading the database with the current value of\n+    ** pWal->hdr.mxFrame risks reading a corrupted snapshot. So, retry\n+    ** instead.\n+    **\n+    ** Before checking that the live wal-index header has not changed\n+    ** since it was read, set Wal.minFrame to the first frame in the wal\n+    ** file that has not yet been checkpointed. This client will not need\n+    ** to read any frames earlier than minFrame from the wal file - they\n+    ** can be safely read directly from the database file.\n+    **\n+    ** Because a ShmBarrier() call is made between taking the copy of\n+    ** nBackfill and checking that the wal-header in shared-memory still\n+    ** matches the one cached in pWal->hdr, it is guaranteed that the\n+    ** checkpointer that set nBackfill was not working with a wal-index\n+    ** header newer than that cached in pWal->hdr. If it were, that could\n+    ** cause a problem. The checkpointer could omit to checkpoint\n+    ** a version of page X that lies before pWal->minFrame (call that version\n+    ** A) on the basis that there is a newer version (version B) of the same\n+    ** page later in the wal file. But if version B happens to like past\n+    ** frame pWal->hdr.mxFrame - then the client would incorrectly assume\n+    ** that it can read version A from the database file. However, since\n+    ** we can guarantee that the checkpointer that set nBackfill could not\n+    ** see any pages past pWal->hdr.mxFrame, this problem does not come up.\n+    *\/\n+    pWal->minFrame = AtomicLoad(&pInfo->nBackfill)+1; SEH_INJECT_FAULT;\n+    walShmBarrier(pWal);\n+    if( AtomicLoad(pInfo->aReadMark+mxI)!=mxReadMark\n+     || memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr))\n+    ){\n+      walUnlockShared(pWal, WAL_READ_LOCK(mxI));\n+      return WAL_RETRY;\n+    }else{\n+      assert( mxReadMark<=pWal->hdr.mxFrame );\n+      pWal->readLock = (i16)mxI;\n+    }\n@@ -69071,1 +69636,14 @@\n-  pWal->pSnapshot = (WalIndexHdr*)pSnapshot;\n+  if( pSnapshot && ((WalIndexHdr*)pSnapshot)->iVersion==0 ){\n+    \/* iVersion==0 means that this is a call to sqlite3_snapshot_get().  In\n+    ** this case set the bGetSnapshot flag so that if the call to\n+    ** sqlite3_snapshot_get() is about to read transaction on this wal\n+    ** file, it does not take read-lock 0 if the wal file has been completely\n+    ** checkpointed. Taking read-lock 0 would work, but then it would be\n+    ** possible for a subsequent writer to destroy the snapshot even while\n+    ** this connection is holding its read-transaction open. This is contrary\n+    ** to user expectations, so we avoid it by not taking read-lock 0. *\/\n+    pWal->bGetSnapshot = 1;\n+  }else{\n+    pWal->pSnapshot = (WalIndexHdr*)pSnapshot;\n+    pWal->bGetSnapshot = 0;\n+  }\n@@ -69882,0 +70460,1 @@\n+  i64 nRow;         \/* Number of rows visited in current tree *\/\n@@ -70356,0 +70935,6 @@\n+\/* Default value for SHARED_LOCK_TRACE macro if shared-cache is disabled\n+** or if the lock tracking is disabled.  This is always the value for\n+** release builds.\n+*\/\n+#define SHARED_LOCK_TRACE(X,MSG,TAB,TYPE)  \/*no-op*\/\n+\n@@ -70358,0 +70943,33 @@\n+#if 0\n+\/*  ^----  Change to 1 and recompile to enable shared-lock tracing\n+**         for debugging purposes.\n+**\n+** Print all shared-cache locks on a BtShared.  Debugging use only.\n+*\/\n+static void sharedLockTrace(\n+  BtShared *pBt,\n+  const char *zMsg,\n+  int iRoot,\n+  int eLockType\n+){\n+  BtLock *pLock;\n+  if( iRoot>0 ){\n+    printf(\"%s-%p %u%s:\", zMsg, pBt, iRoot, eLockType==READ_LOCK?\"R\":\"W\");\n+  }else{\n+    printf(\"%s-%p:\", zMsg, pBt);\n+  }\n+  for(pLock=pBt->pLock; pLock; pLock=pLock->pNext){\n+    printf(\" %p\/%u%s\", pLock->pBtree, pLock->iTable,\n+           pLock->eLock==READ_LOCK ? \"R\" : \"W\");\n+    while( pLock->pNext && pLock->pBtree==pLock->pNext->pBtree ){\n+      pLock = pLock->pNext;\n+      printf(\",%u%s\", pLock->iTable, pLock->eLock==READ_LOCK ? \"R\" : \"W\");\n+    }\n+  }\n+  printf(\"\\n\");\n+  fflush(stdout);\n+}\n+#undef SHARED_LOCK_TRACE\n+#define SHARED_LOCK_TRACE(X,MSG,TAB,TYPE)  sharedLockTrace(X,MSG,TAB,TYPE)\n+#endif \/* Shared-lock tracing *\/\n+\n@@ -70434,0 +71052,2 @@\n+  SHARED_LOCK_TRACE(pBtree->pBt,\"hasLock\",iRoot,eLockType);\n+\n@@ -70567,0 +71187,2 @@\n+  SHARED_LOCK_TRACE(pBt,\"setLock\", iTable, eLock);\n+\n@@ -70634,0 +71256,2 @@\n+  SHARED_LOCK_TRACE(pBt, \"clearAllLocks\", 0, 0);\n+\n@@ -70672,0 +71296,3 @@\n+\n+  SHARED_LOCK_TRACE(pBt, \"downgradeLocks\", 0, 0);\n+\n@@ -74903,0 +75530,19 @@\n+#ifdef SQLITE_DEBUG\n+\/*\n+** Return true if and only if the Btree object will be automatically\n+** closed with the BtCursor closes.  This is used within assert() statements\n+** only.\n+*\/\n+SQLITE_PRIVATE int sqlite3BtreeClosesWithCursor(\n+  Btree *pBtree,       \/* the btree object *\/\n+  BtCursor *pCur       \/* Corresponding cursor *\/\n+){\n+  BtShared *pBt = pBtree->pBt;\n+  if( (pBt->openFlags & BTREE_SINGLE)==0 ) return 0;\n+  if( pBt->pCursor!=pCur ) return 0;\n+  if( pCur->pNext!=0 ) return 0;\n+  if( pCur->pBtree!=pBtree ) return 0;\n+  return 1;\n+}\n+#endif\n+\n@@ -75285,3 +75931,6 @@\n-        Pgno *aNew = (Pgno*)sqlite3Realloc(\n-            pCur->aOverflow, nOvfl*2*sizeof(Pgno)\n-        );\n+        Pgno *aNew;\n+        if( sqlite3FaultSim(413) ){\n+          aNew = 0;\n+        }else{\n+          aNew = (Pgno*)sqlite3Realloc(pCur->aOverflow, nOvfl*2*sizeof(Pgno));\n+        }\n@@ -75297,0 +75946,6 @@\n+      \/* Sanity check the validity of the overflow page cache *\/\n+      assert( pCur->aOverflow[0]==nextPage\n+           || pCur->aOverflow[0]==0\n+           || CORRUPT_DB );\n+      assert( pCur->aOverflow[0]!=0 || pCur->aOverflow[offset\/ovflSize]==0 );\n+\n@@ -75778,0 +76433,17 @@\n+#ifdef SQLITE_DEBUG\n+\/* The cursors is CURSOR_VALID and has BTCF_AtLast set.  Verify that\n+** this flags are true for a consistent database.\n+**\n+** This routine is is called from within assert() statements only.\n+** It is an internal verification routine and does not appear in production\n+** builds.\n+*\/\n+static int cursorIsAtLastEntry(BtCursor *pCur){\n+  int ii;\n+  for(ii=0; ii<pCur->iPage; ii++){\n+    if( pCur->aiIdx[ii]!=pCur->apPage[ii]->nCell ) return 0;\n+  }\n+  return pCur->ix==pCur->pPage->nCell-1 && pCur->pPage->leaf!=0;\n+}\n+#endif\n+\n@@ -75806,12 +76478,1 @@\n-#ifdef SQLITE_DEBUG\n-    \/* This block serves to assert() that the cursor really does point\n-    ** to the last entry in the b-tree. *\/\n-    int ii;\n-    for(ii=0; ii<pCur->iPage; ii++){\n-      assert( pCur->aiIdx[ii]==pCur->apPage[ii]->nCell );\n-    }\n-    assert( pCur->ix==pCur->pPage->nCell-1 || CORRUPT_DB );\n-    testcase( pCur->ix!=pCur->pPage->nCell-1 );\n-    \/* ^-- dbsqlfuzz b92b72e4de80b5140c30ab71372ca719b8feb618 *\/\n-    assert( pCur->pPage->leaf );\n-#endif\n+    assert( cursorIsAtLastEntry(pCur) || CORRUPT_DB );\n@@ -75870,0 +76531,1 @@\n+        assert( cursorIsAtLastEntry(pCur) || CORRUPT_DB );\n@@ -76130,1 +76792,1 @@\n-      pCur->curFlags &= ~BTCF_ValidOvfl;\n+      pCur->curFlags &= ~(BTCF_ValidOvfl|BTCF_AtLast);\n@@ -76336,4 +76998,4 @@\n-  \/* Currently this interface is only called by the OP_IfSmaller\n-  ** opcode, and it that case the cursor will always be valid and\n-  ** will always point to a leaf node. *\/\n-  if( NEVER(pCur->eState!=CURSOR_VALID) ) return -1;\n+  \/* Currently this interface is only called by the OP_IfSizeBetween\n+  ** opcode and the OP_Count opcode with P3=1.  In either case,\n+  ** the cursor will always be valid unless the btree is empty. *\/\n+  if( pCur->eState!=CURSOR_VALID ) return 0;\n@@ -77708,1 +78370,2 @@\n-  for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i; k++){}\n+  assert( pCArray->ixNx[NB*2-1]>i );\n+  for(k=0; pCArray->ixNx[k]<=i; k++){}\n@@ -77791,1 +78454,2 @@\n-  for(k=0; ALWAYS(k<NB*2) && pCArray->ixNx[k]<=i ; k++){}\n+  assert( pCArray->ixNx[NB*2-1]>i );\n+  for(k=0; pCArray->ixNx[k]<=i ; k++){}\n@@ -78076,0 +78740,1 @@\n+    b.ixNx[NB*2-1] = 0x7fffffff;\n@@ -78311,1 +78976,3 @@\n-  memset(&b, 0, sizeof(b));\n+  assert( sizeof(b) - sizeof(b.ixNx) == offsetof(CellArray,ixNx) );\n+  memset(&b, 0, sizeof(b)-sizeof(b.ixNx[0]));\n+  b.ixNx[NB*2-1] = 0x7fffffff;\n@@ -78470,1 +79137,1 @@\n-      rc = SQLITE_CORRUPT_BKPT;\n+      rc = SQLITE_CORRUPT_PAGE(pOld);\n@@ -78494,1 +79161,1 @@\n-        rc = SQLITE_CORRUPT_BKPT;\n+        rc = SQLITE_CORRUPT_PAGE(pOld);\n@@ -78902,1 +79569,2 @@\n-    for(k=0; ALWAYS(k<NB*2) && b.ixNx[k]<=j; k++){}\n+    assert( b.ixNx[NB*2-1]>j );\n+    for(k=0; b.ixNx[k]<=j; k++){}\n@@ -79137,1 +79805,1 @@\n-      return SQLITE_CORRUPT_BKPT;\n+      return SQLITE_CORRUPT_PAGE(pCur->pPage);\n@@ -79197,1 +79865,1 @@\n-      rc = SQLITE_CORRUPT_BKPT;\n+      rc = SQLITE_CORRUPT_PAGE(pPage);\n@@ -79361,1 +80029,1 @@\n-      rc = SQLITE_CORRUPT_BKPT;\n+      rc = SQLITE_CORRUPT_PAGE(pPage);\n@@ -79389,1 +80057,1 @@\n-    return SQLITE_CORRUPT_BKPT;\n+    return SQLITE_CORRUPT_PAGE(pPage);\n@@ -79470,1 +80138,1 @@\n-      return SQLITE_CORRUPT_BKPT;\n+      return SQLITE_CORRUPT_PGNO(pCur->pgnoRoot);\n@@ -79593,1 +80261,1 @@\n-      rc = SQLITE_CORRUPT_BKPT;\n+      rc = SQLITE_CORRUPT_PAGE(pPage);\n@@ -79635,1 +80303,1 @@\n-      return SQLITE_CORRUPT_BKPT;\n+      return SQLITE_CORRUPT_PAGE(pPage);\n@@ -79662,1 +80330,1 @@\n-        return SQLITE_CORRUPT_BKPT;\n+        return SQLITE_CORRUPT_PAGE(pPage);\n@@ -79665,1 +80333,1 @@\n-        return SQLITE_CORRUPT_BKPT;\n+        return SQLITE_CORRUPT_PAGE(pPage);\n@@ -79767,1 +80435,1 @@\n-    return SQLITE_CORRUPT_BKPT;\n+    return SQLITE_CORRUPT_PAGE(pSrc->pPage);\n@@ -79792,1 +80460,1 @@\n-        return SQLITE_CORRUPT_BKPT;\n+        return SQLITE_CORRUPT_PAGE(pSrc->pPage);\n@@ -79888,1 +80556,1 @@\n-      return SQLITE_CORRUPT_BKPT;\n+      return SQLITE_CORRUPT_PGNO(pCur->pgnoRoot);\n@@ -79897,1 +80565,1 @@\n-    return SQLITE_CORRUPT_BKPT;\n+    return SQLITE_CORRUPT_PAGE(pPage);\n@@ -79901,1 +80569,1 @@\n-    return SQLITE_CORRUPT_BKPT;\n+    return SQLITE_CORRUPT_PAGE(pPage);\n@@ -79904,1 +80572,1 @@\n-    return SQLITE_CORRUPT_BKPT;\n+    return SQLITE_CORRUPT_PAGE(pPage);\n@@ -79995,1 +80663,1 @@\n-    if( pCell<&pLeaf->aData[4] ) return SQLITE_CORRUPT_BKPT;\n+    if( pCell<&pLeaf->aData[4] ) return SQLITE_CORRUPT_PAGE(pLeaf);\n@@ -80111,1 +80779,1 @@\n-      return SQLITE_CORRUPT_BKPT;\n+      return SQLITE_CORRUPT_PGNO(pgnoRoot);\n@@ -80159,1 +80827,1 @@\n-        rc = SQLITE_CORRUPT_BKPT;\n+        rc = SQLITE_CORRUPT_PGNO(pgnoRoot);\n@@ -80249,1 +80917,1 @@\n-    return SQLITE_CORRUPT_BKPT;\n+    return SQLITE_CORRUPT_PGNO(pgno);\n@@ -80256,1 +80924,1 @@\n-    rc = SQLITE_CORRUPT_BKPT;\n+    rc = SQLITE_CORRUPT_PAGE(pPage);\n@@ -80360,1 +81028,1 @@\n-    return SQLITE_CORRUPT_BKPT;\n+    return SQLITE_CORRUPT_PGNO(iTable);\n@@ -80954,0 +81622,3 @@\n+  if( pPage->leaf || pPage->intKey==0 ){\n+    pCheck->nRow += nCell;\n+  }\n@@ -81065,0 +81736,1 @@\n+    assert( heap!=0 );\n@@ -81164,0 +81836,1 @@\n+  Mem *aCnt,    \/* Memory cells to write counts for each tree to *\/\n@@ -81177,0 +81850,1 @@\n+\n@@ -81178,0 +81852,1 @@\n+  assert( aCnt!=0 );\n@@ -81250,2 +81925,3 @@\n-    i64 notUsed;\n-    if( aRoot[i]==0 ) continue;\n+    sCheck.nRow = 0;\n+    if( aRoot[i] ){\n+      i64 notUsed;\n@@ -81253,3 +81929,3 @@\n-    if( pBt->autoVacuum && aRoot[i]>1 && !bPartial ){\n-      checkPtrmap(&sCheck, aRoot[i], PTRMAP_ROOTPAGE, 0);\n-    }\n+      if( pBt->autoVacuum && aRoot[i]>1 && !bPartial ){\n+        checkPtrmap(&sCheck, aRoot[i], PTRMAP_ROOTPAGE, 0);\n+      }\n@@ -81257,2 +81933,4 @@\n-    sCheck.v0 = aRoot[i];\n-    checkTreePage(&sCheck, aRoot[i], &notUsed, LARGEST_INT64);\n+      sCheck.v0 = aRoot[i];\n+      checkTreePage(&sCheck, aRoot[i], &notUsed, LARGEST_INT64);\n+    }\n+    sqlite3MemSetArrayInt64(aCnt, i, sCheck.nRow);\n@@ -83313,0 +83991,7 @@\n+\/*\n+** Set the iIdx'th entry of array aMem[] to contain integer value val.\n+*\/\n+SQLITE_PRIVATE void sqlite3MemSetArrayInt64(sqlite3_value *aMem, int iIdx, i64 val){\n+  sqlite3VdbeMemSetInt64(&aMem[iIdx], val);\n+}\n+\n@@ -83409,21 +84094,24 @@\n-  for(i=1, pX=pVdbe->aMem+1; i<pVdbe->nMem; i++, pX++){\n-    if( pX->pScopyFrom==pMem ){\n-      u16 mFlags;\n-      if( pVdbe->db->flags & SQLITE_VdbeTrace ){\n-        sqlite3DebugPrintf(\"Invalidate R[%d] due to change in R[%d]\\n\",\n-          (int)(pX - pVdbe->aMem), (int)(pMem - pVdbe->aMem));\n-      }\n-      \/* If pX is marked as a shallow copy of pMem, then try to verify that\n-      ** no significant changes have been made to pX since the OP_SCopy.\n-      ** A significant change would indicated a missed call to this\n-      ** function for pX.  Minor changes, such as adding or removing a\n-      ** dual type, are allowed, as long as the underlying value is the\n-      ** same. *\/\n-      mFlags = pMem->flags & pX->flags & pX->mScopyFlags;\n-      assert( (mFlags&(MEM_Int|MEM_IntReal))==0 || pMem->u.i==pX->u.i );\n-\n-      \/* pMem is the register that is changing.  But also mark pX as\n-      ** undefined so that we can quickly detect the shallow-copy error *\/\n-      pX->flags = MEM_Undefined;\n-      pX->pScopyFrom = 0;\n-    }\n+  if( pMem->bScopy ){\n+    for(i=1, pX=pVdbe->aMem+1; i<pVdbe->nMem; i++, pX++){\n+      if( pX->pScopyFrom==pMem ){\n+        u16 mFlags;\n+        if( pVdbe->db->flags & SQLITE_VdbeTrace ){\n+          sqlite3DebugPrintf(\"Invalidate R[%d] due to change in R[%d]\\n\",\n+            (int)(pX - pVdbe->aMem), (int)(pMem - pVdbe->aMem));\n+        }\n+        \/* If pX is marked as a shallow copy of pMem, then try to verify that\n+        ** no significant changes have been made to pX since the OP_SCopy.\n+        ** A significant change would indicated a missed call to this\n+        ** function for pX.  Minor changes, such as adding or removing a\n+        ** dual type, are allowed, as long as the underlying value is the\n+        ** same. *\/\n+        mFlags = pMem->flags & pX->flags & pX->mScopyFlags;\n+        assert( (mFlags&(MEM_Int|MEM_IntReal))==0 || pMem->u.i==pX->u.i );\n+\n+        \/* pMem is the register that is changing.  But also mark pX as\n+        ** undefined so that we can quickly detect the shallow-copy error *\/\n+        pX->flags = MEM_Undefined;\n+        pX->pScopyFrom = 0;\n+      }\n+    }\n+    pMem->bScopy = 0;\n@@ -83897,1 +84585,2 @@\n-      rc = sqlite3ValueFromExpr(db, pList->a[i].pExpr, enc, aff, &apVal[i]);\n+      rc = sqlite3Stat4ValueFromExpr(pCtx->pParse, pList->a[i].pExpr, aff,\n+                                     &apVal[i]);\n@@ -84001,8 +84690,14 @@\n-  ** case when the value is -9223372036854775808.\n-  *\/\n-  if( op==TK_UMINUS\n-   && (pExpr->pLeft->op==TK_INTEGER || pExpr->pLeft->op==TK_FLOAT) ){\n-    pExpr = pExpr->pLeft;\n-    op = pExpr->op;\n-    negInt = -1;\n-    zNeg = \"-\";\n+  ** case when the value is -9223372036854775808. Except - do not do this\n+  ** for hexadecimal literals.  *\/\n+  if( op==TK_UMINUS ){\n+    Expr *pLeft = pExpr->pLeft;\n+    if( (pLeft->op==TK_INTEGER || pLeft->op==TK_FLOAT) ){\n+      if( ExprHasProperty(pLeft, EP_IntValue)\n+       || pLeft->u.zToken[0]!='0' || (pLeft->u.zToken[1] & ~0x20)!='X'\n+      ){\n+        pExpr = pLeft;\n+        op = pExpr->op;\n+        negInt = -1;\n+        zNeg = \"-\";\n+      }\n+    }\n@@ -84017,3 +84712,8 @@\n-      zVal = sqlite3MPrintf(db, \"%s%s\", zNeg, pExpr->u.zToken);\n-      if( zVal==0 ) goto no_mem;\n-      sqlite3ValueSetStr(pVal, -1, zVal, SQLITE_UTF8, SQLITE_DYNAMIC);\n+      i64 iVal;\n+      if( op==TK_INTEGER && 0==sqlite3DecOrHexToI64(pExpr->u.zToken, &iVal) ){\n+        sqlite3VdbeMemSetInt64(pVal, iVal*negInt);\n+      }else{\n+        zVal = sqlite3MPrintf(db, \"%s%s\", zNeg, pExpr->u.zToken);\n+        if( zVal==0 ) goto no_mem;\n+        sqlite3ValueSetStr(pVal, -1, zVal, SQLITE_UTF8, SQLITE_DYNAMIC);\n+      }\n@@ -84021,2 +84721,11 @@\n-    if( (op==TK_INTEGER || op==TK_FLOAT ) && affinity==SQLITE_AFF_BLOB ){\n-      sqlite3ValueApplyAffinity(pVal, SQLITE_AFF_NUMERIC, SQLITE_UTF8);\n+    if( affinity==SQLITE_AFF_BLOB ){\n+      if( op==TK_FLOAT ){\n+        assert( pVal && pVal->z && pVal->flags==(MEM_Str|MEM_Term) );\n+        sqlite3AtoF(pVal->z, &pVal->u.r, pVal->n, SQLITE_UTF8);\n+        pVal->flags = MEM_Real;\n+      }else if( op==TK_INTEGER ){\n+        \/* This case is required by -9223372036854775808 and other strings\n+        ** that look like integers but cannot be handled by the\n+        ** sqlite3DecOrHexToI64() call above.  *\/\n+        sqlite3ValueApplyAffinity(pVal, SQLITE_AFF_NUMERIC, SQLITE_UTF8);\n+      }\n@@ -84292,4 +85001,4 @@\n-  int nHdr;                       \/* Size of the header in the record *\/\n-  int iHdr;                       \/* Next unread header byte *\/\n-  int iField;                     \/* Next unread data byte *\/\n-  int szField = 0;                \/* Size of the current data field *\/\n+  u32 nHdr;                       \/* Size of the header in the record *\/\n+  u32 iHdr;                       \/* Next unread header byte *\/\n+  i64 iField;                     \/* Next unread data byte *\/\n+  u32 szField = 0;                \/* Size of the current data field *\/\n@@ -84302,1 +85011,1 @@\n-  if( nHdr>nRec || iHdr>=nHdr ) return SQLITE_CORRUPT_BKPT;\n+  if( nHdr>(u32)nRec || iHdr>=nHdr ) return SQLITE_CORRUPT_BKPT;\n@@ -85337,0 +86046,9 @@\n+\n+          \/* OPFLG_JUMP opcodes never have P2==0, though OPFLG_JUMP0 opcodes\n+          ** might *\/\n+          assert( pOp->p2>0\n+                  || (sqlite3OpcodeProperty[pOp->opcode] & OPFLG_JUMP0)!=0 );\n+\n+          \/* Jumps never go off the end of the bytecode array *\/\n+          assert( pOp->p2<p->nOp\n+                  || (sqlite3OpcodeProperty[pOp->opcode] & OPFLG_JUMP)==0 );\n@@ -85802,0 +86520,6 @@\n+    case P4_SUBRTNSIG: {\n+      SubrtnSig *pSig = (SubrtnSig*)p4;\n+      sqlite3DbFree(db, pSig->zAff);\n+      sqlite3DbFree(db, pSig);\n+      break;\n+    }\n@@ -86381,0 +87105,5 @@\n+    case P4_SUBRTNSIG: {\n+      SubrtnSig *pSig = pOp->p4.pSubrtnSig;\n+      sqlite3_str_appendf(&x, \"subrtnsig:%d,%s\", pSig->selId, pSig->zAff);\n+      break;\n+    }\n@@ -86522,0 +87251,1 @@\n+  assert( db!=0 );\n@@ -86529,0 +87259,1 @@\n+      p->bScopy = 0;\n@@ -86547,0 +87278,1 @@\n+    assert( db!=0 );\n@@ -87027,0 +87759,1 @@\n+  assert( pParse->db==p->db );\n@@ -87744,1 +88477,1 @@\n-      sqlite3VdbeCheckFk(p, 0);\n+      (void)sqlite3VdbeCheckFk(p, 0);\n@@ -88890,1 +89623,1 @@\n-#if  defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_DEBUG)\n+#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_DEBUG)\n@@ -88905,7 +89638,0 @@\n-  }\n-  if( sqlite3Config.bUseLongDouble ){\n-    LONGDOUBLE_TYPE x = (LONGDOUBLE_TYPE)i;\n-    testcase( x<r );\n-    testcase( x>r );\n-    testcase( x==r );\n-    return (x<r) ? -1 : (x>r);\n@@ -88914,1 +89640,0 @@\n-    double s;\n@@ -88920,5 +89645,4 @@\n-    s = (double)i;\n-    testcase( doubleLt(s,r) );\n-    testcase( doubleLt(r,s) );\n-    testcase( doubleEq(r,s) );\n-    return (s<r) ? -1 : (s>r);\n+    testcase( doubleLt(((double)i),r) );\n+    testcase( doubleLt(r,((double)i)) );\n+    testcase( doubleEq(r,((double)i)) );\n+    return (((double)i)<r) ? -1 : (((double)i)>r);\n@@ -89727,1 +90451,2 @@\n-    assert( (v->db->flags & SQLITE_EnableQPSG)==0 );\n+    assert( (v->db->flags & SQLITE_EnableQPSG)==0\n+         || (v->db->mDbFlags & DBFLAG_InternalFunc)!=0 );\n@@ -89747,1 +90472,2 @@\n-  assert( (v->db->flags & SQLITE_EnableQPSG)==0 );\n+  assert( (v->db->flags & SQLITE_EnableQPSG)==0\n+       || (v->db->mDbFlags & DBFLAG_InternalFunc)!=0 );\n@@ -89914,0 +90640,1 @@\n+  sqlite3VdbeMemRelease(&preupdate.oldipk);\n@@ -89921,0 +90648,7 @@\n+  if( preupdate.apDflt ){\n+    int i;\n+    for(i=0; i<pTab->nCol; i++){\n+      sqlite3ValueFree(preupdate.apDflt[i]);\n+    }\n+    sqlite3DbFree(db, preupdate.apDflt);\n+  }\n@@ -89991,1 +90725,0 @@\n-  assert( (db->mTrace & (SQLITE_TRACE_PROFILE|SQLITE_TRACE_XPROFILE))!=0 );\n@@ -90711,1 +91444,1 @@\n-          || (db->nDeferredCons==0 && db->nDeferredImmCons==0)\n+          || ((db->nDeferredCons + db->nDeferredImmCons)==0)\n@@ -91222,0 +91955,1 @@\n+        \/* .bScopy     = *\/ 0,\n@@ -91263,1 +91997,1 @@\n-**     sqlite3_column_real()\n+**     sqlite3_column_double()\n@@ -91549,0 +92283,11 @@\n+**\n+** (tag-20240917-01) If  vdbeUnbind(p,(u32)(i-1))  returns SQLITE_OK,\n+** that means all of the the following will be true:\n+**\n+**     p!=0\n+**     p->pVar!=0\n+**     i>0\n+**     i<=p->nVar\n+**\n+** An assert() is normally added after vdbeUnbind() to help static analyzers\n+** realize this.\n@@ -91606,0 +92351,1 @@\n+    assert( p!=0 && p->aVar!=0 && i>0 && i<=p->nVar ); \/* tag-20240917-01 *\/\n@@ -91655,0 +92401,1 @@\n+    assert( p!=0 && p->aVar!=0 && i>0 && i<=p->nVar ); \/* tag-20240917-01 *\/\n@@ -91668,0 +92415,1 @@\n+    assert( p!=0 && p->aVar!=0 && i>0 && i<=p->nVar ); \/* tag-20240917-01 *\/\n@@ -91678,0 +92426,1 @@\n+    assert( p!=0 && p->aVar!=0 && i>0 && i<=p->nVar ); \/* tag-20240917-01 *\/\n@@ -91693,0 +92442,1 @@\n+    assert( p!=0 && p->aVar!=0 && i>0 && i<=p->nVar ); \/* tag-20240917-01 *\/\n@@ -91774,0 +92524,1 @@\n+    assert( p!=0 && p->aVar!=0 && i>0 && i<=p->nVar ); \/* tag-20240917-01 *\/\n@@ -92087,0 +92838,1 @@\n+  int iStore = 0;\n@@ -92101,1 +92853,3 @@\n-    iIdx = sqlite3TableColumnToIndex(p->pPk, iIdx);\n+    iStore = sqlite3TableColumnToIndex(p->pPk, iIdx);\n+  }else{\n+    iStore = sqlite3TableColumnToStorage(p->pTab, iIdx);\n@@ -92103,1 +92857,1 @@\n-  if( iIdx>=p->pCsr->nField || iIdx<0 ){\n+  if( iStore>=p->pCsr->nField || iStore<0 ){\n@@ -92108,4 +92862,4 @@\n-  \/* If the old.* record has not yet been loaded into memory, do so now. *\/\n-  if( p->pUnpacked==0 ){\n-    u32 nRec;\n-    u8 *aRec;\n+  if( iIdx==p->pTab->iPKey ){\n+    *ppValue = pMem = &p->oldipk;\n+    sqlite3VdbeMemSetInt64(pMem, p->iKey1);\n+  }else{\n@@ -92113,12 +92867,19 @@\n-    assert( p->pCsr->eCurType==CURTYPE_BTREE );\n-    nRec = sqlite3BtreePayloadSize(p->pCsr->uc.pCursor);\n-    aRec = sqlite3DbMallocRaw(db, nRec);\n-    if( !aRec ) goto preupdate_old_out;\n-    rc = sqlite3BtreePayload(p->pCsr->uc.pCursor, 0, nRec, aRec);\n-    if( rc==SQLITE_OK ){\n-      p->pUnpacked = vdbeUnpackRecord(&p->keyinfo, nRec, aRec);\n-      if( !p->pUnpacked ) rc = SQLITE_NOMEM;\n-    }\n-    if( rc!=SQLITE_OK ){\n-      sqlite3DbFree(db, aRec);\n-      goto preupdate_old_out;\n+    \/* If the old.* record has not yet been loaded into memory, do so now. *\/\n+    if( p->pUnpacked==0 ){\n+      u32 nRec;\n+      u8 *aRec;\n+\n+      assert( p->pCsr->eCurType==CURTYPE_BTREE );\n+      nRec = sqlite3BtreePayloadSize(p->pCsr->uc.pCursor);\n+      aRec = sqlite3DbMallocRaw(db, nRec);\n+      if( !aRec ) goto preupdate_old_out;\n+      rc = sqlite3BtreePayload(p->pCsr->uc.pCursor, 0, nRec, aRec);\n+      if( rc==SQLITE_OK ){\n+        p->pUnpacked = vdbeUnpackRecord(&p->keyinfo, nRec, aRec);\n+        if( !p->pUnpacked ) rc = SQLITE_NOMEM;\n+      }\n+      if( rc!=SQLITE_OK ){\n+        sqlite3DbFree(db, aRec);\n+        goto preupdate_old_out;\n+      }\n+      p->aRecord = aRec;\n@@ -92126,2 +92887,0 @@\n-    p->aRecord = aRec;\n-  }\n@@ -92129,10 +92888,32 @@\n-  pMem = *ppValue = &p->pUnpacked->aMem[iIdx];\n-  if( iIdx==p->pTab->iPKey ){\n-    sqlite3VdbeMemSetInt64(pMem, p->iKey1);\n-  }else if( iIdx>=p->pUnpacked->nField ){\n-    *ppValue = (sqlite3_value *)columnNullValue();\n-  }else if( p->pTab->aCol[iIdx].affinity==SQLITE_AFF_REAL ){\n-    if( pMem->flags & (MEM_Int|MEM_IntReal) ){\n-      testcase( pMem->flags & MEM_Int );\n-      testcase( pMem->flags & MEM_IntReal );\n-      sqlite3VdbeMemRealify(pMem);\n+    pMem = *ppValue = &p->pUnpacked->aMem[iStore];\n+    if( iStore>=p->pUnpacked->nField ){\n+      \/* This occurs when the table has been extended using ALTER TABLE\n+      ** ADD COLUMN. The value to return is the default value of the column. *\/\n+      Column *pCol = &p->pTab->aCol[iIdx];\n+      if( pCol->iDflt>0 ){\n+        if( p->apDflt==0 ){\n+          int nByte = sizeof(sqlite3_value*)*p->pTab->nCol;\n+          p->apDflt = (sqlite3_value**)sqlite3DbMallocZero(db, nByte);\n+          if( p->apDflt==0 ) goto preupdate_old_out;\n+        }\n+        if( p->apDflt[iIdx]==0 ){\n+          sqlite3_value *pVal = 0;\n+          Expr *pDflt;\n+          assert( p->pTab!=0 && IsOrdinaryTable(p->pTab) );\n+          pDflt = p->pTab->u.tab.pDfltList->a[pCol->iDflt-1].pExpr;\n+          rc = sqlite3ValueFromExpr(db, pDflt, ENC(db), pCol->affinity, &pVal);\n+          if( rc==SQLITE_OK && pVal==0 ){\n+            rc = SQLITE_CORRUPT_BKPT;\n+          }\n+          p->apDflt[iIdx] = pVal;\n+        }\n+        *ppValue = p->apDflt[iIdx];\n+      }else{\n+        *ppValue = (sqlite3_value *)columnNullValue();\n+      }\n+    }else if( p->pTab->aCol[iIdx].affinity==SQLITE_AFF_REAL ){\n+      if( pMem->flags & (MEM_Int|MEM_IntReal) ){\n+        testcase( pMem->flags & MEM_Int );\n+        testcase( pMem->flags & MEM_IntReal );\n+        sqlite3VdbeMemRealify(pMem);\n+      }\n@@ -92212,0 +92993,1 @@\n+  int iStore = 0;\n@@ -92224,1 +93006,3 @@\n-    iIdx = sqlite3TableColumnToIndex(p->pPk, iIdx);\n+    iStore = sqlite3TableColumnToIndex(p->pPk, iIdx);\n+  }else{\n+    iStore = sqlite3TableColumnToStorage(p->pTab, iIdx);\n@@ -92226,1 +93010,2 @@\n-  if( iIdx>=p->pCsr->nField || iIdx<0 ){\n+\n+  if( iStore>=p->pCsr->nField || iStore<0 ){\n@@ -92246,1 +93031,1 @@\n-    pMem = &pUnpack->aMem[iIdx];\n+    pMem = &pUnpack->aMem[iStore];\n@@ -92249,1 +93034,1 @@\n-    }else if( iIdx>=pUnpack->nField ){\n+    }else if( iStore>=pUnpack->nField ){\n@@ -92253,1 +93038,1 @@\n-    \/* For an UPDATE, memory cell (p->iNewReg+1+iIdx) contains the required\n+    \/* For an UPDATE, memory cell (p->iNewReg+1+iStore) contains the required\n@@ -92266,2 +93051,2 @@\n-    assert( iIdx>=0 && iIdx<p->pCsr->nField );\n-    pMem = &p->aNew[iIdx];\n+    assert( iStore>=0 && iStore<p->pCsr->nField );\n+    pMem = &p->aNew[iStore];\n@@ -92272,1 +93057,1 @@\n-        rc = sqlite3VdbeMemCopy(pMem, &p->v->aMem[p->iNewReg+1+iIdx]);\n+        rc = sqlite3VdbeMemCopy(pMem, &p->v->aMem[p->iNewReg+1+iStore]);\n@@ -92332,1 +93117,0 @@\n-    pScan = &p->aScan[idx];\n@@ -92345,0 +93129,2 @@\n+  assert( pScan==0 || pScan==&p->aScan[idx] );\n+  pScan = &p->aScan[idx];\n@@ -92685,0 +93471,98 @@\n+\/*\n+** High-resolution hardware timer used for debugging and testing only.\n+*\/\n+#if defined(VDBE_PROFILE)  \\\n+ || defined(SQLITE_PERFORMANCE_TRACE) \\\n+ || defined(SQLITE_ENABLE_STMT_SCANSTATUS)\n+\/************** Include hwtime.h in the middle of vdbe.c *********************\/\n+\/************** Begin file hwtime.h ******************************************\/\n+\/*\n+** 2008 May 27\n+**\n+** The author disclaims copyright to this source code.  In place of\n+** a legal notice, here is a blessing:\n+**\n+**    May you do good and not evil.\n+**    May you find forgiveness for yourself and forgive others.\n+**    May you share freely, never taking more than you give.\n+**\n+******************************************************************************\n+**\n+** This file contains inline asm code for retrieving \"high-performance\"\n+** counters for x86 and x86_64 class CPUs.\n+*\/\n+#ifndef SQLITE_HWTIME_H\n+#define SQLITE_HWTIME_H\n+\n+\/*\n+** The following routine only works on Pentium-class (or newer) processors.\n+** It uses the RDTSC opcode to read the cycle count value out of the\n+** processor and returns that value.  This can be used for high-res\n+** profiling.\n+*\/\n+#if !defined(__STRICT_ANSI__) && \\\n+    (defined(__GNUC__) || defined(_MSC_VER)) && \\\n+    (defined(i386) || defined(__i386__) || defined(_M_IX86))\n+\n+  #if defined(__GNUC__)\n+\n+  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n+     unsigned int lo, hi;\n+     __asm__ __volatile__ (\"rdtsc\" : \"=a\" (lo), \"=d\" (hi));\n+     return (sqlite_uint64)hi << 32 | lo;\n+  }\n+\n+  #elif defined(_MSC_VER)\n+\n+  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){\n+     __asm {\n+        rdtsc\n+        ret       ; return value at EDX:EAX\n+     }\n+  }\n+\n+  #endif\n+\n+#elif !defined(__STRICT_ANSI__) && (defined(__GNUC__) && defined(__x86_64__))\n+\n+  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n+     unsigned int lo, hi;\n+     __asm__ __volatile__ (\"rdtsc\" : \"=a\" (lo), \"=d\" (hi));\n+     return (sqlite_uint64)hi << 32 | lo;\n+  }\n+\n+#elif !defined(__STRICT_ANSI__) && (defined(__GNUC__) && defined(__ppc__))\n+\n+  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n+      unsigned long long retval;\n+      unsigned long junk;\n+      __asm__ __volatile__ (\"\\n\\\n+          1:      mftbu   %1\\n\\\n+                  mftb    %L0\\n\\\n+                  mftbu   %0\\n\\\n+                  cmpw    %0,%1\\n\\\n+                  bne     1b\"\n+                  : \"=r\" (retval), \"=r\" (junk));\n+      return retval;\n+  }\n+\n+#else\n+\n+  \/*\n+  ** asm() is needed for hardware timing support.  Without asm(),\n+  ** disable the sqlite3Hwtime() routine.\n+  **\n+  ** sqlite3Hwtime() is only used for some obscure debugging\n+  ** and analysis configurations, not in any deliverable, so this\n+  ** should not be a great loss.\n+  *\/\n+SQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); }\n+\n+#endif\n+\n+#endif \/* !defined(SQLITE_HWTIME_H) *\/\n+\n+\/************** End of hwtime.h **********************************************\/\n+\/************** Continuing where we left off in vdbe.c ***********************\/\n+#endif\n+\n@@ -93262,0 +94146,1 @@\n+    assert( p->pScopyFrom->bScopy );\n@@ -93793,1 +94678,1 @@\n-case OP_InitCoroutine: {     \/* jump *\/\n+case OP_InitCoroutine: {     \/* jump0 *\/\n@@ -93816,1 +94701,3 @@\n-** After the jump, register P1 becomes undefined.\n+** After the jump, the value register P1 is left with a value\n+** such that subsequent OP_Yields go back to the this same\n+** OP_EndCoroutine instruction.\n@@ -93828,0 +94715,1 @@\n+  pIn1->u.i = (int)(pOp - p->aOp) - 1;\n@@ -93829,1 +94717,0 @@\n-  pIn1->flags = MEM_Undefined;\n@@ -93846,1 +94733,1 @@\n-case OP_Yield: {            \/* in1, jump *\/\n+case OP_Yield: {            \/* in1, jump0 *\/\n@@ -93876,1 +94763,1 @@\n-\/* Opcode:  Halt P1 P2 * P4 P5\n+\/* Opcode:  Halt P1 P2 P3 P4 P5\n@@ -93889,1 +94776,5 @@\n-** If P4 is not null then it is an error message string.\n+** If P3 is not zero and P4 is NULL, then P3 is a register that holds the\n+** text of an error message.\n+**\n+** If P3 is zero and P4 is not null then the error message string is held\n+** in P4.\n@@ -93891,1 +94782,2 @@\n-** P5 is a value between 0 and 4, inclusive, that modifies the P4 string.\n+** P5 is a value between 1 and 4, inclusive, then the P4 error message\n+** string is modified as follows:\n@@ -93893,1 +94785,0 @@\n-**    0:  (no change)\n@@ -93899,2 +94790,2 @@\n-** If P5 is not zero and P4 is NULL, then everything after the \":\" is\n-** omitted.\n+** If P3 is zero and P5 is not zero and P4 is NULL, then everything after\n+** the \":\" is omitted.\n@@ -93913,0 +94804,3 @@\n+  assert( pOp->p4type==P4_NOTUSED\n+       || pOp->p4type==P4_STATIC\n+       || pOp->p4type==P4_DYNAMIC );\n@@ -93943,1 +94837,6 @@\n-    if( pOp->p5 ){\n+    if( pOp->p3>0 && pOp->p4type==P4_NOTUSED ){\n+      const char *zErr;\n+      assert( pOp->p3<=(p->nMem + 1 - p->nCursor) );\n+      zErr = sqlite3ValueText(&aMem[pOp->p3], SQLITE_UTF8);\n+      sqlite3VdbeError(p, \"%s\", zErr);\n+    }else if( pOp->p5 ){\n@@ -94176,2 +95075,2 @@\n-\/* Opcode: Variable P1 P2 * P4 *\n-** Synopsis: r[P2]=parameter(P1,P4)\n+\/* Opcode: Variable P1 P2 * * *\n+** Synopsis: r[P2]=parameter(P1)\n@@ -94180,3 +95079,0 @@\n-**\n-** If the parameter is named, then its name appears in P4.\n-** The P4 value is used by sqlite3_bind_parameter_name().\n@@ -94188,1 +95084,0 @@\n-  assert( pOp->p4.z==0 || pOp->p4.z==sqlite3VListNumToName(p->pVList,pOp->p1) );\n@@ -94235,0 +95130,1 @@\n+          assert( aMem[i].bScopy );\n@@ -94307,0 +95203,1 @@\n+  pIn1->bScopy = 1;\n@@ -94709,1 +95606,1 @@\n-case OP_MustBeInt: {            \/* jump, in1 *\/\n+case OP_MustBeInt: {            \/* jump0, in1 *\/\n@@ -94750,1 +95647,1 @@\n-#ifndef SQLITE_OMIT_CAST\n+#if !defined(SQLITE_OMIT_CAST) || !defined(SQLITE_OMIT_ANALYZE)\n@@ -96322,0 +97219,1 @@\n+                   \/* no break *\/ deliberate_fall_through\n@@ -96324,0 +97222,1 @@\n+                   \/* no break *\/ deliberate_fall_through\n@@ -96325,0 +97224,1 @@\n+                   \/* no break *\/ deliberate_fall_through\n@@ -96326,0 +97226,1 @@\n+                   \/* no break *\/ deliberate_fall_through\n@@ -96327,0 +97228,1 @@\n+                   \/* no break *\/ deliberate_fall_through\n@@ -96985,0 +97887,14 @@\n+    if( pOp->p5 & OPFLAG_P2ISREG ){\n+      assert( p2>0 );\n+      assert( p2<=(u32)(p->nMem+1 - p->nCursor) );\n+      pIn2 = &aMem[p2];\n+      assert( memIsValid(pIn2) );\n+      assert( (pIn2->flags & MEM_Int)!=0 );\n+      sqlite3VdbeMemIntegerify(pIn2);\n+      p2 = (int)pIn2->u.i;\n+      \/* The p2 value always comes from a prior OP_CreateBtree opcode and\n+      ** that opcode will always set the p2 value to 2 or more or else fail.\n+      ** If there were a failure, the prepared statement would have halted\n+      ** before reaching this instruction. *\/\n+      assert( p2>=2 );\n+    }\n@@ -96987,15 +97903,1 @@\n-  }\n-  if( pOp->p5 & OPFLAG_P2ISREG ){\n-    assert( p2>0 );\n-    assert( p2<=(u32)(p->nMem+1 - p->nCursor) );\n-    assert( pOp->opcode==OP_OpenWrite );\n-    pIn2 = &aMem[p2];\n-    assert( memIsValid(pIn2) );\n-    assert( (pIn2->flags & MEM_Int)!=0 );\n-    sqlite3VdbeMemIntegerify(pIn2);\n-    p2 = (int)pIn2->u.i;\n-    \/* The p2 value always comes from a prior OP_CreateBtree opcode and\n-    ** that opcode will always set the p2 value to 2 or more or else fail.\n-    ** If there were a failure, the prepared statement would have halted\n-    ** before reaching this instruction. *\/\n-    assert( p2>=2 );\n+    assert( (pOp->p5 & OPFLAG_P2ISREG)==0 );\n@@ -97178,0 +98080,1 @@\n+      assert( p->apCsr[pOp->p1]==pCx );\n@@ -97179,0 +98082,1 @@\n+        assert( !sqlite3BtreeClosesWithCursor(pCx->ub.pBtx, pCx->uc.pCursor) );\n@@ -97180,0 +98084,3 @@\n+        p->apCsr[pOp->p1] = 0;  \/* Not required; helps with static analysis *\/\n+      }else{\n+        assert( sqlite3BtreeClosesWithCursor(pCx->ub.pBtx, pCx->uc.pCursor) );\n@@ -97245,1 +98152,2 @@\n-** the pseudo-table.\n+** the pseudo-table.  If P2 is 0 or negative then the pseudo-cursor\n+** will return NULL for every column.\n@@ -97388,4 +98296,4 @@\n-case OP_SeekLT:         \/* jump, in3, group, ncycle *\/\n-case OP_SeekLE:         \/* jump, in3, group, ncycle *\/\n-case OP_SeekGE:         \/* jump, in3, group, ncycle *\/\n-case OP_SeekGT: {       \/* jump, in3, group, ncycle *\/\n+case OP_SeekLT:         \/* jump0, in3, group, ncycle *\/\n+case OP_SeekLE:         \/* jump0, in3, group, ncycle *\/\n+case OP_SeekGE:         \/* jump0, in3, group, ncycle *\/\n+case OP_SeekGT: {       \/* jump0, in3, group, ncycle *\/\n@@ -97956,0 +98864,1 @@\n+    (void)sqlite3FaultSim(50);  \/* For use by --counter in TH3 *\/\n@@ -98058,1 +98967,1 @@\n-case OP_SeekRowid: {        \/* jump, in3, ncycle *\/\n+case OP_SeekRowid: {        \/* jump0, in3, ncycle *\/\n@@ -98817,1 +99726,1 @@\n-case OP_Last: {              \/* jump, ncycle *\/\n+case OP_Last: {              \/* jump0, ncycle *\/\n@@ -98851,1 +99760,1 @@\n-\/* Opcode: IfSmaller P1 P2 P3 * *\n+\/* Opcode: IfSizeBetween P1 P2 P3 P4 *\n@@ -98853,2 +99762,5 @@\n-** Estimate the number of rows in the table P1.  Jump to P2 if that\n-** estimate is less than approximately 2**(0.1*P3).\n+** Let N be the approximate number of rows in the table or index\n+** with cursor P1 and let X be 10*log2(N) if N is positive or -1\n+** if N is zero.\n+**\n+** Jump to P2 if X is in between P3 and P4, inclusive.\n@@ -98856,1 +99768,1 @@\n-case OP_IfSmaller: {        \/* jump *\/\n+case OP_IfSizeBetween: {        \/* jump *\/\n@@ -98863,0 +99775,3 @@\n+  assert( pOp->p4type==P4_INT32 );\n+  assert( pOp->p3>=-1 && pOp->p3<=640*2 );\n+  assert( pOp->p4.i>=-1 && pOp->p4.i<=640*2 );\n@@ -98869,1 +99784,3 @@\n-  if( res==0 ){\n+  if( res!=0 ){\n+    sz = -1;  \/* -Infinity encoding *\/\n+  }else{\n@@ -98871,1 +99788,2 @@\n-    if( ALWAYS(sz>=0) && sqlite3LogEst((u64)sz)<pOp->p3 ) res = 1;\n+    assert( sz>0 );\n+    sz = sqlite3LogEst((u64)sz);\n@@ -98873,0 +99791,1 @@\n+  res = sz>=pOp->p3 && sz<=pOp->p4.i;\n@@ -98925,1 +99844,1 @@\n-case OP_Rewind: {        \/* jump, ncycle *\/\n+case OP_Rewind: {        \/* jump0, ncycle *\/\n@@ -99572,1 +100491,1 @@\n-\/* Opcode: SqlExec * * * P4 *\n+\/* Opcode: SqlExec P1 P2 * P4 *\n@@ -99575,2 +100494,9 @@\n-** Disable Auth and Trace callbacks while those statements are running if\n-** P1 is true.\n+**\n+** The P1 parameter is a bitmask of options:\n+**\n+**    0x0001     Disable Auth and Trace callbacks while the statements\n+**               in P4 are running.\n+**\n+**    0x0002     Set db->nAnalysisLimit to P2 while the statements in\n+**               P4 are running.\n+**\n@@ -99584,0 +100510,1 @@\n+  int savedAnalysisLimit;\n@@ -99592,1 +100519,2 @@\n-  if( pOp->p1 ){\n+  savedAnalysisLimit = db->nAnalysisLimit;\n+  if( pOp->p1 & 0x0001 ){\n@@ -99598,0 +100526,3 @@\n+  if( pOp->p1 & 0x0002 ){\n+    db->nAnalysisLimit = pOp->p2;\n+  }\n@@ -99604,0 +100535,1 @@\n+  db->nAnalysisLimit = savedAnalysisLimit;\n@@ -99755,2 +100687,2 @@\n-** register P1 the text of an error message describing any problems.\n-** If no problems are found, store a NULL in register P1.\n+** register (P1+1) the text of an error message describing any problems.\n+** If no problems are found, store a NULL in register (P1+1).\n@@ -99758,2 +100690,2 @@\n-** The register P3 contains one less than the maximum number of allowed errors.\n-** At most reg(P3) errors will be reported.\n+** The register (P1) contains one less than the maximum number of allowed\n+** errors.  At most reg(P1) errors will be reported.\n@@ -99779,0 +100711,1 @@\n+  assert( pOp->p4type==P4_INTARRAY );\n@@ -99782,0 +100715,1 @@\n+  assert( aRoot!=0 );\n@@ -99783,2 +100717,2 @@\n-  assert( pOp->p3>0 && pOp->p3<=(p->nMem+1 - p->nCursor) );\n-  pnErr = &aMem[pOp->p3];\n+  assert( pOp->p1>0 && (pOp->p1+1)<=(p->nMem+1 - p->nCursor) );\n+  pnErr = &aMem[pOp->p1];\n@@ -99787,1 +100721,1 @@\n-  pIn1 = &aMem[pOp->p1];\n+  pIn1 = &aMem[pOp->p1+1];\n@@ -99790,2 +100724,2 @@\n-  rc = sqlite3BtreeIntegrityCheck(db, db->aDb[pOp->p5].pBt, &aRoot[1], nRoot,\n-                                 (int)pnErr->u.i+1, &nErr, &z);\n+  rc = sqlite3BtreeIntegrityCheck(db, db->aDb[pOp->p5].pBt, &aRoot[1],\n+      &aMem[pOp->p3], nRoot, (int)pnErr->u.i+1, &nErr, &z);\n@@ -99918,1 +100852,3 @@\n-** exception using the RAISE() function. Register P3 contains the address\n+** exception using the RAISE() function. P2 might be zero, if there is\n+** no possibility that an IGNORE exception will be raised.\n+** Register P3 contains the address\n@@ -99926,1 +100862,1 @@\n-case OP_Program: {        \/* jump *\/\n+case OP_Program: {        \/* jump0 *\/\n@@ -100291,0 +101227,1 @@\n+  u64 nAlloc;\n@@ -100297,2 +101234,10 @@\n-  pCtx = sqlite3DbMallocRawNN(db, n*sizeof(sqlite3_value*) +\n-               (sizeof(pCtx[0]) + sizeof(Mem) - sizeof(sqlite3_value*)));\n+\n+  \/* Allocate space for (a) the context object and (n-1) extra pointers\n+  ** to append to the sqlite3_context.argv[1] array, and (b) a memory\n+  ** cell in which to store the accumulation. Be careful that the memory\n+  ** cell is 8-byte aligned, even on platforms where a pointer is 32-bits.\n+  **\n+  ** Note: We could avoid this by using a regular memory cell from aMem[] for\n+  ** the accumulator, instead of allocating one here. *\/\n+  nAlloc = ROUND8P( sizeof(pCtx[0]) + (n-1)*sizeof(sqlite3_value*) );\n+  pCtx = sqlite3DbMallocRawNN(db, nAlloc + sizeof(Mem));\n@@ -100300,2 +101245,3 @@\n-  pCtx->pMem = 0;\n-  pCtx->pOut = (Mem*)&(pCtx->argv[n]);\n+  pCtx->pOut = (Mem*)((u8*)pCtx + nAlloc);\n+  assert( EIGHT_BYTE_ALIGNMENT(pCtx->pOut) );\n+\n@@ -100303,0 +101249,1 @@\n+  pCtx->pMem = 0;\n@@ -101475,1 +102422,1 @@\n-case OP_Init: {          \/* jump *\/\n+case OP_Init: {          \/* jump0 *\/\n@@ -101636,2 +102583,1 @@\n-** Do nothing.  This instruction is often useful as a jump\n-** destination.\n+** Do nothing.  Continue downward to the next opcode.\n@@ -101639,5 +102585,21 @@\n-\/*\n-** The magic Explain opcode are only inserted when explain==2 (which\n-** is to say when the EXPLAIN QUERY PLAN syntax is used.)\n-** This opcode records information from the optimizer.  It is the\n-** the same as a no-op.  This opcodesnever appears in a real VM program.\n+\/* Opcode: Explain P1 P2 P3 P4 *\n+**\n+** This is the same as OP_Noop during normal query execution.  The\n+** purpose of this opcode is to hold information about the query\n+** plan for the purpose of EXPLAIN QUERY PLAN output.\n+**\n+** The P4 value is human-readable text that describes the query plan\n+** element.  Something like \"SCAN t1\" or \"SEARCH t2 USING INDEX t2x1\".\n+**\n+** The P1 value is the ID of the current element and P2 is the parent\n+** element for the case of nested query plan elements.  If P2 is zero\n+** then this element is a top-level element.\n+**\n+** For loop elements, P3 is the estimated code of each invocation of this\n+** element.\n+**\n+** As with all opcodes, the meanings of the parameters for OP_Explain\n+** are subject to change from one release to the next.  Applications\n+** should not attempt to interpret or use any of the information\n+** contained in the OP_Explain opcode.  The information provided by this\n+** opcode is intended for testing and debugging use only.\n@@ -101970,0 +102932,5 @@\n+    if( pTab && (pTab->tabFlags&TF_HasGenerated)!=0 ){\n+      pTab = 0;\n+      sqlite3ErrorMsg(&sParse, \"cannot open table with generated columns: %s\",\n+                      zTable);\n+    }\n@@ -102877,1 +103844,1 @@\n-      u8 *aNext;                  \/* Pointer to buffer to copy data from *\/\n+      u8 *aNext = 0;              \/* Pointer to buffer to copy data from *\/\n@@ -102884,0 +103851,1 @@\n+      assert( aNext!=0 );\n@@ -105376,1 +106344,1 @@\n-      sqlite3_result_int(ctx, pOp->nExec);\n+      sqlite3_result_int64(ctx, pOp->nExec);\n@@ -105379,1 +106347,1 @@\n-      sqlite3_result_int(ctx, pOp->nCycle);\n+      sqlite3_result_int64(ctx, pOp->nCycle);\n@@ -106153,1 +107121,3 @@\n-      if( pItem->pSelect && sqlite3WalkSelect(pWalker, pItem->pSelect) ){\n+      if( pItem->fg.isSubquery\n+       && sqlite3WalkSelect(pWalker, pItem->u4.pSubq->pSelect)\n+      ){\n@@ -106459,1 +107429,1 @@\n-    pNew->y.pTab = pMatch->pTab;\n+    pNew->y.pTab = pMatch->pSTab;\n@@ -106472,1 +107442,1 @@\n-  Schema *pSchema           \/* non-NULL if a database qualifier is present *\/\n+  const char *zDb           \/* non-NULL if a database qualifier is present *\/\n@@ -106483,1 +107453,1 @@\n-    if( pSchema==0 ) return 0;\n+    if( zDb==0 ) return 0;\n@@ -106523,1 +107493,1 @@\n-  const char *zCol,    \/* Name of the column. *\/\n+  const Expr *pRight,  \/* Name of the column. *\/\n@@ -106540,0 +107510,1 @@\n+  const char *zCol = pRight->u.zToken;\n@@ -106589,1 +107560,1 @@\n-        pTab = pItem->pTab;\n+        pTab = pItem->pSTab;\n@@ -106592,1 +107563,1 @@\n-        assert( (int)pItem->fg.isNestedFrom == IsNestedFrom(pItem->pSelect) );\n+        assert( (int)pItem->fg.isNestedFrom == IsNestedFrom(pItem));\n@@ -106601,2 +107572,6 @@\n-          assert( pItem->pSelect!=0 );\n-          pEList = pItem->pSelect->pEList;\n+          Select *pSel;\n+          assert( pItem->fg.isSubquery );\n+          assert( pItem->u4.pSubq!=0 );\n+          pSel = pItem->u4.pSubq->pSelect;\n+          assert( pSel!=0 );\n+          pEList = pSel->pEList;\n@@ -106665,1 +107640,1 @@\n-            if( !isValidSchemaTableName(zTab, pTab, pSchema) ) continue;\n+            if( !isValidSchemaTableName(zTab, pTab, zDb) ) continue;\n@@ -106725,3 +107700,3 @@\n-               && ALWAYS(pMatch!=0)\n-               && ALWAYS(pMatch->pTab!=0)\n-               && (pMatch->pTab->tabFlags & TF_Ephemeral)!=0\n+               && pMatch!=0\n+               && ALWAYS(pMatch->pSTab!=0)\n+               && (pMatch->pSTab->tabFlags & TF_Ephemeral)!=0\n@@ -106748,1 +107723,1 @@\n-        pExpr->y.pTab = pMatch->pTab;\n+        pExpr->y.pTab = pMatch->pSTab;\n@@ -106771,1 +107746,2 @@\n-                     || sqlite3StrICmp(zTab,pParse->pTriggerTab->zName)==0)\n+                     || sqlite3StrICmp(zTab,pParse->pTriggerTab->zName)==0\n+                     || isValidSchemaTableName(zTab, pParse->pTriggerTab, 0))\n@@ -106789,1 +107765,1 @@\n-          pTab = pUpsert->pUpsertSrc->a[0].pTab;\n+          pTab = pUpsert->pUpsertSrc->a[0].pSTab;\n@@ -106872,1 +107848,1 @@\n-     && ALWAYS(VisibleRowid(pMatch->pTab) || pMatch->fg.isNestedFrom)\n+     && ALWAYS(VisibleRowid(pMatch->pSTab) || pMatch->fg.isNestedFrom)\n@@ -106875,0 +107851,5 @@\n+#if SQLITE_ALLOW_ROWID_IN_VIEW+0==2\n+      if( pMatch->pSTab!=0 && IsView(pMatch->pSTab) ){\n+        eNewExprOp = TK_NULL;\n+      }\n+#endif\n@@ -107028,0 +108009,4 @@\n+    }else if( cnt==0 && ExprHasProperty(pRight,EP_DblQuoted) ){\n+      sqlite3ErrorMsg(pParse, \"%s: \\\"%s\\\" - should this be a\"\n+                              \" string literal in single-quotes?\",\n+                              zErr, zCol);\n@@ -107061,2 +108046,6 @@\n-  if( pExpr->iColumn>=0 && cnt==1 && pMatch!=0 ){\n-    pMatch->colUsed |= sqlite3ExprColUsed(pExpr);\n+  if( pMatch ){\n+    if( pExpr->iColumn>=0 ){\n+      pMatch->colUsed |= sqlite3ExprColUsed(pExpr);\n+    }else{\n+      pMatch->fg.rowidUsed = 1;\n+    }\n@@ -107100,1 +108089,1 @@\n-    pTab = p->y.pTab = pItem->pTab;\n+    pTab = p->y.pTab = pItem->pSTab;\n@@ -107219,1 +108208,1 @@\n-      pExpr->y.pTab = pItem->pTab;\n+      pExpr->y.pTab = pItem->pSTab;\n@@ -107305,1 +108294,0 @@\n-      const char *zColumn;\n@@ -107314,1 +108302,1 @@\n-        zColumn = pExpr->u.zToken;\n+        pRight = pExpr;\n@@ -107333,1 +108321,0 @@\n-        zColumn = pRight->u.zToken;\n@@ -107340,1 +108327,1 @@\n-      return lookupName(pParse, zDb, zTable, zColumn, pNC, pExpr);\n+      return lookupName(pParse, zDb, zTable, pRight, pNC, pExpr);\n@@ -107346,2 +108333,2 @@\n-      ExprList *pList = pExpr->x.pList;    \/* The argument list *\/\n-      int n = pList ? pList->nExpr : 0;    \/* Number of arguments *\/\n+      ExprList *pList;            \/* The argument list *\/\n+      int n;                      \/* Number of arguments *\/\n@@ -107360,0 +108347,2 @@\n+      pList = pExpr->x.pList;\n+      n = pList ? pList->nExpr : 0;\n@@ -107408,0 +108397,18 @@\n+\n+        \/* If the function may call sqlite3_value_subtype(), then set the\n+        ** EP_SubtArg flag on all of its argument expressions. This prevents\n+        ** where.c from replacing the expression with a value read from an\n+        ** index on the same expression, which will not have the correct\n+        ** subtype. Also set the flag if the function expression itself is\n+        ** an EP_SubtArg expression. In this case subtypes are required as\n+        ** the function may return a value with a subtype back to its\n+        ** caller using sqlite3_result_value().  *\/\n+        if( (pDef->funcFlags & SQLITE_SUBTYPE)\n+         || ExprHasProperty(pExpr, EP_SubtArg)\n+        ){\n+          int ii;\n+          for(ii=0; ii<n; ii++){\n+            ExprSetProperty(pList->a[ii].pExpr, EP_SubtArg);\n+          }\n+        }\n+\n@@ -107516,2 +108523,1 @@\n-#ifndef SQLITE_OMIT_WINDOWFUNC\n-      else if( ExprHasProperty(pExpr, EP_WinFunc) ){\n+      else if( ExprHasProperty(pExpr, EP_WinFunc) || pExpr->pLeft ){\n@@ -107520,1 +108526,0 @@\n-#endif\n@@ -107529,1 +108534,1 @@\n-        if( pWin ){\n+        if( pWin && pParse->nErr==0 ){\n@@ -107531,1 +108536,1 @@\n-          assert( pWin==0 || (ExprUseYWin(pExpr) && pWin==pExpr->y.pWin) );\n+          assert( ExprUseYWin(pExpr) && pWin==pExpr->y.pWin );\n@@ -107590,0 +108595,1 @@\n+        assert( pExpr->x.pSelect );\n@@ -107598,0 +108604,1 @@\n+          pExpr->x.pSelect->selFlags |= SF_Correlated;\n@@ -107736,1 +108743,1 @@\n-  assert( sqlite3ExprIsInteger(pE, &i)==0 );\n+  assert( sqlite3ExprIsInteger(pE, &i, 0)==0 );\n@@ -107835,1 +108842,1 @@\n-      if( sqlite3ExprIsInteger(pE, &iCol) ){\n+      if( sqlite3ExprIsInteger(pE, &iCol, 0) ){\n@@ -108020,1 +109027,1 @@\n-    if( sqlite3ExprIsInteger(pE2, &iCol) ){\n+    if( sqlite3ExprIsInteger(pE2, &iCol, 0) ){\n@@ -108111,1 +109118,5 @@\n-      Select *pSub = p->pSrc->a[0].pSelect;\n+      Select *pSub;\n+      assert( p->pSrc->a[0].fg.isSubquery );\n+      assert( p->pSrc->a[0].u4.pSubq!=0 );\n+      pSub = p->pSrc->a[0].u4.pSubq->pSelect;\n+      assert( pSub!=0 );\n@@ -108123,1 +109134,5 @@\n-      if( pItem->pSelect && (pItem->pSelect->selFlags & SF_Resolved)==0 ){\n+      assert( pItem->zName!=0\n+              || pItem->fg.isSubquery );  \/* Test of tag-20240424-1*\/\n+      if( pItem->fg.isSubquery\n+       && (pItem->u4.pSubq->pSelect->selFlags & SF_Resolved)==0\n+      ){\n@@ -108128,1 +109143,1 @@\n-        sqlite3ResolveSelectNames(pParse, pItem->pSelect, pOuterNC);\n+        sqlite3ResolveSelectNames(pParse, pItem->u4.pSubq->pSelect, pOuterNC);\n@@ -108230,1 +109245,4 @@\n-      Select *pSub = p->pSrc->a[0].pSelect;\n+      Select *pSub;\n+      assert( p->pSrc->a[0].fg.isSubquery );\n+      pSub = p->pSrc->a[0].u4.pSubq->pSelect;\n+      assert( pSub!=0 );\n@@ -108384,0 +109402,3 @@\n+**\n+** The return value is SQLITE_OK (0) for success or SQLITE_ERROR (1) for a\n+** failure.\n@@ -108392,1 +109413,1 @@\n-  if( pList==0 ) return WRC_Continue;\n+  if( pList==0 ) return SQLITE_OK;\n@@ -108406,1 +109427,1 @@\n-      return WRC_Abort;\n+      return SQLITE_ERROR;\n@@ -108423,1 +109444,1 @@\n-    if( w.pParse->nErr>0 ) return WRC_Abort;\n+    if( w.pParse->nErr>0 ) return SQLITE_ERROR;\n@@ -108426,1 +109447,1 @@\n-  return WRC_Continue;\n+  return SQLITE_OK;\n@@ -108494,1 +109515,1 @@\n-    sSrc.a[0].pTab = pTab;\n+    sSrc.a[0].pSTab = pTab;\n@@ -108599,1 +109620,3 @@\n-    if( op!=TK_REGISTER || (op = pExpr->op2)==TK_REGISTER ) break;\n+    if( op!=TK_REGISTER ) break;\n+    op = pExpr->op2;\n+    if( NEVER( op==TK_REGISTER ) ) break;\n@@ -108991,1 +110014,1 @@\n-  sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);\n+  sqlite3VdbeChangeP5(pParse->pVdbe, (u16)p5);\n@@ -109429,4 +110452,4 @@\n-** Special case:  If op==TK_INTEGER and pToken points to a string that\n-** can be translated into a 32-bit integer, then the token is not\n-** stored in u.zToken.  Instead, the integer values is written\n-** into u.iValue and the EP_IntValue flag is set.  No extra storage\n+** Special case (tag-20240227-a):  If op==TK_INTEGER and pToken points to\n+** a string that can be translated into a 32-bit integer, then the token is\n+** not stored in u.zToken.  Instead, the integer values is written\n+** into u.iValue and the EP_IntValue flag is set. No extra storage\n@@ -109434,0 +110457,1 @@\n+** See also tag-20240227-b.\n@@ -109449,1 +110473,1 @@\n-      nExtra = pToken->n+1;\n+      nExtra = pToken->n+1;  \/* tag-20240227-a *\/\n@@ -109881,0 +110905,1 @@\n+exprDeleteRestart:\n@@ -109896,1 +110921,0 @@\n-    if( p->pLeft && p->op!=TK_SELECT_COLUMN ) sqlite3ExprDeleteNN(db, p->pLeft);\n@@ -109911,0 +110935,13 @@\n+    if( p->pLeft && p->op!=TK_SELECT_COLUMN ){\n+      Expr *pLeft = p->pLeft;\n+      if( !ExprHasProperty(p, EP_Static)\n+       && !ExprHasProperty(pLeft, EP_Static)\n+      ){\n+        \/* Avoid unnecessary recursion on unary operators *\/\n+        sqlite3DbNNFreeNN(db, p);\n+        p = pLeft;\n+        goto exprDeleteRestart;\n+      }else{\n+        sqlite3ExprDeleteNN(db, pLeft);\n+      }\n+    }\n@@ -109943,2 +110980,2 @@\n-** The deferred delete is (currently) implemented by adding the\n-** pExpr to the pParse->pConstExpr list with a register number of 0.\n+** Return 0 if the delete was successfully deferred.  Return non-zero\n+** if the delete happened immediately because of an OOM.\n@@ -109946,2 +110983,2 @@\n-SQLITE_PRIVATE void sqlite3ExprDeferredDelete(Parse *pParse, Expr *pExpr){\n-  sqlite3ParserAddCleanup(pParse, sqlite3ExprDeleteGeneric, pExpr);\n+SQLITE_PRIVATE int sqlite3ExprDeferredDelete(Parse *pParse, Expr *pExpr){\n+  return 0==sqlite3ParserAddCleanup(pParse, sqlite3ExprDeleteGeneric, pExpr);\n@@ -110375,2 +111412,21 @@\n-    pNewItem->pSchema = pOldItem->pSchema;\n-    pNewItem->zDatabase = sqlite3DbStrDup(db, pOldItem->zDatabase);\n+    pNewItem->fg = pOldItem->fg;\n+    if( pOldItem->fg.isSubquery ){\n+      Subquery *pNewSubq = sqlite3DbMallocRaw(db, sizeof(Subquery));\n+      if( pNewSubq==0 ){\n+        assert( db->mallocFailed );\n+        pNewItem->fg.isSubquery = 0;\n+      }else{\n+        memcpy(pNewSubq, pOldItem->u4.pSubq, sizeof(*pNewSubq));\n+        pNewSubq->pSelect = sqlite3SelectDup(db, pNewSubq->pSelect, flags);\n+        if( pNewSubq->pSelect==0 ){\n+          sqlite3DbFree(db, pNewSubq);\n+          pNewSubq = 0;\n+          pNewItem->fg.isSubquery = 0;\n+        }\n+      }\n+      pNewItem->u4.pSubq = pNewSubq;\n+    }else if( pOldItem->fg.fixedSchema ){\n+      pNewItem->u4.pSchema = pOldItem->u4.pSchema;\n+    }else{\n+      pNewItem->u4.zDatabase = sqlite3DbStrDup(db, pOldItem->u4.zDatabase);\n+    }\n@@ -110379,1 +111435,0 @@\n-    pNewItem->fg = pOldItem->fg;\n@@ -110381,2 +111436,0 @@\n-    pNewItem->addrFillSub = pOldItem->addrFillSub;\n-    pNewItem->regReturn = pOldItem->regReturn;\n@@ -110385,0 +111438,5 @@\n+    }else if( pNewItem->fg.isTabFunc ){\n+      pNewItem->u1.pFuncArg =\n+          sqlite3ExprListDup(db, pOldItem->u1.pFuncArg, flags);\n+    }else{\n+      pNewItem->u1.nRow = pOldItem->u1.nRow;\n@@ -110390,5 +111448,1 @@\n-    if( pNewItem->fg.isTabFunc ){\n-      pNewItem->u1.pFuncArg =\n-          sqlite3ExprListDup(db, pOldItem->u1.pFuncArg, flags);\n-    }\n-    pTab = pNewItem->pTab = pOldItem->pTab;\n+    pTab = pNewItem->pSTab = pOldItem->pSTab;\n@@ -110398,1 +111452,0 @@\n-    pNewItem->pSelect = sqlite3SelectDup(db, pOldItem->pSelect, flags);\n@@ -110414,1 +111467,0 @@\n-  assert( p->eU4!=EU4_EXPR );\n@@ -110418,1 +111470,0 @@\n-  pNew->eU4 = p->eU4;\n@@ -110423,1 +111474,0 @@\n-    pNewItem->u4 = pOldItem->u4;\n@@ -110472,1 +111522,0 @@\n-\n@@ -110859,0 +111908,48 @@\n+\/*\n+** pExpr is a TK_FUNCTION node.  Try to determine whether or not the\n+** function is a constant function.  A function is constant if all of\n+** the following are true:\n+**\n+**    (1)  It is a scalar function (not an aggregate or window function)\n+**    (2)  It has either the SQLITE_FUNC_CONSTANT or SQLITE_FUNC_SLOCHNG\n+**         property.\n+**    (3)  All of its arguments are constants\n+**\n+** This routine sets pWalker->eCode to 0 if pExpr is not a constant.\n+** It makes no changes to pWalker->eCode if pExpr is constant.  In\n+** every case, it returns WRC_Abort.\n+**\n+** Called as a service subroutine from exprNodeIsConstant().\n+*\/\n+static SQLITE_NOINLINE int exprNodeIsConstantFunction(\n+  Walker *pWalker,\n+  Expr *pExpr\n+){\n+  int n;             \/* Number of arguments *\/\n+  ExprList *pList;   \/* List of arguments *\/\n+  FuncDef *pDef;     \/* The function *\/\n+  sqlite3 *db;       \/* The database *\/\n+\n+  assert( pExpr->op==TK_FUNCTION );\n+  if( ExprHasProperty(pExpr, EP_TokenOnly)\n+   || (pList = pExpr->x.pList)==0\n+  ){;\n+    n = 0;\n+  }else{\n+    n = pList->nExpr;\n+    sqlite3WalkExprList(pWalker, pList);\n+    if( pWalker->eCode==0 ) return WRC_Abort;\n+  }\n+  db = pWalker->pParse->db;\n+  pDef = sqlite3FindFunction(db, pExpr->u.zToken, n, ENC(db), 0);\n+  if( pDef==0\n+   || pDef->xFinalize!=0\n+   || (pDef->funcFlags & (SQLITE_FUNC_CONSTANT|SQLITE_FUNC_SLOCHNG))==0\n+   || ExprHasProperty(pExpr, EP_WinFunc)\n+  ){\n+    pWalker->eCode = 0;\n+    return WRC_Abort;\n+  }\n+  return WRC_Prune;\n+}\n+\n@@ -110887,0 +111984,1 @@\n+  assert( pWalker->eCode>0 );\n@@ -110906,0 +112004,2 @@\n+      }else if( pWalker->pParse ){\n+        return exprNodeIsConstantFunction(pWalker, pExpr);\n@@ -110934,0 +112034,1 @@\n+    case TK_RAISE:\n@@ -110937,0 +112038,1 @@\n+      testcase( pExpr->op==TK_RAISE );\n@@ -110958,1 +112060,1 @@\n-static int exprIsConst(Expr *p, int initFlag, int iCur){\n+static int exprIsConst(Parse *pParse, Expr *p, int initFlag){\n@@ -110961,0 +112063,1 @@\n+  w.pParse = pParse;\n@@ -110966,1 +112069,0 @@\n-  w.u.iCur = iCur;\n@@ -110978,0 +112080,6 @@\n+**\n+** The pParse parameter may be NULL.  But if it is NULL, there is no way\n+** to determine if function calls are constant or not, and hence all\n+** function calls will be considered to be non-constant.  If pParse is\n+** not NULL, then a function call might be constant, depending on the\n+** function and on its parameters.\n@@ -110979,2 +112087,2 @@\n-SQLITE_PRIVATE int sqlite3ExprIsConstant(Expr *p){\n-  return exprIsConst(p, 1, 0);\n+SQLITE_PRIVATE int sqlite3ExprIsConstant(Parse *pParse, Expr *p){\n+  return exprIsConst(pParse, p, 1);\n@@ -110996,2 +112104,18 @@\n-SQLITE_PRIVATE int sqlite3ExprIsConstantNotJoin(Expr *p){\n-  return exprIsConst(p, 2, 0);\n+static int sqlite3ExprIsConstantNotJoin(Parse *pParse, Expr *p){\n+  return exprIsConst(pParse, p, 2);\n+}\n+\n+\/*\n+** This routine examines sub-SELECT statements as an expression is being\n+** walked as part of sqlite3ExprIsTableConstant().  Sub-SELECTs are considered\n+** constant as long as they are uncorrelated - meaning that they do not\n+** contain any terms from outer contexts.\n+*\/\n+static int exprSelectWalkTableConstant(Walker *pWalker, Select *pSelect){\n+  assert( pSelect!=0 );\n+  assert( pWalker->eCode==3 || pWalker->eCode==0 );\n+  if( (pSelect->selFlags & SF_Correlated)!=0 ){\n+    pWalker->eCode = 0;\n+    return WRC_Abort;\n+  }\n+  return WRC_Prune;\n@@ -111005,0 +112129,3 @@\n+**\n+** Consider uncorrelated subqueries to be constants if the bAllowSubq\n+** parameter is true.\n@@ -111006,2 +112133,16 @@\n-SQLITE_PRIVATE int sqlite3ExprIsTableConstant(Expr *p, int iCur){\n-  return exprIsConst(p, 3, iCur);\n+static int sqlite3ExprIsTableConstant(Expr *p, int iCur, int bAllowSubq){\n+  Walker w;\n+  w.eCode = 3;\n+  w.pParse = 0;\n+  w.xExprCallback = exprNodeIsConstant;\n+  if( bAllowSubq ){\n+    w.xSelectCallback = exprSelectWalkTableConstant;\n+  }else{\n+    w.xSelectCallback = sqlite3SelectWalkFail;\n+#ifdef SQLITE_DEBUG\n+    w.xSelectCallback2 = sqlite3SelectWalkAssert2;\n+#endif\n+  }\n+  w.u.iCur = iCur;\n+  sqlite3WalkExpr(&w, p);\n+  return w.eCode;\n@@ -111025,1 +112166,4 @@\n-**   (2)  pExpr cannot use subqueries or non-deterministic functions.\n+**   (2a) pExpr cannot use subqueries unless the bAllowSubq parameter is\n+**        true and the subquery is non-correlated\n+**\n+**   (2b) pExpr cannot use non-deterministic functions.\n@@ -111034,1 +112178,1 @@\n-**   (5)  If pSrc is not the right operand of a LEFT JOIN or the left\n+**   (5)  If pSrc is the right operand of a LEFT JOIN or the left\n@@ -111054,1 +112198,2 @@\n-  int iSrc                     \/* Which element of pSrcList to use *\/\n+  int iSrc,                    \/* Which element of pSrcList to use *\/\n+  int bAllowSubq               \/* Allow non-correlated subqueries *\/\n@@ -111079,1 +112224,2 @@\n-  return sqlite3ExprIsTableConstant(pExpr, pSrc->iCursor); \/* rules (1), (2) *\/\n+  \/* Rules (1), (2a), and (2b) handled by the following: *\/\n+  return sqlite3ExprIsTableConstant(pExpr, pSrc->iCursor, bAllowSubq);\n@@ -111164,1 +112310,1 @@\n-  return exprIsConst(p, 4+isInit, 0);\n+  return exprIsConst(0, p, 4+isInit);\n@@ -111190,0 +112336,4 @@\n+**\n+** If the pParse pointer is provided, then allow the expression p to be\n+** a parameter (TK_VARIABLE) that is bound to an integer.\n+** But if pParse is NULL, then p must be a pure integer literal.\n@@ -111191,1 +112341,1 @@\n-SQLITE_PRIVATE int sqlite3ExprIsInteger(const Expr *p, int *pValue){\n+SQLITE_PRIVATE int sqlite3ExprIsInteger(const Expr *p, int *pValue, Parse *pParse){\n@@ -111206,1 +112356,1 @@\n-      rc = sqlite3ExprIsInteger(p->pLeft, pValue);\n+      rc = sqlite3ExprIsInteger(p->pLeft, pValue, 0);\n@@ -111211,1 +112361,1 @@\n-      if( sqlite3ExprIsInteger(p->pLeft, &v) ){\n+      if( sqlite3ExprIsInteger(p->pLeft, &v, 0) ){\n@@ -111218,0 +112368,20 @@\n+    case TK_VARIABLE: {\n+      sqlite3_value *pVal;\n+      if( pParse==0 ) break;\n+      if( NEVER(pParse->pVdbe==0) ) break;\n+      if( (pParse->db->flags & SQLITE_EnableQPSG)!=0 ) break;\n+      sqlite3VdbeSetVarmask(pParse->pVdbe, p->iColumn);\n+      pVal = sqlite3VdbeGetBoundValue(pParse->pReprepare, p->iColumn,\n+                                      SQLITE_AFF_BLOB);\n+      if( pVal ){\n+        if( sqlite3_value_type(pVal)==SQLITE_INTEGER ){\n+          sqlite3_int64 vv = sqlite3_value_int64(pVal);\n+          if( vv == (vv & 0x7fffffff) ){ \/* non-negative numbers only *\/\n+            *pValue = (int)vv;\n+            rc = 1;\n+          }\n+        }\n+        sqlite3ValueFree(pVal);\n+      }\n+      break;\n+    }\n@@ -111371,2 +112541,2 @@\n-  if( pSrc->a[0].pSelect ) return 0;     \/* FROM is not a subquery or view *\/\n-  pTab = pSrc->a[0].pTab;\n+  if( pSrc->a[0].fg.isSubquery) return 0;\/* FROM is not a subquery or view *\/\n+  pTab = pSrc->a[0].pSTab;\n@@ -111412,1 +112582,1 @@\n-static int sqlite3InRhsIsConstant(Expr *pIn){\n+static int sqlite3InRhsIsConstant(Parse *pParse, Expr *pIn){\n@@ -111418,1 +112588,1 @@\n-  res = sqlite3ExprIsConstant(pIn);\n+  res = sqlite3ExprIsConstant(pParse, pIn);\n@@ -111555,1 +112725,1 @@\n-    pTab = p->pSrc->a[0].pTab;\n+    pTab = p->pSrc->a[0].pSTab;\n@@ -111647,0 +112817,1 @@\n+          assert( nExpr>0 && nExpr<BMS );\n@@ -111687,1 +112858,1 @@\n-   && (!sqlite3InRhsIsConstant(pX) || pX->x.pList->nExpr<=2)\n+   && (!sqlite3InRhsIsConstant(pParse,pX) || pX->x.pList->nExpr<=2)\n@@ -111795,0 +112966,44 @@\n+#ifndef SQLITE_OMIT_SUBQUERY\n+\/*\n+** Scan all previously generated bytecode looking for an OP_BeginSubrtn\n+** that is compatible with pExpr.  If found, add the y.sub values\n+** to pExpr and return true.  If not found, return false.\n+*\/\n+static int findCompatibleInRhsSubrtn(\n+  Parse *pParse,          \/* Parsing context *\/\n+  Expr *pExpr,            \/* IN operator with RHS that we want to reuse *\/\n+  SubrtnSig *pNewSig      \/* Signature for the IN operator *\/\n+){\n+  VdbeOp *pOp, *pEnd;\n+  SubrtnSig *pSig;\n+  Vdbe *v;\n+\n+  if( pNewSig==0 ) return 0;\n+  if( (pParse->mSubrtnSig & (1<<(pNewSig->selId&7)))==0 ) return 0;\n+  assert( pExpr->op==TK_IN );\n+  assert( !ExprUseYSub(pExpr) );\n+  assert( ExprUseXSelect(pExpr) );\n+  assert( pExpr->x.pSelect!=0 );\n+  assert( (pExpr->x.pSelect->selFlags & SF_All)==0 );\n+  v = pParse->pVdbe;\n+  assert( v!=0 );\n+  pOp = sqlite3VdbeGetOp(v, 1);\n+  pEnd = sqlite3VdbeGetLastOp(v);\n+  for(; pOp<pEnd; pOp++){\n+    if( pOp->p4type!=P4_SUBRTNSIG ) continue;\n+    assert( pOp->opcode==OP_BeginSubrtn );\n+    pSig = pOp->p4.pSubrtnSig;\n+    assert( pSig!=0 );\n+    if( !pSig->bComplete ) continue;\n+    if( pNewSig->selId!=pSig->selId ) continue;\n+    if( strcmp(pNewSig->zAff,pSig->zAff)!=0 ) continue;\n+    pExpr->y.sub.iAddr = pSig->iAddr;\n+    pExpr->y.sub.regReturn = pSig->regReturn;\n+    pExpr->iTable = pSig->iTable;\n+    ExprSetProperty(pExpr, EP_Subrtn);\n+    return 1;\n+  }\n+  return 0;\n+}\n+#endif \/* SQLITE_OMIT_SUBQUERY *\/\n+\n@@ -111829,0 +113044,1 @@\n+  SubrtnSig *pSig = 0;        \/* Signature for this subroutine *\/\n@@ -111844,3 +113060,4 @@\n-    \/* Reuse of the RHS is allowed *\/\n-    \/* If this routine has already been coded, but the previous code\n-    ** might not have been invoked yet, so invoke it now as a subroutine.\n+    \/* Reuse of the RHS is allowed\n+    **\n+    ** Compute a signature for the RHS of the IN operator to facility\n+    ** finding and reusing prior instances of the same IN operator.\n@@ -111848,1 +113065,16 @@\n-    if( ExprHasProperty(pExpr, EP_Subrtn) ){\n+    assert( !ExprUseXSelect(pExpr) || pExpr->x.pSelect!=0 );\n+    if( ExprUseXSelect(pExpr) && (pExpr->x.pSelect->selFlags & SF_All)==0 ){\n+      pSig = sqlite3DbMallocRawNN(pParse->db, sizeof(pSig[0]));\n+      if( pSig ){\n+        pSig->selId = pExpr->x.pSelect->selId;\n+        pSig->zAff = exprINAffinity(pParse, pExpr);\n+      }\n+    }\n+\n+    \/* Check to see if there is a prior materialization of the RHS of\n+    ** this IN operator.  If there is, then make use of that prior\n+    ** materialization rather than recomputing it.\n+    *\/\n+    if( ExprHasProperty(pExpr, EP_Subrtn)\n+     || findCompatibleInRhsSubrtn(pParse, pExpr, pSig)\n+    ){\n@@ -111860,0 +113092,4 @@\n+      if( pSig ){\n+        sqlite3DbFree(pParse->db, pSig->zAff);\n+        sqlite3DbFree(pParse->db, pSig);\n+      }\n@@ -111870,1 +113106,8 @@\n-\n+    if( pSig ){\n+      pSig->bComplete = 0;\n+      pSig->iAddr = pExpr->y.sub.iAddr;\n+      pSig->regReturn = pExpr->y.sub.regReturn;\n+      pSig->iTable = iTab;\n+      pParse->mSubrtnSig = 1 << (pSig->selId&7);\n+      sqlite3VdbeChangeP4(v, -1, (const char*)pSig, P4_SUBRTNSIG);\n+    }\n@@ -111911,0 +113154,1 @@\n+      int addrBloom = 0;\n@@ -111914,0 +113158,6 @@\n+      if( addrOnce && OptimizationEnabled(pParse->db, SQLITE_BloomFilter) ){\n+        int regBloom = ++pParse->nMem;\n+        addrBloom = sqlite3VdbeAddOp2(v, OP_Blob, 10000, regBloom);\n+        VdbeComment((v, \"Bloom filter\"));\n+        dest.iSDParm2 = regBloom;\n+      }\n@@ -111920,0 +113170,8 @@\n+      if( addrBloom ){\n+        sqlite3VdbeGetOp(v, addrOnce)->p3 = dest.iSDParm2;\n+        if( dest.iSDParm2==0 ){\n+          sqlite3VdbeChangeToNoop(v, addrBloom);\n+        }else{\n+          sqlite3VdbeGetOp(v, addrOnce)->p3 = dest.iSDParm2;\n+        }\n+      }\n@@ -111970,1 +113228,1 @@\n-      if( addrOnce && !sqlite3ExprIsConstant(pE2) ){\n+      if( addrOnce && !sqlite3ExprIsConstant(pParse, pE2) ){\n@@ -111985,0 +113243,1 @@\n+  if( pSig ) pSig->bComplete = 1;\n@@ -112217,3 +113476,1 @@\n-  aiMap = (int*)sqlite3DbMallocZero(\n-      pParse->db, nVector*(sizeof(int) + sizeof(char)) + 1\n-  );\n+  aiMap = (int*)sqlite3DbMallocZero(pParse->db, nVector*sizeof(int));\n@@ -112362,0 +113619,9 @@\n+      if( ExprHasProperty(pExpr, EP_Subrtn) ){\n+        const VdbeOp *pOp = sqlite3VdbeGetOp(v, pExpr->y.sub.iAddr);\n+        assert( pOp->opcode==OP_Once || pParse->nErr );\n+        if( pOp->opcode==OP_Once && pOp->p3>0 ){\n+          assert( OptimizationEnabled(pParse->db, SQLITE_BloomFilter) );\n+          sqlite3VdbeAddOp4Int(v, OP_Filter, pOp->p3, destIfFalse,\n+                               rLhs, nVector); VdbeCoverage(v);\n+        }\n+      }\n@@ -112644,1 +113910,1 @@\n-static void exprToRegister(Expr *pExpr, int iReg){\n+SQLITE_PRIVATE void sqlite3ExprToRegister(Expr *pExpr, int iReg){\n@@ -112647,4 +113913,8 @@\n-  p->op2 = p->op;\n-  p->op = TK_REGISTER;\n-  p->iTable = iReg;\n-  ExprClearProperty(p, EP_Skip);\n+  if( p->op==TK_REGISTER ){\n+    assert( p->iTable==iReg );\n+  }else{\n+    p->op2 = p->op;\n+    p->op = TK_REGISTER;\n+    p->iTable = iReg;\n+    ExprClearProperty(p, EP_Skip);\n+  }\n@@ -112820,0 +114090,53 @@\n+\/*\n+** Expression Node callback for sqlite3ExprCanReturnSubtype().\n+**\n+** Only a function call is able to return a subtype.  So if the node\n+** is not a function call, return WRC_Prune immediately.\n+**\n+** A function call is able to return a subtype if it has the\n+** SQLITE_RESULT_SUBTYPE property.\n+**\n+** Assume that every function is able to pass-through a subtype from\n+** one of its argument (using sqlite3_result_value()).  Most functions\n+** are not this way, but we don't have a mechanism to distinguish those\n+** that are from those that are not, so assume they all work this way.\n+** That means that if one of its arguments is another function and that\n+** other function is able to return a subtype, then this function is\n+** able to return a subtype.\n+*\/\n+static int exprNodeCanReturnSubtype(Walker *pWalker, Expr *pExpr){\n+  int n;\n+  FuncDef *pDef;\n+  sqlite3 *db;\n+  if( pExpr->op!=TK_FUNCTION ){\n+    return WRC_Prune;\n+  }\n+  assert( ExprUseXList(pExpr) );\n+  db = pWalker->pParse->db;\n+  n = ALWAYS(pExpr->x.pList) ? pExpr->x.pList->nExpr : 0;\n+  pDef = sqlite3FindFunction(db, pExpr->u.zToken, n, ENC(db), 0);\n+  if( NEVER(pDef==0) || (pDef->funcFlags & SQLITE_RESULT_SUBTYPE)!=0 ){\n+    pWalker->eCode = 1;\n+    return WRC_Prune;\n+  }\n+  return WRC_Continue;\n+}\n+\n+\/*\n+** Return TRUE if expression pExpr is able to return a subtype.\n+**\n+** A TRUE return does not guarantee that a subtype will be returned.\n+** It only indicates that a subtype return is possible.  False positives\n+** are acceptable as they only disable an optimization.  False negatives,\n+** on the other hand, can lead to incorrect answers.\n+*\/\n+static int sqlite3ExprCanReturnSubtype(Parse *pParse, Expr *pExpr){\n+  Walker w;\n+  memset(&w, 0, sizeof(w));\n+  w.pParse = pParse;\n+  w.xExprCallback = exprNodeCanReturnSubtype;\n+  sqlite3WalkExpr(&w, pExpr);\n+  return w.eCode;\n+}\n+\n+\n@@ -112852,0 +114175,11 @@\n+\n+    \/* Functions that might set a subtype should not be replaced by the\n+    ** value taken from an expression index if they are themselves an\n+    ** argument to another scalar function or aggregate.\n+    ** https:\/\/sqlite.org\/forum\/forumpost\/68d284c86b082c3e *\/\n+    if( ExprHasProperty(pExpr, EP_SubtArg)\n+     && sqlite3ExprCanReturnSubtype(pParse, pExpr)\n+    ){\n+      continue;\n+    }\n+\n@@ -113134,6 +114468,0 @@\n-      if( pExpr->u.zToken[1]!=0 ){\n-        const char *z = sqlite3VListNumToName(pParse->pVList, pExpr->iColumn);\n-        assert( pExpr->u.zToken[0]=='?' || (z && !strcmp(pExpr->u.zToken, z)) );\n-        pParse->pVList[0] = 0; \/* Indicate VList may no longer be enlarged *\/\n-        sqlite3VdbeAppendP4(v, (char*)z, P4_STATIC);\n-      }\n@@ -113313,1 +114641,3 @@\n-      if( ConstFactorOk(pParse) && sqlite3ExprIsConstantNotJoin(pExpr) ){\n+      if( ConstFactorOk(pParse)\n+       && sqlite3ExprIsConstantNotJoin(pParse,pExpr)\n+      ){\n@@ -113344,1 +114674,1 @@\n-        if( i<32 && sqlite3ExprIsConstant(pFarg->a[i].pExpr) ){\n+        if( i<32 && sqlite3ExprIsConstant(pParse, pFarg->a[i].pExpr) ){\n@@ -113486,2 +114816,3 @@\n-        ** from outer queries into sub-queries by the push-down optimization.\n-        ** Clear subtypes as subtypes may not cross a subquery boundary.\n+        ** from outer queries into sub-queries by the WHERE-clause push-down\n+        ** optimization. Clear subtypes as subtypes may not cross a subquery\n+        ** boundary.\n@@ -113656,1 +114987,1 @@\n-        exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));\n+        sqlite3ExprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));\n@@ -113710,2 +115041,1 @@\n-        sqlite3VdbeAddOp4(\n-            v, OP_Halt, SQLITE_OK, OE_Ignore, 0, pExpr->u.zToken,0);\n+        sqlite3VdbeAddOp2(v, OP_Halt, SQLITE_OK, OE_Ignore);\n@@ -113714,1 +115044,2 @@\n-        sqlite3HaltConstraint(pParse,\n+        r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n+        sqlite3VdbeAddOp3(v, OP_Halt,\n@@ -113716,1 +115047,1 @@\n-             pExpr->affExpr, pExpr->u.zToken, 0, 0);\n+             pExpr->affExpr, r1);\n@@ -113718,1 +115049,0 @@\n-\n@@ -113811,1 +115141,1 @@\n-   && sqlite3ExprIsConstantNotJoin(pExpr)\n+   && sqlite3ExprIsConstantNotJoin(pParse, pExpr)\n@@ -113875,1 +115205,1 @@\n-  if( pParse->okConstFactor && sqlite3ExprIsConstantNotJoin(pExpr) ){\n+  if( pParse->okConstFactor && sqlite3ExprIsConstantNotJoin(pParse,pExpr) ){\n@@ -113934,1 +115264,1 @@\n-           && sqlite3ExprIsConstantNotJoin(pExpr)\n+           && sqlite3ExprIsConstantNotJoin(pParse,pExpr)\n@@ -114007,1 +115337,1 @@\n-    exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));\n+    sqlite3ExprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));\n@@ -114386,0 +115716,3 @@\n+**\n+** If the SQLITE_EnableQPSG flag is set on the database connection, then\n+** this routine always returns false.\n@@ -114387,1 +115720,1 @@\n-static int exprCompareVariable(\n+static SQLITE_NOINLINE int exprCompareVariable(\n@@ -114392,1 +115725,1 @@\n-  int res = 0;\n+  int res = 2;\n@@ -114396,0 +115729,4 @@\n+  if( pExpr->op==TK_VARIABLE && pVar->iColumn==pExpr->iColumn ){\n+    return 0;\n+  }\n+  if( (pParse->db->flags & SQLITE_EnableQPSG)!=0 ) return 2;\n@@ -114405,1 +115742,1 @@\n-      res =  0==sqlite3MemCompare(pL, pR, 0);\n+      res = sqlite3MemCompare(pL, pR, 0) ? 2 : 0;\n@@ -114410,1 +115747,0 @@\n-\n@@ -114436,6 +115772,4 @@\n-** If pParse is not NULL then TK_VARIABLE terms in pA with bindings in\n-** pParse->pReprepare can be matched against literals in pB.  The\n-** pParse->pVdbe->expmask bitmask is updated for each variable referenced.\n-** If pParse is NULL (the normal case) then any TK_VARIABLE term in\n-** Argument pParse should normally be NULL. If it is not NULL and pA or\n-** pB causes a return value of 2.\n+** If pParse is not NULL and SQLITE_EnableQPSG is off then TK_VARIABLE\n+** terms in pA with bindings in pParse->pReprepare can be matched against\n+** literals in pB.  The pParse->pVdbe->expmask bitmask is updated for\n+** each variable referenced.\n@@ -114453,2 +115787,2 @@\n-  if( pParse && pA->op==TK_VARIABLE && exprCompareVariable(pParse, pA, pB) ){\n-    return 0;\n+  if( pParse && pA->op==TK_VARIABLE ){\n+    return exprCompareVariable(pParse, pA, pB);\n@@ -114649,0 +115983,50 @@\n+\/*\n+** Return true if the boolean value of the expression is always either\n+** FALSE or NULL.\n+*\/\n+static int sqlite3ExprIsNotTrue(Expr *pExpr){\n+  int v;\n+  if( pExpr->op==TK_NULL ) return 1;\n+  if( pExpr->op==TK_TRUEFALSE && sqlite3ExprTruthValue(pExpr)==0 ) return 1;\n+  v = 1;\n+  if( sqlite3ExprIsInteger(pExpr, &v, 0) && v==0 ) return 1;\n+  return 0;\n+}\n+\n+\/*\n+** Return true if the expression is one of the following:\n+**\n+**    CASE WHEN x THEN y END\n+**    CASE WHEN x THEN y ELSE NULL END\n+**    CASE WHEN x THEN y ELSE false END\n+**    iif(x,y)\n+**    iif(x,y,NULL)\n+**    iif(x,y,false)\n+*\/\n+static int sqlite3ExprIsIIF(sqlite3 *db, const Expr *pExpr){\n+  ExprList *pList;\n+  if( pExpr->op==TK_FUNCTION ){\n+    const char *z = pExpr->u.zToken;\n+    FuncDef *pDef;\n+    if( (z[0]!='i' && z[0]!='I') ) return 0;\n+    if( pExpr->x.pList==0 ) return 0;\n+    pDef = sqlite3FindFunction(db, z, pExpr->x.pList->nExpr, ENC(db), 0);\n+#ifdef SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION\n+    if( pDef==0 ) return 0;\n+#else\n+    if( NEVER(pDef==0) ) return 0;\n+#endif\n+    if( (pDef->funcFlags & SQLITE_FUNC_INLINE)==0 ) return 0;\n+    if( SQLITE_PTR_TO_INT(pDef->pUserData)!=INLINEFUNC_iif ) return 0;\n+  }else if( pExpr->op==TK_CASE ){\n+    if( pExpr->pLeft!=0 ) return 0;\n+  }else{\n+    return 0;\n+  }\n+  pList = pExpr->x.pList;\n+  assert( pList!=0 );\n+  if( pList->nExpr==2 ) return 1;\n+  if( pList->nExpr==3 && sqlite3ExprIsNotTrue(pList->a[2].pExpr) ) return 1;\n+  return 0;\n+}\n+\n@@ -114654,7 +116038,9 @@\n-**     pE1: x==5       pE2: x==5             Result: true\n-**     pE1: x>0        pE2: x==5             Result: false\n-**     pE1: x=21       pE2: x=21 OR y=43     Result: true\n-**     pE1: x!=123     pE2: x IS NOT NULL    Result: true\n-**     pE1: x!=?1      pE2: x IS NOT NULL    Result: true\n-**     pE1: x IS NULL  pE2: x IS NOT NULL    Result: false\n-**     pE1: x IS ?2    pE2: x IS NOT NULL    Result: false\n+**     pE1: x==5        pE2: x==5             Result: true\n+**     pE1: x>0         pE2: x==5             Result: false\n+**     pE1: x=21        pE2: x=21 OR y=43     Result: true\n+**     pE1: x!=123      pE2: x IS NOT NULL    Result: true\n+**     pE1: x!=?1       pE2: x IS NOT NULL    Result: true\n+**     pE1: x IS NULL   pE2: x IS NOT NULL    Result: false\n+**     pE1: x IS ?2     pE2: x IS NOT NULL    Result: false\n+**     pE1: iif(x,y)    pE2: x                Result: true\n+**     PE1: iif(x,y,0)  pE2: x                Result: true\n@@ -114694,0 +116080,3 @@\n+  if( sqlite3ExprIsIIF(pParse->db, pE1) ){\n+    return sqlite3ExprImpliesExpr(pParse,pE1->x.pList->a[0].pExpr,pE2,iTab);\n+  }\n@@ -115085,1 +116474,1 @@\n-        if( pExpr ){\n+        if( pExpr && !sqlite3ExprDeferredDelete(pParse, pExpr) ){\n@@ -115087,1 +116476,0 @@\n-          sqlite3ExprDeferredDelete(pParse, pExpr);\n@@ -115096,1 +116484,1 @@\n-        if( pExpr ){\n+        if( pExpr && !sqlite3ExprDeferredDelete(pParse, pExpr) ){\n@@ -115098,1 +116486,0 @@\n-          sqlite3ExprDeferredDelete(pParse, pExpr);\n@@ -116857,1 +118244,1 @@\n-    rc = sqlite3ViewGetColumnNames(pParse, pParse->pTriggerTab);\n+    rc = sqlite3ViewGetColumnNames(pParse, pParse->pTriggerTab)!=0;\n@@ -116903,2 +118290,3 @@\n-            if( p->pSelect ){\n-              sqlite3SelectPrep(pParse, p->pSelect, 0);\n+            if( p->fg.isSubquery ){\n+              assert( p->u4.pSubq!=0 );\n+              sqlite3SelectPrep(pParse, p->u4.pSubq->pSelect, 0);\n@@ -116972,2 +118360,6 @@\n-      for(i=0; i<pStep->pFrom->nSrc; i++){\n-        sqlite3WalkSelect(pWalker, pStep->pFrom->a[i].pSelect);\n+      SrcList *pFrom = pStep->pFrom;\n+      for(i=0; i<pFrom->nSrc; i++){\n+        if( pFrom->a[i].fg.isSubquery ){\n+          assert( pFrom->a[i].u4.pSubq!=0 );\n+          sqlite3WalkSelect(pWalker, pFrom->a[i].u4.pSubq->pSelect);\n+        }\n@@ -117220,1 +118612,1 @@\n-    if( pItem->pTab==p->pTab ){\n+    if( pItem->pSTab==p->pTab ){\n@@ -117799,0 +119191,4 @@\n+          char aff = pTab->aCol[i].affinity;\n+          if( aff==SQLITE_AFF_REAL ){\n+            pTab->aCol[i].affinity = SQLITE_AFF_NUMERIC;\n+          }\n@@ -117800,0 +119196,1 @@\n+          pTab->aCol[i].affinity = aff;\n@@ -118718,1 +120115,1 @@\n-      assert( p->current.anEq[i] );\n+      assert( p->current.anEq[i] || p->nRow==0 );\n@@ -118903,1 +120300,1 @@\n-    int addrRewind;               \/* Address of \"OP_Rewind iIdxCur\" *\/\n+    int addrGotoEnd;               \/* Address of \"OP_Rewind iIdxCur\" *\/\n@@ -118927,2 +120324,0 @@\n-    **   Rewind csr\n-    **   if eof(csr) goto end_of_scan;\n@@ -118930,0 +120325,7 @@\n+    **   Rewind csr\n+    **   if eof(csr){\n+    **      stat_init() with count = 0;\n+    **      goto end_of_scan;\n+    **   }\n+    **   count()\n+    **   stat_init()\n@@ -118968,1 +120370,1 @@\n-    \/* Invoke the stat_init() function. The arguments are:\n+    \/* Implementation of the following:\n@@ -118970,0 +120372,14 @@\n+    **   regChng = 0\n+    **   Rewind csr\n+    **   if eof(csr){\n+    **      stat_init() with count = 0;\n+    **      goto end_of_scan;\n+    **   }\n+    **   count()\n+    **   stat_init()\n+    **   goto chng_addr_0;\n+    *\/\n+    assert( regTemp2==regStat+4 );\n+    sqlite3VdbeAddOp2(v, OP_Integer, db->nAnalysisLimit, regTemp2);\n+\n+    \/* Arguments to stat_init():\n@@ -118973,2 +120389,1 @@\n-    **    (3) estimated number of rows in the index,\n-    *\/\n+    **    (3) estimated number of rows in the index. *\/\n@@ -118978,14 +120393,2 @@\n-#ifdef SQLITE_ENABLE_STAT4\n-    if( OptimizationEnabled(db, SQLITE_Stat4) ){\n-      sqlite3VdbeAddOp2(v, OP_Count, iIdxCur, regTemp);\n-      addrRewind = sqlite3VdbeAddOp1(v, OP_Rewind, iIdxCur);\n-      VdbeCoverage(v);\n-    }else\n-#endif\n-    {\n-      addrRewind = sqlite3VdbeAddOp1(v, OP_Rewind, iIdxCur);\n-      VdbeCoverage(v);\n-      sqlite3VdbeAddOp3(v, OP_Count, iIdxCur, regTemp, 1);\n-    }\n-    assert( regTemp2==regStat+4 );\n-    sqlite3VdbeAddOp2(v, OP_Integer, db->nAnalysisLimit, regTemp2);\n+    sqlite3VdbeAddOp3(v, OP_Count, iIdxCur, regTemp,\n+                      OptimizationDisabled(db, SQLITE_Stat4));\n@@ -118994,0 +120397,2 @@\n+    addrGotoEnd = sqlite3VdbeAddOp1(v, OP_Rewind, iIdxCur);\n+    VdbeCoverage(v);\n@@ -118995,8 +120400,0 @@\n-    \/* Implementation of the following:\n-    **\n-    **   Rewind csr\n-    **   if eof(csr) goto end_of_scan;\n-    **   regChng = 0\n-    **   goto next_push_0;\n-    **\n-    *\/\n@@ -119109,0 +120506,6 @@\n+    if( pIdx->pPartIdxWhere ){\n+      \/* Partial indexes might get a zero-entry in sqlite_stat1.  But\n+      ** an empty table is omitted from sqlite_stat1. *\/\n+      sqlite3VdbeJumpHere(v, addrGotoEnd);\n+      addrGotoEnd = 0;\n+    }\n@@ -119132,0 +120535,7 @@\n+      \/* No STAT4 data is generated if the number of rows is zero *\/\n+      if( addrGotoEnd==0 ){\n+        sqlite3VdbeAddOp2(v, OP_Cast, regStat1, SQLITE_AFF_INTEGER);\n+        addrGotoEnd = sqlite3VdbeAddOp1(v, OP_IfNot, regStat1);\n+        VdbeCoverage(v);\n+      }\n+\n@@ -119184,1 +120594,1 @@\n-    sqlite3VdbeJumpHere(v, addrRewind);\n+    if( addrGotoEnd ) sqlite3VdbeJumpHere(v, addrGotoEnd);\n@@ -119630,6 +121040,7 @@\n-    char *zIndex;   \/* Index name *\/\n-    Index *pIdx;    \/* Pointer to the index object *\/\n-    int nSample;    \/* Number of samples *\/\n-    int nByte;      \/* Bytes of space required *\/\n-    int i;          \/* Bytes of space required *\/\n-    tRowcnt *pSpace;\n+    char *zIndex;    \/* Index name *\/\n+    Index *pIdx;     \/* Pointer to the index object *\/\n+    int nSample;     \/* Number of samples *\/\n+    i64 nByte;       \/* Bytes of space required *\/\n+    i64 i;           \/* Bytes of space required *\/\n+    tRowcnt *pSpace; \/* Available allocated memory space *\/\n+    u8 *pPtr;        \/* Available memory as a u8 for easier manipulation *\/\n@@ -119655,1 +121066,1 @@\n-    nByte = sizeof(IndexSample) * nSample;\n+    nByte = ROUND8(sizeof(IndexSample) * nSample);\n@@ -119664,1 +121075,4 @@\n-    pSpace = (tRowcnt*)&pIdx->aSample[nSample];\n+    pPtr = (u8*)pIdx->aSample;\n+    pPtr += ROUND8(nSample*sizeof(pIdx->aSample[0]));\n+    pSpace = (tRowcnt*)pPtr;\n+    assert( EIGHT_BYTE_ALIGNMENT( pSpace ) );\n@@ -120028,0 +121442,6 @@\n+    if( (db->flags & SQLITE_AttachWrite)==0 ){\n+      flags &= ~(SQLITE_OPEN_CREATE|SQLITE_OPEN_READWRITE);\n+      flags |= SQLITE_OPEN_READONLY;\n+    }else if( (db->flags & SQLITE_AttachCreate)==0 ){\n+      flags &= ~SQLITE_OPEN_CREATE;\n+    }\n@@ -120080,9 +121500,0 @@\n-#ifdef SQLITE_USER_AUTHENTICATION\n-  if( rc==SQLITE_OK && !REOPEN_AS_MEMDB(db) ){\n-    u8 newAuth = 0;\n-    rc = sqlite3UserAuthCheckLogin(db, zName, &newAuth);\n-    if( newAuth<db->auth.authLevel ){\n-      rc = SQLITE_AUTH_USER;\n-    }\n-  }\n-#endif\n@@ -120332,3 +121743,3 @@\n-    if( pFix->bTemp==0 ){\n-      if( pItem->zDatabase ){\n-        if( iDb!=sqlite3FindDbName(db, pItem->zDatabase) ){\n+    if( pFix->bTemp==0 && pItem->fg.isSubquery==0 ){\n+      if( pItem->fg.fixedSchema==0 && pItem->u4.zDatabase!=0 ){\n+        if( iDb!=sqlite3FindDbName(db, pItem->u4.zDatabase) ){\n@@ -120337,1 +121748,1 @@\n-              pFix->zType, pFix->pName, pItem->zDatabase);\n+              pFix->zType, pFix->pName, pItem->u4.zDatabase);\n@@ -120340,2 +121751,1 @@\n-        sqlite3DbFree(db, pItem->zDatabase);\n-        pItem->zDatabase = 0;\n+        sqlite3DbFree(db, pItem->u4.zDatabase);\n@@ -120343,0 +121753,1 @@\n+        pItem->fg.hadSchema = 1;\n@@ -120344,1 +121755,1 @@\n-      pItem->pSchema = pFix->pSchema;\n+      pItem->u4.pSchema = pFix->pSchema;\n@@ -120346,0 +121757,1 @@\n+      pItem->fg.fixedSchema = 1;\n@@ -120585,5 +121997,1 @@\n-  rc = db->xAuth(db->pAuthArg, SQLITE_READ, zTab,zCol,zDb,pParse->zAuthContext\n-#ifdef SQLITE_USER_AUTHENTICATION\n-                 ,db->auth.zAuthUser\n-#endif\n-                );\n+  rc = db->xAuth(db->pAuthArg, SQLITE_READ, zTab,zCol,zDb,pParse->zAuthContext);\n@@ -120638,1 +122046,1 @@\n-        pTab = pTabList->a[iSrc].pTab;\n+        pTab = pTabList->a[iSrc].pSTab;\n@@ -120696,5 +122104,1 @@\n-  rc = db->xAuth(db->pAuthArg, code, zArg1, zArg2, zArg3, pParse->zAuthContext\n-#ifdef SQLITE_USER_AUTHENTICATION\n-                 ,db->auth.zAuthUser\n-#endif\n-                );\n+  rc = db->xAuth(db->pAuthArg,code,zArg1,zArg2,zArg3,pParse->zAuthContext);\n@@ -120933,11 +122337,0 @@\n-#if SQLITE_USER_AUTHENTICATION\n-    if( pParse->nTableLock>0 && db->init.busy==0 ){\n-      sqlite3UserAuthInit(db);\n-      if( db->auth.authLevel<UAUTH_User ){\n-        sqlite3ErrorMsg(pParse, \"user not authenticated\");\n-        pParse->rc = SQLITE_AUTH_USER;\n-        return;\n-      }\n-    }\n-#endif\n-\n@@ -121072,10 +122465,0 @@\n-#if SQLITE_USER_AUTHENTICATION\n-\/*\n-** Return TRUE if zTable is the name of the system table that stores the\n-** list of users and their access credentials.\n-*\/\n-SQLITE_PRIVATE int sqlite3UserAuthTable(const char *zTable){\n-  return sqlite3_stricmp(zTable, \"sqlite_user\")==0;\n-}\n-#endif\n-\n@@ -121100,7 +122483,0 @@\n-#if SQLITE_USER_AUTHENTICATION\n-  \/* Only the admin user is allowed to know that the sqlite_user table\n-  ** exists *\/\n-  if( db->auth.authLevel<UAUTH_Admin && sqlite3UserAuthTable(zName)!=0 ){\n-    return 0;\n-  }\n-#endif\n@@ -121241,3 +122617,2 @@\n-  assert( p->pSchema==0 || p->zDatabase==0 );\n-  if( p->pSchema ){\n-    int iDb = sqlite3SchemaToIndex(pParse->db, p->pSchema);\n+  if( p->fg.fixedSchema ){\n+    int iDb = sqlite3SchemaToIndex(pParse->db, p->u4.pSchema);\n@@ -121246,1 +122621,2 @@\n-    zDb = p->zDatabase;\n+    assert( !p->fg.isSubquery );\n+    zDb = p->u4.zDatabase;\n@@ -123572,0 +124948,1 @@\n+      int iCsr;           \/* Write cursor on the new table *\/\n@@ -123578,0 +124955,1 @@\n+      iCsr = pParse->nTab++;\n@@ -123581,1 +124959,0 @@\n-      assert(pParse->nTab==1);\n@@ -123583,1 +124960,1 @@\n-      sqlite3VdbeAddOp3(v, OP_OpenWrite, 1, pParse->regRoot, iDb);\n+      sqlite3VdbeAddOp3(v, OP_OpenWrite, iCsr, pParse->regRoot, iDb);\n@@ -123585,1 +124962,0 @@\n-      pParse->nTab = 2;\n@@ -123606,2 +124982,2 @@\n-      sqlite3VdbeAddOp2(v, OP_NewRowid, 1, regRowid);\n-      sqlite3VdbeAddOp3(v, OP_Insert, 1, regRec, regRowid);\n+      sqlite3VdbeAddOp2(v, OP_NewRowid, iCsr, regRowid);\n+      sqlite3VdbeAddOp3(v, OP_Insert, iCsr, regRec, regRowid);\n@@ -123610,1 +124986,1 @@\n-      sqlite3VdbeAddOp1(v, OP_Close, 1);\n+      sqlite3VdbeAddOp1(v, OP_Close, iCsr);\n@@ -123667,1 +125043,1 @@\n-      sqlite3VdbeAddOp4(v, OP_SqlExec, 1, 0, 0,\n+      sqlite3VdbeAddOp4(v, OP_SqlExec, 0x0001, 0, 0,\n@@ -123671,3 +125047,0 @@\n-    sqlite3VdbeAddOp4(v, OP_SqlExec, 1, 0, 0,\n-           sqlite3MPrintf(db, \"PRAGMA \\\"%w\\\".integrity_check(%Q)\",\n-                 db->aDb[iDb].zDbSName, p->zName), P4_DYNAMIC);\n@@ -123811,2 +125184,3 @@\n-** the columns of the view in the pTable structure.  Return the number\n-** of errors.  If an error is seen leave an error message in pParse->zErrMsg.\n+** the columns of the view in the pTable structure.  Return non-zero if\n+** there are errors.  If an error is seen an error message is left\n+** in pParse->zErrMsg.\n@@ -123935,1 +125309,1 @@\n-  return nErr;\n+  return nErr + pParse->nErr;\n@@ -124233,0 +125607,2 @@\n+  assert( pName->a[0].fg.fixedSchema==0 );\n+  assert( pName->a[0].fg.isSubquery==0 );\n@@ -124241,1 +125617,1 @@\n-      sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);\n+      sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].u4.zDatabase);\n@@ -124765,3 +126141,0 @@\n-#if SQLITE_USER_AUTHENTICATION\n-       && sqlite3UserAuthTable(pTab->zName)==0\n-#endif\n@@ -125332,0 +126705,2 @@\n+  assert( pName->a[0].fg.fixedSchema==0 );\n+  assert( pName->a[0].fg.isSubquery==0 );\n@@ -125335,1 +126710,1 @@\n-  pIndex = sqlite3FindIndex(db, pName->a[0].zName, pName->a[0].zDatabase);\n+  pIndex = sqlite3FindIndex(db, pName->a[0].zName, pName->a[0].u4.zDatabase);\n@@ -125340,1 +126715,1 @@\n-      sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);\n+      sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].u4.zDatabase);\n@@ -125464,1 +126839,0 @@\n-  assert( pList->eU4!=EU4_EXPR ); \/* EU4_EXPR mode is not currently used *\/\n@@ -125637,0 +127011,2 @@\n+  assert( pItem->fg.fixedSchema==0 );\n+  assert( pItem->fg.isSubquery==0 );\n@@ -125639,1 +127015,1 @@\n-    pItem->zDatabase = sqlite3NameFromToken(db, pTable);\n+    pItem->u4.zDatabase = sqlite3NameFromToken(db, pTable);\n@@ -125642,1 +127018,1 @@\n-    pItem->zDatabase = 0;\n+    pItem->u4.zDatabase = 0;\n@@ -125658,2 +127034,5 @@\n-      if( pItem->pSelect ){\n-        sqlite3SrcListAssignCursors(pParse, pItem->pSelect->pSrc);\n+      if( pItem->fg.isSubquery ){\n+        assert( pItem->u4.pSubq!=0 );\n+        assert( pItem->u4.pSubq->pSelect!=0 );\n+        assert( pItem->u4.pSubq->pSelect->pSrc!=0 );\n+        sqlite3SrcListAssignCursors(pParse, pItem->u4.pSubq->pSelect->pSrc);\n@@ -125665,0 +127044,24 @@\n+\/*\n+** Delete a Subquery object and its substructure.\n+*\/\n+SQLITE_PRIVATE void sqlite3SubqueryDelete(sqlite3 *db, Subquery *pSubq){\n+  assert( pSubq!=0 && pSubq->pSelect!=0 );\n+  sqlite3SelectDelete(db, pSubq->pSelect);\n+  sqlite3DbFree(db, pSubq);\n+}\n+\n+\/*\n+** Remove a Subquery from a SrcItem.  Return the associated Select object.\n+** The returned Select becomes the responsibility of the caller.\n+*\/\n+SQLITE_PRIVATE Select *sqlite3SubqueryDetach(sqlite3 *db, SrcItem *pItem){\n+  Select *pSel;\n+  assert( pItem!=0 );\n+  assert( pItem->fg.isSubquery );\n+  pSel = pItem->u4.pSubq->pSelect;\n+  sqlite3DbFree(db, pItem->u4.pSubq);\n+  pItem->u4.pSubq = 0;\n+  pItem->fg.isSubquery = 0;\n+  return pSel;\n+}\n+\n@@ -125674,1 +127077,8 @@\n-    if( pItem->zDatabase ) sqlite3DbNNFreeNN(db, pItem->zDatabase);\n+\n+    \/* Check invariants on SrcItem *\/\n+    assert( !pItem->fg.isIndexedBy || !pItem->fg.isTabFunc );\n+    assert( !pItem->fg.isCte || !pItem->fg.isIndexedBy );\n+    assert( !pItem->fg.fixedSchema || !pItem->fg.isSubquery );\n+    assert( !pItem->fg.isSubquery || (pItem->u4.pSubq!=0 &&\n+                                      pItem->u4.pSubq->pSelect!=0) );\n+\n@@ -125677,0 +127087,5 @@\n+    if( pItem->fg.isSubquery ){\n+      sqlite3SubqueryDelete(db, pItem->u4.pSubq);\n+    }else if( pItem->fg.fixedSchema==0 && pItem->u4.zDatabase!=0 ){\n+      sqlite3DbNNFreeNN(db, pItem->u4.zDatabase);\n+    }\n@@ -125679,2 +127094,1 @@\n-    sqlite3DeleteTable(db, pItem->pTab);\n-    if( pItem->pSelect ) sqlite3SelectDelete(db, pItem->pSelect);\n+    sqlite3DeleteTable(db, pItem->pSTab);\n@@ -125690,0 +127104,48 @@\n+\/*\n+** Attach a Subquery object to pItem->uv.pSubq.  Set the\n+** pSelect value but leave all the other values initialized\n+** to zero.\n+**\n+** A copy of the Select object is made if dupSelect is true, and the\n+** SrcItem takes responsibility for deleting the copy.  If dupSelect is\n+** false, ownership of the Select passes to the SrcItem.  Either way,\n+** the SrcItem will take responsibility for deleting the Select.\n+**\n+** When dupSelect is zero, that means the Select might get deleted right\n+** away if there is an OOM error.  Beware.\n+**\n+** Return non-zero on success.  Return zero on an OOM error.\n+*\/\n+SQLITE_PRIVATE int sqlite3SrcItemAttachSubquery(\n+  Parse *pParse,     \/* Parsing context *\/\n+  SrcItem *pItem,    \/* Item to which the subquery is to be attached *\/\n+  Select *pSelect,   \/* The subquery SELECT.  Must be non-NULL *\/\n+  int dupSelect      \/* If true, attach a copy of pSelect, not pSelect itself.*\/\n+){\n+  Subquery *p;\n+  assert( pSelect!=0 );\n+  assert( pItem->fg.isSubquery==0 );\n+  if( pItem->fg.fixedSchema ){\n+    pItem->u4.pSchema = 0;\n+    pItem->fg.fixedSchema = 0;\n+  }else if( pItem->u4.zDatabase!=0 ){\n+    sqlite3DbFree(pParse->db, pItem->u4.zDatabase);\n+    pItem->u4.zDatabase = 0;\n+  }\n+  if( dupSelect ){\n+    pSelect = sqlite3SelectDup(pParse->db, pSelect, 0);\n+    if( pSelect==0 ) return 0;\n+  }\n+  p = pItem->u4.pSubq = sqlite3DbMallocRawNN(pParse->db, sizeof(Subquery));\n+  if( p==0 ){\n+    sqlite3SelectDelete(pParse->db, pSelect);\n+    return 0;\n+  }\n+  pItem->fg.isSubquery = 1;\n+  p->pSelect = pSelect;\n+  assert( offsetof(Subquery, pSelect)==0 );\n+  memset(((char*)p)+sizeof(p->pSelect), 0, sizeof(*p)-sizeof(p->pSelect));\n+  return 1;\n+}\n+\n+\n@@ -125739,0 +127201,1 @@\n+  assert( pSubquery==0 || pDatabase==0 );\n@@ -125740,3 +127203,4 @@\n-    pItem->pSelect = pSubquery;\n-    if( pSubquery->selFlags & SF_NestedFrom ){\n-      pItem->fg.isNestedFrom = 1;\n+    if( sqlite3SrcItemAttachSubquery(pParse, pItem, pSubquery, 0) ){\n+      if( pSubquery->selFlags & SF_NestedFrom ){\n+        pItem->fg.isNestedFrom = 1;\n+      }\n@@ -126755,1 +128219,2 @@\n-  assert( p->nArg>=-1 );\n+  assert( p->nArg>=(-4) && p->nArg!=(-2) );\n+  assert( nArg>=(-2) );\n@@ -126759,1 +128224,1 @@\n-    if( nArg==(-2) ) return (p->xSFunc==0) ? 0 : FUNC_PERFECT_MATCH;\n+    if( nArg==(-2) ) return p->xSFunc==0 ? 0 : FUNC_PERFECT_MATCH;\n@@ -126761,0 +128226,5 @@\n+    \/* Special p->nArg values available to built-in functions only:\n+    **    -3     1 or more arguments required\n+    **    -4     2 or more arguments required\n+    *\/\n+    if( p->nArg<(-2) && nArg<(-2-p->nArg) ) return 0;\n@@ -127020,2 +128490,2 @@\n-**    pSrc->a[0].pTab       Pointer to the Table object\n-**    pSrc->a[0].pIndex     Pointer to the INDEXED BY index, if there is one\n+**    pSrc->a[0].spTab        Pointer to the Table object\n+**    pSrc->a[0].u2.pIBIndex  Pointer to the INDEXED BY index, if there is one\n@@ -127029,2 +128499,2 @@\n-  if( pItem->pTab ) sqlite3DeleteTable(pParse->db, pItem->pTab);\n-  pItem->pTab = pTab;\n+  if( pItem->pSTab ) sqlite3DeleteTable(pParse->db, pItem->pSTab);\n+  pItem->pSTab = pTab;\n@@ -127071,0 +128541,1 @@\n+  assert( IsVirtual(pTab) );\n@@ -127152,1 +128623,2 @@\n-    pFrom->a[0].zDatabase = sqlite3DbStrDup(db, db->aDb[iDb].zDbSName);\n+    assert( pFrom->a[0].fg.fixedSchema==0 && pFrom->a[0].fg.isSubquery==0 );\n+    pFrom->a[0].u4.zDatabase = sqlite3DbStrDup(db, db->aDb[iDb].zDbSName);\n@@ -127214,1 +128686,1 @@\n-  pTab = pSrc->a[0].pTab;\n+  pTab = pSrc->a[0].pSTab;\n@@ -127247,1 +128719,1 @@\n-  pSrc->a[0].pTab = 0;\n+  pSrc->a[0].pSTab = 0;\n@@ -127249,1 +128721,1 @@\n-  pSrc->a[0].pTab = pTab;\n+  pSrc->a[0].pSTab = pTab;\n@@ -128381,1 +129853,0 @@\n-  int negP2 = 0;\n@@ -128390,1 +129861,1 @@\n-  p1 = sqlite3_value_int(argv[1]);\n+  p1 = sqlite3_value_int64(argv[1]);\n@@ -128415,5 +129886,1 @@\n-    p2 = sqlite3_value_int(argv[2]);\n-    if( p2<0 ){\n-      p2 = -p2;\n-      negP2 = 1;\n-    }\n+    p2 = sqlite3_value_int64(argv[2]);\n@@ -128426,2 +129893,5 @@\n-      p2 += p1;\n-      if( p2<0 ) p2 = 0;\n+      if( p2<0 ){\n+        p2 = 0;\n+      }else{\n+        p2 += p1;\n+      }\n@@ -128435,5 +129905,5 @@\n-  if( negP2 ){\n-    p1 -= p2;\n-    if( p1<0 ){\n-      p2 += p1;\n-      p1 = 0;\n+  if( p2<0 ){\n+    if( p2<-p1 ){\n+      p2 = p1;\n+    }else{\n+      p2 = -p2;\n@@ -128441,0 +129911,1 @@\n+    p1 -= p2;\n@@ -128454,1 +129925,3 @@\n-    if( p1+p2>len ){\n+    if( p1>=len ){\n+      p1 = p2 = 0;\n+    }else if( p2>len-p1 ){\n@@ -128456,1 +129929,1 @@\n-      if( p2<0 ) p2 = 0;\n+      assert( p2>0 );\n@@ -128467,1 +129940,1 @@\n-  int n = 0;\n+  i64 n = 0;\n@@ -128473,1 +129946,1 @@\n-    n = sqlite3_value_int(argv[1]);\n+    n = sqlite3_value_int64(argv[1]);\n@@ -128488,1 +129961,1 @@\n-    zBuf = sqlite3_mprintf(\"%!.*f\",n,r);\n+    zBuf = sqlite3_mprintf(\"%!.*f\",(int)n,r);\n@@ -129597,1 +131070,1 @@\n-  n += (argc-1)*nSep;\n+  n += (argc-1)*(i64)nSep;\n@@ -129895,1 +131368,4 @@\n-      p->iSum -= sqlite3_value_int64(argv[0]);\n+      if( sqlite3SubInt64(&p->iSum, sqlite3_value_int64(argv[0])) ){\n+        p->ovrfl = 1;\n+        p->approx = 1;\n+      }\n@@ -130076,1 +131552,5 @@\n-** The SEPARATOR goes before the EXPR string.  This is tragic.  The\n+** Content is accumulated in GroupConcatCtx.str with the SEPARATOR\n+** coming before the EXPR value, except for the first entry which\n+** omits the SEPARATOR.\n+**\n+** It is tragic that the SEPARATOR goes before the EXPR string.  The\n@@ -130180,1 +131660,1 @@\n-    int nVS;\n+    int nVS;  \/* Number of characters to remove *\/\n@@ -130233,0 +131713,2 @@\n+    }else if( pGCC->nAccum>0 && pAccum->nChar==0 ){\n+      sqlite3_result_text(context, \"\", 1, SQLITE_STATIC);\n@@ -130556,1 +132038,7 @@\n-** z is the maximum real precision.\n+** z is the maximum real precision.  Return a string that shows the\n+** results of the sqlite3FpDecode() function.\n+**\n+** Used for testing and debugging only, specifically testing and debugging\n+** of the sqlite3FpDecode() function.  This SQL function does not appear\n+** in production builds.  This function is not an API and is subject to\n+** modification or removal in future versions of SQLite.\n@@ -130572,0 +132060,1 @@\n+  if( z<=0 ) z = 1;\n@@ -130582,0 +132071,76 @@\n+#ifdef SQLITE_DEBUG\n+\/*\n+** Implementation of parseuri(uri,flags) function.\n+**\n+** Required Arguments:\n+**    \"uri\"        The URI to parse.\n+**    \"flags\"      Bitmask of flags, as if to sqlite3_open_v2().\n+**\n+** Additional arguments beyond the first two make calls to\n+** sqlite3_uri_key() for integers and sqlite3_uri_parameter for\n+** anything else.\n+**\n+** The result is a string showing the results of calling sqlite3ParseUri().\n+**\n+** Used for testing and debugging only, specifically testing and debugging\n+** of the sqlite3ParseUri() function.  This SQL function does not appear\n+** in production builds.  This function is not an API and is subject to\n+** modification or removal in future versions of SQLite.\n+*\/\n+static void parseuriFunc(\n+  sqlite3_context *ctx,\n+  int argc,\n+  sqlite3_value **argv\n+){\n+  sqlite3_str *pResult;\n+  const char *zVfs;\n+  const char *zUri;\n+  unsigned int flgs;\n+  int rc;\n+  sqlite3_vfs *pVfs = 0;\n+  char *zFile = 0;\n+  char *zErr = 0;\n+\n+  if( argc<2 ) return;\n+  pVfs = sqlite3_vfs_find(0);\n+  assert( pVfs );\n+  zVfs = pVfs->zName;\n+  zUri = (const char*)sqlite3_value_text(argv[0]);\n+  if( zUri==0 ) return;\n+  flgs = (unsigned int)sqlite3_value_int(argv[1]);\n+  rc = sqlite3ParseUri(zVfs, zUri, &flgs, &pVfs, &zFile, &zErr);\n+  pResult = sqlite3_str_new(0);\n+  if( pResult ){\n+    int i;\n+    sqlite3_str_appendf(pResult, \"rc=%d\", rc);\n+    sqlite3_str_appendf(pResult, \", flags=0x%x\", flgs);\n+    sqlite3_str_appendf(pResult, \", vfs=%Q\", pVfs ? pVfs->zName: 0);\n+    sqlite3_str_appendf(pResult, \", err=%Q\", zErr);\n+    sqlite3_str_appendf(pResult, \", file=%Q\", zFile);\n+    if( zFile ){\n+      const char *z = zFile;\n+      z += sqlite3Strlen30(z)+1;\n+      while( z[0] ){\n+        sqlite3_str_appendf(pResult, \", %Q\", z);\n+        z += sqlite3Strlen30(z)+1;\n+      }\n+      for(i=2; i<argc; i++){\n+        const char *zArg;\n+        if( sqlite3_value_type(argv[i])==SQLITE_INTEGER ){\n+          int k = sqlite3_value_int(argv[i]);\n+          sqlite3_str_appendf(pResult, \", '%d:%q'\",k,sqlite3_uri_key(zFile, k));\n+        }else if( (zArg = (const char*)sqlite3_value_text(argv[i]))!=0 ){\n+          sqlite3_str_appendf(pResult, \", '%q:%q'\",\n+                 zArg, sqlite3_uri_parameter(zFile,zArg));\n+        }else{\n+          sqlite3_str_appendf(pResult, \", NULL\");\n+        }\n+      }\n+    }\n+    sqlite3_result_text(ctx, sqlite3_str_finish(pResult), -1, sqlite3_free);\n+  }\n+  sqlite3_free_filename(zFile);\n+  sqlite3_free(zErr);\n+}\n+#endif \/* SQLITE_DEBUG *\/\n+\n@@ -130616,3 +132181,0 @@\n-#if SQLITE_USER_AUTHENTICATION\n-    FUNCTION(sqlite_crypt,       2, 0, 0, sqlite3CryptFunc ),\n-#endif\n@@ -130635,2 +132197,1 @@\n-    FUNCTION(min,               -1, 0, 1, minmaxFunc       ),\n-    FUNCTION(min,                0, 0, 1, 0                ),\n+    FUNCTION(min,               -3, 0, 1, minmaxFunc       ),\n@@ -130639,2 +132200,1 @@\n-    FUNCTION(max,               -1, 1, 1, minmaxFunc       ),\n-    FUNCTION(max,                0, 1, 1, 0                ),\n+    FUNCTION(max,               -3, 1, 1, minmaxFunc       ),\n@@ -130644,1 +132204,2 @@\n-    FUNCTION2(subtype,           1, 0, 0, subtypeFunc, SQLITE_FUNC_TYPEOF),\n+    FUNCTION2(subtype,           1, 0, 0, subtypeFunc,\n+                                           SQLITE_FUNC_TYPEOF|SQLITE_SUBTYPE),\n@@ -130655,0 +132216,1 @@\n+    FUNCTION(parseuri,          -1, 0, 0, parseuriFunc     ),\n@@ -130665,5 +132227,2 @@\n-    FUNCTION(concat,            -1, 0, 0, concatFunc       ),\n-    FUNCTION(concat,             0, 0, 0, 0                ),\n-    FUNCTION(concat_ws,         -1, 0, 0, concatwsFunc     ),\n-    FUNCTION(concat_ws,          0, 0, 0, 0                ),\n-    FUNCTION(concat_ws,          1, 0, 0, 0                ),\n+    FUNCTION(concat,            -3, 0, 0, concatFunc       ),\n+    FUNCTION(concat_ws,         -4, 0, 0, concatwsFunc     ),\n@@ -130713,2 +132272,0 @@\n-    FUNCTION(coalesce,           1, 0, 0, 0                ),\n-    FUNCTION(coalesce,           0, 0, 0, 0                ),\n@@ -130749,1 +132306,1 @@\n-    FUNCTION(pi,                 0, 0, 0,      piFunc      ),\n+    MFUNCTION(pi,                0, 0,         piFunc      ),\n@@ -130752,2 +132309,3 @@\n-    INLINE_FUNC(coalesce,       -1, INLINEFUNC_coalesce, 0 ),\n-    INLINE_FUNC(iif,             3, INLINEFUNC_iif,      0 ),\n+    INLINE_FUNC(coalesce,       -4, INLINEFUNC_coalesce, 0 ),\n+    INLINE_FUNC(iif,            -4, INLINEFUNC_iif,      0 ),\n+    INLINE_FUNC(if,             -4, INLINEFUNC_iif,      0 ),\n@@ -131828,1 +133386,1 @@\n-      pItem->pTab = pFKey->pFrom;\n+      pItem->pSTab = pFKey->pFrom;\n@@ -131830,1 +133388,1 @@\n-      pItem->pTab->nTabRef++;\n+      pItem->pSTab->nTabRef++;\n@@ -132113,1 +133671,2 @@\n-      pRaise = sqlite3Expr(db, TK_RAISE, \"FOREIGN KEY constraint failed\");\n+      pRaise = sqlite3Expr(db, TK_STRING, \"FOREIGN KEY constraint failed\"),\n+      pRaise = sqlite3PExpr(pParse, TK_RAISE, pRaise, 0);\n@@ -132121,1 +133680,2 @@\n-        pSrc->a[0].zDatabase = sqlite3DbStrDup(db, db->aDb[iDb].zDbSName);\n+        assert( pSrc->a[0].fg.fixedSchema==0 && pSrc->a[0].fg.isSubquery==0 );\n+        pSrc->a[0].u4.zDatabase = sqlite3DbStrDup(db, db->aDb[iDb].zDbSName);\n@@ -132847,0 +134407,204 @@\n+\/*\n+** If argument pVal is a Select object returned by an sqlite3MultiValues()\n+** that was able to use the co-routine optimization, finish coding the\n+** co-routine.\n+*\/\n+SQLITE_PRIVATE void sqlite3MultiValuesEnd(Parse *pParse, Select *pVal){\n+  if( ALWAYS(pVal) && pVal->pSrc->nSrc>0 ){\n+    SrcItem *pItem = &pVal->pSrc->a[0];\n+    assert( (pItem->fg.isSubquery && pItem->u4.pSubq!=0) || pParse->nErr );\n+    if( pItem->fg.isSubquery ){\n+      sqlite3VdbeEndCoroutine(pParse->pVdbe, pItem->u4.pSubq->regReturn);\n+      sqlite3VdbeJumpHere(pParse->pVdbe, pItem->u4.pSubq->addrFillSub - 1);\n+    }\n+  }\n+}\n+\n+\/*\n+** Return true if all expressions in the expression-list passed as the\n+** only argument are constant.\n+*\/\n+static int exprListIsConstant(Parse *pParse, ExprList *pRow){\n+  int ii;\n+  for(ii=0; ii<pRow->nExpr; ii++){\n+    if( 0==sqlite3ExprIsConstant(pParse, pRow->a[ii].pExpr) ) return 0;\n+  }\n+  return 1;\n+}\n+\n+\/*\n+** Return true if all expressions in the expression-list passed as the\n+** only argument are both constant and have no affinity.\n+*\/\n+static int exprListIsNoAffinity(Parse *pParse, ExprList *pRow){\n+  int ii;\n+  if( exprListIsConstant(pParse,pRow)==0 ) return 0;\n+  for(ii=0; ii<pRow->nExpr; ii++){\n+    Expr *pExpr = pRow->a[ii].pExpr;\n+    assert( pExpr->op!=TK_RAISE );\n+    assert( pExpr->affExpr==0 );\n+    if( 0!=sqlite3ExprAffinity(pExpr) ) return 0;\n+  }\n+  return 1;\n+\n+}\n+\n+\/*\n+** This function is called by the parser for the second and subsequent\n+** rows of a multi-row VALUES clause. Argument pLeft is the part of\n+** the VALUES clause already parsed, argument pRow is the vector of values\n+** for the new row. The Select object returned represents the complete\n+** VALUES clause, including the new row.\n+**\n+** There are two ways in which this may be achieved - by incremental\n+** coding of a co-routine (the \"co-routine\" method) or by returning a\n+** Select object equivalent to the following (the \"UNION ALL\" method):\n+**\n+**        \"pLeft UNION ALL SELECT pRow\"\n+**\n+** If the VALUES clause contains a lot of rows, this compound Select\n+** object may consume a lot of memory.\n+**\n+** When the co-routine method is used, each row that will be returned\n+** by the VALUES clause is coded into part of a co-routine as it is\n+** passed to this function. The returned Select object is equivalent to:\n+**\n+**     SELECT * FROM (\n+**       Select object to read co-routine\n+**     )\n+**\n+** The co-routine method is used in most cases. Exceptions are:\n+**\n+**    a) If the current statement has a WITH clause. This is to avoid\n+**       statements like:\n+**\n+**            WITH cte AS ( VALUES('x'), ('y') ... )\n+**            SELECT * FROM cte AS a, cte AS b;\n+**\n+**       This will not work, as the co-routine uses a hard-coded register\n+**       for its OP_Yield instructions, and so it is not possible for two\n+**       cursors to iterate through it concurrently.\n+**\n+**    b) The schema is currently being parsed (i.e. the VALUES clause is part\n+**       of a schema item like a VIEW or TRIGGER). In this case there is no VM\n+**       being generated when parsing is taking place, and so generating\n+**       a co-routine is not possible.\n+**\n+**    c) There are non-constant expressions in the VALUES clause (e.g.\n+**       the VALUES clause is part of a correlated sub-query).\n+**\n+**    d) One or more of the values in the first row of the VALUES clause\n+**       has an affinity (i.e. is a CAST expression). This causes problems\n+**       because the complex rules SQLite uses (see function\n+**       sqlite3SubqueryColumnTypes() in select.c) to determine the effective\n+**       affinity of such a column for all rows require access to all values in\n+**       the column simultaneously.\n+*\/\n+SQLITE_PRIVATE Select *sqlite3MultiValues(Parse *pParse, Select *pLeft, ExprList *pRow){\n+\n+  if( pParse->bHasWith                   \/* condition (a) above *\/\n+   || pParse->db->init.busy              \/* condition (b) above *\/\n+   || exprListIsConstant(pParse,pRow)==0 \/* condition (c) above *\/\n+   || (pLeft->pSrc->nSrc==0 &&\n+       exprListIsNoAffinity(pParse,pLeft->pEList)==0) \/* condition (d) above *\/\n+   || IN_SPECIAL_PARSE\n+  ){\n+    \/* The co-routine method cannot be used. Fall back to UNION ALL. *\/\n+    Select *pSelect = 0;\n+    int f = SF_Values | SF_MultiValue;\n+    if( pLeft->pSrc->nSrc ){\n+      sqlite3MultiValuesEnd(pParse, pLeft);\n+      f = SF_Values;\n+    }else if( pLeft->pPrior ){\n+      \/* In this case set the SF_MultiValue flag only if it was set on pLeft *\/\n+      f = (f & pLeft->selFlags);\n+    }\n+    pSelect = sqlite3SelectNew(pParse, pRow, 0, 0, 0, 0, 0, f, 0);\n+    pLeft->selFlags &= ~SF_MultiValue;\n+    if( pSelect ){\n+      pSelect->op = TK_ALL;\n+      pSelect->pPrior = pLeft;\n+      pLeft = pSelect;\n+    }\n+  }else{\n+    SrcItem *p = 0;               \/* SrcItem that reads from co-routine *\/\n+\n+    if( pLeft->pSrc->nSrc==0 ){\n+      \/* Co-routine has not yet been started and the special Select object\n+      ** that accesses the co-routine has not yet been created. This block\n+      ** does both those things. *\/\n+      Vdbe *v = sqlite3GetVdbe(pParse);\n+      Select *pRet = sqlite3SelectNew(pParse, 0, 0, 0, 0, 0, 0, 0, 0);\n+\n+      \/* Ensure the database schema has been read. This is to ensure we have\n+      ** the correct text encoding.  *\/\n+      if( (pParse->db->mDbFlags & DBFLAG_SchemaKnownOk)==0 ){\n+        sqlite3ReadSchema(pParse);\n+      }\n+\n+      if( pRet ){\n+        SelectDest dest;\n+        Subquery *pSubq;\n+        pRet->pSrc->nSrc = 1;\n+        pRet->pPrior = pLeft->pPrior;\n+        pRet->op = pLeft->op;\n+        if( pRet->pPrior ) pRet->selFlags |= SF_Values;\n+        pLeft->pPrior = 0;\n+        pLeft->op = TK_SELECT;\n+        assert( pLeft->pNext==0 );\n+        assert( pRet->pNext==0 );\n+        p = &pRet->pSrc->a[0];\n+        p->fg.viaCoroutine = 1;\n+        p->iCursor = -1;\n+        assert( !p->fg.isIndexedBy && !p->fg.isTabFunc );\n+        p->u1.nRow = 2;\n+        if( sqlite3SrcItemAttachSubquery(pParse, p, pLeft, 0) ){\n+          pSubq = p->u4.pSubq;\n+          pSubq->addrFillSub = sqlite3VdbeCurrentAddr(v) + 1;\n+          pSubq->regReturn = ++pParse->nMem;\n+          sqlite3VdbeAddOp3(v, OP_InitCoroutine,\n+                            pSubq->regReturn, 0, pSubq->addrFillSub);\n+          sqlite3SelectDestInit(&dest, SRT_Coroutine, pSubq->regReturn);\n+\n+          \/* Allocate registers for the output of the co-routine. Do so so\n+          ** that there are two unused registers immediately before those\n+          ** used by the co-routine. This allows the code in sqlite3Insert()\n+          ** to use these registers directly, instead of copying the output\n+          ** of the co-routine to a separate array for processing.  *\/\n+          dest.iSdst = pParse->nMem + 3;\n+          dest.nSdst = pLeft->pEList->nExpr;\n+          pParse->nMem += 2 + dest.nSdst;\n+\n+          pLeft->selFlags |= SF_MultiValue;\n+          sqlite3Select(pParse, pLeft, &dest);\n+          pSubq->regResult = dest.iSdst;\n+          assert( pParse->nErr || dest.iSdst>0 );\n+        }\n+        pLeft = pRet;\n+      }\n+    }else{\n+      p = &pLeft->pSrc->a[0];\n+      assert( !p->fg.isTabFunc && !p->fg.isIndexedBy );\n+      p->u1.nRow++;\n+    }\n+\n+    if( pParse->nErr==0 ){\n+      Subquery *pSubq;\n+      assert( p!=0 );\n+      assert( p->fg.isSubquery );\n+      pSubq = p->u4.pSubq;\n+      assert( pSubq!=0 );\n+      assert( pSubq->pSelect!=0 );\n+      assert( pSubq->pSelect->pEList!=0 );\n+      if( pSubq->pSelect->pEList->nExpr!=pRow->nExpr ){\n+        sqlite3SelectWrongNumTermsError(pParse, pSubq->pSelect);\n+      }else{\n+        sqlite3ExprCodeExprList(pParse, pRow, pSubq->regResult, 0, 0);\n+        sqlite3VdbeAddOp1(pParse->pVdbe, OP_Yield, pSubq->regReturn);\n+      }\n+    }\n+    sqlite3ExprListDelete(pParse->db, pRow);\n+  }\n+\n+  return pLeft;\n+}\n@@ -132993,0 +134757,1 @@\n+  int *aTabColMap = 0;  \/* Mapping from pTab columns to pCol entries *\/\n@@ -133137,5 +134902,2 @@\n-    assert( pColumn->eU4!=EU4_EXPR );\n-    pColumn->eU4 = EU4_IDX;\n-    for(i=0; i<pColumn->nId; i++){\n-      pColumn->a[i].u4.idx = -1;\n-    }\n+    aTabColMap = sqlite3DbMallocZero(db, pTab->nCol*sizeof(int));\n+    if( aTabColMap==0 ) goto insert_cleanup;\n@@ -133143,0 +134905,2 @@\n+      const char *zCName = pColumn->a[i].zName;\n+      u8 hName = sqlite3StrIHash(zCName);\n@@ -133144,2 +134908,3 @@\n-        if( sqlite3StrICmp(pColumn->a[i].zName, pTab->aCol[j].zCnName)==0 ){\n-          pColumn->a[i].u4.idx = j;\n+        if( pTab->aCol[j].hName!=hName ) continue;\n+        if( sqlite3StrICmp(zCName, pTab->aCol[j].zCnName)==0 ){\n+          if( aTabColMap[j]==0 ) aTabColMap[j] = i+1;\n@@ -133183,2 +134948,0 @@\n-    int regYield;       \/* Register holding co-routine entry-point *\/\n-    int addrTop;        \/* Top of the co-routine *\/\n@@ -133187,15 +134950,37 @@\n-    regYield = ++pParse->nMem;\n-    addrTop = sqlite3VdbeCurrentAddr(v) + 1;\n-    sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, addrTop);\n-    sqlite3SelectDestInit(&dest, SRT_Coroutine, regYield);\n-    dest.iSdst = bIdListInOrder ? regData : 0;\n-    dest.nSdst = pTab->nCol;\n-    rc = sqlite3Select(pParse, pSelect, &dest);\n-    regFromSelect = dest.iSdst;\n-    assert( db->pParse==pParse );\n-    if( rc || pParse->nErr ) goto insert_cleanup;\n-    assert( db->mallocFailed==0 );\n-    sqlite3VdbeEndCoroutine(v, regYield);\n-    sqlite3VdbeJumpHere(v, addrTop - 1);                       \/* label B: *\/\n-    assert( pSelect->pEList );\n-    nColumn = pSelect->pEList->nExpr;\n+    if( pSelect->pSrc->nSrc==1\n+     && pSelect->pSrc->a[0].fg.viaCoroutine\n+     && pSelect->pPrior==0\n+    ){\n+      SrcItem *pItem = &pSelect->pSrc->a[0];\n+      Subquery *pSubq;\n+      assert( pItem->fg.isSubquery );\n+      pSubq = pItem->u4.pSubq;\n+      dest.iSDParm = pSubq->regReturn;\n+      regFromSelect = pSubq->regResult;\n+      assert( pSubq->pSelect!=0 );\n+      assert( pSubq->pSelect->pEList!=0 );\n+      nColumn = pSubq->pSelect->pEList->nExpr;\n+      ExplainQueryPlan((pParse, 0, \"SCAN %S\", pItem));\n+      if( bIdListInOrder && nColumn==pTab->nCol ){\n+        regData = regFromSelect;\n+        regRowid = regData - 1;\n+        regIns = regRowid - (IsVirtual(pTab) ? 1 : 0);\n+      }\n+    }else{\n+      int addrTop;        \/* Top of the co-routine *\/\n+      int regYield = ++pParse->nMem;\n+      addrTop = sqlite3VdbeCurrentAddr(v) + 1;\n+      sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, addrTop);\n+      sqlite3SelectDestInit(&dest, SRT_Coroutine, regYield);\n+      dest.iSdst = bIdListInOrder ? regData : 0;\n+      dest.nSdst = pTab->nCol;\n+      rc = sqlite3Select(pParse, pSelect, &dest);\n+      regFromSelect = dest.iSdst;\n+      assert( db->pParse==pParse );\n+      if( rc || pParse->nErr ) goto insert_cleanup;\n+      assert( db->mallocFailed==0 );\n+      sqlite3VdbeEndCoroutine(v, regYield);\n+      sqlite3VdbeJumpHere(v, addrTop - 1);                       \/* label B: *\/\n+      assert( pSelect->pEList );\n+      nColumn = pSelect->pEList->nExpr;\n+    }\n@@ -133447,3 +135232,3 @@\n-      assert( pColumn->eU4==EU4_IDX );\n-      for(j=0; j<pColumn->nId && pColumn->a[j].u4.idx!=i; j++){}\n-      if( j>=pColumn->nId ){\n+      j = aTabColMap[i];\n+      assert( j>=0 && j<=pColumn->nId );\n+      if( j==0 ){\n@@ -133457,1 +135242,1 @@\n-      k = j;\n+      k = j - 1;\n@@ -133702,1 +135487,4 @@\n-  sqlite3IdListDelete(db, pColumn);\n+  if( pColumn ){\n+    sqlite3IdListDelete(db, pColumn);\n+    sqlite3DbFree(db, aTabColMap);\n+  }\n@@ -135097,1 +136885,1 @@\n-  if( pSelect->pSrc->a[0].pSelect ){\n+  if( pSelect->pSrc->a[0].fg.isSubquery ){\n@@ -137926,0 +139714,28 @@\n+\/*\n+** When the 0x10 bit of PRAGMA optimize is set, any ANALYZE commands\n+** will be run with an analysis_limit set to the lessor of the value of\n+** the following macro or to the actual analysis_limit if it is non-zero,\n+** in order to prevent PRAGMA optimize from running for too long.\n+**\n+** The value of 2000 is chosen emperically so that the worst-case run-time\n+** for PRAGMA optimize does not exceed 100 milliseconds against a variety\n+** of test databases on a RaspberryPI-4 compiled using -Os and without\n+** -DSQLITE_DEBUG.  Of course, your mileage may vary.  For the purpose of\n+** this paragraph, \"worst-case\" means that ANALYZE ends up being\n+** run on every table in the database.  The worst case typically only\n+** happens if PRAGMA optimize is run on a database file for which ANALYZE\n+** has not been previously run and the 0x10000 flag is included so that\n+** all tables are analyzed.  The usual case for PRAGMA optimize is that\n+** no ANALYZE commands will be run at all, or if any ANALYZE happens it\n+** will be against a single table, so that expected timing for PRAGMA\n+** optimize on a PI-4 is more like 1 millisecond or less with the 0x10000\n+** flag or less than 100 microseconds without the 0x10000 flag.\n+**\n+** An analysis limit of 2000 is almost always sufficient for the query\n+** planner to fully characterize an index.  The additional accuracy from\n+** a larger analysis is not usually helpful.\n+*\/\n+#ifndef SQLITE_DEFAULT_OPTIMIZE_LIMIT\n+# define SQLITE_DEFAULT_OPTIMIZE_LIMIT 2000\n+#endif\n+\n@@ -139012,6 +140828,0 @@\n-#if SQLITE_USER_AUTHENTICATION\n-      if( db->auth.authLevel==UAUTH_User ){\n-        \/* Do not allow non-admin users to modify the schema arbitrarily *\/\n-        mask &= ~(SQLITE_WriteSchema);\n-      }\n-#endif\n@@ -139153,1 +140963,2 @@\n-              (void)sqlite3_prepare(db, zSql, -1, &pDummy, 0);\n+              (void)sqlite3_prepare_v3(db, zSql, -1, SQLITE_PREPARE_DONT_LOG,\n+                                       &pDummy, 0);\n@@ -139571,1 +141382,1 @@\n-      if( sqlite3GetInt32(zRight, &mxErr) ){\n+      if( sqlite3GetInt32(pValue->z, &mxErr) ){\n@@ -139588,1 +141399,0 @@\n-      int mxIdx = 0;   \/* Maximum number of indexes for any table *\/\n@@ -139610,1 +141420,0 @@\n-        if( nIdx>mxIdx ) mxIdx = nIdx;\n@@ -139630,1 +141439,2 @@\n-      sqlite3TouchRegister(pParse, 8+mxIdx);\n+      sqlite3TouchRegister(pParse, 8+cnt);\n+      sqlite3VdbeAddOp3(v, OP_Null, 0, 8, 8+cnt);\n@@ -139634,2 +141444,2 @@\n-      sqlite3VdbeAddOp4(v, OP_IntegrityCk, 2, cnt, 1, (char*)aRoot,P4_INTARRAY);\n-      sqlite3VdbeChangeP5(v, (u8)i);\n+      sqlite3VdbeAddOp4(v, OP_IntegrityCk, 1, cnt, 8, (char*)aRoot,P4_INTARRAY);\n+      sqlite3VdbeChangeP5(v, (u16)i);\n@@ -139644,0 +141454,30 @@\n+      \/* Check that the indexes all have the right number of rows *\/\n+      cnt = pObjTab ? 1 : 0;\n+      sqlite3VdbeLoadString(v, 2, \"wrong # of entries in index \");\n+      for(x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){\n+        int iTab = 0;\n+        Table *pTab = sqliteHashData(x);\n+        Index *pIdx;\n+        if( pObjTab && pObjTab!=pTab ) continue;\n+        if( HasRowid(pTab) ){\n+          iTab = cnt++;\n+        }else{\n+          iTab = cnt;\n+          for(pIdx=pTab->pIndex; ALWAYS(pIdx); pIdx=pIdx->pNext){\n+            if( IsPrimaryKeyIndex(pIdx) ) break;\n+            iTab++;\n+          }\n+        }\n+        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n+          if( pIdx->pPartIdxWhere==0 ){\n+            addr = sqlite3VdbeAddOp3(v, OP_Eq, 8+cnt, 0, 8+iTab);\n+            VdbeCoverageNeverNull(v);\n+            sqlite3VdbeLoadString(v, 4, pIdx->zName);\n+            sqlite3VdbeAddOp3(v, OP_Concat, 4, 2, 3);\n+            integrityCheckResultRow(v);\n+            sqlite3VdbeJumpHere(v, addr);\n+          }\n+          cnt++;\n+        }\n+      }\n+\n@@ -139967,15 +141807,3 @@\n-        if( !isQuick ){\n-          sqlite3VdbeLoadString(v, 2, \"wrong # of entries in index \");\n-          for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){\n-            if( pPk==pIdx ) continue;\n-            sqlite3VdbeAddOp2(v, OP_Count, iIdxCur+j, 3);\n-            addr = sqlite3VdbeAddOp3(v, OP_Eq, 8+j, 0, 3); VdbeCoverage(v);\n-            sqlite3VdbeChangeP5(v, SQLITE_NOTNULL);\n-            sqlite3VdbeLoadString(v, 4, pIdx->zName);\n-            sqlite3VdbeAddOp3(v, OP_Concat, 4, 2, 3);\n-            integrityCheckResultRow(v);\n-            sqlite3VdbeJumpHere(v, addr);\n-          }\n-          if( pPk ){\n-            sqlite3ReleaseTempRange(pParse, r2, pPk->nKeyCol);\n-          }\n+        if( pPk ){\n+          assert( !isQuick );\n+          sqlite3ReleaseTempRange(pParse, r2, pPk->nKeyCol);\n@@ -140279,3 +142107,3 @@\n-  **    0x0001    Debugging mode.  Do not actually perform any optimizations\n-  **              but instead return one line of text for each optimization\n-  **              that would have been done.  Off by default.\n+  **    0x00001    Debugging mode.  Do not actually perform any optimizations\n+  **               but instead return one line of text for each optimization\n+  **               that would have been done.  Off by default.\n@@ -140283,2 +142111,2 @@\n-  **    0x0002    Run ANALYZE on tables that might benefit.  On by default.\n-  **              See below for additional information.\n+  **    0x00002    Run ANALYZE on tables that might benefit.  On by default.\n+  **               See below for additional information.\n@@ -140286,4 +142114,8 @@\n-  **    0x0004    (Not yet implemented) Record usage and performance\n-  **              information from the current session in the\n-  **              database file so that it will be available to \"optimize\"\n-  **              pragmas run by future database connections.\n+  **    0x00010    Run all ANALYZE operations using an analysis_limit that\n+  **               is the lessor of the current analysis_limit and the\n+  **               SQLITE_DEFAULT_OPTIMIZE_LIMIT compile-time option.\n+  **               The default value of SQLITE_DEFAULT_OPTIMIZE_LIMIT is\n+  **               currently (2024-02-19) set to 2000, which is such that\n+  **               the worst case run-time for PRAGMA optimize on a 100MB\n+  **               database will usually be less than 100 milliseconds on\n+  **               a RaspberryPI-4 class machine.  On by default.\n@@ -140291,2 +142123,3 @@\n-  **    0x0008    (Not yet implemented) Create indexes that might have\n-  **              been helpful to recent queries\n+  **    0x10000    Look at tables to see if they need to be reanalyzed\n+  **               due to growth or shrinkage even if they have not been\n+  **               queried during the current connection.  Off by default.\n@@ -140294,5 +142127,5 @@\n-  ** The default MASK is and always shall be 0xfffe.  0xfffe means perform all\n-  ** of the optimizations listed above except Debug Mode, including new\n-  ** optimizations that have not yet been invented.  If new optimizations are\n-  ** ever added that should be off by default, those off-by-default\n-  ** optimizations will have bitmasks of 0x10000 or larger.\n+  ** The default MASK is and always shall be 0x0fffe.  In the current\n+  ** implementation, the default mask only covers the 0x00002 optimization,\n+  ** though additional optimizations that are covered by 0x0fffe might be\n+  ** added in the future.  Optimizations that are off by default and must\n+  ** be explicitly requested have masks of 0x10000 or greater.\n@@ -140305,1 +142138,5 @@\n-  ** (1) MASK bit 0x02 is set.\n+  ** (1) MASK bit 0x00002 is set.\n+  **\n+  ** (2) The table is an ordinary table, not a virtual table or view.\n+  **\n+  ** (3) The table name does not begin with \"sqlite_\".\n@@ -140307,3 +142144,7 @@\n-  ** (2) The query planner used sqlite_stat1-style statistics for one or\n-  **     more indexes of the table at some point during the lifetime of\n-  **     the current connection.\n+  ** (4) One or more of the following is true:\n+  **      (4a) The 0x10000 MASK bit is set.\n+  **      (4b) One or more indexes on the table lacks an entry\n+  **           in the sqlite_stat1 table.\n+  **      (4c) The query planner used sqlite_stat1-style statistics for one\n+  **           or more indexes of the table at some point during the lifetime\n+  **           of the current connection.\n@@ -140311,3 +142152,7 @@\n-  ** (3) One or more indexes of the table are currently unanalyzed OR\n-  **     the number of rows in the table has increased by 25 times or more\n-  **     since the last time ANALYZE was run.\n+  ** (5) One or more of the following is true:\n+  **      (5a) One or more indexes on the table lacks an entry\n+  **           in the sqlite_stat1 table.  (Same as 4a)\n+  **      (5b) The number of rows in the table has increased or decreased by\n+  **           10-fold.  In other words, the current size of the table is\n+  **           10 times larger than the size in sqlite_stat1 or else the\n+  **           current size is less than 1\/10th the size in sqlite_stat1.\n@@ -140316,1 +142161,3 @@\n-  ** future releases.\n+  ** future releases.  Future versions of SQLite might accept a string\n+  ** literal argument to this pragma that contains a mnemonic description\n+  ** of the options rather than a bitmap.\n@@ -140328,0 +142175,4 @@\n+    int nLimit;            \/* Analysis limit to use *\/\n+    int nCheck = 0;        \/* Number of tables to be optimized *\/\n+    int nBtree = 0;        \/* Number of btrees to scan *\/\n+    int nIndex;            \/* Number of indexes on the current table *\/\n@@ -140335,0 +142186,8 @@\n+    if( (opMask & 0x10)==0 ){\n+      nLimit = 0;\n+    }else if( db->nAnalysisLimit>0\n+           && db->nAnalysisLimit<SQLITE_DEFAULT_OPTIMIZE_LIMIT ){\n+      nLimit = 0;\n+    }else{\n+      nLimit = SQLITE_DEFAULT_OPTIMIZE_LIMIT;\n+    }\n@@ -140343,4 +142202,2 @@\n-        \/* If table pTab has not been used in a way that would benefit from\n-        ** having analysis statistics during the current session, then skip it.\n-        ** This also has the effect of skipping virtual tables and views *\/\n-        if( (pTab->tabFlags & TF_StatsUsed)==0 ) continue;\n+        \/* This only works for ordinary tables *\/\n+        if( !IsOrdinaryTable(pTab) ) continue;\n@@ -140348,2 +142205,9 @@\n-        \/* Reanalyze if the table is 25 times larger than the last analysis *\/\n-        szThreshold = pTab->nRowLogEst + 46; assert( sqlite3LogEst(25)==46 );\n+        \/* Do not scan system tables *\/\n+        if( 0==sqlite3StrNICmp(pTab->zName, \"sqlite_\", 7) ) continue;\n+\n+        \/* Find the size of the table as last recorded in sqlite_stat1.\n+        ** If any index is unanalyzed, then the threshold is -1 to\n+        ** indicate a new, unanalyzed index\n+        *\/\n+        szThreshold = pTab->nRowLogEst;\n+        nIndex = 0;\n@@ -140351,0 +142215,1 @@\n+          nIndex++;\n@@ -140352,2 +142217,1 @@\n-            szThreshold = 0; \/* Always analyze if any index lacks statistics *\/\n-            break;\n+            szThreshold = -1; \/* Always analyze if any index lacks statistics *\/\n@@ -140356,4 +142220,37 @@\n-        if( szThreshold ){\n-          sqlite3OpenTable(pParse, iTabCur, iDb, pTab, OP_OpenRead);\n-          sqlite3VdbeAddOp3(v, OP_IfSmaller, iTabCur,\n-                         sqlite3VdbeCurrentAddr(v)+2+(opMask&1), szThreshold);\n+\n+        \/* If table pTab has not been used in a way that would benefit from\n+        ** having analysis statistics during the current session, then skip it,\n+        ** unless the 0x10000 MASK bit is set. *\/\n+        if( (pTab->tabFlags & TF_MaybeReanalyze)!=0 ){\n+          \/* Check for size change if stat1 has been used for a query *\/\n+        }else if( opMask & 0x10000 ){\n+          \/* Check for size change if 0x10000 is set *\/\n+        }else if( pTab->pIndex!=0 && szThreshold<0 ){\n+          \/* Do analysis if unanalyzed indexes exists *\/\n+        }else{\n+          \/* Otherwise, we can skip this table *\/\n+          continue;\n+        }\n+\n+        nCheck++;\n+        if( nCheck==2 ){\n+          \/* If ANALYZE might be invoked two or more times, hold a write\n+          ** transaction for efficiency *\/\n+          sqlite3BeginWriteOperation(pParse, 0, iDb);\n+        }\n+        nBtree += nIndex+1;\n+\n+        \/* Reanalyze if the table is 10 times larger or smaller than\n+        ** the last analysis.  Unconditional reanalysis if there are\n+        ** unanalyzed indexes. *\/\n+        sqlite3OpenTable(pParse, iTabCur, iDb, pTab, OP_OpenRead);\n+        if( szThreshold>=0 ){\n+          const LogEst iRange = 33;   \/* 10x size change *\/\n+          sqlite3VdbeAddOp4Int(v, OP_IfSizeBetween, iTabCur,\n+                         sqlite3VdbeCurrentAddr(v)+2+(opMask&1),\n+                         szThreshold>=iRange ? szThreshold-iRange : -1,\n+                         szThreshold+iRange);\n+          VdbeCoverage(v);\n+        }else{\n+          sqlite3VdbeAddOp2(v, OP_Rewind, iTabCur,\n+                         sqlite3VdbeCurrentAddr(v)+2+(opMask&1));\n@@ -140369,1 +142266,2 @@\n-          sqlite3VdbeAddOp4(v, OP_SqlExec, 0, 0, 0, zSubSql, P4_DYNAMIC);\n+          sqlite3VdbeAddOp4(v, OP_SqlExec, nLimit ? 0x02 : 00, nLimit, 0,\n+                            zSubSql, P4_DYNAMIC);\n@@ -140374,0 +142272,15 @@\n+\n+    \/* In a schema with a large number of tables and indexes, scale back\n+    ** the analysis_limit to avoid excess run-time in the worst case.\n+    *\/\n+    if( !db->mallocFailed && nLimit>0 && nBtree>100 ){\n+      int iAddr, iEnd;\n+      VdbeOp *aOp;\n+      nLimit = 100*nLimit\/nBtree;\n+      if( nLimit<100 ) nLimit = 100;\n+      aOp = sqlite3VdbeGetOp(v, 0);\n+      iEnd = sqlite3VdbeCurrentAddr(v);\n+      for(iAddr=0; iAddr<iEnd; iAddr++){\n+        if( aOp[iAddr].opcode==OP_SqlExec ) aOp[iAddr].p2 = nLimit;\n+      }\n+    }\n@@ -140637,2 +142550,0 @@\n-    if( pConstraint->usable==0 ) continue;\n-    if( pConstraint->op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;\n@@ -140640,0 +142551,2 @@\n+    if( pConstraint->op!=SQLITE_INDEX_CONSTRAINT_EQ ) continue;\n+    if( pConstraint->usable==0 ) return SQLITE_CONSTRAINT;\n@@ -140652,5 +142565,0 @@\n-  if( seen[1]==0 ){\n-    pIdxInfo->estimatedCost = (double)1000;\n-    pIdxInfo->estimatedRows = 1000;\n-    return SQLITE_OK;\n-  }\n@@ -140659,3 +142567,5 @@\n-  j = seen[1]-1;\n-  pIdxInfo->aConstraintUsage[j].argvIndex = 2;\n-  pIdxInfo->aConstraintUsage[j].omit = 1;\n+  if( seen[1] ){\n+    j = seen[1]-1;\n+    pIdxInfo->aConstraintUsage[j].argvIndex = 2;\n+    pIdxInfo->aConstraintUsage[j].omit = 1;\n+  }\n@@ -140681,0 +142591,1 @@\n+  pCsr->iRowid = 0;\n@@ -141154,8 +143065,1 @@\n-      if( db->nVdbeActive>0 && encoding!=ENC(db)\n-       && (db->mDbFlags & DBFLAG_Vacuum)==0\n-      ){\n-        rc = SQLITE_LOCKED;\n-        goto initone_error_out;\n-      }else{\n-        sqlite3SetTextEncoding(db, encoding);\n-      }\n+      sqlite3SetTextEncoding(db, encoding);\n@@ -141481,1 +143385,7 @@\n-  ParseCleanup *pCleanup = sqlite3DbMallocRaw(pParse->db, sizeof(*pCleanup));\n+  ParseCleanup *pCleanup;\n+  if( sqlite3FaultSim(300) ){\n+    pCleanup = 0;\n+    sqlite3OomFault(pParse->db);\n+  }else{\n+    pCleanup = sqlite3DbMallocRaw(pParse->db, sizeof(*pCleanup));\n+  }\n@@ -141849,0 +143759,6 @@\n+\n+  \/* Make sure nBytes is non-negative and correct.  It should be the\n+  ** number of bytes until the end of the input buffer or until the first\n+  ** U+0000 character.  If the input nBytes is odd, convert it into\n+  ** an even number.  If the input nBytes is negative, then the input\n+  ** must be terminated by at least one U+0000 character *\/\n@@ -141854,0 +143770,5 @@\n+  }else{\n+    int sz;\n+    const char *z = (const char*)zSql;\n+    for(sz=0; z[sz]!=0 || z[sz+1]!=0; sz += 2){}\n+    nBytes = sz;\n@@ -141855,0 +143776,1 @@\n+\n@@ -141868,1 +143790,1 @@\n-    *pzTail = (u8 *)zSql + sqlite3Utf16ByteLen(zSql, chars_parsed);\n+    *pzTail = (u8 *)zSql + sqlite3Utf16ByteLen(zSql, nBytes, chars_parsed);\n@@ -142262,1 +144184,1 @@\n-  assert( (int)pItem->fg.isNestedFrom == IsNestedFrom(pItem->pSelect) );\n+  assert( (int)pItem->fg.isNestedFrom == IsNestedFrom(pItem) );\n@@ -142265,2 +144187,4 @@\n-    assert( pItem->pSelect!=0 );\n-    pResults = pItem->pSelect->pEList;\n+    assert( pItem->fg.isSubquery );\n+    assert( pItem->u4.pSubq!=0 );\n+    assert( pItem->u4.pSubq->pSelect!=0 );\n+    pResults = pItem->u4.pSubq->pSelect->pEList;\n@@ -142300,1 +144224,1 @@\n-    iCol = sqlite3ColumnIndex(pSrc->a[i].pTab, zCol);\n+    iCol = sqlite3ColumnIndex(pSrc->a[i].pSTab, zCol);\n@@ -142302,1 +144226,1 @@\n-     && (bIgnoreHidden==0 || IsHiddenColumn(&pSrc->a[i].pTab->aCol[iCol])==0)\n+     && (bIgnoreHidden==0 || IsHiddenColumn(&pSrc->a[i].pSTab->aCol[iCol])==0)\n@@ -142431,1 +144355,1 @@\n-    Table *pRightTab = pRight->pTab;\n+    Table *pRightTab = pRight->pSTab;\n@@ -142434,1 +144358,1 @@\n-    if( NEVER(pLeft->pTab==0 || pRightTab==0) ) continue;\n+    if( NEVER(pLeft->pSTab==0 || pRightTab==0) ) continue;\n@@ -143307,0 +145231,1 @@\n+        pDest->iSDParm2 = 0; \/* Signal that any Bloom filter is unpopulated *\/\n@@ -143313,0 +145238,5 @@\n+        if( pDest->iSDParm2 ){\n+          sqlite3VdbeAddOp4Int(v, OP_FilterAdd, pDest->iSDParm2, 0,\n+                               regResult, nResultCol);\n+          ExplainQueryPlan((pParse, 0, \"CREATE BLOOM FILTER\"));\n+        }\n@@ -143603,3 +145533,10 @@\n-  ExplainQueryPlan2(addrExplain, (pParse, 0,\n-        \"USE TEMP B-TREE FOR %sORDER BY\", pSort->nOBSat>0?\"RIGHT PART OF \":\"\")\n-  );\n+  nKey = pOrderBy->nExpr - pSort->nOBSat;\n+  if( pSort->nOBSat==0 || nKey==1 ){\n+    ExplainQueryPlan2(addrExplain, (pParse, 0,\n+      \"USE TEMP B-TREE FOR %sORDER BY\", pSort->nOBSat?\"LAST TERM OF \":\"\"\n+    ));\n+  }else{\n+    ExplainQueryPlan2(addrExplain, (pParse, 0,\n+      \"USE TEMP B-TREE FOR LAST %d TERMS OF ORDER BY\", nKey\n+    ));\n+  }\n@@ -143643,1 +145580,0 @@\n-  nKey = pOrderBy->nExpr - pSort->nOBSat;\n@@ -143848,2 +145784,6 @@\n-          pTab = pTabList->a[j].pTab;\n-          pS = pTabList->a[j].pSelect;\n+          pTab = pTabList->a[j].pSTab;\n+          if( pTabList->a[j].fg.isSubquery ){\n+            pS = pTabList->a[j].u4.pSubq->pSelect;\n+          }else{\n+            pS = 0;\n+          }\n@@ -144248,2 +146188,1 @@\n-  testcase( (pSelect->selFlags & SF_Resolved)==0 );\n-  assert( (pSelect->selFlags & SF_Resolved)!=0 || IN_RENAME_OBJECT );\n+  assert( (pSelect->selFlags & SF_Resolved)!=0 );\n@@ -144260,0 +146199,2 @@\n+    int m = 0;\n+    Select *pS2 = pSelect;\n@@ -144264,0 +146205,5 @@\n+    while( pCol->affinity<=SQLITE_AFF_NONE && pS2->pNext!=0 ){\n+      m |= sqlite3ExprDataType(pS2->pEList->a[i].pExpr);\n+      pS2 = pS2->pNext;\n+      pCol->affinity = sqlite3ExprAffinity(pS2->pEList->a[i].pExpr);\n+    }\n@@ -144267,4 +146213,2 @@\n-    if( pCol->affinity>=SQLITE_AFF_TEXT && pSelect->pNext ){\n-      int m = 0;\n-      Select *pS2;\n-      for(m=0, pS2=pSelect->pNext; pS2; pS2=pS2->pNext){\n+    if( pCol->affinity>=SQLITE_AFF_TEXT && (pS2->pNext || pS2!=pSelect) ){\n+      for(pS2=pS2->pNext; pS2; pS2=pS2->pNext){\n@@ -144300,1 +146244,1 @@\n-      i64 m = sqlite3Strlen30(zType);\n+      const i64 k = sqlite3Strlen30(zType);\n@@ -144302,1 +146246,1 @@\n-      pCol->zCnName = sqlite3DbReallocOrFree(db, pCol->zCnName, n+m+2);\n+      pCol->zCnName = sqlite3DbReallocOrFree(db, pCol->zCnName, n+k+2);\n@@ -144305,1 +146249,1 @@\n-        memcpy(&pCol->zCnName[n+1], zType, m+1);\n+        memcpy(&pCol->zCnName[n+1], zType, k+1);\n@@ -144412,1 +146356,1 @@\n-    if( sqlite3ExprIsInteger(pLimit->pLeft, &n) ){\n+    if( sqlite3ExprIsInteger(pLimit->pLeft, &n, pParse) ){\n@@ -144892,1 +146836,1 @@\n-         && sqlite3ExprIsInteger(p->pLimit->pLeft, &nLimit)\n+         && sqlite3ExprIsInteger(p->pLimit->pLeft, &nLimit, pParse)\n@@ -145236,0 +147180,5 @@\n+      if( pDest->iSDParm2>0 ){\n+        sqlite3VdbeAddOp4Int(v, OP_FilterAdd, pDest->iSDParm2, 0,\n+                             pIn->iSdst, pIn->nSdst);\n+        ExplainQueryPlan((pParse, 0, \"CREATE BLOOM FILTER\"));\n+      }\n@@ -145814,10 +147763,4 @@\n-        if( ExprHasProperty(pExpr,EP_OuterON|EP_InnerON) ){\n-          sqlite3SetJoinExpr(pNew, pExpr->w.iJoin,\n-                             pExpr->flags & (EP_OuterON|EP_InnerON));\n-        }\n-        sqlite3ExprDelete(db, pExpr);\n-        pExpr = pNew;\n-        if( pExpr->op==TK_TRUEFALSE ){\n-          pExpr->u.iValue = sqlite3ExprTruthValue(pExpr);\n-          pExpr->op = TK_INTEGER;\n-          ExprSetProperty(pExpr, EP_IntValue);\n+        if( pNew->op==TK_TRUEFALSE ){\n+          pNew->u.iValue = sqlite3ExprTruthValue(pNew);\n+          pNew->op = TK_INTEGER;\n+          ExprSetProperty(pNew, EP_IntValue);\n@@ -145829,1 +147772,1 @@\n-          CollSeq *pNat = sqlite3ExprCollSeq(pSubst->pParse, pExpr);\n+          CollSeq *pNat = sqlite3ExprCollSeq(pSubst->pParse, pNew);\n@@ -145833,2 +147776,2 @@\n-          if( pNat!=pColl || (pExpr->op!=TK_COLUMN && pExpr->op!=TK_COLLATE) ){\n-            pExpr = sqlite3ExprAddCollateString(pSubst->pParse, pExpr,\n+          if( pNat!=pColl || (pNew->op!=TK_COLUMN && pNew->op!=TK_COLLATE) ){\n+            pNew = sqlite3ExprAddCollateString(pSubst->pParse, pNew,\n@@ -145839,1 +147782,7 @@\n-        ExprClearProperty(pExpr, EP_Collate);\n+        ExprClearProperty(pNew, EP_Collate);\n+        if( ExprHasProperty(pExpr,EP_OuterON|EP_InnerON) ){\n+          sqlite3SetJoinExpr(pNew, pExpr->w.iJoin,\n+                             pExpr->flags & (EP_OuterON|EP_InnerON));\n+        }\n+        sqlite3ExprDelete(db, pExpr);\n+        pExpr = pNew;\n@@ -145892,1 +147841,3 @@\n-      substSelect(pSubst, pItem->pSelect, 1);\n+      if( pItem->fg.isSubquery ){\n+        substSelect(pSubst, pItem->u4.pSubq->pSelect, 1);\n+      }\n@@ -145923,1 +147874,1 @@\n-  if( NEVER(pSrcItem->pTab==0) ) return;\n+  if( NEVER(pSrcItem->pSTab==0) ) return;\n@@ -145963,2 +147914,4 @@\n-      for(p=pItem->pSelect; p; p=p->pPrior){\n-        srclistRenumberCursors(pParse, aCsrMap, p->pSrc, -1);\n+      if( pItem->fg.isSubquery ){\n+        for(p=pItem->u4.pSubq->pSelect; p; p=p->pPrior){\n+          srclistRenumberCursors(pParse, aCsrMap, p->pSrc, -1);\n+        }\n@@ -146275,1 +148228,2 @@\n-  pSub = pSubitem->pSelect;\n+  assert( pSubitem->fg.isSubquery );\n+  pSub = pSubitem->u4.pSubq->pSelect;\n@@ -146328,1 +148282,1 @@\n-     || IsVirtual(pSubSrc->a[0].pTab)          \/* (3b) *\/\n+     || IsVirtual(pSubSrc->a[0].pSTab)         \/* (3b) *\/\n@@ -146414,2 +148368,8 @@\n-  pSub1 = pSubitem->pSelect;\n-  sqlite3DbFree(db, pSubitem->zDatabase);\n+\n+  if( ALWAYS(pSubitem->fg.isSubquery) ){\n+    pSub1 = sqlite3SubqueryDetach(db, pSubitem);\n+  }else{\n+    pSub1 = 0;\n+  }\n+  assert( pSubitem->fg.isSubquery==0 );\n+  assert( pSubitem->fg.fixedSchema==0 );\n@@ -146418,1 +148378,0 @@\n-  pSubitem->zDatabase = 0;\n@@ -146421,1 +148380,0 @@\n-  pSubitem->pSelect = 0;\n@@ -146462,2 +148420,2 @@\n-    Table *pItemTab = pSubitem->pTab;\n-    pSubitem->pTab = 0;\n+    Table *pItemTab = pSubitem->pSTab;\n+    pSubitem->pSTab = 0;\n@@ -146471,1 +148429,1 @@\n-    pSubitem->pTab = pItemTab;\n+    pSubitem->pSTab = pItemTab;\n@@ -146486,1 +148444,1 @@\n-    assert( pSubitem->pSelect==0 );\n+    assert( pSubitem->fg.isSubquery==0 );\n@@ -146490,1 +148448,4 @@\n-    pSubitem->pSelect = pSub1;\n+    assert( pSubitem->fg.fixedSchema==0 );\n+    assert( pSubitem->fg.isSubquery==0 );\n+    assert( pSubitem->u4.zDatabase==0 );\n+    sqlite3SrcItemAttachSubquery(pParse, pSubitem, pSub1, 0);\n@@ -146501,2 +148462,2 @@\n-  if( ALWAYS(pSubitem->pTab!=0) ){\n-    Table *pTabToDel = pSubitem->pTab;\n+  if( ALWAYS(pSubitem->pSTab!=0) ){\n+    Table *pTabToDel = pSubitem->pSTab;\n@@ -146510,1 +148471,1 @@\n-    pSubitem->pTab = 0;\n+    pSubitem->pSTab = 0;\n@@ -146564,0 +148525,1 @@\n+    iNewParent = pSubSrc->a[0].iCursor;\n@@ -146566,1 +148528,0 @@\n-      if( pItem->fg.isUsing ) sqlite3IdListDelete(db, pItem->u3.pUsing);\n@@ -146568,0 +148529,4 @@\n+      assert( pItem->fg.isSubquery\n+           || pItem->fg.fixedSchema\n+           || pItem->u4.zDatabase==0 );\n+      if( pItem->fg.isUsing ) sqlite3IdListDelete(db, pItem->u3.pUsing);\n@@ -146570,1 +148535,0 @@\n-      iNewParent = pSubSrc->a[i].iCursor;\n@@ -146610,0 +148574,1 @@\n+      assert( pSubSrc->nSrc==1 );\n@@ -146702,1 +148667,1 @@\n-  assert( sqlite3ExprIsConstant(pValue) );\n+  assert( sqlite3ExprIsConstant(pConst->pParse, pValue) );\n@@ -146760,1 +148725,1 @@\n-  if( pRight->op==TK_COLUMN && sqlite3ExprIsConstant(pLeft) ){\n+  if( pRight->op==TK_COLUMN && sqlite3ExprIsConstant(pConst->pParse, pLeft) ){\n@@ -146763,1 +148728,1 @@\n-  if( pLeft->op==TK_COLUMN && sqlite3ExprIsConstant(pRight) ){\n+  if( pLeft->op==TK_COLUMN && sqlite3ExprIsConstant(pConst->pParse, pRight) ){\n@@ -146984,0 +148949,13 @@\n+** NAME AMBIGUITY\n+**\n+** This optimization is called the \"WHERE-clause push-down optimization\"\n+** or sometimes the \"predicate push-down optimization\".\n+**\n+** Do not confuse this optimization with another unrelated optimization\n+** with a similar name:  The \"MySQL push-down optimization\" causes WHERE\n+** clause terms that can be evaluated using only the index and without\n+** reference to the table are run first, so that if they are false,\n+** unnecessary table seeks are avoided.\n+**\n+** RULES\n+**\n@@ -147049,4 +149027,4 @@\n-**       Without this restriction, the push-down optimization might move\n-**       the ON\/USING filter expression from the left side of a RIGHT JOIN\n-**       over to the right side, which leads to incorrect answers.  See\n-**       also restriction (6) in sqlite3ExprIsSingleTableConstraint().\n+**       Without this restriction, the WHERE-clause push-down optimization\n+**       might move the ON\/USING filter expression from the left side of a\n+**       RIGHT JOIN over to the right side, which leads to incorrect answers.\n+**       See also restriction (6) in sqlite3ExprIsSingleTableConstraint().\n@@ -147184,1 +149162,1 @@\n-  if( sqlite3ExprIsSingleTableConstraint(pWhere, pSrcList, iSrc) ){\n+  if( sqlite3ExprIsSingleTableConstraint(pWhere, pSrcList, iSrc, 1) ){\n@@ -147238,4 +149216,4 @@\n-  assert( pItem->pTab!=0 );\n-  pTab = pItem->pTab;\n-  assert( pItem->pSelect!=0 );\n-  pSub = pItem->pSelect;\n+  assert( pItem->pSTab!=0 );\n+  pTab = pItem->pSTab;\n+  assert( pItem->fg.isSubquery );\n+  pSub = pItem->u4.pSubq->pSelect;\n@@ -147370,1 +149348,1 @@\n-   || p->pSrc->a[0].pSelect\n+   || p->pSrc->a[0].fg.isSubquery\n@@ -147376,1 +149354,1 @@\n-  pTab = p->pSrc->a[0].pTab;\n+  pTab = p->pSrc->a[0].pSTab;\n@@ -147401,1 +149379,1 @@\n-  Table *pTab = pFrom->pTab;\n+  Table *pTab = pFrom->pSTab;\n@@ -147478,1 +149456,5 @@\n-  if( pNewSrc==0 ) return WRC_Abort;\n+  assert( pNewSrc!=0 || pParse->nErr );\n+  if( pParse->nErr ){\n+    sqlite3SrcListDelete(db, pNewSrc);\n+    return WRC_Abort;\n+  }\n@@ -147533,1 +149515,1 @@\n-  assert( pItem->zDatabase==0 );\n+  assert( pItem->fg.fixedSchema || pItem->u4.zDatabase==0 );\n@@ -147603,1 +149585,1 @@\n-  assert( pFrom->pTab==0 );\n+  assert( pFrom->pSTab==0 );\n@@ -147613,1 +149595,2 @@\n-  if( pFrom->zDatabase!=0 ){\n+  assert( pFrom->fg.hadSchema==0 || pFrom->fg.notCte!=0 );\n+  if( pFrom->fg.fixedSchema==0 && pFrom->u4.zDatabase!=0 ){\n@@ -147649,1 +149632,1 @@\n-    assert( pFrom->pTab==0 );\n+    assert( pFrom->pSTab==0 );\n@@ -147663,1 +149646,1 @@\n-    pFrom->pTab = pTab;\n+    pFrom->pSTab = pTab;\n@@ -147669,1 +149652,1 @@\n-    pFrom->pSelect = sqlite3SelectDup(db, pCte->pSelect, 0);\n+    sqlite3SrcItemAttachSubquery(pParse, pFrom, pCte->pSelect, 1);\n@@ -147671,2 +149654,4 @@\n-    pFrom->pSelect->selFlags |= SF_CopyCte;\n-    assert( pFrom->pSelect );\n+    assert( pFrom->fg.isSubquery && pFrom->u4.pSubq );\n+    pSel = pFrom->u4.pSubq->pSelect;\n+    assert( pSel!=0 );\n+    pSel->selFlags |= SF_CopyCte;\n@@ -147677,0 +149662,1 @@\n+    assert( !pFrom->fg.isIndexedBy );\n@@ -147682,1 +149668,1 @@\n-    pRecTerm = pSel = pFrom->pSelect;\n+    pRecTerm = pSel;\n@@ -147690,2 +149676,4 @@\n-        if( pItem->zDatabase==0\n-         && pItem->zName!=0\n+        if( pItem->zName!=0\n+         && !pItem->fg.hadSchema\n+         && ALWAYS( !pItem->fg.isSubquery )\n+         && (pItem->fg.fixedSchema || pItem->u4.zDatabase==0)\n@@ -147694,1 +149682,1 @@\n-          pItem->pTab = pTab;\n+          pItem->pSTab = pTab;\n@@ -147796,1 +149784,1 @@\n-  Select *pSel = pFrom->pSelect;\n+  Select *pSel;\n@@ -147799,0 +149787,3 @@\n+  assert( pFrom->fg.isSubquery );\n+  assert( pFrom->u4.pSubq!=0 );\n+  pSel = pFrom->u4.pSubq->pSelect;\n@@ -147800,1 +149791,1 @@\n-  pFrom->pTab = pTab = sqlite3DbMallocZero(pParse->db, sizeof(Table));\n+  pFrom->pSTab = pTab = sqlite3DbMallocZero(pParse->db, sizeof(Table));\n@@ -147920,2 +149911,2 @@\n-    assert( pFrom->fg.isRecursive==0 || pFrom->pTab!=0 );\n-    if( pFrom->pTab ) continue;\n+    assert( pFrom->fg.isRecursive==0 || pFrom->pSTab!=0 );\n+    if( pFrom->pSTab ) continue;\n@@ -147925,1 +149916,3 @@\n-      Select *pSel = pFrom->pSelect;\n+      Select *pSel;\n+      assert( pFrom->fg.isSubquery && pFrom->u4.pSubq!=0 );\n+      pSel = pFrom->u4.pSubq->pSelect;\n@@ -147928,1 +149921,1 @@\n-      assert( pFrom->pTab==0 );\n+      assert( pFrom->pSTab==0 );\n@@ -147935,1 +149928,1 @@\n-      pTab = pFrom->pTab;\n+      pTab = pFrom->pSTab;\n@@ -147940,2 +149933,2 @@\n-      assert( pFrom->pTab==0 );\n-      pFrom->pTab = pTab = sqlite3LocateTableItem(pParse, 0, pFrom);\n+      assert( pFrom->pSTab==0 );\n+      pFrom->pSTab = pTab = sqlite3LocateTableItem(pParse, 0, pFrom);\n@@ -147946,1 +149939,1 @@\n-        pFrom->pTab = 0;\n+        pFrom->pSTab = 0;\n@@ -147958,1 +149951,1 @@\n-        assert( pFrom->pSelect==0 );\n+        assert( pFrom->fg.isSubquery==0 );\n@@ -147966,1 +149959,1 @@\n-          pFrom->pSelect = sqlite3SelectDup(db, pTab->u.view.pSelect, 0);\n+          sqlite3SrcItemAttachSubquery(pParse, pFrom, pTab->u.view.pSelect, 1);\n@@ -147982,1 +149975,3 @@\n-        sqlite3WalkSelect(pWalker, pFrom->pSelect);\n+        if( pFrom->fg.isSubquery ){\n+          sqlite3WalkSelect(pWalker, pFrom->u4.pSubq->pSelect);\n+        }\n@@ -148069,1 +150064,1 @@\n-          Table *pTab = pFrom->pTab;   \/* Table for this data source *\/\n+          Table *pTab = pFrom->pSTab;  \/* Table for this data source *\/\n@@ -148080,1 +150075,1 @@\n-          assert( (int)pFrom->fg.isNestedFrom == IsNestedFrom(pFrom->pSelect) );\n+          assert( (int)pFrom->fg.isNestedFrom == IsNestedFrom(pFrom) );\n@@ -148082,2 +150077,3 @@\n-            assert( pFrom->pSelect!=0 );\n-            pNestedFrom = pFrom->pSelect->pEList;\n+            assert( pFrom->fg.isSubquery && pFrom->u4.pSubq );\n+            assert( pFrom->u4.pSubq->pSelect!=0 );\n+            pNestedFrom = pFrom->u4.pSubq->pSelect->pEList;\n@@ -148319,2 +150315,1 @@\n-  testcase( (p->selFlags & SF_Resolved)==0 );\n-  assert( (p->selFlags & SF_Resolved) || IN_RENAME_OBJECT );\n+  assert( (p->selFlags & SF_Resolved) );\n@@ -148323,1 +150318,1 @@\n-    Table *pTab = pFrom->pTab;\n+    Table *pTab = pFrom->pSTab;\n@@ -148325,1 +150320,1 @@\n-    if( (pTab->tabFlags & TF_Ephemeral)!=0 ){\n+    if( (pTab->tabFlags & TF_Ephemeral)!=0 && pFrom->fg.isSubquery ){\n@@ -148327,4 +150322,2 @@\n-      Select *pSel = pFrom->pSelect;\n-      if( pSel ){\n-        sqlite3SubqueryColumnTypes(pParse, pTab, pSel, SQLITE_AFF_NONE);\n-      }\n+      Select *pSel = pFrom->u4.pSubq->pSelect;\n+      sqlite3SubqueryColumnTypes(pParse, pTab, pSel, SQLITE_AFF_NONE);\n@@ -148390,0 +150383,2 @@\n+  sqlite3DebugPrintf(\"AggInfo %d\/%p:\\n\",\n+     pAggInfo->selId, pAggInfo);\n@@ -148642,0 +150637,1 @@\n+    if( pParse->nErr ) return;\n@@ -148682,1 +150678,1 @@\n-      sqlite3VdbeChangeP5(v, (u8)nArg);\n+      sqlite3VdbeChangeP5(v, (u16)nArg);\n@@ -148845,1 +150841,1 @@\n-      sqlite3VdbeChangeP5(v, (u8)nArg);\n+      sqlite3VdbeChangeP5(v, (u16)nArg);\n@@ -148851,0 +150847,1 @@\n+    if( pParse->nErr ) return;\n@@ -148860,0 +150857,1 @@\n+    if( pParse->nErr ) return;\n@@ -148975,2 +150973,5 @@\n-  assert( pThis->pSelect!=0 );\n-  if( pThis->pSelect->selFlags & SF_PushDown ) return 0;\n+  Select *pSel;\n+  assert( pThis->fg.isSubquery );\n+  pSel = pThis->u4.pSubq->pSelect;\n+  assert( pSel!=0 );\n+  if( pSel->selFlags & SF_PushDown ) return 0;\n@@ -148980,1 +150981,1 @@\n-    if( pItem->pSelect==0 ) continue;\n+    if( !pItem->fg.isSubquery ) continue;\n@@ -148983,3 +150984,3 @@\n-    assert( pItem->pTab!=0 );\n-    assert( pThis->pTab!=0 );\n-    if( pItem->pTab->pSchema!=pThis->pTab->pSchema ) continue;\n+    assert( pItem->pSTab!=0 );\n+    assert( pThis->pSTab!=0 );\n+    if( pItem->pSTab->pSchema!=pThis->pSTab->pSchema ) continue;\n@@ -148987,2 +150988,2 @@\n-    pS1 = pItem->pSelect;\n-    if( pItem->pTab->pSchema==0 && pThis->pSelect->selId!=pS1->selId ){\n+    pS1 = pItem->u4.pSubq->pSelect;\n+    if( pItem->pSTab->pSchema==0 && pSel->selId!=pS1->selId ){\n@@ -148993,1 +150994,1 @@\n-    if( pItem->pSelect->selFlags & SF_PushDown ){\n+    if( pS1->selFlags & SF_PushDown ){\n@@ -149037,0 +151038,1 @@\n+  SrcItem *pFrom;\n@@ -149051,2 +151053,3 @@\n-  pSub = p->pSrc->a[0].pSelect;\n-  if( pSub==0 ) return 0;                           \/* The FROM is a subquery *\/\n+  pFrom = p->pSrc->a;\n+  if( pFrom->fg.isSubquery==0 ) return 0;    \/* FROM is a subquery *\/\n+  pSub = pFrom->u4.pSubq->pSelect;\n@@ -149061,1 +151064,1 @@\n-   pSub = pSub->pPrior;                              \/* Repeat over compound *\/\n+    pSub = pSub->pPrior;                              \/* Repeat over compound *\/\n@@ -149069,2 +151072,1 @@\n-  pSub = p->pSrc->a[0].pSelect;\n-  p->pSrc->a[0].pSelect = 0;\n+  pSub = sqlite3SubqueryDetach(db, pFrom);\n@@ -149115,1 +151117,1 @@\n-    if( p0->pTab==p1->pTab && 0==sqlite3_stricmp(p0->zAlias, p1->zAlias) ){\n+    if( p0->pSTab==p1->pSTab && 0==sqlite3_stricmp(p0->zAlias, p1->zAlias) ){\n@@ -149118,3 +151120,3 @@\n-    if( p1->pSelect\n-     && (p1->pSelect->selFlags & SF_NestedFrom)!=0\n-     && sameSrcAlias(p0, p1->pSelect->pSrc)\n+    if( p1->fg.isSubquery\n+     && (p1->u4.pSubq->pSelect->selFlags & SF_NestedFrom)!=0\n+     && sameSrcAlias(p0, p1->u4.pSubq->pSelect->pSrc)\n@@ -149185,1 +151187,1 @@\n-    if( pItem->pSelect!=0 ) return 0;                             \/* (1c-i) *\/\n+    if( pItem->fg.isSubquery ) return 0;                          \/* (1c-i) *\/\n@@ -149191,1 +151193,1 @@\n-** Generate code for the SELECT statement given in the p argument.\n+** Generate byte-code for the SELECT statement given in the p argument.\n@@ -149202,0 +151204,34 @@\n+**\n+** This is a long function.  The following is an outline of the processing\n+** steps, with tags referencing various milestones:\n+**\n+**  *  Resolve names and similar preparation                tag-select-0100\n+**  *  Scan of the FROM clause                              tag-select-0200\n+**      +  OUTER JOIN strength reduction                      tag-select-0220\n+**      +  Sub-query ORDER BY removal                         tag-select-0230\n+**      +  Query flattening                                   tag-select-0240\n+**  *  Separate subroutine for compound-SELECT              tag-select-0300\n+**  *  WHERE-clause constant propagation                    tag-select-0330\n+**  *  Count()-of-VIEW optimization                         tag-select-0350\n+**  *  Scan of the FROM clause again                        tag-select-0400\n+**      +  Authorize unreferenced tables                      tag-select-0410\n+**      +  Predicate push-down optimization                   tag-select-0420\n+**      +  Omit unused subquery columns optimization          tag-select-0440\n+**      +  Generate code to implement subqueries              tag-select-0480\n+**         -  Co-routines                                       tag-select-0482\n+**         -  Reuse previously computed CTE                     tag-select-0484\n+**         -  REuse previously computed VIEW                    tag-select-0486\n+**         -  Materialize a VIEW or CTE                         tag-select-0488\n+**  *  DISTINCT ORDER BY -> GROUP BY optimization           tag-select-0500\n+**  *  Set up for ORDER BY                                  tag-select-0600\n+**  *  Create output table                                  tag-select-0630\n+**  *  Prepare registers for LIMIT                          tag-select-0650\n+**  *  Setup for DISTINCT                                   tag-select-0680\n+**  *  Generate code for non-aggregate and non-GROUP BY     tag-select-0700\n+**  *  Generate code for aggregate and\/or GROUP BY          tag-select-0800\n+**      +  GROUP BY queries                                   tag-select-0810\n+**      +  non-GROUP BY queries                               tag-select-0820\n+**         -  Special case of count() w\/o GROUP BY              tag-select-0821\n+**         -  General case of non-GROUP BY aggregates           tag-select-0822\n+**  *  Sort results, as needed                              tag-select-0900\n+**  *  Internal self-checks                                 tag-select-1000\n@@ -149245,0 +151281,1 @@\n+  \/* tag-select-0100 *\/\n@@ -149296,1 +151333,1 @@\n-          p0->zAlias ? p0->zAlias : p0->pTab->zName\n+          p0->zAlias ? p0->zAlias : p0->pSTab->zName\n@@ -149331,0 +151368,1 @@\n+  ** tag-select-0200\n@@ -149335,2 +151373,2 @@\n-    Select *pSub = pItem->pSelect;\n-    Table *pTab = pItem->pTab;\n+    Select *pSub = pItem->fg.isSubquery ? pItem->u4.pSubq->pSelect : 0;\n+    Table *pTab = pItem->pSTab;\n@@ -149353,0 +151391,1 @@\n+    ** tag-select-0220\n@@ -149423,1 +151462,2 @@\n-    \/* If a FROM-clause subquery has an ORDER BY clause that is not\n+    \/* tag-select-0230:\n+    ** If a FROM-clause subquery has an ORDER BY clause that is not\n@@ -149442,0 +151482,3 @@\n+    **    (6)   The subquery is not a recursive CTE.  ORDER BY has a different\n+    **          meaning for recursive CTEs and this optimization does not\n+    **          apply.\n@@ -149448,1 +151491,1 @@\n-     && (pSub->selFlags & SF_OrderByReqd)==0      \/* Condition (2) *\/\n+     && (pSub->selFlags & (SF_OrderByReqd|SF_Recursive))==0  \/* (2) and (6) *\/\n@@ -149486,0 +151529,1 @@\n+    \/* tag-select-0240 *\/\n@@ -149501,1 +151545,1 @@\n-  ** procedure.\n+  ** procedure.  tag-select-0300\n@@ -149517,1 +151561,1 @@\n-  ** a join.  No need to speed time on this operation for non-join queries\n+  ** a join.  No need to spend time on this operation for non-join queries\n@@ -149519,1 +151563,1 @@\n-  ** sqlite3WhereBegin().\n+  ** sqlite3WhereBegin().  tag-select-0330\n@@ -149536,0 +151580,1 @@\n+  \/* tag-select-0350 *\/\n@@ -149543,3 +151588,6 @@\n-  \/* For each term in the FROM clause, do two things:\n-  ** (1) Authorized unreferenced tables\n-  ** (2) Generate code for all sub-queries\n+  \/* Loop over all terms in the FROM clause and do two things for each term:\n+  **\n+  **   (1) Authorize unreferenced tables\n+  **   (2) Generate code for all sub-queries\n+  **\n+  ** tag-select-0400\n@@ -149551,0 +151599,1 @@\n+    Subquery *pSubq;\n@@ -149556,1 +151605,3 @@\n-    \/* Issue SQLITE_READ authorizations with a fake column name for any\n+    \/* Authorized unreferenced tables.  tag-select-0410\n+    **\n+    ** Issue SQLITE_READ authorizations with a fake column name for any\n@@ -149573,1 +151624,10 @@\n-      sqlite3AuthCheck(pParse, SQLITE_READ, pItem->zName, \"\", pItem->zDatabase);\n+      const char *zDb;\n+      if( pItem->fg.fixedSchema ){\n+        int iDb = sqlite3SchemaToIndex(pParse->db, pItem->u4.pSchema);\n+        zDb = db->aDb[iDb].zDbSName;\n+      }else if( pItem->fg.isSubquery ){\n+        zDb = 0;\n+      }else{\n+        zDb = pItem->u4.zDatabase;\n+      }\n+      sqlite3AuthCheck(pParse, SQLITE_READ, pItem->zName, \"\", zDb);\n@@ -149579,2 +151639,4 @@\n-    pSub = pItem->pSelect;\n-    if( pSub==0 ) continue;\n+    if( pItem->fg.isSubquery==0 ) continue;\n+    pSubq = pItem->u4.pSubq;\n+    assert( pSubq!=0 );\n+    pSub = pSubq->pSelect;\n@@ -149583,1 +151645,1 @@\n-    assert( pItem->addrFillSub==0 );\n+    if( pSubq->addrFillSub!=0 ) continue;\n@@ -149596,0 +151658,1 @@\n+    ** This is the \"predicate push-down optimization\".  tag-select-0420\n@@ -149609,1 +151672,1 @@\n-      assert( pItem->pSelect && (pItem->pSelect->selFlags & SF_PushDown)!=0 );\n+      assert( pSubq->pSelect && (pSub->selFlags & SF_PushDown)!=0 );\n@@ -149611,1 +151674,1 @@\n-      TREETRACE(0x4000,pParse,p,(\"Push-down not possible\\n\"));\n+      TREETRACE(0x4000,pParse,p,(\"WHERE-clause push-down not possible\\n\"));\n@@ -149616,0 +151679,1 @@\n+    ** tag-select-0440\n@@ -149633,1 +151697,1 @@\n-    \/* Generate code to implement the subquery\n+    \/* Generate byte-code to implement the subquery  tag-select-0480\n@@ -149637,1 +151701,1 @@\n-      ** set on each invocation.\n+      ** set on each invocation.  tag-select-0482\n@@ -149641,2 +151705,2 @@\n-      pItem->regReturn = ++pParse->nMem;\n-      sqlite3VdbeAddOp3(v, OP_InitCoroutine, pItem->regReturn, 0, addrTop);\n+      pSubq->regReturn = ++pParse->nMem;\n+      sqlite3VdbeAddOp3(v, OP_InitCoroutine, pSubq->regReturn, 0, addrTop);\n@@ -149644,2 +151708,2 @@\n-      pItem->addrFillSub = addrTop;\n-      sqlite3SelectDestInit(&dest, SRT_Coroutine, pItem->regReturn);\n+      pSubq->addrFillSub = addrTop;\n+      sqlite3SelectDestInit(&dest, SRT_Coroutine, pSubq->regReturn);\n@@ -149648,1 +151712,1 @@\n-      pItem->pTab->nRowLogEst = pSub->nSelectRow;\n+      pItem->pSTab->nRowLogEst = pSub->nSelectRow;\n@@ -149650,2 +151714,3 @@\n-      pItem->regResult = dest.iSdst;\n-      sqlite3VdbeEndCoroutine(v, pItem->regReturn);\n+      pSubq->regResult = dest.iSdst;\n+      sqlite3VdbeEndCoroutine(v, pSubq->regReturn);\n+      VdbeComment((v, \"end %!S\", pItem));\n@@ -149657,2 +151722,2 @@\n-      ** the make the pItem->iCursor be a copy of the ephemeral table that\n-      ** holds the result of the materialization. *\/\n+      ** then make the pItem->iCursor be a copy of the ephemeral table that\n+      ** holds the result of the materialization. tag-select-0484 *\/\n@@ -149668,3 +151733,8 @@\n-      ** this same FROM clause.  Reuse it. *\/\n-      if( pPrior->addrFillSub ){\n-        sqlite3VdbeAddOp2(v, OP_Gosub, pPrior->regReturn, pPrior->addrFillSub);\n+      ** this same FROM clause.  Reuse it.  tag-select-0486 *\/\n+      Subquery *pPriorSubq;\n+      assert( pPrior->fg.isSubquery );\n+      pPriorSubq = pPrior->u4.pSubq;\n+      assert( pPriorSubq!=0 );\n+      if( pPriorSubq->addrFillSub ){\n+        sqlite3VdbeAddOp2(v, OP_Gosub, pPriorSubq->regReturn,\n+                                       pPriorSubq->addrFillSub);\n@@ -149673,1 +151743,1 @@\n-      pSub->nSelectRow = pPrior->pSelect->nSelectRow;\n+      pSub->nSelectRow = pPriorSubq->pSelect->nSelectRow;\n@@ -149677,1 +151747,1 @@\n-      ** the same view can reuse the materialization. *\/\n+      ** the same view can reuse the materialization.  tag-select-0488 *\/\n@@ -149684,1 +151754,1 @@\n-      pItem->regReturn = ++pParse->nMem;\n+      pSubq->regReturn = ++pParse->nMem;\n@@ -149686,1 +151756,1 @@\n-      pItem->addrFillSub = topAddr+1;\n+      pSubq->addrFillSub = topAddr+1;\n@@ -149701,1 +151771,1 @@\n-      pItem->pTab->nRowLogEst = pSub->nSelectRow;\n+      pItem->pSTab->nRowLogEst = pSub->nSelectRow;\n@@ -149703,1 +151773,1 @@\n-      sqlite3VdbeAddOp2(v, OP_Return, pItem->regReturn, topAddr+1);\n+      sqlite3VdbeAddOp2(v, OP_Return, pSubq->regReturn, topAddr+1);\n@@ -149710,2 +151780,2 @@\n-        pCteUse->addrM9e = pItem->addrFillSub;\n-        pCteUse->regRtn = pItem->regReturn;\n+        pCteUse->addrM9e = pSubq->addrFillSub;\n+        pCteUse->regRtn = pSubq->regReturn;\n@@ -149737,1 +151807,3 @@\n-  \/* If the query is DISTINCT with an ORDER BY but is not an aggregate, and\n+  \/* tag-select-0500\n+  **\n+  ** If the query is DISTINCT with an ORDER BY but is not an aggregate, and\n@@ -149754,0 +151826,1 @@\n+   && OptimizationEnabled(db, SQLITE_GroupByOrder)\n@@ -149760,0 +151833,5 @@\n+    if( pGroupBy ){\n+      for(i=0; i<pGroupBy->nExpr; i++){\n+        pGroupBy->a[i].u.x.iOrderByCol = i+1;\n+      }\n+    }\n@@ -149781,1 +151859,1 @@\n-  ** that change.\n+  ** that change.  tag-select-0600\n@@ -149798,0 +151876,1 @@\n+  ** tag-select-0630\n@@ -149815,1 +151894,1 @@\n-  \/* Set the limiter.\n+  \/* Set the limiter.  tag-select-0650\n@@ -149827,1 +151906,1 @@\n-  \/* Open an ephemeral index to use for the distinct set.\n+  \/* Open an ephemeral index to use for the distinct set. tag-select-0680\n@@ -149842,1 +151921,1 @@\n-    \/* No aggregate functions and no GROUP BY clause *\/\n+    \/* No aggregate functions and no GROUP BY clause.  tag-select-0700 *\/\n@@ -149915,2 +151994,2 @@\n-    \/* This case when there exist aggregate functions or a GROUP BY clause\n-    ** or both *\/\n+    \/* This case is for when there exist aggregate functions or a GROUP BY\n+    ** clause or both.  tag-select-0800 *\/\n@@ -150035,1 +152114,1 @@\n-    ** much more complex than aggregates without a GROUP BY.\n+    ** much more complex than aggregates without a GROUP BY.  tag-select-0810\n@@ -150222,0 +152301,2 @@\n+        int iOrderByCol = pGroupBy->a[j].u.x.iOrderByCol;\n+\n@@ -150228,0 +152309,11 @@\n+\n+        if( iOrderByCol ){\n+          Expr *pX = p->pEList->a[iOrderByCol-1].pExpr;\n+          Expr *pBase = sqlite3ExprSkipCollateAndLikely(pX);\n+          if( ALWAYS(pBase!=0)\n+           && pBase->op!=TK_AGG_COLUMN\n+           && pBase->op!=TK_REGISTER\n+          ){\n+            sqlite3ExprToRegister(pX, iAMem+j);\n+          }\n+        }\n@@ -150243,1 +152335,0 @@\n-      sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);\n@@ -150246,0 +152337,1 @@\n+      sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);\n@@ -150319,0 +152411,1 @@\n+      \/* Aggregate functions without GROUP BY. tag-select-0820 *\/\n@@ -150321,1 +152414,3 @@\n-        \/* If isSimpleCount() returns a pointer to a Table structure, then\n+        \/* tag-select-0821\n+        **\n+        ** If isSimpleCount() returns a pointer to a Table structure, then\n@@ -150380,0 +152475,2 @@\n+        \/* The general case of an aggregate query without GROUP BY\n+        ** tag-select-0822 *\/\n@@ -150468,1 +152565,1 @@\n-  ** and send them to the callback one by one.\n+  ** and send them to the callback one by one.  tag-select-0900\n@@ -150491,0 +152588,1 @@\n+  \/* Internal self-checks.  tag-select-1000 *\/\n@@ -150492,0 +152590,6 @@\n+#if TREETRACE_ENABLED\n+    if( sqlite3TreeTrace & 0x20 ){\n+      TREETRACE(0x20,pParse,p,(\"Finished with AggInfo\\n\"));\n+      printAggInfo(pAggInfo);\n+    }\n+#endif\n@@ -150874,2 +152978,4 @@\n-    sqlite3DbFree(db, pTableName->a[0].zDatabase);\n-    pTableName->a[0].zDatabase = 0;\n+    assert( pTableName->a[0].fg.fixedSchema==0 );\n+    assert( pTableName->a[0].fg.isSubquery==0 );\n+    sqlite3DbFree(db, pTableName->a[0].u4.zDatabase);\n+    pTableName->a[0].u4.zDatabase = 0;\n@@ -151353,1 +153459,2 @@\n-  zDb = pName->a[0].zDatabase;\n+  assert( pName->a[0].fg.fixedSchema==0 && pName->a[0].fg.isSubquery==0 );\n+  zDb = pName->a[0].u4.zDatabase;\n@@ -151590,1 +153697,3 @@\n-      pSrc->a[0].pSchema = pSchema;\n+      assert( pSrc->a[0].fg.fixedSchema || pSrc->a[0].u4.zDatabase==0 );\n+      pSrc->a[0].u4.pSchema = pSchema;\n+      pSrc->a[0].fg.fixedSchema = 1;\n@@ -151673,0 +153782,66 @@\n+\/* If the Expr node is a subquery or an EXISTS operator or an IN operator that\n+** uses a subquery, and if the subquery is SF_Correlated, then mark the\n+** expression as EP_VarSelect.\n+*\/\n+static int sqlite3ReturningSubqueryVarSelect(Walker *NotUsed, Expr *pExpr){\n+  UNUSED_PARAMETER(NotUsed);\n+  if( ExprUseXSelect(pExpr)\n+   && (pExpr->x.pSelect->selFlags & SF_Correlated)!=0\n+  ){\n+    testcase( ExprHasProperty(pExpr, EP_VarSelect) );\n+    ExprSetProperty(pExpr, EP_VarSelect);\n+  }\n+  return WRC_Continue;\n+}\n+\n+\n+\/*\n+** If the SELECT references the table pWalker->u.pTab, then do two things:\n+**\n+**    (1) Mark the SELECT as as SF_Correlated.\n+**    (2) Set pWalker->eCode to non-zero so that the caller will know\n+**        that (1) has happened.\n+*\/\n+static int sqlite3ReturningSubqueryCorrelated(Walker *pWalker, Select *pSelect){\n+  int i;\n+  SrcList *pSrc;\n+  assert( pSelect!=0 );\n+  pSrc = pSelect->pSrc;\n+  assert( pSrc!=0 );\n+  for(i=0; i<pSrc->nSrc; i++){\n+    if( pSrc->a[i].pSTab==pWalker->u.pTab ){\n+      testcase( pSelect->selFlags & SF_Correlated );\n+      pSelect->selFlags |= SF_Correlated;\n+      pWalker->eCode = 1;\n+      break;\n+    }\n+  }\n+  return WRC_Continue;\n+}\n+\n+\/*\n+** Scan the expression list that is the argument to RETURNING looking\n+** for subqueries that depend on the table which is being modified in the\n+** statement that is hosting the RETURNING clause (pTab).  Mark all such\n+** subqueries as SF_Correlated.  If the subqueries are part of an\n+** expression, mark the expression as EP_VarSelect.\n+**\n+** https:\/\/sqlite.org\/forum\/forumpost\/2c83569ce8945d39\n+*\/\n+static void sqlite3ProcessReturningSubqueries(\n+  ExprList *pEList,\n+  Table *pTab\n+){\n+  Walker w;\n+  memset(&w, 0, sizeof(w));\n+  w.xExprCallback = sqlite3ExprWalkNoop;\n+  w.xSelectCallback = sqlite3ReturningSubqueryCorrelated;\n+  w.u.pTab = pTab;\n+  sqlite3WalkExprList(&w, pEList);\n+  if( w.eCode ){\n+    w.xExprCallback = sqlite3ReturningSubqueryVarSelect;\n+    w.xSelectCallback = sqlite3SelectWalkNoop;\n+    sqlite3WalkExprList(&w, pEList);\n+  }\n+}\n+\n@@ -151708,1 +153883,2 @@\n-  sFrom.a[0].pTab = pTab;\n+  sFrom.a[0].pSTab = pTab;\n+  sFrom.a[0].zName = pTab->zName; \/* tag-20240424-1 *\/\n@@ -151735,0 +153911,1 @@\n+      sqlite3ProcessReturningSubqueries(pNew, pTab);\n@@ -152058,1 +154235,1 @@\n-    sqlite3VdbeChangeP5(v, (u8)bRecursive);\n+    sqlite3VdbeChangeP5(v, (u16)bRecursive);\n@@ -152417,1 +154594,1 @@\n-  Table *pTab = pTabList->a[0].pTab;\n+  Table *pTab = pTabList->a[0].pSTab;\n@@ -152441,2 +154618,2 @@\n-    pSrc->a[0].pTab->nTabRef--;\n-    pSrc->a[0].pTab = 0;\n+    pSrc->a[0].pSTab->nTabRef--;\n+    pSrc->a[0].pSTab = 0;\n@@ -153690,1 +155867,1 @@\n-  assert( pTabList->a[0].pTab!=0 );\n+  assert( pTabList->a[0].pSTab!=0 );\n@@ -153709,1 +155886,1 @@\n-    pTab = pTabList->a[0].pTab;\n+    pTab = pTabList->a[0].pSTab;\n@@ -154080,0 +156257,3 @@\n+  u64 iRandom;            \/* Random value used for zDbVacuum[] *\/\n+  char zDbVacuum[42];     \/* Name of the ATTACH-ed database used for vacuum *\/\n+\n@@ -154120,1 +156300,1 @@\n-  \/* Attach the temporary database as 'vacuum_db'. The synchronous pragma\n+  \/* Attach the temporary database as 'vacuum_XXXXXX'. The synchronous pragma\n@@ -154127,1 +156307,1 @@\n-  ** (Later:) I tried setting \"PRAGMA vacuum_db.journal_mode=OFF\" but\n+  ** (Later:) I tried setting \"PRAGMA vacuum_XXXXXX.journal_mode=OFF\" but\n@@ -154134,0 +156314,2 @@\n+  sqlite3_randomness(sizeof(iRandom),&iRandom);\n+  sqlite3_snprintf(sizeof(zDbVacuum), zDbVacuum, \"vacuum_%016llx\", iRandom);\n@@ -154135,1 +156317,1 @@\n-  rc = execSqlF(db, pzErrMsg, \"ATTACH %Q AS vacuum_db\", zOut);\n+  rc = execSqlF(db, pzErrMsg, \"ATTACH %Q AS %s\", zOut, zDbVacuum);\n@@ -154140,1 +156322,1 @@\n-  assert( strcmp(pDb->zDbSName,\"vacuum_db\")==0 );\n+  assert( strcmp(pDb->zDbSName,zDbVacuum)==0 );\n@@ -154217,1 +156399,1 @@\n-      \"SELECT'INSERT INTO vacuum_db.'||quote(name)\"\n+      \"SELECT'INSERT INTO %s.'||quote(name)\"\n@@ -154219,1 +156401,1 @@\n-      \"FROM vacuum_db.sqlite_schema \"\n+      \"FROM %s.sqlite_schema \"\n@@ -154221,1 +156403,1 @@\n-      zDbMain\n+      zDbVacuum, zDbMain, zDbVacuum\n@@ -154233,1 +156415,1 @@\n-      \"INSERT INTO vacuum_db.sqlite_schema\"\n+      \"INSERT INTO %s.sqlite_schema\"\n@@ -154237,1 +156419,1 @@\n-      zDbMain\n+      zDbVacuum, zDbMain\n@@ -154945,0 +157127,2 @@\n+  assert( pTab!=0 );\n+  assert( pTab->nTabRef>1 || rc!=SQLITE_OK );\n@@ -154967,1 +157151,1 @@\n-      *pzErr = sqlite3MPrintf(db, zFormat, pTab->zName);\n+      *pzErr = sqlite3MPrintf(db, zFormat, zModuleName);\n@@ -155145,0 +157329,3 @@\n+  int i;\n+  const unsigned char *z;\n+  static const u8 aKeyword[] = { TK_CREATE, TK_TABLE, 0 };\n@@ -155151,0 +157338,17 @@\n+\n+  \/* Verify that the first two keywords in the CREATE TABLE statement\n+  ** really are \"CREATE\" and \"TABLE\".  If this is not the case, then\n+  ** sqlite3_declare_vtab() is being misused.\n+  *\/\n+  z = (const unsigned char*)zCreateTable;\n+  for(i=0; aKeyword[i]; i++){\n+    int tokenType = 0;\n+    do{\n+      z += sqlite3GetToken(z, &tokenType);\n+    }while( tokenType==TK_SPACE || tokenType==TK_COMMENT );\n+    if( tokenType!=aKeyword[i] ){\n+      sqlite3ErrorWithMsg(db, SQLITE_ERROR, \"syntax error\");\n+      return SQLITE_ERROR;\n+    }\n+  }\n+\n@@ -155158,0 +157362,1 @@\n+\n@@ -155171,5 +157376,4 @@\n-  if( SQLITE_OK==sqlite3RunParser(&sParse, zCreateTable)\n-   && ALWAYS(sParse.pNewTable!=0)\n-   && ALWAYS(!db->mallocFailed)\n-   && IsOrdinaryTable(sParse.pNewTable)\n-  ){\n+  if( SQLITE_OK==sqlite3RunParser(&sParse, zCreateTable) ){\n+    assert( sParse.pNewTable!=0 );\n+    assert( !db->mallocFailed );\n+    assert( IsOrdinaryTable(sParse.pNewTable) );\n@@ -155181,0 +157385,1 @@\n+      assert( IsOrdinaryTable(pNew) );\n@@ -155855,0 +158060,1 @@\n+      ExprList *pOrderBy;    \/* ORDER BY clause if this is really a subquery *\/\n@@ -155860,0 +158066,1 @@\n+      u32 bIdxNumHex : 1;    \/* Show idxNum as hex in EXPLAIN QUERY PLAN *\/\n@@ -155872,0 +158079,4 @@\n+#ifdef WHERETRACE_ENABLED\n+  LogEst rStarDelta;    \/* Cost delta due to star-schema heuristic.  Not\n+                        ** initialized unless pWInfo->bStarUsed *\/\n+#endif\n@@ -155920,1 +158131,1 @@\n-  LogEst rUnsorted;     \/* Total cost of this path ignoring sorting costs *\/\n+  LogEst rUnsort;       \/* Total cost of this path ignoring sorting costs *\/\n@@ -156193,1 +158404,3 @@\n-  unsigned sorted :1;          \/* True if really sorted (not just grouped) *\/\n+  unsigned sorted        :1;   \/* True if really sorted (not just grouped) *\/\n+  unsigned bStarDone     :1;   \/* True if check for star-query is complete *\/\n+  unsigned bStarUsed     :1;   \/* True if star-query heuristic is used *\/\n@@ -156195,0 +158408,3 @@\n+#ifdef WHERETRACE_ENABLED\n+  LogEst rTotalCost;        \/* Total cost of the solution *\/\n+#endif\n@@ -156240,0 +158456,7 @@\n+SQLITE_PRIVATE void sqlite3WhereAddExplainText(\n+  Parse *pParse,                  \/* Parse context *\/\n+  int addr,\n+  SrcList *pTabList,              \/* Table list this loop refers to *\/\n+  WhereLevel *pLevel,             \/* Scan to write OP_Explain opcode for *\/\n+  u16 wctrlFlags                  \/* Flags passed to sqlite3WhereBegin() *\/\n+);\n@@ -156243,0 +158466,1 @@\n+# define  sqlite3WhereAddExplainText(u,v,w,x,y)\n@@ -156345,1 +158569,2 @@\n-                      \/*   0x02000000  -- available for reuse *\/\n+#define WHERE_COROUTINE    0x02000000  \/* Implemented by co-routine.\n+                                       ** NB: False-negatives are possible *\/\n@@ -156443,7 +158668,3 @@\n-** This function is a no-op unless currently processing an EXPLAIN QUERY PLAN\n-** command, or if stmt_scanstatus_v2() stats are enabled, or if SQLITE_DEBUG\n-** was defined at compile-time. If it is not a no-op, a single OP_Explain\n-** opcode is added to the output to describe the table scan strategy in pLevel.\n-**\n-** If an OP_Explain opcode is added to the VM, its address is returned.\n-** Otherwise, if no OP_Explain is coded, zero is returned.\n+** This function sets the P4 value of an existing OP_Explain opcode to\n+** text describing the loop in pLevel. If the OP_Explain opcode already has\n+** a P4 value, it is freed before it is overwritten.\n@@ -156451,1 +158672,1 @@\n-SQLITE_PRIVATE int sqlite3WhereExplainOneScan(\n+SQLITE_PRIVATE void sqlite3WhereAddExplainText(\n@@ -156453,0 +158674,1 @@\n+  int addr,                       \/* Address of OP_Explain opcode *\/\n@@ -156457,1 +158679,0 @@\n-  int ret = 0;\n@@ -156462,0 +158683,2 @@\n+    VdbeOp *pOp = sqlite3VdbeGetOp(pParse->pVdbe, addr);\n+\n@@ -156463,1 +158686,0 @@\n-    Vdbe *v = pParse->pVdbe;      \/* VM being constructed *\/\n@@ -156468,0 +158690,1 @@\n+#if defined(SQLITE_DEBUG) && !defined(SQLITE_OMIT_EXPLAIN)\n@@ -156469,0 +158692,1 @@\n+#endif\n@@ -156472,0 +158696,2 @@\n+    if( db->mallocFailed ) return;\n+\n@@ -156474,1 +158700,0 @@\n-    if( (flags&WHERE_MULTI_OR) || (wctrlFlags&WHERE_OR_SUBCLAUSE) ) return 0;\n@@ -156490,1 +158715,1 @@\n-      if( !HasRowid(pItem->pTab) && IsPrimaryKeyIndex(pIdx) ){\n+      if( !HasRowid(pItem->pSTab) && IsPrimaryKeyIndex(pIdx) ){\n@@ -156498,1 +158723,1 @@\n-      }else if( flags & WHERE_IDX_ONLY ){\n+      }else if( flags & (WHERE_IDX_ONLY|WHERE_EXPRIDX) ){\n@@ -156533,1 +158758,3 @@\n-      sqlite3_str_appendf(&str, \" VIRTUAL TABLE INDEX %d:%s\",\n+      sqlite3_str_appendall(&str, \" VIRTUAL TABLE INDEX \");\n+      sqlite3_str_appendf(&str,\n+                  pLoop->u.vtab.bIdxNumHex ? \"0x%x:%s\" : \"%d:%s\",\n@@ -156548,0 +158775,1 @@\n+#if defined(SQLITE_DEBUG) && !defined(SQLITE_OMIT_EXPLAIN)\n@@ -156550,2 +158778,41 @@\n-    ret = sqlite3VdbeAddOp4(v, OP_Explain, sqlite3VdbeCurrentAddr(v),\n-                            pParse->addrExplain, 0, zMsg,P4_DYNAMIC);\n+#endif\n+\n+    assert( pOp->opcode==OP_Explain );\n+    assert( pOp->p4type==P4_DYNAMIC || pOp->p4.z==0 );\n+    sqlite3DbFree(db, pOp->p4.z);\n+    pOp->p4type = P4_DYNAMIC;\n+    pOp->p4.z = sqlite3StrAccumFinish(&str);\n+  }\n+}\n+\n+\n+\/*\n+** This function is a no-op unless currently processing an EXPLAIN QUERY PLAN\n+** command, or if stmt_scanstatus_v2() stats are enabled, or if SQLITE_DEBUG\n+** was defined at compile-time. If it is not a no-op, a single OP_Explain\n+** opcode is added to the output to describe the table scan strategy in pLevel.\n+**\n+** If an OP_Explain opcode is added to the VM, its address is returned.\n+** Otherwise, if no OP_Explain is coded, zero is returned.\n+*\/\n+SQLITE_PRIVATE int sqlite3WhereExplainOneScan(\n+  Parse *pParse,                  \/* Parse context *\/\n+  SrcList *pTabList,              \/* Table list this loop refers to *\/\n+  WhereLevel *pLevel,             \/* Scan to write OP_Explain opcode for *\/\n+  u16 wctrlFlags                  \/* Flags passed to sqlite3WhereBegin() *\/\n+){\n+  int ret = 0;\n+#if !defined(SQLITE_DEBUG)\n+  if( sqlite3ParseToplevel(pParse)->explain==2 || IS_STMT_SCANSTATUS(pParse->db) )\n+#endif\n+  {\n+    if( (pLevel->pWLoop->wsFlags & WHERE_MULTI_OR)==0\n+     && (wctrlFlags & WHERE_OR_SUBCLAUSE)==0\n+    ){\n+      Vdbe *v = pParse->pVdbe;\n+      int addr = sqlite3VdbeCurrentAddr(v);\n+      ret = sqlite3VdbeAddOp3(\n+          v, OP_Explain, addr, pParse->addrExplain, pLevel->pWLoop->rRun\n+      );\n+      sqlite3WhereAddExplainText(pParse, addr, pTabList, pLevel, wctrlFlags);\n+    }\n@@ -156586,1 +158853,1 @@\n-    const Table *pTab = pItem->pTab;\n+    const Table *pTab = pItem->pSTab;\n@@ -156649,2 +158916,5 @@\n-      int addr = pSrclist->a[pLvl->iFrom].addrFillSub;\n-      VdbeOp *pOp = sqlite3VdbeGetOp(v, addr-1);\n+      int addr;\n+      VdbeOp *pOp;\n+      assert( pSrclist->a[pLvl->iFrom].fg.isSubquery );\n+      addr = pSrclist->a[pLvl->iFrom].u4.pSubq->addrFillSub;\n+      pOp = sqlite3VdbeGetOp(v, addr-1);\n@@ -156793,0 +159063,33 @@\n+\/*\n+** The pOrderBy->a[].u.x.iOrderByCol values might be incorrect because\n+** columns might have been rearranged in the result set.  This routine\n+** fixes them up.\n+**\n+** pEList is the new result set.  The pEList->a[].u.x.iOrderByCol values\n+** contain the *old* locations of each expression.  This is a temporary\n+** use of u.x.iOrderByCol, not its intended use.  The caller must reset\n+** u.x.iOrderByCol back to zero for all entries in pEList before the\n+** caller returns.\n+**\n+** This routine changes pOrderBy->a[].u.x.iOrderByCol values from\n+** pEList->a[N].u.x.iOrderByCol into N+1.  (The \"+1\" is because of the 1-based\n+** indexing used by iOrderByCol.)  Or if no match, iOrderByCol is set to zero.\n+*\/\n+static void adjustOrderByCol(ExprList *pOrderBy, ExprList *pEList){\n+  int i, j;\n+  if( pOrderBy==0 ) return;\n+  for(i=0; i<pOrderBy->nExpr; i++){\n+    int t = pOrderBy->a[i].u.x.iOrderByCol;\n+    if( t==0 ) continue;\n+    for(j=0; j<pEList->nExpr; j++){\n+      if( pEList->a[j].u.x.iOrderByCol==t ){\n+        pOrderBy->a[i].u.x.iOrderByCol = j+1;\n+        break;\n+      }\n+    }\n+    if( j>=pEList->nExpr ){\n+      pOrderBy->a[i].u.x.iOrderByCol = 0;\n+    }\n+  }\n+}\n+\n@@ -156856,0 +159159,1 @@\n+          if( pRhs ) pRhs->a[pRhs->nExpr-1].u.x.iOrderByCol = iField+1;\n@@ -156869,0 +159173,1 @@\n+      pSelect->selId = ++pParse->nSelect; \/* Req'd for SubrtnSig validity *\/\n@@ -156878,12 +159183,10 @@\n-      if( pSelect->pOrderBy ){\n-        \/* If the SELECT statement has an ORDER BY clause, zero the\n-        ** iOrderByCol variables. These are set to non-zero when an\n-        ** ORDER BY term exactly matches one of the terms of the\n-        ** result-set. Since the result-set of the SELECT statement may\n-        ** have been modified or reordered, these variables are no longer\n-        ** set correctly.  Since setting them is just an optimization,\n-        ** it's easiest just to zero them here.  *\/\n-        ExprList *pOrderBy = pSelect->pOrderBy;\n-        for(i=0; i<pOrderBy->nExpr; i++){\n-          pOrderBy->a[i].u.x.iOrderByCol = 0;\n-        }\n+\n+      \/* If either the ORDER BY clause or the GROUP BY clause contains\n+      ** references to result-set columns, those references might now be\n+      ** obsolete.  So fix them up.\n+      *\/\n+      assert( pRhs!=0 || db->mallocFailed );\n+      if( pRhs ){\n+        adjustOrderByCol(pSelect->pOrderBy, pRhs);\n+        adjustOrderByCol(pSelect->pGroupBy, pRhs);\n+        for(i=0; i<pRhs->nExpr; i++) pRhs->a[i].u.x.iOrderByCol = 0;\n@@ -156904,0 +159207,141 @@\n+#ifndef SQLITE_OMIT_SUBQUERY\n+\/*\n+** Generate code for a single X IN (....) term of the WHERE clause.\n+**\n+** This is a special-case of codeEqualityTerm() that works for IN operators\n+** only.  It is broken out into a subroutine because this case is\n+** uncommon and by splitting it off into a subroutine, the common case\n+** runs faster.\n+**\n+** The current value for the constraint is left in  register iTarget.\n+** This routine sets up a loop that will iterate over all values of X.\n+*\/\n+static SQLITE_NOINLINE void codeINTerm(\n+  Parse *pParse,      \/* The parsing context *\/\n+  WhereTerm *pTerm,   \/* The term of the WHERE clause to be coded *\/\n+  WhereLevel *pLevel, \/* The level of the FROM clause we are working on *\/\n+  int iEq,            \/* Index of the equality term within this level *\/\n+  int bRev,           \/* True for reverse-order IN operations *\/\n+  int iTarget         \/* Attempt to leave results in this register *\/\n+){\n+  Expr *pX = pTerm->pExpr;\n+  int eType = IN_INDEX_NOOP;\n+  int iTab;\n+  struct InLoop *pIn;\n+  WhereLoop *pLoop = pLevel->pWLoop;\n+  Vdbe *v = pParse->pVdbe;\n+  int i;\n+  int nEq = 0;\n+  int *aiMap = 0;\n+\n+  if( (pLoop->wsFlags & WHERE_VIRTUALTABLE)==0\n+    && pLoop->u.btree.pIndex!=0\n+    && pLoop->u.btree.pIndex->aSortOrder[iEq]\n+  ){\n+    testcase( iEq==0 );\n+    testcase( bRev );\n+    bRev = !bRev;\n+  }\n+  assert( pX->op==TK_IN );\n+\n+  for(i=0; i<iEq; i++){\n+    if( pLoop->aLTerm[i] && pLoop->aLTerm[i]->pExpr==pX ){\n+      disableTerm(pLevel, pTerm);\n+      return;\n+    }\n+  }\n+  for(i=iEq;i<pLoop->nLTerm; i++){\n+    assert( pLoop->aLTerm[i]!=0 );\n+    if( pLoop->aLTerm[i]->pExpr==pX ) nEq++;\n+  }\n+\n+  iTab = 0;\n+  if( !ExprUseXSelect(pX) || pX->x.pSelect->pEList->nExpr==1 ){\n+    eType = sqlite3FindInIndex(pParse, pX, IN_INDEX_LOOP, 0, 0, &iTab);\n+  }else{\n+    Expr *pExpr = pTerm->pExpr;\n+    if( pExpr->iTable==0 || !ExprHasProperty(pExpr, EP_Subrtn) ){\n+      sqlite3 *db = pParse->db;\n+      pX = removeUnindexableInClauseTerms(pParse, iEq, pLoop, pX);\n+      if( !db->mallocFailed ){\n+        aiMap = (int*)sqlite3DbMallocZero(pParse->db, sizeof(int)*nEq);\n+        eType = sqlite3FindInIndex(pParse, pX, IN_INDEX_LOOP, 0, aiMap,&iTab);\n+        pExpr->iTable = iTab;\n+      }\n+      sqlite3ExprDelete(db, pX);\n+    }else{\n+      int n = sqlite3ExprVectorSize(pX->pLeft);\n+      aiMap = (int*)sqlite3DbMallocZero(pParse->db, sizeof(int)*MAX(nEq,n));\n+      eType = sqlite3FindInIndex(pParse, pX, IN_INDEX_LOOP, 0, aiMap, &iTab);\n+    }\n+    pX = pExpr;\n+  }\n+\n+  if( eType==IN_INDEX_INDEX_DESC ){\n+    testcase( bRev );\n+    bRev = !bRev;\n+  }\n+  sqlite3VdbeAddOp2(v, bRev ? OP_Last : OP_Rewind, iTab, 0);\n+  VdbeCoverageIf(v, bRev);\n+  VdbeCoverageIf(v, !bRev);\n+\n+  assert( (pLoop->wsFlags & WHERE_MULTI_OR)==0 );\n+  pLoop->wsFlags |= WHERE_IN_ABLE;\n+  if( pLevel->u.in.nIn==0 ){\n+    pLevel->addrNxt = sqlite3VdbeMakeLabel(pParse);\n+  }\n+  if( iEq>0 && (pLoop->wsFlags & WHERE_IN_SEEKSCAN)==0 ){\n+    pLoop->wsFlags |= WHERE_IN_EARLYOUT;\n+  }\n+\n+  i = pLevel->u.in.nIn;\n+  pLevel->u.in.nIn += nEq;\n+  pLevel->u.in.aInLoop =\n+     sqlite3WhereRealloc(pTerm->pWC->pWInfo,\n+                         pLevel->u.in.aInLoop,\n+                         sizeof(pLevel->u.in.aInLoop[0])*pLevel->u.in.nIn);\n+  pIn = pLevel->u.in.aInLoop;\n+  if( pIn ){\n+    int iMap = 0;               \/* Index in aiMap[] *\/\n+    pIn += i;\n+    for(i=iEq;i<pLoop->nLTerm; i++){\n+      if( pLoop->aLTerm[i]->pExpr==pX ){\n+        int iOut = iTarget + i - iEq;\n+        if( eType==IN_INDEX_ROWID ){\n+          pIn->addrInTop = sqlite3VdbeAddOp2(v, OP_Rowid, iTab, iOut);\n+        }else{\n+          int iCol = aiMap ? aiMap[iMap++] : 0;\n+          pIn->addrInTop = sqlite3VdbeAddOp3(v,OP_Column,iTab, iCol, iOut);\n+        }\n+        sqlite3VdbeAddOp1(v, OP_IsNull, iOut); VdbeCoverage(v);\n+        if( i==iEq ){\n+          pIn->iCur = iTab;\n+          pIn->eEndLoopOp = bRev ? OP_Prev : OP_Next;\n+          if( iEq>0 ){\n+            pIn->iBase = iTarget - i;\n+            pIn->nPrefix = i;\n+          }else{\n+            pIn->nPrefix = 0;\n+          }\n+        }else{\n+          pIn->eEndLoopOp = OP_Noop;\n+        }\n+        pIn++;\n+      }\n+    }\n+    testcase( iEq>0\n+              && (pLoop->wsFlags & WHERE_IN_SEEKSCAN)==0\n+              && (pLoop->wsFlags & WHERE_VIRTUALTABLE)!=0 );\n+    if( iEq>0\n+     && (pLoop->wsFlags & (WHERE_IN_SEEKSCAN|WHERE_VIRTUALTABLE))==0\n+    ){\n+      sqlite3VdbeAddOp3(v, OP_SeekHit, pLevel->iIdxCur, 0, iEq);\n+    }\n+  }else{\n+    pLevel->u.in.nIn = 0;\n+  }\n+  sqlite3DbFree(pParse->db, aiMap);\n+}\n+#endif\n+\n+\n@@ -156928,1 +159372,0 @@\n-  Vdbe *v = pParse->pVdbe;\n@@ -156937,1 +159380,1 @@\n-    sqlite3VdbeAddOp2(v, OP_Null, 0, iReg);\n+    sqlite3VdbeAddOp2(pParse->pVdbe, OP_Null, 0, iReg);\n@@ -156940,16 +159383,0 @@\n-    int eType = IN_INDEX_NOOP;\n-    int iTab;\n-    struct InLoop *pIn;\n-    WhereLoop *pLoop = pLevel->pWLoop;\n-    int i;\n-    int nEq = 0;\n-    int *aiMap = 0;\n-\n-    if( (pLoop->wsFlags & WHERE_VIRTUALTABLE)==0\n-      && pLoop->u.btree.pIndex!=0\n-      && pLoop->u.btree.pIndex->aSortOrder[iEq]\n-    ){\n-      testcase( iEq==0 );\n-      testcase( bRev );\n-      bRev = !bRev;\n-    }\n@@ -156958,98 +159385,1 @@\n-\n-    for(i=0; i<iEq; i++){\n-      if( pLoop->aLTerm[i] && pLoop->aLTerm[i]->pExpr==pX ){\n-        disableTerm(pLevel, pTerm);\n-        return iTarget;\n-      }\n-    }\n-    for(i=iEq;i<pLoop->nLTerm; i++){\n-      assert( pLoop->aLTerm[i]!=0 );\n-      if( pLoop->aLTerm[i]->pExpr==pX ) nEq++;\n-    }\n-\n-    iTab = 0;\n-    if( !ExprUseXSelect(pX) || pX->x.pSelect->pEList->nExpr==1 ){\n-      eType = sqlite3FindInIndex(pParse, pX, IN_INDEX_LOOP, 0, 0, &iTab);\n-    }else{\n-      Expr *pExpr = pTerm->pExpr;\n-      if( pExpr->iTable==0 || !ExprHasProperty(pExpr, EP_Subrtn) ){\n-        sqlite3 *db = pParse->db;\n-        pX = removeUnindexableInClauseTerms(pParse, iEq, pLoop, pX);\n-        if( !db->mallocFailed ){\n-          aiMap = (int*)sqlite3DbMallocZero(pParse->db, sizeof(int)*nEq);\n-          eType = sqlite3FindInIndex(pParse, pX, IN_INDEX_LOOP, 0, aiMap,&iTab);\n-          pExpr->iTable = iTab;\n-        }\n-        sqlite3ExprDelete(db, pX);\n-      }else{\n-        int n = sqlite3ExprVectorSize(pX->pLeft);\n-        aiMap = (int*)sqlite3DbMallocZero(pParse->db, sizeof(int)*MAX(nEq,n));\n-        eType = sqlite3FindInIndex(pParse, pX, IN_INDEX_LOOP, 0, aiMap, &iTab);\n-      }\n-      pX = pExpr;\n-    }\n-\n-    if( eType==IN_INDEX_INDEX_DESC ){\n-      testcase( bRev );\n-      bRev = !bRev;\n-    }\n-    sqlite3VdbeAddOp2(v, bRev ? OP_Last : OP_Rewind, iTab, 0);\n-    VdbeCoverageIf(v, bRev);\n-    VdbeCoverageIf(v, !bRev);\n-\n-    assert( (pLoop->wsFlags & WHERE_MULTI_OR)==0 );\n-    pLoop->wsFlags |= WHERE_IN_ABLE;\n-    if( pLevel->u.in.nIn==0 ){\n-      pLevel->addrNxt = sqlite3VdbeMakeLabel(pParse);\n-    }\n-    if( iEq>0 && (pLoop->wsFlags & WHERE_IN_SEEKSCAN)==0 ){\n-      pLoop->wsFlags |= WHERE_IN_EARLYOUT;\n-    }\n-\n-    i = pLevel->u.in.nIn;\n-    pLevel->u.in.nIn += nEq;\n-    pLevel->u.in.aInLoop =\n-       sqlite3WhereRealloc(pTerm->pWC->pWInfo,\n-                           pLevel->u.in.aInLoop,\n-                           sizeof(pLevel->u.in.aInLoop[0])*pLevel->u.in.nIn);\n-    pIn = pLevel->u.in.aInLoop;\n-    if( pIn ){\n-      int iMap = 0;               \/* Index in aiMap[] *\/\n-      pIn += i;\n-      for(i=iEq;i<pLoop->nLTerm; i++){\n-        if( pLoop->aLTerm[i]->pExpr==pX ){\n-          int iOut = iReg + i - iEq;\n-          if( eType==IN_INDEX_ROWID ){\n-            pIn->addrInTop = sqlite3VdbeAddOp2(v, OP_Rowid, iTab, iOut);\n-          }else{\n-            int iCol = aiMap ? aiMap[iMap++] : 0;\n-            pIn->addrInTop = sqlite3VdbeAddOp3(v,OP_Column,iTab, iCol, iOut);\n-          }\n-          sqlite3VdbeAddOp1(v, OP_IsNull, iOut); VdbeCoverage(v);\n-          if( i==iEq ){\n-            pIn->iCur = iTab;\n-            pIn->eEndLoopOp = bRev ? OP_Prev : OP_Next;\n-            if( iEq>0 ){\n-              pIn->iBase = iReg - i;\n-              pIn->nPrefix = i;\n-            }else{\n-              pIn->nPrefix = 0;\n-            }\n-          }else{\n-            pIn->eEndLoopOp = OP_Noop;\n-          }\n-          pIn++;\n-        }\n-      }\n-      testcase( iEq>0\n-                && (pLoop->wsFlags & WHERE_IN_SEEKSCAN)==0\n-                && (pLoop->wsFlags & WHERE_VIRTUALTABLE)!=0 );\n-      if( iEq>0\n-       && (pLoop->wsFlags & (WHERE_IN_SEEKSCAN|WHERE_VIRTUALTABLE))==0\n-      ){\n-        sqlite3VdbeAddOp3(v, OP_SeekHit, pLevel->iIdxCur, 0, iEq);\n-      }\n-    }else{\n-      pLevel->u.in.nIn = 0;\n-    }\n-    sqlite3DbFree(pParse->db, aiMap);\n+    codeINTerm(pParse, pTerm, pLevel, iEq, bRev, iTarget);\n@@ -157670,0 +160000,21 @@\n+\/*\n+** Loop pLoop is a WHERE_INDEXED level that uses at least one IN(...)\n+** operator. Return true if level pLoop is guaranteed to visit only one\n+** row for each key generated for the index.\n+*\/\n+static int whereLoopIsOneRow(WhereLoop *pLoop){\n+  if( pLoop->u.btree.pIndex->onError\n+   && pLoop->nSkip==0\n+   && pLoop->u.btree.nEq==pLoop->u.btree.pIndex->nKeyCol\n+  ){\n+    int ii;\n+    for(ii=0; ii<pLoop->u.btree.nEq; ii++){\n+      if( pLoop->aLTerm[ii]->eOperator & (WO_IS|WO_ISNULL) ){\n+        return 0;\n+      }\n+    }\n+    return 1;\n+  }\n+  return 0;\n+}\n+\n@@ -157706,1 +160057,2 @@\n-  VdbeModuleComment((v, \"Begin WHERE-loop%d: %s\",iLevel,pTabItem->pTab->zName));\n+  VdbeModuleComment((v, \"Begin WHERE-loop%d: %s\",\n+                     iLevel, pTabItem->pSTab->zName));\n@@ -157748,1 +160100,1 @@\n-    VdbeComment((v, \"init LEFT JOIN no-match flag\"));\n+    VdbeComment((v, \"init LEFT JOIN match flag\"));\n@@ -157761,2 +160113,6 @@\n-    int regYield = pTabItem->regReturn;\n-    sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, pTabItem->addrFillSub);\n+    int regYield;\n+    Subquery *pSubq;\n+    assert( pTabItem->fg.isSubquery && pTabItem->u4.pSubq!=0 );\n+    pSubq = pTabItem->u4.pSubq;\n+    regYield = pSubq->regReturn;\n+    sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, pSubq->addrFillSub);\n@@ -157765,1 +160121,1 @@\n-    VdbeComment((v, \"next row of %s\", pTabItem->pTab->zName));\n+    VdbeComment((v, \"next row of %s\", pTabItem->pSTab->zName));\n@@ -158417,1 +160773,3 @@\n-    if( pLoop->wsFlags & WHERE_ONEROW ){\n+    if( (pLoop->wsFlags & WHERE_ONEROW)\n+     || (pLevel->u.in.nIn && regBignull==0 && whereLoopIsOneRow(pLoop))\n+    ){\n@@ -158492,1 +160850,1 @@\n-    Table *pTab = pTabItem->pTab;\n+    Table *pTab = pTabItem->pSTab;\n@@ -158807,0 +161165,6 @@\n+  **\n+  ** This optimization of causing simple query restrictions to occur before\n+  ** more complex one is call the \"push-down\" optimization in MySQL.  Here\n+  ** in SQLite, the name is \"MySQL push-down\", since there is also another\n+  ** totally unrelated optimization called \"WHERE-clause push-down\".\n+  ** Sometimes the qualifier is omitted, resulting in an ambiguity, so beware.\n@@ -158945,1 +161309,1 @@\n-    pTab = pWInfo->pTabList->a[pLevel->iFrom].pTab;\n+    pTab = pWInfo->pTabList->a[pLevel->iFrom].pSTab;\n@@ -159052,1 +161416,1 @@\n-  ExplainQueryPlan((pParse, 1, \"RIGHT-JOIN %s\", pTabItem->pTab->zName));\n+  ExplainQueryPlan((pParse, 1, \"RIGHT-JOIN %s\", pTabItem->pSTab->zName));\n@@ -159057,0 +161421,3 @@\n+    SrcItem *pRight;\n+    assert( pWInfo->a[k].pWLoop->iTab == pWInfo->a[k].iFrom );\n+    pRight = &pWInfo->pTabList->a[pWInfo->a[k].iFrom];\n@@ -159058,0 +161425,10 @@\n+    if( pRight->fg.viaCoroutine ){\n+      Subquery *pSubq;\n+      assert( pRight->fg.isSubquery && pRight->u4.pSubq!=0 );\n+      pSubq = pRight->u4.pSubq;\n+      assert( pSubq->pSelect!=0 && pSubq->pSelect->pEList!=0 );\n+      sqlite3VdbeAddOp3(\n+          v, OP_Null, 0, pSubq->regResult,\n+          pSubq->regResult + pSubq->pSelect->pEList->nExpr-1\n+      );\n+    }\n@@ -159093,1 +161470,1 @@\n-    Table *pTab = pTabItem->pTab;\n+    Table *pTab = pTabItem->pSTab;\n@@ -159226,1 +161603,6 @@\n-  return op==TK_IN || (op>=TK_EQ && op<=TK_GE) || op==TK_ISNULL || op==TK_IS;\n+  assert( TK_IN<TK_EQ );\n+  assert( TK_IS<TK_EQ );\n+  assert( TK_ISNULL<TK_EQ );\n+  if( op>TK_GE ) return 0;\n+  if( op>=TK_EQ ) return 1;\n+  return op==TK_IN || op==TK_ISNULL || op==TK_IS;\n@@ -159259,1 +161641,4 @@\n-  if( op==TK_IN ){\n+  if( op>=TK_EQ ){\n+    assert( (WO_EQ<<(op-TK_EQ)) < 0x7fff );\n+    c = (u16)(WO_EQ<<(op-TK_EQ));\n+  }else if( op==TK_IN ){\n@@ -159263,2 +161648,0 @@\n-  }else if( op==TK_IS ){\n-    c = WO_IS;\n@@ -159266,2 +161649,2 @@\n-    assert( (WO_EQ<<(op-TK_EQ)) < 0x7fff );\n-    c = (u16)(WO_EQ<<(op-TK_EQ));\n+    assert( op==TK_IS );\n+    c = WO_IS;\n@@ -159338,2 +161721,6 @@\n-\n-    \/* Count the number of prefix characters prior to the first wildcard *\/\n+    \/* Count the number of prefix bytes prior to the first wildcard,\n+    ** U+fffd character, or malformed utf-8. If the underlying database\n+    ** has a UTF16LE encoding, then only consider ASCII characters.  Note that\n+    ** the encoding of z[] is UTF8 - we are dealing with only UTF8 here in this\n+    ** code, but the database engine itself might be processing content using a\n+    ** different encoding. *\/\n@@ -159343,1 +161730,13 @@\n-      if( c==wc[3] && z[cnt]!=0 ) cnt++;\n+      if( c==wc[3] && z[cnt]>0 && z[cnt]<0x80 ){\n+        cnt++;\n+      }else if( c>=0x80 ){\n+        const u8 *z2 = z+cnt-1;\n+        if( c==0xff || sqlite3Utf8Read(&z2)==0xfffd  \/* bad utf-8 *\/\n+         || ENC(db)==SQLITE_UTF16LE\n+        ){\n+          cnt--;\n+          break;\n+        }else{\n+          cnt = (int)(z2-z);\n+        }\n+      }\n@@ -159354,1 +161753,1 @@\n-    if( (cnt>1 || (cnt>0 && z[0]!=wc[3])) && 255!=(u8)z[cnt-1] ){\n+    if( (cnt>1 || (cnt>0 && z[0]!=wc[3])) && ALWAYS(255!=(u8)z[cnt-1]) ){\n@@ -159358,1 +161757,1 @@\n-      *pisComplete = c==wc[0] && z[cnt+1]==0;\n+      *pisComplete = c==wc[0] && z[cnt+1]==0 && ENC(db)!=SQLITE_UTF16LE;\n@@ -159554,0 +161953,7 @@\n+  }else if( pExpr->op>=TK_EQ ){\n+    \/* Comparison operators are a common case.  Save a few comparisons for\n+    ** that common case by terminating early. *\/\n+    assert( TK_NE < TK_EQ );\n+    assert( TK_ISNOT < TK_EQ );\n+    assert( TK_NOTNULL < TK_EQ );\n+    return 0;\n@@ -160070,1 +162476,3 @@\n-        mask |= exprSelectUsage(pMaskSet, pSrc->a[i].pSelect);\n+        if( pSrc->a[i].fg.isSubquery ){\n+          mask |= exprSelectUsage(pMaskSet, pSrc->a[i].u4.pSubq->pSelect);\n+        }\n@@ -160108,1 +162516,1 @@\n-    for(pIdx=pFrom->a[j].pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n+    for(pIdx=pFrom->a[j].pSTab->pIndex; pIdx; pIdx=pIdx->pNext){\n@@ -160114,1 +162522,1 @@\n-          && pExpr->op!=TK_STRING\n+         && !sqlite3ExprIsConstant(0,pIdx->aColExpr->a[i].pExpr)\n@@ -160152,1 +162560,1 @@\n-    for(pIdx=pFrom->a[i].pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n+    for(pIdx=pFrom->a[i].pSTab->pIndex; pIdx; pIdx=pIdx->pNext){\n@@ -160480,1 +162888,1 @@\n-      u8 c, *pC;       \/* Last character before the first wildcard *\/\n+      u8 *pC;       \/* Last character before the first wildcard *\/\n@@ -160482,1 +162890,0 @@\n-      c = *pC;\n@@ -160490,2 +162897,8 @@\n-        if( c=='A'-1 ) isComplete = 0;\n-        c = sqlite3UpperToLower[c];\n+        if( *pC=='A'-1 ) isComplete = 0;\n+        *pC = sqlite3UpperToLower[*pC];\n+      }\n+\n+      \/* Increment the value of the last utf8 character in the prefix. *\/\n+      while( *pC==0xBF && pC>(u8*)pStr2->u.zToken ){\n+        *pC = 0x80;\n+        pC--;\n@@ -160493,1 +162906,2 @@\n-      *pC = c + 1;\n+      assert( *pC!=0xFF );        \/* isLikeOrGlob() guarantees this *\/\n+      (*pC)++;\n@@ -160695,1 +163109,1 @@\n-  if( sqlite3ExprIsInteger(pExpr, &iVal) && iVal>=0 ){\n+  if( sqlite3ExprIsInteger(pExpr, &iVal, pParse) && iVal>=0 ){\n@@ -160740,1 +163154,1 @@\n-   && (p->pSrc->nSrc==1 && IsVirtual(p->pSrc->a[0].pTab))       \/* 3 *\/\n+   && (p->pSrc->nSrc==1 && IsVirtual(p->pSrc->a[0].pSTab))      \/* 3 *\/\n@@ -160763,0 +163177,1 @@\n+      if( pWC->a[ii].prereqRight!=0 ) return;\n@@ -160777,3 +163192,1 @@\n-    whereAddLimitExpr(pWC, p->iLimit, p->pLimit->pLeft,\n-                      iCsr, SQLITE_INDEX_CONSTRAINT_LIMIT);\n-    if( p->iOffset>0 ){\n+    if( p->iOffset!=0 && (p->selFlags & SF_Compound)==0 ){\n@@ -160783,0 +163196,4 @@\n+    if( p->iOffset==0 || (p->selFlags & SF_Compound)==0 ){\n+      whereAddLimitExpr(pWC, p->iLimit, p->pLimit->pLeft,\n+                        iCsr, SQLITE_INDEX_CONSTRAINT_LIMIT);\n+    }\n@@ -160958,1 +163375,1 @@\n-  pTab = pItem->pTab;\n+  pTab = pItem->pSTab;\n@@ -161300,0 +163717,36 @@\n+\/*\n+** Term pTerm is guaranteed to be a WO_IN term. It may be a component term\n+** of a vector IN expression of the form \"(x, y, ...) IN (SELECT ...)\".\n+** This function checks to see if the term is compatible with an index\n+** column with affinity idxaff (one of the SQLITE_AFF_XYZ values). If so,\n+** it returns a pointer to the name of the collation sequence (e.g. \"BINARY\"\n+** or \"NOCASE\") used by the comparison in pTerm. If it is not compatible\n+** with affinity idxaff, NULL is returned.\n+*\/\n+static SQLITE_NOINLINE const char *indexInAffinityOk(\n+  Parse *pParse,\n+  WhereTerm *pTerm,\n+  u8 idxaff\n+){\n+  Expr *pX = pTerm->pExpr;\n+  Expr inexpr;\n+\n+  assert( pTerm->eOperator & WO_IN );\n+\n+  if( sqlite3ExprIsVector(pX->pLeft) ){\n+    int iField = pTerm->u.x.iField - 1;\n+    inexpr.flags = 0;\n+    inexpr.op = TK_EQ;\n+    inexpr.pLeft = pX->pLeft->x.pList->a[iField].pExpr;\n+    assert( ExprUseXSelect(pX) );\n+    inexpr.pRight = pX->x.pSelect->pEList->a[iField].pExpr;\n+    pX = &inexpr;\n+  }\n+\n+  if( sqlite3IndexAffinityOk(pX, idxaff) ){\n+    CollSeq *pRet = sqlite3ExprCompareCollSeq(pParse, pX);\n+    return pRet ? pRet->zName : sqlite3StrBINARY;\n+  }\n+  return 0;\n+}\n+\n@@ -161350,1 +163803,1 @@\n-              CollSeq *pColl;\n+              const char *zCollName;\n@@ -161353,2 +163806,12 @@\n-              if( !sqlite3IndexAffinityOk(pX, pScan->idxaff) ){\n-                continue;\n+\n+              if( (pTerm->eOperator & WO_IN) ){\n+                zCollName = indexInAffinityOk(pParse, pTerm, pScan->idxaff);\n+                if( !zCollName ) continue;\n+              }else{\n+                CollSeq *pColl;\n+                if( !sqlite3IndexAffinityOk(pX, pScan->idxaff) ){\n+                  continue;\n+                }\n+                assert(pX->pLeft);\n+                pColl = sqlite3ExprCompareCollSeq(pParse, pX);\n+                zCollName = pColl ? pColl->zName : sqlite3StrBINARY;\n@@ -161356,4 +163819,2 @@\n-              assert(pX->pLeft);\n-              pColl = sqlite3ExprCompareCollSeq(pParse, pX);\n-              if( pColl==0 ) pColl = pParse->db->pDfltColl;\n-              if( sqlite3StrICmp(pColl->zName, pScan->zCollName) ){\n+\n+              if( sqlite3StrICmp(zCollName, pScan->zCollName) ){\n@@ -161598,1 +164059,1 @@\n-  pTab = pTabList->a[0].pTab;\n+  pTab = pTabList->a[0].pSTab;\n@@ -161673,0 +164134,6 @@\n+#ifdef SQLITE_DEBUG\n+  if( pParse->db->flags & SQLITE_VdbeAddopTrace ){\n+    printf(\"CHECKING for column-to-copy on cursor %d for %d..%d\\n\",\n+            iTabCur, iStart, iEnd);\n+  }\n+#endif\n@@ -161711,1 +164178,4 @@\n-static void whereTraceIndexInfoInputs(sqlite3_index_info *p){\n+static void whereTraceIndexInfoInputs(\n+  sqlite3_index_info *p,   \/* The IndexInfo object *\/\n+  Table *pTab              \/* The TABLE that is the virtual table *\/\n+){\n@@ -161714,0 +164184,1 @@\n+  sqlite3DebugPrintf(\"sqlite3_index_info inputs for %s:\\n\", pTab->zName);\n@@ -161731,1 +164202,4 @@\n-static void whereTraceIndexInfoOutputs(sqlite3_index_info *p){\n+static void whereTraceIndexInfoOutputs(\n+  sqlite3_index_info *p,   \/* The IndexInfo object *\/\n+  Table *pTab              \/* The TABLE that is the virtual table *\/\n+){\n@@ -161734,0 +164208,1 @@\n+  sqlite3DebugPrintf(\"sqlite3_index_info outputs for %s:\\n\", pTab->zName);\n@@ -161747,2 +164222,2 @@\n-#define whereTraceIndexInfoInputs(A)\n-#define whereTraceIndexInfoOutputs(A)\n+#define whereTraceIndexInfoInputs(A,B)\n+#define whereTraceIndexInfoOutputs(A,B)\n@@ -161779,1 +164254,1 @@\n-   && ExprHasProperty(pTerm->pExpr, EP_InnerON)\n+   && NEVER(ExprHasProperty(pTerm->pExpr, EP_InnerON))\n@@ -161786,0 +164261,39 @@\n+#ifndef SQLITE_OMIT_AUTOMATIC_INDEX\n+\/*\n+** Return true if column iCol of table pTab seem like it might be a\n+** good column to use as part of a query-time index.\n+**\n+** Current algorithm (subject to improvement!):\n+**\n+**   1.   If iCol is already the left-most column of some other index,\n+**        then return false.\n+**\n+**   2.   If iCol is part of an existing index that has an aiRowLogEst of\n+**        more than 20, then return false.\n+**\n+**   3.   If no disqualifying conditions above are found, return true.\n+**\n+** 2025-01-03: I experimented with a new rule that returns false if the\n+** the datatype of the column is \"BOOLEAN\". This did not improve\n+** performance on any queries at hand, but it did burn CPU cycles, so the\n+** idea was not committed.\n+*\/\n+static SQLITE_NOINLINE int columnIsGoodIndexCandidate(\n+  const Table *pTab,\n+  int iCol\n+){\n+  const Index *pIdx;\n+  for(pIdx = pTab->pIndex; pIdx!=0; pIdx=pIdx->pNext){\n+    int j;\n+    for(j=0; j<pIdx->nKeyCol; j++){\n+       if( pIdx->aiColumn[j]==iCol ){\n+         if( j==0 ) return 0;\n+         if( pIdx->hasStat1 && pIdx->aiRowLogEst[j+1]>20 ) return 0;\n+         break;\n+       }\n+    }\n+  }\n+  return 1;\n+}\n+#endif \/* SQLITE_OMIT_AUTOMATIC_INDEX *\/\n+\n@@ -161800,0 +164314,2 @@\n+  int leftCol;\n+\n@@ -161810,2 +164326,3 @@\n-  if( pTerm->u.x.leftColumn<0 ) return 0;\n-  aff = pSrc->pTab->aCol[pTerm->u.x.leftColumn].affinity;\n+  leftCol = pTerm->u.x.leftColumn;\n+  if( leftCol<0 ) return 0;\n+  aff = pSrc->pSTab->aCol[leftCol].affinity;\n@@ -161814,1 +164331,1 @@\n-  return 1;\n+  return columnIsGoodIndexCandidate(pSrc->pSTab, leftCol);\n@@ -161847,1 +164364,1 @@\n-    assert( pIdx->aiColumn[pIdx->nColumn-1]==XN_ROWID );\n+    assert( pIdx->aiColumn[pIdx->nColumn-1]==XN_ROWID || !HasRowid(pTab) );\n@@ -161922,1 +164439,1 @@\n-  pTable = pSrc->pTab;\n+  pTable = pSrc->pSTab;\n@@ -161932,1 +164449,1 @@\n-     && sqlite3ExprIsSingleTableConstraint(pExpr, pTabList, pLevel->iFrom)\n+     && sqlite3ExprIsSingleTableConstraint(pExpr, pTabList, pLevel->iFrom, 0)\n@@ -161974,1 +164491,1 @@\n-    extraCols = ALLBITS;\n+    extraCols = ALLBITS & ~idxCols;\n@@ -161978,0 +164495,13 @@\n+  if( !HasRowid(pTable) ){\n+    \/* For WITHOUT ROWID tables, ensure that all PRIMARY KEY columns are\n+    ** either in the idxCols mask or in the extraCols mask *\/\n+    for(i=0; i<pTable->nCol; i++){\n+      if( (pTable->aCol[i].colFlags & COLFLAG_PRIMKEY)==0 ) continue;\n+      if( i>=BMS-1 ){\n+        extraCols |= MASKBIT(BMS-1);\n+        break;\n+      }\n+      if( idxCols & MASKBIT(i) ) continue;\n+      extraCols |= MASKBIT(i);\n+    }\n+  }\n@@ -161989,1 +164519,2 @@\n-  pIdx = sqlite3AllocateIndexObject(pParse->db, nKeyCol+1, 0, &zNotUsed);\n+  pIdx = sqlite3AllocateIndexObject(pParse->db, nKeyCol+HasRowid(pTable),\n+                                    0, &zNotUsed);\n@@ -162045,2 +164576,4 @@\n-  pIdx->aiColumn[n] = XN_ROWID;\n-  pIdx->azColl[n] = sqlite3StrBINARY;\n+  if( HasRowid(pTable) ){\n+    pIdx->aiColumn[n] = XN_ROWID;\n+    pIdx->azColl[n] = sqlite3StrBINARY;\n+  }\n@@ -162064,1 +164597,6 @@\n-    int regYield = pSrc->regReturn;\n+    int regYield;\n+    Subquery *pSubq;\n+    assert( pSrc->fg.isSubquery );\n+    pSubq = pSrc->u4.pSubq;\n+    assert( pSubq!=0 );\n+    regYield = pSubq->regReturn;\n@@ -162066,1 +164604,1 @@\n-    sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, pSrc->addrFillSub);\n+    sqlite3VdbeAddOp3(v, OP_InitCoroutine, regYield, 0, pSubq->addrFillSub);\n@@ -162069,1 +164607,1 @@\n-    VdbeComment((v, \"next row of %s\", pSrc->pTab->zName));\n+    VdbeComment((v, \"next row of %s\", pSrc->pSTab->zName));\n@@ -162091,0 +164629,1 @@\n+    assert( pSrc->fg.isSubquery && pSrc->u4.pSubq!=0 );\n@@ -162095,1 +164634,1 @@\n-                          pSrc->regResult, pLevel->iIdxCur);\n+                          pSrc->u4.pSubq->regResult, pLevel->iIdxCur);\n@@ -162186,1 +164725,1 @@\n-    pTab = pItem->pTab;\n+    pTab = pItem->pSTab;\n@@ -162201,1 +164740,1 @@\n-       && sqlite3ExprIsSingleTableConstraint(pExpr, pTabList, iSrc)\n+       && sqlite3ExprIsSingleTableConstraint(pExpr, pTabList, iSrc, 0)\n@@ -162217,1 +164756,1 @@\n-        assert( pIdx->pTable==pItem->pTab );\n+        assert( pIdx->pTable==pItem->pSTab );\n@@ -162255,0 +164794,14 @@\n+\/*\n+** Return term iTerm of the WhereClause passed as the first argument. Terms\n+** are numbered from 0 upwards, starting with the terms in pWC->a[], then\n+** those in pWC->pOuter->a[] (if any), and so on.\n+*\/\n+static WhereTerm *termFromWhereClause(WhereClause *pWC, int iTerm){\n+  WhereClause *p;\n+  for(p=pWC; p; p=p->pOuter){\n+    if( iTerm<p->nTerm ) return &p->a[iTerm];\n+    iTerm -= p->nTerm;\n+  }\n+  return 0;\n+}\n+\n@@ -162281,0 +164834,1 @@\n+  WhereClause *p;\n@@ -162283,1 +164837,1 @@\n-  pTab = pSrc->pTab;\n+  pTab = pSrc->pSTab;\n@@ -162291,11 +164845,12 @@\n-  for(i=nTerm=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){\n-    pTerm->wtFlags &= ~TERM_OK;\n-    if( pTerm->leftCursor != pSrc->iCursor ) continue;\n-    if( pTerm->prereqRight & mUnusable ) continue;\n-    assert( IsPowerOfTwo(pTerm->eOperator & ~WO_EQUIV) );\n-    testcase( pTerm->eOperator & WO_IN );\n-    testcase( pTerm->eOperator & WO_ISNULL );\n-    testcase( pTerm->eOperator & WO_IS );\n-    testcase( pTerm->eOperator & WO_ALL );\n-    if( (pTerm->eOperator & ~(WO_EQUIV))==0 ) continue;\n-    if( pTerm->wtFlags & TERM_VNULL ) continue;\n+  for(p=pWC, nTerm=0; p; p=p->pOuter){\n+    for(i=0, pTerm=p->a; i<p->nTerm; i++, pTerm++){\n+      pTerm->wtFlags &= ~TERM_OK;\n+      if( pTerm->leftCursor != pSrc->iCursor ) continue;\n+      if( pTerm->prereqRight & mUnusable ) continue;\n+      assert( IsPowerOfTwo(pTerm->eOperator & ~WO_EQUIV) );\n+      testcase( pTerm->eOperator & WO_IN );\n+      testcase( pTerm->eOperator & WO_ISNULL );\n+      testcase( pTerm->eOperator & WO_IS );\n+      testcase( pTerm->eOperator & WO_ALL );\n+      if( (pTerm->eOperator & ~(WO_EQUIV))==0 ) continue;\n+      if( pTerm->wtFlags & TERM_VNULL ) continue;\n@@ -162303,7 +164858,10 @@\n-    assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );\n-    assert( pTerm->u.x.leftColumn>=XN_ROWID );\n-    assert( pTerm->u.x.leftColumn<pTab->nCol );\n-    if( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))!=0\n-     && !constraintCompatibleWithOuterJoin(pTerm,pSrc)\n-    ){\n-      continue;\n+      assert( (pTerm->eOperator & (WO_OR|WO_AND))==0 );\n+      assert( pTerm->u.x.leftColumn>=XN_ROWID );\n+      assert( pTerm->u.x.leftColumn<pTab->nCol );\n+      if( (pSrc->fg.jointype & (JT_LEFT|JT_LTORJ|JT_RIGHT))!=0\n+          && !constraintCompatibleWithOuterJoin(pTerm,pSrc)\n+        ){\n+        continue;\n+      }\n+      nTerm++;\n+      pTerm->wtFlags |= TERM_OK;\n@@ -162311,2 +164869,0 @@\n-    nTerm++;\n-    pTerm->wtFlags |= TERM_OK;\n@@ -162327,1 +164883,1 @@\n-      if( sqlite3ExprIsConstant(pExpr) ){\n+      if( sqlite3ExprIsConstant(0, pExpr) ){\n@@ -162362,1 +164918,1 @@\n-      if( (pWInfo->wctrlFlags & WHERE_DISTINCTBY) ){\n+      if( (pWInfo->wctrlFlags & WHERE_DISTINCTBY) && !pSrc->fg.rowidUsed ){\n@@ -162387,0 +164943,13 @@\n+  pIdxInfo->colUsed = (sqlite3_int64)pSrc->colUsed;\n+  if( HasRowid(pTab)==0 ){\n+    \/* Ensure that all bits associated with PK columns are set. This is to\n+    ** ensure they are available for cases like RIGHT joins or OR loops. *\/\n+    Index *pPk = sqlite3PrimaryKeyIndex((Table*)pTab);\n+    assert( pPk!=0 );\n+    for(i=0; i<pPk->nKeyCol; i++){\n+      int iCol = pPk->aiColumn[i];\n+      assert( iCol>=0 );\n+      if( iCol>=BMS-1 ) iCol = BMS-1;\n+      pIdxInfo->colUsed |= MASKBIT(iCol);\n+    }\n+  }\n@@ -162391,39 +164960,42 @@\n-  for(i=j=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){\n-    u16 op;\n-    if( (pTerm->wtFlags & TERM_OK)==0 ) continue;\n-    pIdxCons[j].iColumn = pTerm->u.x.leftColumn;\n-    pIdxCons[j].iTermOffset = i;\n-    op = pTerm->eOperator & WO_ALL;\n-    if( op==WO_IN ){\n-      if( (pTerm->wtFlags & TERM_SLICE)==0 ){\n-        pHidden->mIn |= SMASKBIT32(j);\n-      }\n-      op = WO_EQ;\n-    }\n-    if( op==WO_AUX ){\n-      pIdxCons[j].op = pTerm->eMatchOp;\n-    }else if( op & (WO_ISNULL|WO_IS) ){\n-      if( op==WO_ISNULL ){\n-        pIdxCons[j].op = SQLITE_INDEX_CONSTRAINT_ISNULL;\n-      }else{\n-        pIdxCons[j].op = SQLITE_INDEX_CONSTRAINT_IS;\n-      }\n-    }else{\n-      pIdxCons[j].op = (u8)op;\n-      \/* The direct assignment in the previous line is possible only because\n-      ** the WO_ and SQLITE_INDEX_CONSTRAINT_ codes are identical.  The\n-      ** following asserts verify this fact. *\/\n-      assert( WO_EQ==SQLITE_INDEX_CONSTRAINT_EQ );\n-      assert( WO_LT==SQLITE_INDEX_CONSTRAINT_LT );\n-      assert( WO_LE==SQLITE_INDEX_CONSTRAINT_LE );\n-      assert( WO_GT==SQLITE_INDEX_CONSTRAINT_GT );\n-      assert( WO_GE==SQLITE_INDEX_CONSTRAINT_GE );\n-      assert( pTerm->eOperator&(WO_IN|WO_EQ|WO_LT|WO_LE|WO_GT|WO_GE|WO_AUX) );\n-\n-      if( op & (WO_LT|WO_LE|WO_GT|WO_GE)\n-       && sqlite3ExprIsVector(pTerm->pExpr->pRight)\n-      ){\n-        testcase( j!=i );\n-        if( j<16 ) mNoOmit |= (1 << j);\n-        if( op==WO_LT ) pIdxCons[j].op = WO_LE;\n-        if( op==WO_GT ) pIdxCons[j].op = WO_GE;\n+  for(p=pWC, i=j=0; p; p=p->pOuter){\n+    int nLast = i+p->nTerm;;\n+    for(pTerm=p->a; i<nLast; i++, pTerm++){\n+      u16 op;\n+      if( (pTerm->wtFlags & TERM_OK)==0 ) continue;\n+      pIdxCons[j].iColumn = pTerm->u.x.leftColumn;\n+      pIdxCons[j].iTermOffset = i;\n+      op = pTerm->eOperator & WO_ALL;\n+      if( op==WO_IN ){\n+        if( (pTerm->wtFlags & TERM_SLICE)==0 ){\n+          pHidden->mIn |= SMASKBIT32(j);\n+        }\n+        op = WO_EQ;\n+      }\n+      if( op==WO_AUX ){\n+        pIdxCons[j].op = pTerm->eMatchOp;\n+      }else if( op & (WO_ISNULL|WO_IS) ){\n+        if( op==WO_ISNULL ){\n+          pIdxCons[j].op = SQLITE_INDEX_CONSTRAINT_ISNULL;\n+        }else{\n+          pIdxCons[j].op = SQLITE_INDEX_CONSTRAINT_IS;\n+        }\n+      }else{\n+        pIdxCons[j].op = (u8)op;\n+        \/* The direct assignment in the previous line is possible only because\n+        ** the WO_ and SQLITE_INDEX_CONSTRAINT_ codes are identical.  The\n+        ** following asserts verify this fact. *\/\n+        assert( WO_EQ==SQLITE_INDEX_CONSTRAINT_EQ );\n+        assert( WO_LT==SQLITE_INDEX_CONSTRAINT_LT );\n+        assert( WO_LE==SQLITE_INDEX_CONSTRAINT_LE );\n+        assert( WO_GT==SQLITE_INDEX_CONSTRAINT_GT );\n+        assert( WO_GE==SQLITE_INDEX_CONSTRAINT_GE );\n+        assert( pTerm->eOperator&(WO_IN|WO_EQ|WO_LT|WO_LE|WO_GT|WO_GE|WO_AUX) );\n+\n+        if( op & (WO_LT|WO_LE|WO_GT|WO_GE)\n+            && sqlite3ExprIsVector(pTerm->pExpr->pRight)\n+          ){\n+          testcase( j!=i );\n+          if( j<16 ) mNoOmit |= (1 << j);\n+          if( op==WO_LT ) pIdxCons[j].op = WO_LE;\n+          if( op==WO_GT ) pIdxCons[j].op = WO_GE;\n+        }\n@@ -162431,1 +165003,0 @@\n-    }\n@@ -162433,1 +165004,2 @@\n-    j++;\n+      j++;\n+    }\n@@ -162439,1 +165011,1 @@\n-    if( sqlite3ExprIsConstant(pExpr) ) continue;\n+    if( sqlite3ExprIsConstant(0, pExpr) ) continue;\n@@ -162453,0 +165025,11 @@\n+\/*\n+** Free and zero the sqlite3_index_info.idxStr value if needed.\n+*\/\n+static void freeIdxStr(sqlite3_index_info *pIdxInfo){\n+  if( pIdxInfo->needToFreeIdxStr ){\n+    sqlite3_free(pIdxInfo->idxStr);\n+    pIdxInfo->idxStr = 0;\n+    pIdxInfo->needToFreeIdxStr = 0;\n+  }\n+}\n+\n@@ -162468,0 +165051,1 @@\n+  freeIdxStr(pIdxInfo);\n@@ -162488,1 +165072,0 @@\n-  sqlite3_vtab *pVtab = sqlite3GetVTable(pParse->db, pTab)->pVtab;\n@@ -162490,0 +165073,1 @@\n+  sqlite3_vtab *pVtab;\n@@ -162491,1 +165075,3 @@\n-  whereTraceIndexInfoInputs(p);\n+  assert( IsVirtual(pTab) );\n+  pVtab = sqlite3GetVTable(pParse->db, pTab)->pVtab;\n+  whereTraceIndexInfoInputs(p, pTab);\n@@ -162495,1 +165081,1 @@\n-  whereTraceIndexInfoOutputs(p);\n+  whereTraceIndexInfoOutputs(p, pTab);\n@@ -163182,1 +165768,1 @@\n-#ifdef WHERETRACE_ENABLED\n+#if defined(WHERETRACE_ENABLED) || defined(SQLITE_DEBUG)\n@@ -163226,0 +165812,3 @@\n+SQLITE_PRIVATE void sqlite3ShowWhereTerm(WhereTerm *pTerm){\n+  sqlite3WhereTermPrint(pTerm, 0);\n+}\n@@ -163257,0 +165846,1 @@\n+  WhereInfo *pWInfo;\n@@ -163258,1 +165848,1 @@\n-    WhereInfo *pWInfo = pWC->pWInfo;\n+    pWInfo = pWC->pWInfo;\n@@ -163261,1 +165851,1 @@\n-    Table *pTab = pItem->pTab;\n+    Table *pTab = pItem->pSTab;\n@@ -163268,0 +165858,1 @@\n+    pWInfo = 0;\n@@ -163299,1 +165890,6 @@\n-  sqlite3DebugPrintf(\" cost %d,%d,%d\\n\", p->rSetup, p->rRun, p->nOut);\n+  if( pWInfo && pWInfo->bStarUsed && p->rStarDelta!=0 ){\n+    sqlite3DebugPrintf(\" cost %d,%d,%d delta=%d\\n\",\n+                       p->rSetup, p->rRun, p->nOut, p->rStarDelta);\n+  }else{\n+    sqlite3DebugPrintf(\" cost %d,%d,%d\\n\", p->rSetup, p->rRun, p->nOut);\n+  }\n@@ -163433,1 +166029,1 @@\n-** In other words, return true if the cost relationwship between X and Y\n+** In other words, return true if the cost relationship between X and Y\n@@ -163819,1 +166415,1 @@\n-          if( sqlite3ExprIsInteger(pRight, &k) && k>=(-1) && k<=1 ){\n+          if( sqlite3ExprIsInteger(pRight, &k, 0) && k>=(-1) && k<=1 ){\n@@ -163973,1 +166569,3 @@\n-    if( pProbe->bLowQual )   opMask &= ~(WO_EQ|WO_IN|WO_IS);\n+    if( pProbe->bLowQual && pSrc->fg.isIndexedBy==0 ){\n+      opMask &= ~(WO_EQ|WO_IN|WO_IS);\n+    }\n@@ -164114,1 +166712,1 @@\n-         || (pProbe->nKeyCol==1 && pProbe->onError && eOp==WO_EQ)\n+         || (pProbe->nKeyCol==1 && pProbe->onError && (eOp & WO_EQ))\n@@ -164240,5 +166838,8 @@\n-    \/* Set rCostIdx to the cost of visiting selected rows in index. Add\n-    ** it to pNew->rRun, which is currently set to the cost of the index\n-    ** seek only. Then, if this is a non-covering index, add the cost of\n-    ** visiting the rows in the main table.  *\/\n-    assert( pSrc->pTab->szTabRow>0 );\n+    \/* Set rCostIdx to the estimated cost of visiting selected rows in the\n+    ** index.  The estimate is the sum of two values:\n+    **   1.  The cost of doing one search-by-key to find the first matching\n+    **       entry\n+    **   2.  Stepping forward in the index pNew->nOut times to find all\n+    **       additional matching entries.\n+    *\/\n+    assert( pSrc->pSTab->szTabRow>0 );\n@@ -164252,1 +166853,1 @@\n-      rCostIdx = pNew->nOut + 1 + (15*pProbe->szIdxRow)\/pSrc->pTab->szTabRow;\n+      rCostIdx = pNew->nOut + 1 + (15*pProbe->szIdxRow)\/pSrc->pSTab->szTabRow;\n@@ -164254,1 +166855,9 @@\n-    pNew->rRun = sqlite3LogEstAdd(rLogSize, rCostIdx);\n+    rCostIdx = sqlite3LogEstAdd(rLogSize, rCostIdx);\n+\n+    \/* Estimate the cost of running the loop.  If all data is coming\n+    ** from the index, then this is just the cost of doing the index\n+    ** lookup and scan.  But if some data is coming out of the main table,\n+    ** we also have to add in the cost of doing pNew->nOut searches to\n+    ** locate the row in the main table that corresponds to the index entry.\n+    *\/\n+    pNew->rRun = rCostIdx;\n@@ -164360,1 +166969,3 @@\n-    if( pExpr->op==TK_COLUMN && pExpr->iTable==iCursor ){\n+    if( (pExpr->op==TK_COLUMN || pExpr->op==TK_AGG_COLUMN)\n+     && pExpr->iTable==iCursor\n+    ){\n@@ -164396,1 +167007,0 @@\n-  if( pParse->db->flags & SQLITE_EnableQPSG ) pParse = 0;\n@@ -164617,1 +167227,1 @@\n-    if( !sqlite3ExprIsConstant(pRight) ) return;\n+    if( !sqlite3ExprIsConstant(0, pRight) ) return;\n@@ -164707,1 +167317,1 @@\n-  pTab = pSrc->pTab;\n+  pTab = pSrc->pSTab;\n@@ -164709,1 +167319,1 @@\n-  assert( !IsVirtual(pSrc->pTab) );\n+  assert( !IsVirtual(pSrc->pSTab) );\n@@ -164734,1 +167344,1 @@\n-    pFirst = pSrc->pTab->pIndex;\n+    pFirst = pSrc->pSTab->pIndex;\n@@ -164751,1 +167361,0 @@\n-   && HasRowid(pTab)         \/* Not WITHOUT ROWID table. (FIXME: Why not?) *\/\n@@ -164824,0 +167433,1 @@\n+    pNew->u.btree.pOrderBy = 0;\n@@ -164853,0 +167463,4 @@\n+      if( pSrc->fg.isSubquery ){\n+        if( pSrc->fg.viaCoroutine ) pNew->wsFlags |= WHERE_COROUTINE;\n+        pNew->u.btree.pOrderBy = pSrc->u4.pSubq->pSelect->pOrderBy;\n+      }\n@@ -164890,1 +167504,3 @@\n-        }else if( m==0 ){\n+        }else if( m==0\n+           && (HasRowid(pTab) || pWInfo->pSelect!=0 || sqlite3FaultSim(700))\n+        ){\n@@ -164966,1 +167582,1 @@\n-      pTab->tabFlags |= TF_StatsUsed;\n+      pTab->tabFlags |= TF_MaybeReanalyze;\n@@ -164988,0 +167604,15 @@\n+\/*\n+** Return true if the first nCons constraints in the pUsage array are\n+** marked as in-use (have argvIndex>0). False otherwise.\n+*\/\n+static int allConstraintsUsed(\n+  struct sqlite3_index_constraint_usage *aUsage,\n+  int nCons\n+){\n+  int ii;\n+  for(ii=0; ii<nCons; ii++){\n+    if( aUsage[ii].argvIndex<=0 ) return 0;\n+  }\n+  return 1;\n+}\n+\n@@ -165038,1 +167669,1 @@\n-    WhereTerm *pTerm = &pWC->a[pIdxCons->iTermOffset];\n+    WhereTerm *pTerm = termFromWhereClause(pWC, pIdxCons->iTermOffset);\n@@ -165057,1 +167688,0 @@\n-  pIdxInfo->colUsed = (sqlite3_int64)pSrc->colUsed;\n@@ -165061,1 +167691,1 @@\n-  rc = vtabBestIndex(pParse, pSrc->pTab, pIdxInfo);\n+  rc = vtabBestIndex(pParse, pSrc->pSTab, pIdxInfo);\n@@ -165069,0 +167699,1 @@\n+      freeIdxStr(pIdxInfo);\n@@ -165086,1 +167717,1 @@\n-       || j>=pWC->nTerm\n+       || (pTerm = termFromWhereClause(pWC, j))==0\n@@ -165090,2 +167721,2 @@\n-        sqlite3ErrorMsg(pParse,\"%s.xBestIndex malfunction\",pSrc->pTab->zName);\n-        testcase( pIdxInfo->needToFreeIdxStr );\n+        sqlite3ErrorMsg(pParse,\"%s.xBestIndex malfunction\",pSrc->pSTab->zName);\n+        freeIdxStr(pIdxInfo);\n@@ -165097,1 +167728,0 @@\n-      pTerm = &pWC->a[j];\n@@ -165128,0 +167758,2 @@\n+      \/* Unless pbRetryLimit is non-NULL, there should be no LIMIT\/OFFSET\n+      ** terms. And if there are any, they should follow all other terms. *\/\n@@ -165129,1 +167761,4 @@\n-      if( isLimitTerm(pTerm) && *pbIn ){\n+      assert( !isLimitTerm(pTerm) || i>=nConstraint-2 );\n+      assert( !isLimitTerm(pTerm) || i==nConstraint-1 || isLimitTerm(pTerm+1) );\n+\n+      if( isLimitTerm(pTerm) && (*pbIn || !allConstraintsUsed(pUsage, i)) ){\n@@ -165132,8 +167767,6 @@\n-        ** OFFSET term handled as well, the plan is unusable. Set output\n-        ** variable *pbRetryLimit to true to tell the caller to retry with\n-        ** LIMIT and OFFSET disabled. *\/\n-        if( pIdxInfo->needToFreeIdxStr ){\n-          sqlite3_free(pIdxInfo->idxStr);\n-          pIdxInfo->idxStr = 0;\n-          pIdxInfo->needToFreeIdxStr = 0;\n-        }\n+        ** OFFSET term handled as well, the plan is unusable. Similarly,\n+        ** if there is a LIMIT\/OFFSET and there are other unused terms,\n+        ** the plan cannot be used. In these cases set variable *pbRetryLimit\n+        ** to true to tell the caller to retry with LIMIT and OFFSET\n+        ** disabled. *\/\n+        freeIdxStr(pIdxInfo);\n@@ -165151,2 +167784,2 @@\n-      sqlite3ErrorMsg(pParse,\"%s.xBestIndex malfunction\",pSrc->pTab->zName);\n-      testcase( pIdxInfo->needToFreeIdxStr );\n+      sqlite3ErrorMsg(pParse,\"%s.xBestIndex malfunction\",pSrc->pSTab->zName);\n+      freeIdxStr(pIdxInfo);\n@@ -165163,0 +167796,1 @@\n+  pNew->u.vtab.bIdxNumHex = (pIdxInfo->idxFlags&SQLITE_INDEX_SCAN_HEX)!=0;\n@@ -165207,1 +167841,1 @@\n-    Expr *pX = pHidden->pWC->a[iTerm].pExpr;\n+    Expr *pX = termFromWhereClause(pHidden->pWC, iTerm)->pExpr;\n@@ -165253,1 +167887,3 @@\n-      WhereTerm *pTerm = &pH->pWC->a[pIdxInfo->aConstraint[iCons].iTermOffset];\n+      WhereTerm *pTerm = termFromWhereClause(\n+          pH->pWC, pIdxInfo->aConstraint[iCons].iTermOffset\n+      );\n@@ -165351,1 +167987,1 @@\n-  assert( IsVirtual(pSrc->pTab) );\n+  assert( IsVirtual(pSrc->pSTab) );\n@@ -165365,1 +168001,1 @@\n-  WHERETRACE(0x800, (\"BEGIN %s.addVirtual()\\n\", pSrc->pTab->zName));\n+  WHERETRACE(0x800, (\"BEGIN %s.addVirtual()\\n\", pSrc->pSTab->zName));\n@@ -165409,3 +168045,2 @@\n-        Bitmask mThis = (\n-            pWC->a[p->aConstraint[i].iTermOffset].prereqRight & ~mPrereq\n-        );\n+        int iTerm = p->aConstraint[i].iTermOffset;\n+        Bitmask mThis = termFromWhereClause(pWC, iTerm)->prereqRight & ~mPrereq;\n@@ -165447,1 +168082,0 @@\n-  if( p->needToFreeIdxStr ) sqlite3_free(p->idxStr);\n@@ -165449,1 +168083,1 @@\n-  WHERETRACE(0x800, (\"END %s.addVirtual(), rc=%d\\n\", pSrc->pTab->zName, rc));\n+  WHERETRACE(0x800, (\"END %s.addVirtual(), rc=%d\\n\", pSrc->pSTab->zName, rc));\n@@ -165521,1 +168155,1 @@\n-        if( IsVirtual(pItem->pTab) ){\n+        if( IsVirtual(pItem->pSTab) ){\n@@ -165635,1 +168269,1 @@\n-    if( IsVirtual(pItem->pTab) ){\n+    if( IsVirtual(pItem->pSTab) ){\n@@ -165667,0 +168301,91 @@\n+\/* Implementation of the order-by-subquery optimization:\n+**\n+** WhereLoop pLoop, which the iLoop-th term of the nested loop, is really\n+** a subquery or CTE that has an ORDER BY clause.  See if any of the terms\n+** in the subquery ORDER BY clause will satisfy pOrderBy from the outer\n+** query.  Mark off all satisfied terms (by setting bits in *pOBSat) and\n+** return TRUE if they do.  If not, return false.\n+**\n+** Example:\n+**\n+**    CREATE TABLE t1(a,b,c, PRIMARY KEY(a,b));\n+**    CREATE TABLE t2(x,y);\n+**    WITH t3(p,q) AS MATERIALIZED (SELECT x+y, x-y FROM t2 ORDER BY x+y)\n+**       SELECT * FROM t3 JOIN t1 ON a=q ORDER BY p, b;\n+**\n+** The CTE named \"t3\" comes out in the natural order of \"p\", so the first\n+** first them of \"ORDER BY p,b\" is satisfied by a sequential scan of \"t3\"\n+** and sorting only needs to occur on the second term \"b\".\n+**\n+** Limitations:\n+**\n+** (1)  The optimization is not applied if the outer ORDER BY contains\n+**      a COLLATE clause.  The optimization might be applied if the\n+**      outer ORDER BY uses NULLS FIRST, NULLS LAST, ASC, and\/or DESC as\n+**      long as the subquery ORDER BY does the same.  But if the\n+**      outer ORDER BY uses COLLATE, even a redundant COLLATE, the\n+**      optimization is bypassed.\n+**\n+** (2)  The subquery ORDER BY terms must exactly match subquery result\n+**      columns, including any COLLATE annotations.  This routine relies\n+**      on iOrderByCol to do matching between order by terms and result\n+**      columns, and iOrderByCol will not be set if the result column\n+**      and ORDER BY collations differ.\n+**\n+** (3)  The subquery and outer ORDER BY can be in opposite directions as\n+**      long as  the subquery is materialized.  If the subquery is\n+**      implemented as a co-routine, the sort orders must be in the same\n+**      direction because there is no way to run a co-routine backwards.\n+*\/\n+static SQLITE_NOINLINE int wherePathMatchSubqueryOB(\n+  WhereInfo *pWInfo,      \/* The WHERE clause *\/\n+  WhereLoop *pLoop,       \/* The nested loop term that is a subquery *\/\n+  int iLoop,              \/* Which level of the nested loop.  0==outermost *\/\n+  int iCur,               \/* Cursor used by the this loop *\/\n+  ExprList *pOrderBy,     \/* The ORDER BY clause on the whole query *\/\n+  Bitmask *pRevMask,      \/* When loops need to go in reverse order *\/\n+  Bitmask *pOBSat         \/* Which terms of pOrderBy are satisfied so far *\/\n+){\n+  int iOB;                \/* Index into pOrderBy->a[] *\/\n+  int jSub;               \/* Index into pSubOB->a[] *\/\n+  u8 rev = 0;             \/* True if iOB and jSub sort in opposite directions *\/\n+  u8 revIdx = 0;          \/* Sort direction for jSub *\/\n+  Expr *pOBExpr;          \/* Current term of outer ORDER BY *\/\n+  ExprList *pSubOB;       \/* Complete ORDER BY on the subquery *\/\n+\n+  pSubOB = pLoop->u.btree.pOrderBy;\n+  assert( pSubOB!=0 );\n+  for(iOB=0; (MASKBIT(iOB) & *pOBSat)!=0; iOB++){}\n+  for(jSub=0; jSub<pSubOB->nExpr && iOB<pOrderBy->nExpr; jSub++, iOB++){\n+    if( pSubOB->a[jSub].u.x.iOrderByCol==0 ) break;\n+    pOBExpr = pOrderBy->a[iOB].pExpr;\n+    if( pOBExpr->op!=TK_COLUMN && pOBExpr->op!=TK_AGG_COLUMN ) break;\n+    if( pOBExpr->iTable!=iCur ) break;\n+    if( pOBExpr->iColumn!=pSubOB->a[jSub].u.x.iOrderByCol-1 ) break;\n+    if( (pWInfo->wctrlFlags & WHERE_GROUPBY)==0 ){\n+      u8 sfOB = pOrderBy->a[iOB].fg.sortFlags;   \/* sortFlags for iOB *\/\n+      u8 sfSub = pSubOB->a[jSub].fg.sortFlags;   \/* sortFlags for jSub *\/\n+      if( (sfSub & KEYINFO_ORDER_BIGNULL) != (sfOB & KEYINFO_ORDER_BIGNULL) ){\n+        break;\n+      }\n+      revIdx = sfSub & KEYINFO_ORDER_DESC;\n+      if( jSub>0 ){\n+        if( (rev^revIdx)!=(sfOB & KEYINFO_ORDER_DESC) ){\n+          break;\n+        }\n+      }else{\n+        rev = revIdx ^ (sfOB & KEYINFO_ORDER_DESC);\n+        if( rev ){\n+          if( (pLoop->wsFlags & WHERE_COROUTINE)!=0 ){\n+            \/* Cannot run a co-routine in reverse order *\/\n+            break;\n+          }\n+          *pRevMask |= MASKBIT(iLoop);\n+        }\n+      }\n+    }\n+    *pOBSat |= MASKBIT(iOB);\n+  }\n+  return jSub>0;\n+}\n+\n@@ -165812,0 +168537,10 @@\n+        if( pLoop->u.btree.pOrderBy\n+         && OptimizationEnabled(db, SQLITE_OrderBySubq)\n+         &&  wherePathMatchSubqueryOB(pWInfo,pLoop,iLoop,iCur,\n+                                     pOrderBy,pRevMask, &obSat)\n+        ){\n+          nColumn = 0;\n+          isOrderDistinct = 0;\n+        }else{\n+          nColumn = 1;\n+        }\n@@ -165814,1 +168549,0 @@\n-        nColumn = 1;\n@@ -165824,1 +168558,1 @@\n-        ** for isOrderDistinct to be true.  So the isOrderDistint value\n+        ** for isOrderDistinct to be true.  So the isOrderDistinct value\n@@ -165909,1 +168643,1 @@\n-        ** of the index and mark that ORDER BY term off\n+        ** of the index and mark that ORDER BY term having been satisfied.\n@@ -165991,1 +168725,1 @@\n-        if( mTerm==0 && !sqlite3ExprIsConstant(p) ) continue;\n+        if( mTerm==0 && !sqlite3ExprIsConstant(0,p) ) continue;\n@@ -166116,0 +168850,210 @@\n+\/*\n+** Compute the maximum number of paths in the solver algorithm, for\n+** queries that have three or more terms in the FROM clause.  Queries with\n+** two or fewer FROM clause terms are handled by the caller.\n+**\n+** Query planning is NP-hard.  We must limit the number of paths at\n+** each step of the solver search algorithm to avoid exponential behavior.\n+**\n+** The value returned is a tuning parameter.  Currently the value is:\n+**\n+**     18    for star queries\n+**     12    otherwise\n+**\n+** For the purposes of this heuristic, a star-query is defined as a query\n+** with a large central table that is joined using an INNER JOIN,\n+** not CROSS or OUTER JOINs, against four or more smaller tables.\n+** The central table is called the \"fact\" table.  The smaller tables\n+** that get joined are \"dimension tables\".  Also, any table that is\n+** self-joined cannot be a dimension table; we assume that dimension\n+** tables may only be joined against fact tables.\n+**\n+** SIDE EFFECT:  (and really the whole point of this subroutine)\n+**\n+** If pWInfo describes a star-query, then the cost for SCANs of dimension\n+** WhereLoops is increased to be slightly larger than the cost of a SCAN\n+** in the fact table.  Only SCAN costs are increased.  SEARCH costs are\n+** unchanged. This heuristic helps keep fact tables in outer loops. Without\n+** this heuristic, paths with fact tables in outer loops tend to get pruned\n+** by the mxChoice limit on the number of paths, resulting in poor query\n+** plans.  See the starschema1.test test module for examples of queries\n+** that need this heuristic to find good query plans.\n+**\n+** This heuristic can be completely disabled, so that no query is\n+** considered a star-query, using SQLITE_TESTCTRL_OPTIMIZATION to\n+** disable the SQLITE_StarQuery optimization.  In the CLI, the command\n+** to do that is:  \".testctrl opt -starquery\".\n+**\n+** HISTORICAL NOTES:\n+**\n+** This optimization was first added on 2024-05-09 by check-in 38db9b5c83d.\n+** The original optimization reduced the cost and output size estimate for\n+** fact tables to help them move to outer loops.  But months later (as people\n+** started upgrading) performance regression reports started caming in,\n+** including:\n+**\n+**    forum post b18ef983e68d06d1 (2024-12-21)\n+**    forum post 0025389d0860af82 (2025-01-14)\n+**    forum post d87570a145599033 (2025-01-17)\n+**\n+** To address these, the criteria for a star-query was tightened to exclude\n+** cases where the fact and dimensions are separated by an outer join, and\n+** the affect of star-schema detection was changed to increase the rRun cost\n+** on just full table scans of dimension tables, rather than reducing costs\n+** in the all access methods of the fact table.\n+*\/\n+static int computeMxChoice(WhereInfo *pWInfo){\n+  int nLoop = pWInfo->nLevel;    \/* Number of terms in the join *\/\n+  WhereLoop *pWLoop;             \/* For looping over WhereLoops *\/\n+\n+#ifdef SQLITE_DEBUG\n+  \/* The star-query detection code below makes use of the following\n+  ** properties of the WhereLoop list, so verify them before\n+  ** continuing:\n+  **    (1)  .maskSelf is the bitmask corresponding to .iTab\n+  **    (2)  The WhereLoop list is in ascending .iTab order\n+  *\/\n+  for(pWLoop=pWInfo->pLoops; pWLoop; pWLoop=pWLoop->pNextLoop){\n+    assert( pWLoop->maskSelf==MASKBIT(pWLoop->iTab) );\n+    assert( pWLoop->pNextLoop==0 || pWLoop->iTab<=pWLoop->pNextLoop->iTab );\n+  }\n+#endif \/* SQLITE_DEBUG *\/\n+\n+  if( nLoop>=5\n+   && !pWInfo->bStarDone\n+   && OptimizationEnabled(pWInfo->pParse->db, SQLITE_StarQuery)\n+  ){\n+    SrcItem *aFromTabs;    \/* All terms of the FROM clause *\/\n+    int iFromIdx;          \/* Term of FROM clause is the candidate fact-table *\/\n+    Bitmask m;             \/* Bitmask for candidate fact-table *\/\n+    Bitmask mSelfJoin = 0; \/* Tables that cannot be dimension tables *\/\n+    WhereLoop *pStart;     \/* Where to start searching for dimension-tables *\/\n+\n+    pWInfo->bStarDone = 1; \/* Only do this computation once *\/\n+\n+    \/* Look for fact tables with four or more dimensions where the\n+    ** dimension tables are not separately from the fact tables by an outer\n+    ** or cross join.  Adjust cost weights if found.\n+    *\/\n+    assert( !pWInfo->bStarUsed );\n+    aFromTabs = pWInfo->pTabList->a;\n+    pStart = pWInfo->pLoops;\n+    for(iFromIdx=0, m=1; iFromIdx<nLoop; iFromIdx++, m<<=1){\n+      int nDep = 0;             \/* Number of dimension tables *\/\n+      LogEst mxRun;             \/* Maximum SCAN cost of a fact table *\/\n+      Bitmask mSeen = 0;        \/* Mask of dimension tables *\/\n+      SrcItem *pFactTab;        \/* The candidate fact table *\/\n+\n+      pFactTab = aFromTabs + iFromIdx;\n+      if( (pFactTab->fg.jointype & (JT_OUTER|JT_CROSS))!=0 ){\n+        \/* If the candidate fact-table is the right table of an outer join\n+        ** restrict the search for dimension-tables to be tables to the right\n+        ** of the fact-table. *\/\n+        if( iFromIdx+4 > nLoop ) break;  \/* Impossible to reach nDep>=4 *\/\n+        while( pStart && pStart->iTab<=iFromIdx ){\n+          pStart = pStart->pNextLoop;\n+        }\n+      }\n+      for(pWLoop=pStart; pWLoop; pWLoop=pWLoop->pNextLoop){\n+        if( (aFromTabs[pWLoop->iTab].fg.jointype & (JT_OUTER|JT_CROSS))!=0 ){\n+          \/* Fact-tables and dimension-tables cannot be separated by an\n+          ** outer join (at least for the definition of fact- and dimension-\n+          ** used by this heuristic). *\/\n+          break;\n+        }\n+        if( (pWLoop->prereq & m)!=0        \/* pWInfo depends on iFromIdx *\/\n+         && (pWLoop->maskSelf & mSeen)==0  \/* pWInfo not already a dependency *\/\n+         && (pWLoop->maskSelf & mSelfJoin)==0 \/* Not a self-join *\/\n+        ){\n+          if( aFromTabs[pWLoop->iTab].pSTab==pFactTab->pSTab ){\n+            mSelfJoin |= m;\n+          }else{\n+            nDep++;\n+            mSeen |= pWLoop->maskSelf;\n+          }\n+        }\n+      }\n+      if( nDep<=3 ) continue;\n+\n+      \/* If we reach this point, it means that pFactTab is a fact table\n+      ** with four or more dimensions connected by inner joins.  Proceed\n+      ** to make cost adjustments. *\/\n+\n+#ifdef WHERETRACE_ENABLED\n+      \/* Make sure rStarDelta values are initialized *\/\n+      if( !pWInfo->bStarUsed ){\n+        for(pWLoop=pWInfo->pLoops; pWLoop; pWLoop=pWLoop->pNextLoop){\n+          pWLoop->rStarDelta = 0;\n+        }\n+      }\n+#endif\n+      pWInfo->bStarUsed = 1;\n+\n+      \/* Compute the maximum cost of any WhereLoop for the\n+      ** fact table plus one epsilon *\/\n+      mxRun = LOGEST_MIN;\n+      for(pWLoop=pStart; pWLoop; pWLoop=pWLoop->pNextLoop){\n+        if( pWLoop->iTab<iFromIdx ) continue;\n+        if( pWLoop->iTab>iFromIdx ) break;\n+        if( pWLoop->rRun>mxRun ) mxRun = pWLoop->rRun;\n+      }\n+      if( ALWAYS(mxRun<LOGEST_MAX) ) mxRun++;\n+\n+      \/* Increase the cost of table scans for dimension tables to be\n+      ** slightly more than the maximum cost of the fact table *\/\n+      for(pWLoop=pStart; pWLoop; pWLoop=pWLoop->pNextLoop){\n+        if( (pWLoop->maskSelf & mSeen)==0 ) continue;\n+        if( pWLoop->nLTerm ) continue;\n+        if( pWLoop->rRun<mxRun ){\n+#ifdef WHERETRACE_ENABLED \/* 0x80000 *\/\n+          if( sqlite3WhereTrace & 0x80000 ){\n+            SrcItem *pDim = aFromTabs + pWLoop->iTab;\n+            sqlite3DebugPrintf(\n+              \"Increase SCAN cost of dimension %s(%d) of fact %s(%d) to %d\\n\",\n+              pDim->zAlias ? pDim->zAlias: pDim->pSTab->zName, pWLoop->iTab,\n+              pFactTab->zAlias ? pFactTab->zAlias : pFactTab->pSTab->zName,\n+              iFromIdx, mxRun\n+            );\n+          }\n+          pWLoop->rStarDelta = mxRun - pWLoop->rRun;\n+#endif \/* WHERETRACE_ENABLED *\/\n+          pWLoop->rRun = mxRun;\n+        }\n+      }\n+    }\n+#ifdef WHERETRACE_ENABLED \/* 0x80000 *\/\n+    if( (sqlite3WhereTrace & 0x80000)!=0 && pWInfo->bStarUsed ){\n+      sqlite3DebugPrintf(\"WhereLoops changed by star-query heuristic:\\n\");\n+      for(pWLoop=pWInfo->pLoops; pWLoop; pWLoop=pWLoop->pNextLoop){\n+        if( pWLoop->rStarDelta ){\n+          sqlite3WhereLoopPrint(pWLoop, &pWInfo->sWC);\n+        }\n+      }\n+    }\n+#endif\n+  }\n+  return pWInfo->bStarUsed ? 18 : 12;\n+}\n+\n+\/*\n+** Two WhereLoop objects, pCandidate and pBaseline, are known to have the\n+** same cost.  Look deep into each to see if pCandidate is even slightly\n+** better than pBaseline.  Return false if it is, if pCandidate is is preferred.\n+** Return true if pBaseline is preferred or if we cannot tell the difference.\n+**\n+**    Result       Meaning\n+**    --------     ----------------------------------------------------------\n+**    true         We cannot tell the difference in pCandidate and pBaseline\n+**    false        pCandidate seems like a better choice than pBaseline\n+*\/\n+static SQLITE_NOINLINE int whereLoopIsNoBetter(\n+  const WhereLoop *pCandidate,\n+  const WhereLoop *pBaseline\n+){\n+  if( (pCandidate->wsFlags & WHERE_INDEXED)==0 ) return 1;\n+  if( (pBaseline->wsFlags & WHERE_INDEXED)==0 ) return 1;\n+  if( pCandidate->u.btree.pIndex->szIdxRow <\n+        pBaseline->u.btree.pIndex->szIdxRow ) return 0;\n+  return 1;\n+}\n+\n@@ -166137,1 +169081,1 @@\n-  LogEst mxUnsorted = 0;    \/* Maximum unsorted cost of a set of path *\/\n+  LogEst mxUnsort = 0;      \/* Maximum unsorted cost of a set of path *\/\n@@ -166151,5 +169095,0 @@\n-  \/* TUNING: For simple queries, only the best path is tracked.\n-  ** For 2-way joins, the 5 best paths are followed.\n-  ** For joins of 3 or more tables, track the 10 best paths *\/\n-  mxChoice = (nLoop<=1) ? 1 : (nLoop==2 ? 5 : 10);\n-  assert( nLoop<=pWInfo->pTabList->nSrc );\n@@ -166158,0 +169097,19 @@\n+  \/* TUNING: mxChoice is the maximum number of possible paths to preserve\n+  ** at each step.  Based on the number of loops in the FROM clause:\n+  **\n+  **     nLoop      mxChoice\n+  **     -----      --------\n+  **       1            1            \/\/ the most common case\n+  **       2            5\n+  **       3+        12 or 18        \/\/ see computeMxChoice()\n+  *\/\n+  if( nLoop<=1 ){\n+    mxChoice = 1;\n+  }else if( nLoop==2 ){\n+    mxChoice = 5;\n+  }else if( pParse->nErr ){\n+    mxChoice = 1;\n+  }else{\n+    mxChoice = computeMxChoice(pWInfo);\n+  }\n+  assert( nLoop<=pWInfo->pTabList->nSrc );\n@@ -166222,1 +169180,1 @@\n-        LogEst rUnsorted;                 \/* Unsorted cost of (pFrom+pWLoop) *\/\n+        LogEst rUnsort;                   \/* Unsorted cost of (pFrom+pWLoop) *\/\n@@ -166240,2 +169198,5 @@\n-        rUnsorted = sqlite3LogEstAdd(pWLoop->rSetup,pWLoop->rRun + pFrom->nRow);\n-        rUnsorted = sqlite3LogEstAdd(rUnsorted, pFrom->rUnsorted);\n+        rUnsort = pWLoop->rRun + pFrom->nRow;\n+        if( pWLoop->rSetup ){\n+          rUnsort = sqlite3LogEstAdd(pWLoop->rSetup, rUnsort);\n+        }\n+        rUnsort = sqlite3LogEstAdd(rUnsort, pFrom->rUnsort);\n@@ -166263,1 +169224,1 @@\n-          rCost = sqlite3LogEstAdd(rUnsorted, aSortCost[isOrdered]) + 3;\n+          rCost = sqlite3LogEstAdd(rUnsort, aSortCost[isOrdered]) + 3;\n@@ -166268,1 +169229,1 @@\n-               rUnsorted, rCost));\n+               rUnsort, rCost));\n@@ -166270,2 +169231,2 @@\n-          rCost = rUnsorted;\n-          rUnsorted -= 2;  \/* TUNING:  Slight bias in favor of no-sort plans *\/\n+          rCost = rUnsort;\n+          rUnsort -= 2;  \/* TUNING:  Slight bias in favor of no-sort plans *\/\n@@ -166285,0 +169246,1 @@\n+        testcase( nTo==0 );\n@@ -166296,1 +169258,1 @@\n-           && (rCost>mxCost || (rCost==mxCost && rUnsorted>=mxUnsorted))\n+           && (rCost>mxCost || (rCost==mxCost && rUnsort>=mxUnsort))\n@@ -166304,1 +169266,1 @@\n-                  wherePathName(pFrom, iLoop, pWLoop), rCost, nOut, rUnsorted,\n+                  wherePathName(pFrom, iLoop, pWLoop), rCost, nOut, rUnsort,\n@@ -166323,1 +169285,1 @@\n-                wherePathName(pFrom, iLoop, pWLoop), rCost, nOut, rUnsorted,\n+                wherePathName(pFrom, iLoop, pWLoop), rCost, nOut, rUnsort,\n@@ -166334,1 +169296,1 @@\n-          **   (pTo->rCost,pTo->nRow,pTo->rUnsorted) <= (rCost,nOut,rUnsorted)\n+          **   (pTo->rCost,pTo->nRow,pTo->rUnsort) <= (rCost,nOut,rUnsort)\n@@ -166336,6 +169298,5 @@\n-          if( pTo->rCost<rCost\n-           || (pTo->rCost==rCost\n-               && (pTo->nRow<nOut\n-                   || (pTo->nRow==nOut && pTo->rUnsorted<=rUnsorted)\n-                  )\n-              )\n+          if( (pTo->rCost<rCost)\n+           || (pTo->rCost==rCost && pTo->nRow<nOut)\n+           || (pTo->rCost==rCost && pTo->nRow==nOut && pTo->rUnsort<rUnsort)\n+           || (pTo->rCost==rCost && pTo->nRow==nOut && pTo->rUnsort==rUnsort\n+                  && whereLoopIsNoBetter(pWLoop, pTo->aLoop[iLoop]) )\n@@ -166347,1 +169308,1 @@\n-                  wherePathName(pFrom, iLoop, pWLoop), rCost, nOut, rUnsorted,\n+                  wherePathName(pFrom, iLoop, pWLoop), rCost, nOut, rUnsort,\n@@ -166351,1 +169312,1 @@\n-                  pTo->rUnsorted, pTo->isOrdered>=0 ? pTo->isOrdered+'0' : '?');\n+                  pTo->rUnsort, pTo->isOrdered>=0 ? pTo->isOrdered+'0' : '?');\n@@ -166365,1 +169326,1 @@\n-                wherePathName(pFrom, iLoop, pWLoop), rCost, nOut, rUnsorted,\n+                wherePathName(pFrom, iLoop, pWLoop), rCost, nOut, rUnsort,\n@@ -166369,1 +169330,1 @@\n-                pTo->rUnsorted, pTo->isOrdered>=0 ? pTo->isOrdered+'0' : '?');\n+                pTo->rUnsort, pTo->isOrdered>=0 ? pTo->isOrdered+'0' : '?');\n@@ -166378,1 +169339,1 @@\n-        pTo->rUnsorted = rUnsorted;\n+        pTo->rUnsort = rUnsort;\n@@ -166385,1 +169346,1 @@\n-          mxUnsorted = aTo[0].nRow;\n+          mxUnsort = aTo[0].nRow;\n@@ -166388,1 +169349,1 @@\n-             || (pTo->rCost==mxCost && pTo->rUnsorted>mxUnsorted)\n+             || (pTo->rCost==mxCost && pTo->rUnsort>mxUnsort)\n@@ -166391,1 +169352,1 @@\n-              mxUnsorted = pTo->rUnsorted;\n+              mxUnsort = pTo->rUnsort;\n@@ -166401,0 +169362,3 @@\n+      LogEst rMin, rFloor = 0;\n+      int nDone = 0;\n+      int nProgress;\n@@ -166402,8 +169366,19 @@\n-      for(ii=0, pTo=aTo; ii<nTo; ii++, pTo++){\n-        sqlite3DebugPrintf(\" %s cost=%-3d nrow=%-3d order=%c\",\n-           wherePathName(pTo, iLoop+1, 0), pTo->rCost, pTo->nRow,\n-           pTo->isOrdered>=0 ? (pTo->isOrdered+'0') : '?');\n-        if( pTo->isOrdered>0 ){\n-          sqlite3DebugPrintf(\" rev=0x%llx\\n\", pTo->revLoop);\n-        }else{\n-          sqlite3DebugPrintf(\"\\n\");\n+      do{\n+        nProgress = 0;\n+        rMin = 0x7fff;\n+        for(ii=0, pTo=aTo; ii<nTo; ii++, pTo++){\n+          if( pTo->rCost>rFloor && pTo->rCost<rMin ) rMin = pTo->rCost;\n+        }\n+        for(ii=0, pTo=aTo; ii<nTo; ii++, pTo++){\n+          if( pTo->rCost==rMin ){\n+            sqlite3DebugPrintf(\" %s cost=%-3d nrow=%-3d order=%c\",\n+               wherePathName(pTo, iLoop+1, 0), pTo->rCost, pTo->nRow,\n+               pTo->isOrdered>=0 ? (pTo->isOrdered+'0') : '?');\n+            if( pTo->isOrdered>0 ){\n+              sqlite3DebugPrintf(\" rev=0x%llx\\n\", pTo->revLoop);\n+            }else{\n+              sqlite3DebugPrintf(\"\\n\");\n+            }\n+            nDone++;\n+            nProgress++;\n+          }\n@@ -166411,1 +169386,2 @@\n-      }\n+        rFloor = rMin;\n+      }while( nDone<nTo && nProgress>0 );\n@@ -166460,4 +169436,3 @@\n-      if( pWInfo->pSelect->pOrderBy\n-       && pWInfo->nOBSat > pWInfo->pSelect->pOrderBy->nExpr ){\n-        pWInfo->nOBSat = pWInfo->pSelect->pOrderBy->nExpr;\n-      }\n+      \/* vvv--- See check-in [12ad822d9b827777] on 2023-03-16 ---vvv *\/\n+      assert( pWInfo->pSelect->pOrderBy==0\n+           || pWInfo->nOBSat <= pWInfo->pSelect->pOrderBy->nExpr );\n@@ -166506,1 +169481,0 @@\n-\n@@ -166508,0 +169482,3 @@\n+#ifdef WHERETRACE_ENABLED\n+  pWInfo->rTotalCost = pFrom->rCost;\n+#endif\n@@ -166514,0 +169491,77 @@\n+\/*\n+** This routine implements a heuristic designed to improve query planning.\n+** This routine is called in between the first and second call to\n+** wherePathSolver().  Hence the name \"Interstage\" \"Heuristic\".\n+**\n+** The first call to wherePathSolver() (hereafter just \"solver()\") computes\n+** the best path without regard to the order of the outputs.  The second call\n+** to the solver() builds upon the first call to try to find an alternative\n+** path that satisfies the ORDER BY clause.\n+**\n+** This routine looks at the results of the first solver() run, and for\n+** every FROM clause term in the resulting query plan that uses an equality\n+** constraint against an index, disable other WhereLoops for that same\n+** FROM clause term that would try to do a full-table scan.  This prevents\n+** an index search from being converted into a full-table scan in order to\n+** satisfy an ORDER BY clause, since even though we might get slightly better\n+** performance using the full-scan without sorting if the output size\n+** estimates are very precise, we might also get severe performance\n+** degradation using the full-scan if the output size estimate is too large.\n+** It is better to err on the side of caution.\n+**\n+** Except, if the first solver() call generated a full-table scan in an outer\n+** loop then stop this analysis at the first full-scan, since the second\n+** solver() run might try to swap that full-scan for another in order to\n+** get the output into the correct order.  In other words, we allow a\n+** rewrite like this:\n+**\n+**     First Solver()                      Second Solver()\n+**       |-- SCAN t1                         |-- SCAN t2\n+**       |-- SEARCH t2                       `-- SEARCH t1\n+**       `-- SORT USING B-TREE\n+**\n+** The purpose of this routine is to disallow rewrites such as:\n+**\n+**     First Solver()                      Second Solver()\n+**       |-- SEARCH t1                       |-- SCAN t2     <--- bad!\n+**       |-- SEARCH t2                       `-- SEARCH t1\n+**       `-- SORT USING B-TREE\n+**\n+** See test cases in test\/whereN.test for the real-world query that\n+** originally provoked this heuristic.\n+*\/\n+static SQLITE_NOINLINE void whereInterstageHeuristic(WhereInfo *pWInfo){\n+  int i;\n+#ifdef WHERETRACE_ENABLED\n+  int once = 0;\n+#endif\n+  for(i=0; i<pWInfo->nLevel; i++){\n+    WhereLoop *p = pWInfo->a[i].pWLoop;\n+    if( p==0 ) break;\n+    if( (p->wsFlags & WHERE_VIRTUALTABLE)!=0 ) continue;\n+    if( (p->wsFlags & (WHERE_COLUMN_EQ|WHERE_COLUMN_NULL|WHERE_COLUMN_IN))!=0 ){\n+      u8 iTab = p->iTab;\n+      WhereLoop *pLoop;\n+      for(pLoop=pWInfo->pLoops; pLoop; pLoop=pLoop->pNextLoop){\n+        if( pLoop->iTab!=iTab ) continue;\n+        if( (pLoop->wsFlags & (WHERE_CONSTRAINT|WHERE_AUTO_INDEX))!=0 ){\n+          \/* Auto-index and index-constrained loops allowed to remain *\/\n+          continue;\n+        }\n+#ifdef WHERETRACE_ENABLED\n+        if( sqlite3WhereTrace & 0x80 ){\n+          if( once==0 ){\n+            sqlite3DebugPrintf(\"Loops disabled by interstage heuristic:\\n\");\n+            once = 1;\n+          }\n+          sqlite3WhereLoopPrint(pLoop, &pWInfo->sWC);\n+        }\n+#endif \/* WHERETRACE_ENABLED *\/\n+        pLoop->prereq = ALLBITS;  \/* Prevent 2nd solver() from using this one *\/\n+      }\n+    }else{\n+      break;\n+    }\n+  }\n+}\n+\n@@ -166541,1 +169595,1 @@\n-  pTab = pItem->pTab;\n+  pTab = pItem->pSTab;\n@@ -166682,0 +169736,4 @@\n+**   6) The ORDER BY clause has 63 or fewer terms\n+**   7) The omit-noop-join optimization is enabled.\n+**\n+** Items (1), (6), and (7) are checked by the caller.\n@@ -166727,0 +169785,1 @@\n+    Bitmask m1;\n@@ -166747,1 +169806,1 @@\n-       && pTerm->pExpr->w.iJoin==pItem->iCursor\n+       && NEVER(pTerm->pExpr->w.iJoin==pItem->iCursor)\n@@ -166753,1 +169812,4 @@\n-    WHERETRACE(0xffffffff, (\"-> drop loop %c not used\\n\", pLoop->cId));\n+    WHERETRACE(0xffffffff,(\"-> omit unused FROM-clause term %c\\n\",pLoop->cId));\n+    m1 = MASKBIT(i)-1;\n+    testcase( ((pWInfo->revMask>>1) & ~m1)!=0 );\n+    pWInfo->revMask = (m1 & pWInfo->revMask) | ((pWInfo->revMask>>1) & ~m1);\n@@ -166800,1 +169862,1 @@\n-    Table *pTab = pItem->pTab;\n+    Table *pTab = pItem->pSTab;\n@@ -166802,1 +169864,1 @@\n-    pTab->tabFlags |= TF_StatsUsed;\n+    pTab->tabFlags |= TF_MaybeReanalyze;\n@@ -166855,15 +169917,1 @@\n-    if( sqlite3ExprIsConstant(pExpr) ) continue;\n-    if( pExpr->op==TK_FUNCTION ){\n-      \/* Functions that might set a subtype should not be replaced by the\n-      ** value taken from an expression index since the index omits the\n-      ** subtype.  https:\/\/sqlite.org\/forum\/forumpost\/68d284c86b082c3e *\/\n-      int n;\n-      FuncDef *pDef;\n-      sqlite3 *db = pParse->db;\n-      assert( ExprUseXList(pExpr) );\n-      n = pExpr->x.pList ? pExpr->x.pList->nExpr : 0;\n-      pDef = sqlite3FindFunction(db, pExpr->u.zToken, n, ENC(db), 0);\n-      if( pDef==0 || (pDef->funcFlags & SQLITE_RESULT_SUBTYPE)!=0 ){\n-        continue;\n-      }\n-    }\n+    if( sqlite3ExprIsConstant(0,pExpr) ) continue;\n@@ -166912,2 +169960,2 @@\n-     || NEVER(pItem->pSelect==0)\n-     || pItem->pSelect->pOrderBy==0\n+     || NEVER(pItem->fg.isSubquery==0)\n+     || pItem->u4.pSubq->pSelect->pOrderBy==0\n@@ -167051,0 +170099,1 @@\n+    wctrlFlags |= WHERE_KEEP_ALL_JOINS; \/* Disable omit-noop-join opt *\/\n@@ -167133,1 +170182,5 @@\n-    ExplainQueryPlan((pParse, 0, \"SCAN CONSTANT ROW\"));\n+    if( ALWAYS(pWInfo->pSelect)\n+     && (pWInfo->pSelect->selFlags & SF_MultiValue)==0\n+    ){\n+      ExplainQueryPlan((pParse, 0, \"SCAN CONSTANT ROW\"));\n+    }\n@@ -167286,1 +170339,2 @@\n-       wherePathSolver(pWInfo, pWInfo->nRowOut+1);\n+       whereInterstageHeuristic(pWInfo);\n+       wherePathSolver(pWInfo, pWInfo->nRowOut<0 ? 1 : pWInfo->nRowOut+1);\n@@ -167310,1 +170364,2 @@\n-    sqlite3DebugPrintf(\"---- Solution nRow=%d\", pWInfo->nRowOut);\n+    sqlite3DebugPrintf(\"---- Solution cost=%d, nRow=%d\",\n+                       pWInfo->rTotalCost, pWInfo->nRowOut);\n@@ -167346,4 +170401,4 @@\n-  if( pWInfo->nLevel>=2\n-   && pResultSet!=0                         \/* these two combine to guarantee *\/\n-   && 0==(wctrlFlags & WHERE_AGG_DISTINCT)  \/* condition (1) above *\/\n-   && OptimizationEnabled(db, SQLITE_OmitNoopJoin)\n+  if( pWInfo->nLevel>=2       \/* Must be a join, or this opt8n is pointless *\/\n+   && pResultSet!=0           \/* Condition (1) *\/\n+   && 0==(wctrlFlags & (WHERE_AGG_DISTINCT|WHERE_KEEP_ALL_JOINS)) \/* (1),(6) *\/\n+   && OptimizationEnabled(db, SQLITE_OmitNoopJoin)                \/* (7) *\/\n@@ -167397,1 +170452,1 @@\n-    assert( !(wsFlags & WHERE_VIRTUALTABLE) || IsVirtual(pTabList->a[0].pTab) );\n+    assert( !(wsFlags&WHERE_VIRTUALTABLE) || IsVirtual(pTabList->a[0].pSTab) );\n@@ -167400,1 +170455,1 @@\n-     && !IsVirtual(pTabList->a[0].pTab)\n+     && !IsVirtual(pTabList->a[0].pSTab)\n@@ -167405,1 +170460,1 @@\n-      if( HasRowid(pTabList->a[0].pTab) && (wsFlags & WHERE_IDX_ONLY) ){\n+      if( HasRowid(pTabList->a[0].pSTab) && (wsFlags & WHERE_IDX_ONLY) ){\n@@ -167423,1 +170478,1 @@\n-    pTab = pTabItem->pTab;\n+    pTab = pTabItem->pSTab;\n@@ -167494,1 +170549,1 @@\n-        Index *pJ = pTabItem->pTab->pIndex;\n+        Index *pJ = pTabItem->pSTab->pIndex;\n@@ -167561,1 +170616,1 @@\n-      assert( pTab==pTabItem->pTab );\n+      assert( pTab==pTabItem->pSTab );\n@@ -167600,2 +170655,6 @@\n-      if( pSrc->fg.isCorrelated ){\n-        sqlite3VdbeAddOp2(v, OP_Gosub, pSrc->regReturn, pSrc->addrFillSub);\n+      Subquery *pSubq;\n+      int iOnce = 0;\n+      assert( pSrc->fg.isSubquery );\n+      pSubq = pSrc->u4.pSubq;\n+      if( pSrc->fg.isCorrelated==0 ){\n+        iOnce = sqlite3VdbeAddOp0(v, OP_Once); VdbeCoverage(v);\n@@ -167603,3 +170662,1 @@\n-        int iOnce = sqlite3VdbeAddOp0(v, OP_Once);  VdbeCoverage(v);\n-        sqlite3VdbeAddOp2(v, OP_Gosub, pSrc->regReturn, pSrc->addrFillSub);\n-        sqlite3VdbeJumpHere(v, iOnce);\n+        iOnce = 0;\n@@ -167607,0 +170664,3 @@\n+      sqlite3VdbeAddOp2(v, OP_Gosub, pSubq->regReturn, pSubq->addrFillSub);\n+      VdbeComment((v, \"materialize %!S\", pSrc));\n+      if( iOnce )  sqlite3VdbeJumpHere(v, iOnce);\n@@ -167666,0 +170726,1 @@\n+    sqlite3ShowWhereTerm(0); \/* So compiler won't complain about unused func *\/\n@@ -167669,20 +170730,0 @@\n-#ifdef SQLITE_DEBUG\n-\/*\n-** Return true if cursor iCur is opened by instruction k of the\n-** bytecode.  Used inside of assert() only.\n-*\/\n-static int cursorIsOpen(Vdbe *v, int iCur, int k){\n-  while( k>=0 ){\n-    VdbeOp *pOp = sqlite3VdbeGetOp(v,k--);\n-    if( pOp->p1!=iCur ) continue;\n-    if( pOp->opcode==OP_Close ) return 0;\n-    if( pOp->opcode==OP_OpenRead ) return 1;\n-    if( pOp->opcode==OP_OpenWrite ) return 1;\n-    if( pOp->opcode==OP_OpenDup ) return 1;\n-    if( pOp->opcode==OP_OpenAutoindex ) return 1;\n-    if( pOp->opcode==OP_OpenEphemeral ) return 1;\n-  }\n-  return 0;\n-}\n-#endif \/* SQLITE_DEBUG *\/\n-\n@@ -167835,1 +170876,10 @@\n-        assert( pLevel->iTabCur==pTabList->a[pLevel->iFrom].iCursor );\n+        SrcItem *pSrc = &pTabList->a[pLevel->iFrom];\n+        assert( pLevel->iTabCur==pSrc->iCursor );\n+        if( pSrc->fg.viaCoroutine ){\n+          int m, n;\n+          assert( pSrc->fg.isSubquery );\n+          n = pSrc->u4.pSubq->regResult;\n+          assert( pSrc->pSTab!=0 );\n+          m = pSrc->pSTab->nCol;\n+          sqlite3VdbeAddOp3(v, OP_Null, 0, n, n+m-1);\n+        }\n@@ -167857,1 +170907,1 @@\n-                     pWInfo->pTabList->a[pLevel->iFrom].pTab->zName));\n+                     pWInfo->pTabList->a[pLevel->iFrom].pSTab->zName));\n@@ -167866,1 +170916,1 @@\n-    Table *pTab = pTabItem->pTab;\n+    Table *pTab = pTabItem->pSTab;\n@@ -167885,0 +170935,2 @@\n+      assert( pTabItem->fg.isSubquery );\n+      assert( pTabItem->u4.pSubq->regResult>=0 );\n@@ -167886,1 +170938,1 @@\n-                            pTabItem->regResult, 0);\n+                            pTabItem->u4.pSubq->regResult, 0);\n@@ -167974,15 +171026,23 @@\n-          }else{\n-            \/* Unable to translate the table reference into an index\n-            ** reference.  Verify that this is harmless - that the\n-            ** table being referenced really is open.\n-            *\/\n-#ifdef SQLITE_ENABLE_OFFSET_SQL_FUNC\n-            assert( (pLoop->wsFlags & WHERE_IDX_ONLY)==0\n-                 || cursorIsOpen(v,pOp->p1,k)\n-                 || pOp->opcode==OP_Offset\n-            );\n-#else\n-            assert( (pLoop->wsFlags & WHERE_IDX_ONLY)==0\n-                 || cursorIsOpen(v,pOp->p1,k)\n-            );\n-#endif\n+          }else if( pLoop->wsFlags & (WHERE_IDX_ONLY|WHERE_EXPRIDX) ){\n+            if( pLoop->wsFlags & WHERE_IDX_ONLY ){\n+              \/* An error. pLoop is supposed to be a covering index loop,\n+              ** and yet the VM code refers to a column of the table that\n+              ** is not part of the index.  *\/\n+              sqlite3ErrorMsg(pParse, \"internal query planner error\");\n+              pParse->rc = SQLITE_INTERNAL;\n+            }else{\n+              \/* The WHERE_EXPRIDX flag is set by the planner when it is likely\n+              ** that pLoop is a covering index loop, but it is not possible\n+              ** to be 100% sure. In this case, any OP_Explain opcode\n+              ** corresponding to this loop describes the index as a \"COVERING\n+              ** INDEX\". But, pOp proves that pLoop is not actually a covering\n+              ** index loop. So clear the WHERE_EXPRIDX flag and rewrite the\n+              ** text that accompanies the OP_Explain opcode, if any.  *\/\n+              pLoop->wsFlags &= ~WHERE_EXPRIDX;\n+              sqlite3WhereAddExplainText(pParse,\n+                  pLevel->addrBody-1,\n+                  pTabList,\n+                  pLevel,\n+                  pWInfo->wctrlFlags\n+              );\n+            }\n@@ -168934,1 +171994,1 @@\n-        if( sqlite3ExprIsInteger(pSub, &iDummy) ){\n+        if( sqlite3ExprIsInteger(pSub, &iDummy, 0) ){\n@@ -169102,1 +172162,3 @@\n-    if( p->pSrc ){\n+    if( p->pSrc==0 ){\n+      sqlite3SelectDelete(db, pSub);\n+    }else if( sqlite3SrcItemAttachSubquery(pParse, &p->pSrc->a[0], pSub, 0) ){\n@@ -169104,1 +172166,0 @@\n-      p->pSrc->a[0].pSelect = pSub;\n@@ -169118,1 +172179,1 @@\n-        p->pSrc->a[0].pTab = pTab;\n+        p->pSrc->a[0].pSTab = pTab;\n@@ -169126,2 +172187,0 @@\n-    }else{\n-      sqlite3SelectDelete(db, pSub);\n@@ -169189,1 +172248,1 @@\n-  if( 0==sqlite3ExprIsConstant(pExpr) ){\n+  if( 0==sqlite3ExprIsConstant(0,pExpr) ){\n@@ -169414,2 +172473,0 @@\n-  int nEphExpr = pSelect->pSrc->a[0].pSelect->pEList->nExpr;\n-  Window *pMWin = pSelect->pWin;\n@@ -169417,1 +172474,8 @@\n-  Vdbe *v = sqlite3GetVdbe(pParse);\n+  int nEphExpr;\n+  Window *pMWin;\n+  Vdbe *v;\n+\n+  assert( pSelect->pSrc->a[0].fg.isSubquery );\n+  nEphExpr = pSelect->pSrc->a[0].u4.pSubq->pSelect->pEList->nExpr;\n+  pMWin = pSelect->pWin;\n+  v = sqlite3GetVdbe(pParse);\n@@ -169691,0 +172755,1 @@\n+    int addrIf = 0;\n@@ -169707,0 +172772,12 @@\n+    if( pWin->pFilter ){\n+      int regTmp;\n+      assert( ExprUseXList(pWin->pOwner) );\n+      assert( pWin->bExprArgs || !nArg ||nArg==pWin->pOwner->x.pList->nExpr );\n+      assert( pWin->bExprArgs || nArg  ||pWin->pOwner->x.pList==0 );\n+      regTmp = sqlite3GetTempReg(pParse);\n+      sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol+nArg,regTmp);\n+      addrIf = sqlite3VdbeAddOp3(v, OP_IfNot, regTmp, 0, 1);\n+      VdbeCoverage(v);\n+      sqlite3ReleaseTempReg(pParse, regTmp);\n+    }\n+\n@@ -169726,0 +172803,1 @@\n+      assert( pWin->pFilter==0 );\n@@ -169732,13 +172810,0 @@\n-      int addrIf = 0;\n-      if( pWin->pFilter ){\n-        int regTmp;\n-        assert( ExprUseXList(pWin->pOwner) );\n-        assert( pWin->bExprArgs || !nArg ||nArg==pWin->pOwner->x.pList->nExpr );\n-        assert( pWin->bExprArgs || nArg  ||pWin->pOwner->x.pList==0 );\n-        regTmp = sqlite3GetTempReg(pParse);\n-        sqlite3VdbeAddOp3(v, OP_Column, csr, pWin->iArgCol+nArg,regTmp);\n-        addrIf = sqlite3VdbeAddOp3(v, OP_IfNot, regTmp, 0, 1);\n-        VdbeCoverage(v);\n-        sqlite3ReleaseTempReg(pParse, regTmp);\n-      }\n-\n@@ -169771,1 +172836,1 @@\n-      sqlite3VdbeChangeP5(v, (u8)nArg);\n+      sqlite3VdbeChangeP5(v, (u16)nArg);\n@@ -169775,1 +172840,0 @@\n-      if( addrIf ) sqlite3VdbeJumpHere(v, addrIf);\n@@ -169777,0 +172841,2 @@\n+\n+    if( addrIf ) sqlite3VdbeJumpHere(v, addrIf);\n@@ -170814,1 +173880,1 @@\n-  int nInput = p->pSrc->a[0].pTab->nCol;    \/* Number of cols returned by sub *\/\n+  int nInput = p->pSrc->a[0].pSTab->nCol;   \/* Number of cols returned by sub *\/\n@@ -171203,0 +174269,7 @@\n+\/*\n+** Generate a syntax error\n+*\/\n+static void parserSyntaxError(Parse *pParse, Token *p){\n+  sqlite3ErrorMsg(pParse, \"near \\\"%T\\\": syntax error\", p);\n+}\n+\n@@ -171259,3 +174332,3 @@\n-      if( (p->selFlags & SF_MultiValue)==0 &&\n-        (mxSelect = pParse->db->aLimit[SQLITE_LIMIT_COMPOUND_SELECT])>0 &&\n-        cnt>mxSelect\n+      if( (p->selFlags & (SF_MultiValue|SF_Values))==0\n+       && (mxSelect = pParse->db->aLimit[SQLITE_LIMIT_COMPOUND_SELECT])>0\n+       && cnt>mxSelect\n@@ -171281,0 +174354,8 @@\n+  \/* Memory allocator for parser stack resizing.  This is a thin wrapper around\n+  ** sqlite3_realloc() that includes a call to sqlite3FaultSim() to facilitate\n+  ** testing.\n+  *\/\n+  static void *parserStackRealloc(void *pOld, sqlite3_uint64 newSize){\n+    return sqlite3FaultSim(700) ? 0 : sqlite3_realloc(pOld, newSize);\n+  }\n+\n@@ -171403,126 +174484,126 @@\n-#define TK_MATCH                          46\n-#define TK_LIKE_KW                        47\n-#define TK_BETWEEN                        48\n-#define TK_IN                             49\n-#define TK_ISNULL                         50\n-#define TK_NOTNULL                        51\n-#define TK_NE                             52\n-#define TK_EQ                             53\n-#define TK_GT                             54\n-#define TK_LE                             55\n-#define TK_LT                             56\n-#define TK_GE                             57\n-#define TK_ESCAPE                         58\n-#define TK_ID                             59\n-#define TK_COLUMNKW                       60\n-#define TK_DO                             61\n-#define TK_FOR                            62\n-#define TK_IGNORE                         63\n-#define TK_INITIALLY                      64\n-#define TK_INSTEAD                        65\n-#define TK_NO                             66\n-#define TK_KEY                            67\n-#define TK_OF                             68\n-#define TK_OFFSET                         69\n-#define TK_PRAGMA                         70\n-#define TK_RAISE                          71\n-#define TK_RECURSIVE                      72\n-#define TK_REPLACE                        73\n-#define TK_RESTRICT                       74\n-#define TK_ROW                            75\n-#define TK_ROWS                           76\n-#define TK_TRIGGER                        77\n-#define TK_VACUUM                         78\n-#define TK_VIEW                           79\n-#define TK_VIRTUAL                        80\n-#define TK_WITH                           81\n-#define TK_NULLS                          82\n-#define TK_FIRST                          83\n-#define TK_LAST                           84\n-#define TK_CURRENT                        85\n-#define TK_FOLLOWING                      86\n-#define TK_PARTITION                      87\n-#define TK_PRECEDING                      88\n-#define TK_RANGE                          89\n-#define TK_UNBOUNDED                      90\n-#define TK_EXCLUDE                        91\n-#define TK_GROUPS                         92\n-#define TK_OTHERS                         93\n-#define TK_TIES                           94\n-#define TK_GENERATED                      95\n-#define TK_ALWAYS                         96\n-#define TK_MATERIALIZED                   97\n-#define TK_REINDEX                        98\n-#define TK_RENAME                         99\n-#define TK_CTIME_KW                       100\n-#define TK_ANY                            101\n-#define TK_BITAND                         102\n-#define TK_BITOR                          103\n-#define TK_LSHIFT                         104\n-#define TK_RSHIFT                         105\n-#define TK_PLUS                           106\n-#define TK_MINUS                          107\n-#define TK_STAR                           108\n-#define TK_SLASH                          109\n-#define TK_REM                            110\n-#define TK_CONCAT                         111\n-#define TK_PTR                            112\n-#define TK_COLLATE                        113\n-#define TK_BITNOT                         114\n-#define TK_ON                             115\n-#define TK_INDEXED                        116\n-#define TK_STRING                         117\n-#define TK_JOIN_KW                        118\n-#define TK_CONSTRAINT                     119\n-#define TK_DEFAULT                        120\n-#define TK_NULL                           121\n-#define TK_PRIMARY                        122\n-#define TK_UNIQUE                         123\n-#define TK_CHECK                          124\n-#define TK_REFERENCES                     125\n-#define TK_AUTOINCR                       126\n-#define TK_INSERT                         127\n-#define TK_DELETE                         128\n-#define TK_UPDATE                         129\n-#define TK_SET                            130\n-#define TK_DEFERRABLE                     131\n-#define TK_FOREIGN                        132\n-#define TK_DROP                           133\n-#define TK_UNION                          134\n-#define TK_ALL                            135\n-#define TK_EXCEPT                         136\n-#define TK_INTERSECT                      137\n-#define TK_SELECT                         138\n-#define TK_VALUES                         139\n-#define TK_DISTINCT                       140\n-#define TK_DOT                            141\n-#define TK_FROM                           142\n-#define TK_JOIN                           143\n-#define TK_USING                          144\n-#define TK_ORDER                          145\n-#define TK_GROUP                          146\n-#define TK_HAVING                         147\n-#define TK_LIMIT                          148\n-#define TK_WHERE                          149\n-#define TK_RETURNING                      150\n-#define TK_INTO                           151\n-#define TK_NOTHING                        152\n-#define TK_FLOAT                          153\n-#define TK_BLOB                           154\n-#define TK_INTEGER                        155\n-#define TK_VARIABLE                       156\n-#define TK_CASE                           157\n-#define TK_WHEN                           158\n-#define TK_THEN                           159\n-#define TK_ELSE                           160\n-#define TK_INDEX                          161\n-#define TK_ALTER                          162\n-#define TK_ADD                            163\n-#define TK_WINDOW                         164\n-#define TK_OVER                           165\n-#define TK_FILTER                         166\n-#define TK_COLUMN                         167\n-#define TK_AGG_FUNCTION                   168\n-#define TK_AGG_COLUMN                     169\n-#define TK_TRUEFALSE                      170\n-#define TK_ISNOT                          171\n+#define TK_ISNOT                          46\n+#define TK_MATCH                          47\n+#define TK_LIKE_KW                        48\n+#define TK_BETWEEN                        49\n+#define TK_IN                             50\n+#define TK_ISNULL                         51\n+#define TK_NOTNULL                        52\n+#define TK_NE                             53\n+#define TK_EQ                             54\n+#define TK_GT                             55\n+#define TK_LE                             56\n+#define TK_LT                             57\n+#define TK_GE                             58\n+#define TK_ESCAPE                         59\n+#define TK_ID                             60\n+#define TK_COLUMNKW                       61\n+#define TK_DO                             62\n+#define TK_FOR                            63\n+#define TK_IGNORE                         64\n+#define TK_INITIALLY                      65\n+#define TK_INSTEAD                        66\n+#define TK_NO                             67\n+#define TK_KEY                            68\n+#define TK_OF                             69\n+#define TK_OFFSET                         70\n+#define TK_PRAGMA                         71\n+#define TK_RAISE                          72\n+#define TK_RECURSIVE                      73\n+#define TK_REPLACE                        74\n+#define TK_RESTRICT                       75\n+#define TK_ROW                            76\n+#define TK_ROWS                           77\n+#define TK_TRIGGER                        78\n+#define TK_VACUUM                         79\n+#define TK_VIEW                           80\n+#define TK_VIRTUAL                        81\n+#define TK_WITH                           82\n+#define TK_NULLS                          83\n+#define TK_FIRST                          84\n+#define TK_LAST                           85\n+#define TK_CURRENT                        86\n+#define TK_FOLLOWING                      87\n+#define TK_PARTITION                      88\n+#define TK_PRECEDING                      89\n+#define TK_RANGE                          90\n+#define TK_UNBOUNDED                      91\n+#define TK_EXCLUDE                        92\n+#define TK_GROUPS                         93\n+#define TK_OTHERS                         94\n+#define TK_TIES                           95\n+#define TK_GENERATED                      96\n+#define TK_ALWAYS                         97\n+#define TK_MATERIALIZED                   98\n+#define TK_REINDEX                        99\n+#define TK_RENAME                         100\n+#define TK_CTIME_KW                       101\n+#define TK_ANY                            102\n+#define TK_BITAND                         103\n+#define TK_BITOR                          104\n+#define TK_LSHIFT                         105\n+#define TK_RSHIFT                         106\n+#define TK_PLUS                           107\n+#define TK_MINUS                          108\n+#define TK_STAR                           109\n+#define TK_SLASH                          110\n+#define TK_REM                            111\n+#define TK_CONCAT                         112\n+#define TK_PTR                            113\n+#define TK_COLLATE                        114\n+#define TK_BITNOT                         115\n+#define TK_ON                             116\n+#define TK_INDEXED                        117\n+#define TK_STRING                         118\n+#define TK_JOIN_KW                        119\n+#define TK_CONSTRAINT                     120\n+#define TK_DEFAULT                        121\n+#define TK_NULL                           122\n+#define TK_PRIMARY                        123\n+#define TK_UNIQUE                         124\n+#define TK_CHECK                          125\n+#define TK_REFERENCES                     126\n+#define TK_AUTOINCR                       127\n+#define TK_INSERT                         128\n+#define TK_DELETE                         129\n+#define TK_UPDATE                         130\n+#define TK_SET                            131\n+#define TK_DEFERRABLE                     132\n+#define TK_FOREIGN                        133\n+#define TK_DROP                           134\n+#define TK_UNION                          135\n+#define TK_ALL                            136\n+#define TK_EXCEPT                         137\n+#define TK_INTERSECT                      138\n+#define TK_SELECT                         139\n+#define TK_VALUES                         140\n+#define TK_DISTINCT                       141\n+#define TK_DOT                            142\n+#define TK_FROM                           143\n+#define TK_JOIN                           144\n+#define TK_USING                          145\n+#define TK_ORDER                          146\n+#define TK_GROUP                          147\n+#define TK_HAVING                         148\n+#define TK_LIMIT                          149\n+#define TK_WHERE                          150\n+#define TK_RETURNING                      151\n+#define TK_INTO                           152\n+#define TK_NOTHING                        153\n+#define TK_FLOAT                          154\n+#define TK_BLOB                           155\n+#define TK_INTEGER                        156\n+#define TK_VARIABLE                       157\n+#define TK_CASE                           158\n+#define TK_WHEN                           159\n+#define TK_THEN                           160\n+#define TK_ELSE                           161\n+#define TK_INDEX                          162\n+#define TK_ALTER                          163\n+#define TK_ADD                            164\n+#define TK_WINDOW                         165\n+#define TK_OVER                           166\n+#define TK_FILTER                         167\n+#define TK_COLUMN                         168\n+#define TK_AGG_FUNCTION                   169\n+#define TK_AGG_COLUMN                     170\n+#define TK_TRUEFALSE                      171\n@@ -171530,2 +174611,2 @@\n-#define TK_UMINUS                         173\n-#define TK_UPLUS                          174\n+#define TK_UPLUS                          173\n+#define TK_UMINUS                         174\n@@ -171540,2 +174621,4 @@\n-#define TK_SPACE                          183\n-#define TK_ILLEGAL                        184\n+#define TK_QNUMBER                        183\n+#define TK_SPACE                          184\n+#define TK_COMMENT                        185\n+#define TK_ILLEGAL                        186\n@@ -171582,0 +174665,3 @@\n+**    YYREALLOC          Name of the realloc() function to use\n+**    YYFREE             Name of the free() function to use\n+**    YYDYNSTACK         True if stack space should be extended on heap\n@@ -171595,0 +174681,2 @@\n+**    YY_MIN_DSTRCTR     Minimum symbol value that has a destructor\n+**    YY_MAX_DSTRCTR     Maximum symbol value that has a destructor\n@@ -171601,1 +174689,1 @@\n-#define YYNOCODE 319\n+#define YYNOCODE 323\n@@ -171603,1 +174691,1 @@\n-#define YYWILDCARD 101\n+#define YYWILDCARD 102\n@@ -171608,18 +174696,18 @@\n-  TriggerStep* yy33;\n-  Window* yy41;\n-  Select* yy47;\n-  SrcList* yy131;\n-  struct TrigEvent yy180;\n-  struct {int value; int mask;} yy231;\n-  IdList* yy254;\n-  u32 yy285;\n-  ExprList* yy322;\n-  Cte* yy385;\n-  int yy394;\n-  Upsert* yy444;\n-  u8 yy516;\n-  With* yy521;\n-  const char* yy522;\n-  Expr* yy528;\n-  OnOrUsing yy561;\n-  struct FrameBound yy595;\n+  u32 yy9;\n+  struct TrigEvent yy28;\n+  With* yy125;\n+  IdList* yy204;\n+  struct FrameBound yy205;\n+  TriggerStep* yy319;\n+  const char* yy342;\n+  Cte* yy361;\n+  ExprList* yy402;\n+  Upsert* yy403;\n+  OnOrUsing yy421;\n+  u8 yy444;\n+  struct {int value; int mask;} yy481;\n+  Window* yy483;\n+  int yy502;\n+  SrcList* yy563;\n+  Expr* yy590;\n+  Select* yy637;\n@@ -171635,0 +174723,3 @@\n+#define YYREALLOC parserStackRealloc\n+#define YYFREE sqlite3_free\n+#define YYDYNSTACK 1\n@@ -171641,12 +174732,14 @@\n-#define YYNSTATE             579\n-#define YYNRULE              405\n-#define YYNRULE_WITH_ACTION  340\n-#define YYNTOKEN             185\n-#define YY_MAX_SHIFT         578\n-#define YY_MIN_SHIFTREDUCE   838\n-#define YY_MAX_SHIFTREDUCE   1242\n-#define YY_ERROR_ACTION      1243\n-#define YY_ACCEPT_ACTION     1244\n-#define YY_NO_ACTION         1245\n-#define YY_MIN_REDUCE        1246\n-#define YY_MAX_REDUCE        1650\n+#define YYNSTATE             583\n+#define YYNRULE              409\n+#define YYNRULE_WITH_ACTION  344\n+#define YYNTOKEN             187\n+#define YY_MAX_SHIFT         582\n+#define YY_MIN_SHIFTREDUCE   845\n+#define YY_MAX_SHIFTREDUCE   1253\n+#define YY_ERROR_ACTION      1254\n+#define YY_ACCEPT_ACTION     1255\n+#define YY_NO_ACTION         1256\n+#define YY_MIN_REDUCE        1257\n+#define YY_MAX_REDUCE        1665\n+#define YY_MIN_DSTRCTR       206\n+#define YY_MAX_DSTRCTR       320\n@@ -171668,0 +174761,16 @@\n+\/* Macro to determine if stack space has the ability to grow using\n+** heap memory.\n+*\/\n+#if YYSTACKDEPTH<=0 || YYDYNSTACK\n+# define YYGROWABLESTACK 1\n+#else\n+# define YYGROWABLESTACK 0\n+#endif\n+\n+\/* Guarantee a minimum number of initial stack slots.\n+*\/\n+#if YYSTACKDEPTH<=0\n+# undef YYSTACKDEPTH\n+# define YYSTACKDEPTH 2  \/* Need a minimum stack size *\/\n+#endif\n+\n@@ -171719,1 +174828,1 @@\n-#define YY_ACTTAB_COUNT (2100)\n+#define YY_ACTTAB_COUNT (2207)\n@@ -171721,210 +174830,221 @@\n- \/*     0 *\/   572,  210,  572,  119,  116,  231,  572,  119,  116,  231,\n- \/*    10 *\/   572, 1317,  379, 1296,  410,  566,  566,  566,  572,  411,\n- \/*    20 *\/   380, 1317, 1279,   42,   42,   42,   42,  210, 1529,   72,\n- \/*    30 *\/    72,  974,  421,   42,   42,  495,  305,  281,  305,  975,\n- \/*    40 *\/   399,   72,   72,  126,  127,   81, 1217, 1217, 1054, 1057,\n- \/*    50 *\/  1044, 1044,  124,  124,  125,  125,  125,  125,  480,  411,\n- \/*    60 *\/  1244,    1,    1,  578,    2, 1248,  554,  119,  116,  231,\n- \/*    70 *\/   319,  484,  147,  484,  528,  119,  116,  231,  533, 1330,\n- \/*    80 *\/   419,  527,  143,  126,  127,   81, 1217, 1217, 1054, 1057,\n- \/*    90 *\/  1044, 1044,  124,  124,  125,  125,  125,  125,  119,  116,\n- \/*   100 *\/   231,  329,  123,  123,  123,  123,  122,  122,  121,  121,\n- \/*   110 *\/   121,  120,  117,  448,  286,  286,  286,  286,  446,  446,\n- \/*   120 *\/   446, 1568,  378, 1570, 1193,  377, 1164,  569, 1164,  569,\n- \/*   130 *\/   411, 1568,  541,  261,  228,  448,  102,  146,  453,  318,\n- \/*   140 *\/   563,  242,  123,  123,  123,  123,  122,  122,  121,  121,\n- \/*   150 *\/   121,  120,  117,  448,  126,  127,   81, 1217, 1217, 1054,\n- \/*   160 *\/  1057, 1044, 1044,  124,  124,  125,  125,  125,  125,  143,\n- \/*   170 *\/   296, 1193,  341,  452,  121,  121,  121,  120,  117,  448,\n- \/*   180 *\/   128, 1193, 1194, 1193,  149,  445,  444,  572,  120,  117,\n- \/*   190 *\/   448,  125,  125,  125,  125,  118,  123,  123,  123,  123,\n- \/*   200 *\/   122,  122,  121,  121,  121,  120,  117,  448,  458,  114,\n- \/*   210 *\/    13,   13,  550,  123,  123,  123,  123,  122,  122,  121,\n- \/*   220 *\/   121,  121,  120,  117,  448,  424,  318,  563, 1193, 1194,\n- \/*   230 *\/  1193,  150, 1225,  411, 1225,  125,  125,  125,  125,  123,\n- \/*   240 *\/   123,  123,  123,  122,  122,  121,  121,  121,  120,  117,\n- \/*   250 *\/   448,  469,  344, 1041, 1041, 1055, 1058,  126,  127,   81,\n- \/*   260 *\/  1217, 1217, 1054, 1057, 1044, 1044,  124,  124,  125,  125,\n- \/*   270 *\/   125,  125, 1282,  526,  224, 1193,  572,  411,  226,  519,\n- \/*   280 *\/   177,   83,   84,  123,  123,  123,  123,  122,  122,  121,\n- \/*   290 *\/   121,  121,  120,  117,  448, 1010,   16,   16, 1193,  134,\n- \/*   300 *\/   134,  126,  127,   81, 1217, 1217, 1054, 1057, 1044, 1044,\n- \/*   310 *\/   124,  124,  125,  125,  125,  125,  123,  123,  123,  123,\n- \/*   320 *\/   122,  122,  121,  121,  121,  120,  117,  448, 1045,  550,\n- \/*   330 *\/  1193,  375, 1193, 1194, 1193,  254, 1438,  401,  508,  505,\n- \/*   340 *\/   504,  112,  564,  570,    4,  929,  929,  435,  503,  342,\n- \/*   350 *\/   464,  330,  362,  396, 1238, 1193, 1194, 1193,  567,  572,\n- \/*   360 *\/   123,  123,  123,  123,  122,  122,  121,  121,  121,  120,\n- \/*   370 *\/   117,  448,  286,  286,  371, 1581, 1607,  445,  444,  155,\n- \/*   380 *\/   411,  449,   72,   72, 1289,  569, 1222, 1193, 1194, 1193,\n- \/*   390 *\/    86, 1224,  273,  561,  547,  520,  520,  572,   99, 1223,\n- \/*   400 *\/     6, 1281,  476,  143,  126,  127,   81, 1217, 1217, 1054,\n- \/*   410 *\/  1057, 1044, 1044,  124,  124,  125,  125,  125,  125,  554,\n- \/*   420 *\/    13,   13, 1031,  511, 1225, 1193, 1225,  553,  110,  110,\n- \/*   430 *\/   224,  572, 1239,  177,  572,  429,  111,  199,  449,  573,\n- \/*   440 *\/   449,  432, 1555, 1019,  327,  555, 1193,  272,  289,  370,\n- \/*   450 *\/   514,  365,  513,  259,   72,   72,  547,   72,   72,  361,\n- \/*   460 *\/   318,  563, 1613,  123,  123,  123,  123,  122,  122,  121,\n- \/*   470 *\/   121,  121,  120,  117,  448, 1019, 1019, 1021, 1022,   28,\n- \/*   480 *\/   286,  286, 1193, 1194, 1193, 1159,  572, 1612,  411,  904,\n- \/*   490 *\/   192,  554,  358,  569,  554,  940,  537,  521, 1159,  437,\n- \/*   500 *\/   415, 1159,  556, 1193, 1194, 1193,  572,  548,  548,   52,\n- \/*   510 *\/    52,  216,  126,  127,   81, 1217, 1217, 1054, 1057, 1044,\n- \/*   520 *\/  1044,  124,  124,  125,  125,  125,  125, 1193,  478,  136,\n- \/*   530 *\/   136,  411,  286,  286, 1493,  509,  122,  122,  121,  121,\n- \/*   540 *\/   121,  120,  117,  448, 1010,  569,  522,  219,  545,  545,\n- \/*   550 *\/   318,  563,  143,    6,  536,  126,  127,   81, 1217, 1217,\n- \/*   560 *\/  1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,  125,\n- \/*   570 *\/  1557,  123,  123,  123,  123,  122,  122,  121,  121,  121,\n- \/*   580 *\/   120,  117,  448,  489, 1193, 1194, 1193,  486,  283, 1270,\n- \/*   590 *\/   960,  254, 1193,  375,  508,  505,  504, 1193,  342,  574,\n- \/*   600 *\/  1193,  574,  411,  294,  503,  960,  879,  193,  484,  318,\n- \/*   610 *\/   563,  386,  292,  382,  123,  123,  123,  123,  122,  122,\n- \/*   620 *\/   121,  121,  121,  120,  117,  448,  126,  127,   81, 1217,\n- \/*   630 *\/  1217, 1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,\n- \/*   640 *\/   125,  411,  396, 1139, 1193,  872,  101,  286,  286, 1193,\n- \/*   650 *\/  1194, 1193,  375, 1096, 1193, 1194, 1193, 1193, 1194, 1193,\n- \/*   660 *\/   569,  459,   33,  375,  235,  126,  127,   81, 1217, 1217,\n- \/*   670 *\/  1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,  125,\n- \/*   680 *\/  1437,  962,  572,  230,  961,  123,  123,  123,  123,  122,\n- \/*   690 *\/   122,  121,  121,  121,  120,  117,  448, 1159,  230, 1193,\n- \/*   700 *\/   158, 1193, 1194, 1193, 1556,   13,   13,  303,  960, 1233,\n- \/*   710 *\/  1159,  154,  411, 1159,  375, 1584, 1177,    5,  371, 1581,\n- \/*   720 *\/   431, 1239,    3,  960,  123,  123,  123,  123,  122,  122,\n- \/*   730 *\/   121,  121,  121,  120,  117,  448,  126,  127,   81, 1217,\n- \/*   740 *\/  1217, 1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,\n- \/*   750 *\/   125,  411,  210,  571, 1193, 1032, 1193, 1194, 1193, 1193,\n- \/*   760 *\/   390,  855,  156, 1555,  376,  404, 1101, 1101,  492,  572,\n- \/*   770 *\/   469,  344, 1322, 1322, 1555,  126,  127,   81, 1217, 1217,\n- \/*   780 *\/  1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,  125,\n- \/*   790 *\/   130,  572,   13,   13,  532,  123,  123,  123,  123,  122,\n- \/*   800 *\/   122,  121,  121,  121,  120,  117,  448,  304,  572,  457,\n- \/*   810 *\/   229, 1193, 1194, 1193,   13,   13, 1193, 1194, 1193, 1300,\n- \/*   820 *\/   467, 1270,  411, 1320, 1320, 1555, 1015,  457,  456,  436,\n- \/*   830 *\/   301,   72,   72, 1268,  123,  123,  123,  123,  122,  122,\n- \/*   840 *\/   121,  121,  121,  120,  117,  448,  126,  127,   81, 1217,\n- \/*   850 *\/  1217, 1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,\n- \/*   860 *\/   125,  411,  384, 1076, 1159,  286,  286,  421,  314,  280,\n- \/*   870 *\/   280,  287,  287,  461,  408,  407, 1539, 1159,  569,  572,\n- \/*   880 *\/  1159, 1196,  569,  409,  569,  126,  127,   81, 1217, 1217,\n- \/*   890 *\/  1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,  125,\n- \/*   900 *\/   457, 1485,   13,   13, 1541,  123,  123,  123,  123,  122,\n- \/*   910 *\/   122,  121,  121,  121,  120,  117,  448,  202,  572,  462,\n- \/*   920 *\/  1587,  578,    2, 1248,  843,  844,  845, 1563,  319,  409,\n- \/*   930 *\/   147,    6,  411,  257,  256,  255,  208, 1330,    9, 1196,\n- \/*   940 *\/   264,   72,   72, 1436,  123,  123,  123,  123,  122,  122,\n- \/*   950 *\/   121,  121,  121,  120,  117,  448,  126,  127,   81, 1217,\n- \/*   960 *\/  1217, 1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,\n- \/*   970 *\/   125,  572,  286,  286,  572, 1213,  411,  577,  315, 1248,\n- \/*   980 *\/   421,  371, 1581,  356,  319,  569,  147,  495,  529, 1644,\n- \/*   990 *\/   397,  935,  495, 1330,   71,   71,  934,   72,   72,  242,\n- \/*  1000 *\/  1328,  105,   81, 1217, 1217, 1054, 1057, 1044, 1044,  124,\n- \/*  1010 *\/   124,  125,  125,  125,  125,  123,  123,  123,  123,  122,\n- \/*  1020 *\/   122,  121,  121,  121,  120,  117,  448, 1117,  286,  286,\n- \/*  1030 *\/  1422,  452, 1528, 1213,  443,  286,  286, 1492, 1355,  313,\n- \/*  1040 *\/   478,  569, 1118,  454,  351,  495,  354, 1266,  569,  209,\n- \/*  1050 *\/   572,  418,  179,  572, 1031,  242,  385, 1119,  523,  123,\n- \/*  1060 *\/   123,  123,  123,  122,  122,  121,  121,  121,  120,  117,\n- \/*  1070 *\/   448, 1020,  108,   72,   72, 1019,   13,   13,  915,  572,\n- \/*  1080 *\/  1498,  572,  286,  286,   98,  530, 1537,  452,  916, 1334,\n- \/*  1090 *\/  1329,  203,  411,  286,  286,  569,  152,  211, 1498, 1500,\n- \/*  1100 *\/   426,  569,   56,   56,   57,   57,  569, 1019, 1019, 1021,\n- \/*  1110 *\/   447,  572,  411,  531,   12,  297,  126,  127,   81, 1217,\n- \/*  1120 *\/  1217, 1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,\n- \/*  1130 *\/   125,  572,  411,  867,   15,   15,  126,  127,   81, 1217,\n- \/*  1140 *\/  1217, 1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,\n- \/*  1150 *\/   125,  373,  529,  264,   44,   44,  126,  115,   81, 1217,\n- \/*  1160 *\/  1217, 1054, 1057, 1044, 1044,  124,  124,  125,  125,  125,\n- \/*  1170 *\/   125, 1498,  478, 1271,  417,  123,  123,  123,  123,  122,\n- \/*  1180 *\/   122,  121,  121,  121,  120,  117,  448,  205, 1213,  495,\n- \/*  1190 *\/   430,  867,  468,  322,  495,  123,  123,  123,  123,  122,\n- \/*  1200 *\/   122,  121,  121,  121,  120,  117,  448,  572,  557, 1140,\n- \/*  1210 *\/  1642, 1422, 1642,  543,  572,  123,  123,  123,  123,  122,\n- \/*  1220 *\/   122,  121,  121,  121,  120,  117,  448,  572, 1422,  572,\n- \/*  1230 *\/    13,   13,  542,  323, 1325,  411,  334,   58,   58,  349,\n- \/*  1240 *\/  1422, 1170,  326,  286,  286,  549, 1213,  300,  895,  530,\n- \/*  1250 *\/    45,   45,   59,   59, 1140, 1643,  569, 1643,  565,  417,\n- \/*  1260 *\/   127,   81, 1217, 1217, 1054, 1057, 1044, 1044,  124,  124,\n- \/*  1270 *\/   125,  125,  125,  125, 1367,  373,  500,  290, 1193,  512,\n- \/*  1280 *\/  1366,  427,  394,  394,  393,  275,  391,  896, 1138,  852,\n- \/*  1290 *\/   478,  258, 1422, 1170,  463, 1159,   12,  331,  428,  333,\n- \/*  1300 *\/  1117,  460,  236,  258,  325,  460,  544, 1544, 1159, 1098,\n- \/*  1310 *\/   491, 1159,  324, 1098,  440, 1118,  335,  516,  123,  123,\n- \/*  1320 *\/   123,  123,  122,  122,  121,  121,  121,  120,  117,  448,\n- \/*  1330 *\/  1119,  318,  563, 1138,  572, 1193, 1194, 1193,  112,  564,\n- \/*  1340 *\/   201,    4,  238,  433,  935,  490,  285,  228, 1517,  934,\n- \/*  1350 *\/   170,  560,  572,  142, 1516,  567,  572,   60,   60,  572,\n- \/*  1360 *\/   416,  572,  441,  572,  535,  302,  875,    8,  487,  572,\n- \/*  1370 *\/   237,  572,  416,  572,  485,   61,   61,  572,  449,   62,\n- \/*  1380 *\/    62,  332,   63,   63,   46,   46,   47,   47,  361,  572,\n- \/*  1390 *\/   561,  572,   48,   48,   50,   50,   51,   51,  572,  295,\n- \/*  1400 *\/    64,   64,  482,  295,  539,  412,  471, 1031,  572,  538,\n- \/*  1410 *\/   318,  563,   65,   65,   66,   66,  409,  475,  572, 1031,\n- \/*  1420 *\/   572,   14,   14,  875, 1020,  110,  110,  409, 1019,  572,\n- \/*  1430 *\/   474,   67,   67,  111,  455,  449,  573,  449,   98,  317,\n- \/*  1440 *\/  1019,  132,  132,  133,  133,  572, 1561,  572,  974,  409,\n- \/*  1450 *\/     6, 1562,   68,   68, 1560,    6,  975,  572,    6, 1559,\n- \/*  1460 *\/  1019, 1019, 1021,    6,  346,  218,  101,  531,   53,   53,\n- \/*  1470 *\/    69,   69, 1019, 1019, 1021, 1022,   28, 1586, 1181,  451,\n- \/*  1480 *\/    70,   70,  290,   87,  215,   31, 1363,  394,  394,  393,\n- \/*  1490 *\/   275,  391,  350,  109,  852,  107,  572,  112,  564,  483,\n- \/*  1500 *\/     4, 1212,  572,  239,  153,  572,   39,  236, 1299,  325,\n- \/*  1510 *\/   112,  564, 1298,    4,  567,  572,   32,  324,  572,   54,\n- \/*  1520 *\/    54,  572, 1135,  353,  398,  165,  165,  567,  166,  166,\n- \/*  1530 *\/   572,  291,  355,  572,   17,  357,  572,  449,   77,   77,\n- \/*  1540 *\/  1313,   55,   55, 1297,   73,   73,  572,  238,  470,  561,\n- \/*  1550 *\/   449,  472,  364,  135,  135,  170,   74,   74,  142,  163,\n- \/*  1560 *\/   163,  374,  561,  539,  572,  321,  572,  886,  540,  137,\n- \/*  1570 *\/   137,  339, 1353,  422,  298,  237,  539,  572, 1031,  572,\n- \/*  1580 *\/   340,  538,  101,  369,  110,  110,  162,  131,  131,  164,\n- \/*  1590 *\/   164, 1031,  111,  368,  449,  573,  449,  110,  110, 1019,\n- \/*  1600 *\/   157,  157,  141,  141,  572,  111,  572,  449,  573,  449,\n- \/*  1610 *\/   412,  288, 1019,  572,  882,  318,  563,  572,  219,  572,\n- \/*  1620 *\/   241, 1012,  477,  263,  263,  894,  893,  140,  140,  138,\n- \/*  1630 *\/   138, 1019, 1019, 1021, 1022,   28,  139,  139,  525,  455,\n- \/*  1640 *\/    76,   76,   78,   78, 1019, 1019, 1021, 1022,   28, 1181,\n- \/*  1650 *\/   451,  572, 1083,  290,  112,  564, 1575,    4,  394,  394,\n- \/*  1660 *\/   393,  275,  391,  572, 1023,  852,  572,  479,  345,  263,\n- \/*  1670 *\/   101,  567,  882, 1376,   75,   75, 1421,  501,  236,  260,\n- \/*  1680 *\/   325,  112,  564,  359,    4,  101,   43,   43,  324,   49,\n- \/*  1690 *\/    49,  901,  902,  161,  449,  101,  977,  978,  567, 1079,\n- \/*  1700 *\/  1349,  260,  965,  932,  263,  114,  561, 1095,  517, 1095,\n- \/*  1710 *\/  1083, 1094,  865, 1094,  151,  933, 1144,  114,  238, 1361,\n- \/*  1720 *\/   558,  449, 1023,  559, 1426, 1278,  170, 1269, 1257,  142,\n- \/*  1730 *\/  1601, 1256, 1258,  561, 1594, 1031,  496,  278,  213, 1346,\n- \/*  1740 *\/   310,  110,  110,  939,  311,  312,  237,   11,  234,  111,\n- \/*  1750 *\/   221,  449,  573,  449,  293,  395, 1019, 1408,  337, 1403,\n- \/*  1760 *\/  1396,  338, 1031,  299,  343, 1413, 1412,  481,  110,  110,\n- \/*  1770 *\/   506,  402,  225, 1296,  206,  367,  111, 1358,  449,  573,\n- \/*  1780 *\/   449,  412, 1359, 1019, 1489, 1488,  318,  563, 1019, 1019,\n- \/*  1790 *\/  1021, 1022,   28,  562,  207,  220,   80,  564,  389,    4,\n- \/*  1800 *\/  1597, 1357,  552, 1356, 1233,  181,  267,  232, 1536, 1534,\n- \/*  1810 *\/   455, 1230,  420,  567,   82, 1019, 1019, 1021, 1022,   28,\n- \/*  1820 *\/    86,  217,   85, 1494,  190,  175,  183,  465,  185,  466,\n- \/*  1830 *\/    36, 1409,  186,  187,  188,  499,  449,  244,   37,   99,\n- \/*  1840 *\/   400, 1415, 1414,  488, 1417,  194,  473,  403,  561, 1483,\n- \/*  1850 *\/   248,   92, 1505,  494,  198,  279,  112,  564,  250,    4,\n- \/*  1860 *\/   348,  497,  405,  352, 1259,  251,  252,  515, 1316,  434,\n- \/*  1870 *\/  1315, 1314,   94,  567, 1307,  886, 1306, 1031,  226,  406,\n- \/*  1880 *\/  1611, 1610,  438,  110,  110, 1580, 1286,  524,  439,  308,\n- \/*  1890 *\/   266,  111, 1285,  449,  573,  449,  449,  309, 1019,  366,\n- \/*  1900 *\/  1284, 1609,  265, 1566, 1565,  442,  372, 1381,  561,  129,\n- \/*  1910 *\/   550, 1380,   10, 1470,  383,  106,  316,  551,  100,   35,\n- \/*  1920 *\/   534,  575,  212, 1339,  381,  387, 1187, 1338,  274,  276,\n- \/*  1930 *\/  1019, 1019, 1021, 1022,   28,  277,  413, 1031,  576, 1254,\n- \/*  1940 *\/   388, 1521, 1249,  110,  110,  167, 1522,  168,  148, 1520,\n- \/*  1950 *\/  1519,  111,  306,  449,  573,  449,  222,  223, 1019,  839,\n- \/*  1960 *\/   169,   79,  450,  214,  414,  233,  320,  145, 1093, 1091,\n- \/*  1970 *\/   328,  182,  171, 1212,  918,  184,  240,  336,  243, 1107,\n- \/*  1980 *\/   189,  172,  173,  423,  425,   88,  180,  191,   89,   90,\n- \/*  1990 *\/  1019, 1019, 1021, 1022,   28,   91,  174, 1110,  245, 1106,\n- \/*  2000 *\/   246,  159,   18,  247,  347, 1099,  263,  195, 1227,  493,\n- \/*  2010 *\/   249,  196,   38,  854,  498,  368,  253,  360,  897,  197,\n- \/*  2020 *\/   502,   93,   19,   20,  507,  884,  363,  510,   95,  307,\n- \/*  2030 *\/   160,   96,  518,   97, 1175, 1060, 1146,   40,   21,  227,\n- \/*  2040 *\/   176, 1145,  282,  284,  969,  200,  963,  114,  262, 1165,\n- \/*  2050 *\/    22,   23,   24, 1161, 1169,   25, 1163, 1150,   34,   26,\n- \/*  2060 *\/  1168,  546,   27,  204,  101,  103,  104, 1074,    7, 1061,\n- \/*  2070 *\/  1059, 1063, 1116, 1064, 1115,  268,  269,   29,   41,  270,\n- \/*  2080 *\/  1024,  866,  113,   30,  568,  392, 1183,  144,  178, 1182,\n- \/*  2090 *\/   271,  928, 1245, 1245, 1245, 1245, 1245, 1245, 1245, 1602,\n+ \/*     0 *\/   130,  127,  234,  282,  282, 1328,  576, 1307,  460,  289,\n+ \/*    10 *\/   289,  576, 1622,  381,  576, 1328,  573,  576,  562,  413,\n+ \/*    20 *\/  1300, 1542,  573,  481,  562,  524,  460,  459,  558,   82,\n+ \/*    30 *\/    82,  983,  294,  375,   51,   51,  498,   61,   61,  984,\n+ \/*    40 *\/    82,   82, 1577,  137,  138,   91,    7, 1228, 1228, 1063,\n+ \/*    50 *\/  1066, 1053, 1053,  135,  135,  136,  136,  136,  136,  413,\n+ \/*    60 *\/   288,  288,  182,  288,  288,  481,  536,  288,  288,  130,\n+ \/*    70 *\/   127,  234,  432,  573,  525,  562,  573,  557,  562, 1290,\n+ \/*    80 *\/   573,  421,  562,  137,  138,   91,  559, 1228, 1228, 1063,\n+ \/*    90 *\/  1066, 1053, 1053,  135,  135,  136,  136,  136,  136,  296,\n+ \/*   100 *\/   460,  398, 1249,  134,  134,  134,  134,  133,  133,  132,\n+ \/*   110 *\/   132,  132,  131,  128,  451,  451, 1050, 1050, 1064, 1067,\n+ \/*   120 *\/  1255,    1,    1,  582,    2, 1259,  581, 1174, 1259, 1174,\n+ \/*   130 *\/   321,  413,  155,  321, 1584,  155,  379,  112,  481, 1341,\n+ \/*   140 *\/   456,  299, 1341,  134,  134,  134,  134,  133,  133,  132,\n+ \/*   150 *\/   132,  132,  131,  128,  451,  137,  138,   91,  498, 1228,\n+ \/*   160 *\/  1228, 1063, 1066, 1053, 1053,  135,  135,  136,  136,  136,\n+ \/*   170 *\/   136, 1204,  862, 1281,  288,  288,  283,  288,  288,  523,\n+ \/*   180 *\/   523, 1250,  139,  578,    7,  578, 1345,  573, 1169,  562,\n+ \/*   190 *\/   573, 1054,  562,  136,  136,  136,  136,  129,  573,  547,\n+ \/*   200 *\/   562, 1169,  245, 1541, 1169,  245,  133,  133,  132,  132,\n+ \/*   210 *\/   132,  131,  128,  451,  302,  134,  134,  134,  134,  133,\n+ \/*   220 *\/   133,  132,  132,  132,  131,  128,  451, 1575, 1204, 1205,\n+ \/*   230 *\/  1204,    7,  470,  550,  455,  413,  550,  455,  130,  127,\n+ \/*   240 *\/   234,  134,  134,  134,  134,  133,  133,  132,  132,  132,\n+ \/*   250 *\/   131,  128,  451,  136,  136,  136,  136,  538,  483,  137,\n+ \/*   260 *\/   138,   91, 1019, 1228, 1228, 1063, 1066, 1053, 1053,  135,\n+ \/*   270 *\/   135,  136,  136,  136,  136, 1085,  576, 1204,  132,  132,\n+ \/*   280 *\/   132,  131,  128,  451,   93,  214,  134,  134,  134,  134,\n+ \/*   290 *\/   133,  133,  132,  132,  132,  131,  128,  451,  401,   19,\n+ \/*   300 *\/    19,  134,  134,  134,  134,  133,  133,  132,  132,  132,\n+ \/*   310 *\/   131,  128,  451, 1498,  426,  267,  344,  467,  332,  134,\n+ \/*   320 *\/   134,  134,  134,  133,  133,  132,  132,  132,  131,  128,\n+ \/*   330 *\/   451, 1281,  576,    6, 1204, 1205, 1204,  257,  576,  413,\n+ \/*   340 *\/   511,  508,  507, 1279,   94, 1019,  464, 1204,  551,  551,\n+ \/*   350 *\/   506, 1224, 1571,   44,   38,   51,   51,  411,  576,  413,\n+ \/*   360 *\/    45,   51,   51,  137,  138,   91,  530, 1228, 1228, 1063,\n+ \/*   370 *\/  1066, 1053, 1053,  135,  135,  136,  136,  136,  136,  398,\n+ \/*   380 *\/  1148,   82,   82,  137,  138,   91,   39, 1228, 1228, 1063,\n+ \/*   390 *\/  1066, 1053, 1053,  135,  135,  136,  136,  136,  136,  344,\n+ \/*   400 *\/    44,  288,  288,  375, 1204, 1205, 1204,  209, 1204, 1224,\n+ \/*   410 *\/   320,  567,  471,  576,  573,  576,  562,  576,  316,  264,\n+ \/*   420 *\/   231,   46,  160,  134,  134,  134,  134,  133,  133,  132,\n+ \/*   430 *\/   132,  132,  131,  128,  451,  303,   82,   82,   82,   82,\n+ \/*   440 *\/    82,   82,  442,  134,  134,  134,  134,  133,  133,  132,\n+ \/*   450 *\/   132,  132,  131,  128,  451, 1582,  544,  320,  567, 1250,\n+ \/*   460 *\/   874, 1582,  380,  382,  413, 1204, 1205, 1204,  360,  182,\n+ \/*   470 *\/   288,  288, 1576,  557, 1339,  557,    7,  557, 1277,  472,\n+ \/*   480 *\/   346,  526,  531,  573,  556,  562,  439, 1511,  137,  138,\n+ \/*   490 *\/    91,  219, 1228, 1228, 1063, 1066, 1053, 1053,  135,  135,\n+ \/*   500 *\/   136,  136,  136,  136,  465, 1511, 1513,  532,  413,  288,\n+ \/*   510 *\/   288,  423,  512,  288,  288,  411,  288,  288,  874,  130,\n+ \/*   520 *\/   127,  234,  573, 1107,  562, 1204,  573, 1107,  562,  573,\n+ \/*   530 *\/   560,  562,  137,  138,   91, 1293, 1228, 1228, 1063, 1066,\n+ \/*   540 *\/  1053, 1053,  135,  135,  136,  136,  136,  136,  134,  134,\n+ \/*   550 *\/   134,  134,  133,  133,  132,  132,  132,  131,  128,  451,\n+ \/*   560 *\/   493,  503, 1292, 1204,  257,  288,  288,  511,  508,  507,\n+ \/*   570 *\/  1204, 1628, 1169,  123,  568,  275,    4,  506,  573, 1511,\n+ \/*   580 *\/   562,  331, 1204, 1205, 1204, 1169,  548,  548, 1169,  261,\n+ \/*   590 *\/   571,    7,  134,  134,  134,  134,  133,  133,  132,  132,\n+ \/*   600 *\/   132,  131,  128,  451,  108,  533,  130,  127,  234, 1204,\n+ \/*   610 *\/   448,  447,  413, 1451,  452,  983,  886,   96, 1598, 1233,\n+ \/*   620 *\/  1204, 1205, 1204,  984, 1235, 1450,  565, 1204, 1205, 1204,\n+ \/*   630 *\/   229,  522, 1234,  534, 1333, 1333,  137,  138,   91, 1449,\n+ \/*   640 *\/  1228, 1228, 1063, 1066, 1053, 1053,  135,  135,  136,  136,\n+ \/*   650 *\/   136,  136,  373, 1595,  971, 1040,  413, 1236,  418, 1236,\n+ \/*   660 *\/   879,  121,  121,  948,  373, 1595, 1204, 1205, 1204,  122,\n+ \/*   670 *\/  1204,  452,  577,  452,  363,  417, 1028,  882,  373, 1595,\n+ \/*   680 *\/   137,  138,   91,  462, 1228, 1228, 1063, 1066, 1053, 1053,\n+ \/*   690 *\/   135,  135,  136,  136,  136,  136,  134,  134,  134,  134,\n+ \/*   700 *\/   133,  133,  132,  132,  132,  131,  128,  451, 1028, 1028,\n+ \/*   710 *\/  1030, 1031,   35,  570,  570,  570,  197,  423, 1040,  198,\n+ \/*   720 *\/  1204,  123,  568, 1204,    4,  320,  567, 1204, 1205, 1204,\n+ \/*   730 *\/    40,  388,  576,  384,  882, 1029,  423, 1188,  571, 1028,\n+ \/*   740 *\/   134,  134,  134,  134,  133,  133,  132,  132,  132,  131,\n+ \/*   750 *\/   128,  451,  529, 1568, 1204,   19,   19, 1204,  575,  492,\n+ \/*   760 *\/   413,  157,  452,  489, 1187, 1331, 1331,    5, 1204,  949,\n+ \/*   770 *\/   431, 1028, 1028, 1030,  565,   22,   22, 1204, 1205, 1204,\n+ \/*   780 *\/  1204, 1205, 1204,  477,  137,  138,   91,  212, 1228, 1228,\n+ \/*   790 *\/  1063, 1066, 1053, 1053,  135,  135,  136,  136,  136,  136,\n+ \/*   800 *\/  1188,   48,  111, 1040,  413, 1204,  213,  970, 1041,  121,\n+ \/*   810 *\/   121, 1204, 1205, 1204, 1204, 1205, 1204,  122,  221,  452,\n+ \/*   820 *\/   577,  452,   44,  487, 1028, 1204, 1205, 1204,  137,  138,\n+ \/*   830 *\/    91,  378, 1228, 1228, 1063, 1066, 1053, 1053,  135,  135,\n+ \/*   840 *\/   136,  136,  136,  136,  134,  134,  134,  134,  133,  133,\n+ \/*   850 *\/   132,  132,  132,  131,  128,  451, 1028, 1028, 1030, 1031,\n+ \/*   860 *\/    35,  461, 1204, 1205, 1204, 1569, 1040,  377,  214, 1149,\n+ \/*   870 *\/  1657,  535, 1657,  437,  902,  320,  567, 1568,  364,  320,\n+ \/*   880 *\/   567,  412,  329, 1029,  519, 1188,    3, 1028,  134,  134,\n+ \/*   890 *\/   134,  134,  133,  133,  132,  132,  132,  131,  128,  451,\n+ \/*   900 *\/  1659,  399, 1169,  307,  893,  307,  515,  576,  413,  214,\n+ \/*   910 *\/   498,  944, 1024,  540,  903, 1169,  943,  392, 1169, 1028,\n+ \/*   920 *\/  1028, 1030,  406,  298, 1204,   50, 1149, 1658,  413, 1658,\n+ \/*   930 *\/   145,  145,  137,  138,   91,  293, 1228, 1228, 1063, 1066,\n+ \/*   940 *\/  1053, 1053,  135,  135,  136,  136,  136,  136, 1188, 1147,\n+ \/*   950 *\/   514, 1568,  137,  138,   91, 1505, 1228, 1228, 1063, 1066,\n+ \/*   960 *\/  1053, 1053,  135,  135,  136,  136,  136,  136,  434,  323,\n+ \/*   970 *\/   435,  539,  111, 1506,  274,  291,  372,  517,  367,  516,\n+ \/*   980 *\/   262, 1204, 1205, 1204, 1574,  481,  363,  576,    7, 1569,\n+ \/*   990 *\/  1568,  377,  134,  134,  134,  134,  133,  133,  132,  132,\n+ \/*  1000 *\/   132,  131,  128,  451, 1568,  576, 1147,  576,  232,  576,\n+ \/*  1010 *\/    19,   19,  134,  134,  134,  134,  133,  133,  132,  132,\n+ \/*  1020 *\/   132,  131,  128,  451, 1169,  433,  576, 1207,   19,   19,\n+ \/*  1030 *\/    19,   19,   19,   19, 1627,  576,  911, 1169,   47,  120,\n+ \/*  1040 *\/  1169,  117,  413,  306,  498,  438, 1125,  206,  336,   19,\n+ \/*  1050 *\/    19, 1435,   49,  449,  449,  449, 1368,  315,   81,   81,\n+ \/*  1060 *\/   576,  304,  413, 1570,  207,  377,  137,  138,   91,  115,\n+ \/*  1070 *\/  1228, 1228, 1063, 1066, 1053, 1053,  135,  135,  136,  136,\n+ \/*  1080 *\/   136,  136,  576,   82,   82, 1207,  137,  138,   91, 1340,\n+ \/*  1090 *\/  1228, 1228, 1063, 1066, 1053, 1053,  135,  135,  136,  136,\n+ \/*  1100 *\/   136,  136, 1569,  386,  377,   82,   82,  463, 1126, 1552,\n+ \/*  1110 *\/   333,  463,  335,  131,  128,  451, 1569,  161,  377,   16,\n+ \/*  1120 *\/   317,  387,  428, 1127,  448,  447,  134,  134,  134,  134,\n+ \/*  1130 *\/   133,  133,  132,  132,  132,  131,  128,  451, 1128,  576,\n+ \/*  1140 *\/  1105,   10,  445,  267,  576, 1554,  134,  134,  134,  134,\n+ \/*  1150 *\/   133,  133,  132,  132,  132,  131,  128,  451,  532,  576,\n+ \/*  1160 *\/   922,  576,   19,   19,  576, 1573,  576,  147,  147,    7,\n+ \/*  1170 *\/   923, 1236,  498, 1236,  576,  487,  413,  552,  285, 1224,\n+ \/*  1180 *\/   969,  215,   82,   82,   66,   66, 1435,   67,   67,   21,\n+ \/*  1190 *\/    21, 1110, 1110,  495,  334,  297,  413,   53,   53,  297,\n+ \/*  1200 *\/   137,  138,   91,  119, 1228, 1228, 1063, 1066, 1053, 1053,\n+ \/*  1210 *\/   135,  135,  136,  136,  136,  136,  413, 1336, 1311,  446,\n+ \/*  1220 *\/   137,  138,   91,  227, 1228, 1228, 1063, 1066, 1053, 1053,\n+ \/*  1230 *\/   135,  135,  136,  136,  136,  136,  574, 1224,  936,  936,\n+ \/*  1240 *\/   137,  126,   91,  141, 1228, 1228, 1063, 1066, 1053, 1053,\n+ \/*  1250 *\/   135,  135,  136,  136,  136,  136,  533,  429,  472,  346,\n+ \/*  1260 *\/   134,  134,  134,  134,  133,  133,  132,  132,  132,  131,\n+ \/*  1270 *\/   128,  451,  576,  457,  233,  343, 1435,  403,  498, 1550,\n+ \/*  1280 *\/   134,  134,  134,  134,  133,  133,  132,  132,  132,  131,\n+ \/*  1290 *\/   128,  451,  576,  324,  576,   82,   82,  487,  576,  969,\n+ \/*  1300 *\/   134,  134,  134,  134,  133,  133,  132,  132,  132,  131,\n+ \/*  1310 *\/   128,  451,  288,  288,  546,   68,   68,   54,   54,  553,\n+ \/*  1320 *\/   413,   69,   69,  351,    6,  573,  944,  562,  410,  409,\n+ \/*  1330 *\/  1435,  943,  450,  545,  260,  259,  258,  576,  158,  576,\n+ \/*  1340 *\/   413,  222, 1180,  479,  969,  138,   91,  430, 1228, 1228,\n+ \/*  1350 *\/  1063, 1066, 1053, 1053,  135,  135,  136,  136,  136,  136,\n+ \/*  1360 *\/    70,   70,   71,   71,  576, 1126,   91,  576, 1228, 1228,\n+ \/*  1370 *\/  1063, 1066, 1053, 1053,  135,  135,  136,  136,  136,  136,\n+ \/*  1380 *\/  1127,  166,  850,  851,  852, 1282,  419,   72,   72,  108,\n+ \/*  1390 *\/    73,   73, 1310,  358, 1180, 1128,  576,  305,  576,  123,\n+ \/*  1400 *\/   568,  494,    4,  488,  134,  134,  134,  134,  133,  133,\n+ \/*  1410 *\/   132,  132,  132,  131,  128,  451,  571,  564,  534,   55,\n+ \/*  1420 *\/    55,   56,   56,  576,  134,  134,  134,  134,  133,  133,\n+ \/*  1430 *\/   132,  132,  132,  131,  128,  451,  576, 1104,  233, 1104,\n+ \/*  1440 *\/   452, 1602,  582,    2, 1259,  576,   57,   57,  576,  321,\n+ \/*  1450 *\/   576,  155,  565, 1435,  485,  353,  576,  356, 1341,   59,\n+ \/*  1460 *\/    59,  576,   44,  969,  569,  419,  576,  238,   60,   60,\n+ \/*  1470 *\/   261,   74,   74,   75,   75,  287,  231,  576, 1366,   76,\n+ \/*  1480 *\/    76, 1040,  420,  184,   20,   20,  576,  121,  121,   77,\n+ \/*  1490 *\/    77,   97,  218,  288,  288,  122,  125,  452,  577,  452,\n+ \/*  1500 *\/   143,  143, 1028,  576,  520,  576,  573,  576,  562,  144,\n+ \/*  1510 *\/   144,  474,  227, 1244,  478,  123,  568,  576,    4,  320,\n+ \/*  1520 *\/   567,  245,  411,  576,  443,  411,   78,   78,   62,   62,\n+ \/*  1530 *\/    79,   79,  571,  319, 1028, 1028, 1030, 1031,   35,  418,\n+ \/*  1540 *\/    63,   63,  576,  290,  411,    9,   80,   80, 1144,  576,\n+ \/*  1550 *\/   400,  576,  486,  455,  576, 1223,  452,  576,  325,  342,\n+ \/*  1560 *\/   576,  111,  576, 1188,  242,   64,   64,  473,  565,  576,\n+ \/*  1570 *\/    23,  576,  170,  170,  171,  171,  576,   87,   87,  328,\n+ \/*  1580 *\/    65,   65,  542,   83,   83,  146,  146,  541,  123,  568,\n+ \/*  1590 *\/   341,    4,   84,   84,  168,  168,  576, 1040,  576,  148,\n+ \/*  1600 *\/   148,  576, 1380,  121,  121,  571, 1021,  576,  266,  576,\n+ \/*  1610 *\/   424,  122,  576,  452,  577,  452,  576,  553, 1028,  142,\n+ \/*  1620 *\/   142,  169,  169,  576,  162,  162,  528,  889,  371,  452,\n+ \/*  1630 *\/   152,  152,  151,  151, 1379,  149,  149,  109,  370,  150,\n+ \/*  1640 *\/   150,  565,  576,  480,  576,  266,   86,   86,  576, 1092,\n+ \/*  1650 *\/  1028, 1028, 1030, 1031,   35,  542,  482,  576,  266,  466,\n+ \/*  1660 *\/   543,  123,  568, 1616,    4,   88,   88,   85,   85,  475,\n+ \/*  1670 *\/  1040,   52,   52,  222,  901,  900,  121,  121,  571, 1188,\n+ \/*  1680 *\/    58,   58,  244, 1032,  122,  889,  452,  577,  452,  908,\n+ \/*  1690 *\/   909, 1028,  300,  347,  504,  111,  263,  361,  165,  111,\n+ \/*  1700 *\/   111, 1088,  452,  263,  974, 1153,  266, 1092,  986,  987,\n+ \/*  1710 *\/   942,  939,  125,  125,  565, 1103,  872, 1103,  159,  941,\n+ \/*  1720 *\/  1309,  125, 1557, 1028, 1028, 1030, 1031,   35,  542,  337,\n+ \/*  1730 *\/  1530,  205, 1529,  541,  499, 1589,  490,  348, 1376,  352,\n+ \/*  1740 *\/   355, 1032,  357, 1040,  359, 1324, 1308,  366,  563,  121,\n+ \/*  1750 *\/   121,  376, 1188, 1389, 1434, 1362,  280,  122, 1374,  452,\n+ \/*  1760 *\/   577,  452,  167, 1439, 1028, 1289, 1280, 1268, 1267, 1269,\n+ \/*  1770 *\/  1609, 1359,  312,  313,  314,  397,   12,  237,  224, 1421,\n+ \/*  1780 *\/   295, 1416, 1409, 1426,  339,  484,  340,  509, 1371, 1612,\n+ \/*  1790 *\/  1372, 1425, 1244,  404,  301,  228, 1028, 1028, 1030, 1031,\n+ \/*  1800 *\/    35, 1601, 1192,  454,  345, 1307,  292,  369, 1502, 1501,\n+ \/*  1810 *\/   270,  396,  396,  395,  277,  393, 1370, 1369,  859, 1549,\n+ \/*  1820 *\/   186,  123,  568,  235,    4, 1188,  391,  210,  211,  223,\n+ \/*  1830 *\/  1547,  239, 1241,  327,  422,   96,  220,  195,  571,  180,\n+ \/*  1840 *\/   188,  326,  468,  469,  190,  191,  502,  192,  193,  566,\n+ \/*  1850 *\/   247,  109, 1430,  491,  199,  251,  102,  281,  402,  476,\n+ \/*  1860 *\/   405, 1496,  452,  497,  253, 1422,   13, 1428,   14, 1427,\n+ \/*  1870 *\/   203, 1507,  241,  500,  565,  354,  407,   92,   95, 1270,\n+ \/*  1880 *\/   175,  254,  518,   43, 1327,  255, 1326, 1325,  436, 1518,\n+ \/*  1890 *\/   350, 1318,  104,  229,  893, 1626,  440,  441, 1625,  408,\n+ \/*  1900 *\/   240, 1296,  268, 1040,  310,  269, 1297,  527,  444,  121,\n+ \/*  1910 *\/   121,  368, 1295, 1594, 1624,  311, 1394,  122, 1317,  452,\n+ \/*  1920 *\/   577,  452,  374, 1580, 1028, 1393,  140,  553,   11,   90,\n+ \/*  1930 *\/   568,  385,    4,  116,  318,  414, 1579,  110, 1483,  537,\n+ \/*  1940 *\/   320,  567, 1350,  555,   42,  579,  571, 1349, 1198,  383,\n+ \/*  1950 *\/   276,  390,  216,  389,  278,  279, 1028, 1028, 1030, 1031,\n+ \/*  1960 *\/    35,  172,  580, 1265,  458, 1260,  415,  416,  185,  156,\n+ \/*  1970 *\/   452, 1534, 1535,  173, 1533, 1532,   89,  308,  225,  226,\n+ \/*  1980 *\/   846,  174,  565,  453,  217, 1188,  322,  236, 1102,  154,\n+ \/*  1990 *\/  1100,  330,  187,  176, 1223,  243,  189,  925,  338,  246,\n+ \/*  2000 *\/  1116,  194,  177,  425,  178,  427,   98,  196,   99,  100,\n+ \/*  2010 *\/   101, 1040,  179, 1119, 1115,  248,  249,  121,  121,  163,\n+ \/*  2020 *\/    24,  250,  349, 1238,  496,  122, 1108,  452,  577,  452,\n+ \/*  2030 *\/  1192,  454, 1028,  266,  292,  200,  252,  201,  861,  396,\n+ \/*  2040 *\/   396,  395,  277,  393,   15,  501,  859,  370,  292,  256,\n+ \/*  2050 *\/   202,  554,  505,  396,  396,  395,  277,  393,  103,  239,\n+ \/*  2060 *\/   859,  327,   25,   26, 1028, 1028, 1030, 1031,   35,  326,\n+ \/*  2070 *\/   362,  510,  891,  239,  365,  327,  513,  904,  105,  309,\n+ \/*  2080 *\/   164,  181,   27,  326,  106,  521,  107, 1185, 1069, 1155,\n+ \/*  2090 *\/    17, 1154,  230, 1188,  284,  286,  265,  204,  125, 1171,\n+ \/*  2100 *\/   241,   28,  978,  972,   29,   41, 1175, 1179,  175, 1173,\n+ \/*  2110 *\/    30,   43,   31,    8,  241, 1178,   32, 1160,  208,  549,\n+ \/*  2120 *\/    33,  111,  175, 1083, 1070,   43, 1068, 1072,  240,  113,\n+ \/*  2130 *\/   114,   34,  561,  118, 1124,  271, 1073,   36,   18,  572,\n+ \/*  2140 *\/  1033,  873,  240,  124,   37,  935,  272,  273, 1617,  183,\n+ \/*  2150 *\/   153,  394, 1194, 1193, 1256, 1256, 1256, 1256, 1256, 1256,\n+ \/*  2160 *\/  1256, 1256, 1256,  414, 1256, 1256, 1256, 1256,  320,  567,\n+ \/*  2170 *\/  1256, 1256, 1256, 1256, 1256, 1256, 1256,  414, 1256, 1256,\n+ \/*  2180 *\/  1256, 1256,  320,  567, 1256, 1256, 1256, 1256, 1256, 1256,\n+ \/*  2190 *\/  1256, 1256,  458, 1256, 1256, 1256, 1256, 1256, 1256, 1256,\n+ \/*  2200 *\/  1256, 1256, 1256, 1256, 1256, 1256,  458,\n@@ -171933,229 +175053,240 @@\n- \/*     0 *\/   193,  193,  193,  274,  275,  276,  193,  274,  275,  276,\n- \/*    10 *\/   193,  223,  219,  225,  206,  210,  211,  212,  193,   19,\n- \/*    20 *\/   219,  233,  216,  216,  217,  216,  217,  193,  295,  216,\n- \/*    30 *\/   217,   31,  193,  216,  217,  193,  228,  213,  230,   39,\n- \/*    40 *\/   206,  216,  217,   43,   44,   45,   46,   47,   48,   49,\n- \/*    50 *\/    50,   51,   52,   53,   54,   55,   56,   57,  193,   19,\n- \/*    60 *\/   185,  186,  187,  188,  189,  190,  253,  274,  275,  276,\n- \/*    70 *\/   195,  193,  197,  193,  261,  274,  275,  276,  253,  204,\n- \/*    80 *\/   238,  204,   81,   43,   44,   45,   46,   47,   48,   49,\n- \/*    90 *\/    50,   51,   52,   53,   54,   55,   56,   57,  274,  275,\n- \/*   100 *\/   276,  262,  102,  103,  104,  105,  106,  107,  108,  109,\n- \/*   110 *\/   110,  111,  112,  113,  239,  240,  239,  240,  210,  211,\n- \/*   120 *\/   212,  314,  315,  314,   59,  316,   86,  252,   88,  252,\n- \/*   130 *\/    19,  314,  315,  256,  257,  113,   25,   72,  296,  138,\n- \/*   140 *\/   139,  266,  102,  103,  104,  105,  106,  107,  108,  109,\n- \/*   150 *\/   110,  111,  112,  113,   43,   44,   45,   46,   47,   48,\n- \/*   160 *\/    49,   50,   51,   52,   53,   54,   55,   56,   57,   81,\n- \/*   170 *\/   292,   59,  292,  298,  108,  109,  110,  111,  112,  113,\n- \/*   180 *\/    69,  116,  117,  118,   72,  106,  107,  193,  111,  112,\n- \/*   190 *\/   113,   54,   55,   56,   57,   58,  102,  103,  104,  105,\n- \/*   200 *\/   106,  107,  108,  109,  110,  111,  112,  113,  120,   25,\n- \/*   210 *\/   216,  217,  145,  102,  103,  104,  105,  106,  107,  108,\n- \/*   220 *\/   109,  110,  111,  112,  113,  231,  138,  139,  116,  117,\n- \/*   230 *\/   118,  164,  153,   19,  155,   54,   55,   56,   57,  102,\n- \/*   240 *\/   103,  104,  105,  106,  107,  108,  109,  110,  111,  112,\n- \/*   250 *\/   113,  128,  129,   46,   47,   48,   49,   43,   44,   45,\n- \/*   260 *\/    46,   47,   48,   49,   50,   51,   52,   53,   54,   55,\n- \/*   270 *\/    56,   57,  216,  193,   25,   59,  193,   19,  165,  166,\n- \/*   280 *\/   193,   67,   24,  102,  103,  104,  105,  106,  107,  108,\n- \/*   290 *\/   109,  110,  111,  112,  113,   73,  216,  217,   59,  216,\n- \/*   300 *\/   217,   43,   44,   45,   46,   47,   48,   49,   50,   51,\n- \/*   310 *\/    52,   53,   54,   55,   56,   57,  102,  103,  104,  105,\n- \/*   320 *\/   106,  107,  108,  109,  110,  111,  112,  113,  121,  145,\n- \/*   330 *\/    59,  193,  116,  117,  118,  119,  273,  204,  122,  123,\n- \/*   340 *\/   124,   19,   20,  134,   22,  136,  137,   19,  132,  127,\n- \/*   350 *\/   128,  129,   24,   22,   23,  116,  117,  118,   36,  193,\n- \/*   360 *\/   102,  103,  104,  105,  106,  107,  108,  109,  110,  111,\n- \/*   370 *\/   112,  113,  239,  240,  311,  312,  215,  106,  107,  241,\n- \/*   380 *\/    19,   59,  216,  217,  223,  252,  115,  116,  117,  118,\n- \/*   390 *\/   151,  120,   26,   71,  193,  308,  309,  193,  149,  128,\n- \/*   400 *\/   313,  216,  269,   81,   43,   44,   45,   46,   47,   48,\n- \/*   410 *\/    49,   50,   51,   52,   53,   54,   55,   56,   57,  253,\n- \/*   420 *\/   216,  217,  100,   95,  153,   59,  155,  261,  106,  107,\n- \/*   430 *\/    25,  193,  101,  193,  193,  231,  114,   25,  116,  117,\n- \/*   440 *\/   118,  113,  304,  121,  193,  204,   59,  119,  120,  121,\n- \/*   450 *\/   122,  123,  124,  125,  216,  217,  193,  216,  217,  131,\n- \/*   460 *\/   138,  139,  230,  102,  103,  104,  105,  106,  107,  108,\n- \/*   470 *\/   109,  110,  111,  112,  113,  153,  154,  155,  156,  157,\n- \/*   480 *\/   239,  240,  116,  117,  118,   76,  193,   23,   19,   25,\n- \/*   490 *\/    22,  253,   23,  252,  253,  108,   87,  204,   89,  261,\n- \/*   500 *\/   198,   92,  261,  116,  117,  118,  193,  306,  307,  216,\n- \/*   510 *\/   217,  150,   43,   44,   45,   46,   47,   48,   49,   50,\n- \/*   520 *\/    51,   52,   53,   54,   55,   56,   57,   59,  193,  216,\n- \/*   530 *\/   217,   19,  239,  240,  283,   23,  106,  107,  108,  109,\n- \/*   540 *\/   110,  111,  112,  113,   73,  252,  253,  142,  308,  309,\n- \/*   550 *\/   138,  139,   81,  313,  145,   43,   44,   45,   46,   47,\n- \/*   560 *\/    48,   49,   50,   51,   52,   53,   54,   55,   56,   57,\n- \/*   570 *\/   307,  102,  103,  104,  105,  106,  107,  108,  109,  110,\n- \/*   580 *\/   111,  112,  113,  281,  116,  117,  118,  285,   23,  193,\n- \/*   590 *\/    25,  119,   59,  193,  122,  123,  124,   59,  127,  203,\n- \/*   600 *\/    59,  205,   19,  268,  132,   25,   23,   22,  193,  138,\n- \/*   610 *\/   139,  249,  204,  251,  102,  103,  104,  105,  106,  107,\n- \/*   620 *\/   108,  109,  110,  111,  112,  113,   43,   44,   45,   46,\n- \/*   630 *\/    47,   48,   49,   50,   51,   52,   53,   54,   55,   56,\n- \/*   640 *\/    57,   19,   22,   23,   59,   23,   25,  239,  240,  116,\n- \/*   650 *\/   117,  118,  193,   11,  116,  117,  118,  116,  117,  118,\n- \/*   660 *\/   252,  269,   22,  193,   15,   43,   44,   45,   46,   47,\n- \/*   670 *\/    48,   49,   50,   51,   52,   53,   54,   55,   56,   57,\n- \/*   680 *\/   273,  143,  193,  118,  143,  102,  103,  104,  105,  106,\n- \/*   690 *\/   107,  108,  109,  110,  111,  112,  113,   76,  118,   59,\n- \/*   700 *\/   241,  116,  117,  118,  304,  216,  217,  292,  143,   60,\n- \/*   710 *\/    89,  241,   19,   92,  193,  193,   23,   22,  311,  312,\n- \/*   720 *\/   231,  101,   22,  143,  102,  103,  104,  105,  106,  107,\n- \/*   730 *\/   108,  109,  110,  111,  112,  113,   43,   44,   45,   46,\n- \/*   740 *\/    47,   48,   49,   50,   51,   52,   53,   54,   55,   56,\n- \/*   750 *\/    57,   19,  193,  193,   59,   23,  116,  117,  118,   59,\n- \/*   760 *\/   201,   21,  241,  304,  193,  206,  127,  128,  129,  193,\n- \/*   770 *\/   128,  129,  235,  236,  304,   43,   44,   45,   46,   47,\n- \/*   780 *\/    48,   49,   50,   51,   52,   53,   54,   55,   56,   57,\n- \/*   790 *\/    22,  193,  216,  217,  193,  102,  103,  104,  105,  106,\n- \/*   800 *\/   107,  108,  109,  110,  111,  112,  113,  231,  193,  193,\n- \/*   810 *\/   193,  116,  117,  118,  216,  217,  116,  117,  118,  226,\n- \/*   820 *\/    80,  193,   19,  235,  236,  304,   23,  211,  212,  231,\n- \/*   830 *\/   204,  216,  217,  205,  102,  103,  104,  105,  106,  107,\n- \/*   840 *\/   108,  109,  110,  111,  112,  113,   43,   44,   45,   46,\n- \/*   850 *\/    47,   48,   49,   50,   51,   52,   53,   54,   55,   56,\n- \/*   860 *\/    57,   19,  193,  123,   76,  239,  240,  193,  253,  239,\n- \/*   870 *\/   240,  239,  240,  244,  106,  107,  193,   89,  252,  193,\n- \/*   880 *\/    92,   59,  252,  254,  252,   43,   44,   45,   46,   47,\n- \/*   890 *\/    48,   49,   50,   51,   52,   53,   54,   55,   56,   57,\n- \/*   900 *\/   284,  161,  216,  217,  193,  102,  103,  104,  105,  106,\n- \/*   910 *\/   107,  108,  109,  110,  111,  112,  113,  231,  193,  244,\n- \/*   920 *\/   187,  188,  189,  190,    7,    8,    9,  309,  195,  254,\n- \/*   930 *\/   197,  313,   19,  127,  128,  129,  262,  204,   22,  117,\n- \/*   940 *\/    24,  216,  217,  273,  102,  103,  104,  105,  106,  107,\n- \/*   950 *\/   108,  109,  110,  111,  112,  113,   43,   44,   45,   46,\n- \/*   960 *\/    47,   48,   49,   50,   51,   52,   53,   54,   55,   56,\n- \/*   970 *\/    57,  193,  239,  240,  193,   59,   19,  188,  253,  190,\n- \/*   980 *\/   193,  311,  312,   16,  195,  252,  197,  193,   19,  301,\n- \/*   990 *\/   302,  135,  193,  204,  216,  217,  140,  216,  217,  266,\n- \/*  1000 *\/   204,  159,   45,   46,   47,   48,   49,   50,   51,   52,\n- \/*  1010 *\/    53,   54,   55,   56,   57,  102,  103,  104,  105,  106,\n- \/*  1020 *\/   107,  108,  109,  110,  111,  112,  113,   12,  239,  240,\n- \/*  1030 *\/   193,  298,  238,  117,  253,  239,  240,  238,  259,  260,\n- \/*  1040 *\/   193,  252,   27,  193,   77,  193,   79,  204,  252,  262,\n- \/*  1050 *\/   193,  299,  300,  193,  100,  266,  278,   42,  204,  102,\n- \/*  1060 *\/   103,  104,  105,  106,  107,  108,  109,  110,  111,  112,\n- \/*  1070 *\/   113,  117,  159,  216,  217,  121,  216,  217,   63,  193,\n- \/*  1080 *\/   193,  193,  239,  240,  115,  116,  193,  298,   73,  240,\n- \/*  1090 *\/   238,  231,   19,  239,  240,  252,   22,   24,  211,  212,\n- \/*  1100 *\/   263,  252,  216,  217,  216,  217,  252,  153,  154,  155,\n- \/*  1110 *\/   253,  193,   19,  144,  213,  268,   43,   44,   45,   46,\n- \/*  1120 *\/    47,   48,   49,   50,   51,   52,   53,   54,   55,   56,\n- \/*  1130 *\/    57,  193,   19,   59,  216,  217,   43,   44,   45,   46,\n- \/*  1140 *\/    47,   48,   49,   50,   51,   52,   53,   54,   55,   56,\n- \/*  1150 *\/    57,  193,   19,   24,  216,  217,   43,   44,   45,   46,\n- \/*  1160 *\/    47,   48,   49,   50,   51,   52,   53,   54,   55,   56,\n- \/*  1170 *\/    57,  284,  193,  208,  209,  102,  103,  104,  105,  106,\n- \/*  1180 *\/   107,  108,  109,  110,  111,  112,  113,  286,   59,  193,\n- \/*  1190 *\/   232,  117,  291,  193,  193,  102,  103,  104,  105,  106,\n- \/*  1200 *\/   107,  108,  109,  110,  111,  112,  113,  193,  204,   22,\n- \/*  1210 *\/    23,  193,   25,   66,  193,  102,  103,  104,  105,  106,\n- \/*  1220 *\/   107,  108,  109,  110,  111,  112,  113,  193,  193,  193,\n- \/*  1230 *\/   216,  217,   85,  193,  238,   19,   16,  216,  217,  238,\n- \/*  1240 *\/   193,   94,  193,  239,  240,  231,  117,  268,   35,  116,\n- \/*  1250 *\/   216,  217,  216,  217,   22,   23,  252,   25,  208,  209,\n- \/*  1260 *\/    44,   45,   46,   47,   48,   49,   50,   51,   52,   53,\n- \/*  1270 *\/    54,   55,   56,   57,  193,  193,   19,    5,   59,   66,\n- \/*  1280 *\/   193,  263,   10,   11,   12,   13,   14,   74,  101,   17,\n- \/*  1290 *\/   193,   46,  193,  146,  193,   76,  213,   77,  263,   79,\n- \/*  1300 *\/    12,  260,   30,   46,   32,  264,   87,  193,   89,   29,\n- \/*  1310 *\/   263,   92,   40,   33,  232,   27,  193,  108,  102,  103,\n- \/*  1320 *\/   104,  105,  106,  107,  108,  109,  110,  111,  112,  113,\n- \/*  1330 *\/    42,  138,  139,  101,  193,  116,  117,  118,   19,   20,\n- \/*  1340 *\/   255,   22,   70,  130,  135,   65,  256,  257,  193,  140,\n- \/*  1350 *\/    78,   63,  193,   81,  193,   36,  193,  216,  217,  193,\n- \/*  1360 *\/   115,  193,  263,  193,  145,  268,   59,   48,  193,  193,\n- \/*  1370 *\/    98,  193,  115,  193,  291,  216,  217,  193,   59,  216,\n- \/*  1380 *\/   217,  161,  216,  217,  216,  217,  216,  217,  131,  193,\n- \/*  1390 *\/    71,  193,  216,  217,  216,  217,  216,  217,  193,  260,\n- \/*  1400 *\/   216,  217,   19,  264,   85,  133,  244,  100,  193,   90,\n- \/*  1410 *\/   138,  139,  216,  217,  216,  217,  254,  244,  193,  100,\n- \/*  1420 *\/   193,  216,  217,  116,  117,  106,  107,  254,  121,  193,\n- \/*  1430 *\/   115,  216,  217,  114,  162,  116,  117,  118,  115,  244,\n- \/*  1440 *\/   121,  216,  217,  216,  217,  193,  309,  193,   31,  254,\n- \/*  1450 *\/   313,  309,  216,  217,  309,  313,   39,  193,  313,  309,\n- \/*  1460 *\/   153,  154,  155,  313,  193,  150,   25,  144,  216,  217,\n- \/*  1470 *\/   216,  217,  153,  154,  155,  156,  157,    0,    1,    2,\n- \/*  1480 *\/   216,  217,    5,  149,  150,   22,  193,   10,   11,   12,\n- \/*  1490 *\/    13,   14,  193,  158,   17,  160,  193,   19,   20,  116,\n- \/*  1500 *\/    22,   25,  193,   24,   22,  193,   24,   30,  226,   32,\n- \/*  1510 *\/    19,   20,  226,   22,   36,  193,   53,   40,  193,  216,\n- \/*  1520 *\/   217,  193,   23,  193,   25,  216,  217,   36,  216,  217,\n- \/*  1530 *\/   193,   99,  193,  193,   22,  193,  193,   59,  216,  217,\n- \/*  1540 *\/   193,  216,  217,  193,  216,  217,  193,   70,  129,   71,\n- \/*  1550 *\/    59,  129,  193,  216,  217,   78,  216,  217,   81,  216,\n- \/*  1560 *\/   217,  193,   71,   85,  193,  133,  193,  126,   90,  216,\n- \/*  1570 *\/   217,  152,  258,   61,  152,   98,   85,  193,  100,  193,\n- \/*  1580 *\/    23,   90,   25,  121,  106,  107,   23,  216,  217,  216,\n- \/*  1590 *\/   217,  100,  114,  131,  116,  117,  118,  106,  107,  121,\n- \/*  1600 *\/   216,  217,  216,  217,  193,  114,  193,  116,  117,  118,\n- \/*  1610 *\/   133,   22,  121,  193,   59,  138,  139,  193,  142,  193,\n- \/*  1620 *\/   141,   23,   23,   25,   25,  120,  121,  216,  217,  216,\n- \/*  1630 *\/   217,  153,  154,  155,  156,  157,  216,  217,   19,  162,\n- \/*  1640 *\/   216,  217,  216,  217,  153,  154,  155,  156,  157,    1,\n- \/*  1650 *\/     2,  193,   59,    5,   19,   20,  318,   22,   10,   11,\n- \/*  1660 *\/    12,   13,   14,  193,   59,   17,  193,   23,   23,   25,\n- \/*  1670 *\/    25,   36,  117,  193,  216,  217,  193,   23,   30,   25,\n- \/*  1680 *\/    32,   19,   20,   23,   22,   25,  216,  217,   40,  216,\n- \/*  1690 *\/   217,    7,    8,   23,   59,   25,   83,   84,   36,   23,\n- \/*  1700 *\/   193,   25,   23,   23,   25,   25,   71,  153,  145,  155,\n- \/*  1710 *\/   117,  153,   23,  155,   25,   23,   97,   25,   70,  193,\n- \/*  1720 *\/   193,   59,  117,  236,  193,  193,   78,  193,  193,   81,\n- \/*  1730 *\/   141,  193,  193,   71,  193,  100,  288,  287,  242,  255,\n- \/*  1740 *\/   255,  106,  107,  108,  255,  255,   98,  243,  297,  114,\n- \/*  1750 *\/   214,  116,  117,  118,  245,  191,  121,  271,  293,  267,\n- \/*  1760 *\/   267,  246,  100,  246,  245,  271,  271,  293,  106,  107,\n- \/*  1770 *\/   220,  271,  229,  225,  249,  219,  114,  259,  116,  117,\n- \/*  1780 *\/   118,  133,  259,  121,  219,  219,  138,  139,  153,  154,\n- \/*  1790 *\/   155,  156,  157,  280,  249,  243,   19,   20,  245,   22,\n- \/*  1800 *\/   196,  259,  140,  259,   60,  297,  141,  297,  200,  200,\n- \/*  1810 *\/   162,   38,  200,   36,  294,  153,  154,  155,  156,  157,\n- \/*  1820 *\/   151,  150,  294,  283,   22,   43,  234,   18,  237,  200,\n- \/*  1830 *\/   270,  272,  237,  237,  237,   18,   59,  199,  270,  149,\n- \/*  1840 *\/   246,  272,  272,  200,  234,  234,  246,  246,   71,  246,\n- \/*  1850 *\/   199,  158,  290,   62,   22,  200,   19,   20,  199,   22,\n- \/*  1860 *\/   289,  221,  221,  200,  200,  199,  199,  115,  218,   64,\n- \/*  1870 *\/   218,  218,   22,   36,  227,  126,  227,  100,  165,  221,\n- \/*  1880 *\/   224,  224,   24,  106,  107,  312,  218,  305,  113,  282,\n- \/*  1890 *\/    91,  114,  220,  116,  117,  118,   59,  282,  121,  218,\n- \/*  1900 *\/   218,  218,  200,  317,  317,   82,  221,  265,   71,  148,\n- \/*  1910 *\/   145,  265,   22,  277,  200,  158,  279,  140,  147,   25,\n- \/*  1920 *\/   146,  202,  248,  250,  249,  247,   13,  250,  194,  194,\n- \/*  1930 *\/   153,  154,  155,  156,  157,    6,  303,  100,  192,  192,\n- \/*  1940 *\/   246,  213,  192,  106,  107,  207,  213,  207,  222,  213,\n- \/*  1950 *\/   213,  114,  222,  116,  117,  118,  214,  214,  121,    4,\n- \/*  1960 *\/   207,  213,    3,   22,  303,   15,  163,   16,   23,   23,\n- \/*  1970 *\/   139,  151,  130,   25,   20,  142,   24,   16,  144,    1,\n- \/*  1980 *\/   142,  130,  130,   61,   37,   53,  300,  151,   53,   53,\n- \/*  1990 *\/   153,  154,  155,  156,  157,   53,  130,  116,   34,    1,\n- \/*  2000 *\/   141,    5,   22,  115,  161,   68,   25,   68,   75,   41,\n- \/*  2010 *\/   141,  115,   24,   20,   19,  131,  125,   23,   28,   22,\n- \/*  2020 *\/    67,   22,   22,   22,   67,   59,   24,   96,   22,   67,\n- \/*  2030 *\/    23,  149,   22,   25,   23,   23,   23,   22,   34,  141,\n- \/*  2040 *\/    37,   97,   23,   23,  116,   22,  143,   25,   34,   75,\n- \/*  2050 *\/    34,   34,   34,   88,   75,   34,   86,   23,   22,   34,\n- \/*  2060 *\/    93,   24,   34,   25,   25,  142,  142,   23,   44,   23,\n- \/*  2070 *\/    23,   23,   23,   11,   23,   25,   22,   22,   22,  141,\n- \/*  2080 *\/    23,   23,   22,   22,   25,   15,    1,   23,   25,    1,\n- \/*  2090 *\/   141,  135,  319,  319,  319,  319,  319,  319,  319,  141,\n- \/*  2100 *\/   319,  319,  319,  319,  319,  319,  319,  319,  319,  319,\n- \/*  2110 *\/   319,  319,  319,  319,  319,  319,  319,  319,  319,  319,\n- \/*  2120 *\/   319,  319,  319,  319,  319,  319,  319,  319,  319,  319,\n- \/*  2130 *\/   319,  319,  319,  319,  319,  319,  319,  319,  319,  319,\n- \/*  2140 *\/   319,  319,  319,  319,  319,  319,  319,  319,  319,  319,\n- \/*  2150 *\/   319,  319,  319,  319,  319,  319,  319,  319,  319,  319,\n- \/*  2160 *\/   319,  319,  319,  319,  319,  319,  319,  319,  319,  319,\n- \/*  2170 *\/   319,  319,  319,  319,  319,  319,  319,  319,  319,  319,\n- \/*  2180 *\/   319,  319,  319,  319,  319,  319,  319,  319,  319,  319,\n- \/*  2190 *\/   319,  319,  319,  319,  319,  319,  319,  319,  319,  319,\n- \/*  2200 *\/   319,  319,  319,  319,  319,  319,  319,  319,  319,  319,\n- \/*  2210 *\/   319,  319,  319,  319,  319,  319,  319,  319,  319,  319,\n- \/*  2220 *\/   319,  319,  319,  319,  319,  319,  319,  319,  319,  319,\n- \/*  2230 *\/   319,  319,  319,  319,  319,  319,  319,  319,  319,  319,\n- \/*  2240 *\/   319,  319,  319,  319,  319,  319,  319,  319,  319,  319,\n- \/*  2250 *\/   319,  319,  319,  319,  319,  319,  319,  319,  319,  319,\n- \/*  2260 *\/   319,  319,  319,  319,  319,  319,  319,  319,  319,  319,\n- \/*  2270 *\/   319,  319,  319,  319,  319,  319,  319,  319,  319,  319,\n- \/*  2280 *\/   319,  319,  319,  319,  319,\n+ \/*     0 *\/   277,  278,  279,  241,  242,  225,  195,  227,  195,  241,\n+ \/*    10 *\/   242,  195,  217,  221,  195,  235,  254,  195,  256,   19,\n+ \/*    20 *\/   225,  298,  254,  195,  256,  206,  213,  214,  206,  218,\n+ \/*    30 *\/   219,   31,  206,  195,  218,  219,  195,  218,  219,   39,\n+ \/*    40 *\/   218,  219,  313,   43,   44,   45,  317,   47,   48,   49,\n+ \/*    50 *\/    50,   51,   52,   53,   54,   55,   56,   57,   58,   19,\n+ \/*    60 *\/   241,  242,  195,  241,  242,  195,  255,  241,  242,  277,\n+ \/*    70 *\/   278,  279,  234,  254,  255,  256,  254,  255,  256,  218,\n+ \/*    80 *\/   254,  240,  256,   43,   44,   45,  264,   47,   48,   49,\n+ \/*    90 *\/    50,   51,   52,   53,   54,   55,   56,   57,   58,  271,\n+ \/*   100 *\/   287,   22,   23,  103,  104,  105,  106,  107,  108,  109,\n+ \/*   110 *\/   110,  111,  112,  113,  114,  114,   47,   48,   49,   50,\n+ \/*   120 *\/   187,  188,  189,  190,  191,  192,  190,   87,  192,   89,\n+ \/*   130 *\/   197,   19,  199,  197,  318,  199,  320,   25,  195,  206,\n+ \/*   140 *\/   299,  271,  206,  103,  104,  105,  106,  107,  108,  109,\n+ \/*   150 *\/   110,  111,  112,  113,  114,   43,   44,   45,  195,   47,\n+ \/*   160 *\/    48,   49,   50,   51,   52,   53,   54,   55,   56,   57,\n+ \/*   170 *\/    58,   60,   21,  195,  241,  242,  215,  241,  242,  312,\n+ \/*   180 *\/   313,  102,   70,  205,  317,  207,  242,  254,   77,  256,\n+ \/*   190 *\/   254,  122,  256,   55,   56,   57,   58,   59,  254,   88,\n+ \/*   200 *\/   256,   90,  269,  240,   93,  269,  107,  108,  109,  110,\n+ \/*   210 *\/   111,  112,  113,  114,  271,  103,  104,  105,  106,  107,\n+ \/*   220 *\/   108,  109,  110,  111,  112,  113,  114,  313,  117,  118,\n+ \/*   230 *\/   119,  317,   81,  195,  301,   19,  195,  301,  277,  278,\n+ \/*   240 *\/   279,  103,  104,  105,  106,  107,  108,  109,  110,  111,\n+ \/*   250 *\/   112,  113,  114,   55,   56,   57,   58,  146,  195,   43,\n+ \/*   260 *\/    44,   45,   74,   47,   48,   49,   50,   51,   52,   53,\n+ \/*   270 *\/    54,   55,   56,   57,   58,  124,  195,   60,  109,  110,\n+ \/*   280 *\/   111,  112,  113,  114,   68,  195,  103,  104,  105,  106,\n+ \/*   290 *\/   107,  108,  109,  110,  111,  112,  113,  114,  208,  218,\n+ \/*   300 *\/   219,  103,  104,  105,  106,  107,  108,  109,  110,  111,\n+ \/*   310 *\/   112,  113,  114,  162,  233,   24,  128,  129,  130,  103,\n+ \/*   320 *\/   104,  105,  106,  107,  108,  109,  110,  111,  112,  113,\n+ \/*   330 *\/   114,  195,  195,  215,  117,  118,  119,  120,  195,   19,\n+ \/*   340 *\/   123,  124,  125,  207,   24,   74,  246,   60,  310,  311,\n+ \/*   350 *\/   133,   60,  311,   82,   22,  218,  219,  257,  195,   19,\n+ \/*   360 *\/    73,  218,  219,   43,   44,   45,  206,   47,   48,   49,\n+ \/*   370 *\/    50,   51,   52,   53,   54,   55,   56,   57,   58,   22,\n+ \/*   380 *\/    23,  218,  219,   43,   44,   45,   54,   47,   48,   49,\n+ \/*   390 *\/    50,   51,   52,   53,   54,   55,   56,   57,   58,  128,\n+ \/*   400 *\/    82,  241,  242,  195,  117,  118,  119,  289,   60,  118,\n+ \/*   410 *\/   139,  140,  294,  195,  254,  195,  256,  195,  255,  259,\n+ \/*   420 *\/   260,   73,   22,  103,  104,  105,  106,  107,  108,  109,\n+ \/*   430 *\/   110,  111,  112,  113,  114,  206,  218,  219,  218,  219,\n+ \/*   440 *\/   218,  219,  234,  103,  104,  105,  106,  107,  108,  109,\n+ \/*   450 *\/   110,  111,  112,  113,  114,  318,  319,  139,  140,  102,\n+ \/*   460 *\/    60,  318,  319,  221,   19,  117,  118,  119,   23,  195,\n+ \/*   470 *\/   241,  242,  313,  255,  206,  255,  317,  255,  206,  129,\n+ \/*   480 *\/   130,  206,  264,  254,  264,  256,  264,  195,   43,   44,\n+ \/*   490 *\/    45,  151,   47,   48,   49,   50,   51,   52,   53,   54,\n+ \/*   500 *\/    55,   56,   57,   58,  246,  213,  214,   19,   19,  241,\n+ \/*   510 *\/   242,  195,   23,  241,  242,  257,  241,  242,  118,  277,\n+ \/*   520 *\/   278,  279,  254,   29,  256,   60,  254,   33,  256,  254,\n+ \/*   530 *\/   206,  256,   43,   44,   45,  218,   47,   48,   49,   50,\n+ \/*   540 *\/    51,   52,   53,   54,   55,   56,   57,   58,  103,  104,\n+ \/*   550 *\/   105,  106,  107,  108,  109,  110,  111,  112,  113,  114,\n+ \/*   560 *\/    66,   19,  218,   60,  120,  241,  242,  123,  124,  125,\n+ \/*   570 *\/    60,  232,   77,   19,   20,   26,   22,  133,  254,  287,\n+ \/*   580 *\/   256,  265,  117,  118,  119,   90,  312,  313,   93,   47,\n+ \/*   590 *\/    36,  317,  103,  104,  105,  106,  107,  108,  109,  110,\n+ \/*   600 *\/   111,  112,  113,  114,  116,  117,  277,  278,  279,   60,\n+ \/*   610 *\/   107,  108,   19,  276,   60,   31,   23,  152,  195,  116,\n+ \/*   620 *\/   117,  118,  119,   39,  121,  276,   72,  117,  118,  119,\n+ \/*   630 *\/   166,  167,  129,  145,  237,  238,   43,   44,   45,  276,\n+ \/*   640 *\/    47,   48,   49,   50,   51,   52,   53,   54,   55,   56,\n+ \/*   650 *\/    57,   58,  315,  316,  144,  101,   19,  154,  116,  156,\n+ \/*   660 *\/    23,  107,  108,  109,  315,  316,  117,  118,  119,  115,\n+ \/*   670 *\/    60,  117,  118,  119,  132,  200,  122,   60,  315,  316,\n+ \/*   680 *\/    43,   44,   45,  272,   47,   48,   49,   50,   51,   52,\n+ \/*   690 *\/    53,   54,   55,   56,   57,   58,  103,  104,  105,  106,\n+ \/*   700 *\/   107,  108,  109,  110,  111,  112,  113,  114,  154,  155,\n+ \/*   710 *\/   156,  157,  158,  212,  213,  214,   22,  195,  101,   22,\n+ \/*   720 *\/    60,   19,   20,   60,   22,  139,  140,  117,  118,  119,\n+ \/*   730 *\/    22,  251,  195,  253,  117,  118,  195,  183,   36,  122,\n+ \/*   740 *\/   103,  104,  105,  106,  107,  108,  109,  110,  111,  112,\n+ \/*   750 *\/   113,  114,  195,  195,   60,  218,  219,   60,  195,  284,\n+ \/*   760 *\/    19,   25,   60,  288,   23,  237,  238,   22,   60,  109,\n+ \/*   770 *\/   233,  154,  155,  156,   72,  218,  219,  117,  118,  119,\n+ \/*   780 *\/   117,  118,  119,  116,   43,   44,   45,  265,   47,   48,\n+ \/*   790 *\/    49,   50,   51,   52,   53,   54,   55,   56,   57,   58,\n+ \/*   800 *\/   183,  243,   25,  101,   19,   60,  265,  144,   23,  107,\n+ \/*   810 *\/   108,  117,  118,  119,  117,  118,  119,  115,  151,  117,\n+ \/*   820 *\/   118,  119,   82,  195,  122,  117,  118,  119,   43,   44,\n+ \/*   830 *\/    45,  195,   47,   48,   49,   50,   51,   52,   53,   54,\n+ \/*   840 *\/    55,   56,   57,   58,  103,  104,  105,  106,  107,  108,\n+ \/*   850 *\/   109,  110,  111,  112,  113,  114,  154,  155,  156,  157,\n+ \/*   860 *\/   158,  121,  117,  118,  119,  307,  101,  309,  195,   22,\n+ \/*   870 *\/    23,  195,   25,   19,   35,  139,  140,  195,   24,  139,\n+ \/*   880 *\/   140,  208,  195,  118,  109,  183,   22,  122,  103,  104,\n+ \/*   890 *\/   105,  106,  107,  108,  109,  110,  111,  112,  113,  114,\n+ \/*   900 *\/   304,  305,   77,  230,  127,  232,   67,  195,   19,  195,\n+ \/*   910 *\/   195,  136,   23,   88,   75,   90,  141,  203,   93,  154,\n+ \/*   920 *\/   155,  156,  208,  295,   60,  243,   22,   23,   19,   25,\n+ \/*   930 *\/   218,  219,   43,   44,   45,  100,   47,   48,   49,   50,\n+ \/*   940 *\/    51,   52,   53,   54,   55,   56,   57,   58,  183,  102,\n+ \/*   950 *\/    96,  195,   43,   44,   45,  240,   47,   48,   49,   50,\n+ \/*   960 *\/    51,   52,   53,   54,   55,   56,   57,   58,  114,  134,\n+ \/*   970 *\/   131,  146,   25,  286,  120,  121,  122,  123,  124,  125,\n+ \/*   980 *\/   126,  117,  118,  119,  313,  195,  132,  195,  317,  307,\n+ \/*   990 *\/   195,  309,  103,  104,  105,  106,  107,  108,  109,  110,\n+ \/*  1000 *\/   111,  112,  113,  114,  195,  195,  102,  195,  195,  195,\n+ \/*  1010 *\/   218,  219,  103,  104,  105,  106,  107,  108,  109,  110,\n+ \/*  1020 *\/   111,  112,  113,  114,   77,  233,  195,   60,  218,  219,\n+ \/*  1030 *\/   218,  219,  218,  219,   23,  195,   25,   90,  243,  159,\n+ \/*  1040 *\/    93,  161,   19,  233,  195,  233,   23,  233,   16,  218,\n+ \/*  1050 *\/   219,  195,  243,  212,  213,  214,  262,  263,  218,  219,\n+ \/*  1060 *\/   195,  271,   19,  307,  233,  309,   43,   44,   45,  160,\n+ \/*  1070 *\/    47,   48,   49,   50,   51,   52,   53,   54,   55,   56,\n+ \/*  1080 *\/    57,   58,  195,  218,  219,  118,   43,   44,   45,  240,\n+ \/*  1090 *\/    47,   48,   49,   50,   51,   52,   53,   54,   55,   56,\n+ \/*  1100 *\/    57,   58,  307,  195,  309,  218,  219,  263,   12,  195,\n+ \/*  1110 *\/    78,  267,   80,  112,  113,  114,  307,   22,  309,   24,\n+ \/*  1120 *\/   255,  281,  266,   27,  107,  108,  103,  104,  105,  106,\n+ \/*  1130 *\/   107,  108,  109,  110,  111,  112,  113,  114,   42,  195,\n+ \/*  1140 *\/    11,   22,  255,   24,  195,  195,  103,  104,  105,  106,\n+ \/*  1150 *\/   107,  108,  109,  110,  111,  112,  113,  114,   19,  195,\n+ \/*  1160 *\/    64,  195,  218,  219,  195,  313,  195,  218,  219,  317,\n+ \/*  1170 *\/    74,  154,  195,  156,  195,  195,   19,  233,   23,   60,\n+ \/*  1180 *\/    25,   24,  218,  219,  218,  219,  195,  218,  219,  218,\n+ \/*  1190 *\/   219,  128,  129,  130,  162,  263,   19,  218,  219,  267,\n+ \/*  1200 *\/    43,   44,   45,  160,   47,   48,   49,   50,   51,   52,\n+ \/*  1210 *\/    53,   54,   55,   56,   57,   58,   19,  240,  228,  255,\n+ \/*  1220 *\/    43,   44,   45,   25,   47,   48,   49,   50,   51,   52,\n+ \/*  1230 *\/    53,   54,   55,   56,   57,   58,  135,  118,  137,  138,\n+ \/*  1240 *\/    43,   44,   45,   22,   47,   48,   49,   50,   51,   52,\n+ \/*  1250 *\/    53,   54,   55,   56,   57,   58,  117,  266,  129,  130,\n+ \/*  1260 *\/   103,  104,  105,  106,  107,  108,  109,  110,  111,  112,\n+ \/*  1270 *\/   113,  114,  195,  195,  119,  295,  195,  206,  195,  195,\n+ \/*  1280 *\/   103,  104,  105,  106,  107,  108,  109,  110,  111,  112,\n+ \/*  1290 *\/   113,  114,  195,  195,  195,  218,  219,  195,  195,  144,\n+ \/*  1300 *\/   103,  104,  105,  106,  107,  108,  109,  110,  111,  112,\n+ \/*  1310 *\/   113,  114,  241,  242,   67,  218,  219,  218,  219,  146,\n+ \/*  1320 *\/    19,  218,  219,  240,  215,  254,  136,  256,  107,  108,\n+ \/*  1330 *\/   195,  141,  255,   86,  128,  129,  130,  195,  165,  195,\n+ \/*  1340 *\/    19,  143,   95,  272,   25,   44,   45,  266,   47,   48,\n+ \/*  1350 *\/    49,   50,   51,   52,   53,   54,   55,   56,   57,   58,\n+ \/*  1360 *\/   218,  219,  218,  219,  195,   12,   45,  195,   47,   48,\n+ \/*  1370 *\/    49,   50,   51,   52,   53,   54,   55,   56,   57,   58,\n+ \/*  1380 *\/    27,   23,    7,    8,    9,  210,  211,  218,  219,  116,\n+ \/*  1390 *\/   218,  219,  228,   16,  147,   42,  195,  295,  195,   19,\n+ \/*  1400 *\/    20,  266,   22,  294,  103,  104,  105,  106,  107,  108,\n+ \/*  1410 *\/   109,  110,  111,  112,  113,  114,   36,   64,  145,  218,\n+ \/*  1420 *\/   219,  218,  219,  195,  103,  104,  105,  106,  107,  108,\n+ \/*  1430 *\/   109,  110,  111,  112,  113,  114,  195,  154,  119,  156,\n+ \/*  1440 *\/    60,  189,  190,  191,  192,  195,  218,  219,  195,  197,\n+ \/*  1450 *\/   195,  199,   72,  195,   19,   78,  195,   80,  206,  218,\n+ \/*  1460 *\/   219,  195,   82,  144,  210,  211,  195,   15,  218,  219,\n+ \/*  1470 *\/    47,  218,  219,  218,  219,  259,  260,  195,  261,  218,\n+ \/*  1480 *\/   219,  101,  302,  303,  218,  219,  195,  107,  108,  218,\n+ \/*  1490 *\/   219,  150,  151,  241,  242,  115,   25,  117,  118,  119,\n+ \/*  1500 *\/   218,  219,  122,  195,  146,  195,  254,  195,  256,  218,\n+ \/*  1510 *\/   219,  246,   25,   61,  246,   19,   20,  195,   22,  139,\n+ \/*  1520 *\/   140,  269,  257,  195,  266,  257,  218,  219,  218,  219,\n+ \/*  1530 *\/   218,  219,   36,  246,  154,  155,  156,  157,  158,  116,\n+ \/*  1540 *\/   218,  219,  195,   22,  257,   49,  218,  219,   23,  195,\n+ \/*  1550 *\/    25,  195,  117,  301,  195,   25,   60,  195,  195,   23,\n+ \/*  1560 *\/   195,   25,  195,  183,   24,  218,  219,  130,   72,  195,\n+ \/*  1570 *\/    22,  195,  218,  219,  218,  219,  195,  218,  219,  195,\n+ \/*  1580 *\/   218,  219,   86,  218,  219,  218,  219,   91,   19,   20,\n+ \/*  1590 *\/   153,   22,  218,  219,  218,  219,  195,  101,  195,  218,\n+ \/*  1600 *\/   219,  195,  195,  107,  108,   36,   23,  195,   25,  195,\n+ \/*  1610 *\/    62,  115,  195,  117,  118,  119,  195,  146,  122,  218,\n+ \/*  1620 *\/   219,  218,  219,  195,  218,  219,   19,   60,  122,   60,\n+ \/*  1630 *\/   218,  219,  218,  219,  195,  218,  219,  150,  132,  218,\n+ \/*  1640 *\/   219,   72,  195,   23,  195,   25,  218,  219,  195,   60,\n+ \/*  1650 *\/   154,  155,  156,  157,  158,   86,   23,  195,   25,  195,\n+ \/*  1660 *\/    91,   19,   20,  142,   22,  218,  219,  218,  219,  130,\n+ \/*  1670 *\/   101,  218,  219,  143,  121,  122,  107,  108,   36,  183,\n+ \/*  1680 *\/   218,  219,  142,   60,  115,  118,  117,  118,  119,    7,\n+ \/*  1690 *\/     8,  122,  153,   23,   23,   25,   25,   23,   23,   25,\n+ \/*  1700 *\/    25,   23,   60,   25,   23,   98,   25,  118,   84,   85,\n+ \/*  1710 *\/    23,   23,   25,   25,   72,  154,   23,  156,   25,   23,\n+ \/*  1720 *\/   228,   25,  195,  154,  155,  156,  157,  158,   86,  195,\n+ \/*  1730 *\/   195,  258,  195,   91,  291,  322,  195,  195,  195,  195,\n+ \/*  1740 *\/   195,  118,  195,  101,  195,  195,  195,  195,  238,  107,\n+ \/*  1750 *\/   108,  195,  183,  195,  195,  195,  290,  115,  195,  117,\n+ \/*  1760 *\/   118,  119,  244,  195,  122,  195,  195,  195,  195,  195,\n+ \/*  1770 *\/   195,  258,  258,  258,  258,  193,  245,  300,  216,  274,\n+ \/*  1780 *\/   247,  270,  270,  274,  296,  296,  248,  222,  262,  198,\n+ \/*  1790 *\/   262,  274,   61,  274,  248,  231,  154,  155,  156,  157,\n+ \/*  1800 *\/   158,    0,    1,    2,  247,  227,    5,  221,  221,  221,\n+ \/*  1810 *\/   142,   10,   11,   12,   13,   14,  262,  262,   17,  202,\n+ \/*  1820 *\/   300,   19,   20,  300,   22,  183,  247,  251,  251,  245,\n+ \/*  1830 *\/   202,   30,   38,   32,  202,  152,  151,   22,   36,   43,\n+ \/*  1840 *\/   236,   40,   18,  202,  239,  239,   18,  239,  239,  283,\n+ \/*  1850 *\/   201,  150,  236,  202,  236,  201,  159,  202,  248,  248,\n+ \/*  1860 *\/   248,  248,   60,   63,  201,  275,  273,  275,  273,  275,\n+ \/*  1870 *\/    22,  286,   71,  223,   72,  202,  223,  297,  297,  202,\n+ \/*  1880 *\/    79,  201,  116,   82,  220,  201,  220,  220,   65,  293,\n+ \/*  1890 *\/   292,  229,   22,  166,  127,  226,   24,  114,  226,  223,\n+ \/*  1900 *\/    99,  222,  202,  101,  285,   92,  220,  308,   83,  107,\n+ \/*  1910 *\/   108,  220,  220,  316,  220,  285,  268,  115,  229,  117,\n+ \/*  1920 *\/   118,  119,  223,  321,  122,  268,  149,  146,   22,   19,\n+ \/*  1930 *\/    20,  202,   22,  159,  282,  134,  321,  148,  280,  147,\n+ \/*  1940 *\/   139,  140,  252,  141,   25,  204,   36,  252,   13,  251,\n+ \/*  1950 *\/   196,  248,  250,  249,  196,    6,  154,  155,  156,  157,\n+ \/*  1960 *\/   158,  209,  194,  194,  163,  194,  306,  306,  303,  224,\n+ \/*  1970 *\/    60,  215,  215,  209,  215,  215,  215,  224,  216,  216,\n+ \/*  1980 *\/     4,  209,   72,    3,   22,  183,  164,   15,   23,   16,\n+ \/*  1990 *\/    23,  140,  152,  131,   25,   24,  143,   20,   16,  145,\n+ \/*  2000 *\/     1,  143,  131,   62,  131,   37,   54,  152,   54,   54,\n+ \/*  2010 *\/    54,  101,  131,  117,    1,   34,  142,  107,  108,    5,\n+ \/*  2020 *\/    22,  116,  162,   76,   41,  115,   69,  117,  118,  119,\n+ \/*  2030 *\/     1,    2,  122,   25,    5,   69,  142,  116,   20,   10,\n+ \/*  2040 *\/    11,   12,   13,   14,   24,   19,   17,  132,    5,  126,\n+ \/*  2050 *\/    22,  141,   68,   10,   11,   12,   13,   14,   22,   30,\n+ \/*  2060 *\/    17,   32,   22,   22,  154,  155,  156,  157,  158,   40,\n+ \/*  2070 *\/    23,   68,   60,   30,   24,   32,   97,   28,   22,   68,\n+ \/*  2080 *\/    23,   37,   34,   40,  150,   22,   25,   23,   23,   23,\n+ \/*  2090 *\/    22,   98,  142,  183,   23,   23,   34,   22,   25,   89,\n+ \/*  2100 *\/    71,   34,  117,  144,   34,   22,   76,   76,   79,   87,\n+ \/*  2110 *\/    34,   82,   34,   44,   71,   94,   34,   23,   25,   24,\n+ \/*  2120 *\/    34,   25,   79,   23,   23,   82,   23,   23,   99,  143,\n+ \/*  2130 *\/   143,   22,   25,   25,   23,   22,   11,   22,   22,   25,\n+ \/*  2140 *\/    23,   23,   99,   22,   22,  136,  142,  142,  142,   25,\n+ \/*  2150 *\/    23,   15,    1,    1,  323,  323,  323,  323,  323,  323,\n+ \/*  2160 *\/   323,  323,  323,  134,  323,  323,  323,  323,  139,  140,\n+ \/*  2170 *\/   323,  323,  323,  323,  323,  323,  323,  134,  323,  323,\n+ \/*  2180 *\/   323,  323,  139,  140,  323,  323,  323,  323,  323,  323,\n+ \/*  2190 *\/   323,  323,  163,  323,  323,  323,  323,  323,  323,  323,\n+ \/*  2200 *\/   323,  323,  323,  323,  323,  323,  163,  323,  323,  323,\n+ \/*  2210 *\/   323,  323,  323,  323,  323,  323,  323,  323,  323,  323,\n+ \/*  2220 *\/   323,  323,  323,  323,  323,  323,  323,  323,  323,  323,\n+ \/*  2230 *\/   323,  323,  323,  323,  323,  323,  323,  323,  323,  323,\n+ \/*  2240 *\/   323,  323,  323,  323,  323,  323,  323,  323,  323,  323,\n+ \/*  2250 *\/   323,  323,  323,  323,  323,  323,  323,  323,  323,  323,\n+ \/*  2260 *\/   323,  323,  323,  323,  323,  323,  323,  323,  323,  323,\n+ \/*  2270 *\/   323,  323,  323,  323,  323,  323,  323,  323,  323,  323,\n+ \/*  2280 *\/   323,  323,  323,  323,  323,  323,  323,  323,  323,  323,\n+ \/*  2290 *\/   323,  323,  323,  323,  323,  323,  323,  323,  323,  323,\n+ \/*  2300 *\/   323,  323,  323,  323,  323,  323,  323,  323,  323,  323,\n+ \/*  2310 *\/   323,  323,  323,  323,  323,  323,  323,  323,  323,  323,\n+ \/*  2320 *\/   323,  323,  323,  323,  323,  323,  323,  323,  323,  323,\n+ \/*  2330 *\/   323,  323,  323,  323,  323,  323,  323,  323,  323,  323,\n+ \/*  2340 *\/   323,  187,  187,  187,  187,  187,  187,  187,  187,  187,\n+ \/*  2350 *\/   187,  187,  187,  187,  187,  187,  187,  187,  187,  187,\n+ \/*  2360 *\/   187,  187,  187,  187,  187,  187,  187,  187,  187,  187,\n+ \/*  2370 *\/   187,  187,  187,  187,  187,  187,  187,  187,  187,  187,\n+ \/*  2380 *\/   187,  187,  187,  187,  187,  187,  187,  187,  187,  187,\n+ \/*  2390 *\/   187,  187,  187,  187,\n@@ -172163,1 +175294,1 @@\n-#define YY_SHIFT_COUNT    (578)\n+#define YY_SHIFT_COUNT    (582)\n@@ -172165,1 +175296,1 @@\n-#define YY_SHIFT_MAX      (2088)\n+#define YY_SHIFT_MAX      (2152)\n@@ -172167,58 +175298,59 @@\n- \/*     0 *\/  1648, 1477, 1272,  322,  322,    1, 1319, 1478, 1491, 1837,\n- \/*    10 *\/  1837, 1837,  471,    0,    0,  214, 1093, 1837, 1837, 1837,\n- \/*    20 *\/  1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837,\n- \/*    30 *\/  1837,  271,  271, 1219, 1219,  216,   88,    1,    1,    1,\n- \/*    40 *\/     1,    1,   40,  111,  258,  361,  469,  512,  583,  622,\n- \/*    50 *\/   693,  732,  803,  842,  913, 1073, 1093, 1093, 1093, 1093,\n- \/*    60 *\/  1093, 1093, 1093, 1093, 1093, 1093, 1093, 1093, 1093, 1093,\n- \/*    70 *\/  1093, 1093, 1093, 1093, 1113, 1093, 1216,  957,  957, 1635,\n- \/*    80 *\/  1662, 1777, 1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837,\n- \/*    90 *\/  1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837,\n- \/*   100 *\/  1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837,\n- \/*   110 *\/  1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837,\n- \/*   120 *\/  1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837, 1837,\n- \/*   130 *\/  1837,  137,  181,  181,  181,  181,  181,  181,  181,   94,\n- \/*   140 *\/   430,   66,   65,  112,  366,  533,  533,  740, 1257,  533,\n- \/*   150 *\/   533,   79,   79,  533,  412,  412,  412,   77,  412,  123,\n- \/*   160 *\/   113,  113,  113,   22,   22, 2100, 2100,  328,  328,  328,\n- \/*   170 *\/   239,  468,  468,  468,  468, 1015, 1015,  409,  366, 1187,\n- \/*   180 *\/  1232,  533,  533,  533,  533,  533,  533,  533,  533,  533,\n- \/*   190 *\/   533,  533,  533,  533,  533,  533,  533,  533,  533,  533,\n- \/*   200 *\/   533,  969,  621,  621,  533,  642,  788,  788, 1133, 1133,\n- \/*   210 *\/   822,  822,   67, 1193, 2100, 2100, 2100, 2100, 2100, 2100,\n- \/*   220 *\/  2100, 1307,  954,  954,  585,  472,  640,  387,  695,  538,\n- \/*   230 *\/   541,  700,  533,  533,  533,  533,  533,  533,  533,  533,\n- \/*   240 *\/   533,  533,  222,  533,  533,  533,  533,  533,  533,  533,\n- \/*   250 *\/   533,  533,  533,  533,  533, 1213, 1213, 1213,  533,  533,\n- \/*   260 *\/   533,  565,  533,  533,  533,  916, 1147,  533,  533, 1288,\n- \/*   270 *\/   533,  533,  533,  533,  533,  533,  533,  533,  639, 1280,\n- \/*   280 *\/   209, 1129, 1129, 1129, 1129,  580,  209,  209, 1209,  768,\n- \/*   290 *\/   917,  649, 1315, 1334,  405, 1334, 1383,  249, 1315, 1315,\n- \/*   300 *\/   249, 1315,  405, 1383, 1441,  464, 1245, 1417, 1417, 1417,\n- \/*   310 *\/  1323, 1323, 1323, 1323,  184,  184, 1335, 1476,  856, 1482,\n- \/*   320 *\/  1744, 1744, 1665, 1665, 1773, 1773, 1665, 1669, 1671, 1802,\n- \/*   330 *\/  1782, 1809, 1809, 1809, 1809, 1665, 1817, 1690, 1671, 1671,\n- \/*   340 *\/  1690, 1802, 1782, 1690, 1782, 1690, 1665, 1817, 1693, 1791,\n- \/*   350 *\/  1665, 1817, 1832, 1665, 1817, 1665, 1817, 1832, 1752, 1752,\n- \/*   360 *\/  1752, 1805, 1850, 1850, 1832, 1752, 1749, 1752, 1805, 1752,\n- \/*   370 *\/  1752, 1713, 1858, 1775, 1775, 1832, 1665, 1799, 1799, 1823,\n- \/*   380 *\/  1823, 1761, 1765, 1890, 1665, 1757, 1761, 1771, 1774, 1690,\n- \/*   390 *\/  1894, 1913, 1913, 1929, 1929, 1929, 2100, 2100, 2100, 2100,\n- \/*   400 *\/  2100, 2100, 2100, 2100, 2100, 2100, 2100, 2100, 2100, 2100,\n- \/*   410 *\/  2100,  207, 1220,  331,  620,  967,  806, 1074, 1499, 1432,\n- \/*   420 *\/  1463, 1479, 1419, 1422, 1557, 1512, 1598, 1599, 1644, 1645,\n- \/*   430 *\/  1654, 1660, 1555, 1505, 1684, 1462, 1670, 1563, 1619, 1593,\n- \/*   440 *\/  1676, 1679, 1613, 1680, 1554, 1558, 1689, 1692, 1605, 1589,\n- \/*   450 *\/  1955, 1959, 1941, 1803, 1950, 1951, 1945, 1946, 1831, 1820,\n- \/*   460 *\/  1842, 1948, 1948, 1952, 1833, 1954, 1834, 1961, 1978, 1838,\n- \/*   470 *\/  1851, 1948, 1852, 1922, 1947, 1948, 1836, 1932, 1935, 1936,\n- \/*   480 *\/  1942, 1866, 1881, 1964, 1859, 1998, 1996, 1980, 1888, 1843,\n- \/*   490 *\/  1937, 1981, 1939, 1933, 1968, 1869, 1896, 1988, 1993, 1995,\n- \/*   500 *\/  1884, 1891, 1997, 1953, 1999, 2000, 1994, 2001, 1957, 1966,\n- \/*   510 *\/  2002, 1931, 1990, 2006, 1962, 2003, 2007, 2004, 1882, 2010,\n- \/*   520 *\/  2011, 2012, 2008, 2013, 2015, 1944, 1898, 2019, 2020, 1928,\n- \/*   530 *\/  2014, 2023, 1903, 2022, 2016, 2017, 2018, 2021, 1965, 1974,\n- \/*   540 *\/  1970, 2024, 1979, 1967, 2025, 2034, 2036, 2037, 2038, 2039,\n- \/*   550 *\/  2028, 1923, 1924, 2044, 2022, 2046, 2047, 2048, 2049, 2050,\n- \/*   560 *\/  2051, 2054, 2062, 2055, 2056, 2057, 2058, 2060, 2061, 2059,\n- \/*   570 *\/  1956, 1938, 1949, 1958, 2063, 2064, 2070, 2085, 2088,\n+ \/*     0 *\/  2029, 1801, 2043, 1380, 1380,  318,  271, 1496, 1569, 1642,\n+ \/*    10 *\/   702,  702,  702,  740,  318,  318,  318,  318,  318,    0,\n+ \/*    20 *\/     0,  216, 1177,  702,  702,  702,  702,  702,  702,  702,\n+ \/*    30 *\/   702,  702,  702,  702,  702,  702,  702,  702,  503,  503,\n+ \/*    40 *\/   111,  111,  217,  287,  348,  610,  610,  736,  736,  736,\n+ \/*    50 *\/   736,   40,  112,  320,  340,  445,  489,  593,  637,  741,\n+ \/*    60 *\/   785,  889,  909, 1023, 1043, 1157, 1177, 1177, 1177, 1177,\n+ \/*    70 *\/  1177, 1177, 1177, 1177, 1177, 1177, 1177, 1177, 1177, 1177,\n+ \/*    80 *\/  1177, 1177, 1177, 1177, 1197, 1177, 1301, 1321, 1321,  554,\n+ \/*    90 *\/  1802, 1910,  702,  702,  702,  702,  702,  702,  702,  702,\n+ \/*   100 *\/   702,  702,  702,  702,  702,  702,  702,  702,  702,  702,\n+ \/*   110 *\/   702,  702,  702,  702,  702,  702,  702,  702,  702,  702,\n+ \/*   120 *\/   702,  702,  702,  702,  702,  702,  702,  702,  702,  702,\n+ \/*   130 *\/   702,  702,  702,  702,  702,  702,  702,  702,  702,  702,\n+ \/*   140 *\/   702,  702,  138,  198,  198,  198,  198,  198,  198,  198,\n+ \/*   150 *\/   183,   99,  169,  549,  610,  151,  542,  610,  610, 1017,\n+ \/*   160 *\/  1017,  610, 1001,  350,  464,  464,  464,  586,    1,    1,\n+ \/*   170 *\/  2207, 2207,  854,  854,  854,  465,  694,  694,  694,  694,\n+ \/*   180 *\/  1096, 1096,  825,  549,  847,  904,  610,  610,  610,  610,\n+ \/*   190 *\/   610,  610,  610,  610,  610,  610,  610,  610,  610,  610,\n+ \/*   200 *\/   610,  610,  610,  610,  610,  488,  947,  947,  610, 1129,\n+ \/*   210 *\/   495,  495, 1139, 1139,  967,  967, 1173, 2207, 2207, 2207,\n+ \/*   220 *\/  2207, 2207, 2207, 2207,  617,  765,  765,  697,  444,  708,\n+ \/*   230 *\/   660,  745,  510,  663,  864,  610,  610,  610,  610,  610,\n+ \/*   240 *\/   610,  610,  610,  610,  610,  188,  610,  610,  610,  610,\n+ \/*   250 *\/   610,  610,  610,  610,  610,  610,  610,  610,  839,  839,\n+ \/*   260 *\/   839,  610,  610,  610, 1155,  610,  610,  610, 1119, 1247,\n+ \/*   270 *\/   610, 1353,  610,  610,  610,  610,  610,  610,  610,  610,\n+ \/*   280 *\/  1063,  494, 1101,  291,  291,  291,  291, 1319, 1101, 1101,\n+ \/*   290 *\/   775, 1221, 1375, 1452,  667, 1341, 1198, 1341, 1435, 1487,\n+ \/*   300 *\/   667,  667, 1487,  667, 1198, 1435,  777, 1011, 1423,  584,\n+ \/*   310 *\/   584,  584, 1273, 1273, 1273, 1273, 1471, 1471,  880, 1530,\n+ \/*   320 *\/  1190, 1095, 1731, 1731, 1668, 1668, 1794, 1794, 1668, 1683,\n+ \/*   330 *\/  1685, 1815, 1796, 1824, 1824, 1824, 1824, 1668, 1828, 1701,\n+ \/*   340 *\/  1685, 1685, 1701, 1815, 1796, 1701, 1796, 1701, 1668, 1828,\n+ \/*   350 *\/  1697, 1800, 1668, 1828, 1848, 1668, 1828, 1668, 1828, 1848,\n+ \/*   360 *\/  1766, 1766, 1766, 1823, 1870, 1870, 1848, 1766, 1767, 1766,\n+ \/*   370 *\/  1823, 1766, 1766, 1727, 1872, 1783, 1783, 1848, 1668, 1813,\n+ \/*   380 *\/  1813, 1825, 1825, 1777, 1781, 1906, 1668, 1774, 1777, 1789,\n+ \/*   390 *\/  1792, 1701, 1919, 1935, 1935, 1949, 1949, 1949, 2207, 2207,\n+ \/*   400 *\/  2207, 2207, 2207, 2207, 2207, 2207, 2207, 2207, 2207, 2207,\n+ \/*   410 *\/  2207, 2207, 2207,   69, 1032,   79,  357, 1377, 1206,  400,\n+ \/*   420 *\/  1525,  835,  332, 1540, 1437, 1539, 1536, 1548, 1583, 1620,\n+ \/*   430 *\/  1633, 1670, 1671, 1674, 1567, 1553, 1682, 1506, 1675, 1358,\n+ \/*   440 *\/  1607, 1589, 1678, 1681, 1624, 1687, 1688, 1283, 1561, 1693,\n+ \/*   450 *\/  1696, 1623, 1521, 1976, 1980, 1962, 1822, 1972, 1973, 1965,\n+ \/*   460 *\/  1967, 1851, 1840, 1862, 1969, 1969, 1971, 1853, 1977, 1854,\n+ \/*   470 *\/  1982, 1999, 1858, 1871, 1969, 1873, 1941, 1968, 1969, 1855,\n+ \/*   480 *\/  1952, 1954, 1955, 1956, 1881, 1896, 1981, 1874, 2013, 2014,\n+ \/*   490 *\/  1998, 1905, 1860, 1957, 2008, 1966, 1947, 1983, 1894, 1921,\n+ \/*   500 *\/  2020, 2018, 2026, 1915, 1923, 2028, 1984, 2036, 2040, 2047,\n+ \/*   510 *\/  2041, 2003, 2012, 2050, 1979, 2049, 2056, 2011, 2044, 2057,\n+ \/*   520 *\/  2048, 1934, 2063, 2064, 2065, 2061, 2066, 2068, 1993, 1950,\n+ \/*   530 *\/  2071, 2072, 1985, 2062, 2075, 1959, 2073, 2067, 2070, 2076,\n+ \/*   540 *\/  2078, 2010, 2030, 2022, 2069, 2031, 2021, 2082, 2094, 2083,\n+ \/*   550 *\/  2095, 2093, 2096, 2086, 1986, 1987, 2100, 2073, 2101, 2103,\n+ \/*   560 *\/  2104, 2109, 2107, 2108, 2111, 2113, 2125, 2115, 2116, 2117,\n+ \/*   570 *\/  2118, 2121, 2122, 2114, 2009, 2004, 2005, 2006, 2124, 2127,\n+ \/*   580 *\/  2136, 2151, 2152,\n@@ -172226,3 +175358,3 @@\n-#define YY_REDUCE_COUNT (410)\n-#define YY_REDUCE_MIN   (-271)\n-#define YY_REDUCE_MAX   (1753)\n+#define YY_REDUCE_COUNT (412)\n+#define YY_REDUCE_MIN   (-277)\n+#define YY_REDUCE_MAX   (1772)\n@@ -172230,42 +175362,42 @@\n- \/*     0 *\/  -125,  733,  789,  241,  293, -123, -193, -191, -183, -187,\n- \/*    10 *\/   166,  238,  133, -207, -199, -267, -176,   -6,  204,  489,\n- \/*    20 *\/   576,  598, -175,  686,  860,  615,  725, 1014,  778,  781,\n- \/*    30 *\/   857,  616,  887,   87,  240, -192,  408,  626,  796,  843,\n- \/*    40 *\/   854, 1004, -271, -271, -271, -271, -271, -271, -271, -271,\n- \/*    50 *\/  -271, -271, -271, -271, -271, -271, -271, -271, -271, -271,\n- \/*    60 *\/  -271, -271, -271, -271, -271, -271, -271, -271, -271, -271,\n- \/*    70 *\/  -271, -271, -271, -271, -271, -271, -271, -271, -271,   80,\n- \/*    80 *\/    83,  313,  886,  888,  918,  938, 1021, 1034, 1036, 1141,\n- \/*    90 *\/  1159, 1163, 1166, 1168, 1170, 1176, 1178, 1180, 1184, 1196,\n- \/*   100 *\/  1198, 1205, 1215, 1225, 1227, 1236, 1252, 1254, 1264, 1303,\n- \/*   110 *\/  1309, 1312, 1322, 1325, 1328, 1337, 1340, 1343, 1353, 1371,\n- \/*   120 *\/  1373, 1384, 1386, 1411, 1413, 1420, 1424, 1426, 1458, 1470,\n- \/*   130 *\/  1473, -271, -271, -271, -271, -271, -271, -271, -271, -271,\n- \/*   140 *\/  -271, -271,  138,  459,  396, -158,  470,  302, -212,  521,\n- \/*   150 *\/   201, -195,  -92,  559,  630,  632,  630, -271,  632,  901,\n- \/*   160 *\/    63,  407,  670, -271, -271, -271, -271,  161,  161,  161,\n- \/*   170 *\/   251,  335,  847,  979, 1097,  537,  588,  618,  628,  688,\n- \/*   180 *\/   688, -166, -161,  674,  787,  794,  799,  852,  996, -122,\n- \/*   190 *\/   837, -120, 1018, 1035,  415, 1047, 1001,  958, 1082,  400,\n- \/*   200 *\/  1099,  779, 1137, 1142,  263, 1083, 1145, 1150, 1041, 1139,\n- \/*   210 *\/   965, 1050,  362,  849,  752,  629,  675, 1162, 1173, 1090,\n- \/*   220 *\/  1195, -194,   56,  185, -135,  232,  522,  560,  571,  601,\n- \/*   230 *\/   617,  669,  683,  711,  850,  893, 1000, 1040, 1049, 1081,\n- \/*   240 *\/  1087, 1101,  392, 1114, 1123, 1155, 1161, 1175, 1271, 1293,\n- \/*   250 *\/  1299, 1330, 1339, 1342, 1347,  593, 1282, 1286, 1350, 1359,\n- \/*   260 *\/  1368, 1314, 1480, 1483, 1507, 1085, 1338, 1526, 1527, 1487,\n- \/*   270 *\/  1531,  560, 1532, 1534, 1535, 1538, 1539, 1541, 1448, 1450,\n- \/*   280 *\/  1496, 1484, 1485, 1489, 1490, 1314, 1496, 1496, 1504, 1536,\n- \/*   290 *\/  1564, 1451, 1486, 1492, 1509, 1493, 1465, 1515, 1494, 1495,\n- \/*   300 *\/  1517, 1500, 1519, 1474, 1550, 1543, 1548, 1556, 1565, 1566,\n- \/*   310 *\/  1518, 1523, 1542, 1544, 1525, 1545, 1513, 1553, 1552, 1604,\n- \/*   320 *\/  1508, 1510, 1608, 1609, 1520, 1528, 1612, 1540, 1559, 1560,\n- \/*   330 *\/  1592, 1591, 1595, 1596, 1597, 1629, 1638, 1594, 1569, 1570,\n- \/*   340 *\/  1600, 1568, 1610, 1601, 1611, 1603, 1643, 1651, 1562, 1571,\n- \/*   350 *\/  1655, 1659, 1640, 1663, 1666, 1664, 1667, 1641, 1650, 1652,\n- \/*   360 *\/  1653, 1647, 1656, 1657, 1658, 1668, 1672, 1681, 1649, 1682,\n- \/*   370 *\/  1683, 1573, 1582, 1607, 1615, 1685, 1702, 1586, 1587, 1642,\n- \/*   380 *\/  1646, 1673, 1675, 1636, 1714, 1637, 1677, 1674, 1678, 1694,\n- \/*   390 *\/  1719, 1734, 1735, 1746, 1747, 1750, 1633, 1661, 1686, 1738,\n- \/*   400 *\/  1728, 1733, 1736, 1737, 1740, 1726, 1730, 1742, 1743, 1748,\n- \/*   410 *\/  1753,\n+ \/*     0 *\/   -67, 1252,  -64, -178, -181,  160, 1071,  143, -184,  137,\n+ \/*    10 *\/   218,  220,  222, -174,  229,  268,  272,  275,  324, -208,\n+ \/*    20 *\/   242, -277,  -39,   81,  537,  792,  810,  812, -189,  814,\n+ \/*    30 *\/   831,  163,  865,  944,  887,  840,  964, 1077, -187,  292,\n+ \/*    40 *\/  -133,  274,  673,  558,  682,  795,  809, -238, -232, -238,\n+ \/*    50 *\/  -232,  329,  329,  329,  329,  329,  329,  329,  329,  329,\n+ \/*    60 *\/   329,  329,  329,  329,  329,  329,  329,  329,  329,  329,\n+ \/*    70 *\/   329,  329,  329,  329,  329,  329,  329,  329,  329,  329,\n+ \/*    80 *\/   329,  329,  329,  329,  329,  329,  329,  329,  329,  557,\n+ \/*    90 *\/   712,  949,  966,  969,  971,  979, 1097, 1099, 1103, 1142,\n+ \/*   100 *\/  1144, 1169, 1172, 1201, 1203, 1228, 1241, 1250, 1253, 1255,\n+ \/*   110 *\/  1261, 1266, 1271, 1282, 1291, 1308, 1310, 1312, 1322, 1328,\n+ \/*   120 *\/  1347, 1354, 1356, 1359, 1362, 1365, 1367, 1374, 1376, 1381,\n+ \/*   130 *\/  1401, 1403, 1406, 1412, 1414, 1417, 1421, 1428, 1447, 1449,\n+ \/*   140 *\/  1453, 1462,  329,  329,  329,  329,  329,  329,  329,  329,\n+ \/*   150 *\/   329,  329,  329,  -22, -159,  475, -220,  756,   38,  501,\n+ \/*   160 *\/   841,  714,  329,  118,  337,  349,  363,  -56,  329,  329,\n+ \/*   170 *\/   329,  329, -205, -205, -205,  687, -172, -130,  -57,  790,\n+ \/*   180 *\/   397,  528, -271,  136,  596,  596,   90,  316,  522,  541,\n+ \/*   190 *\/   -37,  715,  849,  977,  628,  856,  980,  991, 1081, 1102,\n+ \/*   200 *\/  1135, 1083, -162,  208, 1258,  794,  -86,  159,   41, 1109,\n+ \/*   210 *\/   671,  852,  844,  932, 1175, 1254,  480, 1180,  100,  258,\n+ \/*   220 *\/  1265, 1268, 1216, 1287, -139,  317,  344,   63,  339,  423,\n+ \/*   230 *\/   563,  636,  676,  813,  908,  914,  950, 1078, 1084, 1098,\n+ \/*   240 *\/  1363, 1384, 1407, 1439, 1464,  411, 1527, 1534, 1535, 1537,\n+ \/*   250 *\/  1541, 1542, 1543, 1544, 1545, 1547, 1549, 1550,  990, 1164,\n+ \/*   260 *\/  1492, 1551, 1552, 1556, 1217, 1558, 1559, 1560, 1473, 1413,\n+ \/*   270 *\/  1563, 1510, 1568,  563, 1570, 1571, 1572, 1573, 1574, 1575,\n+ \/*   280 *\/  1443, 1466, 1518, 1513, 1514, 1515, 1516, 1217, 1518, 1518,\n+ \/*   290 *\/  1531, 1562, 1582, 1477, 1505, 1511, 1533, 1512, 1488, 1538,\n+ \/*   300 *\/  1509, 1517, 1546, 1519, 1557, 1489, 1565, 1564, 1578, 1586,\n+ \/*   310 *\/  1587, 1588, 1526, 1528, 1554, 1555, 1576, 1577, 1566, 1579,\n+ \/*   320 *\/  1584, 1591, 1520, 1523, 1617, 1628, 1580, 1581, 1632, 1585,\n+ \/*   330 *\/  1590, 1593, 1604, 1605, 1606, 1608, 1609, 1641, 1649, 1610,\n+ \/*   340 *\/  1592, 1594, 1611, 1595, 1616, 1612, 1618, 1613, 1651, 1654,\n+ \/*   350 *\/  1596, 1598, 1655, 1663, 1650, 1673, 1680, 1677, 1684, 1653,\n+ \/*   360 *\/  1664, 1666, 1667, 1662, 1669, 1672, 1676, 1686, 1679, 1691,\n+ \/*   370 *\/  1689, 1692, 1694, 1597, 1599, 1619, 1630, 1699, 1700, 1602,\n+ \/*   380 *\/  1615, 1648, 1657, 1690, 1698, 1658, 1729, 1652, 1695, 1702,\n+ \/*   390 *\/  1704, 1703, 1741, 1754, 1758, 1768, 1769, 1771, 1660, 1661,\n+ \/*   400 *\/  1665, 1752, 1756, 1757, 1759, 1760, 1764, 1745, 1753, 1762,\n+ \/*   410 *\/  1763, 1761, 1772,\n@@ -172274,58 +175406,59 @@\n- \/*     0 *\/  1648, 1648, 1648, 1478, 1243, 1354, 1243, 1243, 1243, 1478,\n- \/*    10 *\/  1478, 1478, 1243, 1384, 1384, 1531, 1276, 1243, 1243, 1243,\n- \/*    20 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1477, 1243,\n- \/*    30 *\/  1243, 1243, 1243, 1564, 1564, 1243, 1243, 1243, 1243, 1243,\n- \/*    40 *\/  1243, 1243, 1243, 1393, 1243, 1400, 1243, 1243, 1243, 1243,\n- \/*    50 *\/  1243, 1479, 1480, 1243, 1243, 1243, 1530, 1532, 1495, 1407,\n- \/*    60 *\/  1406, 1405, 1404, 1513, 1372, 1398, 1391, 1395, 1474, 1475,\n- \/*    70 *\/  1473, 1626, 1480, 1479, 1243, 1394, 1442, 1458, 1441, 1243,\n- \/*    80 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n- \/*    90 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n- \/*   100 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n- \/*   110 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n- \/*   120 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n- \/*   130 *\/  1243, 1450, 1457, 1456, 1455, 1464, 1454, 1451, 1444, 1443,\n- \/*   140 *\/  1445, 1446, 1243, 1243, 1267, 1243, 1243, 1264, 1318, 1243,\n- \/*   150 *\/  1243, 1243, 1243, 1243, 1550, 1549, 1243, 1447, 1243, 1276,\n- \/*   160 *\/  1435, 1434, 1433, 1461, 1448, 1460, 1459, 1538, 1600, 1599,\n- \/*   170 *\/  1496, 1243, 1243, 1243, 1243, 1243, 1243, 1564, 1243, 1243,\n- \/*   180 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n- \/*   190 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n- \/*   200 *\/  1243, 1374, 1564, 1564, 1243, 1276, 1564, 1564, 1375, 1375,\n- \/*   210 *\/  1272, 1272, 1378, 1243, 1545, 1345, 1345, 1345, 1345, 1354,\n- \/*   220 *\/  1345, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n- \/*   230 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1535, 1533, 1243, 1243,\n- \/*   240 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n- \/*   250 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n- \/*   260 *\/  1243, 1243, 1243, 1243, 1243, 1350, 1243, 1243, 1243, 1243,\n- \/*   270 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1593, 1243, 1508,\n- \/*   280 *\/  1332, 1350, 1350, 1350, 1350, 1352, 1333, 1331, 1344, 1277,\n- \/*   290 *\/  1250, 1640, 1410, 1399, 1351, 1399, 1637, 1397, 1410, 1410,\n- \/*   300 *\/  1397, 1410, 1351, 1637, 1293, 1615, 1288, 1384, 1384, 1384,\n- \/*   310 *\/  1374, 1374, 1374, 1374, 1378, 1378, 1476, 1351, 1344, 1243,\n- \/*   320 *\/  1640, 1640, 1360, 1360, 1639, 1639, 1360, 1496, 1623, 1419,\n- \/*   330 *\/  1321, 1327, 1327, 1327, 1327, 1360, 1261, 1397, 1623, 1623,\n- \/*   340 *\/  1397, 1419, 1321, 1397, 1321, 1397, 1360, 1261, 1512, 1634,\n- \/*   350 *\/  1360, 1261, 1486, 1360, 1261, 1360, 1261, 1486, 1319, 1319,\n- \/*   360 *\/  1319, 1308, 1243, 1243, 1486, 1319, 1293, 1319, 1308, 1319,\n- \/*   370 *\/  1319, 1582, 1243, 1490, 1490, 1486, 1360, 1574, 1574, 1387,\n- \/*   380 *\/  1387, 1392, 1378, 1481, 1360, 1243, 1392, 1390, 1388, 1397,\n- \/*   390 *\/  1311, 1596, 1596, 1592, 1592, 1592, 1645, 1645, 1545, 1608,\n- \/*   400 *\/  1276, 1276, 1276, 1276, 1608, 1295, 1295, 1277, 1277, 1276,\n- \/*   410 *\/  1608, 1243, 1243, 1243, 1243, 1243, 1243, 1603, 1243, 1540,\n- \/*   420 *\/  1497, 1364, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n- \/*   430 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1551, 1243,\n- \/*   440 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1424,\n- \/*   450 *\/  1243, 1246, 1542, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n- \/*   460 *\/  1243, 1401, 1402, 1365, 1243, 1243, 1243, 1243, 1243, 1243,\n- \/*   470 *\/  1243, 1416, 1243, 1243, 1243, 1411, 1243, 1243, 1243, 1243,\n- \/*   480 *\/  1243, 1243, 1243, 1243, 1636, 1243, 1243, 1243, 1243, 1243,\n- \/*   490 *\/  1243, 1511, 1510, 1243, 1243, 1362, 1243, 1243, 1243, 1243,\n- \/*   500 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1291,\n- \/*   510 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n- \/*   520 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243,\n- \/*   530 *\/  1243, 1243, 1243, 1389, 1243, 1243, 1243, 1243, 1243, 1243,\n- \/*   540 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1579, 1379,\n- \/*   550 *\/  1243, 1243, 1243, 1243, 1627, 1243, 1243, 1243, 1243, 1243,\n- \/*   560 *\/  1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1243, 1619,\n- \/*   570 *\/  1335, 1425, 1243, 1428, 1265, 1243, 1255, 1243, 1243,\n+ \/*     0 *\/  1663, 1663, 1663, 1491, 1254, 1367, 1254, 1254, 1254, 1254,\n+ \/*    10 *\/  1491, 1491, 1491, 1254, 1254, 1254, 1254, 1254, 1254, 1397,\n+ \/*    20 *\/  1397, 1544, 1287, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+ \/*    30 *\/  1254, 1254, 1254, 1254, 1254, 1490, 1254, 1254, 1254, 1254,\n+ \/*    40 *\/  1578, 1578, 1254, 1254, 1254, 1254, 1254, 1563, 1562, 1254,\n+ \/*    50 *\/  1254, 1254, 1406, 1254, 1413, 1254, 1254, 1254, 1254, 1254,\n+ \/*    60 *\/  1492, 1493, 1254, 1254, 1254, 1254, 1543, 1545, 1508, 1420,\n+ \/*    70 *\/  1419, 1418, 1417, 1526, 1385, 1411, 1404, 1408, 1487, 1488,\n+ \/*    80 *\/  1486, 1641, 1493, 1492, 1254, 1407, 1455, 1471, 1454, 1254,\n+ \/*    90 *\/  1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+ \/*   100 *\/  1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+ \/*   110 *\/  1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+ \/*   120 *\/  1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+ \/*   130 *\/  1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+ \/*   140 *\/  1254, 1254, 1463, 1470, 1469, 1468, 1477, 1467, 1464, 1457,\n+ \/*   150 *\/  1456, 1458, 1459, 1278, 1254, 1275, 1329, 1254, 1254, 1254,\n+ \/*   160 *\/  1254, 1254, 1460, 1287, 1448, 1447, 1446, 1254, 1474, 1461,\n+ \/*   170 *\/  1473, 1472, 1551, 1615, 1614, 1509, 1254, 1254, 1254, 1254,\n+ \/*   180 *\/  1254, 1254, 1578, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+ \/*   190 *\/  1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+ \/*   200 *\/  1254, 1254, 1254, 1254, 1254, 1387, 1578, 1578, 1254, 1287,\n+ \/*   210 *\/  1578, 1578, 1388, 1388, 1283, 1283, 1391, 1558, 1358, 1358,\n+ \/*   220 *\/  1358, 1358, 1367, 1358, 1254, 1254, 1254, 1254, 1254, 1254,\n+ \/*   230 *\/  1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1548,\n+ \/*   240 *\/  1546, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+ \/*   250 *\/  1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+ \/*   260 *\/  1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1363, 1254,\n+ \/*   270 *\/  1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1608,\n+ \/*   280 *\/  1254, 1521, 1343, 1363, 1363, 1363, 1363, 1365, 1344, 1342,\n+ \/*   290 *\/  1357, 1288, 1261, 1655, 1423, 1412, 1364, 1412, 1652, 1410,\n+ \/*   300 *\/  1423, 1423, 1410, 1423, 1364, 1652, 1304, 1630, 1299, 1397,\n+ \/*   310 *\/  1397, 1397, 1387, 1387, 1387, 1387, 1391, 1391, 1489, 1364,\n+ \/*   320 *\/  1357, 1254, 1655, 1655, 1373, 1373, 1654, 1654, 1373, 1509,\n+ \/*   330 *\/  1638, 1432, 1332, 1338, 1338, 1338, 1338, 1373, 1272, 1410,\n+ \/*   340 *\/  1638, 1638, 1410, 1432, 1332, 1410, 1332, 1410, 1373, 1272,\n+ \/*   350 *\/  1525, 1649, 1373, 1272, 1499, 1373, 1272, 1373, 1272, 1499,\n+ \/*   360 *\/  1330, 1330, 1330, 1319, 1254, 1254, 1499, 1330, 1304, 1330,\n+ \/*   370 *\/  1319, 1330, 1330, 1596, 1254, 1503, 1503, 1499, 1373, 1588,\n+ \/*   380 *\/  1588, 1400, 1400, 1405, 1391, 1494, 1373, 1254, 1405, 1403,\n+ \/*   390 *\/  1401, 1410, 1322, 1611, 1611, 1607, 1607, 1607, 1660, 1660,\n+ \/*   400 *\/  1558, 1623, 1287, 1287, 1287, 1287, 1623, 1306, 1306, 1288,\n+ \/*   410 *\/  1288, 1287, 1623, 1254, 1254, 1254, 1254, 1254, 1254, 1618,\n+ \/*   420 *\/  1254, 1553, 1510, 1377, 1254, 1254, 1254, 1254, 1254, 1254,\n+ \/*   430 *\/  1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+ \/*   440 *\/  1564, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+ \/*   450 *\/  1254, 1254, 1437, 1254, 1257, 1555, 1254, 1254, 1254, 1254,\n+ \/*   460 *\/  1254, 1254, 1254, 1254, 1414, 1415, 1378, 1254, 1254, 1254,\n+ \/*   470 *\/  1254, 1254, 1254, 1254, 1429, 1254, 1254, 1254, 1424, 1254,\n+ \/*   480 *\/  1254, 1254, 1254, 1254, 1254, 1254, 1254, 1651, 1254, 1254,\n+ \/*   490 *\/  1254, 1254, 1254, 1254, 1524, 1523, 1254, 1254, 1375, 1254,\n+ \/*   500 *\/  1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+ \/*   510 *\/  1254, 1254, 1302, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+ \/*   520 *\/  1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+ \/*   530 *\/  1254, 1254, 1254, 1254, 1254, 1254, 1402, 1254, 1254, 1254,\n+ \/*   540 *\/  1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+ \/*   550 *\/  1254, 1593, 1392, 1254, 1254, 1254, 1254, 1642, 1254, 1254,\n+ \/*   560 *\/  1254, 1254, 1352, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+ \/*   570 *\/  1254, 1254, 1254, 1634, 1346, 1438, 1254, 1441, 1276, 1254,\n+ \/*   580 *\/  1266, 1254, 1254,\n@@ -172353,4 +175486,4 @@\n-   59,  \/*    EXPLAIN => ID *\/\n-   59,  \/*      QUERY => ID *\/\n-   59,  \/*       PLAN => ID *\/\n-   59,  \/*      BEGIN => ID *\/\n+   60,  \/*    EXPLAIN => ID *\/\n+   60,  \/*      QUERY => ID *\/\n+   60,  \/*       PLAN => ID *\/\n+   60,  \/*      BEGIN => ID *\/\n@@ -172358,3 +175491,3 @@\n-   59,  \/*   DEFERRED => ID *\/\n-   59,  \/*  IMMEDIATE => ID *\/\n-   59,  \/*  EXCLUSIVE => ID *\/\n+   60,  \/*   DEFERRED => ID *\/\n+   60,  \/*  IMMEDIATE => ID *\/\n+   60,  \/*  EXCLUSIVE => ID *\/\n@@ -172362,4 +175495,4 @@\n-   59,  \/*        END => ID *\/\n-   59,  \/*   ROLLBACK => ID *\/\n-   59,  \/*  SAVEPOINT => ID *\/\n-   59,  \/*    RELEASE => ID *\/\n+   60,  \/*        END => ID *\/\n+   60,  \/*   ROLLBACK => ID *\/\n+   60,  \/*  SAVEPOINT => ID *\/\n+   60,  \/*    RELEASE => ID *\/\n@@ -172369,1 +175502,1 @@\n-   59,  \/*         IF => ID *\/\n+   60,  \/*         IF => ID *\/\n@@ -172372,1 +175505,1 @@\n-   59,  \/*       TEMP => ID *\/\n+   60,  \/*       TEMP => ID *\/\n@@ -172377,17 +175510,17 @@\n-   59,  \/*    WITHOUT => ID *\/\n-   59,  \/*      ABORT => ID *\/\n-   59,  \/*     ACTION => ID *\/\n-   59,  \/*      AFTER => ID *\/\n-   59,  \/*    ANALYZE => ID *\/\n-   59,  \/*        ASC => ID *\/\n-   59,  \/*     ATTACH => ID *\/\n-   59,  \/*     BEFORE => ID *\/\n-   59,  \/*         BY => ID *\/\n-   59,  \/*    CASCADE => ID *\/\n-   59,  \/*       CAST => ID *\/\n-   59,  \/*   CONFLICT => ID *\/\n-   59,  \/*   DATABASE => ID *\/\n-   59,  \/*       DESC => ID *\/\n-   59,  \/*     DETACH => ID *\/\n-   59,  \/*       EACH => ID *\/\n-   59,  \/*       FAIL => ID *\/\n+   60,  \/*    WITHOUT => ID *\/\n+   60,  \/*      ABORT => ID *\/\n+   60,  \/*     ACTION => ID *\/\n+   60,  \/*      AFTER => ID *\/\n+   60,  \/*    ANALYZE => ID *\/\n+   60,  \/*        ASC => ID *\/\n+   60,  \/*     ATTACH => ID *\/\n+   60,  \/*     BEFORE => ID *\/\n+   60,  \/*         BY => ID *\/\n+   60,  \/*    CASCADE => ID *\/\n+   60,  \/*       CAST => ID *\/\n+   60,  \/*   CONFLICT => ID *\/\n+   60,  \/*   DATABASE => ID *\/\n+   60,  \/*       DESC => ID *\/\n+   60,  \/*     DETACH => ID *\/\n+   60,  \/*       EACH => ID *\/\n+   60,  \/*       FAIL => ID *\/\n@@ -172397,2 +175530,3 @@\n-   59,  \/*      MATCH => ID *\/\n-   59,  \/*    LIKE_KW => ID *\/\n+    0,  \/*      ISNOT => nothing *\/\n+   60,  \/*      MATCH => ID *\/\n+   60,  \/*    LIKE_KW => ID *\/\n@@ -172411,41 +175545,41 @@\n-   59,  \/*   COLUMNKW => ID *\/\n-   59,  \/*         DO => ID *\/\n-   59,  \/*        FOR => ID *\/\n-   59,  \/*     IGNORE => ID *\/\n-   59,  \/*  INITIALLY => ID *\/\n-   59,  \/*    INSTEAD => ID *\/\n-   59,  \/*         NO => ID *\/\n-   59,  \/*        KEY => ID *\/\n-   59,  \/*         OF => ID *\/\n-   59,  \/*     OFFSET => ID *\/\n-   59,  \/*     PRAGMA => ID *\/\n-   59,  \/*      RAISE => ID *\/\n-   59,  \/*  RECURSIVE => ID *\/\n-   59,  \/*    REPLACE => ID *\/\n-   59,  \/*   RESTRICT => ID *\/\n-   59,  \/*        ROW => ID *\/\n-   59,  \/*       ROWS => ID *\/\n-   59,  \/*    TRIGGER => ID *\/\n-   59,  \/*     VACUUM => ID *\/\n-   59,  \/*       VIEW => ID *\/\n-   59,  \/*    VIRTUAL => ID *\/\n-   59,  \/*       WITH => ID *\/\n-   59,  \/*      NULLS => ID *\/\n-   59,  \/*      FIRST => ID *\/\n-   59,  \/*       LAST => ID *\/\n-   59,  \/*    CURRENT => ID *\/\n-   59,  \/*  FOLLOWING => ID *\/\n-   59,  \/*  PARTITION => ID *\/\n-   59,  \/*  PRECEDING => ID *\/\n-   59,  \/*      RANGE => ID *\/\n-   59,  \/*  UNBOUNDED => ID *\/\n-   59,  \/*    EXCLUDE => ID *\/\n-   59,  \/*     GROUPS => ID *\/\n-   59,  \/*     OTHERS => ID *\/\n-   59,  \/*       TIES => ID *\/\n-   59,  \/*  GENERATED => ID *\/\n-   59,  \/*     ALWAYS => ID *\/\n-   59,  \/* MATERIALIZED => ID *\/\n-   59,  \/*    REINDEX => ID *\/\n-   59,  \/*     RENAME => ID *\/\n-   59,  \/*   CTIME_KW => ID *\/\n+   60,  \/*   COLUMNKW => ID *\/\n+   60,  \/*         DO => ID *\/\n+   60,  \/*        FOR => ID *\/\n+   60,  \/*     IGNORE => ID *\/\n+   60,  \/*  INITIALLY => ID *\/\n+   60,  \/*    INSTEAD => ID *\/\n+   60,  \/*         NO => ID *\/\n+   60,  \/*        KEY => ID *\/\n+   60,  \/*         OF => ID *\/\n+   60,  \/*     OFFSET => ID *\/\n+   60,  \/*     PRAGMA => ID *\/\n+   60,  \/*      RAISE => ID *\/\n+   60,  \/*  RECURSIVE => ID *\/\n+   60,  \/*    REPLACE => ID *\/\n+   60,  \/*   RESTRICT => ID *\/\n+   60,  \/*        ROW => ID *\/\n+   60,  \/*       ROWS => ID *\/\n+   60,  \/*    TRIGGER => ID *\/\n+   60,  \/*     VACUUM => ID *\/\n+   60,  \/*       VIEW => ID *\/\n+   60,  \/*    VIRTUAL => ID *\/\n+   60,  \/*       WITH => ID *\/\n+   60,  \/*      NULLS => ID *\/\n+   60,  \/*      FIRST => ID *\/\n+   60,  \/*       LAST => ID *\/\n+   60,  \/*    CURRENT => ID *\/\n+   60,  \/*  FOLLOWING => ID *\/\n+   60,  \/*  PARTITION => ID *\/\n+   60,  \/*  PRECEDING => ID *\/\n+   60,  \/*      RANGE => ID *\/\n+   60,  \/*  UNBOUNDED => ID *\/\n+   60,  \/*    EXCLUDE => ID *\/\n+   60,  \/*     GROUPS => ID *\/\n+   60,  \/*     OTHERS => ID *\/\n+   60,  \/*       TIES => ID *\/\n+   60,  \/*  GENERATED => ID *\/\n+   60,  \/*     ALWAYS => ID *\/\n+   60,  \/* MATERIALIZED => ID *\/\n+   60,  \/*    REINDEX => ID *\/\n+   60,  \/*     RENAME => ID *\/\n+   60,  \/*   CTIME_KW => ID *\/\n@@ -172522,1 +175656,0 @@\n-    0,  \/*      ISNOT => nothing *\/\n@@ -172524,1 +175657,0 @@\n-    0,  \/*     UMINUS => nothing *\/\n@@ -172526,0 +175658,1 @@\n+    0,  \/*     UMINUS => nothing *\/\n@@ -172534,0 +175667,1 @@\n+    0,  \/*    QNUMBER => nothing *\/\n@@ -172535,0 +175669,1 @@\n+    0,  \/*    COMMENT => nothing *\/\n@@ -172576,8 +175711,3 @@\n-#if YYSTACKDEPTH<=0\n-  int yystksz;                  \/* Current side of the stack *\/\n-  yyStackEntry *yystack;        \/* The parser's stack *\/\n-  yyStackEntry yystk0;          \/* First stack entry *\/\n-#else\n-  yyStackEntry yystack[YYSTACKDEPTH];  \/* The parser's stack *\/\n-  yyStackEntry *yystackEnd;            \/* Last entry in the stack *\/\n-#endif\n+  yyStackEntry *yystackEnd;           \/* Last entry in the stack *\/\n+  yyStackEntry *yystack;              \/* The parser stack *\/\n+  yyStackEntry yystk0[YYSTACKDEPTH];  \/* Initial stack space *\/\n@@ -172670,126 +175800,126 @@\n-  \/*   46 *\/ \"MATCH\",\n-  \/*   47 *\/ \"LIKE_KW\",\n-  \/*   48 *\/ \"BETWEEN\",\n-  \/*   49 *\/ \"IN\",\n-  \/*   50 *\/ \"ISNULL\",\n-  \/*   51 *\/ \"NOTNULL\",\n-  \/*   52 *\/ \"NE\",\n-  \/*   53 *\/ \"EQ\",\n-  \/*   54 *\/ \"GT\",\n-  \/*   55 *\/ \"LE\",\n-  \/*   56 *\/ \"LT\",\n-  \/*   57 *\/ \"GE\",\n-  \/*   58 *\/ \"ESCAPE\",\n-  \/*   59 *\/ \"ID\",\n-  \/*   60 *\/ \"COLUMNKW\",\n-  \/*   61 *\/ \"DO\",\n-  \/*   62 *\/ \"FOR\",\n-  \/*   63 *\/ \"IGNORE\",\n-  \/*   64 *\/ \"INITIALLY\",\n-  \/*   65 *\/ \"INSTEAD\",\n-  \/*   66 *\/ \"NO\",\n-  \/*   67 *\/ \"KEY\",\n-  \/*   68 *\/ \"OF\",\n-  \/*   69 *\/ \"OFFSET\",\n-  \/*   70 *\/ \"PRAGMA\",\n-  \/*   71 *\/ \"RAISE\",\n-  \/*   72 *\/ \"RECURSIVE\",\n-  \/*   73 *\/ \"REPLACE\",\n-  \/*   74 *\/ \"RESTRICT\",\n-  \/*   75 *\/ \"ROW\",\n-  \/*   76 *\/ \"ROWS\",\n-  \/*   77 *\/ \"TRIGGER\",\n-  \/*   78 *\/ \"VACUUM\",\n-  \/*   79 *\/ \"VIEW\",\n-  \/*   80 *\/ \"VIRTUAL\",\n-  \/*   81 *\/ \"WITH\",\n-  \/*   82 *\/ \"NULLS\",\n-  \/*   83 *\/ \"FIRST\",\n-  \/*   84 *\/ \"LAST\",\n-  \/*   85 *\/ \"CURRENT\",\n-  \/*   86 *\/ \"FOLLOWING\",\n-  \/*   87 *\/ \"PARTITION\",\n-  \/*   88 *\/ \"PRECEDING\",\n-  \/*   89 *\/ \"RANGE\",\n-  \/*   90 *\/ \"UNBOUNDED\",\n-  \/*   91 *\/ \"EXCLUDE\",\n-  \/*   92 *\/ \"GROUPS\",\n-  \/*   93 *\/ \"OTHERS\",\n-  \/*   94 *\/ \"TIES\",\n-  \/*   95 *\/ \"GENERATED\",\n-  \/*   96 *\/ \"ALWAYS\",\n-  \/*   97 *\/ \"MATERIALIZED\",\n-  \/*   98 *\/ \"REINDEX\",\n-  \/*   99 *\/ \"RENAME\",\n-  \/*  100 *\/ \"CTIME_KW\",\n-  \/*  101 *\/ \"ANY\",\n-  \/*  102 *\/ \"BITAND\",\n-  \/*  103 *\/ \"BITOR\",\n-  \/*  104 *\/ \"LSHIFT\",\n-  \/*  105 *\/ \"RSHIFT\",\n-  \/*  106 *\/ \"PLUS\",\n-  \/*  107 *\/ \"MINUS\",\n-  \/*  108 *\/ \"STAR\",\n-  \/*  109 *\/ \"SLASH\",\n-  \/*  110 *\/ \"REM\",\n-  \/*  111 *\/ \"CONCAT\",\n-  \/*  112 *\/ \"PTR\",\n-  \/*  113 *\/ \"COLLATE\",\n-  \/*  114 *\/ \"BITNOT\",\n-  \/*  115 *\/ \"ON\",\n-  \/*  116 *\/ \"INDEXED\",\n-  \/*  117 *\/ \"STRING\",\n-  \/*  118 *\/ \"JOIN_KW\",\n-  \/*  119 *\/ \"CONSTRAINT\",\n-  \/*  120 *\/ \"DEFAULT\",\n-  \/*  121 *\/ \"NULL\",\n-  \/*  122 *\/ \"PRIMARY\",\n-  \/*  123 *\/ \"UNIQUE\",\n-  \/*  124 *\/ \"CHECK\",\n-  \/*  125 *\/ \"REFERENCES\",\n-  \/*  126 *\/ \"AUTOINCR\",\n-  \/*  127 *\/ \"INSERT\",\n-  \/*  128 *\/ \"DELETE\",\n-  \/*  129 *\/ \"UPDATE\",\n-  \/*  130 *\/ \"SET\",\n-  \/*  131 *\/ \"DEFERRABLE\",\n-  \/*  132 *\/ \"FOREIGN\",\n-  \/*  133 *\/ \"DROP\",\n-  \/*  134 *\/ \"UNION\",\n-  \/*  135 *\/ \"ALL\",\n-  \/*  136 *\/ \"EXCEPT\",\n-  \/*  137 *\/ \"INTERSECT\",\n-  \/*  138 *\/ \"SELECT\",\n-  \/*  139 *\/ \"VALUES\",\n-  \/*  140 *\/ \"DISTINCT\",\n-  \/*  141 *\/ \"DOT\",\n-  \/*  142 *\/ \"FROM\",\n-  \/*  143 *\/ \"JOIN\",\n-  \/*  144 *\/ \"USING\",\n-  \/*  145 *\/ \"ORDER\",\n-  \/*  146 *\/ \"GROUP\",\n-  \/*  147 *\/ \"HAVING\",\n-  \/*  148 *\/ \"LIMIT\",\n-  \/*  149 *\/ \"WHERE\",\n-  \/*  150 *\/ \"RETURNING\",\n-  \/*  151 *\/ \"INTO\",\n-  \/*  152 *\/ \"NOTHING\",\n-  \/*  153 *\/ \"FLOAT\",\n-  \/*  154 *\/ \"BLOB\",\n-  \/*  155 *\/ \"INTEGER\",\n-  \/*  156 *\/ \"VARIABLE\",\n-  \/*  157 *\/ \"CASE\",\n-  \/*  158 *\/ \"WHEN\",\n-  \/*  159 *\/ \"THEN\",\n-  \/*  160 *\/ \"ELSE\",\n-  \/*  161 *\/ \"INDEX\",\n-  \/*  162 *\/ \"ALTER\",\n-  \/*  163 *\/ \"ADD\",\n-  \/*  164 *\/ \"WINDOW\",\n-  \/*  165 *\/ \"OVER\",\n-  \/*  166 *\/ \"FILTER\",\n-  \/*  167 *\/ \"COLUMN\",\n-  \/*  168 *\/ \"AGG_FUNCTION\",\n-  \/*  169 *\/ \"AGG_COLUMN\",\n-  \/*  170 *\/ \"TRUEFALSE\",\n-  \/*  171 *\/ \"ISNOT\",\n+  \/*   46 *\/ \"ISNOT\",\n+  \/*   47 *\/ \"MATCH\",\n+  \/*   48 *\/ \"LIKE_KW\",\n+  \/*   49 *\/ \"BETWEEN\",\n+  \/*   50 *\/ \"IN\",\n+  \/*   51 *\/ \"ISNULL\",\n+  \/*   52 *\/ \"NOTNULL\",\n+  \/*   53 *\/ \"NE\",\n+  \/*   54 *\/ \"EQ\",\n+  \/*   55 *\/ \"GT\",\n+  \/*   56 *\/ \"LE\",\n+  \/*   57 *\/ \"LT\",\n+  \/*   58 *\/ \"GE\",\n+  \/*   59 *\/ \"ESCAPE\",\n+  \/*   60 *\/ \"ID\",\n+  \/*   61 *\/ \"COLUMNKW\",\n+  \/*   62 *\/ \"DO\",\n+  \/*   63 *\/ \"FOR\",\n+  \/*   64 *\/ \"IGNORE\",\n+  \/*   65 *\/ \"INITIALLY\",\n+  \/*   66 *\/ \"INSTEAD\",\n+  \/*   67 *\/ \"NO\",\n+  \/*   68 *\/ \"KEY\",\n+  \/*   69 *\/ \"OF\",\n+  \/*   70 *\/ \"OFFSET\",\n+  \/*   71 *\/ \"PRAGMA\",\n+  \/*   72 *\/ \"RAISE\",\n+  \/*   73 *\/ \"RECURSIVE\",\n+  \/*   74 *\/ \"REPLACE\",\n+  \/*   75 *\/ \"RESTRICT\",\n+  \/*   76 *\/ \"ROW\",\n+  \/*   77 *\/ \"ROWS\",\n+  \/*   78 *\/ \"TRIGGER\",\n+  \/*   79 *\/ \"VACUUM\",\n+  \/*   80 *\/ \"VIEW\",\n+  \/*   81 *\/ \"VIRTUAL\",\n+  \/*   82 *\/ \"WITH\",\n+  \/*   83 *\/ \"NULLS\",\n+  \/*   84 *\/ \"FIRST\",\n+  \/*   85 *\/ \"LAST\",\n+  \/*   86 *\/ \"CURRENT\",\n+  \/*   87 *\/ \"FOLLOWING\",\n+  \/*   88 *\/ \"PARTITION\",\n+  \/*   89 *\/ \"PRECEDING\",\n+  \/*   90 *\/ \"RANGE\",\n+  \/*   91 *\/ \"UNBOUNDED\",\n+  \/*   92 *\/ \"EXCLUDE\",\n+  \/*   93 *\/ \"GROUPS\",\n+  \/*   94 *\/ \"OTHERS\",\n+  \/*   95 *\/ \"TIES\",\n+  \/*   96 *\/ \"GENERATED\",\n+  \/*   97 *\/ \"ALWAYS\",\n+  \/*   98 *\/ \"MATERIALIZED\",\n+  \/*   99 *\/ \"REINDEX\",\n+  \/*  100 *\/ \"RENAME\",\n+  \/*  101 *\/ \"CTIME_KW\",\n+  \/*  102 *\/ \"ANY\",\n+  \/*  103 *\/ \"BITAND\",\n+  \/*  104 *\/ \"BITOR\",\n+  \/*  105 *\/ \"LSHIFT\",\n+  \/*  106 *\/ \"RSHIFT\",\n+  \/*  107 *\/ \"PLUS\",\n+  \/*  108 *\/ \"MINUS\",\n+  \/*  109 *\/ \"STAR\",\n+  \/*  110 *\/ \"SLASH\",\n+  \/*  111 *\/ \"REM\",\n+  \/*  112 *\/ \"CONCAT\",\n+  \/*  113 *\/ \"PTR\",\n+  \/*  114 *\/ \"COLLATE\",\n+  \/*  115 *\/ \"BITNOT\",\n+  \/*  116 *\/ \"ON\",\n+  \/*  117 *\/ \"INDEXED\",\n+  \/*  118 *\/ \"STRING\",\n+  \/*  119 *\/ \"JOIN_KW\",\n+  \/*  120 *\/ \"CONSTRAINT\",\n+  \/*  121 *\/ \"DEFAULT\",\n+  \/*  122 *\/ \"NULL\",\n+  \/*  123 *\/ \"PRIMARY\",\n+  \/*  124 *\/ \"UNIQUE\",\n+  \/*  125 *\/ \"CHECK\",\n+  \/*  126 *\/ \"REFERENCES\",\n+  \/*  127 *\/ \"AUTOINCR\",\n+  \/*  128 *\/ \"INSERT\",\n+  \/*  129 *\/ \"DELETE\",\n+  \/*  130 *\/ \"UPDATE\",\n+  \/*  131 *\/ \"SET\",\n+  \/*  132 *\/ \"DEFERRABLE\",\n+  \/*  133 *\/ \"FOREIGN\",\n+  \/*  134 *\/ \"DROP\",\n+  \/*  135 *\/ \"UNION\",\n+  \/*  136 *\/ \"ALL\",\n+  \/*  137 *\/ \"EXCEPT\",\n+  \/*  138 *\/ \"INTERSECT\",\n+  \/*  139 *\/ \"SELECT\",\n+  \/*  140 *\/ \"VALUES\",\n+  \/*  141 *\/ \"DISTINCT\",\n+  \/*  142 *\/ \"DOT\",\n+  \/*  143 *\/ \"FROM\",\n+  \/*  144 *\/ \"JOIN\",\n+  \/*  145 *\/ \"USING\",\n+  \/*  146 *\/ \"ORDER\",\n+  \/*  147 *\/ \"GROUP\",\n+  \/*  148 *\/ \"HAVING\",\n+  \/*  149 *\/ \"LIMIT\",\n+  \/*  150 *\/ \"WHERE\",\n+  \/*  151 *\/ \"RETURNING\",\n+  \/*  152 *\/ \"INTO\",\n+  \/*  153 *\/ \"NOTHING\",\n+  \/*  154 *\/ \"FLOAT\",\n+  \/*  155 *\/ \"BLOB\",\n+  \/*  156 *\/ \"INTEGER\",\n+  \/*  157 *\/ \"VARIABLE\",\n+  \/*  158 *\/ \"CASE\",\n+  \/*  159 *\/ \"WHEN\",\n+  \/*  160 *\/ \"THEN\",\n+  \/*  161 *\/ \"ELSE\",\n+  \/*  162 *\/ \"INDEX\",\n+  \/*  163 *\/ \"ALTER\",\n+  \/*  164 *\/ \"ADD\",\n+  \/*  165 *\/ \"WINDOW\",\n+  \/*  166 *\/ \"OVER\",\n+  \/*  167 *\/ \"FILTER\",\n+  \/*  168 *\/ \"COLUMN\",\n+  \/*  169 *\/ \"AGG_FUNCTION\",\n+  \/*  170 *\/ \"AGG_COLUMN\",\n+  \/*  171 *\/ \"TRUEFALSE\",\n@@ -172797,2 +175927,2 @@\n-  \/*  173 *\/ \"UMINUS\",\n-  \/*  174 *\/ \"UPLUS\",\n+  \/*  173 *\/ \"UPLUS\",\n+  \/*  174 *\/ \"UMINUS\",\n@@ -172807,136 +175937,140 @@\n-  \/*  183 *\/ \"SPACE\",\n-  \/*  184 *\/ \"ILLEGAL\",\n-  \/*  185 *\/ \"input\",\n-  \/*  186 *\/ \"cmdlist\",\n-  \/*  187 *\/ \"ecmd\",\n-  \/*  188 *\/ \"cmdx\",\n-  \/*  189 *\/ \"explain\",\n-  \/*  190 *\/ \"cmd\",\n-  \/*  191 *\/ \"transtype\",\n-  \/*  192 *\/ \"trans_opt\",\n-  \/*  193 *\/ \"nm\",\n-  \/*  194 *\/ \"savepoint_opt\",\n-  \/*  195 *\/ \"create_table\",\n-  \/*  196 *\/ \"create_table_args\",\n-  \/*  197 *\/ \"createkw\",\n-  \/*  198 *\/ \"temp\",\n-  \/*  199 *\/ \"ifnotexists\",\n-  \/*  200 *\/ \"dbnm\",\n-  \/*  201 *\/ \"columnlist\",\n-  \/*  202 *\/ \"conslist_opt\",\n-  \/*  203 *\/ \"table_option_set\",\n-  \/*  204 *\/ \"select\",\n-  \/*  205 *\/ \"table_option\",\n-  \/*  206 *\/ \"columnname\",\n-  \/*  207 *\/ \"carglist\",\n-  \/*  208 *\/ \"typetoken\",\n-  \/*  209 *\/ \"typename\",\n-  \/*  210 *\/ \"signed\",\n-  \/*  211 *\/ \"plus_num\",\n-  \/*  212 *\/ \"minus_num\",\n-  \/*  213 *\/ \"scanpt\",\n-  \/*  214 *\/ \"scantok\",\n-  \/*  215 *\/ \"ccons\",\n-  \/*  216 *\/ \"term\",\n-  \/*  217 *\/ \"expr\",\n-  \/*  218 *\/ \"onconf\",\n-  \/*  219 *\/ \"sortorder\",\n-  \/*  220 *\/ \"autoinc\",\n-  \/*  221 *\/ \"eidlist_opt\",\n-  \/*  222 *\/ \"refargs\",\n-  \/*  223 *\/ \"defer_subclause\",\n-  \/*  224 *\/ \"generated\",\n-  \/*  225 *\/ \"refarg\",\n-  \/*  226 *\/ \"refact\",\n-  \/*  227 *\/ \"init_deferred_pred_opt\",\n-  \/*  228 *\/ \"conslist\",\n-  \/*  229 *\/ \"tconscomma\",\n-  \/*  230 *\/ \"tcons\",\n-  \/*  231 *\/ \"sortlist\",\n-  \/*  232 *\/ \"eidlist\",\n-  \/*  233 *\/ \"defer_subclause_opt\",\n-  \/*  234 *\/ \"orconf\",\n-  \/*  235 *\/ \"resolvetype\",\n-  \/*  236 *\/ \"raisetype\",\n-  \/*  237 *\/ \"ifexists\",\n-  \/*  238 *\/ \"fullname\",\n-  \/*  239 *\/ \"selectnowith\",\n-  \/*  240 *\/ \"oneselect\",\n-  \/*  241 *\/ \"wqlist\",\n-  \/*  242 *\/ \"multiselect_op\",\n-  \/*  243 *\/ \"distinct\",\n-  \/*  244 *\/ \"selcollist\",\n-  \/*  245 *\/ \"from\",\n-  \/*  246 *\/ \"where_opt\",\n-  \/*  247 *\/ \"groupby_opt\",\n-  \/*  248 *\/ \"having_opt\",\n-  \/*  249 *\/ \"orderby_opt\",\n-  \/*  250 *\/ \"limit_opt\",\n-  \/*  251 *\/ \"window_clause\",\n-  \/*  252 *\/ \"values\",\n-  \/*  253 *\/ \"nexprlist\",\n-  \/*  254 *\/ \"sclp\",\n-  \/*  255 *\/ \"as\",\n-  \/*  256 *\/ \"seltablist\",\n-  \/*  257 *\/ \"stl_prefix\",\n-  \/*  258 *\/ \"joinop\",\n-  \/*  259 *\/ \"on_using\",\n-  \/*  260 *\/ \"indexed_by\",\n-  \/*  261 *\/ \"exprlist\",\n-  \/*  262 *\/ \"xfullname\",\n-  \/*  263 *\/ \"idlist\",\n-  \/*  264 *\/ \"indexed_opt\",\n-  \/*  265 *\/ \"nulls\",\n-  \/*  266 *\/ \"with\",\n-  \/*  267 *\/ \"where_opt_ret\",\n-  \/*  268 *\/ \"setlist\",\n-  \/*  269 *\/ \"insert_cmd\",\n-  \/*  270 *\/ \"idlist_opt\",\n-  \/*  271 *\/ \"upsert\",\n-  \/*  272 *\/ \"returning\",\n-  \/*  273 *\/ \"filter_over\",\n-  \/*  274 *\/ \"likeop\",\n-  \/*  275 *\/ \"between_op\",\n-  \/*  276 *\/ \"in_op\",\n-  \/*  277 *\/ \"paren_exprlist\",\n-  \/*  278 *\/ \"case_operand\",\n-  \/*  279 *\/ \"case_exprlist\",\n-  \/*  280 *\/ \"case_else\",\n-  \/*  281 *\/ \"uniqueflag\",\n-  \/*  282 *\/ \"collate\",\n-  \/*  283 *\/ \"vinto\",\n-  \/*  284 *\/ \"nmnum\",\n-  \/*  285 *\/ \"trigger_decl\",\n-  \/*  286 *\/ \"trigger_cmd_list\",\n-  \/*  287 *\/ \"trigger_time\",\n-  \/*  288 *\/ \"trigger_event\",\n-  \/*  289 *\/ \"foreach_clause\",\n-  \/*  290 *\/ \"when_clause\",\n-  \/*  291 *\/ \"trigger_cmd\",\n-  \/*  292 *\/ \"trnm\",\n-  \/*  293 *\/ \"tridxby\",\n-  \/*  294 *\/ \"database_kw_opt\",\n-  \/*  295 *\/ \"key_opt\",\n-  \/*  296 *\/ \"add_column_fullname\",\n-  \/*  297 *\/ \"kwcolumn_opt\",\n-  \/*  298 *\/ \"create_vtab\",\n-  \/*  299 *\/ \"vtabarglist\",\n-  \/*  300 *\/ \"vtabarg\",\n-  \/*  301 *\/ \"vtabargtoken\",\n-  \/*  302 *\/ \"lp\",\n-  \/*  303 *\/ \"anylist\",\n-  \/*  304 *\/ \"wqitem\",\n-  \/*  305 *\/ \"wqas\",\n-  \/*  306 *\/ \"windowdefn_list\",\n-  \/*  307 *\/ \"windowdefn\",\n-  \/*  308 *\/ \"window\",\n-  \/*  309 *\/ \"frame_opt\",\n-  \/*  310 *\/ \"part_opt\",\n-  \/*  311 *\/ \"filter_clause\",\n-  \/*  312 *\/ \"over_clause\",\n-  \/*  313 *\/ \"range_or_rows\",\n-  \/*  314 *\/ \"frame_bound\",\n-  \/*  315 *\/ \"frame_bound_s\",\n-  \/*  316 *\/ \"frame_bound_e\",\n-  \/*  317 *\/ \"frame_exclude_opt\",\n-  \/*  318 *\/ \"frame_exclude\",\n+  \/*  183 *\/ \"QNUMBER\",\n+  \/*  184 *\/ \"SPACE\",\n+  \/*  185 *\/ \"COMMENT\",\n+  \/*  186 *\/ \"ILLEGAL\",\n+  \/*  187 *\/ \"input\",\n+  \/*  188 *\/ \"cmdlist\",\n+  \/*  189 *\/ \"ecmd\",\n+  \/*  190 *\/ \"cmdx\",\n+  \/*  191 *\/ \"explain\",\n+  \/*  192 *\/ \"cmd\",\n+  \/*  193 *\/ \"transtype\",\n+  \/*  194 *\/ \"trans_opt\",\n+  \/*  195 *\/ \"nm\",\n+  \/*  196 *\/ \"savepoint_opt\",\n+  \/*  197 *\/ \"create_table\",\n+  \/*  198 *\/ \"create_table_args\",\n+  \/*  199 *\/ \"createkw\",\n+  \/*  200 *\/ \"temp\",\n+  \/*  201 *\/ \"ifnotexists\",\n+  \/*  202 *\/ \"dbnm\",\n+  \/*  203 *\/ \"columnlist\",\n+  \/*  204 *\/ \"conslist_opt\",\n+  \/*  205 *\/ \"table_option_set\",\n+  \/*  206 *\/ \"select\",\n+  \/*  207 *\/ \"table_option\",\n+  \/*  208 *\/ \"columnname\",\n+  \/*  209 *\/ \"carglist\",\n+  \/*  210 *\/ \"typetoken\",\n+  \/*  211 *\/ \"typename\",\n+  \/*  212 *\/ \"signed\",\n+  \/*  213 *\/ \"plus_num\",\n+  \/*  214 *\/ \"minus_num\",\n+  \/*  215 *\/ \"scanpt\",\n+  \/*  216 *\/ \"scantok\",\n+  \/*  217 *\/ \"ccons\",\n+  \/*  218 *\/ \"term\",\n+  \/*  219 *\/ \"expr\",\n+  \/*  220 *\/ \"onconf\",\n+  \/*  221 *\/ \"sortorder\",\n+  \/*  222 *\/ \"autoinc\",\n+  \/*  223 *\/ \"eidlist_opt\",\n+  \/*  224 *\/ \"refargs\",\n+  \/*  225 *\/ \"defer_subclause\",\n+  \/*  226 *\/ \"generated\",\n+  \/*  227 *\/ \"refarg\",\n+  \/*  228 *\/ \"refact\",\n+  \/*  229 *\/ \"init_deferred_pred_opt\",\n+  \/*  230 *\/ \"conslist\",\n+  \/*  231 *\/ \"tconscomma\",\n+  \/*  232 *\/ \"tcons\",\n+  \/*  233 *\/ \"sortlist\",\n+  \/*  234 *\/ \"eidlist\",\n+  \/*  235 *\/ \"defer_subclause_opt\",\n+  \/*  236 *\/ \"orconf\",\n+  \/*  237 *\/ \"resolvetype\",\n+  \/*  238 *\/ \"raisetype\",\n+  \/*  239 *\/ \"ifexists\",\n+  \/*  240 *\/ \"fullname\",\n+  \/*  241 *\/ \"selectnowith\",\n+  \/*  242 *\/ \"oneselect\",\n+  \/*  243 *\/ \"wqlist\",\n+  \/*  244 *\/ \"multiselect_op\",\n+  \/*  245 *\/ \"distinct\",\n+  \/*  246 *\/ \"selcollist\",\n+  \/*  247 *\/ \"from\",\n+  \/*  248 *\/ \"where_opt\",\n+  \/*  249 *\/ \"groupby_opt\",\n+  \/*  250 *\/ \"having_opt\",\n+  \/*  251 *\/ \"orderby_opt\",\n+  \/*  252 *\/ \"limit_opt\",\n+  \/*  253 *\/ \"window_clause\",\n+  \/*  254 *\/ \"values\",\n+  \/*  255 *\/ \"nexprlist\",\n+  \/*  256 *\/ \"mvalues\",\n+  \/*  257 *\/ \"sclp\",\n+  \/*  258 *\/ \"as\",\n+  \/*  259 *\/ \"seltablist\",\n+  \/*  260 *\/ \"stl_prefix\",\n+  \/*  261 *\/ \"joinop\",\n+  \/*  262 *\/ \"on_using\",\n+  \/*  263 *\/ \"indexed_by\",\n+  \/*  264 *\/ \"exprlist\",\n+  \/*  265 *\/ \"xfullname\",\n+  \/*  266 *\/ \"idlist\",\n+  \/*  267 *\/ \"indexed_opt\",\n+  \/*  268 *\/ \"nulls\",\n+  \/*  269 *\/ \"with\",\n+  \/*  270 *\/ \"where_opt_ret\",\n+  \/*  271 *\/ \"setlist\",\n+  \/*  272 *\/ \"insert_cmd\",\n+  \/*  273 *\/ \"idlist_opt\",\n+  \/*  274 *\/ \"upsert\",\n+  \/*  275 *\/ \"returning\",\n+  \/*  276 *\/ \"filter_over\",\n+  \/*  277 *\/ \"likeop\",\n+  \/*  278 *\/ \"between_op\",\n+  \/*  279 *\/ \"in_op\",\n+  \/*  280 *\/ \"paren_exprlist\",\n+  \/*  281 *\/ \"case_operand\",\n+  \/*  282 *\/ \"case_exprlist\",\n+  \/*  283 *\/ \"case_else\",\n+  \/*  284 *\/ \"uniqueflag\",\n+  \/*  285 *\/ \"collate\",\n+  \/*  286 *\/ \"vinto\",\n+  \/*  287 *\/ \"nmnum\",\n+  \/*  288 *\/ \"trigger_decl\",\n+  \/*  289 *\/ \"trigger_cmd_list\",\n+  \/*  290 *\/ \"trigger_time\",\n+  \/*  291 *\/ \"trigger_event\",\n+  \/*  292 *\/ \"foreach_clause\",\n+  \/*  293 *\/ \"when_clause\",\n+  \/*  294 *\/ \"trigger_cmd\",\n+  \/*  295 *\/ \"trnm\",\n+  \/*  296 *\/ \"tridxby\",\n+  \/*  297 *\/ \"database_kw_opt\",\n+  \/*  298 *\/ \"key_opt\",\n+  \/*  299 *\/ \"add_column_fullname\",\n+  \/*  300 *\/ \"kwcolumn_opt\",\n+  \/*  301 *\/ \"create_vtab\",\n+  \/*  302 *\/ \"vtabarglist\",\n+  \/*  303 *\/ \"vtabarg\",\n+  \/*  304 *\/ \"vtabargtoken\",\n+  \/*  305 *\/ \"lp\",\n+  \/*  306 *\/ \"anylist\",\n+  \/*  307 *\/ \"wqitem\",\n+  \/*  308 *\/ \"wqas\",\n+  \/*  309 *\/ \"withnm\",\n+  \/*  310 *\/ \"windowdefn_list\",\n+  \/*  311 *\/ \"windowdefn\",\n+  \/*  312 *\/ \"window\",\n+  \/*  313 *\/ \"frame_opt\",\n+  \/*  314 *\/ \"part_opt\",\n+  \/*  315 *\/ \"filter_clause\",\n+  \/*  316 *\/ \"over_clause\",\n+  \/*  317 *\/ \"range_or_rows\",\n+  \/*  318 *\/ \"frame_bound\",\n+  \/*  319 *\/ \"frame_bound_s\",\n+  \/*  320 *\/ \"frame_bound_e\",\n+  \/*  321 *\/ \"frame_exclude_opt\",\n+  \/*  322 *\/ \"frame_exclude\",\n@@ -173045,310 +176179,314 @@\n- \/*  95 *\/ \"values ::= values COMMA LP nexprlist RP\",\n- \/*  96 *\/ \"distinct ::= DISTINCT\",\n- \/*  97 *\/ \"distinct ::= ALL\",\n- \/*  98 *\/ \"distinct ::=\",\n- \/*  99 *\/ \"sclp ::=\",\n- \/* 100 *\/ \"selcollist ::= sclp scanpt expr scanpt as\",\n- \/* 101 *\/ \"selcollist ::= sclp scanpt STAR\",\n- \/* 102 *\/ \"selcollist ::= sclp scanpt nm DOT STAR\",\n- \/* 103 *\/ \"as ::= AS nm\",\n- \/* 104 *\/ \"as ::=\",\n- \/* 105 *\/ \"from ::=\",\n- \/* 106 *\/ \"from ::= FROM seltablist\",\n- \/* 107 *\/ \"stl_prefix ::= seltablist joinop\",\n- \/* 108 *\/ \"stl_prefix ::=\",\n- \/* 109 *\/ \"seltablist ::= stl_prefix nm dbnm as on_using\",\n- \/* 110 *\/ \"seltablist ::= stl_prefix nm dbnm as indexed_by on_using\",\n- \/* 111 *\/ \"seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_using\",\n- \/* 112 *\/ \"seltablist ::= stl_prefix LP select RP as on_using\",\n- \/* 113 *\/ \"seltablist ::= stl_prefix LP seltablist RP as on_using\",\n- \/* 114 *\/ \"dbnm ::=\",\n- \/* 115 *\/ \"dbnm ::= DOT nm\",\n- \/* 116 *\/ \"fullname ::= nm\",\n- \/* 117 *\/ \"fullname ::= nm DOT nm\",\n- \/* 118 *\/ \"xfullname ::= nm\",\n- \/* 119 *\/ \"xfullname ::= nm DOT nm\",\n- \/* 120 *\/ \"xfullname ::= nm DOT nm AS nm\",\n- \/* 121 *\/ \"xfullname ::= nm AS nm\",\n- \/* 122 *\/ \"joinop ::= COMMA|JOIN\",\n- \/* 123 *\/ \"joinop ::= JOIN_KW JOIN\",\n- \/* 124 *\/ \"joinop ::= JOIN_KW nm JOIN\",\n- \/* 125 *\/ \"joinop ::= JOIN_KW nm nm JOIN\",\n- \/* 126 *\/ \"on_using ::= ON expr\",\n- \/* 127 *\/ \"on_using ::= USING LP idlist RP\",\n- \/* 128 *\/ \"on_using ::=\",\n- \/* 129 *\/ \"indexed_opt ::=\",\n- \/* 130 *\/ \"indexed_by ::= INDEXED BY nm\",\n- \/* 131 *\/ \"indexed_by ::= NOT INDEXED\",\n- \/* 132 *\/ \"orderby_opt ::=\",\n- \/* 133 *\/ \"orderby_opt ::= ORDER BY sortlist\",\n- \/* 134 *\/ \"sortlist ::= sortlist COMMA expr sortorder nulls\",\n- \/* 135 *\/ \"sortlist ::= expr sortorder nulls\",\n- \/* 136 *\/ \"sortorder ::= ASC\",\n- \/* 137 *\/ \"sortorder ::= DESC\",\n- \/* 138 *\/ \"sortorder ::=\",\n- \/* 139 *\/ \"nulls ::= NULLS FIRST\",\n- \/* 140 *\/ \"nulls ::= NULLS LAST\",\n- \/* 141 *\/ \"nulls ::=\",\n- \/* 142 *\/ \"groupby_opt ::=\",\n- \/* 143 *\/ \"groupby_opt ::= GROUP BY nexprlist\",\n- \/* 144 *\/ \"having_opt ::=\",\n- \/* 145 *\/ \"having_opt ::= HAVING expr\",\n- \/* 146 *\/ \"limit_opt ::=\",\n- \/* 147 *\/ \"limit_opt ::= LIMIT expr\",\n- \/* 148 *\/ \"limit_opt ::= LIMIT expr OFFSET expr\",\n- \/* 149 *\/ \"limit_opt ::= LIMIT expr COMMA expr\",\n- \/* 150 *\/ \"cmd ::= with DELETE FROM xfullname indexed_opt where_opt_ret\",\n- \/* 151 *\/ \"where_opt ::=\",\n- \/* 152 *\/ \"where_opt ::= WHERE expr\",\n- \/* 153 *\/ \"where_opt_ret ::=\",\n- \/* 154 *\/ \"where_opt_ret ::= WHERE expr\",\n- \/* 155 *\/ \"where_opt_ret ::= RETURNING selcollist\",\n- \/* 156 *\/ \"where_opt_ret ::= WHERE expr RETURNING selcollist\",\n- \/* 157 *\/ \"cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist from where_opt_ret\",\n- \/* 158 *\/ \"setlist ::= setlist COMMA nm EQ expr\",\n- \/* 159 *\/ \"setlist ::= setlist COMMA LP idlist RP EQ expr\",\n- \/* 160 *\/ \"setlist ::= nm EQ expr\",\n- \/* 161 *\/ \"setlist ::= LP idlist RP EQ expr\",\n- \/* 162 *\/ \"cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert\",\n- \/* 163 *\/ \"cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES returning\",\n- \/* 164 *\/ \"upsert ::=\",\n- \/* 165 *\/ \"upsert ::= RETURNING selcollist\",\n- \/* 166 *\/ \"upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt upsert\",\n- \/* 167 *\/ \"upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING upsert\",\n- \/* 168 *\/ \"upsert ::= ON CONFLICT DO NOTHING returning\",\n- \/* 169 *\/ \"upsert ::= ON CONFLICT DO UPDATE SET setlist where_opt returning\",\n- \/* 170 *\/ \"returning ::= RETURNING selcollist\",\n- \/* 171 *\/ \"insert_cmd ::= INSERT orconf\",\n- \/* 172 *\/ \"insert_cmd ::= REPLACE\",\n- \/* 173 *\/ \"idlist_opt ::=\",\n- \/* 174 *\/ \"idlist_opt ::= LP idlist RP\",\n- \/* 175 *\/ \"idlist ::= idlist COMMA nm\",\n- \/* 176 *\/ \"idlist ::= nm\",\n- \/* 177 *\/ \"expr ::= LP expr RP\",\n- \/* 178 *\/ \"expr ::= ID|INDEXED|JOIN_KW\",\n- \/* 179 *\/ \"expr ::= nm DOT nm\",\n- \/* 180 *\/ \"expr ::= nm DOT nm DOT nm\",\n- \/* 181 *\/ \"term ::= NULL|FLOAT|BLOB\",\n- \/* 182 *\/ \"term ::= STRING\",\n- \/* 183 *\/ \"term ::= INTEGER\",\n- \/* 184 *\/ \"expr ::= VARIABLE\",\n- \/* 185 *\/ \"expr ::= expr COLLATE ID|STRING\",\n- \/* 186 *\/ \"expr ::= CAST LP expr AS typetoken RP\",\n- \/* 187 *\/ \"expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP\",\n- \/* 188 *\/ \"expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP\",\n- \/* 189 *\/ \"expr ::= ID|INDEXED|JOIN_KW LP STAR RP\",\n- \/* 190 *\/ \"expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP filter_over\",\n- \/* 191 *\/ \"expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP filter_over\",\n- \/* 192 *\/ \"expr ::= ID|INDEXED|JOIN_KW LP STAR RP filter_over\",\n- \/* 193 *\/ \"term ::= CTIME_KW\",\n- \/* 194 *\/ \"expr ::= LP nexprlist COMMA expr RP\",\n- \/* 195 *\/ \"expr ::= expr AND expr\",\n- \/* 196 *\/ \"expr ::= expr OR expr\",\n- \/* 197 *\/ \"expr ::= expr LT|GT|GE|LE expr\",\n- \/* 198 *\/ \"expr ::= expr EQ|NE expr\",\n- \/* 199 *\/ \"expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr\",\n- \/* 200 *\/ \"expr ::= expr PLUS|MINUS expr\",\n- \/* 201 *\/ \"expr ::= expr STAR|SLASH|REM expr\",\n- \/* 202 *\/ \"expr ::= expr CONCAT expr\",\n- \/* 203 *\/ \"likeop ::= NOT LIKE_KW|MATCH\",\n- \/* 204 *\/ \"expr ::= expr likeop expr\",\n- \/* 205 *\/ \"expr ::= expr likeop expr ESCAPE expr\",\n- \/* 206 *\/ \"expr ::= expr ISNULL|NOTNULL\",\n- \/* 207 *\/ \"expr ::= expr NOT NULL\",\n- \/* 208 *\/ \"expr ::= expr IS expr\",\n- \/* 209 *\/ \"expr ::= expr IS NOT expr\",\n- \/* 210 *\/ \"expr ::= expr IS NOT DISTINCT FROM expr\",\n- \/* 211 *\/ \"expr ::= expr IS DISTINCT FROM expr\",\n- \/* 212 *\/ \"expr ::= NOT expr\",\n- \/* 213 *\/ \"expr ::= BITNOT expr\",\n- \/* 214 *\/ \"expr ::= PLUS|MINUS expr\",\n- \/* 215 *\/ \"expr ::= expr PTR expr\",\n- \/* 216 *\/ \"between_op ::= BETWEEN\",\n- \/* 217 *\/ \"between_op ::= NOT BETWEEN\",\n- \/* 218 *\/ \"expr ::= expr between_op expr AND expr\",\n- \/* 219 *\/ \"in_op ::= IN\",\n- \/* 220 *\/ \"in_op ::= NOT IN\",\n- \/* 221 *\/ \"expr ::= expr in_op LP exprlist RP\",\n- \/* 222 *\/ \"expr ::= LP select RP\",\n- \/* 223 *\/ \"expr ::= expr in_op LP select RP\",\n- \/* 224 *\/ \"expr ::= expr in_op nm dbnm paren_exprlist\",\n- \/* 225 *\/ \"expr ::= EXISTS LP select RP\",\n- \/* 226 *\/ \"expr ::= CASE case_operand case_exprlist case_else END\",\n- \/* 227 *\/ \"case_exprlist ::= case_exprlist WHEN expr THEN expr\",\n- \/* 228 *\/ \"case_exprlist ::= WHEN expr THEN expr\",\n- \/* 229 *\/ \"case_else ::= ELSE expr\",\n- \/* 230 *\/ \"case_else ::=\",\n- \/* 231 *\/ \"case_operand ::=\",\n- \/* 232 *\/ \"exprlist ::=\",\n- \/* 233 *\/ \"nexprlist ::= nexprlist COMMA expr\",\n- \/* 234 *\/ \"nexprlist ::= expr\",\n- \/* 235 *\/ \"paren_exprlist ::=\",\n- \/* 236 *\/ \"paren_exprlist ::= LP exprlist RP\",\n- \/* 237 *\/ \"cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt\",\n- \/* 238 *\/ \"uniqueflag ::= UNIQUE\",\n- \/* 239 *\/ \"uniqueflag ::=\",\n- \/* 240 *\/ \"eidlist_opt ::=\",\n- \/* 241 *\/ \"eidlist_opt ::= LP eidlist RP\",\n- \/* 242 *\/ \"eidlist ::= eidlist COMMA nm collate sortorder\",\n- \/* 243 *\/ \"eidlist ::= nm collate sortorder\",\n- \/* 244 *\/ \"collate ::=\",\n- \/* 245 *\/ \"collate ::= COLLATE ID|STRING\",\n- \/* 246 *\/ \"cmd ::= DROP INDEX ifexists fullname\",\n- \/* 247 *\/ \"cmd ::= VACUUM vinto\",\n- \/* 248 *\/ \"cmd ::= VACUUM nm vinto\",\n- \/* 249 *\/ \"vinto ::= INTO expr\",\n- \/* 250 *\/ \"vinto ::=\",\n- \/* 251 *\/ \"cmd ::= PRAGMA nm dbnm\",\n- \/* 252 *\/ \"cmd ::= PRAGMA nm dbnm EQ nmnum\",\n- \/* 253 *\/ \"cmd ::= PRAGMA nm dbnm LP nmnum RP\",\n- \/* 254 *\/ \"cmd ::= PRAGMA nm dbnm EQ minus_num\",\n- \/* 255 *\/ \"cmd ::= PRAGMA nm dbnm LP minus_num RP\",\n- \/* 256 *\/ \"plus_num ::= PLUS INTEGER|FLOAT\",\n- \/* 257 *\/ \"minus_num ::= MINUS INTEGER|FLOAT\",\n- \/* 258 *\/ \"cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END\",\n- \/* 259 *\/ \"trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause\",\n- \/* 260 *\/ \"trigger_time ::= BEFORE|AFTER\",\n- \/* 261 *\/ \"trigger_time ::= INSTEAD OF\",\n- \/* 262 *\/ \"trigger_time ::=\",\n- \/* 263 *\/ \"trigger_event ::= DELETE|INSERT\",\n- \/* 264 *\/ \"trigger_event ::= UPDATE\",\n- \/* 265 *\/ \"trigger_event ::= UPDATE OF idlist\",\n- \/* 266 *\/ \"when_clause ::=\",\n- \/* 267 *\/ \"when_clause ::= WHEN expr\",\n- \/* 268 *\/ \"trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI\",\n- \/* 269 *\/ \"trigger_cmd_list ::= trigger_cmd SEMI\",\n- \/* 270 *\/ \"trnm ::= nm DOT nm\",\n- \/* 271 *\/ \"tridxby ::= INDEXED BY nm\",\n- \/* 272 *\/ \"tridxby ::= NOT INDEXED\",\n- \/* 273 *\/ \"trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist from where_opt scanpt\",\n- \/* 274 *\/ \"trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt\",\n- \/* 275 *\/ \"trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt\",\n- \/* 276 *\/ \"trigger_cmd ::= scanpt select scanpt\",\n- \/* 277 *\/ \"expr ::= RAISE LP IGNORE RP\",\n- \/* 278 *\/ \"expr ::= RAISE LP raisetype COMMA nm RP\",\n- \/* 279 *\/ \"raisetype ::= ROLLBACK\",\n- \/* 280 *\/ \"raisetype ::= ABORT\",\n- \/* 281 *\/ \"raisetype ::= FAIL\",\n- \/* 282 *\/ \"cmd ::= DROP TRIGGER ifexists fullname\",\n- \/* 283 *\/ \"cmd ::= ATTACH database_kw_opt expr AS expr key_opt\",\n- \/* 284 *\/ \"cmd ::= DETACH database_kw_opt expr\",\n- \/* 285 *\/ \"key_opt ::=\",\n- \/* 286 *\/ \"key_opt ::= KEY expr\",\n- \/* 287 *\/ \"cmd ::= REINDEX\",\n- \/* 288 *\/ \"cmd ::= REINDEX nm dbnm\",\n- \/* 289 *\/ \"cmd ::= ANALYZE\",\n- \/* 290 *\/ \"cmd ::= ANALYZE nm dbnm\",\n- \/* 291 *\/ \"cmd ::= ALTER TABLE fullname RENAME TO nm\",\n- \/* 292 *\/ \"cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist\",\n- \/* 293 *\/ \"cmd ::= ALTER TABLE fullname DROP kwcolumn_opt nm\",\n- \/* 294 *\/ \"add_column_fullname ::= fullname\",\n- \/* 295 *\/ \"cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm\",\n- \/* 296 *\/ \"cmd ::= create_vtab\",\n- \/* 297 *\/ \"cmd ::= create_vtab LP vtabarglist RP\",\n- \/* 298 *\/ \"create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm\",\n- \/* 299 *\/ \"vtabarg ::=\",\n- \/* 300 *\/ \"vtabargtoken ::= ANY\",\n- \/* 301 *\/ \"vtabargtoken ::= lp anylist RP\",\n- \/* 302 *\/ \"lp ::= LP\",\n- \/* 303 *\/ \"with ::= WITH wqlist\",\n- \/* 304 *\/ \"with ::= WITH RECURSIVE wqlist\",\n- \/* 305 *\/ \"wqas ::= AS\",\n- \/* 306 *\/ \"wqas ::= AS MATERIALIZED\",\n- \/* 307 *\/ \"wqas ::= AS NOT MATERIALIZED\",\n- \/* 308 *\/ \"wqitem ::= nm eidlist_opt wqas LP select RP\",\n- \/* 309 *\/ \"wqlist ::= wqitem\",\n- \/* 310 *\/ \"wqlist ::= wqlist COMMA wqitem\",\n- \/* 311 *\/ \"windowdefn_list ::= windowdefn_list COMMA windowdefn\",\n- \/* 312 *\/ \"windowdefn ::= nm AS LP window RP\",\n- \/* 313 *\/ \"window ::= PARTITION BY nexprlist orderby_opt frame_opt\",\n- \/* 314 *\/ \"window ::= nm PARTITION BY nexprlist orderby_opt frame_opt\",\n- \/* 315 *\/ \"window ::= ORDER BY sortlist frame_opt\",\n- \/* 316 *\/ \"window ::= nm ORDER BY sortlist frame_opt\",\n- \/* 317 *\/ \"window ::= nm frame_opt\",\n- \/* 318 *\/ \"frame_opt ::=\",\n- \/* 319 *\/ \"frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt\",\n- \/* 320 *\/ \"frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt\",\n- \/* 321 *\/ \"range_or_rows ::= RANGE|ROWS|GROUPS\",\n- \/* 322 *\/ \"frame_bound_s ::= frame_bound\",\n- \/* 323 *\/ \"frame_bound_s ::= UNBOUNDED PRECEDING\",\n- \/* 324 *\/ \"frame_bound_e ::= frame_bound\",\n- \/* 325 *\/ \"frame_bound_e ::= UNBOUNDED FOLLOWING\",\n- \/* 326 *\/ \"frame_bound ::= expr PRECEDING|FOLLOWING\",\n- \/* 327 *\/ \"frame_bound ::= CURRENT ROW\",\n- \/* 328 *\/ \"frame_exclude_opt ::=\",\n- \/* 329 *\/ \"frame_exclude_opt ::= EXCLUDE frame_exclude\",\n- \/* 330 *\/ \"frame_exclude ::= NO OTHERS\",\n- \/* 331 *\/ \"frame_exclude ::= CURRENT ROW\",\n- \/* 332 *\/ \"frame_exclude ::= GROUP|TIES\",\n- \/* 333 *\/ \"window_clause ::= WINDOW windowdefn_list\",\n- \/* 334 *\/ \"filter_over ::= filter_clause over_clause\",\n- \/* 335 *\/ \"filter_over ::= over_clause\",\n- \/* 336 *\/ \"filter_over ::= filter_clause\",\n- \/* 337 *\/ \"over_clause ::= OVER LP window RP\",\n- \/* 338 *\/ \"over_clause ::= OVER nm\",\n- \/* 339 *\/ \"filter_clause ::= FILTER LP WHERE expr RP\",\n- \/* 340 *\/ \"input ::= cmdlist\",\n- \/* 341 *\/ \"cmdlist ::= cmdlist ecmd\",\n- \/* 342 *\/ \"cmdlist ::= ecmd\",\n- \/* 343 *\/ \"ecmd ::= SEMI\",\n- \/* 344 *\/ \"ecmd ::= cmdx SEMI\",\n- \/* 345 *\/ \"ecmd ::= explain cmdx SEMI\",\n- \/* 346 *\/ \"trans_opt ::=\",\n- \/* 347 *\/ \"trans_opt ::= TRANSACTION\",\n- \/* 348 *\/ \"trans_opt ::= TRANSACTION nm\",\n- \/* 349 *\/ \"savepoint_opt ::= SAVEPOINT\",\n- \/* 350 *\/ \"savepoint_opt ::=\",\n- \/* 351 *\/ \"cmd ::= create_table create_table_args\",\n- \/* 352 *\/ \"table_option_set ::= table_option\",\n- \/* 353 *\/ \"columnlist ::= columnlist COMMA columnname carglist\",\n- \/* 354 *\/ \"columnlist ::= columnname carglist\",\n- \/* 355 *\/ \"nm ::= ID|INDEXED|JOIN_KW\",\n- \/* 356 *\/ \"nm ::= STRING\",\n- \/* 357 *\/ \"typetoken ::= typename\",\n- \/* 358 *\/ \"typename ::= ID|STRING\",\n- \/* 359 *\/ \"signed ::= plus_num\",\n- \/* 360 *\/ \"signed ::= minus_num\",\n- \/* 361 *\/ \"carglist ::= carglist ccons\",\n- \/* 362 *\/ \"carglist ::=\",\n- \/* 363 *\/ \"ccons ::= NULL onconf\",\n- \/* 364 *\/ \"ccons ::= GENERATED ALWAYS AS generated\",\n- \/* 365 *\/ \"ccons ::= AS generated\",\n- \/* 366 *\/ \"conslist_opt ::= COMMA conslist\",\n- \/* 367 *\/ \"conslist ::= conslist tconscomma tcons\",\n- \/* 368 *\/ \"conslist ::= tcons\",\n- \/* 369 *\/ \"tconscomma ::=\",\n- \/* 370 *\/ \"defer_subclause_opt ::= defer_subclause\",\n- \/* 371 *\/ \"resolvetype ::= raisetype\",\n- \/* 372 *\/ \"selectnowith ::= oneselect\",\n- \/* 373 *\/ \"oneselect ::= values\",\n- \/* 374 *\/ \"sclp ::= selcollist COMMA\",\n- \/* 375 *\/ \"as ::= ID|STRING\",\n- \/* 376 *\/ \"indexed_opt ::= indexed_by\",\n- \/* 377 *\/ \"returning ::=\",\n- \/* 378 *\/ \"expr ::= term\",\n- \/* 379 *\/ \"likeop ::= LIKE_KW|MATCH\",\n- \/* 380 *\/ \"case_operand ::= expr\",\n- \/* 381 *\/ \"exprlist ::= nexprlist\",\n- \/* 382 *\/ \"nmnum ::= plus_num\",\n- \/* 383 *\/ \"nmnum ::= nm\",\n- \/* 384 *\/ \"nmnum ::= ON\",\n- \/* 385 *\/ \"nmnum ::= DELETE\",\n- \/* 386 *\/ \"nmnum ::= DEFAULT\",\n- \/* 387 *\/ \"plus_num ::= INTEGER|FLOAT\",\n- \/* 388 *\/ \"foreach_clause ::=\",\n- \/* 389 *\/ \"foreach_clause ::= FOR EACH ROW\",\n- \/* 390 *\/ \"trnm ::= nm\",\n- \/* 391 *\/ \"tridxby ::=\",\n- \/* 392 *\/ \"database_kw_opt ::= DATABASE\",\n- \/* 393 *\/ \"database_kw_opt ::=\",\n- \/* 394 *\/ \"kwcolumn_opt ::=\",\n- \/* 395 *\/ \"kwcolumn_opt ::= COLUMNKW\",\n- \/* 396 *\/ \"vtabarglist ::= vtabarg\",\n- \/* 397 *\/ \"vtabarglist ::= vtabarglist COMMA vtabarg\",\n- \/* 398 *\/ \"vtabarg ::= vtabarg vtabargtoken\",\n- \/* 399 *\/ \"anylist ::=\",\n- \/* 400 *\/ \"anylist ::= anylist LP anylist RP\",\n- \/* 401 *\/ \"anylist ::= anylist ANY\",\n- \/* 402 *\/ \"with ::=\",\n- \/* 403 *\/ \"windowdefn_list ::= windowdefn\",\n- \/* 404 *\/ \"window ::= frame_opt\",\n+ \/*  95 *\/ \"oneselect ::= mvalues\",\n+ \/*  96 *\/ \"mvalues ::= values COMMA LP nexprlist RP\",\n+ \/*  97 *\/ \"mvalues ::= mvalues COMMA LP nexprlist RP\",\n+ \/*  98 *\/ \"distinct ::= DISTINCT\",\n+ \/*  99 *\/ \"distinct ::= ALL\",\n+ \/* 100 *\/ \"distinct ::=\",\n+ \/* 101 *\/ \"sclp ::=\",\n+ \/* 102 *\/ \"selcollist ::= sclp scanpt expr scanpt as\",\n+ \/* 103 *\/ \"selcollist ::= sclp scanpt STAR\",\n+ \/* 104 *\/ \"selcollist ::= sclp scanpt nm DOT STAR\",\n+ \/* 105 *\/ \"as ::= AS nm\",\n+ \/* 106 *\/ \"as ::=\",\n+ \/* 107 *\/ \"from ::=\",\n+ \/* 108 *\/ \"from ::= FROM seltablist\",\n+ \/* 109 *\/ \"stl_prefix ::= seltablist joinop\",\n+ \/* 110 *\/ \"stl_prefix ::=\",\n+ \/* 111 *\/ \"seltablist ::= stl_prefix nm dbnm as on_using\",\n+ \/* 112 *\/ \"seltablist ::= stl_prefix nm dbnm as indexed_by on_using\",\n+ \/* 113 *\/ \"seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_using\",\n+ \/* 114 *\/ \"seltablist ::= stl_prefix LP select RP as on_using\",\n+ \/* 115 *\/ \"seltablist ::= stl_prefix LP seltablist RP as on_using\",\n+ \/* 116 *\/ \"dbnm ::=\",\n+ \/* 117 *\/ \"dbnm ::= DOT nm\",\n+ \/* 118 *\/ \"fullname ::= nm\",\n+ \/* 119 *\/ \"fullname ::= nm DOT nm\",\n+ \/* 120 *\/ \"xfullname ::= nm\",\n+ \/* 121 *\/ \"xfullname ::= nm DOT nm\",\n+ \/* 122 *\/ \"xfullname ::= nm DOT nm AS nm\",\n+ \/* 123 *\/ \"xfullname ::= nm AS nm\",\n+ \/* 124 *\/ \"joinop ::= COMMA|JOIN\",\n+ \/* 125 *\/ \"joinop ::= JOIN_KW JOIN\",\n+ \/* 126 *\/ \"joinop ::= JOIN_KW nm JOIN\",\n+ \/* 127 *\/ \"joinop ::= JOIN_KW nm nm JOIN\",\n+ \/* 128 *\/ \"on_using ::= ON expr\",\n+ \/* 129 *\/ \"on_using ::= USING LP idlist RP\",\n+ \/* 130 *\/ \"on_using ::=\",\n+ \/* 131 *\/ \"indexed_opt ::=\",\n+ \/* 132 *\/ \"indexed_by ::= INDEXED BY nm\",\n+ \/* 133 *\/ \"indexed_by ::= NOT INDEXED\",\n+ \/* 134 *\/ \"orderby_opt ::=\",\n+ \/* 135 *\/ \"orderby_opt ::= ORDER BY sortlist\",\n+ \/* 136 *\/ \"sortlist ::= sortlist COMMA expr sortorder nulls\",\n+ \/* 137 *\/ \"sortlist ::= expr sortorder nulls\",\n+ \/* 138 *\/ \"sortorder ::= ASC\",\n+ \/* 139 *\/ \"sortorder ::= DESC\",\n+ \/* 140 *\/ \"sortorder ::=\",\n+ \/* 141 *\/ \"nulls ::= NULLS FIRST\",\n+ \/* 142 *\/ \"nulls ::= NULLS LAST\",\n+ \/* 143 *\/ \"nulls ::=\",\n+ \/* 144 *\/ \"groupby_opt ::=\",\n+ \/* 145 *\/ \"groupby_opt ::= GROUP BY nexprlist\",\n+ \/* 146 *\/ \"having_opt ::=\",\n+ \/* 147 *\/ \"having_opt ::= HAVING expr\",\n+ \/* 148 *\/ \"limit_opt ::=\",\n+ \/* 149 *\/ \"limit_opt ::= LIMIT expr\",\n+ \/* 150 *\/ \"limit_opt ::= LIMIT expr OFFSET expr\",\n+ \/* 151 *\/ \"limit_opt ::= LIMIT expr COMMA expr\",\n+ \/* 152 *\/ \"cmd ::= with DELETE FROM xfullname indexed_opt where_opt_ret\",\n+ \/* 153 *\/ \"where_opt ::=\",\n+ \/* 154 *\/ \"where_opt ::= WHERE expr\",\n+ \/* 155 *\/ \"where_opt_ret ::=\",\n+ \/* 156 *\/ \"where_opt_ret ::= WHERE expr\",\n+ \/* 157 *\/ \"where_opt_ret ::= RETURNING selcollist\",\n+ \/* 158 *\/ \"where_opt_ret ::= WHERE expr RETURNING selcollist\",\n+ \/* 159 *\/ \"cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist from where_opt_ret\",\n+ \/* 160 *\/ \"setlist ::= setlist COMMA nm EQ expr\",\n+ \/* 161 *\/ \"setlist ::= setlist COMMA LP idlist RP EQ expr\",\n+ \/* 162 *\/ \"setlist ::= nm EQ expr\",\n+ \/* 163 *\/ \"setlist ::= LP idlist RP EQ expr\",\n+ \/* 164 *\/ \"cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert\",\n+ \/* 165 *\/ \"cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES returning\",\n+ \/* 166 *\/ \"upsert ::=\",\n+ \/* 167 *\/ \"upsert ::= RETURNING selcollist\",\n+ \/* 168 *\/ \"upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt upsert\",\n+ \/* 169 *\/ \"upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING upsert\",\n+ \/* 170 *\/ \"upsert ::= ON CONFLICT DO NOTHING returning\",\n+ \/* 171 *\/ \"upsert ::= ON CONFLICT DO UPDATE SET setlist where_opt returning\",\n+ \/* 172 *\/ \"returning ::= RETURNING selcollist\",\n+ \/* 173 *\/ \"insert_cmd ::= INSERT orconf\",\n+ \/* 174 *\/ \"insert_cmd ::= REPLACE\",\n+ \/* 175 *\/ \"idlist_opt ::=\",\n+ \/* 176 *\/ \"idlist_opt ::= LP idlist RP\",\n+ \/* 177 *\/ \"idlist ::= idlist COMMA nm\",\n+ \/* 178 *\/ \"idlist ::= nm\",\n+ \/* 179 *\/ \"expr ::= LP expr RP\",\n+ \/* 180 *\/ \"expr ::= ID|INDEXED|JOIN_KW\",\n+ \/* 181 *\/ \"expr ::= nm DOT nm\",\n+ \/* 182 *\/ \"expr ::= nm DOT nm DOT nm\",\n+ \/* 183 *\/ \"term ::= NULL|FLOAT|BLOB\",\n+ \/* 184 *\/ \"term ::= STRING\",\n+ \/* 185 *\/ \"term ::= INTEGER\",\n+ \/* 186 *\/ \"expr ::= VARIABLE\",\n+ \/* 187 *\/ \"expr ::= expr COLLATE ID|STRING\",\n+ \/* 188 *\/ \"expr ::= CAST LP expr AS typetoken RP\",\n+ \/* 189 *\/ \"expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP\",\n+ \/* 190 *\/ \"expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP\",\n+ \/* 191 *\/ \"expr ::= ID|INDEXED|JOIN_KW LP STAR RP\",\n+ \/* 192 *\/ \"expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP filter_over\",\n+ \/* 193 *\/ \"expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP filter_over\",\n+ \/* 194 *\/ \"expr ::= ID|INDEXED|JOIN_KW LP STAR RP filter_over\",\n+ \/* 195 *\/ \"term ::= CTIME_KW\",\n+ \/* 196 *\/ \"expr ::= LP nexprlist COMMA expr RP\",\n+ \/* 197 *\/ \"expr ::= expr AND expr\",\n+ \/* 198 *\/ \"expr ::= expr OR expr\",\n+ \/* 199 *\/ \"expr ::= expr LT|GT|GE|LE expr\",\n+ \/* 200 *\/ \"expr ::= expr EQ|NE expr\",\n+ \/* 201 *\/ \"expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr\",\n+ \/* 202 *\/ \"expr ::= expr PLUS|MINUS expr\",\n+ \/* 203 *\/ \"expr ::= expr STAR|SLASH|REM expr\",\n+ \/* 204 *\/ \"expr ::= expr CONCAT expr\",\n+ \/* 205 *\/ \"likeop ::= NOT LIKE_KW|MATCH\",\n+ \/* 206 *\/ \"expr ::= expr likeop expr\",\n+ \/* 207 *\/ \"expr ::= expr likeop expr ESCAPE expr\",\n+ \/* 208 *\/ \"expr ::= expr ISNULL|NOTNULL\",\n+ \/* 209 *\/ \"expr ::= expr NOT NULL\",\n+ \/* 210 *\/ \"expr ::= expr IS expr\",\n+ \/* 211 *\/ \"expr ::= expr IS NOT expr\",\n+ \/* 212 *\/ \"expr ::= expr IS NOT DISTINCT FROM expr\",\n+ \/* 213 *\/ \"expr ::= expr IS DISTINCT FROM expr\",\n+ \/* 214 *\/ \"expr ::= NOT expr\",\n+ \/* 215 *\/ \"expr ::= BITNOT expr\",\n+ \/* 216 *\/ \"expr ::= PLUS|MINUS expr\",\n+ \/* 217 *\/ \"expr ::= expr PTR expr\",\n+ \/* 218 *\/ \"between_op ::= BETWEEN\",\n+ \/* 219 *\/ \"between_op ::= NOT BETWEEN\",\n+ \/* 220 *\/ \"expr ::= expr between_op expr AND expr\",\n+ \/* 221 *\/ \"in_op ::= IN\",\n+ \/* 222 *\/ \"in_op ::= NOT IN\",\n+ \/* 223 *\/ \"expr ::= expr in_op LP exprlist RP\",\n+ \/* 224 *\/ \"expr ::= LP select RP\",\n+ \/* 225 *\/ \"expr ::= expr in_op LP select RP\",\n+ \/* 226 *\/ \"expr ::= expr in_op nm dbnm paren_exprlist\",\n+ \/* 227 *\/ \"expr ::= EXISTS LP select RP\",\n+ \/* 228 *\/ \"expr ::= CASE case_operand case_exprlist case_else END\",\n+ \/* 229 *\/ \"case_exprlist ::= case_exprlist WHEN expr THEN expr\",\n+ \/* 230 *\/ \"case_exprlist ::= WHEN expr THEN expr\",\n+ \/* 231 *\/ \"case_else ::= ELSE expr\",\n+ \/* 232 *\/ \"case_else ::=\",\n+ \/* 233 *\/ \"case_operand ::=\",\n+ \/* 234 *\/ \"exprlist ::=\",\n+ \/* 235 *\/ \"nexprlist ::= nexprlist COMMA expr\",\n+ \/* 236 *\/ \"nexprlist ::= expr\",\n+ \/* 237 *\/ \"paren_exprlist ::=\",\n+ \/* 238 *\/ \"paren_exprlist ::= LP exprlist RP\",\n+ \/* 239 *\/ \"cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt\",\n+ \/* 240 *\/ \"uniqueflag ::= UNIQUE\",\n+ \/* 241 *\/ \"uniqueflag ::=\",\n+ \/* 242 *\/ \"eidlist_opt ::=\",\n+ \/* 243 *\/ \"eidlist_opt ::= LP eidlist RP\",\n+ \/* 244 *\/ \"eidlist ::= eidlist COMMA nm collate sortorder\",\n+ \/* 245 *\/ \"eidlist ::= nm collate sortorder\",\n+ \/* 246 *\/ \"collate ::=\",\n+ \/* 247 *\/ \"collate ::= COLLATE ID|STRING\",\n+ \/* 248 *\/ \"cmd ::= DROP INDEX ifexists fullname\",\n+ \/* 249 *\/ \"cmd ::= VACUUM vinto\",\n+ \/* 250 *\/ \"cmd ::= VACUUM nm vinto\",\n+ \/* 251 *\/ \"vinto ::= INTO expr\",\n+ \/* 252 *\/ \"vinto ::=\",\n+ \/* 253 *\/ \"cmd ::= PRAGMA nm dbnm\",\n+ \/* 254 *\/ \"cmd ::= PRAGMA nm dbnm EQ nmnum\",\n+ \/* 255 *\/ \"cmd ::= PRAGMA nm dbnm LP nmnum RP\",\n+ \/* 256 *\/ \"cmd ::= PRAGMA nm dbnm EQ minus_num\",\n+ \/* 257 *\/ \"cmd ::= PRAGMA nm dbnm LP minus_num RP\",\n+ \/* 258 *\/ \"plus_num ::= PLUS INTEGER|FLOAT\",\n+ \/* 259 *\/ \"minus_num ::= MINUS INTEGER|FLOAT\",\n+ \/* 260 *\/ \"cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END\",\n+ \/* 261 *\/ \"trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause\",\n+ \/* 262 *\/ \"trigger_time ::= BEFORE|AFTER\",\n+ \/* 263 *\/ \"trigger_time ::= INSTEAD OF\",\n+ \/* 264 *\/ \"trigger_time ::=\",\n+ \/* 265 *\/ \"trigger_event ::= DELETE|INSERT\",\n+ \/* 266 *\/ \"trigger_event ::= UPDATE\",\n+ \/* 267 *\/ \"trigger_event ::= UPDATE OF idlist\",\n+ \/* 268 *\/ \"when_clause ::=\",\n+ \/* 269 *\/ \"when_clause ::= WHEN expr\",\n+ \/* 270 *\/ \"trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI\",\n+ \/* 271 *\/ \"trigger_cmd_list ::= trigger_cmd SEMI\",\n+ \/* 272 *\/ \"trnm ::= nm DOT nm\",\n+ \/* 273 *\/ \"tridxby ::= INDEXED BY nm\",\n+ \/* 274 *\/ \"tridxby ::= NOT INDEXED\",\n+ \/* 275 *\/ \"trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist from where_opt scanpt\",\n+ \/* 276 *\/ \"trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt\",\n+ \/* 277 *\/ \"trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt\",\n+ \/* 278 *\/ \"trigger_cmd ::= scanpt select scanpt\",\n+ \/* 279 *\/ \"expr ::= RAISE LP IGNORE RP\",\n+ \/* 280 *\/ \"expr ::= RAISE LP raisetype COMMA expr RP\",\n+ \/* 281 *\/ \"raisetype ::= ROLLBACK\",\n+ \/* 282 *\/ \"raisetype ::= ABORT\",\n+ \/* 283 *\/ \"raisetype ::= FAIL\",\n+ \/* 284 *\/ \"cmd ::= DROP TRIGGER ifexists fullname\",\n+ \/* 285 *\/ \"cmd ::= ATTACH database_kw_opt expr AS expr key_opt\",\n+ \/* 286 *\/ \"cmd ::= DETACH database_kw_opt expr\",\n+ \/* 287 *\/ \"key_opt ::=\",\n+ \/* 288 *\/ \"key_opt ::= KEY expr\",\n+ \/* 289 *\/ \"cmd ::= REINDEX\",\n+ \/* 290 *\/ \"cmd ::= REINDEX nm dbnm\",\n+ \/* 291 *\/ \"cmd ::= ANALYZE\",\n+ \/* 292 *\/ \"cmd ::= ANALYZE nm dbnm\",\n+ \/* 293 *\/ \"cmd ::= ALTER TABLE fullname RENAME TO nm\",\n+ \/* 294 *\/ \"cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist\",\n+ \/* 295 *\/ \"cmd ::= ALTER TABLE fullname DROP kwcolumn_opt nm\",\n+ \/* 296 *\/ \"add_column_fullname ::= fullname\",\n+ \/* 297 *\/ \"cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm\",\n+ \/* 298 *\/ \"cmd ::= create_vtab\",\n+ \/* 299 *\/ \"cmd ::= create_vtab LP vtabarglist RP\",\n+ \/* 300 *\/ \"create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm\",\n+ \/* 301 *\/ \"vtabarg ::=\",\n+ \/* 302 *\/ \"vtabargtoken ::= ANY\",\n+ \/* 303 *\/ \"vtabargtoken ::= lp anylist RP\",\n+ \/* 304 *\/ \"lp ::= LP\",\n+ \/* 305 *\/ \"with ::= WITH wqlist\",\n+ \/* 306 *\/ \"with ::= WITH RECURSIVE wqlist\",\n+ \/* 307 *\/ \"wqas ::= AS\",\n+ \/* 308 *\/ \"wqas ::= AS MATERIALIZED\",\n+ \/* 309 *\/ \"wqas ::= AS NOT MATERIALIZED\",\n+ \/* 310 *\/ \"wqitem ::= withnm eidlist_opt wqas LP select RP\",\n+ \/* 311 *\/ \"withnm ::= nm\",\n+ \/* 312 *\/ \"wqlist ::= wqitem\",\n+ \/* 313 *\/ \"wqlist ::= wqlist COMMA wqitem\",\n+ \/* 314 *\/ \"windowdefn_list ::= windowdefn_list COMMA windowdefn\",\n+ \/* 315 *\/ \"windowdefn ::= nm AS LP window RP\",\n+ \/* 316 *\/ \"window ::= PARTITION BY nexprlist orderby_opt frame_opt\",\n+ \/* 317 *\/ \"window ::= nm PARTITION BY nexprlist orderby_opt frame_opt\",\n+ \/* 318 *\/ \"window ::= ORDER BY sortlist frame_opt\",\n+ \/* 319 *\/ \"window ::= nm ORDER BY sortlist frame_opt\",\n+ \/* 320 *\/ \"window ::= nm frame_opt\",\n+ \/* 321 *\/ \"frame_opt ::=\",\n+ \/* 322 *\/ \"frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt\",\n+ \/* 323 *\/ \"frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt\",\n+ \/* 324 *\/ \"range_or_rows ::= RANGE|ROWS|GROUPS\",\n+ \/* 325 *\/ \"frame_bound_s ::= frame_bound\",\n+ \/* 326 *\/ \"frame_bound_s ::= UNBOUNDED PRECEDING\",\n+ \/* 327 *\/ \"frame_bound_e ::= frame_bound\",\n+ \/* 328 *\/ \"frame_bound_e ::= UNBOUNDED FOLLOWING\",\n+ \/* 329 *\/ \"frame_bound ::= expr PRECEDING|FOLLOWING\",\n+ \/* 330 *\/ \"frame_bound ::= CURRENT ROW\",\n+ \/* 331 *\/ \"frame_exclude_opt ::=\",\n+ \/* 332 *\/ \"frame_exclude_opt ::= EXCLUDE frame_exclude\",\n+ \/* 333 *\/ \"frame_exclude ::= NO OTHERS\",\n+ \/* 334 *\/ \"frame_exclude ::= CURRENT ROW\",\n+ \/* 335 *\/ \"frame_exclude ::= GROUP|TIES\",\n+ \/* 336 *\/ \"window_clause ::= WINDOW windowdefn_list\",\n+ \/* 337 *\/ \"filter_over ::= filter_clause over_clause\",\n+ \/* 338 *\/ \"filter_over ::= over_clause\",\n+ \/* 339 *\/ \"filter_over ::= filter_clause\",\n+ \/* 340 *\/ \"over_clause ::= OVER LP window RP\",\n+ \/* 341 *\/ \"over_clause ::= OVER nm\",\n+ \/* 342 *\/ \"filter_clause ::= FILTER LP WHERE expr RP\",\n+ \/* 343 *\/ \"term ::= QNUMBER\",\n+ \/* 344 *\/ \"input ::= cmdlist\",\n+ \/* 345 *\/ \"cmdlist ::= cmdlist ecmd\",\n+ \/* 346 *\/ \"cmdlist ::= ecmd\",\n+ \/* 347 *\/ \"ecmd ::= SEMI\",\n+ \/* 348 *\/ \"ecmd ::= cmdx SEMI\",\n+ \/* 349 *\/ \"ecmd ::= explain cmdx SEMI\",\n+ \/* 350 *\/ \"trans_opt ::=\",\n+ \/* 351 *\/ \"trans_opt ::= TRANSACTION\",\n+ \/* 352 *\/ \"trans_opt ::= TRANSACTION nm\",\n+ \/* 353 *\/ \"savepoint_opt ::= SAVEPOINT\",\n+ \/* 354 *\/ \"savepoint_opt ::=\",\n+ \/* 355 *\/ \"cmd ::= create_table create_table_args\",\n+ \/* 356 *\/ \"table_option_set ::= table_option\",\n+ \/* 357 *\/ \"columnlist ::= columnlist COMMA columnname carglist\",\n+ \/* 358 *\/ \"columnlist ::= columnname carglist\",\n+ \/* 359 *\/ \"nm ::= ID|INDEXED|JOIN_KW\",\n+ \/* 360 *\/ \"nm ::= STRING\",\n+ \/* 361 *\/ \"typetoken ::= typename\",\n+ \/* 362 *\/ \"typename ::= ID|STRING\",\n+ \/* 363 *\/ \"signed ::= plus_num\",\n+ \/* 364 *\/ \"signed ::= minus_num\",\n+ \/* 365 *\/ \"carglist ::= carglist ccons\",\n+ \/* 366 *\/ \"carglist ::=\",\n+ \/* 367 *\/ \"ccons ::= NULL onconf\",\n+ \/* 368 *\/ \"ccons ::= GENERATED ALWAYS AS generated\",\n+ \/* 369 *\/ \"ccons ::= AS generated\",\n+ \/* 370 *\/ \"conslist_opt ::= COMMA conslist\",\n+ \/* 371 *\/ \"conslist ::= conslist tconscomma tcons\",\n+ \/* 372 *\/ \"conslist ::= tcons\",\n+ \/* 373 *\/ \"tconscomma ::=\",\n+ \/* 374 *\/ \"defer_subclause_opt ::= defer_subclause\",\n+ \/* 375 *\/ \"resolvetype ::= raisetype\",\n+ \/* 376 *\/ \"selectnowith ::= oneselect\",\n+ \/* 377 *\/ \"oneselect ::= values\",\n+ \/* 378 *\/ \"sclp ::= selcollist COMMA\",\n+ \/* 379 *\/ \"as ::= ID|STRING\",\n+ \/* 380 *\/ \"indexed_opt ::= indexed_by\",\n+ \/* 381 *\/ \"returning ::=\",\n+ \/* 382 *\/ \"expr ::= term\",\n+ \/* 383 *\/ \"likeop ::= LIKE_KW|MATCH\",\n+ \/* 384 *\/ \"case_operand ::= expr\",\n+ \/* 385 *\/ \"exprlist ::= nexprlist\",\n+ \/* 386 *\/ \"nmnum ::= plus_num\",\n+ \/* 387 *\/ \"nmnum ::= nm\",\n+ \/* 388 *\/ \"nmnum ::= ON\",\n+ \/* 389 *\/ \"nmnum ::= DELETE\",\n+ \/* 390 *\/ \"nmnum ::= DEFAULT\",\n+ \/* 391 *\/ \"plus_num ::= INTEGER|FLOAT\",\n+ \/* 392 *\/ \"foreach_clause ::=\",\n+ \/* 393 *\/ \"foreach_clause ::= FOR EACH ROW\",\n+ \/* 394 *\/ \"trnm ::= nm\",\n+ \/* 395 *\/ \"tridxby ::=\",\n+ \/* 396 *\/ \"database_kw_opt ::= DATABASE\",\n+ \/* 397 *\/ \"database_kw_opt ::=\",\n+ \/* 398 *\/ \"kwcolumn_opt ::=\",\n+ \/* 399 *\/ \"kwcolumn_opt ::= COLUMNKW\",\n+ \/* 400 *\/ \"vtabarglist ::= vtabarg\",\n+ \/* 401 *\/ \"vtabarglist ::= vtabarglist COMMA vtabarg\",\n+ \/* 402 *\/ \"vtabarg ::= vtabarg vtabargtoken\",\n+ \/* 403 *\/ \"anylist ::=\",\n+ \/* 404 *\/ \"anylist ::= anylist LP anylist RP\",\n+ \/* 405 *\/ \"anylist ::= anylist ANY\",\n+ \/* 406 *\/ \"with ::=\",\n+ \/* 407 *\/ \"windowdefn_list ::= windowdefn\",\n+ \/* 408 *\/ \"window ::= frame_opt\",\n@@ -173359,1 +176497,1 @@\n-#if YYSTACKDEPTH<=0\n+#if YYGROWABLESTACK\n@@ -173365,0 +176503,1 @@\n+  int oldSize = 1 + (int)(p->yystackEnd - p->yystack);\n@@ -173369,5 +176508,6 @@\n-  newSize = p->yystksz*2 + 100;\n-  idx = p->yytos ? (int)(p->yytos - p->yystack) : 0;\n-  if( p->yystack==&p->yystk0 ){\n-    pNew = malloc(newSize*sizeof(pNew[0]));\n-    if( pNew ) pNew[0] = p->yystk0;\n+  newSize = oldSize*2 + 100;\n+  idx = (int)(p->yytos - p->yystack);\n+  if( p->yystack==p->yystk0 ){\n+    pNew = YYREALLOC(0, newSize*sizeof(pNew[0]));\n+    if( pNew==0 ) return 1;\n+    memcpy(pNew, p->yystack, oldSize*sizeof(pNew[0]));\n@@ -173375,1 +176515,2 @@\n-    pNew = realloc(p->yystack, newSize*sizeof(pNew[0]));\n+    pNew = YYREALLOC(p->yystack, newSize*sizeof(pNew[0]));\n+    if( pNew==0 ) return 1;\n@@ -173377,3 +176518,2 @@\n-  if( pNew ){\n-    p->yystack = pNew;\n-    p->yytos = &p->yystack[idx];\n+  p->yystack = pNew;\n+  p->yytos = &p->yystack[idx];\n@@ -173381,6 +176521,3 @@\n-    if( yyTraceFILE ){\n-      fprintf(yyTraceFILE,\"%sStack grows from %d to %d entries.\\n\",\n-              yyTracePrompt, p->yystksz, newSize);\n-    }\n-#endif\n-    p->yystksz = newSize;\n+  if( yyTraceFILE ){\n+    fprintf(yyTraceFILE,\"%sStack grows from %d to %d entries.\\n\",\n+            yyTracePrompt, oldSize, newSize);\n@@ -173388,1 +176525,3 @@\n-  return pNew==0;\n+#endif\n+  p->yystackEnd = &p->yystack[newSize-1];\n+  return 0;\n@@ -173390,0 +176529,7 @@\n+#endif \/* YYGROWABLESTACK *\/\n+\n+#if !YYGROWABLESTACK\n+\/* For builds that do no have a growable stack, yyGrowStack always\n+** returns an error.\n+*\/\n+# define yyGrowStack(X) 1\n@@ -173409,9 +176555,2 @@\n-#if YYSTACKDEPTH<=0\n-  yypParser->yytos = NULL;\n-  yypParser->yystack = NULL;\n-  yypParser->yystksz = 0;\n-  if( yyGrowStack(yypParser) ){\n-    yypParser->yystack = &yypParser->yystk0;\n-    yypParser->yystksz = 1;\n-  }\n-#endif\n+  yypParser->yystack = yypParser->yystk0;\n+  yypParser->yystackEnd = &yypParser->yystack[YYSTACKDEPTH-1];\n@@ -173424,3 +176563,0 @@\n-#if YYSTACKDEPTH>0\n-  yypParser->yystackEnd = &yypParser->yystack[YYSTACKDEPTH-1];\n-#endif\n@@ -173480,4 +176616,5 @@\n-    case 204: \/* select *\/\n-    case 239: \/* selectnowith *\/\n-    case 240: \/* oneselect *\/\n-    case 252: \/* values *\/\n+    case 206: \/* select *\/\n+    case 241: \/* selectnowith *\/\n+    case 242: \/* oneselect *\/\n+    case 254: \/* values *\/\n+    case 256: \/* mvalues *\/\n@@ -173485,14 +176622,14 @@\n-sqlite3SelectDelete(pParse->db, (yypminor->yy47));\n-}\n-      break;\n-    case 216: \/* term *\/\n-    case 217: \/* expr *\/\n-    case 246: \/* where_opt *\/\n-    case 248: \/* having_opt *\/\n-    case 267: \/* where_opt_ret *\/\n-    case 278: \/* case_operand *\/\n-    case 280: \/* case_else *\/\n-    case 283: \/* vinto *\/\n-    case 290: \/* when_clause *\/\n-    case 295: \/* key_opt *\/\n-    case 311: \/* filter_clause *\/\n+sqlite3SelectDelete(pParse->db, (yypminor->yy637));\n+}\n+      break;\n+    case 218: \/* term *\/\n+    case 219: \/* expr *\/\n+    case 248: \/* where_opt *\/\n+    case 250: \/* having_opt *\/\n+    case 270: \/* where_opt_ret *\/\n+    case 281: \/* case_operand *\/\n+    case 283: \/* case_else *\/\n+    case 286: \/* vinto *\/\n+    case 293: \/* when_clause *\/\n+    case 298: \/* key_opt *\/\n+    case 315: \/* filter_clause *\/\n@@ -173500,16 +176637,16 @@\n-sqlite3ExprDelete(pParse->db, (yypminor->yy528));\n-}\n-      break;\n-    case 221: \/* eidlist_opt *\/\n-    case 231: \/* sortlist *\/\n-    case 232: \/* eidlist *\/\n-    case 244: \/* selcollist *\/\n-    case 247: \/* groupby_opt *\/\n-    case 249: \/* orderby_opt *\/\n-    case 253: \/* nexprlist *\/\n-    case 254: \/* sclp *\/\n-    case 261: \/* exprlist *\/\n-    case 268: \/* setlist *\/\n-    case 277: \/* paren_exprlist *\/\n-    case 279: \/* case_exprlist *\/\n-    case 310: \/* part_opt *\/\n+sqlite3ExprDelete(pParse->db, (yypminor->yy590));\n+}\n+      break;\n+    case 223: \/* eidlist_opt *\/\n+    case 233: \/* sortlist *\/\n+    case 234: \/* eidlist *\/\n+    case 246: \/* selcollist *\/\n+    case 249: \/* groupby_opt *\/\n+    case 251: \/* orderby_opt *\/\n+    case 255: \/* nexprlist *\/\n+    case 257: \/* sclp *\/\n+    case 264: \/* exprlist *\/\n+    case 271: \/* setlist *\/\n+    case 280: \/* paren_exprlist *\/\n+    case 282: \/* case_exprlist *\/\n+    case 314: \/* part_opt *\/\n@@ -173517,1 +176654,1 @@\n-sqlite3ExprListDelete(pParse->db, (yypminor->yy322));\n+sqlite3ExprListDelete(pParse->db, (yypminor->yy402));\n@@ -173520,5 +176657,5 @@\n-    case 238: \/* fullname *\/\n-    case 245: \/* from *\/\n-    case 256: \/* seltablist *\/\n-    case 257: \/* stl_prefix *\/\n-    case 262: \/* xfullname *\/\n+    case 240: \/* fullname *\/\n+    case 247: \/* from *\/\n+    case 259: \/* seltablist *\/\n+    case 260: \/* stl_prefix *\/\n+    case 265: \/* xfullname *\/\n@@ -173526,1 +176663,1 @@\n-sqlite3SrcListDelete(pParse->db, (yypminor->yy131));\n+sqlite3SrcListDelete(pParse->db, (yypminor->yy563));\n@@ -173529,1 +176666,1 @@\n-    case 241: \/* wqlist *\/\n+    case 243: \/* wqlist *\/\n@@ -173531,1 +176668,1 @@\n-sqlite3WithDelete(pParse->db, (yypminor->yy521));\n+sqlite3WithDelete(pParse->db, (yypminor->yy125));\n@@ -173534,2 +176671,2 @@\n-    case 251: \/* window_clause *\/\n-    case 306: \/* windowdefn_list *\/\n+    case 253: \/* window_clause *\/\n+    case 310: \/* windowdefn_list *\/\n@@ -173537,1 +176674,1 @@\n-sqlite3WindowListDelete(pParse->db, (yypminor->yy41));\n+sqlite3WindowListDelete(pParse->db, (yypminor->yy483));\n@@ -173540,2 +176677,2 @@\n-    case 263: \/* idlist *\/\n-    case 270: \/* idlist_opt *\/\n+    case 266: \/* idlist *\/\n+    case 273: \/* idlist_opt *\/\n@@ -173543,1 +176680,1 @@\n-sqlite3IdListDelete(pParse->db, (yypminor->yy254));\n+sqlite3IdListDelete(pParse->db, (yypminor->yy204));\n@@ -173546,5 +176683,5 @@\n-    case 273: \/* filter_over *\/\n-    case 307: \/* windowdefn *\/\n-    case 308: \/* window *\/\n-    case 309: \/* frame_opt *\/\n-    case 312: \/* over_clause *\/\n+    case 276: \/* filter_over *\/\n+    case 311: \/* windowdefn *\/\n+    case 312: \/* window *\/\n+    case 313: \/* frame_opt *\/\n+    case 316: \/* over_clause *\/\n@@ -173552,1 +176689,1 @@\n-sqlite3WindowDelete(pParse->db, (yypminor->yy41));\n+sqlite3WindowDelete(pParse->db, (yypminor->yy483));\n@@ -173555,2 +176692,2 @@\n-    case 286: \/* trigger_cmd_list *\/\n-    case 291: \/* trigger_cmd *\/\n+    case 289: \/* trigger_cmd_list *\/\n+    case 294: \/* trigger_cmd *\/\n@@ -173558,1 +176695,1 @@\n-sqlite3DeleteTriggerStep(pParse->db, (yypminor->yy33));\n+sqlite3DeleteTriggerStep(pParse->db, (yypminor->yy319));\n@@ -173561,1 +176698,1 @@\n-    case 288: \/* trigger_event *\/\n+    case 291: \/* trigger_event *\/\n@@ -173563,1 +176700,1 @@\n-sqlite3IdListDelete(pParse->db, (yypminor->yy180).b);\n+sqlite3IdListDelete(pParse->db, (yypminor->yy28).b);\n@@ -173566,3 +176703,3 @@\n-    case 314: \/* frame_bound *\/\n-    case 315: \/* frame_bound_s *\/\n-    case 316: \/* frame_bound_e *\/\n+    case 318: \/* frame_bound *\/\n+    case 319: \/* frame_bound_s *\/\n+    case 320: \/* frame_bound_e *\/\n@@ -173570,1 +176707,1 @@\n-sqlite3ExprDelete(pParse->db, (yypminor->yy595).pExpr);\n+sqlite3ExprDelete(pParse->db, (yypminor->yy205).pExpr);\n@@ -173604,3 +176741,20 @@\n-  while( pParser->yytos>pParser->yystack ) yy_pop_parser_stack(pParser);\n-#if YYSTACKDEPTH<=0\n-  if( pParser->yystack!=&pParser->yystk0 ) free(pParser->yystack);\n+\n+  \/* In-lined version of calling yy_pop_parser_stack() for each\n+  ** element left in the stack *\/\n+  yyStackEntry *yytos = pParser->yytos;\n+  while( yytos>pParser->yystack ){\n+#ifndef NDEBUG\n+    if( yyTraceFILE ){\n+      fprintf(yyTraceFILE,\"%sPopping %s\\n\",\n+        yyTracePrompt,\n+        yyTokenName[yytos->major]);\n+    }\n+#endif\n+    if( yytos->major>=YY_MIN_DSTRCTR ){\n+      yy_destructor(pParser, yytos->major, &yytos->minor);\n+    }\n+    yytos--;\n+  }\n+\n+#if YYGROWABLESTACK\n+  if( pParser->yystack!=pParser->yystk0 ) YYFREE(pParser->yystack);\n@@ -173789,1 +176943,1 @@\n-  sqlite3ErrorMsg(pParse, \"parser stack overflow\");\n+  sqlite3OomFault(pParse->db);\n@@ -173833,8 +176987,2 @@\n-#if YYSTACKDEPTH>0\n-  if( yypParser->yytos>yypParser->yystackEnd ){\n-    yypParser->yytos--;\n-    yyStackOverflow(yypParser);\n-    return;\n-  }\n-#else\n-  if( yypParser->yytos>=&yypParser->yystack[yypParser->yystksz] ){\n+  yytos = yypParser->yytos;\n+  if( yytos>yypParser->yystackEnd ){\n@@ -173846,0 +176994,2 @@\n+    yytos = yypParser->yytos;\n+    assert( yytos <= yypParser->yystackEnd );\n@@ -173847,1 +176997,0 @@\n-#endif\n@@ -173851,1 +177000,0 @@\n-  yytos = yypParser->yytos;\n@@ -173861,405 +177009,409 @@\n-   189,  \/* (0) explain ::= EXPLAIN *\/\n-   189,  \/* (1) explain ::= EXPLAIN QUERY PLAN *\/\n-   188,  \/* (2) cmdx ::= cmd *\/\n-   190,  \/* (3) cmd ::= BEGIN transtype trans_opt *\/\n-   191,  \/* (4) transtype ::= *\/\n-   191,  \/* (5) transtype ::= DEFERRED *\/\n-   191,  \/* (6) transtype ::= IMMEDIATE *\/\n-   191,  \/* (7) transtype ::= EXCLUSIVE *\/\n-   190,  \/* (8) cmd ::= COMMIT|END trans_opt *\/\n-   190,  \/* (9) cmd ::= ROLLBACK trans_opt *\/\n-   190,  \/* (10) cmd ::= SAVEPOINT nm *\/\n-   190,  \/* (11) cmd ::= RELEASE savepoint_opt nm *\/\n-   190,  \/* (12) cmd ::= ROLLBACK trans_opt TO savepoint_opt nm *\/\n-   195,  \/* (13) create_table ::= createkw temp TABLE ifnotexists nm dbnm *\/\n-   197,  \/* (14) createkw ::= CREATE *\/\n-   199,  \/* (15) ifnotexists ::= *\/\n-   199,  \/* (16) ifnotexists ::= IF NOT EXISTS *\/\n-   198,  \/* (17) temp ::= TEMP *\/\n-   198,  \/* (18) temp ::= *\/\n-   196,  \/* (19) create_table_args ::= LP columnlist conslist_opt RP table_option_set *\/\n-   196,  \/* (20) create_table_args ::= AS select *\/\n-   203,  \/* (21) table_option_set ::= *\/\n-   203,  \/* (22) table_option_set ::= table_option_set COMMA table_option *\/\n-   205,  \/* (23) table_option ::= WITHOUT nm *\/\n-   205,  \/* (24) table_option ::= nm *\/\n-   206,  \/* (25) columnname ::= nm typetoken *\/\n-   208,  \/* (26) typetoken ::= *\/\n-   208,  \/* (27) typetoken ::= typename LP signed RP *\/\n-   208,  \/* (28) typetoken ::= typename LP signed COMMA signed RP *\/\n-   209,  \/* (29) typename ::= typename ID|STRING *\/\n-   213,  \/* (30) scanpt ::= *\/\n-   214,  \/* (31) scantok ::= *\/\n-   215,  \/* (32) ccons ::= CONSTRAINT nm *\/\n-   215,  \/* (33) ccons ::= DEFAULT scantok term *\/\n-   215,  \/* (34) ccons ::= DEFAULT LP expr RP *\/\n-   215,  \/* (35) ccons ::= DEFAULT PLUS scantok term *\/\n-   215,  \/* (36) ccons ::= DEFAULT MINUS scantok term *\/\n-   215,  \/* (37) ccons ::= DEFAULT scantok ID|INDEXED *\/\n-   215,  \/* (38) ccons ::= NOT NULL onconf *\/\n-   215,  \/* (39) ccons ::= PRIMARY KEY sortorder onconf autoinc *\/\n-   215,  \/* (40) ccons ::= UNIQUE onconf *\/\n-   215,  \/* (41) ccons ::= CHECK LP expr RP *\/\n-   215,  \/* (42) ccons ::= REFERENCES nm eidlist_opt refargs *\/\n-   215,  \/* (43) ccons ::= defer_subclause *\/\n-   215,  \/* (44) ccons ::= COLLATE ID|STRING *\/\n-   224,  \/* (45) generated ::= LP expr RP *\/\n-   224,  \/* (46) generated ::= LP expr RP ID *\/\n-   220,  \/* (47) autoinc ::= *\/\n-   220,  \/* (48) autoinc ::= AUTOINCR *\/\n-   222,  \/* (49) refargs ::= *\/\n-   222,  \/* (50) refargs ::= refargs refarg *\/\n-   225,  \/* (51) refarg ::= MATCH nm *\/\n-   225,  \/* (52) refarg ::= ON INSERT refact *\/\n-   225,  \/* (53) refarg ::= ON DELETE refact *\/\n-   225,  \/* (54) refarg ::= ON UPDATE refact *\/\n-   226,  \/* (55) refact ::= SET NULL *\/\n-   226,  \/* (56) refact ::= SET DEFAULT *\/\n-   226,  \/* (57) refact ::= CASCADE *\/\n-   226,  \/* (58) refact ::= RESTRICT *\/\n-   226,  \/* (59) refact ::= NO ACTION *\/\n-   223,  \/* (60) defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt *\/\n-   223,  \/* (61) defer_subclause ::= DEFERRABLE init_deferred_pred_opt *\/\n-   227,  \/* (62) init_deferred_pred_opt ::= *\/\n-   227,  \/* (63) init_deferred_pred_opt ::= INITIALLY DEFERRED *\/\n-   227,  \/* (64) init_deferred_pred_opt ::= INITIALLY IMMEDIATE *\/\n-   202,  \/* (65) conslist_opt ::= *\/\n-   229,  \/* (66) tconscomma ::= COMMA *\/\n-   230,  \/* (67) tcons ::= CONSTRAINT nm *\/\n-   230,  \/* (68) tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf *\/\n-   230,  \/* (69) tcons ::= UNIQUE LP sortlist RP onconf *\/\n-   230,  \/* (70) tcons ::= CHECK LP expr RP onconf *\/\n-   230,  \/* (71) tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt *\/\n-   233,  \/* (72) defer_subclause_opt ::= *\/\n-   218,  \/* (73) onconf ::= *\/\n-   218,  \/* (74) onconf ::= ON CONFLICT resolvetype *\/\n-   234,  \/* (75) orconf ::= *\/\n-   234,  \/* (76) orconf ::= OR resolvetype *\/\n-   235,  \/* (77) resolvetype ::= IGNORE *\/\n-   235,  \/* (78) resolvetype ::= REPLACE *\/\n-   190,  \/* (79) cmd ::= DROP TABLE ifexists fullname *\/\n-   237,  \/* (80) ifexists ::= IF EXISTS *\/\n-   237,  \/* (81) ifexists ::= *\/\n-   190,  \/* (82) cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select *\/\n-   190,  \/* (83) cmd ::= DROP VIEW ifexists fullname *\/\n-   190,  \/* (84) cmd ::= select *\/\n-   204,  \/* (85) select ::= WITH wqlist selectnowith *\/\n-   204,  \/* (86) select ::= WITH RECURSIVE wqlist selectnowith *\/\n-   204,  \/* (87) select ::= selectnowith *\/\n-   239,  \/* (88) selectnowith ::= selectnowith multiselect_op oneselect *\/\n-   242,  \/* (89) multiselect_op ::= UNION *\/\n-   242,  \/* (90) multiselect_op ::= UNION ALL *\/\n-   242,  \/* (91) multiselect_op ::= EXCEPT|INTERSECT *\/\n-   240,  \/* (92) oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt *\/\n-   240,  \/* (93) oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt *\/\n-   252,  \/* (94) values ::= VALUES LP nexprlist RP *\/\n-   252,  \/* (95) values ::= values COMMA LP nexprlist RP *\/\n-   243,  \/* (96) distinct ::= DISTINCT *\/\n-   243,  \/* (97) distinct ::= ALL *\/\n-   243,  \/* (98) distinct ::= *\/\n-   254,  \/* (99) sclp ::= *\/\n-   244,  \/* (100) selcollist ::= sclp scanpt expr scanpt as *\/\n-   244,  \/* (101) selcollist ::= sclp scanpt STAR *\/\n-   244,  \/* (102) selcollist ::= sclp scanpt nm DOT STAR *\/\n-   255,  \/* (103) as ::= AS nm *\/\n-   255,  \/* (104) as ::= *\/\n-   245,  \/* (105) from ::= *\/\n-   245,  \/* (106) from ::= FROM seltablist *\/\n-   257,  \/* (107) stl_prefix ::= seltablist joinop *\/\n-   257,  \/* (108) stl_prefix ::= *\/\n-   256,  \/* (109) seltablist ::= stl_prefix nm dbnm as on_using *\/\n-   256,  \/* (110) seltablist ::= stl_prefix nm dbnm as indexed_by on_using *\/\n-   256,  \/* (111) seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_using *\/\n-   256,  \/* (112) seltablist ::= stl_prefix LP select RP as on_using *\/\n-   256,  \/* (113) seltablist ::= stl_prefix LP seltablist RP as on_using *\/\n-   200,  \/* (114) dbnm ::= *\/\n-   200,  \/* (115) dbnm ::= DOT nm *\/\n-   238,  \/* (116) fullname ::= nm *\/\n-   238,  \/* (117) fullname ::= nm DOT nm *\/\n-   262,  \/* (118) xfullname ::= nm *\/\n-   262,  \/* (119) xfullname ::= nm DOT nm *\/\n-   262,  \/* (120) xfullname ::= nm DOT nm AS nm *\/\n-   262,  \/* (121) xfullname ::= nm AS nm *\/\n-   258,  \/* (122) joinop ::= COMMA|JOIN *\/\n-   258,  \/* (123) joinop ::= JOIN_KW JOIN *\/\n-   258,  \/* (124) joinop ::= JOIN_KW nm JOIN *\/\n-   258,  \/* (125) joinop ::= JOIN_KW nm nm JOIN *\/\n-   259,  \/* (126) on_using ::= ON expr *\/\n-   259,  \/* (127) on_using ::= USING LP idlist RP *\/\n-   259,  \/* (128) on_using ::= *\/\n-   264,  \/* (129) indexed_opt ::= *\/\n-   260,  \/* (130) indexed_by ::= INDEXED BY nm *\/\n-   260,  \/* (131) indexed_by ::= NOT INDEXED *\/\n-   249,  \/* (132) orderby_opt ::= *\/\n-   249,  \/* (133) orderby_opt ::= ORDER BY sortlist *\/\n-   231,  \/* (134) sortlist ::= sortlist COMMA expr sortorder nulls *\/\n-   231,  \/* (135) sortlist ::= expr sortorder nulls *\/\n-   219,  \/* (136) sortorder ::= ASC *\/\n-   219,  \/* (137) sortorder ::= DESC *\/\n-   219,  \/* (138) sortorder ::= *\/\n-   265,  \/* (139) nulls ::= NULLS FIRST *\/\n-   265,  \/* (140) nulls ::= NULLS LAST *\/\n-   265,  \/* (141) nulls ::= *\/\n-   247,  \/* (142) groupby_opt ::= *\/\n-   247,  \/* (143) groupby_opt ::= GROUP BY nexprlist *\/\n-   248,  \/* (144) having_opt ::= *\/\n-   248,  \/* (145) having_opt ::= HAVING expr *\/\n-   250,  \/* (146) limit_opt ::= *\/\n-   250,  \/* (147) limit_opt ::= LIMIT expr *\/\n-   250,  \/* (148) limit_opt ::= LIMIT expr OFFSET expr *\/\n-   250,  \/* (149) limit_opt ::= LIMIT expr COMMA expr *\/\n-   190,  \/* (150) cmd ::= with DELETE FROM xfullname indexed_opt where_opt_ret *\/\n-   246,  \/* (151) where_opt ::= *\/\n-   246,  \/* (152) where_opt ::= WHERE expr *\/\n-   267,  \/* (153) where_opt_ret ::= *\/\n-   267,  \/* (154) where_opt_ret ::= WHERE expr *\/\n-   267,  \/* (155) where_opt_ret ::= RETURNING selcollist *\/\n-   267,  \/* (156) where_opt_ret ::= WHERE expr RETURNING selcollist *\/\n-   190,  \/* (157) cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist from where_opt_ret *\/\n-   268,  \/* (158) setlist ::= setlist COMMA nm EQ expr *\/\n-   268,  \/* (159) setlist ::= setlist COMMA LP idlist RP EQ expr *\/\n-   268,  \/* (160) setlist ::= nm EQ expr *\/\n-   268,  \/* (161) setlist ::= LP idlist RP EQ expr *\/\n-   190,  \/* (162) cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert *\/\n-   190,  \/* (163) cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES returning *\/\n-   271,  \/* (164) upsert ::= *\/\n-   271,  \/* (165) upsert ::= RETURNING selcollist *\/\n-   271,  \/* (166) upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt upsert *\/\n-   271,  \/* (167) upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING upsert *\/\n-   271,  \/* (168) upsert ::= ON CONFLICT DO NOTHING returning *\/\n-   271,  \/* (169) upsert ::= ON CONFLICT DO UPDATE SET setlist where_opt returning *\/\n-   272,  \/* (170) returning ::= RETURNING selcollist *\/\n-   269,  \/* (171) insert_cmd ::= INSERT orconf *\/\n-   269,  \/* (172) insert_cmd ::= REPLACE *\/\n-   270,  \/* (173) idlist_opt ::= *\/\n-   270,  \/* (174) idlist_opt ::= LP idlist RP *\/\n-   263,  \/* (175) idlist ::= idlist COMMA nm *\/\n-   263,  \/* (176) idlist ::= nm *\/\n-   217,  \/* (177) expr ::= LP expr RP *\/\n-   217,  \/* (178) expr ::= ID|INDEXED|JOIN_KW *\/\n-   217,  \/* (179) expr ::= nm DOT nm *\/\n-   217,  \/* (180) expr ::= nm DOT nm DOT nm *\/\n-   216,  \/* (181) term ::= NULL|FLOAT|BLOB *\/\n-   216,  \/* (182) term ::= STRING *\/\n-   216,  \/* (183) term ::= INTEGER *\/\n-   217,  \/* (184) expr ::= VARIABLE *\/\n-   217,  \/* (185) expr ::= expr COLLATE ID|STRING *\/\n-   217,  \/* (186) expr ::= CAST LP expr AS typetoken RP *\/\n-   217,  \/* (187) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP *\/\n-   217,  \/* (188) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP *\/\n-   217,  \/* (189) expr ::= ID|INDEXED|JOIN_KW LP STAR RP *\/\n-   217,  \/* (190) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP filter_over *\/\n-   217,  \/* (191) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP filter_over *\/\n-   217,  \/* (192) expr ::= ID|INDEXED|JOIN_KW LP STAR RP filter_over *\/\n-   216,  \/* (193) term ::= CTIME_KW *\/\n-   217,  \/* (194) expr ::= LP nexprlist COMMA expr RP *\/\n-   217,  \/* (195) expr ::= expr AND expr *\/\n-   217,  \/* (196) expr ::= expr OR expr *\/\n-   217,  \/* (197) expr ::= expr LT|GT|GE|LE expr *\/\n-   217,  \/* (198) expr ::= expr EQ|NE expr *\/\n-   217,  \/* (199) expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr *\/\n-   217,  \/* (200) expr ::= expr PLUS|MINUS expr *\/\n-   217,  \/* (201) expr ::= expr STAR|SLASH|REM expr *\/\n-   217,  \/* (202) expr ::= expr CONCAT expr *\/\n-   274,  \/* (203) likeop ::= NOT LIKE_KW|MATCH *\/\n-   217,  \/* (204) expr ::= expr likeop expr *\/\n-   217,  \/* (205) expr ::= expr likeop expr ESCAPE expr *\/\n-   217,  \/* (206) expr ::= expr ISNULL|NOTNULL *\/\n-   217,  \/* (207) expr ::= expr NOT NULL *\/\n-   217,  \/* (208) expr ::= expr IS expr *\/\n-   217,  \/* (209) expr ::= expr IS NOT expr *\/\n-   217,  \/* (210) expr ::= expr IS NOT DISTINCT FROM expr *\/\n-   217,  \/* (211) expr ::= expr IS DISTINCT FROM expr *\/\n-   217,  \/* (212) expr ::= NOT expr *\/\n-   217,  \/* (213) expr ::= BITNOT expr *\/\n-   217,  \/* (214) expr ::= PLUS|MINUS expr *\/\n-   217,  \/* (215) expr ::= expr PTR expr *\/\n-   275,  \/* (216) between_op ::= BETWEEN *\/\n-   275,  \/* (217) between_op ::= NOT BETWEEN *\/\n-   217,  \/* (218) expr ::= expr between_op expr AND expr *\/\n-   276,  \/* (219) in_op ::= IN *\/\n-   276,  \/* (220) in_op ::= NOT IN *\/\n-   217,  \/* (221) expr ::= expr in_op LP exprlist RP *\/\n-   217,  \/* (222) expr ::= LP select RP *\/\n-   217,  \/* (223) expr ::= expr in_op LP select RP *\/\n-   217,  \/* (224) expr ::= expr in_op nm dbnm paren_exprlist *\/\n-   217,  \/* (225) expr ::= EXISTS LP select RP *\/\n-   217,  \/* (226) expr ::= CASE case_operand case_exprlist case_else END *\/\n-   279,  \/* (227) case_exprlist ::= case_exprlist WHEN expr THEN expr *\/\n-   279,  \/* (228) case_exprlist ::= WHEN expr THEN expr *\/\n-   280,  \/* (229) case_else ::= ELSE expr *\/\n-   280,  \/* (230) case_else ::= *\/\n-   278,  \/* (231) case_operand ::= *\/\n-   261,  \/* (232) exprlist ::= *\/\n-   253,  \/* (233) nexprlist ::= nexprlist COMMA expr *\/\n-   253,  \/* (234) nexprlist ::= expr *\/\n-   277,  \/* (235) paren_exprlist ::= *\/\n-   277,  \/* (236) paren_exprlist ::= LP exprlist RP *\/\n-   190,  \/* (237) cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt *\/\n-   281,  \/* (238) uniqueflag ::= UNIQUE *\/\n-   281,  \/* (239) uniqueflag ::= *\/\n-   221,  \/* (240) eidlist_opt ::= *\/\n-   221,  \/* (241) eidlist_opt ::= LP eidlist RP *\/\n-   232,  \/* (242) eidlist ::= eidlist COMMA nm collate sortorder *\/\n-   232,  \/* (243) eidlist ::= nm collate sortorder *\/\n-   282,  \/* (244) collate ::= *\/\n-   282,  \/* (245) collate ::= COLLATE ID|STRING *\/\n-   190,  \/* (246) cmd ::= DROP INDEX ifexists fullname *\/\n-   190,  \/* (247) cmd ::= VACUUM vinto *\/\n-   190,  \/* (248) cmd ::= VACUUM nm vinto *\/\n-   283,  \/* (249) vinto ::= INTO expr *\/\n-   283,  \/* (250) vinto ::= *\/\n-   190,  \/* (251) cmd ::= PRAGMA nm dbnm *\/\n-   190,  \/* (252) cmd ::= PRAGMA nm dbnm EQ nmnum *\/\n-   190,  \/* (253) cmd ::= PRAGMA nm dbnm LP nmnum RP *\/\n-   190,  \/* (254) cmd ::= PRAGMA nm dbnm EQ minus_num *\/\n-   190,  \/* (255) cmd ::= PRAGMA nm dbnm LP minus_num RP *\/\n-   211,  \/* (256) plus_num ::= PLUS INTEGER|FLOAT *\/\n-   212,  \/* (257) minus_num ::= MINUS INTEGER|FLOAT *\/\n-   190,  \/* (258) cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END *\/\n-   285,  \/* (259) trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause *\/\n-   287,  \/* (260) trigger_time ::= BEFORE|AFTER *\/\n-   287,  \/* (261) trigger_time ::= INSTEAD OF *\/\n-   287,  \/* (262) trigger_time ::= *\/\n-   288,  \/* (263) trigger_event ::= DELETE|INSERT *\/\n-   288,  \/* (264) trigger_event ::= UPDATE *\/\n-   288,  \/* (265) trigger_event ::= UPDATE OF idlist *\/\n-   290,  \/* (266) when_clause ::= *\/\n-   290,  \/* (267) when_clause ::= WHEN expr *\/\n-   286,  \/* (268) trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI *\/\n-   286,  \/* (269) trigger_cmd_list ::= trigger_cmd SEMI *\/\n-   292,  \/* (270) trnm ::= nm DOT nm *\/\n-   293,  \/* (271) tridxby ::= INDEXED BY nm *\/\n-   293,  \/* (272) tridxby ::= NOT INDEXED *\/\n-   291,  \/* (273) trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist from where_opt scanpt *\/\n-   291,  \/* (274) trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt *\/\n-   291,  \/* (275) trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt *\/\n-   291,  \/* (276) trigger_cmd ::= scanpt select scanpt *\/\n-   217,  \/* (277) expr ::= RAISE LP IGNORE RP *\/\n-   217,  \/* (278) expr ::= RAISE LP raisetype COMMA nm RP *\/\n-   236,  \/* (279) raisetype ::= ROLLBACK *\/\n-   236,  \/* (280) raisetype ::= ABORT *\/\n-   236,  \/* (281) raisetype ::= FAIL *\/\n-   190,  \/* (282) cmd ::= DROP TRIGGER ifexists fullname *\/\n-   190,  \/* (283) cmd ::= ATTACH database_kw_opt expr AS expr key_opt *\/\n-   190,  \/* (284) cmd ::= DETACH database_kw_opt expr *\/\n-   295,  \/* (285) key_opt ::= *\/\n-   295,  \/* (286) key_opt ::= KEY expr *\/\n-   190,  \/* (287) cmd ::= REINDEX *\/\n-   190,  \/* (288) cmd ::= REINDEX nm dbnm *\/\n-   190,  \/* (289) cmd ::= ANALYZE *\/\n-   190,  \/* (290) cmd ::= ANALYZE nm dbnm *\/\n-   190,  \/* (291) cmd ::= ALTER TABLE fullname RENAME TO nm *\/\n-   190,  \/* (292) cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist *\/\n-   190,  \/* (293) cmd ::= ALTER TABLE fullname DROP kwcolumn_opt nm *\/\n-   296,  \/* (294) add_column_fullname ::= fullname *\/\n-   190,  \/* (295) cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm *\/\n-   190,  \/* (296) cmd ::= create_vtab *\/\n-   190,  \/* (297) cmd ::= create_vtab LP vtabarglist RP *\/\n-   298,  \/* (298) create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm *\/\n-   300,  \/* (299) vtabarg ::= *\/\n-   301,  \/* (300) vtabargtoken ::= ANY *\/\n-   301,  \/* (301) vtabargtoken ::= lp anylist RP *\/\n-   302,  \/* (302) lp ::= LP *\/\n-   266,  \/* (303) with ::= WITH wqlist *\/\n-   266,  \/* (304) with ::= WITH RECURSIVE wqlist *\/\n-   305,  \/* (305) wqas ::= AS *\/\n-   305,  \/* (306) wqas ::= AS MATERIALIZED *\/\n-   305,  \/* (307) wqas ::= AS NOT MATERIALIZED *\/\n-   304,  \/* (308) wqitem ::= nm eidlist_opt wqas LP select RP *\/\n-   241,  \/* (309) wqlist ::= wqitem *\/\n-   241,  \/* (310) wqlist ::= wqlist COMMA wqitem *\/\n-   306,  \/* (311) windowdefn_list ::= windowdefn_list COMMA windowdefn *\/\n-   307,  \/* (312) windowdefn ::= nm AS LP window RP *\/\n-   308,  \/* (313) window ::= PARTITION BY nexprlist orderby_opt frame_opt *\/\n-   308,  \/* (314) window ::= nm PARTITION BY nexprlist orderby_opt frame_opt *\/\n-   308,  \/* (315) window ::= ORDER BY sortlist frame_opt *\/\n-   308,  \/* (316) window ::= nm ORDER BY sortlist frame_opt *\/\n-   308,  \/* (317) window ::= nm frame_opt *\/\n-   309,  \/* (318) frame_opt ::= *\/\n-   309,  \/* (319) frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt *\/\n-   309,  \/* (320) frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt *\/\n-   313,  \/* (321) range_or_rows ::= RANGE|ROWS|GROUPS *\/\n-   315,  \/* (322) frame_bound_s ::= frame_bound *\/\n-   315,  \/* (323) frame_bound_s ::= UNBOUNDED PRECEDING *\/\n-   316,  \/* (324) frame_bound_e ::= frame_bound *\/\n-   316,  \/* (325) frame_bound_e ::= UNBOUNDED FOLLOWING *\/\n-   314,  \/* (326) frame_bound ::= expr PRECEDING|FOLLOWING *\/\n-   314,  \/* (327) frame_bound ::= CURRENT ROW *\/\n-   317,  \/* (328) frame_exclude_opt ::= *\/\n-   317,  \/* (329) frame_exclude_opt ::= EXCLUDE frame_exclude *\/\n-   318,  \/* (330) frame_exclude ::= NO OTHERS *\/\n-   318,  \/* (331) frame_exclude ::= CURRENT ROW *\/\n-   318,  \/* (332) frame_exclude ::= GROUP|TIES *\/\n-   251,  \/* (333) window_clause ::= WINDOW windowdefn_list *\/\n-   273,  \/* (334) filter_over ::= filter_clause over_clause *\/\n-   273,  \/* (335) filter_over ::= over_clause *\/\n-   273,  \/* (336) filter_over ::= filter_clause *\/\n-   312,  \/* (337) over_clause ::= OVER LP window RP *\/\n-   312,  \/* (338) over_clause ::= OVER nm *\/\n-   311,  \/* (339) filter_clause ::= FILTER LP WHERE expr RP *\/\n-   185,  \/* (340) input ::= cmdlist *\/\n-   186,  \/* (341) cmdlist ::= cmdlist ecmd *\/\n-   186,  \/* (342) cmdlist ::= ecmd *\/\n-   187,  \/* (343) ecmd ::= SEMI *\/\n-   187,  \/* (344) ecmd ::= cmdx SEMI *\/\n-   187,  \/* (345) ecmd ::= explain cmdx SEMI *\/\n-   192,  \/* (346) trans_opt ::= *\/\n-   192,  \/* (347) trans_opt ::= TRANSACTION *\/\n-   192,  \/* (348) trans_opt ::= TRANSACTION nm *\/\n-   194,  \/* (349) savepoint_opt ::= SAVEPOINT *\/\n-   194,  \/* (350) savepoint_opt ::= *\/\n-   190,  \/* (351) cmd ::= create_table create_table_args *\/\n-   203,  \/* (352) table_option_set ::= table_option *\/\n-   201,  \/* (353) columnlist ::= columnlist COMMA columnname carglist *\/\n-   201,  \/* (354) columnlist ::= columnname carglist *\/\n-   193,  \/* (355) nm ::= ID|INDEXED|JOIN_KW *\/\n-   193,  \/* (356) nm ::= STRING *\/\n-   208,  \/* (357) typetoken ::= typename *\/\n-   209,  \/* (358) typename ::= ID|STRING *\/\n-   210,  \/* (359) signed ::= plus_num *\/\n-   210,  \/* (360) signed ::= minus_num *\/\n-   207,  \/* (361) carglist ::= carglist ccons *\/\n-   207,  \/* (362) carglist ::= *\/\n-   215,  \/* (363) ccons ::= NULL onconf *\/\n-   215,  \/* (364) ccons ::= GENERATED ALWAYS AS generated *\/\n-   215,  \/* (365) ccons ::= AS generated *\/\n-   202,  \/* (366) conslist_opt ::= COMMA conslist *\/\n-   228,  \/* (367) conslist ::= conslist tconscomma tcons *\/\n-   228,  \/* (368) conslist ::= tcons *\/\n-   229,  \/* (369) tconscomma ::= *\/\n-   233,  \/* (370) defer_subclause_opt ::= defer_subclause *\/\n-   235,  \/* (371) resolvetype ::= raisetype *\/\n-   239,  \/* (372) selectnowith ::= oneselect *\/\n-   240,  \/* (373) oneselect ::= values *\/\n-   254,  \/* (374) sclp ::= selcollist COMMA *\/\n-   255,  \/* (375) as ::= ID|STRING *\/\n-   264,  \/* (376) indexed_opt ::= indexed_by *\/\n-   272,  \/* (377) returning ::= *\/\n-   217,  \/* (378) expr ::= term *\/\n-   274,  \/* (379) likeop ::= LIKE_KW|MATCH *\/\n-   278,  \/* (380) case_operand ::= expr *\/\n-   261,  \/* (381) exprlist ::= nexprlist *\/\n-   284,  \/* (382) nmnum ::= plus_num *\/\n-   284,  \/* (383) nmnum ::= nm *\/\n-   284,  \/* (384) nmnum ::= ON *\/\n-   284,  \/* (385) nmnum ::= DELETE *\/\n-   284,  \/* (386) nmnum ::= DEFAULT *\/\n-   211,  \/* (387) plus_num ::= INTEGER|FLOAT *\/\n-   289,  \/* (388) foreach_clause ::= *\/\n-   289,  \/* (389) foreach_clause ::= FOR EACH ROW *\/\n-   292,  \/* (390) trnm ::= nm *\/\n-   293,  \/* (391) tridxby ::= *\/\n-   294,  \/* (392) database_kw_opt ::= DATABASE *\/\n-   294,  \/* (393) database_kw_opt ::= *\/\n-   297,  \/* (394) kwcolumn_opt ::= *\/\n-   297,  \/* (395) kwcolumn_opt ::= COLUMNKW *\/\n-   299,  \/* (396) vtabarglist ::= vtabarg *\/\n-   299,  \/* (397) vtabarglist ::= vtabarglist COMMA vtabarg *\/\n-   300,  \/* (398) vtabarg ::= vtabarg vtabargtoken *\/\n-   303,  \/* (399) anylist ::= *\/\n-   303,  \/* (400) anylist ::= anylist LP anylist RP *\/\n-   303,  \/* (401) anylist ::= anylist ANY *\/\n-   266,  \/* (402) with ::= *\/\n-   306,  \/* (403) windowdefn_list ::= windowdefn *\/\n-   308,  \/* (404) window ::= frame_opt *\/\n+   191,  \/* (0) explain ::= EXPLAIN *\/\n+   191,  \/* (1) explain ::= EXPLAIN QUERY PLAN *\/\n+   190,  \/* (2) cmdx ::= cmd *\/\n+   192,  \/* (3) cmd ::= BEGIN transtype trans_opt *\/\n+   193,  \/* (4) transtype ::= *\/\n+   193,  \/* (5) transtype ::= DEFERRED *\/\n+   193,  \/* (6) transtype ::= IMMEDIATE *\/\n+   193,  \/* (7) transtype ::= EXCLUSIVE *\/\n+   192,  \/* (8) cmd ::= COMMIT|END trans_opt *\/\n+   192,  \/* (9) cmd ::= ROLLBACK trans_opt *\/\n+   192,  \/* (10) cmd ::= SAVEPOINT nm *\/\n+   192,  \/* (11) cmd ::= RELEASE savepoint_opt nm *\/\n+   192,  \/* (12) cmd ::= ROLLBACK trans_opt TO savepoint_opt nm *\/\n+   197,  \/* (13) create_table ::= createkw temp TABLE ifnotexists nm dbnm *\/\n+   199,  \/* (14) createkw ::= CREATE *\/\n+   201,  \/* (15) ifnotexists ::= *\/\n+   201,  \/* (16) ifnotexists ::= IF NOT EXISTS *\/\n+   200,  \/* (17) temp ::= TEMP *\/\n+   200,  \/* (18) temp ::= *\/\n+   198,  \/* (19) create_table_args ::= LP columnlist conslist_opt RP table_option_set *\/\n+   198,  \/* (20) create_table_args ::= AS select *\/\n+   205,  \/* (21) table_option_set ::= *\/\n+   205,  \/* (22) table_option_set ::= table_option_set COMMA table_option *\/\n+   207,  \/* (23) table_option ::= WITHOUT nm *\/\n+   207,  \/* (24) table_option ::= nm *\/\n+   208,  \/* (25) columnname ::= nm typetoken *\/\n+   210,  \/* (26) typetoken ::= *\/\n+   210,  \/* (27) typetoken ::= typename LP signed RP *\/\n+   210,  \/* (28) typetoken ::= typename LP signed COMMA signed RP *\/\n+   211,  \/* (29) typename ::= typename ID|STRING *\/\n+   215,  \/* (30) scanpt ::= *\/\n+   216,  \/* (31) scantok ::= *\/\n+   217,  \/* (32) ccons ::= CONSTRAINT nm *\/\n+   217,  \/* (33) ccons ::= DEFAULT scantok term *\/\n+   217,  \/* (34) ccons ::= DEFAULT LP expr RP *\/\n+   217,  \/* (35) ccons ::= DEFAULT PLUS scantok term *\/\n+   217,  \/* (36) ccons ::= DEFAULT MINUS scantok term *\/\n+   217,  \/* (37) ccons ::= DEFAULT scantok ID|INDEXED *\/\n+   217,  \/* (38) ccons ::= NOT NULL onconf *\/\n+   217,  \/* (39) ccons ::= PRIMARY KEY sortorder onconf autoinc *\/\n+   217,  \/* (40) ccons ::= UNIQUE onconf *\/\n+   217,  \/* (41) ccons ::= CHECK LP expr RP *\/\n+   217,  \/* (42) ccons ::= REFERENCES nm eidlist_opt refargs *\/\n+   217,  \/* (43) ccons ::= defer_subclause *\/\n+   217,  \/* (44) ccons ::= COLLATE ID|STRING *\/\n+   226,  \/* (45) generated ::= LP expr RP *\/\n+   226,  \/* (46) generated ::= LP expr RP ID *\/\n+   222,  \/* (47) autoinc ::= *\/\n+   222,  \/* (48) autoinc ::= AUTOINCR *\/\n+   224,  \/* (49) refargs ::= *\/\n+   224,  \/* (50) refargs ::= refargs refarg *\/\n+   227,  \/* (51) refarg ::= MATCH nm *\/\n+   227,  \/* (52) refarg ::= ON INSERT refact *\/\n+   227,  \/* (53) refarg ::= ON DELETE refact *\/\n+   227,  \/* (54) refarg ::= ON UPDATE refact *\/\n+   228,  \/* (55) refact ::= SET NULL *\/\n+   228,  \/* (56) refact ::= SET DEFAULT *\/\n+   228,  \/* (57) refact ::= CASCADE *\/\n+   228,  \/* (58) refact ::= RESTRICT *\/\n+   228,  \/* (59) refact ::= NO ACTION *\/\n+   225,  \/* (60) defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt *\/\n+   225,  \/* (61) defer_subclause ::= DEFERRABLE init_deferred_pred_opt *\/\n+   229,  \/* (62) init_deferred_pred_opt ::= *\/\n+   229,  \/* (63) init_deferred_pred_opt ::= INITIALLY DEFERRED *\/\n+   229,  \/* (64) init_deferred_pred_opt ::= INITIALLY IMMEDIATE *\/\n+   204,  \/* (65) conslist_opt ::= *\/\n+   231,  \/* (66) tconscomma ::= COMMA *\/\n+   232,  \/* (67) tcons ::= CONSTRAINT nm *\/\n+   232,  \/* (68) tcons ::= PRIMARY KEY LP sortlist autoinc RP onconf *\/\n+   232,  \/* (69) tcons ::= UNIQUE LP sortlist RP onconf *\/\n+   232,  \/* (70) tcons ::= CHECK LP expr RP onconf *\/\n+   232,  \/* (71) tcons ::= FOREIGN KEY LP eidlist RP REFERENCES nm eidlist_opt refargs defer_subclause_opt *\/\n+   235,  \/* (72) defer_subclause_opt ::= *\/\n+   220,  \/* (73) onconf ::= *\/\n+   220,  \/* (74) onconf ::= ON CONFLICT resolvetype *\/\n+   236,  \/* (75) orconf ::= *\/\n+   236,  \/* (76) orconf ::= OR resolvetype *\/\n+   237,  \/* (77) resolvetype ::= IGNORE *\/\n+   237,  \/* (78) resolvetype ::= REPLACE *\/\n+   192,  \/* (79) cmd ::= DROP TABLE ifexists fullname *\/\n+   239,  \/* (80) ifexists ::= IF EXISTS *\/\n+   239,  \/* (81) ifexists ::= *\/\n+   192,  \/* (82) cmd ::= createkw temp VIEW ifnotexists nm dbnm eidlist_opt AS select *\/\n+   192,  \/* (83) cmd ::= DROP VIEW ifexists fullname *\/\n+   192,  \/* (84) cmd ::= select *\/\n+   206,  \/* (85) select ::= WITH wqlist selectnowith *\/\n+   206,  \/* (86) select ::= WITH RECURSIVE wqlist selectnowith *\/\n+   206,  \/* (87) select ::= selectnowith *\/\n+   241,  \/* (88) selectnowith ::= selectnowith multiselect_op oneselect *\/\n+   244,  \/* (89) multiselect_op ::= UNION *\/\n+   244,  \/* (90) multiselect_op ::= UNION ALL *\/\n+   244,  \/* (91) multiselect_op ::= EXCEPT|INTERSECT *\/\n+   242,  \/* (92) oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt *\/\n+   242,  \/* (93) oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt window_clause orderby_opt limit_opt *\/\n+   254,  \/* (94) values ::= VALUES LP nexprlist RP *\/\n+   242,  \/* (95) oneselect ::= mvalues *\/\n+   256,  \/* (96) mvalues ::= values COMMA LP nexprlist RP *\/\n+   256,  \/* (97) mvalues ::= mvalues COMMA LP nexprlist RP *\/\n+   245,  \/* (98) distinct ::= DISTINCT *\/\n+   245,  \/* (99) distinct ::= ALL *\/\n+   245,  \/* (100) distinct ::= *\/\n+   257,  \/* (101) sclp ::= *\/\n+   246,  \/* (102) selcollist ::= sclp scanpt expr scanpt as *\/\n+   246,  \/* (103) selcollist ::= sclp scanpt STAR *\/\n+   246,  \/* (104) selcollist ::= sclp scanpt nm DOT STAR *\/\n+   258,  \/* (105) as ::= AS nm *\/\n+   258,  \/* (106) as ::= *\/\n+   247,  \/* (107) from ::= *\/\n+   247,  \/* (108) from ::= FROM seltablist *\/\n+   260,  \/* (109) stl_prefix ::= seltablist joinop *\/\n+   260,  \/* (110) stl_prefix ::= *\/\n+   259,  \/* (111) seltablist ::= stl_prefix nm dbnm as on_using *\/\n+   259,  \/* (112) seltablist ::= stl_prefix nm dbnm as indexed_by on_using *\/\n+   259,  \/* (113) seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_using *\/\n+   259,  \/* (114) seltablist ::= stl_prefix LP select RP as on_using *\/\n+   259,  \/* (115) seltablist ::= stl_prefix LP seltablist RP as on_using *\/\n+   202,  \/* (116) dbnm ::= *\/\n+   202,  \/* (117) dbnm ::= DOT nm *\/\n+   240,  \/* (118) fullname ::= nm *\/\n+   240,  \/* (119) fullname ::= nm DOT nm *\/\n+   265,  \/* (120) xfullname ::= nm *\/\n+   265,  \/* (121) xfullname ::= nm DOT nm *\/\n+   265,  \/* (122) xfullname ::= nm DOT nm AS nm *\/\n+   265,  \/* (123) xfullname ::= nm AS nm *\/\n+   261,  \/* (124) joinop ::= COMMA|JOIN *\/\n+   261,  \/* (125) joinop ::= JOIN_KW JOIN *\/\n+   261,  \/* (126) joinop ::= JOIN_KW nm JOIN *\/\n+   261,  \/* (127) joinop ::= JOIN_KW nm nm JOIN *\/\n+   262,  \/* (128) on_using ::= ON expr *\/\n+   262,  \/* (129) on_using ::= USING LP idlist RP *\/\n+   262,  \/* (130) on_using ::= *\/\n+   267,  \/* (131) indexed_opt ::= *\/\n+   263,  \/* (132) indexed_by ::= INDEXED BY nm *\/\n+   263,  \/* (133) indexed_by ::= NOT INDEXED *\/\n+   251,  \/* (134) orderby_opt ::= *\/\n+   251,  \/* (135) orderby_opt ::= ORDER BY sortlist *\/\n+   233,  \/* (136) sortlist ::= sortlist COMMA expr sortorder nulls *\/\n+   233,  \/* (137) sortlist ::= expr sortorder nulls *\/\n+   221,  \/* (138) sortorder ::= ASC *\/\n+   221,  \/* (139) sortorder ::= DESC *\/\n+   221,  \/* (140) sortorder ::= *\/\n+   268,  \/* (141) nulls ::= NULLS FIRST *\/\n+   268,  \/* (142) nulls ::= NULLS LAST *\/\n+   268,  \/* (143) nulls ::= *\/\n+   249,  \/* (144) groupby_opt ::= *\/\n+   249,  \/* (145) groupby_opt ::= GROUP BY nexprlist *\/\n+   250,  \/* (146) having_opt ::= *\/\n+   250,  \/* (147) having_opt ::= HAVING expr *\/\n+   252,  \/* (148) limit_opt ::= *\/\n+   252,  \/* (149) limit_opt ::= LIMIT expr *\/\n+   252,  \/* (150) limit_opt ::= LIMIT expr OFFSET expr *\/\n+   252,  \/* (151) limit_opt ::= LIMIT expr COMMA expr *\/\n+   192,  \/* (152) cmd ::= with DELETE FROM xfullname indexed_opt where_opt_ret *\/\n+   248,  \/* (153) where_opt ::= *\/\n+   248,  \/* (154) where_opt ::= WHERE expr *\/\n+   270,  \/* (155) where_opt_ret ::= *\/\n+   270,  \/* (156) where_opt_ret ::= WHERE expr *\/\n+   270,  \/* (157) where_opt_ret ::= RETURNING selcollist *\/\n+   270,  \/* (158) where_opt_ret ::= WHERE expr RETURNING selcollist *\/\n+   192,  \/* (159) cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist from where_opt_ret *\/\n+   271,  \/* (160) setlist ::= setlist COMMA nm EQ expr *\/\n+   271,  \/* (161) setlist ::= setlist COMMA LP idlist RP EQ expr *\/\n+   271,  \/* (162) setlist ::= nm EQ expr *\/\n+   271,  \/* (163) setlist ::= LP idlist RP EQ expr *\/\n+   192,  \/* (164) cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert *\/\n+   192,  \/* (165) cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES returning *\/\n+   274,  \/* (166) upsert ::= *\/\n+   274,  \/* (167) upsert ::= RETURNING selcollist *\/\n+   274,  \/* (168) upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt upsert *\/\n+   274,  \/* (169) upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING upsert *\/\n+   274,  \/* (170) upsert ::= ON CONFLICT DO NOTHING returning *\/\n+   274,  \/* (171) upsert ::= ON CONFLICT DO UPDATE SET setlist where_opt returning *\/\n+   275,  \/* (172) returning ::= RETURNING selcollist *\/\n+   272,  \/* (173) insert_cmd ::= INSERT orconf *\/\n+   272,  \/* (174) insert_cmd ::= REPLACE *\/\n+   273,  \/* (175) idlist_opt ::= *\/\n+   273,  \/* (176) idlist_opt ::= LP idlist RP *\/\n+   266,  \/* (177) idlist ::= idlist COMMA nm *\/\n+   266,  \/* (178) idlist ::= nm *\/\n+   219,  \/* (179) expr ::= LP expr RP *\/\n+   219,  \/* (180) expr ::= ID|INDEXED|JOIN_KW *\/\n+   219,  \/* (181) expr ::= nm DOT nm *\/\n+   219,  \/* (182) expr ::= nm DOT nm DOT nm *\/\n+   218,  \/* (183) term ::= NULL|FLOAT|BLOB *\/\n+   218,  \/* (184) term ::= STRING *\/\n+   218,  \/* (185) term ::= INTEGER *\/\n+   219,  \/* (186) expr ::= VARIABLE *\/\n+   219,  \/* (187) expr ::= expr COLLATE ID|STRING *\/\n+   219,  \/* (188) expr ::= CAST LP expr AS typetoken RP *\/\n+   219,  \/* (189) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP *\/\n+   219,  \/* (190) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP *\/\n+   219,  \/* (191) expr ::= ID|INDEXED|JOIN_KW LP STAR RP *\/\n+   219,  \/* (192) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP filter_over *\/\n+   219,  \/* (193) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP filter_over *\/\n+   219,  \/* (194) expr ::= ID|INDEXED|JOIN_KW LP STAR RP filter_over *\/\n+   218,  \/* (195) term ::= CTIME_KW *\/\n+   219,  \/* (196) expr ::= LP nexprlist COMMA expr RP *\/\n+   219,  \/* (197) expr ::= expr AND expr *\/\n+   219,  \/* (198) expr ::= expr OR expr *\/\n+   219,  \/* (199) expr ::= expr LT|GT|GE|LE expr *\/\n+   219,  \/* (200) expr ::= expr EQ|NE expr *\/\n+   219,  \/* (201) expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr *\/\n+   219,  \/* (202) expr ::= expr PLUS|MINUS expr *\/\n+   219,  \/* (203) expr ::= expr STAR|SLASH|REM expr *\/\n+   219,  \/* (204) expr ::= expr CONCAT expr *\/\n+   277,  \/* (205) likeop ::= NOT LIKE_KW|MATCH *\/\n+   219,  \/* (206) expr ::= expr likeop expr *\/\n+   219,  \/* (207) expr ::= expr likeop expr ESCAPE expr *\/\n+   219,  \/* (208) expr ::= expr ISNULL|NOTNULL *\/\n+   219,  \/* (209) expr ::= expr NOT NULL *\/\n+   219,  \/* (210) expr ::= expr IS expr *\/\n+   219,  \/* (211) expr ::= expr IS NOT expr *\/\n+   219,  \/* (212) expr ::= expr IS NOT DISTINCT FROM expr *\/\n+   219,  \/* (213) expr ::= expr IS DISTINCT FROM expr *\/\n+   219,  \/* (214) expr ::= NOT expr *\/\n+   219,  \/* (215) expr ::= BITNOT expr *\/\n+   219,  \/* (216) expr ::= PLUS|MINUS expr *\/\n+   219,  \/* (217) expr ::= expr PTR expr *\/\n+   278,  \/* (218) between_op ::= BETWEEN *\/\n+   278,  \/* (219) between_op ::= NOT BETWEEN *\/\n+   219,  \/* (220) expr ::= expr between_op expr AND expr *\/\n+   279,  \/* (221) in_op ::= IN *\/\n+   279,  \/* (222) in_op ::= NOT IN *\/\n+   219,  \/* (223) expr ::= expr in_op LP exprlist RP *\/\n+   219,  \/* (224) expr ::= LP select RP *\/\n+   219,  \/* (225) expr ::= expr in_op LP select RP *\/\n+   219,  \/* (226) expr ::= expr in_op nm dbnm paren_exprlist *\/\n+   219,  \/* (227) expr ::= EXISTS LP select RP *\/\n+   219,  \/* (228) expr ::= CASE case_operand case_exprlist case_else END *\/\n+   282,  \/* (229) case_exprlist ::= case_exprlist WHEN expr THEN expr *\/\n+   282,  \/* (230) case_exprlist ::= WHEN expr THEN expr *\/\n+   283,  \/* (231) case_else ::= ELSE expr *\/\n+   283,  \/* (232) case_else ::= *\/\n+   281,  \/* (233) case_operand ::= *\/\n+   264,  \/* (234) exprlist ::= *\/\n+   255,  \/* (235) nexprlist ::= nexprlist COMMA expr *\/\n+   255,  \/* (236) nexprlist ::= expr *\/\n+   280,  \/* (237) paren_exprlist ::= *\/\n+   280,  \/* (238) paren_exprlist ::= LP exprlist RP *\/\n+   192,  \/* (239) cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt *\/\n+   284,  \/* (240) uniqueflag ::= UNIQUE *\/\n+   284,  \/* (241) uniqueflag ::= *\/\n+   223,  \/* (242) eidlist_opt ::= *\/\n+   223,  \/* (243) eidlist_opt ::= LP eidlist RP *\/\n+   234,  \/* (244) eidlist ::= eidlist COMMA nm collate sortorder *\/\n+   234,  \/* (245) eidlist ::= nm collate sortorder *\/\n+   285,  \/* (246) collate ::= *\/\n+   285,  \/* (247) collate ::= COLLATE ID|STRING *\/\n+   192,  \/* (248) cmd ::= DROP INDEX ifexists fullname *\/\n+   192,  \/* (249) cmd ::= VACUUM vinto *\/\n+   192,  \/* (250) cmd ::= VACUUM nm vinto *\/\n+   286,  \/* (251) vinto ::= INTO expr *\/\n+   286,  \/* (252) vinto ::= *\/\n+   192,  \/* (253) cmd ::= PRAGMA nm dbnm *\/\n+   192,  \/* (254) cmd ::= PRAGMA nm dbnm EQ nmnum *\/\n+   192,  \/* (255) cmd ::= PRAGMA nm dbnm LP nmnum RP *\/\n+   192,  \/* (256) cmd ::= PRAGMA nm dbnm EQ minus_num *\/\n+   192,  \/* (257) cmd ::= PRAGMA nm dbnm LP minus_num RP *\/\n+   213,  \/* (258) plus_num ::= PLUS INTEGER|FLOAT *\/\n+   214,  \/* (259) minus_num ::= MINUS INTEGER|FLOAT *\/\n+   192,  \/* (260) cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END *\/\n+   288,  \/* (261) trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause *\/\n+   290,  \/* (262) trigger_time ::= BEFORE|AFTER *\/\n+   290,  \/* (263) trigger_time ::= INSTEAD OF *\/\n+   290,  \/* (264) trigger_time ::= *\/\n+   291,  \/* (265) trigger_event ::= DELETE|INSERT *\/\n+   291,  \/* (266) trigger_event ::= UPDATE *\/\n+   291,  \/* (267) trigger_event ::= UPDATE OF idlist *\/\n+   293,  \/* (268) when_clause ::= *\/\n+   293,  \/* (269) when_clause ::= WHEN expr *\/\n+   289,  \/* (270) trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI *\/\n+   289,  \/* (271) trigger_cmd_list ::= trigger_cmd SEMI *\/\n+   295,  \/* (272) trnm ::= nm DOT nm *\/\n+   296,  \/* (273) tridxby ::= INDEXED BY nm *\/\n+   296,  \/* (274) tridxby ::= NOT INDEXED *\/\n+   294,  \/* (275) trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist from where_opt scanpt *\/\n+   294,  \/* (276) trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt *\/\n+   294,  \/* (277) trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt *\/\n+   294,  \/* (278) trigger_cmd ::= scanpt select scanpt *\/\n+   219,  \/* (279) expr ::= RAISE LP IGNORE RP *\/\n+   219,  \/* (280) expr ::= RAISE LP raisetype COMMA expr RP *\/\n+   238,  \/* (281) raisetype ::= ROLLBACK *\/\n+   238,  \/* (282) raisetype ::= ABORT *\/\n+   238,  \/* (283) raisetype ::= FAIL *\/\n+   192,  \/* (284) cmd ::= DROP TRIGGER ifexists fullname *\/\n+   192,  \/* (285) cmd ::= ATTACH database_kw_opt expr AS expr key_opt *\/\n+   192,  \/* (286) cmd ::= DETACH database_kw_opt expr *\/\n+   298,  \/* (287) key_opt ::= *\/\n+   298,  \/* (288) key_opt ::= KEY expr *\/\n+   192,  \/* (289) cmd ::= REINDEX *\/\n+   192,  \/* (290) cmd ::= REINDEX nm dbnm *\/\n+   192,  \/* (291) cmd ::= ANALYZE *\/\n+   192,  \/* (292) cmd ::= ANALYZE nm dbnm *\/\n+   192,  \/* (293) cmd ::= ALTER TABLE fullname RENAME TO nm *\/\n+   192,  \/* (294) cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist *\/\n+   192,  \/* (295) cmd ::= ALTER TABLE fullname DROP kwcolumn_opt nm *\/\n+   299,  \/* (296) add_column_fullname ::= fullname *\/\n+   192,  \/* (297) cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm *\/\n+   192,  \/* (298) cmd ::= create_vtab *\/\n+   192,  \/* (299) cmd ::= create_vtab LP vtabarglist RP *\/\n+   301,  \/* (300) create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm *\/\n+   303,  \/* (301) vtabarg ::= *\/\n+   304,  \/* (302) vtabargtoken ::= ANY *\/\n+   304,  \/* (303) vtabargtoken ::= lp anylist RP *\/\n+   305,  \/* (304) lp ::= LP *\/\n+   269,  \/* (305) with ::= WITH wqlist *\/\n+   269,  \/* (306) with ::= WITH RECURSIVE wqlist *\/\n+   308,  \/* (307) wqas ::= AS *\/\n+   308,  \/* (308) wqas ::= AS MATERIALIZED *\/\n+   308,  \/* (309) wqas ::= AS NOT MATERIALIZED *\/\n+   307,  \/* (310) wqitem ::= withnm eidlist_opt wqas LP select RP *\/\n+   309,  \/* (311) withnm ::= nm *\/\n+   243,  \/* (312) wqlist ::= wqitem *\/\n+   243,  \/* (313) wqlist ::= wqlist COMMA wqitem *\/\n+   310,  \/* (314) windowdefn_list ::= windowdefn_list COMMA windowdefn *\/\n+   311,  \/* (315) windowdefn ::= nm AS LP window RP *\/\n+   312,  \/* (316) window ::= PARTITION BY nexprlist orderby_opt frame_opt *\/\n+   312,  \/* (317) window ::= nm PARTITION BY nexprlist orderby_opt frame_opt *\/\n+   312,  \/* (318) window ::= ORDER BY sortlist frame_opt *\/\n+   312,  \/* (319) window ::= nm ORDER BY sortlist frame_opt *\/\n+   312,  \/* (320) window ::= nm frame_opt *\/\n+   313,  \/* (321) frame_opt ::= *\/\n+   313,  \/* (322) frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt *\/\n+   313,  \/* (323) frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt *\/\n+   317,  \/* (324) range_or_rows ::= RANGE|ROWS|GROUPS *\/\n+   319,  \/* (325) frame_bound_s ::= frame_bound *\/\n+   319,  \/* (326) frame_bound_s ::= UNBOUNDED PRECEDING *\/\n+   320,  \/* (327) frame_bound_e ::= frame_bound *\/\n+   320,  \/* (328) frame_bound_e ::= UNBOUNDED FOLLOWING *\/\n+   318,  \/* (329) frame_bound ::= expr PRECEDING|FOLLOWING *\/\n+   318,  \/* (330) frame_bound ::= CURRENT ROW *\/\n+   321,  \/* (331) frame_exclude_opt ::= *\/\n+   321,  \/* (332) frame_exclude_opt ::= EXCLUDE frame_exclude *\/\n+   322,  \/* (333) frame_exclude ::= NO OTHERS *\/\n+   322,  \/* (334) frame_exclude ::= CURRENT ROW *\/\n+   322,  \/* (335) frame_exclude ::= GROUP|TIES *\/\n+   253,  \/* (336) window_clause ::= WINDOW windowdefn_list *\/\n+   276,  \/* (337) filter_over ::= filter_clause over_clause *\/\n+   276,  \/* (338) filter_over ::= over_clause *\/\n+   276,  \/* (339) filter_over ::= filter_clause *\/\n+   316,  \/* (340) over_clause ::= OVER LP window RP *\/\n+   316,  \/* (341) over_clause ::= OVER nm *\/\n+   315,  \/* (342) filter_clause ::= FILTER LP WHERE expr RP *\/\n+   218,  \/* (343) term ::= QNUMBER *\/\n+   187,  \/* (344) input ::= cmdlist *\/\n+   188,  \/* (345) cmdlist ::= cmdlist ecmd *\/\n+   188,  \/* (346) cmdlist ::= ecmd *\/\n+   189,  \/* (347) ecmd ::= SEMI *\/\n+   189,  \/* (348) ecmd ::= cmdx SEMI *\/\n+   189,  \/* (349) ecmd ::= explain cmdx SEMI *\/\n+   194,  \/* (350) trans_opt ::= *\/\n+   194,  \/* (351) trans_opt ::= TRANSACTION *\/\n+   194,  \/* (352) trans_opt ::= TRANSACTION nm *\/\n+   196,  \/* (353) savepoint_opt ::= SAVEPOINT *\/\n+   196,  \/* (354) savepoint_opt ::= *\/\n+   192,  \/* (355) cmd ::= create_table create_table_args *\/\n+   205,  \/* (356) table_option_set ::= table_option *\/\n+   203,  \/* (357) columnlist ::= columnlist COMMA columnname carglist *\/\n+   203,  \/* (358) columnlist ::= columnname carglist *\/\n+   195,  \/* (359) nm ::= ID|INDEXED|JOIN_KW *\/\n+   195,  \/* (360) nm ::= STRING *\/\n+   210,  \/* (361) typetoken ::= typename *\/\n+   211,  \/* (362) typename ::= ID|STRING *\/\n+   212,  \/* (363) signed ::= plus_num *\/\n+   212,  \/* (364) signed ::= minus_num *\/\n+   209,  \/* (365) carglist ::= carglist ccons *\/\n+   209,  \/* (366) carglist ::= *\/\n+   217,  \/* (367) ccons ::= NULL onconf *\/\n+   217,  \/* (368) ccons ::= GENERATED ALWAYS AS generated *\/\n+   217,  \/* (369) ccons ::= AS generated *\/\n+   204,  \/* (370) conslist_opt ::= COMMA conslist *\/\n+   230,  \/* (371) conslist ::= conslist tconscomma tcons *\/\n+   230,  \/* (372) conslist ::= tcons *\/\n+   231,  \/* (373) tconscomma ::= *\/\n+   235,  \/* (374) defer_subclause_opt ::= defer_subclause *\/\n+   237,  \/* (375) resolvetype ::= raisetype *\/\n+   241,  \/* (376) selectnowith ::= oneselect *\/\n+   242,  \/* (377) oneselect ::= values *\/\n+   257,  \/* (378) sclp ::= selcollist COMMA *\/\n+   258,  \/* (379) as ::= ID|STRING *\/\n+   267,  \/* (380) indexed_opt ::= indexed_by *\/\n+   275,  \/* (381) returning ::= *\/\n+   219,  \/* (382) expr ::= term *\/\n+   277,  \/* (383) likeop ::= LIKE_KW|MATCH *\/\n+   281,  \/* (384) case_operand ::= expr *\/\n+   264,  \/* (385) exprlist ::= nexprlist *\/\n+   287,  \/* (386) nmnum ::= plus_num *\/\n+   287,  \/* (387) nmnum ::= nm *\/\n+   287,  \/* (388) nmnum ::= ON *\/\n+   287,  \/* (389) nmnum ::= DELETE *\/\n+   287,  \/* (390) nmnum ::= DEFAULT *\/\n+   213,  \/* (391) plus_num ::= INTEGER|FLOAT *\/\n+   292,  \/* (392) foreach_clause ::= *\/\n+   292,  \/* (393) foreach_clause ::= FOR EACH ROW *\/\n+   295,  \/* (394) trnm ::= nm *\/\n+   296,  \/* (395) tridxby ::= *\/\n+   297,  \/* (396) database_kw_opt ::= DATABASE *\/\n+   297,  \/* (397) database_kw_opt ::= *\/\n+   300,  \/* (398) kwcolumn_opt ::= *\/\n+   300,  \/* (399) kwcolumn_opt ::= COLUMNKW *\/\n+   302,  \/* (400) vtabarglist ::= vtabarg *\/\n+   302,  \/* (401) vtabarglist ::= vtabarglist COMMA vtabarg *\/\n+   303,  \/* (402) vtabarg ::= vtabarg vtabargtoken *\/\n+   306,  \/* (403) anylist ::= *\/\n+   306,  \/* (404) anylist ::= anylist LP anylist RP *\/\n+   306,  \/* (405) anylist ::= anylist ANY *\/\n+   269,  \/* (406) with ::= *\/\n+   310,  \/* (407) windowdefn_list ::= windowdefn *\/\n+   312,  \/* (408) window ::= frame_opt *\/\n@@ -174366,310 +177518,314 @@\n-   -5,  \/* (95) values ::= values COMMA LP nexprlist RP *\/\n-   -1,  \/* (96) distinct ::= DISTINCT *\/\n-   -1,  \/* (97) distinct ::= ALL *\/\n-    0,  \/* (98) distinct ::= *\/\n-    0,  \/* (99) sclp ::= *\/\n-   -5,  \/* (100) selcollist ::= sclp scanpt expr scanpt as *\/\n-   -3,  \/* (101) selcollist ::= sclp scanpt STAR *\/\n-   -5,  \/* (102) selcollist ::= sclp scanpt nm DOT STAR *\/\n-   -2,  \/* (103) as ::= AS nm *\/\n-    0,  \/* (104) as ::= *\/\n-    0,  \/* (105) from ::= *\/\n-   -2,  \/* (106) from ::= FROM seltablist *\/\n-   -2,  \/* (107) stl_prefix ::= seltablist joinop *\/\n-    0,  \/* (108) stl_prefix ::= *\/\n-   -5,  \/* (109) seltablist ::= stl_prefix nm dbnm as on_using *\/\n-   -6,  \/* (110) seltablist ::= stl_prefix nm dbnm as indexed_by on_using *\/\n-   -8,  \/* (111) seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_using *\/\n-   -6,  \/* (112) seltablist ::= stl_prefix LP select RP as on_using *\/\n-   -6,  \/* (113) seltablist ::= stl_prefix LP seltablist RP as on_using *\/\n-    0,  \/* (114) dbnm ::= *\/\n-   -2,  \/* (115) dbnm ::= DOT nm *\/\n-   -1,  \/* (116) fullname ::= nm *\/\n-   -3,  \/* (117) fullname ::= nm DOT nm *\/\n-   -1,  \/* (118) xfullname ::= nm *\/\n-   -3,  \/* (119) xfullname ::= nm DOT nm *\/\n-   -5,  \/* (120) xfullname ::= nm DOT nm AS nm *\/\n-   -3,  \/* (121) xfullname ::= nm AS nm *\/\n-   -1,  \/* (122) joinop ::= COMMA|JOIN *\/\n-   -2,  \/* (123) joinop ::= JOIN_KW JOIN *\/\n-   -3,  \/* (124) joinop ::= JOIN_KW nm JOIN *\/\n-   -4,  \/* (125) joinop ::= JOIN_KW nm nm JOIN *\/\n-   -2,  \/* (126) on_using ::= ON expr *\/\n-   -4,  \/* (127) on_using ::= USING LP idlist RP *\/\n-    0,  \/* (128) on_using ::= *\/\n-    0,  \/* (129) indexed_opt ::= *\/\n-   -3,  \/* (130) indexed_by ::= INDEXED BY nm *\/\n-   -2,  \/* (131) indexed_by ::= NOT INDEXED *\/\n-    0,  \/* (132) orderby_opt ::= *\/\n-   -3,  \/* (133) orderby_opt ::= ORDER BY sortlist *\/\n-   -5,  \/* (134) sortlist ::= sortlist COMMA expr sortorder nulls *\/\n-   -3,  \/* (135) sortlist ::= expr sortorder nulls *\/\n-   -1,  \/* (136) sortorder ::= ASC *\/\n-   -1,  \/* (137) sortorder ::= DESC *\/\n-    0,  \/* (138) sortorder ::= *\/\n-   -2,  \/* (139) nulls ::= NULLS FIRST *\/\n-   -2,  \/* (140) nulls ::= NULLS LAST *\/\n-    0,  \/* (141) nulls ::= *\/\n-    0,  \/* (142) groupby_opt ::= *\/\n-   -3,  \/* (143) groupby_opt ::= GROUP BY nexprlist *\/\n-    0,  \/* (144) having_opt ::= *\/\n-   -2,  \/* (145) having_opt ::= HAVING expr *\/\n-    0,  \/* (146) limit_opt ::= *\/\n-   -2,  \/* (147) limit_opt ::= LIMIT expr *\/\n-   -4,  \/* (148) limit_opt ::= LIMIT expr OFFSET expr *\/\n-   -4,  \/* (149) limit_opt ::= LIMIT expr COMMA expr *\/\n-   -6,  \/* (150) cmd ::= with DELETE FROM xfullname indexed_opt where_opt_ret *\/\n-    0,  \/* (151) where_opt ::= *\/\n-   -2,  \/* (152) where_opt ::= WHERE expr *\/\n-    0,  \/* (153) where_opt_ret ::= *\/\n-   -2,  \/* (154) where_opt_ret ::= WHERE expr *\/\n-   -2,  \/* (155) where_opt_ret ::= RETURNING selcollist *\/\n-   -4,  \/* (156) where_opt_ret ::= WHERE expr RETURNING selcollist *\/\n-   -9,  \/* (157) cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist from where_opt_ret *\/\n-   -5,  \/* (158) setlist ::= setlist COMMA nm EQ expr *\/\n-   -7,  \/* (159) setlist ::= setlist COMMA LP idlist RP EQ expr *\/\n-   -3,  \/* (160) setlist ::= nm EQ expr *\/\n-   -5,  \/* (161) setlist ::= LP idlist RP EQ expr *\/\n-   -7,  \/* (162) cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert *\/\n-   -8,  \/* (163) cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES returning *\/\n-    0,  \/* (164) upsert ::= *\/\n-   -2,  \/* (165) upsert ::= RETURNING selcollist *\/\n-  -12,  \/* (166) upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt upsert *\/\n-   -9,  \/* (167) upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING upsert *\/\n-   -5,  \/* (168) upsert ::= ON CONFLICT DO NOTHING returning *\/\n-   -8,  \/* (169) upsert ::= ON CONFLICT DO UPDATE SET setlist where_opt returning *\/\n-   -2,  \/* (170) returning ::= RETURNING selcollist *\/\n-   -2,  \/* (171) insert_cmd ::= INSERT orconf *\/\n-   -1,  \/* (172) insert_cmd ::= REPLACE *\/\n-    0,  \/* (173) idlist_opt ::= *\/\n-   -3,  \/* (174) idlist_opt ::= LP idlist RP *\/\n-   -3,  \/* (175) idlist ::= idlist COMMA nm *\/\n-   -1,  \/* (176) idlist ::= nm *\/\n-   -3,  \/* (177) expr ::= LP expr RP *\/\n-   -1,  \/* (178) expr ::= ID|INDEXED|JOIN_KW *\/\n-   -3,  \/* (179) expr ::= nm DOT nm *\/\n-   -5,  \/* (180) expr ::= nm DOT nm DOT nm *\/\n-   -1,  \/* (181) term ::= NULL|FLOAT|BLOB *\/\n-   -1,  \/* (182) term ::= STRING *\/\n-   -1,  \/* (183) term ::= INTEGER *\/\n-   -1,  \/* (184) expr ::= VARIABLE *\/\n-   -3,  \/* (185) expr ::= expr COLLATE ID|STRING *\/\n-   -6,  \/* (186) expr ::= CAST LP expr AS typetoken RP *\/\n-   -5,  \/* (187) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP *\/\n-   -8,  \/* (188) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP *\/\n-   -4,  \/* (189) expr ::= ID|INDEXED|JOIN_KW LP STAR RP *\/\n-   -6,  \/* (190) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP filter_over *\/\n-   -9,  \/* (191) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP filter_over *\/\n-   -5,  \/* (192) expr ::= ID|INDEXED|JOIN_KW LP STAR RP filter_over *\/\n-   -1,  \/* (193) term ::= CTIME_KW *\/\n-   -5,  \/* (194) expr ::= LP nexprlist COMMA expr RP *\/\n-   -3,  \/* (195) expr ::= expr AND expr *\/\n-   -3,  \/* (196) expr ::= expr OR expr *\/\n-   -3,  \/* (197) expr ::= expr LT|GT|GE|LE expr *\/\n-   -3,  \/* (198) expr ::= expr EQ|NE expr *\/\n-   -3,  \/* (199) expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr *\/\n-   -3,  \/* (200) expr ::= expr PLUS|MINUS expr *\/\n-   -3,  \/* (201) expr ::= expr STAR|SLASH|REM expr *\/\n-   -3,  \/* (202) expr ::= expr CONCAT expr *\/\n-   -2,  \/* (203) likeop ::= NOT LIKE_KW|MATCH *\/\n-   -3,  \/* (204) expr ::= expr likeop expr *\/\n-   -5,  \/* (205) expr ::= expr likeop expr ESCAPE expr *\/\n-   -2,  \/* (206) expr ::= expr ISNULL|NOTNULL *\/\n-   -3,  \/* (207) expr ::= expr NOT NULL *\/\n-   -3,  \/* (208) expr ::= expr IS expr *\/\n-   -4,  \/* (209) expr ::= expr IS NOT expr *\/\n-   -6,  \/* (210) expr ::= expr IS NOT DISTINCT FROM expr *\/\n-   -5,  \/* (211) expr ::= expr IS DISTINCT FROM expr *\/\n-   -2,  \/* (212) expr ::= NOT expr *\/\n-   -2,  \/* (213) expr ::= BITNOT expr *\/\n-   -2,  \/* (214) expr ::= PLUS|MINUS expr *\/\n-   -3,  \/* (215) expr ::= expr PTR expr *\/\n-   -1,  \/* (216) between_op ::= BETWEEN *\/\n-   -2,  \/* (217) between_op ::= NOT BETWEEN *\/\n-   -5,  \/* (218) expr ::= expr between_op expr AND expr *\/\n-   -1,  \/* (219) in_op ::= IN *\/\n-   -2,  \/* (220) in_op ::= NOT IN *\/\n-   -5,  \/* (221) expr ::= expr in_op LP exprlist RP *\/\n-   -3,  \/* (222) expr ::= LP select RP *\/\n-   -5,  \/* (223) expr ::= expr in_op LP select RP *\/\n-   -5,  \/* (224) expr ::= expr in_op nm dbnm paren_exprlist *\/\n-   -4,  \/* (225) expr ::= EXISTS LP select RP *\/\n-   -5,  \/* (226) expr ::= CASE case_operand case_exprlist case_else END *\/\n-   -5,  \/* (227) case_exprlist ::= case_exprlist WHEN expr THEN expr *\/\n-   -4,  \/* (228) case_exprlist ::= WHEN expr THEN expr *\/\n-   -2,  \/* (229) case_else ::= ELSE expr *\/\n-    0,  \/* (230) case_else ::= *\/\n-    0,  \/* (231) case_operand ::= *\/\n-    0,  \/* (232) exprlist ::= *\/\n-   -3,  \/* (233) nexprlist ::= nexprlist COMMA expr *\/\n-   -1,  \/* (234) nexprlist ::= expr *\/\n-    0,  \/* (235) paren_exprlist ::= *\/\n-   -3,  \/* (236) paren_exprlist ::= LP exprlist RP *\/\n-  -12,  \/* (237) cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt *\/\n-   -1,  \/* (238) uniqueflag ::= UNIQUE *\/\n-    0,  \/* (239) uniqueflag ::= *\/\n-    0,  \/* (240) eidlist_opt ::= *\/\n-   -3,  \/* (241) eidlist_opt ::= LP eidlist RP *\/\n-   -5,  \/* (242) eidlist ::= eidlist COMMA nm collate sortorder *\/\n-   -3,  \/* (243) eidlist ::= nm collate sortorder *\/\n-    0,  \/* (244) collate ::= *\/\n-   -2,  \/* (245) collate ::= COLLATE ID|STRING *\/\n-   -4,  \/* (246) cmd ::= DROP INDEX ifexists fullname *\/\n-   -2,  \/* (247) cmd ::= VACUUM vinto *\/\n-   -3,  \/* (248) cmd ::= VACUUM nm vinto *\/\n-   -2,  \/* (249) vinto ::= INTO expr *\/\n-    0,  \/* (250) vinto ::= *\/\n-   -3,  \/* (251) cmd ::= PRAGMA nm dbnm *\/\n-   -5,  \/* (252) cmd ::= PRAGMA nm dbnm EQ nmnum *\/\n-   -6,  \/* (253) cmd ::= PRAGMA nm dbnm LP nmnum RP *\/\n-   -5,  \/* (254) cmd ::= PRAGMA nm dbnm EQ minus_num *\/\n-   -6,  \/* (255) cmd ::= PRAGMA nm dbnm LP minus_num RP *\/\n-   -2,  \/* (256) plus_num ::= PLUS INTEGER|FLOAT *\/\n-   -2,  \/* (257) minus_num ::= MINUS INTEGER|FLOAT *\/\n-   -5,  \/* (258) cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END *\/\n-  -11,  \/* (259) trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause *\/\n-   -1,  \/* (260) trigger_time ::= BEFORE|AFTER *\/\n-   -2,  \/* (261) trigger_time ::= INSTEAD OF *\/\n-    0,  \/* (262) trigger_time ::= *\/\n-   -1,  \/* (263) trigger_event ::= DELETE|INSERT *\/\n-   -1,  \/* (264) trigger_event ::= UPDATE *\/\n-   -3,  \/* (265) trigger_event ::= UPDATE OF idlist *\/\n-    0,  \/* (266) when_clause ::= *\/\n-   -2,  \/* (267) when_clause ::= WHEN expr *\/\n-   -3,  \/* (268) trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI *\/\n-   -2,  \/* (269) trigger_cmd_list ::= trigger_cmd SEMI *\/\n-   -3,  \/* (270) trnm ::= nm DOT nm *\/\n-   -3,  \/* (271) tridxby ::= INDEXED BY nm *\/\n-   -2,  \/* (272) tridxby ::= NOT INDEXED *\/\n-   -9,  \/* (273) trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist from where_opt scanpt *\/\n-   -8,  \/* (274) trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt *\/\n-   -6,  \/* (275) trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt *\/\n-   -3,  \/* (276) trigger_cmd ::= scanpt select scanpt *\/\n-   -4,  \/* (277) expr ::= RAISE LP IGNORE RP *\/\n-   -6,  \/* (278) expr ::= RAISE LP raisetype COMMA nm RP *\/\n-   -1,  \/* (279) raisetype ::= ROLLBACK *\/\n-   -1,  \/* (280) raisetype ::= ABORT *\/\n-   -1,  \/* (281) raisetype ::= FAIL *\/\n-   -4,  \/* (282) cmd ::= DROP TRIGGER ifexists fullname *\/\n-   -6,  \/* (283) cmd ::= ATTACH database_kw_opt expr AS expr key_opt *\/\n-   -3,  \/* (284) cmd ::= DETACH database_kw_opt expr *\/\n-    0,  \/* (285) key_opt ::= *\/\n-   -2,  \/* (286) key_opt ::= KEY expr *\/\n-   -1,  \/* (287) cmd ::= REINDEX *\/\n-   -3,  \/* (288) cmd ::= REINDEX nm dbnm *\/\n-   -1,  \/* (289) cmd ::= ANALYZE *\/\n-   -3,  \/* (290) cmd ::= ANALYZE nm dbnm *\/\n-   -6,  \/* (291) cmd ::= ALTER TABLE fullname RENAME TO nm *\/\n-   -7,  \/* (292) cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist *\/\n-   -6,  \/* (293) cmd ::= ALTER TABLE fullname DROP kwcolumn_opt nm *\/\n-   -1,  \/* (294) add_column_fullname ::= fullname *\/\n-   -8,  \/* (295) cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm *\/\n-   -1,  \/* (296) cmd ::= create_vtab *\/\n-   -4,  \/* (297) cmd ::= create_vtab LP vtabarglist RP *\/\n-   -8,  \/* (298) create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm *\/\n-    0,  \/* (299) vtabarg ::= *\/\n-   -1,  \/* (300) vtabargtoken ::= ANY *\/\n-   -3,  \/* (301) vtabargtoken ::= lp anylist RP *\/\n-   -1,  \/* (302) lp ::= LP *\/\n-   -2,  \/* (303) with ::= WITH wqlist *\/\n-   -3,  \/* (304) with ::= WITH RECURSIVE wqlist *\/\n-   -1,  \/* (305) wqas ::= AS *\/\n-   -2,  \/* (306) wqas ::= AS MATERIALIZED *\/\n-   -3,  \/* (307) wqas ::= AS NOT MATERIALIZED *\/\n-   -6,  \/* (308) wqitem ::= nm eidlist_opt wqas LP select RP *\/\n-   -1,  \/* (309) wqlist ::= wqitem *\/\n-   -3,  \/* (310) wqlist ::= wqlist COMMA wqitem *\/\n-   -3,  \/* (311) windowdefn_list ::= windowdefn_list COMMA windowdefn *\/\n-   -5,  \/* (312) windowdefn ::= nm AS LP window RP *\/\n-   -5,  \/* (313) window ::= PARTITION BY nexprlist orderby_opt frame_opt *\/\n-   -6,  \/* (314) window ::= nm PARTITION BY nexprlist orderby_opt frame_opt *\/\n-   -4,  \/* (315) window ::= ORDER BY sortlist frame_opt *\/\n-   -5,  \/* (316) window ::= nm ORDER BY sortlist frame_opt *\/\n-   -2,  \/* (317) window ::= nm frame_opt *\/\n-    0,  \/* (318) frame_opt ::= *\/\n-   -3,  \/* (319) frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt *\/\n-   -6,  \/* (320) frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt *\/\n-   -1,  \/* (321) range_or_rows ::= RANGE|ROWS|GROUPS *\/\n-   -1,  \/* (322) frame_bound_s ::= frame_bound *\/\n-   -2,  \/* (323) frame_bound_s ::= UNBOUNDED PRECEDING *\/\n-   -1,  \/* (324) frame_bound_e ::= frame_bound *\/\n-   -2,  \/* (325) frame_bound_e ::= UNBOUNDED FOLLOWING *\/\n-   -2,  \/* (326) frame_bound ::= expr PRECEDING|FOLLOWING *\/\n-   -2,  \/* (327) frame_bound ::= CURRENT ROW *\/\n-    0,  \/* (328) frame_exclude_opt ::= *\/\n-   -2,  \/* (329) frame_exclude_opt ::= EXCLUDE frame_exclude *\/\n-   -2,  \/* (330) frame_exclude ::= NO OTHERS *\/\n-   -2,  \/* (331) frame_exclude ::= CURRENT ROW *\/\n-   -1,  \/* (332) frame_exclude ::= GROUP|TIES *\/\n-   -2,  \/* (333) window_clause ::= WINDOW windowdefn_list *\/\n-   -2,  \/* (334) filter_over ::= filter_clause over_clause *\/\n-   -1,  \/* (335) filter_over ::= over_clause *\/\n-   -1,  \/* (336) filter_over ::= filter_clause *\/\n-   -4,  \/* (337) over_clause ::= OVER LP window RP *\/\n-   -2,  \/* (338) over_clause ::= OVER nm *\/\n-   -5,  \/* (339) filter_clause ::= FILTER LP WHERE expr RP *\/\n-   -1,  \/* (340) input ::= cmdlist *\/\n-   -2,  \/* (341) cmdlist ::= cmdlist ecmd *\/\n-   -1,  \/* (342) cmdlist ::= ecmd *\/\n-   -1,  \/* (343) ecmd ::= SEMI *\/\n-   -2,  \/* (344) ecmd ::= cmdx SEMI *\/\n-   -3,  \/* (345) ecmd ::= explain cmdx SEMI *\/\n-    0,  \/* (346) trans_opt ::= *\/\n-   -1,  \/* (347) trans_opt ::= TRANSACTION *\/\n-   -2,  \/* (348) trans_opt ::= TRANSACTION nm *\/\n-   -1,  \/* (349) savepoint_opt ::= SAVEPOINT *\/\n-    0,  \/* (350) savepoint_opt ::= *\/\n-   -2,  \/* (351) cmd ::= create_table create_table_args *\/\n-   -1,  \/* (352) table_option_set ::= table_option *\/\n-   -4,  \/* (353) columnlist ::= columnlist COMMA columnname carglist *\/\n-   -2,  \/* (354) columnlist ::= columnname carglist *\/\n-   -1,  \/* (355) nm ::= ID|INDEXED|JOIN_KW *\/\n-   -1,  \/* (356) nm ::= STRING *\/\n-   -1,  \/* (357) typetoken ::= typename *\/\n-   -1,  \/* (358) typename ::= ID|STRING *\/\n-   -1,  \/* (359) signed ::= plus_num *\/\n-   -1,  \/* (360) signed ::= minus_num *\/\n-   -2,  \/* (361) carglist ::= carglist ccons *\/\n-    0,  \/* (362) carglist ::= *\/\n-   -2,  \/* (363) ccons ::= NULL onconf *\/\n-   -4,  \/* (364) ccons ::= GENERATED ALWAYS AS generated *\/\n-   -2,  \/* (365) ccons ::= AS generated *\/\n-   -2,  \/* (366) conslist_opt ::= COMMA conslist *\/\n-   -3,  \/* (367) conslist ::= conslist tconscomma tcons *\/\n-   -1,  \/* (368) conslist ::= tcons *\/\n-    0,  \/* (369) tconscomma ::= *\/\n-   -1,  \/* (370) defer_subclause_opt ::= defer_subclause *\/\n-   -1,  \/* (371) resolvetype ::= raisetype *\/\n-   -1,  \/* (372) selectnowith ::= oneselect *\/\n-   -1,  \/* (373) oneselect ::= values *\/\n-   -2,  \/* (374) sclp ::= selcollist COMMA *\/\n-   -1,  \/* (375) as ::= ID|STRING *\/\n-   -1,  \/* (376) indexed_opt ::= indexed_by *\/\n-    0,  \/* (377) returning ::= *\/\n-   -1,  \/* (378) expr ::= term *\/\n-   -1,  \/* (379) likeop ::= LIKE_KW|MATCH *\/\n-   -1,  \/* (380) case_operand ::= expr *\/\n-   -1,  \/* (381) exprlist ::= nexprlist *\/\n-   -1,  \/* (382) nmnum ::= plus_num *\/\n-   -1,  \/* (383) nmnum ::= nm *\/\n-   -1,  \/* (384) nmnum ::= ON *\/\n-   -1,  \/* (385) nmnum ::= DELETE *\/\n-   -1,  \/* (386) nmnum ::= DEFAULT *\/\n-   -1,  \/* (387) plus_num ::= INTEGER|FLOAT *\/\n-    0,  \/* (388) foreach_clause ::= *\/\n-   -3,  \/* (389) foreach_clause ::= FOR EACH ROW *\/\n-   -1,  \/* (390) trnm ::= nm *\/\n-    0,  \/* (391) tridxby ::= *\/\n-   -1,  \/* (392) database_kw_opt ::= DATABASE *\/\n-    0,  \/* (393) database_kw_opt ::= *\/\n-    0,  \/* (394) kwcolumn_opt ::= *\/\n-   -1,  \/* (395) kwcolumn_opt ::= COLUMNKW *\/\n-   -1,  \/* (396) vtabarglist ::= vtabarg *\/\n-   -3,  \/* (397) vtabarglist ::= vtabarglist COMMA vtabarg *\/\n-   -2,  \/* (398) vtabarg ::= vtabarg vtabargtoken *\/\n-    0,  \/* (399) anylist ::= *\/\n-   -4,  \/* (400) anylist ::= anylist LP anylist RP *\/\n-   -2,  \/* (401) anylist ::= anylist ANY *\/\n-    0,  \/* (402) with ::= *\/\n-   -1,  \/* (403) windowdefn_list ::= windowdefn *\/\n-   -1,  \/* (404) window ::= frame_opt *\/\n+   -1,  \/* (95) oneselect ::= mvalues *\/\n+   -5,  \/* (96) mvalues ::= values COMMA LP nexprlist RP *\/\n+   -5,  \/* (97) mvalues ::= mvalues COMMA LP nexprlist RP *\/\n+   -1,  \/* (98) distinct ::= DISTINCT *\/\n+   -1,  \/* (99) distinct ::= ALL *\/\n+    0,  \/* (100) distinct ::= *\/\n+    0,  \/* (101) sclp ::= *\/\n+   -5,  \/* (102) selcollist ::= sclp scanpt expr scanpt as *\/\n+   -3,  \/* (103) selcollist ::= sclp scanpt STAR *\/\n+   -5,  \/* (104) selcollist ::= sclp scanpt nm DOT STAR *\/\n+   -2,  \/* (105) as ::= AS nm *\/\n+    0,  \/* (106) as ::= *\/\n+    0,  \/* (107) from ::= *\/\n+   -2,  \/* (108) from ::= FROM seltablist *\/\n+   -2,  \/* (109) stl_prefix ::= seltablist joinop *\/\n+    0,  \/* (110) stl_prefix ::= *\/\n+   -5,  \/* (111) seltablist ::= stl_prefix nm dbnm as on_using *\/\n+   -6,  \/* (112) seltablist ::= stl_prefix nm dbnm as indexed_by on_using *\/\n+   -8,  \/* (113) seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_using *\/\n+   -6,  \/* (114) seltablist ::= stl_prefix LP select RP as on_using *\/\n+   -6,  \/* (115) seltablist ::= stl_prefix LP seltablist RP as on_using *\/\n+    0,  \/* (116) dbnm ::= *\/\n+   -2,  \/* (117) dbnm ::= DOT nm *\/\n+   -1,  \/* (118) fullname ::= nm *\/\n+   -3,  \/* (119) fullname ::= nm DOT nm *\/\n+   -1,  \/* (120) xfullname ::= nm *\/\n+   -3,  \/* (121) xfullname ::= nm DOT nm *\/\n+   -5,  \/* (122) xfullname ::= nm DOT nm AS nm *\/\n+   -3,  \/* (123) xfullname ::= nm AS nm *\/\n+   -1,  \/* (124) joinop ::= COMMA|JOIN *\/\n+   -2,  \/* (125) joinop ::= JOIN_KW JOIN *\/\n+   -3,  \/* (126) joinop ::= JOIN_KW nm JOIN *\/\n+   -4,  \/* (127) joinop ::= JOIN_KW nm nm JOIN *\/\n+   -2,  \/* (128) on_using ::= ON expr *\/\n+   -4,  \/* (129) on_using ::= USING LP idlist RP *\/\n+    0,  \/* (130) on_using ::= *\/\n+    0,  \/* (131) indexed_opt ::= *\/\n+   -3,  \/* (132) indexed_by ::= INDEXED BY nm *\/\n+   -2,  \/* (133) indexed_by ::= NOT INDEXED *\/\n+    0,  \/* (134) orderby_opt ::= *\/\n+   -3,  \/* (135) orderby_opt ::= ORDER BY sortlist *\/\n+   -5,  \/* (136) sortlist ::= sortlist COMMA expr sortorder nulls *\/\n+   -3,  \/* (137) sortlist ::= expr sortorder nulls *\/\n+   -1,  \/* (138) sortorder ::= ASC *\/\n+   -1,  \/* (139) sortorder ::= DESC *\/\n+    0,  \/* (140) sortorder ::= *\/\n+   -2,  \/* (141) nulls ::= NULLS FIRST *\/\n+   -2,  \/* (142) nulls ::= NULLS LAST *\/\n+    0,  \/* (143) nulls ::= *\/\n+    0,  \/* (144) groupby_opt ::= *\/\n+   -3,  \/* (145) groupby_opt ::= GROUP BY nexprlist *\/\n+    0,  \/* (146) having_opt ::= *\/\n+   -2,  \/* (147) having_opt ::= HAVING expr *\/\n+    0,  \/* (148) limit_opt ::= *\/\n+   -2,  \/* (149) limit_opt ::= LIMIT expr *\/\n+   -4,  \/* (150) limit_opt ::= LIMIT expr OFFSET expr *\/\n+   -4,  \/* (151) limit_opt ::= LIMIT expr COMMA expr *\/\n+   -6,  \/* (152) cmd ::= with DELETE FROM xfullname indexed_opt where_opt_ret *\/\n+    0,  \/* (153) where_opt ::= *\/\n+   -2,  \/* (154) where_opt ::= WHERE expr *\/\n+    0,  \/* (155) where_opt_ret ::= *\/\n+   -2,  \/* (156) where_opt_ret ::= WHERE expr *\/\n+   -2,  \/* (157) where_opt_ret ::= RETURNING selcollist *\/\n+   -4,  \/* (158) where_opt_ret ::= WHERE expr RETURNING selcollist *\/\n+   -9,  \/* (159) cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist from where_opt_ret *\/\n+   -5,  \/* (160) setlist ::= setlist COMMA nm EQ expr *\/\n+   -7,  \/* (161) setlist ::= setlist COMMA LP idlist RP EQ expr *\/\n+   -3,  \/* (162) setlist ::= nm EQ expr *\/\n+   -5,  \/* (163) setlist ::= LP idlist RP EQ expr *\/\n+   -7,  \/* (164) cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert *\/\n+   -8,  \/* (165) cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES returning *\/\n+    0,  \/* (166) upsert ::= *\/\n+   -2,  \/* (167) upsert ::= RETURNING selcollist *\/\n+  -12,  \/* (168) upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt upsert *\/\n+   -9,  \/* (169) upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING upsert *\/\n+   -5,  \/* (170) upsert ::= ON CONFLICT DO NOTHING returning *\/\n+   -8,  \/* (171) upsert ::= ON CONFLICT DO UPDATE SET setlist where_opt returning *\/\n+   -2,  \/* (172) returning ::= RETURNING selcollist *\/\n+   -2,  \/* (173) insert_cmd ::= INSERT orconf *\/\n+   -1,  \/* (174) insert_cmd ::= REPLACE *\/\n+    0,  \/* (175) idlist_opt ::= *\/\n+   -3,  \/* (176) idlist_opt ::= LP idlist RP *\/\n+   -3,  \/* (177) idlist ::= idlist COMMA nm *\/\n+   -1,  \/* (178) idlist ::= nm *\/\n+   -3,  \/* (179) expr ::= LP expr RP *\/\n+   -1,  \/* (180) expr ::= ID|INDEXED|JOIN_KW *\/\n+   -3,  \/* (181) expr ::= nm DOT nm *\/\n+   -5,  \/* (182) expr ::= nm DOT nm DOT nm *\/\n+   -1,  \/* (183) term ::= NULL|FLOAT|BLOB *\/\n+   -1,  \/* (184) term ::= STRING *\/\n+   -1,  \/* (185) term ::= INTEGER *\/\n+   -1,  \/* (186) expr ::= VARIABLE *\/\n+   -3,  \/* (187) expr ::= expr COLLATE ID|STRING *\/\n+   -6,  \/* (188) expr ::= CAST LP expr AS typetoken RP *\/\n+   -5,  \/* (189) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP *\/\n+   -8,  \/* (190) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP *\/\n+   -4,  \/* (191) expr ::= ID|INDEXED|JOIN_KW LP STAR RP *\/\n+   -6,  \/* (192) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP filter_over *\/\n+   -9,  \/* (193) expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP filter_over *\/\n+   -5,  \/* (194) expr ::= ID|INDEXED|JOIN_KW LP STAR RP filter_over *\/\n+   -1,  \/* (195) term ::= CTIME_KW *\/\n+   -5,  \/* (196) expr ::= LP nexprlist COMMA expr RP *\/\n+   -3,  \/* (197) expr ::= expr AND expr *\/\n+   -3,  \/* (198) expr ::= expr OR expr *\/\n+   -3,  \/* (199) expr ::= expr LT|GT|GE|LE expr *\/\n+   -3,  \/* (200) expr ::= expr EQ|NE expr *\/\n+   -3,  \/* (201) expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr *\/\n+   -3,  \/* (202) expr ::= expr PLUS|MINUS expr *\/\n+   -3,  \/* (203) expr ::= expr STAR|SLASH|REM expr *\/\n+   -3,  \/* (204) expr ::= expr CONCAT expr *\/\n+   -2,  \/* (205) likeop ::= NOT LIKE_KW|MATCH *\/\n+   -3,  \/* (206) expr ::= expr likeop expr *\/\n+   -5,  \/* (207) expr ::= expr likeop expr ESCAPE expr *\/\n+   -2,  \/* (208) expr ::= expr ISNULL|NOTNULL *\/\n+   -3,  \/* (209) expr ::= expr NOT NULL *\/\n+   -3,  \/* (210) expr ::= expr IS expr *\/\n+   -4,  \/* (211) expr ::= expr IS NOT expr *\/\n+   -6,  \/* (212) expr ::= expr IS NOT DISTINCT FROM expr *\/\n+   -5,  \/* (213) expr ::= expr IS DISTINCT FROM expr *\/\n+   -2,  \/* (214) expr ::= NOT expr *\/\n+   -2,  \/* (215) expr ::= BITNOT expr *\/\n+   -2,  \/* (216) expr ::= PLUS|MINUS expr *\/\n+   -3,  \/* (217) expr ::= expr PTR expr *\/\n+   -1,  \/* (218) between_op ::= BETWEEN *\/\n+   -2,  \/* (219) between_op ::= NOT BETWEEN *\/\n+   -5,  \/* (220) expr ::= expr between_op expr AND expr *\/\n+   -1,  \/* (221) in_op ::= IN *\/\n+   -2,  \/* (222) in_op ::= NOT IN *\/\n+   -5,  \/* (223) expr ::= expr in_op LP exprlist RP *\/\n+   -3,  \/* (224) expr ::= LP select RP *\/\n+   -5,  \/* (225) expr ::= expr in_op LP select RP *\/\n+   -5,  \/* (226) expr ::= expr in_op nm dbnm paren_exprlist *\/\n+   -4,  \/* (227) expr ::= EXISTS LP select RP *\/\n+   -5,  \/* (228) expr ::= CASE case_operand case_exprlist case_else END *\/\n+   -5,  \/* (229) case_exprlist ::= case_exprlist WHEN expr THEN expr *\/\n+   -4,  \/* (230) case_exprlist ::= WHEN expr THEN expr *\/\n+   -2,  \/* (231) case_else ::= ELSE expr *\/\n+    0,  \/* (232) case_else ::= *\/\n+    0,  \/* (233) case_operand ::= *\/\n+    0,  \/* (234) exprlist ::= *\/\n+   -3,  \/* (235) nexprlist ::= nexprlist COMMA expr *\/\n+   -1,  \/* (236) nexprlist ::= expr *\/\n+    0,  \/* (237) paren_exprlist ::= *\/\n+   -3,  \/* (238) paren_exprlist ::= LP exprlist RP *\/\n+  -12,  \/* (239) cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt *\/\n+   -1,  \/* (240) uniqueflag ::= UNIQUE *\/\n+    0,  \/* (241) uniqueflag ::= *\/\n+    0,  \/* (242) eidlist_opt ::= *\/\n+   -3,  \/* (243) eidlist_opt ::= LP eidlist RP *\/\n+   -5,  \/* (244) eidlist ::= eidlist COMMA nm collate sortorder *\/\n+   -3,  \/* (245) eidlist ::= nm collate sortorder *\/\n+    0,  \/* (246) collate ::= *\/\n+   -2,  \/* (247) collate ::= COLLATE ID|STRING *\/\n+   -4,  \/* (248) cmd ::= DROP INDEX ifexists fullname *\/\n+   -2,  \/* (249) cmd ::= VACUUM vinto *\/\n+   -3,  \/* (250) cmd ::= VACUUM nm vinto *\/\n+   -2,  \/* (251) vinto ::= INTO expr *\/\n+    0,  \/* (252) vinto ::= *\/\n+   -3,  \/* (253) cmd ::= PRAGMA nm dbnm *\/\n+   -5,  \/* (254) cmd ::= PRAGMA nm dbnm EQ nmnum *\/\n+   -6,  \/* (255) cmd ::= PRAGMA nm dbnm LP nmnum RP *\/\n+   -5,  \/* (256) cmd ::= PRAGMA nm dbnm EQ minus_num *\/\n+   -6,  \/* (257) cmd ::= PRAGMA nm dbnm LP minus_num RP *\/\n+   -2,  \/* (258) plus_num ::= PLUS INTEGER|FLOAT *\/\n+   -2,  \/* (259) minus_num ::= MINUS INTEGER|FLOAT *\/\n+   -5,  \/* (260) cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END *\/\n+  -11,  \/* (261) trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause *\/\n+   -1,  \/* (262) trigger_time ::= BEFORE|AFTER *\/\n+   -2,  \/* (263) trigger_time ::= INSTEAD OF *\/\n+    0,  \/* (264) trigger_time ::= *\/\n+   -1,  \/* (265) trigger_event ::= DELETE|INSERT *\/\n+   -1,  \/* (266) trigger_event ::= UPDATE *\/\n+   -3,  \/* (267) trigger_event ::= UPDATE OF idlist *\/\n+    0,  \/* (268) when_clause ::= *\/\n+   -2,  \/* (269) when_clause ::= WHEN expr *\/\n+   -3,  \/* (270) trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI *\/\n+   -2,  \/* (271) trigger_cmd_list ::= trigger_cmd SEMI *\/\n+   -3,  \/* (272) trnm ::= nm DOT nm *\/\n+   -3,  \/* (273) tridxby ::= INDEXED BY nm *\/\n+   -2,  \/* (274) tridxby ::= NOT INDEXED *\/\n+   -9,  \/* (275) trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist from where_opt scanpt *\/\n+   -8,  \/* (276) trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt *\/\n+   -6,  \/* (277) trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt *\/\n+   -3,  \/* (278) trigger_cmd ::= scanpt select scanpt *\/\n+   -4,  \/* (279) expr ::= RAISE LP IGNORE RP *\/\n+   -6,  \/* (280) expr ::= RAISE LP raisetype COMMA expr RP *\/\n+   -1,  \/* (281) raisetype ::= ROLLBACK *\/\n+   -1,  \/* (282) raisetype ::= ABORT *\/\n+   -1,  \/* (283) raisetype ::= FAIL *\/\n+   -4,  \/* (284) cmd ::= DROP TRIGGER ifexists fullname *\/\n+   -6,  \/* (285) cmd ::= ATTACH database_kw_opt expr AS expr key_opt *\/\n+   -3,  \/* (286) cmd ::= DETACH database_kw_opt expr *\/\n+    0,  \/* (287) key_opt ::= *\/\n+   -2,  \/* (288) key_opt ::= KEY expr *\/\n+   -1,  \/* (289) cmd ::= REINDEX *\/\n+   -3,  \/* (290) cmd ::= REINDEX nm dbnm *\/\n+   -1,  \/* (291) cmd ::= ANALYZE *\/\n+   -3,  \/* (292) cmd ::= ANALYZE nm dbnm *\/\n+   -6,  \/* (293) cmd ::= ALTER TABLE fullname RENAME TO nm *\/\n+   -7,  \/* (294) cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist *\/\n+   -6,  \/* (295) cmd ::= ALTER TABLE fullname DROP kwcolumn_opt nm *\/\n+   -1,  \/* (296) add_column_fullname ::= fullname *\/\n+   -8,  \/* (297) cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm *\/\n+   -1,  \/* (298) cmd ::= create_vtab *\/\n+   -4,  \/* (299) cmd ::= create_vtab LP vtabarglist RP *\/\n+   -8,  \/* (300) create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm *\/\n+    0,  \/* (301) vtabarg ::= *\/\n+   -1,  \/* (302) vtabargtoken ::= ANY *\/\n+   -3,  \/* (303) vtabargtoken ::= lp anylist RP *\/\n+   -1,  \/* (304) lp ::= LP *\/\n+   -2,  \/* (305) with ::= WITH wqlist *\/\n+   -3,  \/* (306) with ::= WITH RECURSIVE wqlist *\/\n+   -1,  \/* (307) wqas ::= AS *\/\n+   -2,  \/* (308) wqas ::= AS MATERIALIZED *\/\n+   -3,  \/* (309) wqas ::= AS NOT MATERIALIZED *\/\n+   -6,  \/* (310) wqitem ::= withnm eidlist_opt wqas LP select RP *\/\n+   -1,  \/* (311) withnm ::= nm *\/\n+   -1,  \/* (312) wqlist ::= wqitem *\/\n+   -3,  \/* (313) wqlist ::= wqlist COMMA wqitem *\/\n+   -3,  \/* (314) windowdefn_list ::= windowdefn_list COMMA windowdefn *\/\n+   -5,  \/* (315) windowdefn ::= nm AS LP window RP *\/\n+   -5,  \/* (316) window ::= PARTITION BY nexprlist orderby_opt frame_opt *\/\n+   -6,  \/* (317) window ::= nm PARTITION BY nexprlist orderby_opt frame_opt *\/\n+   -4,  \/* (318) window ::= ORDER BY sortlist frame_opt *\/\n+   -5,  \/* (319) window ::= nm ORDER BY sortlist frame_opt *\/\n+   -2,  \/* (320) window ::= nm frame_opt *\/\n+    0,  \/* (321) frame_opt ::= *\/\n+   -3,  \/* (322) frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt *\/\n+   -6,  \/* (323) frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt *\/\n+   -1,  \/* (324) range_or_rows ::= RANGE|ROWS|GROUPS *\/\n+   -1,  \/* (325) frame_bound_s ::= frame_bound *\/\n+   -2,  \/* (326) frame_bound_s ::= UNBOUNDED PRECEDING *\/\n+   -1,  \/* (327) frame_bound_e ::= frame_bound *\/\n+   -2,  \/* (328) frame_bound_e ::= UNBOUNDED FOLLOWING *\/\n+   -2,  \/* (329) frame_bound ::= expr PRECEDING|FOLLOWING *\/\n+   -2,  \/* (330) frame_bound ::= CURRENT ROW *\/\n+    0,  \/* (331) frame_exclude_opt ::= *\/\n+   -2,  \/* (332) frame_exclude_opt ::= EXCLUDE frame_exclude *\/\n+   -2,  \/* (333) frame_exclude ::= NO OTHERS *\/\n+   -2,  \/* (334) frame_exclude ::= CURRENT ROW *\/\n+   -1,  \/* (335) frame_exclude ::= GROUP|TIES *\/\n+   -2,  \/* (336) window_clause ::= WINDOW windowdefn_list *\/\n+   -2,  \/* (337) filter_over ::= filter_clause over_clause *\/\n+   -1,  \/* (338) filter_over ::= over_clause *\/\n+   -1,  \/* (339) filter_over ::= filter_clause *\/\n+   -4,  \/* (340) over_clause ::= OVER LP window RP *\/\n+   -2,  \/* (341) over_clause ::= OVER nm *\/\n+   -5,  \/* (342) filter_clause ::= FILTER LP WHERE expr RP *\/\n+   -1,  \/* (343) term ::= QNUMBER *\/\n+   -1,  \/* (344) input ::= cmdlist *\/\n+   -2,  \/* (345) cmdlist ::= cmdlist ecmd *\/\n+   -1,  \/* (346) cmdlist ::= ecmd *\/\n+   -1,  \/* (347) ecmd ::= SEMI *\/\n+   -2,  \/* (348) ecmd ::= cmdx SEMI *\/\n+   -3,  \/* (349) ecmd ::= explain cmdx SEMI *\/\n+    0,  \/* (350) trans_opt ::= *\/\n+   -1,  \/* (351) trans_opt ::= TRANSACTION *\/\n+   -2,  \/* (352) trans_opt ::= TRANSACTION nm *\/\n+   -1,  \/* (353) savepoint_opt ::= SAVEPOINT *\/\n+    0,  \/* (354) savepoint_opt ::= *\/\n+   -2,  \/* (355) cmd ::= create_table create_table_args *\/\n+   -1,  \/* (356) table_option_set ::= table_option *\/\n+   -4,  \/* (357) columnlist ::= columnlist COMMA columnname carglist *\/\n+   -2,  \/* (358) columnlist ::= columnname carglist *\/\n+   -1,  \/* (359) nm ::= ID|INDEXED|JOIN_KW *\/\n+   -1,  \/* (360) nm ::= STRING *\/\n+   -1,  \/* (361) typetoken ::= typename *\/\n+   -1,  \/* (362) typename ::= ID|STRING *\/\n+   -1,  \/* (363) signed ::= plus_num *\/\n+   -1,  \/* (364) signed ::= minus_num *\/\n+   -2,  \/* (365) carglist ::= carglist ccons *\/\n+    0,  \/* (366) carglist ::= *\/\n+   -2,  \/* (367) ccons ::= NULL onconf *\/\n+   -4,  \/* (368) ccons ::= GENERATED ALWAYS AS generated *\/\n+   -2,  \/* (369) ccons ::= AS generated *\/\n+   -2,  \/* (370) conslist_opt ::= COMMA conslist *\/\n+   -3,  \/* (371) conslist ::= conslist tconscomma tcons *\/\n+   -1,  \/* (372) conslist ::= tcons *\/\n+    0,  \/* (373) tconscomma ::= *\/\n+   -1,  \/* (374) defer_subclause_opt ::= defer_subclause *\/\n+   -1,  \/* (375) resolvetype ::= raisetype *\/\n+   -1,  \/* (376) selectnowith ::= oneselect *\/\n+   -1,  \/* (377) oneselect ::= values *\/\n+   -2,  \/* (378) sclp ::= selcollist COMMA *\/\n+   -1,  \/* (379) as ::= ID|STRING *\/\n+   -1,  \/* (380) indexed_opt ::= indexed_by *\/\n+    0,  \/* (381) returning ::= *\/\n+   -1,  \/* (382) expr ::= term *\/\n+   -1,  \/* (383) likeop ::= LIKE_KW|MATCH *\/\n+   -1,  \/* (384) case_operand ::= expr *\/\n+   -1,  \/* (385) exprlist ::= nexprlist *\/\n+   -1,  \/* (386) nmnum ::= plus_num *\/\n+   -1,  \/* (387) nmnum ::= nm *\/\n+   -1,  \/* (388) nmnum ::= ON *\/\n+   -1,  \/* (389) nmnum ::= DELETE *\/\n+   -1,  \/* (390) nmnum ::= DEFAULT *\/\n+   -1,  \/* (391) plus_num ::= INTEGER|FLOAT *\/\n+    0,  \/* (392) foreach_clause ::= *\/\n+   -3,  \/* (393) foreach_clause ::= FOR EACH ROW *\/\n+   -1,  \/* (394) trnm ::= nm *\/\n+    0,  \/* (395) tridxby ::= *\/\n+   -1,  \/* (396) database_kw_opt ::= DATABASE *\/\n+    0,  \/* (397) database_kw_opt ::= *\/\n+    0,  \/* (398) kwcolumn_opt ::= *\/\n+   -1,  \/* (399) kwcolumn_opt ::= COLUMNKW *\/\n+   -1,  \/* (400) vtabarglist ::= vtabarg *\/\n+   -3,  \/* (401) vtabarglist ::= vtabarglist COMMA vtabarg *\/\n+   -2,  \/* (402) vtabarg ::= vtabarg vtabargtoken *\/\n+    0,  \/* (403) anylist ::= *\/\n+   -4,  \/* (404) anylist ::= anylist LP anylist RP *\/\n+   -2,  \/* (405) anylist ::= anylist ANY *\/\n+    0,  \/* (406) with ::= *\/\n+   -1,  \/* (407) windowdefn_list ::= windowdefn *\/\n+   -1,  \/* (408) window ::= frame_opt *\/\n@@ -174727,1 +177883,1 @@\n-{sqlite3BeginTransaction(pParse, yymsp[-1].minor.yy394);}\n+{sqlite3BeginTransaction(pParse, yymsp[-1].minor.yy502);}\n@@ -174730,1 +177886,1 @@\n-{yymsp[1].minor.yy394 = TK_DEFERRED;}\n+{yymsp[1].minor.yy502 = TK_DEFERRED;}\n@@ -174735,2 +177891,2 @@\n-      case 321: \/* range_or_rows ::= RANGE|ROWS|GROUPS *\/ yytestcase(yyruleno==321);\n-{yymsp[0].minor.yy394 = yymsp[0].major; \/*A-overwrites-X*\/}\n+      case 324: \/* range_or_rows ::= RANGE|ROWS|GROUPS *\/ yytestcase(yyruleno==324);\n+{yymsp[0].minor.yy502 = yymsp[0].major; \/*A-overwrites-X*\/}\n@@ -174759,1 +177915,1 @@\n-   sqlite3StartTable(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,yymsp[-4].minor.yy394,0,0,yymsp[-2].minor.yy394);\n+   sqlite3StartTable(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,yymsp[-4].minor.yy502,0,0,yymsp[-2].minor.yy502);\n@@ -174771,3 +177927,3 @@\n-      case 98: \/* distinct ::= *\/ yytestcase(yyruleno==98);\n-      case 244: \/* collate ::= *\/ yytestcase(yyruleno==244);\n-{yymsp[1].minor.yy394 = 0;}\n+      case 100: \/* distinct ::= *\/ yytestcase(yyruleno==100);\n+      case 246: \/* collate ::= *\/ yytestcase(yyruleno==246);\n+{yymsp[1].minor.yy502 = 0;}\n@@ -174776,1 +177932,1 @@\n-{yymsp[-2].minor.yy394 = 1;}\n+{yymsp[-2].minor.yy502 = 1;}\n@@ -174779,1 +177935,1 @@\n-{yymsp[0].minor.yy394 = pParse->db->init.busy==0;}\n+{yymsp[0].minor.yy502 = pParse->db->init.busy==0;}\n@@ -174783,1 +177939,1 @@\n-  sqlite3EndTable(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,yymsp[0].minor.yy285,0);\n+  sqlite3EndTable(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,yymsp[0].minor.yy9,0);\n@@ -174788,2 +177944,2 @@\n-  sqlite3EndTable(pParse,0,0,0,yymsp[0].minor.yy47);\n-  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy47);\n+  sqlite3EndTable(pParse,0,0,0,yymsp[0].minor.yy637);\n+  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy637);\n@@ -174793,1 +177949,1 @@\n-{yymsp[1].minor.yy285 = 0;}\n+{yymsp[1].minor.yy9 = 0;}\n@@ -174796,2 +177952,2 @@\n-{yylhsminor.yy285 = yymsp[-2].minor.yy285|yymsp[0].minor.yy285;}\n-  yymsp[-2].minor.yy285 = yylhsminor.yy285;\n+{yylhsminor.yy9 = yymsp[-2].minor.yy9|yymsp[0].minor.yy9;}\n+  yymsp[-2].minor.yy9 = yylhsminor.yy9;\n@@ -174802,1 +177958,1 @@\n-    yymsp[-1].minor.yy285 = TF_WithoutRowid | TF_NoVisibleRowid;\n+    yymsp[-1].minor.yy9 = TF_WithoutRowid | TF_NoVisibleRowid;\n@@ -174804,1 +177960,1 @@\n-    yymsp[-1].minor.yy285 = 0;\n+    yymsp[-1].minor.yy9 = 0;\n@@ -174812,1 +177968,1 @@\n-    yylhsminor.yy285 = TF_Strict;\n+    yylhsminor.yy9 = TF_Strict;\n@@ -174814,1 +177970,1 @@\n-    yylhsminor.yy285 = 0;\n+    yylhsminor.yy9 = 0;\n@@ -174818,1 +177974,1 @@\n-  yymsp[0].minor.yy285 = yylhsminor.yy285;\n+  yymsp[0].minor.yy9 = yylhsminor.yy9;\n@@ -174825,1 +177981,1 @@\n-      case 104: \/* as ::= *\/ yytestcase(yyruleno==104);\n+      case 106: \/* as ::= *\/ yytestcase(yyruleno==106);\n@@ -174844,1 +178000,1 @@\n-  yymsp[1].minor.yy522 = yyLookaheadToken.z;\n+  yymsp[1].minor.yy342 = yyLookaheadToken.z;\n@@ -174858,1 +178014,1 @@\n-{sqlite3AddDefaultValue(pParse,yymsp[0].minor.yy528,yymsp[-1].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);}\n+{sqlite3AddDefaultValue(pParse,yymsp[0].minor.yy590,yymsp[-1].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);}\n@@ -174861,1 +178017,1 @@\n-{sqlite3AddDefaultValue(pParse,yymsp[-1].minor.yy528,yymsp[-2].minor.yy0.z+1,yymsp[0].minor.yy0.z);}\n+{sqlite3AddDefaultValue(pParse,yymsp[-1].minor.yy590,yymsp[-2].minor.yy0.z+1,yymsp[0].minor.yy0.z);}\n@@ -174864,1 +178020,1 @@\n-{sqlite3AddDefaultValue(pParse,yymsp[0].minor.yy528,yymsp[-2].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);}\n+{sqlite3AddDefaultValue(pParse,yymsp[0].minor.yy590,yymsp[-2].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);}\n@@ -174868,1 +178024,1 @@\n-  Expr *p = sqlite3PExpr(pParse, TK_UMINUS, yymsp[0].minor.yy528, 0);\n+  Expr *p = sqlite3PExpr(pParse, TK_UMINUS, yymsp[0].minor.yy590, 0);\n@@ -174883,1 +178039,1 @@\n-{sqlite3AddNotNull(pParse, yymsp[0].minor.yy394);}\n+{sqlite3AddNotNull(pParse, yymsp[0].minor.yy502);}\n@@ -174886,1 +178042,1 @@\n-{sqlite3AddPrimaryKey(pParse,0,yymsp[-1].minor.yy394,yymsp[0].minor.yy394,yymsp[-2].minor.yy394);}\n+{sqlite3AddPrimaryKey(pParse,0,yymsp[-1].minor.yy502,yymsp[0].minor.yy502,yymsp[-2].minor.yy502);}\n@@ -174889,1 +178045,1 @@\n-{sqlite3CreateIndex(pParse,0,0,0,0,yymsp[0].minor.yy394,0,0,0,0,\n+{sqlite3CreateIndex(pParse,0,0,0,0,yymsp[0].minor.yy502,0,0,0,0,\n@@ -174893,1 +178049,1 @@\n-{sqlite3AddCheckConstraint(pParse,yymsp[-1].minor.yy528,yymsp[-2].minor.yy0.z,yymsp[0].minor.yy0.z);}\n+{sqlite3AddCheckConstraint(pParse,yymsp[-1].minor.yy590,yymsp[-2].minor.yy0.z,yymsp[0].minor.yy0.z);}\n@@ -174896,1 +178052,1 @@\n-{sqlite3CreateForeignKey(pParse,0,&yymsp[-2].minor.yy0,yymsp[-1].minor.yy322,yymsp[0].minor.yy394);}\n+{sqlite3CreateForeignKey(pParse,0,&yymsp[-2].minor.yy0,yymsp[-1].minor.yy402,yymsp[0].minor.yy502);}\n@@ -174899,1 +178055,1 @@\n-{sqlite3DeferForeignKey(pParse,yymsp[0].minor.yy394);}\n+{sqlite3DeferForeignKey(pParse,yymsp[0].minor.yy502);}\n@@ -174905,1 +178061,1 @@\n-{sqlite3AddGenerated(pParse,yymsp[-1].minor.yy528,0);}\n+{sqlite3AddGenerated(pParse,yymsp[-1].minor.yy590,0);}\n@@ -174908,1 +178064,1 @@\n-{sqlite3AddGenerated(pParse,yymsp[-2].minor.yy528,&yymsp[0].minor.yy0);}\n+{sqlite3AddGenerated(pParse,yymsp[-2].minor.yy590,&yymsp[0].minor.yy0);}\n@@ -174911,1 +178067,1 @@\n-{yymsp[0].minor.yy394 = 1;}\n+{yymsp[0].minor.yy502 = 1;}\n@@ -174914,1 +178070,1 @@\n-{ yymsp[1].minor.yy394 = OE_None*0x0101; \/* EV: R-19803-45884 *\/}\n+{ yymsp[1].minor.yy502 = OE_None*0x0101; \/* EV: R-19803-45884 *\/}\n@@ -174917,1 +178073,1 @@\n-{ yymsp[-1].minor.yy394 = (yymsp[-1].minor.yy394 & ~yymsp[0].minor.yy231.mask) | yymsp[0].minor.yy231.value; }\n+{ yymsp[-1].minor.yy502 = (yymsp[-1].minor.yy502 & ~yymsp[0].minor.yy481.mask) | yymsp[0].minor.yy481.value; }\n@@ -174920,1 +178076,1 @@\n-{ yymsp[-1].minor.yy231.value = 0;     yymsp[-1].minor.yy231.mask = 0x000000; }\n+{ yymsp[-1].minor.yy481.value = 0;     yymsp[-1].minor.yy481.mask = 0x000000; }\n@@ -174923,1 +178079,1 @@\n-{ yymsp[-2].minor.yy231.value = 0;     yymsp[-2].minor.yy231.mask = 0x000000; }\n+{ yymsp[-2].minor.yy481.value = 0;     yymsp[-2].minor.yy481.mask = 0x000000; }\n@@ -174926,1 +178082,1 @@\n-{ yymsp[-2].minor.yy231.value = yymsp[0].minor.yy394;     yymsp[-2].minor.yy231.mask = 0x0000ff; }\n+{ yymsp[-2].minor.yy481.value = yymsp[0].minor.yy502;     yymsp[-2].minor.yy481.mask = 0x0000ff; }\n@@ -174929,1 +178085,1 @@\n-{ yymsp[-2].minor.yy231.value = yymsp[0].minor.yy394<<8;  yymsp[-2].minor.yy231.mask = 0x00ff00; }\n+{ yymsp[-2].minor.yy481.value = yymsp[0].minor.yy502<<8;  yymsp[-2].minor.yy481.mask = 0x00ff00; }\n@@ -174932,1 +178088,1 @@\n-{ yymsp[-1].minor.yy394 = OE_SetNull;  \/* EV: R-33326-45252 *\/}\n+{ yymsp[-1].minor.yy502 = OE_SetNull;  \/* EV: R-33326-45252 *\/}\n@@ -174935,1 +178091,1 @@\n-{ yymsp[-1].minor.yy394 = OE_SetDflt;  \/* EV: R-33326-45252 *\/}\n+{ yymsp[-1].minor.yy502 = OE_SetDflt;  \/* EV: R-33326-45252 *\/}\n@@ -174938,1 +178094,1 @@\n-{ yymsp[0].minor.yy394 = OE_Cascade;  \/* EV: R-33326-45252 *\/}\n+{ yymsp[0].minor.yy502 = OE_Cascade;  \/* EV: R-33326-45252 *\/}\n@@ -174941,1 +178097,1 @@\n-{ yymsp[0].minor.yy394 = OE_Restrict; \/* EV: R-33326-45252 *\/}\n+{ yymsp[0].minor.yy502 = OE_Restrict; \/* EV: R-33326-45252 *\/}\n@@ -174944,1 +178100,1 @@\n-{ yymsp[-1].minor.yy394 = OE_None;     \/* EV: R-33326-45252 *\/}\n+{ yymsp[-1].minor.yy502 = OE_None;     \/* EV: R-33326-45252 *\/}\n@@ -174947,1 +178103,1 @@\n-{yymsp[-2].minor.yy394 = 0;}\n+{yymsp[-2].minor.yy502 = 0;}\n@@ -174951,2 +178107,2 @@\n-      case 171: \/* insert_cmd ::= INSERT orconf *\/ yytestcase(yyruleno==171);\n-{yymsp[-1].minor.yy394 = yymsp[0].minor.yy394;}\n+      case 173: \/* insert_cmd ::= INSERT orconf *\/ yytestcase(yyruleno==173);\n+{yymsp[-1].minor.yy502 = yymsp[0].minor.yy502;}\n@@ -174956,4 +178112,4 @@\n-      case 217: \/* between_op ::= NOT BETWEEN *\/ yytestcase(yyruleno==217);\n-      case 220: \/* in_op ::= NOT IN *\/ yytestcase(yyruleno==220);\n-      case 245: \/* collate ::= COLLATE ID|STRING *\/ yytestcase(yyruleno==245);\n-{yymsp[-1].minor.yy394 = 1;}\n+      case 219: \/* between_op ::= NOT BETWEEN *\/ yytestcase(yyruleno==219);\n+      case 222: \/* in_op ::= NOT IN *\/ yytestcase(yyruleno==222);\n+      case 247: \/* collate ::= COLLATE ID|STRING *\/ yytestcase(yyruleno==247);\n+{yymsp[-1].minor.yy502 = 1;}\n@@ -174962,1 +178118,1 @@\n-{yymsp[-1].minor.yy394 = 0;}\n+{yymsp[-1].minor.yy502 = 0;}\n@@ -174968,1 +178124,1 @@\n-{sqlite3AddPrimaryKey(pParse,yymsp[-3].minor.yy322,yymsp[0].minor.yy394,yymsp[-2].minor.yy394,0);}\n+{sqlite3AddPrimaryKey(pParse,yymsp[-3].minor.yy402,yymsp[0].minor.yy502,yymsp[-2].minor.yy502,0);}\n@@ -174971,1 +178127,1 @@\n-{sqlite3CreateIndex(pParse,0,0,0,yymsp[-2].minor.yy322,yymsp[0].minor.yy394,0,0,0,0,\n+{sqlite3CreateIndex(pParse,0,0,0,yymsp[-2].minor.yy402,yymsp[0].minor.yy502,0,0,0,0,\n@@ -174975,1 +178131,1 @@\n-{sqlite3AddCheckConstraint(pParse,yymsp[-2].minor.yy528,yymsp[-3].minor.yy0.z,yymsp[-1].minor.yy0.z);}\n+{sqlite3AddCheckConstraint(pParse,yymsp[-2].minor.yy590,yymsp[-3].minor.yy0.z,yymsp[-1].minor.yy0.z);}\n@@ -174979,2 +178135,2 @@\n-    sqlite3CreateForeignKey(pParse, yymsp[-6].minor.yy322, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy322, yymsp[-1].minor.yy394);\n-    sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy394);\n+    sqlite3CreateForeignKey(pParse, yymsp[-6].minor.yy402, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy402, yymsp[-1].minor.yy502);\n+    sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy502);\n@@ -174985,1 +178141,1 @@\n-{yymsp[1].minor.yy394 = OE_Default;}\n+{yymsp[1].minor.yy502 = OE_Default;}\n@@ -174988,1 +178144,1 @@\n-{yymsp[-2].minor.yy394 = yymsp[0].minor.yy394;}\n+{yymsp[-2].minor.yy502 = yymsp[0].minor.yy502;}\n@@ -174991,1 +178147,1 @@\n-{yymsp[0].minor.yy394 = OE_Ignore;}\n+{yymsp[0].minor.yy502 = OE_Ignore;}\n@@ -174994,2 +178150,2 @@\n-      case 172: \/* insert_cmd ::= REPLACE *\/ yytestcase(yyruleno==172);\n-{yymsp[0].minor.yy394 = OE_Replace;}\n+      case 174: \/* insert_cmd ::= REPLACE *\/ yytestcase(yyruleno==174);\n+{yymsp[0].minor.yy502 = OE_Replace;}\n@@ -174999,1 +178155,1 @@\n-  sqlite3DropTable(pParse, yymsp[0].minor.yy131, 0, yymsp[-1].minor.yy394);\n+  sqlite3DropTable(pParse, yymsp[0].minor.yy563, 0, yymsp[-1].minor.yy502);\n@@ -175004,1 +178160,1 @@\n-  sqlite3CreateView(pParse, &yymsp[-8].minor.yy0, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy322, yymsp[0].minor.yy47, yymsp[-7].minor.yy394, yymsp[-5].minor.yy394);\n+  sqlite3CreateView(pParse, &yymsp[-8].minor.yy0, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy402, yymsp[0].minor.yy637, yymsp[-7].minor.yy502, yymsp[-5].minor.yy502);\n@@ -175009,1 +178165,1 @@\n-  sqlite3DropTable(pParse, yymsp[0].minor.yy131, 1, yymsp[-1].minor.yy394);\n+  sqlite3DropTable(pParse, yymsp[0].minor.yy563, 1, yymsp[-1].minor.yy502);\n@@ -175015,2 +178171,6 @@\n-  sqlite3Select(pParse, yymsp[0].minor.yy47, &dest);\n-  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy47);\n+  if( (pParse->db->mDbFlags & DBFLAG_EncodingFixed)!=0\n+   || sqlite3ReadSchema(pParse)==SQLITE_OK\n+  ){\n+    sqlite3Select(pParse, yymsp[0].minor.yy637, &dest);\n+  }\n+  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy637);\n@@ -175020,1 +178180,1 @@\n-{yymsp[-2].minor.yy47 = attachWithToSelect(pParse,yymsp[0].minor.yy47,yymsp[-1].minor.yy521);}\n+{yymsp[-2].minor.yy637 = attachWithToSelect(pParse,yymsp[0].minor.yy637,yymsp[-1].minor.yy125);}\n@@ -175023,1 +178183,1 @@\n-{yymsp[-3].minor.yy47 = attachWithToSelect(pParse,yymsp[0].minor.yy47,yymsp[-1].minor.yy521);}\n+{yymsp[-3].minor.yy637 = attachWithToSelect(pParse,yymsp[0].minor.yy637,yymsp[-1].minor.yy125);}\n@@ -175027,1 +178187,1 @@\n-  Select *p = yymsp[0].minor.yy47;\n+  Select *p = yymsp[0].minor.yy637;\n@@ -175035,2 +178195,2 @@\n-  Select *pRhs = yymsp[0].minor.yy47;\n-  Select *pLhs = yymsp[-2].minor.yy47;\n+  Select *pRhs = yymsp[0].minor.yy637;\n+  Select *pLhs = yymsp[-2].minor.yy637;\n@@ -175046,1 +178206,1 @@\n-    pRhs->op = (u8)yymsp[-1].minor.yy394;\n+    pRhs->op = (u8)yymsp[-1].minor.yy502;\n@@ -175050,1 +178210,1 @@\n-    if( yymsp[-1].minor.yy394!=TK_ALL ) pParse->hasCompound = 1;\n+    if( yymsp[-1].minor.yy502!=TK_ALL ) pParse->hasCompound = 1;\n@@ -175054,1 +178214,1 @@\n-  yymsp[-2].minor.yy47 = pRhs;\n+  yymsp[-2].minor.yy637 = pRhs;\n@@ -175059,1 +178219,1 @@\n-{yymsp[0].minor.yy394 = yymsp[0].major; \/*A-overwrites-OP*\/}\n+{yymsp[0].minor.yy502 = yymsp[0].major; \/*A-overwrites-OP*\/}\n@@ -175062,1 +178222,1 @@\n-{yymsp[-1].minor.yy394 = TK_ALL;}\n+{yymsp[-1].minor.yy502 = TK_ALL;}\n@@ -175066,1 +178226,1 @@\n-  yymsp[-8].minor.yy47 = sqlite3SelectNew(pParse,yymsp[-6].minor.yy322,yymsp[-5].minor.yy131,yymsp[-4].minor.yy528,yymsp[-3].minor.yy322,yymsp[-2].minor.yy528,yymsp[-1].minor.yy322,yymsp[-7].minor.yy394,yymsp[0].minor.yy528);\n+  yymsp[-8].minor.yy637 = sqlite3SelectNew(pParse,yymsp[-6].minor.yy402,yymsp[-5].minor.yy563,yymsp[-4].minor.yy590,yymsp[-3].minor.yy402,yymsp[-2].minor.yy590,yymsp[-1].minor.yy402,yymsp[-7].minor.yy502,yymsp[0].minor.yy590);\n@@ -175071,3 +178231,3 @@\n-  yymsp[-9].minor.yy47 = sqlite3SelectNew(pParse,yymsp[-7].minor.yy322,yymsp[-6].minor.yy131,yymsp[-5].minor.yy528,yymsp[-4].minor.yy322,yymsp[-3].minor.yy528,yymsp[-1].minor.yy322,yymsp[-8].minor.yy394,yymsp[0].minor.yy528);\n-  if( yymsp[-9].minor.yy47 ){\n-    yymsp[-9].minor.yy47->pWinDefn = yymsp[-2].minor.yy41;\n+  yymsp[-9].minor.yy637 = sqlite3SelectNew(pParse,yymsp[-7].minor.yy402,yymsp[-6].minor.yy563,yymsp[-5].minor.yy590,yymsp[-4].minor.yy402,yymsp[-3].minor.yy590,yymsp[-1].minor.yy402,yymsp[-8].minor.yy502,yymsp[0].minor.yy590);\n+  if( yymsp[-9].minor.yy637 ){\n+    yymsp[-9].minor.yy637->pWinDefn = yymsp[-2].minor.yy483;\n@@ -175075,1 +178235,1 @@\n-    sqlite3WindowListDelete(pParse->db, yymsp[-2].minor.yy41);\n+    sqlite3WindowListDelete(pParse->db, yymsp[-2].minor.yy483);\n@@ -175081,1 +178241,1 @@\n-  yymsp[-3].minor.yy47 = sqlite3SelectNew(pParse,yymsp[-1].minor.yy322,0,0,0,0,0,SF_Values,0);\n+  yymsp[-3].minor.yy637 = sqlite3SelectNew(pParse,yymsp[-1].minor.yy402,0,0,0,0,0,SF_Values,0);\n@@ -175084,1 +178244,1 @@\n-      case 95: \/* values ::= values COMMA LP nexprlist RP *\/\n+      case 95: \/* oneselect ::= mvalues *\/\n@@ -175086,10 +178246,7 @@\n-  Select *pRight, *pLeft = yymsp[-4].minor.yy47;\n-  pRight = sqlite3SelectNew(pParse,yymsp[-1].minor.yy322,0,0,0,0,0,SF_Values|SF_MultiValue,0);\n-  if( ALWAYS(pLeft) ) pLeft->selFlags &= ~SF_MultiValue;\n-  if( pRight ){\n-    pRight->op = TK_ALL;\n-    pRight->pPrior = pLeft;\n-    yymsp[-4].minor.yy47 = pRight;\n-  }else{\n-    yymsp[-4].minor.yy47 = pLeft;\n-  }\n+  sqlite3MultiValuesEnd(pParse, yymsp[0].minor.yy637);\n+}\n+        break;\n+      case 96: \/* mvalues ::= values COMMA LP nexprlist RP *\/\n+      case 97: \/* mvalues ::= mvalues COMMA LP nexprlist RP *\/ yytestcase(yyruleno==97);\n+{\n+  yymsp[-4].minor.yy637 = sqlite3MultiValues(pParse, yymsp[-4].minor.yy637, yymsp[-1].minor.yy402);\n@@ -175098,2 +178255,2 @@\n-      case 96: \/* distinct ::= DISTINCT *\/\n-{yymsp[0].minor.yy394 = SF_Distinct;}\n+      case 98: \/* distinct ::= DISTINCT *\/\n+{yymsp[0].minor.yy502 = SF_Distinct;}\n@@ -175101,2 +178258,2 @@\n-      case 97: \/* distinct ::= ALL *\/\n-{yymsp[0].minor.yy394 = SF_All;}\n+      case 99: \/* distinct ::= ALL *\/\n+{yymsp[0].minor.yy502 = SF_All;}\n@@ -175104,7 +178261,7 @@\n-      case 99: \/* sclp ::= *\/\n-      case 132: \/* orderby_opt ::= *\/ yytestcase(yyruleno==132);\n-      case 142: \/* groupby_opt ::= *\/ yytestcase(yyruleno==142);\n-      case 232: \/* exprlist ::= *\/ yytestcase(yyruleno==232);\n-      case 235: \/* paren_exprlist ::= *\/ yytestcase(yyruleno==235);\n-      case 240: \/* eidlist_opt ::= *\/ yytestcase(yyruleno==240);\n-{yymsp[1].minor.yy322 = 0;}\n+      case 101: \/* sclp ::= *\/\n+      case 134: \/* orderby_opt ::= *\/ yytestcase(yyruleno==134);\n+      case 144: \/* groupby_opt ::= *\/ yytestcase(yyruleno==144);\n+      case 234: \/* exprlist ::= *\/ yytestcase(yyruleno==234);\n+      case 237: \/* paren_exprlist ::= *\/ yytestcase(yyruleno==237);\n+      case 242: \/* eidlist_opt ::= *\/ yytestcase(yyruleno==242);\n+{yymsp[1].minor.yy402 = 0;}\n@@ -175112,1 +178269,1 @@\n-      case 100: \/* selcollist ::= sclp scanpt expr scanpt as *\/\n+      case 102: \/* selcollist ::= sclp scanpt expr scanpt as *\/\n@@ -175114,3 +178271,3 @@\n-   yymsp[-4].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy322, yymsp[-2].minor.yy528);\n-   if( yymsp[0].minor.yy0.n>0 ) sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy322, &yymsp[0].minor.yy0, 1);\n-   sqlite3ExprListSetSpan(pParse,yymsp[-4].minor.yy322,yymsp[-3].minor.yy522,yymsp[-1].minor.yy522);\n+   yymsp[-4].minor.yy402 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy402, yymsp[-2].minor.yy590);\n+   if( yymsp[0].minor.yy0.n>0 ) sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy402, &yymsp[0].minor.yy0, 1);\n+   sqlite3ExprListSetSpan(pParse,yymsp[-4].minor.yy402,yymsp[-3].minor.yy342,yymsp[-1].minor.yy342);\n@@ -175119,1 +178276,1 @@\n-      case 101: \/* selcollist ::= sclp scanpt STAR *\/\n+      case 103: \/* selcollist ::= sclp scanpt STAR *\/\n@@ -175123,1 +178280,1 @@\n-  yymsp[-2].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy322, p);\n+  yymsp[-2].minor.yy402 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy402, p);\n@@ -175126,1 +178283,1 @@\n-      case 102: \/* selcollist ::= sclp scanpt nm DOT STAR *\/\n+      case 104: \/* selcollist ::= sclp scanpt nm DOT STAR *\/\n@@ -175133,1 +178290,1 @@\n-  yymsp[-4].minor.yy322 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy322, pDot);\n+  yymsp[-4].minor.yy402 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy402, pDot);\n@@ -175136,4 +178293,4 @@\n-      case 103: \/* as ::= AS nm *\/\n-      case 115: \/* dbnm ::= DOT nm *\/ yytestcase(yyruleno==115);\n-      case 256: \/* plus_num ::= PLUS INTEGER|FLOAT *\/ yytestcase(yyruleno==256);\n-      case 257: \/* minus_num ::= MINUS INTEGER|FLOAT *\/ yytestcase(yyruleno==257);\n+      case 105: \/* as ::= AS nm *\/\n+      case 117: \/* dbnm ::= DOT nm *\/ yytestcase(yyruleno==117);\n+      case 258: \/* plus_num ::= PLUS INTEGER|FLOAT *\/ yytestcase(yyruleno==258);\n+      case 259: \/* minus_num ::= MINUS INTEGER|FLOAT *\/ yytestcase(yyruleno==259);\n@@ -175142,3 +178299,3 @@\n-      case 105: \/* from ::= *\/\n-      case 108: \/* stl_prefix ::= *\/ yytestcase(yyruleno==108);\n-{yymsp[1].minor.yy131 = 0;}\n+      case 107: \/* from ::= *\/\n+      case 110: \/* stl_prefix ::= *\/ yytestcase(yyruleno==110);\n+{yymsp[1].minor.yy563 = 0;}\n@@ -175146,1 +178303,1 @@\n-      case 106: \/* from ::= FROM seltablist *\/\n+      case 108: \/* from ::= FROM seltablist *\/\n@@ -175148,2 +178305,2 @@\n-  yymsp[-1].minor.yy131 = yymsp[0].minor.yy131;\n-  sqlite3SrcListShiftJoinType(pParse,yymsp[-1].minor.yy131);\n+  yymsp[-1].minor.yy563 = yymsp[0].minor.yy563;\n+  sqlite3SrcListShiftJoinType(pParse,yymsp[-1].minor.yy563);\n@@ -175152,1 +178309,1 @@\n-      case 107: \/* stl_prefix ::= seltablist joinop *\/\n+      case 109: \/* stl_prefix ::= seltablist joinop *\/\n@@ -175154,1 +178311,1 @@\n-   if( ALWAYS(yymsp[-1].minor.yy131 && yymsp[-1].minor.yy131->nSrc>0) ) yymsp[-1].minor.yy131->a[yymsp[-1].minor.yy131->nSrc-1].fg.jointype = (u8)yymsp[0].minor.yy394;\n+   if( ALWAYS(yymsp[-1].minor.yy563 && yymsp[-1].minor.yy563->nSrc>0) ) yymsp[-1].minor.yy563->a[yymsp[-1].minor.yy563->nSrc-1].fg.jointype = (u8)yymsp[0].minor.yy502;\n@@ -175157,1 +178314,1 @@\n-      case 109: \/* seltablist ::= stl_prefix nm dbnm as on_using *\/\n+      case 111: \/* seltablist ::= stl_prefix nm dbnm as on_using *\/\n@@ -175159,1 +178316,1 @@\n-  yymsp[-4].minor.yy131 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-4].minor.yy131,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,0,&yymsp[0].minor.yy561);\n+  yymsp[-4].minor.yy563 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-4].minor.yy563,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,0,&yymsp[0].minor.yy421);\n@@ -175162,1 +178319,1 @@\n-      case 110: \/* seltablist ::= stl_prefix nm dbnm as indexed_by on_using *\/\n+      case 112: \/* seltablist ::= stl_prefix nm dbnm as indexed_by on_using *\/\n@@ -175164,2 +178321,2 @@\n-  yymsp[-5].minor.yy131 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-5].minor.yy131,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,0,&yymsp[0].minor.yy561);\n-  sqlite3SrcListIndexedBy(pParse, yymsp[-5].minor.yy131, &yymsp[-1].minor.yy0);\n+  yymsp[-5].minor.yy563 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-5].minor.yy563,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,0,&yymsp[0].minor.yy421);\n+  sqlite3SrcListIndexedBy(pParse, yymsp[-5].minor.yy563, &yymsp[-1].minor.yy0);\n@@ -175168,1 +178325,1 @@\n-      case 111: \/* seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_using *\/\n+      case 113: \/* seltablist ::= stl_prefix nm dbnm LP exprlist RP as on_using *\/\n@@ -175170,2 +178327,2 @@\n-  yymsp[-7].minor.yy131 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-7].minor.yy131,&yymsp[-6].minor.yy0,&yymsp[-5].minor.yy0,&yymsp[-1].minor.yy0,0,&yymsp[0].minor.yy561);\n-  sqlite3SrcListFuncArgs(pParse, yymsp[-7].minor.yy131, yymsp[-3].minor.yy322);\n+  yymsp[-7].minor.yy563 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-7].minor.yy563,&yymsp[-6].minor.yy0,&yymsp[-5].minor.yy0,&yymsp[-1].minor.yy0,0,&yymsp[0].minor.yy421);\n+  sqlite3SrcListFuncArgs(pParse, yymsp[-7].minor.yy563, yymsp[-3].minor.yy402);\n@@ -175174,1 +178331,1 @@\n-      case 112: \/* seltablist ::= stl_prefix LP select RP as on_using *\/\n+      case 114: \/* seltablist ::= stl_prefix LP select RP as on_using *\/\n@@ -175176,1 +178333,1 @@\n-    yymsp[-5].minor.yy131 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-5].minor.yy131,0,0,&yymsp[-1].minor.yy0,yymsp[-3].minor.yy47,&yymsp[0].minor.yy561);\n+    yymsp[-5].minor.yy563 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-5].minor.yy563,0,0,&yymsp[-1].minor.yy0,yymsp[-3].minor.yy637,&yymsp[0].minor.yy421);\n@@ -175179,1 +178336,1 @@\n-      case 113: \/* seltablist ::= stl_prefix LP seltablist RP as on_using *\/\n+      case 115: \/* seltablist ::= stl_prefix LP seltablist RP as on_using *\/\n@@ -175181,7 +178338,8 @@\n-    if( yymsp[-5].minor.yy131==0 && yymsp[-1].minor.yy0.n==0 && yymsp[0].minor.yy561.pOn==0 && yymsp[0].minor.yy561.pUsing==0 ){\n-      yymsp[-5].minor.yy131 = yymsp[-3].minor.yy131;\n-    }else if( ALWAYS(yymsp[-3].minor.yy131!=0) && yymsp[-3].minor.yy131->nSrc==1 ){\n-      yymsp[-5].minor.yy131 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-5].minor.yy131,0,0,&yymsp[-1].minor.yy0,0,&yymsp[0].minor.yy561);\n-      if( yymsp[-5].minor.yy131 ){\n-        SrcItem *pNew = &yymsp[-5].minor.yy131->a[yymsp[-5].minor.yy131->nSrc-1];\n-        SrcItem *pOld = yymsp[-3].minor.yy131->a;\n+    if( yymsp[-5].minor.yy563==0 && yymsp[-1].minor.yy0.n==0 && yymsp[0].minor.yy421.pOn==0 && yymsp[0].minor.yy421.pUsing==0 ){\n+      yymsp[-5].minor.yy563 = yymsp[-3].minor.yy563;\n+    }else if( ALWAYS(yymsp[-3].minor.yy563!=0) && yymsp[-3].minor.yy563->nSrc==1 ){\n+      yymsp[-5].minor.yy563 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-5].minor.yy563,0,0,&yymsp[-1].minor.yy0,0,&yymsp[0].minor.yy421);\n+      if( yymsp[-5].minor.yy563 ){\n+        SrcItem *pNew = &yymsp[-5].minor.yy563->a[yymsp[-5].minor.yy563->nSrc-1];\n+        SrcItem *pOld = yymsp[-3].minor.yy563->a;\n+        assert( pOld->fg.fixedSchema==0 );\n@@ -175189,4 +178347,13 @@\n-        pNew->zDatabase = pOld->zDatabase;\n-        pNew->pSelect = pOld->pSelect;\n-        if( pNew->pSelect && (pNew->pSelect->selFlags & SF_NestedFrom)!=0 ){\n-          pNew->fg.isNestedFrom = 1;\n+        assert( pOld->fg.fixedSchema==0 );\n+        if( pOld->fg.isSubquery ){\n+          pNew->fg.isSubquery = 1;\n+          pNew->u4.pSubq = pOld->u4.pSubq;\n+          pOld->u4.pSubq = 0;\n+          pOld->fg.isSubquery = 0;\n+          assert( pNew->u4.pSubq!=0 && pNew->u4.pSubq->pSelect!=0 );\n+          if( (pNew->u4.pSubq->pSelect->selFlags & SF_NestedFrom)!=0 ){\n+            pNew->fg.isNestedFrom = 1;\n+          }\n+        }else{\n+          pNew->u4.zDatabase = pOld->u4.zDatabase;\n+          pOld->u4.zDatabase = 0;\n@@ -175200,2 +178367,1 @@\n-        pOld->zName = pOld->zDatabase = 0;\n-        pOld->pSelect = 0;\n+        pOld->zName = 0;\n@@ -175203,1 +178369,1 @@\n-      sqlite3SrcListDelete(pParse->db, yymsp[-3].minor.yy131);\n+      sqlite3SrcListDelete(pParse->db, yymsp[-3].minor.yy563);\n@@ -175206,3 +178372,3 @@\n-      sqlite3SrcListShiftJoinType(pParse,yymsp[-3].minor.yy131);\n-      pSubquery = sqlite3SelectNew(pParse,0,yymsp[-3].minor.yy131,0,0,0,0,SF_NestedFrom,0);\n-      yymsp[-5].minor.yy131 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-5].minor.yy131,0,0,&yymsp[-1].minor.yy0,pSubquery,&yymsp[0].minor.yy561);\n+      sqlite3SrcListShiftJoinType(pParse,yymsp[-3].minor.yy563);\n+      pSubquery = sqlite3SelectNew(pParse,0,yymsp[-3].minor.yy563,0,0,0,0,SF_NestedFrom,0);\n+      yymsp[-5].minor.yy563 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-5].minor.yy563,0,0,&yymsp[-1].minor.yy0,pSubquery,&yymsp[0].minor.yy421);\n@@ -175212,2 +178378,2 @@\n-      case 114: \/* dbnm ::= *\/\n-      case 129: \/* indexed_opt ::= *\/ yytestcase(yyruleno==129);\n+      case 116: \/* dbnm ::= *\/\n+      case 131: \/* indexed_opt ::= *\/ yytestcase(yyruleno==131);\n@@ -175216,1 +178382,1 @@\n-      case 116: \/* fullname ::= nm *\/\n+      case 118: \/* fullname ::= nm *\/\n@@ -175218,2 +178384,2 @@\n-  yylhsminor.yy131 = sqlite3SrcListAppend(pParse,0,&yymsp[0].minor.yy0,0);\n-  if( IN_RENAME_OBJECT && yylhsminor.yy131 ) sqlite3RenameTokenMap(pParse, yylhsminor.yy131->a[0].zName, &yymsp[0].minor.yy0);\n+  yylhsminor.yy563 = sqlite3SrcListAppend(pParse,0,&yymsp[0].minor.yy0,0);\n+  if( IN_RENAME_OBJECT && yylhsminor.yy563 ) sqlite3RenameTokenMap(pParse, yylhsminor.yy563->a[0].zName, &yymsp[0].minor.yy0);\n@@ -175221,1 +178387,1 @@\n-  yymsp[0].minor.yy131 = yylhsminor.yy131;\n+  yymsp[0].minor.yy563 = yylhsminor.yy563;\n@@ -175223,1 +178389,1 @@\n-      case 117: \/* fullname ::= nm DOT nm *\/\n+      case 119: \/* fullname ::= nm DOT nm *\/\n@@ -175225,2 +178391,2 @@\n-  yylhsminor.yy131 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0);\n-  if( IN_RENAME_OBJECT && yylhsminor.yy131 ) sqlite3RenameTokenMap(pParse, yylhsminor.yy131->a[0].zName, &yymsp[0].minor.yy0);\n+  yylhsminor.yy563 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0);\n+  if( IN_RENAME_OBJECT && yylhsminor.yy563 ) sqlite3RenameTokenMap(pParse, yylhsminor.yy563->a[0].zName, &yymsp[0].minor.yy0);\n@@ -175228,1 +178394,1 @@\n-  yymsp[-2].minor.yy131 = yylhsminor.yy131;\n+  yymsp[-2].minor.yy563 = yylhsminor.yy563;\n@@ -175230,2 +178396,2 @@\n-      case 118: \/* xfullname ::= nm *\/\n-{yymsp[0].minor.yy131 = sqlite3SrcListAppend(pParse,0,&yymsp[0].minor.yy0,0); \/*A-overwrites-X*\/}\n+      case 120: \/* xfullname ::= nm *\/\n+{yymsp[0].minor.yy563 = sqlite3SrcListAppend(pParse,0,&yymsp[0].minor.yy0,0); \/*A-overwrites-X*\/}\n@@ -175233,2 +178399,2 @@\n-      case 119: \/* xfullname ::= nm DOT nm *\/\n-{yymsp[-2].minor.yy131 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0); \/*A-overwrites-X*\/}\n+      case 121: \/* xfullname ::= nm DOT nm *\/\n+{yymsp[-2].minor.yy563 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0); \/*A-overwrites-X*\/}\n@@ -175236,1 +178402,1 @@\n-      case 120: \/* xfullname ::= nm DOT nm AS nm *\/\n+      case 122: \/* xfullname ::= nm DOT nm AS nm *\/\n@@ -175238,2 +178404,2 @@\n-   yymsp[-4].minor.yy131 = sqlite3SrcListAppend(pParse,0,&yymsp[-4].minor.yy0,&yymsp[-2].minor.yy0); \/*A-overwrites-X*\/\n-   if( yymsp[-4].minor.yy131 ) yymsp[-4].minor.yy131->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);\n+   yymsp[-4].minor.yy563 = sqlite3SrcListAppend(pParse,0,&yymsp[-4].minor.yy0,&yymsp[-2].minor.yy0); \/*A-overwrites-X*\/\n+   if( yymsp[-4].minor.yy563 ) yymsp[-4].minor.yy563->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);\n@@ -175242,1 +178408,1 @@\n-      case 121: \/* xfullname ::= nm AS nm *\/\n+      case 123: \/* xfullname ::= nm AS nm *\/\n@@ -175244,2 +178410,2 @@\n-   yymsp[-2].minor.yy131 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,0); \/*A-overwrites-X*\/\n-   if( yymsp[-2].minor.yy131 ) yymsp[-2].minor.yy131->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);\n+   yymsp[-2].minor.yy563 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,0); \/*A-overwrites-X*\/\n+   if( yymsp[-2].minor.yy563 ) yymsp[-2].minor.yy563->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);\n@@ -175248,2 +178414,2 @@\n-      case 122: \/* joinop ::= COMMA|JOIN *\/\n-{ yymsp[0].minor.yy394 = JT_INNER; }\n+      case 124: \/* joinop ::= COMMA|JOIN *\/\n+{ yymsp[0].minor.yy502 = JT_INNER; }\n@@ -175251,2 +178417,2 @@\n-      case 123: \/* joinop ::= JOIN_KW JOIN *\/\n-{yymsp[-1].minor.yy394 = sqlite3JoinType(pParse,&yymsp[-1].minor.yy0,0,0);  \/*X-overwrites-A*\/}\n+      case 125: \/* joinop ::= JOIN_KW JOIN *\/\n+{yymsp[-1].minor.yy502 = sqlite3JoinType(pParse,&yymsp[-1].minor.yy0,0,0);  \/*X-overwrites-A*\/}\n@@ -175254,2 +178420,2 @@\n-      case 124: \/* joinop ::= JOIN_KW nm JOIN *\/\n-{yymsp[-2].minor.yy394 = sqlite3JoinType(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,0); \/*X-overwrites-A*\/}\n+      case 126: \/* joinop ::= JOIN_KW nm JOIN *\/\n+{yymsp[-2].minor.yy502 = sqlite3JoinType(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,0); \/*X-overwrites-A*\/}\n@@ -175257,2 +178423,2 @@\n-      case 125: \/* joinop ::= JOIN_KW nm nm JOIN *\/\n-{yymsp[-3].minor.yy394 = sqlite3JoinType(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0);\/*X-overwrites-A*\/}\n+      case 127: \/* joinop ::= JOIN_KW nm nm JOIN *\/\n+{yymsp[-3].minor.yy502 = sqlite3JoinType(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0);\/*X-overwrites-A*\/}\n@@ -175260,2 +178426,2 @@\n-      case 126: \/* on_using ::= ON expr *\/\n-{yymsp[-1].minor.yy561.pOn = yymsp[0].minor.yy528; yymsp[-1].minor.yy561.pUsing = 0;}\n+      case 128: \/* on_using ::= ON expr *\/\n+{yymsp[-1].minor.yy421.pOn = yymsp[0].minor.yy590; yymsp[-1].minor.yy421.pUsing = 0;}\n@@ -175263,2 +178429,2 @@\n-      case 127: \/* on_using ::= USING LP idlist RP *\/\n-{yymsp[-3].minor.yy561.pOn = 0; yymsp[-3].minor.yy561.pUsing = yymsp[-1].minor.yy254;}\n+      case 129: \/* on_using ::= USING LP idlist RP *\/\n+{yymsp[-3].minor.yy421.pOn = 0; yymsp[-3].minor.yy421.pUsing = yymsp[-1].minor.yy204;}\n@@ -175266,2 +178432,2 @@\n-      case 128: \/* on_using ::= *\/\n-{yymsp[1].minor.yy561.pOn = 0; yymsp[1].minor.yy561.pUsing = 0;}\n+      case 130: \/* on_using ::= *\/\n+{yymsp[1].minor.yy421.pOn = 0; yymsp[1].minor.yy421.pUsing = 0;}\n@@ -175269,1 +178435,1 @@\n-      case 130: \/* indexed_by ::= INDEXED BY nm *\/\n+      case 132: \/* indexed_by ::= INDEXED BY nm *\/\n@@ -175272,1 +178438,1 @@\n-      case 131: \/* indexed_by ::= NOT INDEXED *\/\n+      case 133: \/* indexed_by ::= NOT INDEXED *\/\n@@ -175275,3 +178441,3 @@\n-      case 133: \/* orderby_opt ::= ORDER BY sortlist *\/\n-      case 143: \/* groupby_opt ::= GROUP BY nexprlist *\/ yytestcase(yyruleno==143);\n-{yymsp[-2].minor.yy322 = yymsp[0].minor.yy322;}\n+      case 135: \/* orderby_opt ::= ORDER BY sortlist *\/\n+      case 145: \/* groupby_opt ::= GROUP BY nexprlist *\/ yytestcase(yyruleno==145);\n+{yymsp[-2].minor.yy402 = yymsp[0].minor.yy402;}\n@@ -175279,1 +178445,1 @@\n-      case 134: \/* sortlist ::= sortlist COMMA expr sortorder nulls *\/\n+      case 136: \/* sortlist ::= sortlist COMMA expr sortorder nulls *\/\n@@ -175281,2 +178447,2 @@\n-  yymsp[-4].minor.yy322 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy322,yymsp[-2].minor.yy528);\n-  sqlite3ExprListSetSortOrder(yymsp[-4].minor.yy322,yymsp[-1].minor.yy394,yymsp[0].minor.yy394);\n+  yymsp[-4].minor.yy402 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy402,yymsp[-2].minor.yy590);\n+  sqlite3ExprListSetSortOrder(yymsp[-4].minor.yy402,yymsp[-1].minor.yy502,yymsp[0].minor.yy502);\n@@ -175285,1 +178451,1 @@\n-      case 135: \/* sortlist ::= expr sortorder nulls *\/\n+      case 137: \/* sortlist ::= expr sortorder nulls *\/\n@@ -175287,2 +178453,2 @@\n-  yymsp[-2].minor.yy322 = sqlite3ExprListAppend(pParse,0,yymsp[-2].minor.yy528); \/*A-overwrites-Y*\/\n-  sqlite3ExprListSetSortOrder(yymsp[-2].minor.yy322,yymsp[-1].minor.yy394,yymsp[0].minor.yy394);\n+  yymsp[-2].minor.yy402 = sqlite3ExprListAppend(pParse,0,yymsp[-2].minor.yy590); \/*A-overwrites-Y*\/\n+  sqlite3ExprListSetSortOrder(yymsp[-2].minor.yy402,yymsp[-1].minor.yy502,yymsp[0].minor.yy502);\n@@ -175291,2 +178457,2 @@\n-      case 136: \/* sortorder ::= ASC *\/\n-{yymsp[0].minor.yy394 = SQLITE_SO_ASC;}\n+      case 138: \/* sortorder ::= ASC *\/\n+{yymsp[0].minor.yy502 = SQLITE_SO_ASC;}\n@@ -175294,2 +178460,2 @@\n-      case 137: \/* sortorder ::= DESC *\/\n-{yymsp[0].minor.yy394 = SQLITE_SO_DESC;}\n+      case 139: \/* sortorder ::= DESC *\/\n+{yymsp[0].minor.yy502 = SQLITE_SO_DESC;}\n@@ -175297,3 +178463,3 @@\n-      case 138: \/* sortorder ::= *\/\n-      case 141: \/* nulls ::= *\/ yytestcase(yyruleno==141);\n-{yymsp[1].minor.yy394 = SQLITE_SO_UNDEFINED;}\n+      case 140: \/* sortorder ::= *\/\n+      case 143: \/* nulls ::= *\/ yytestcase(yyruleno==143);\n+{yymsp[1].minor.yy502 = SQLITE_SO_UNDEFINED;}\n@@ -175301,2 +178467,2 @@\n-      case 139: \/* nulls ::= NULLS FIRST *\/\n-{yymsp[-1].minor.yy394 = SQLITE_SO_ASC;}\n+      case 141: \/* nulls ::= NULLS FIRST *\/\n+{yymsp[-1].minor.yy502 = SQLITE_SO_ASC;}\n@@ -175304,2 +178470,2 @@\n-      case 140: \/* nulls ::= NULLS LAST *\/\n-{yymsp[-1].minor.yy394 = SQLITE_SO_DESC;}\n+      case 142: \/* nulls ::= NULLS LAST *\/\n+{yymsp[-1].minor.yy502 = SQLITE_SO_DESC;}\n@@ -175307,8 +178473,8 @@\n-      case 144: \/* having_opt ::= *\/\n-      case 146: \/* limit_opt ::= *\/ yytestcase(yyruleno==146);\n-      case 151: \/* where_opt ::= *\/ yytestcase(yyruleno==151);\n-      case 153: \/* where_opt_ret ::= *\/ yytestcase(yyruleno==153);\n-      case 230: \/* case_else ::= *\/ yytestcase(yyruleno==230);\n-      case 231: \/* case_operand ::= *\/ yytestcase(yyruleno==231);\n-      case 250: \/* vinto ::= *\/ yytestcase(yyruleno==250);\n-{yymsp[1].minor.yy528 = 0;}\n+      case 146: \/* having_opt ::= *\/\n+      case 148: \/* limit_opt ::= *\/ yytestcase(yyruleno==148);\n+      case 153: \/* where_opt ::= *\/ yytestcase(yyruleno==153);\n+      case 155: \/* where_opt_ret ::= *\/ yytestcase(yyruleno==155);\n+      case 232: \/* case_else ::= *\/ yytestcase(yyruleno==232);\n+      case 233: \/* case_operand ::= *\/ yytestcase(yyruleno==233);\n+      case 252: \/* vinto ::= *\/ yytestcase(yyruleno==252);\n+{yymsp[1].minor.yy590 = 0;}\n@@ -175316,6 +178482,6 @@\n-      case 145: \/* having_opt ::= HAVING expr *\/\n-      case 152: \/* where_opt ::= WHERE expr *\/ yytestcase(yyruleno==152);\n-      case 154: \/* where_opt_ret ::= WHERE expr *\/ yytestcase(yyruleno==154);\n-      case 229: \/* case_else ::= ELSE expr *\/ yytestcase(yyruleno==229);\n-      case 249: \/* vinto ::= INTO expr *\/ yytestcase(yyruleno==249);\n-{yymsp[-1].minor.yy528 = yymsp[0].minor.yy528;}\n+      case 147: \/* having_opt ::= HAVING expr *\/\n+      case 154: \/* where_opt ::= WHERE expr *\/ yytestcase(yyruleno==154);\n+      case 156: \/* where_opt_ret ::= WHERE expr *\/ yytestcase(yyruleno==156);\n+      case 231: \/* case_else ::= ELSE expr *\/ yytestcase(yyruleno==231);\n+      case 251: \/* vinto ::= INTO expr *\/ yytestcase(yyruleno==251);\n+{yymsp[-1].minor.yy590 = yymsp[0].minor.yy590;}\n@@ -175323,2 +178489,2 @@\n-      case 147: \/* limit_opt ::= LIMIT expr *\/\n-{yymsp[-1].minor.yy528 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[0].minor.yy528,0);}\n+      case 149: \/* limit_opt ::= LIMIT expr *\/\n+{yymsp[-1].minor.yy590 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[0].minor.yy590,0);}\n@@ -175326,2 +178492,2 @@\n-      case 148: \/* limit_opt ::= LIMIT expr OFFSET expr *\/\n-{yymsp[-3].minor.yy528 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[-2].minor.yy528,yymsp[0].minor.yy528);}\n+      case 150: \/* limit_opt ::= LIMIT expr OFFSET expr *\/\n+{yymsp[-3].minor.yy590 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[-2].minor.yy590,yymsp[0].minor.yy590);}\n@@ -175329,2 +178495,2 @@\n-      case 149: \/* limit_opt ::= LIMIT expr COMMA expr *\/\n-{yymsp[-3].minor.yy528 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[0].minor.yy528,yymsp[-2].minor.yy528);}\n+      case 151: \/* limit_opt ::= LIMIT expr COMMA expr *\/\n+{yymsp[-3].minor.yy590 = sqlite3PExpr(pParse,TK_LIMIT,yymsp[0].minor.yy590,yymsp[-2].minor.yy590);}\n@@ -175332,1 +178498,1 @@\n-      case 150: \/* cmd ::= with DELETE FROM xfullname indexed_opt where_opt_ret *\/\n+      case 152: \/* cmd ::= with DELETE FROM xfullname indexed_opt where_opt_ret *\/\n@@ -175334,2 +178500,2 @@\n-  sqlite3SrcListIndexedBy(pParse, yymsp[-2].minor.yy131, &yymsp[-1].minor.yy0);\n-  sqlite3DeleteFrom(pParse,yymsp[-2].minor.yy131,yymsp[0].minor.yy528,0,0);\n+  sqlite3SrcListIndexedBy(pParse, yymsp[-2].minor.yy563, &yymsp[-1].minor.yy0);\n+  sqlite3DeleteFrom(pParse,yymsp[-2].minor.yy563,yymsp[0].minor.yy590,0,0);\n@@ -175338,2 +178504,2 @@\n-      case 155: \/* where_opt_ret ::= RETURNING selcollist *\/\n-{sqlite3AddReturning(pParse,yymsp[0].minor.yy322); yymsp[-1].minor.yy528 = 0;}\n+      case 157: \/* where_opt_ret ::= RETURNING selcollist *\/\n+{sqlite3AddReturning(pParse,yymsp[0].minor.yy402); yymsp[-1].minor.yy590 = 0;}\n@@ -175341,2 +178507,2 @@\n-      case 156: \/* where_opt_ret ::= WHERE expr RETURNING selcollist *\/\n-{sqlite3AddReturning(pParse,yymsp[0].minor.yy322); yymsp[-3].minor.yy528 = yymsp[-2].minor.yy528;}\n+      case 158: \/* where_opt_ret ::= WHERE expr RETURNING selcollist *\/\n+{sqlite3AddReturning(pParse,yymsp[0].minor.yy402); yymsp[-3].minor.yy590 = yymsp[-2].minor.yy590;}\n@@ -175344,1 +178510,1 @@\n-      case 157: \/* cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist from where_opt_ret *\/\n+      case 159: \/* cmd ::= with UPDATE orconf xfullname indexed_opt SET setlist from where_opt_ret *\/\n@@ -175346,4 +178512,4 @@\n-  sqlite3SrcListIndexedBy(pParse, yymsp[-5].minor.yy131, &yymsp[-4].minor.yy0);\n-  sqlite3ExprListCheckLength(pParse,yymsp[-2].minor.yy322,\"set list\");\n-  if( yymsp[-1].minor.yy131 ){\n-    SrcList *pFromClause = yymsp[-1].minor.yy131;\n+  sqlite3SrcListIndexedBy(pParse, yymsp[-5].minor.yy563, &yymsp[-4].minor.yy0);\n+  sqlite3ExprListCheckLength(pParse,yymsp[-2].minor.yy402,\"set list\");\n+  if( yymsp[-1].minor.yy563 ){\n+    SrcList *pFromClause = yymsp[-1].minor.yy563;\n@@ -175358,1 +178524,1 @@\n-    yymsp[-5].minor.yy131 = sqlite3SrcListAppendList(pParse, yymsp[-5].minor.yy131, pFromClause);\n+    yymsp[-5].minor.yy563 = sqlite3SrcListAppendList(pParse, yymsp[-5].minor.yy563, pFromClause);\n@@ -175360,1 +178526,1 @@\n-  sqlite3Update(pParse,yymsp[-5].minor.yy131,yymsp[-2].minor.yy322,yymsp[0].minor.yy528,yymsp[-6].minor.yy394,0,0,0);\n+  sqlite3Update(pParse,yymsp[-5].minor.yy563,yymsp[-2].minor.yy402,yymsp[0].minor.yy590,yymsp[-6].minor.yy502,0,0,0);\n@@ -175363,1 +178529,1 @@\n-      case 158: \/* setlist ::= setlist COMMA nm EQ expr *\/\n+      case 160: \/* setlist ::= setlist COMMA nm EQ expr *\/\n@@ -175365,2 +178531,2 @@\n-  yymsp[-4].minor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy322, yymsp[0].minor.yy528);\n-  sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy322, &yymsp[-2].minor.yy0, 1);\n+  yymsp[-4].minor.yy402 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy402, yymsp[0].minor.yy590);\n+  sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy402, &yymsp[-2].minor.yy0, 1);\n@@ -175369,1 +178535,1 @@\n-      case 159: \/* setlist ::= setlist COMMA LP idlist RP EQ expr *\/\n+      case 161: \/* setlist ::= setlist COMMA LP idlist RP EQ expr *\/\n@@ -175371,1 +178537,1 @@\n-  yymsp[-6].minor.yy322 = sqlite3ExprListAppendVector(pParse, yymsp[-6].minor.yy322, yymsp[-3].minor.yy254, yymsp[0].minor.yy528);\n+  yymsp[-6].minor.yy402 = sqlite3ExprListAppendVector(pParse, yymsp[-6].minor.yy402, yymsp[-3].minor.yy204, yymsp[0].minor.yy590);\n@@ -175374,1 +178540,1 @@\n-      case 160: \/* setlist ::= nm EQ expr *\/\n+      case 162: \/* setlist ::= nm EQ expr *\/\n@@ -175376,2 +178542,2 @@\n-  yylhsminor.yy322 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy528);\n-  sqlite3ExprListSetName(pParse, yylhsminor.yy322, &yymsp[-2].minor.yy0, 1);\n+  yylhsminor.yy402 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy590);\n+  sqlite3ExprListSetName(pParse, yylhsminor.yy402, &yymsp[-2].minor.yy0, 1);\n@@ -175379,1 +178545,1 @@\n-  yymsp[-2].minor.yy322 = yylhsminor.yy322;\n+  yymsp[-2].minor.yy402 = yylhsminor.yy402;\n@@ -175381,1 +178547,1 @@\n-      case 161: \/* setlist ::= LP idlist RP EQ expr *\/\n+      case 163: \/* setlist ::= LP idlist RP EQ expr *\/\n@@ -175383,1 +178549,1 @@\n-  yymsp[-4].minor.yy322 = sqlite3ExprListAppendVector(pParse, 0, yymsp[-3].minor.yy254, yymsp[0].minor.yy528);\n+  yymsp[-4].minor.yy402 = sqlite3ExprListAppendVector(pParse, 0, yymsp[-3].minor.yy204, yymsp[0].minor.yy590);\n@@ -175386,1 +178552,1 @@\n-      case 162: \/* cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert *\/\n+      case 164: \/* cmd ::= with insert_cmd INTO xfullname idlist_opt select upsert *\/\n@@ -175388,1 +178554,1 @@\n-  sqlite3Insert(pParse, yymsp[-3].minor.yy131, yymsp[-1].minor.yy47, yymsp[-2].minor.yy254, yymsp[-5].minor.yy394, yymsp[0].minor.yy444);\n+  sqlite3Insert(pParse, yymsp[-3].minor.yy563, yymsp[-1].minor.yy637, yymsp[-2].minor.yy204, yymsp[-5].minor.yy502, yymsp[0].minor.yy403);\n@@ -175391,1 +178557,1 @@\n-      case 163: \/* cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES returning *\/\n+      case 165: \/* cmd ::= with insert_cmd INTO xfullname idlist_opt DEFAULT VALUES returning *\/\n@@ -175393,1 +178559,1 @@\n-  sqlite3Insert(pParse, yymsp[-4].minor.yy131, 0, yymsp[-3].minor.yy254, yymsp[-6].minor.yy394, 0);\n+  sqlite3Insert(pParse, yymsp[-4].minor.yy563, 0, yymsp[-3].minor.yy204, yymsp[-6].minor.yy502, 0);\n@@ -175396,2 +178562,2 @@\n-      case 164: \/* upsert ::= *\/\n-{ yymsp[1].minor.yy444 = 0; }\n+      case 166: \/* upsert ::= *\/\n+{ yymsp[1].minor.yy403 = 0; }\n@@ -175399,2 +178565,2 @@\n-      case 165: \/* upsert ::= RETURNING selcollist *\/\n-{ yymsp[-1].minor.yy444 = 0; sqlite3AddReturning(pParse,yymsp[0].minor.yy322); }\n+      case 167: \/* upsert ::= RETURNING selcollist *\/\n+{ yymsp[-1].minor.yy403 = 0; sqlite3AddReturning(pParse,yymsp[0].minor.yy402); }\n@@ -175402,2 +178568,2 @@\n-      case 166: \/* upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt upsert *\/\n-{ yymsp[-11].minor.yy444 = sqlite3UpsertNew(pParse->db,yymsp[-8].minor.yy322,yymsp[-6].minor.yy528,yymsp[-2].minor.yy322,yymsp[-1].minor.yy528,yymsp[0].minor.yy444);}\n+      case 168: \/* upsert ::= ON CONFLICT LP sortlist RP where_opt DO UPDATE SET setlist where_opt upsert *\/\n+{ yymsp[-11].minor.yy403 = sqlite3UpsertNew(pParse->db,yymsp[-8].minor.yy402,yymsp[-6].minor.yy590,yymsp[-2].minor.yy402,yymsp[-1].minor.yy590,yymsp[0].minor.yy403);}\n@@ -175405,2 +178571,2 @@\n-      case 167: \/* upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING upsert *\/\n-{ yymsp[-8].minor.yy444 = sqlite3UpsertNew(pParse->db,yymsp[-5].minor.yy322,yymsp[-3].minor.yy528,0,0,yymsp[0].minor.yy444); }\n+      case 169: \/* upsert ::= ON CONFLICT LP sortlist RP where_opt DO NOTHING upsert *\/\n+{ yymsp[-8].minor.yy403 = sqlite3UpsertNew(pParse->db,yymsp[-5].minor.yy402,yymsp[-3].minor.yy590,0,0,yymsp[0].minor.yy403); }\n@@ -175408,2 +178574,2 @@\n-      case 168: \/* upsert ::= ON CONFLICT DO NOTHING returning *\/\n-{ yymsp[-4].minor.yy444 = sqlite3UpsertNew(pParse->db,0,0,0,0,0); }\n+      case 170: \/* upsert ::= ON CONFLICT DO NOTHING returning *\/\n+{ yymsp[-4].minor.yy403 = sqlite3UpsertNew(pParse->db,0,0,0,0,0); }\n@@ -175411,2 +178577,2 @@\n-      case 169: \/* upsert ::= ON CONFLICT DO UPDATE SET setlist where_opt returning *\/\n-{ yymsp[-7].minor.yy444 = sqlite3UpsertNew(pParse->db,0,0,yymsp[-2].minor.yy322,yymsp[-1].minor.yy528,0);}\n+      case 171: \/* upsert ::= ON CONFLICT DO UPDATE SET setlist where_opt returning *\/\n+{ yymsp[-7].minor.yy403 = sqlite3UpsertNew(pParse->db,0,0,yymsp[-2].minor.yy402,yymsp[-1].minor.yy590,0);}\n@@ -175414,2 +178580,2 @@\n-      case 170: \/* returning ::= RETURNING selcollist *\/\n-{sqlite3AddReturning(pParse,yymsp[0].minor.yy322);}\n+      case 172: \/* returning ::= RETURNING selcollist *\/\n+{sqlite3AddReturning(pParse,yymsp[0].minor.yy402);}\n@@ -175417,2 +178583,2 @@\n-      case 173: \/* idlist_opt ::= *\/\n-{yymsp[1].minor.yy254 = 0;}\n+      case 175: \/* idlist_opt ::= *\/\n+{yymsp[1].minor.yy204 = 0;}\n@@ -175420,2 +178586,2 @@\n-      case 174: \/* idlist_opt ::= LP idlist RP *\/\n-{yymsp[-2].minor.yy254 = yymsp[-1].minor.yy254;}\n+      case 176: \/* idlist_opt ::= LP idlist RP *\/\n+{yymsp[-2].minor.yy204 = yymsp[-1].minor.yy204;}\n@@ -175423,2 +178589,2 @@\n-      case 175: \/* idlist ::= idlist COMMA nm *\/\n-{yymsp[-2].minor.yy254 = sqlite3IdListAppend(pParse,yymsp[-2].minor.yy254,&yymsp[0].minor.yy0);}\n+      case 177: \/* idlist ::= idlist COMMA nm *\/\n+{yymsp[-2].minor.yy204 = sqlite3IdListAppend(pParse,yymsp[-2].minor.yy204,&yymsp[0].minor.yy0);}\n@@ -175426,2 +178592,2 @@\n-      case 176: \/* idlist ::= nm *\/\n-{yymsp[0].minor.yy254 = sqlite3IdListAppend(pParse,0,&yymsp[0].minor.yy0); \/*A-overwrites-Y*\/}\n+      case 178: \/* idlist ::= nm *\/\n+{yymsp[0].minor.yy204 = sqlite3IdListAppend(pParse,0,&yymsp[0].minor.yy0); \/*A-overwrites-Y*\/}\n@@ -175429,2 +178595,2 @@\n-      case 177: \/* expr ::= LP expr RP *\/\n-{yymsp[-2].minor.yy528 = yymsp[-1].minor.yy528;}\n+      case 179: \/* expr ::= LP expr RP *\/\n+{yymsp[-2].minor.yy590 = yymsp[-1].minor.yy590;}\n@@ -175432,2 +178598,2 @@\n-      case 178: \/* expr ::= ID|INDEXED|JOIN_KW *\/\n-{yymsp[0].minor.yy528=tokenExpr(pParse,TK_ID,yymsp[0].minor.yy0); \/*A-overwrites-X*\/}\n+      case 180: \/* expr ::= ID|INDEXED|JOIN_KW *\/\n+{yymsp[0].minor.yy590=tokenExpr(pParse,TK_ID,yymsp[0].minor.yy0); \/*A-overwrites-X*\/}\n@@ -175435,1 +178601,1 @@\n-      case 179: \/* expr ::= nm DOT nm *\/\n+      case 181: \/* expr ::= nm DOT nm *\/\n@@ -175439,1 +178605,1 @@\n-  yylhsminor.yy528 = sqlite3PExpr(pParse, TK_DOT, temp1, temp2);\n+  yylhsminor.yy590 = sqlite3PExpr(pParse, TK_DOT, temp1, temp2);\n@@ -175441,1 +178607,1 @@\n-  yymsp[-2].minor.yy528 = yylhsminor.yy528;\n+  yymsp[-2].minor.yy590 = yylhsminor.yy590;\n@@ -175443,1 +178609,1 @@\n-      case 180: \/* expr ::= nm DOT nm DOT nm *\/\n+      case 182: \/* expr ::= nm DOT nm DOT nm *\/\n@@ -175452,1 +178618,1 @@\n-  yylhsminor.yy528 = sqlite3PExpr(pParse, TK_DOT, temp1, temp4);\n+  yylhsminor.yy590 = sqlite3PExpr(pParse, TK_DOT, temp1, temp4);\n@@ -175454,1 +178620,1 @@\n-  yymsp[-4].minor.yy528 = yylhsminor.yy528;\n+  yymsp[-4].minor.yy590 = yylhsminor.yy590;\n@@ -175456,3 +178622,3 @@\n-      case 181: \/* term ::= NULL|FLOAT|BLOB *\/\n-      case 182: \/* term ::= STRING *\/ yytestcase(yyruleno==182);\n-{yymsp[0].minor.yy528=tokenExpr(pParse,yymsp[0].major,yymsp[0].minor.yy0); \/*A-overwrites-X*\/}\n+      case 183: \/* term ::= NULL|FLOAT|BLOB *\/\n+      case 184: \/* term ::= STRING *\/ yytestcase(yyruleno==184);\n+{yymsp[0].minor.yy590=tokenExpr(pParse,yymsp[0].major,yymsp[0].minor.yy0); \/*A-overwrites-X*\/}\n@@ -175460,1 +178626,1 @@\n-      case 183: \/* term ::= INTEGER *\/\n+      case 185: \/* term ::= INTEGER *\/\n@@ -175462,2 +178628,2 @@\n-  yylhsminor.yy528 = sqlite3ExprAlloc(pParse->db, TK_INTEGER, &yymsp[0].minor.yy0, 1);\n-  if( yylhsminor.yy528 ) yylhsminor.yy528->w.iOfst = (int)(yymsp[0].minor.yy0.z - pParse->zTail);\n+  yylhsminor.yy590 = sqlite3ExprAlloc(pParse->db, TK_INTEGER, &yymsp[0].minor.yy0, 1);\n+  if( yylhsminor.yy590 ) yylhsminor.yy590->w.iOfst = (int)(yymsp[0].minor.yy0.z - pParse->zTail);\n@@ -175465,1 +178631,1 @@\n-  yymsp[0].minor.yy528 = yylhsminor.yy528;\n+  yymsp[0].minor.yy590 = yylhsminor.yy590;\n@@ -175467,1 +178633,1 @@\n-      case 184: \/* expr ::= VARIABLE *\/\n+      case 186: \/* expr ::= VARIABLE *\/\n@@ -175471,2 +178637,2 @@\n-    yymsp[0].minor.yy528 = tokenExpr(pParse, TK_VARIABLE, yymsp[0].minor.yy0);\n-    sqlite3ExprAssignVarNumber(pParse, yymsp[0].minor.yy528, n);\n+    yymsp[0].minor.yy590 = tokenExpr(pParse, TK_VARIABLE, yymsp[0].minor.yy0);\n+    sqlite3ExprAssignVarNumber(pParse, yymsp[0].minor.yy590, n);\n@@ -175480,2 +178646,2 @@\n-      sqlite3ErrorMsg(pParse, \"near \\\"%T\\\": syntax error\", &t);\n-      yymsp[0].minor.yy528 = 0;\n+      parserSyntaxError(pParse, &t);\n+      yymsp[0].minor.yy590 = 0;\n@@ -175483,2 +178649,2 @@\n-      yymsp[0].minor.yy528 = sqlite3PExpr(pParse, TK_REGISTER, 0, 0);\n-      if( yymsp[0].minor.yy528 ) sqlite3GetInt32(&t.z[1], &yymsp[0].minor.yy528->iTable);\n+      yymsp[0].minor.yy590 = sqlite3PExpr(pParse, TK_REGISTER, 0, 0);\n+      if( yymsp[0].minor.yy590 ) sqlite3GetInt32(&t.z[1], &yymsp[0].minor.yy590->iTable);\n@@ -175489,1 +178655,1 @@\n-      case 185: \/* expr ::= expr COLLATE ID|STRING *\/\n+      case 187: \/* expr ::= expr COLLATE ID|STRING *\/\n@@ -175491,1 +178657,1 @@\n-  yymsp[-2].minor.yy528 = sqlite3ExprAddCollateToken(pParse, yymsp[-2].minor.yy528, &yymsp[0].minor.yy0, 1);\n+  yymsp[-2].minor.yy590 = sqlite3ExprAddCollateToken(pParse, yymsp[-2].minor.yy590, &yymsp[0].minor.yy0, 1);\n@@ -175494,1 +178660,1 @@\n-      case 186: \/* expr ::= CAST LP expr AS typetoken RP *\/\n+      case 188: \/* expr ::= CAST LP expr AS typetoken RP *\/\n@@ -175496,2 +178662,2 @@\n-  yymsp[-5].minor.yy528 = sqlite3ExprAlloc(pParse->db, TK_CAST, &yymsp[-1].minor.yy0, 1);\n-  sqlite3ExprAttachSubtrees(pParse->db, yymsp[-5].minor.yy528, yymsp[-3].minor.yy528, 0);\n+  yymsp[-5].minor.yy590 = sqlite3ExprAlloc(pParse->db, TK_CAST, &yymsp[-1].minor.yy0, 1);\n+  sqlite3ExprAttachSubtrees(pParse->db, yymsp[-5].minor.yy590, yymsp[-3].minor.yy590, 0);\n@@ -175500,1 +178666,1 @@\n-      case 187: \/* expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP *\/\n+      case 189: \/* expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP *\/\n@@ -175502,1 +178668,1 @@\n-  yylhsminor.yy528 = sqlite3ExprFunction(pParse, yymsp[-1].minor.yy322, &yymsp[-4].minor.yy0, yymsp[-2].minor.yy394);\n+  yylhsminor.yy590 = sqlite3ExprFunction(pParse, yymsp[-1].minor.yy402, &yymsp[-4].minor.yy0, yymsp[-2].minor.yy502);\n@@ -175504,1 +178670,1 @@\n-  yymsp[-4].minor.yy528 = yylhsminor.yy528;\n+  yymsp[-4].minor.yy590 = yylhsminor.yy590;\n@@ -175506,1 +178672,1 @@\n-      case 188: \/* expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP *\/\n+      case 190: \/* expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP *\/\n@@ -175508,2 +178674,2 @@\n-  yylhsminor.yy528 = sqlite3ExprFunction(pParse, yymsp[-4].minor.yy322, &yymsp[-7].minor.yy0, yymsp[-5].minor.yy394);\n-  sqlite3ExprAddFunctionOrderBy(pParse, yylhsminor.yy528, yymsp[-1].minor.yy322);\n+  yylhsminor.yy590 = sqlite3ExprFunction(pParse, yymsp[-4].minor.yy402, &yymsp[-7].minor.yy0, yymsp[-5].minor.yy502);\n+  sqlite3ExprAddFunctionOrderBy(pParse, yylhsminor.yy590, yymsp[-1].minor.yy402);\n@@ -175511,1 +178677,1 @@\n-  yymsp[-7].minor.yy528 = yylhsminor.yy528;\n+  yymsp[-7].minor.yy590 = yylhsminor.yy590;\n@@ -175513,1 +178679,1 @@\n-      case 189: \/* expr ::= ID|INDEXED|JOIN_KW LP STAR RP *\/\n+      case 191: \/* expr ::= ID|INDEXED|JOIN_KW LP STAR RP *\/\n@@ -175515,1 +178681,1 @@\n-  yylhsminor.yy528 = sqlite3ExprFunction(pParse, 0, &yymsp[-3].minor.yy0, 0);\n+  yylhsminor.yy590 = sqlite3ExprFunction(pParse, 0, &yymsp[-3].minor.yy0, 0);\n@@ -175517,1 +178683,1 @@\n-  yymsp[-3].minor.yy528 = yylhsminor.yy528;\n+  yymsp[-3].minor.yy590 = yylhsminor.yy590;\n@@ -175519,1 +178685,1 @@\n-      case 190: \/* expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP filter_over *\/\n+      case 192: \/* expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist RP filter_over *\/\n@@ -175521,2 +178687,2 @@\n-  yylhsminor.yy528 = sqlite3ExprFunction(pParse, yymsp[-2].minor.yy322, &yymsp[-5].minor.yy0, yymsp[-3].minor.yy394);\n-  sqlite3WindowAttach(pParse, yylhsminor.yy528, yymsp[0].minor.yy41);\n+  yylhsminor.yy590 = sqlite3ExprFunction(pParse, yymsp[-2].minor.yy402, &yymsp[-5].minor.yy0, yymsp[-3].minor.yy502);\n+  sqlite3WindowAttach(pParse, yylhsminor.yy590, yymsp[0].minor.yy483);\n@@ -175524,1 +178690,1 @@\n-  yymsp[-5].minor.yy528 = yylhsminor.yy528;\n+  yymsp[-5].minor.yy590 = yylhsminor.yy590;\n@@ -175526,1 +178692,1 @@\n-      case 191: \/* expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP filter_over *\/\n+      case 193: \/* expr ::= ID|INDEXED|JOIN_KW LP distinct exprlist ORDER BY sortlist RP filter_over *\/\n@@ -175528,3 +178694,3 @@\n-  yylhsminor.yy528 = sqlite3ExprFunction(pParse, yymsp[-5].minor.yy322, &yymsp[-8].minor.yy0, yymsp[-6].minor.yy394);\n-  sqlite3WindowAttach(pParse, yylhsminor.yy528, yymsp[0].minor.yy41);\n-  sqlite3ExprAddFunctionOrderBy(pParse, yylhsminor.yy528, yymsp[-2].minor.yy322);\n+  yylhsminor.yy590 = sqlite3ExprFunction(pParse, yymsp[-5].minor.yy402, &yymsp[-8].minor.yy0, yymsp[-6].minor.yy502);\n+  sqlite3WindowAttach(pParse, yylhsminor.yy590, yymsp[0].minor.yy483);\n+  sqlite3ExprAddFunctionOrderBy(pParse, yylhsminor.yy590, yymsp[-2].minor.yy402);\n@@ -175532,1 +178698,1 @@\n-  yymsp[-8].minor.yy528 = yylhsminor.yy528;\n+  yymsp[-8].minor.yy590 = yylhsminor.yy590;\n@@ -175534,1 +178700,1 @@\n-      case 192: \/* expr ::= ID|INDEXED|JOIN_KW LP STAR RP filter_over *\/\n+      case 194: \/* expr ::= ID|INDEXED|JOIN_KW LP STAR RP filter_over *\/\n@@ -175536,2 +178702,2 @@\n-  yylhsminor.yy528 = sqlite3ExprFunction(pParse, 0, &yymsp[-4].minor.yy0, 0);\n-  sqlite3WindowAttach(pParse, yylhsminor.yy528, yymsp[0].minor.yy41);\n+  yylhsminor.yy590 = sqlite3ExprFunction(pParse, 0, &yymsp[-4].minor.yy0, 0);\n+  sqlite3WindowAttach(pParse, yylhsminor.yy590, yymsp[0].minor.yy483);\n@@ -175539,1 +178705,1 @@\n-  yymsp[-4].minor.yy528 = yylhsminor.yy528;\n+  yymsp[-4].minor.yy590 = yylhsminor.yy590;\n@@ -175541,1 +178707,1 @@\n-      case 193: \/* term ::= CTIME_KW *\/\n+      case 195: \/* term ::= CTIME_KW *\/\n@@ -175543,1 +178709,1 @@\n-  yylhsminor.yy528 = sqlite3ExprFunction(pParse, 0, &yymsp[0].minor.yy0, 0);\n+  yylhsminor.yy590 = sqlite3ExprFunction(pParse, 0, &yymsp[0].minor.yy0, 0);\n@@ -175545,1 +178711,1 @@\n-  yymsp[0].minor.yy528 = yylhsminor.yy528;\n+  yymsp[0].minor.yy590 = yylhsminor.yy590;\n@@ -175547,1 +178713,1 @@\n-      case 194: \/* expr ::= LP nexprlist COMMA expr RP *\/\n+      case 196: \/* expr ::= LP nexprlist COMMA expr RP *\/\n@@ -175549,4 +178715,4 @@\n-  ExprList *pList = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy322, yymsp[-1].minor.yy528);\n-  yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, TK_VECTOR, 0, 0);\n-  if( yymsp[-4].minor.yy528 ){\n-    yymsp[-4].minor.yy528->x.pList = pList;\n+  ExprList *pList = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy402, yymsp[-1].minor.yy590);\n+  yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_VECTOR, 0, 0);\n+  if( yymsp[-4].minor.yy590 ){\n+    yymsp[-4].minor.yy590->x.pList = pList;\n@@ -175554,1 +178720,1 @@\n-      yymsp[-4].minor.yy528->flags |= pList->a[0].pExpr->flags & EP_Propagate;\n+      yymsp[-4].minor.yy590->flags |= pList->a[0].pExpr->flags & EP_Propagate;\n@@ -175561,2 +178727,2 @@\n-      case 195: \/* expr ::= expr AND expr *\/\n-{yymsp[-2].minor.yy528=sqlite3ExprAnd(pParse,yymsp[-2].minor.yy528,yymsp[0].minor.yy528);}\n+      case 197: \/* expr ::= expr AND expr *\/\n+{yymsp[-2].minor.yy590=sqlite3ExprAnd(pParse,yymsp[-2].minor.yy590,yymsp[0].minor.yy590);}\n@@ -175564,8 +178730,8 @@\n-      case 196: \/* expr ::= expr OR expr *\/\n-      case 197: \/* expr ::= expr LT|GT|GE|LE expr *\/ yytestcase(yyruleno==197);\n-      case 198: \/* expr ::= expr EQ|NE expr *\/ yytestcase(yyruleno==198);\n-      case 199: \/* expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr *\/ yytestcase(yyruleno==199);\n-      case 200: \/* expr ::= expr PLUS|MINUS expr *\/ yytestcase(yyruleno==200);\n-      case 201: \/* expr ::= expr STAR|SLASH|REM expr *\/ yytestcase(yyruleno==201);\n-      case 202: \/* expr ::= expr CONCAT expr *\/ yytestcase(yyruleno==202);\n-{yymsp[-2].minor.yy528=sqlite3PExpr(pParse,yymsp[-1].major,yymsp[-2].minor.yy528,yymsp[0].minor.yy528);}\n+      case 198: \/* expr ::= expr OR expr *\/\n+      case 199: \/* expr ::= expr LT|GT|GE|LE expr *\/ yytestcase(yyruleno==199);\n+      case 200: \/* expr ::= expr EQ|NE expr *\/ yytestcase(yyruleno==200);\n+      case 201: \/* expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr *\/ yytestcase(yyruleno==201);\n+      case 202: \/* expr ::= expr PLUS|MINUS expr *\/ yytestcase(yyruleno==202);\n+      case 203: \/* expr ::= expr STAR|SLASH|REM expr *\/ yytestcase(yyruleno==203);\n+      case 204: \/* expr ::= expr CONCAT expr *\/ yytestcase(yyruleno==204);\n+{yymsp[-2].minor.yy590=sqlite3PExpr(pParse,yymsp[-1].major,yymsp[-2].minor.yy590,yymsp[0].minor.yy590);}\n@@ -175573,1 +178739,1 @@\n-      case 203: \/* likeop ::= NOT LIKE_KW|MATCH *\/\n+      case 205: \/* likeop ::= NOT LIKE_KW|MATCH *\/\n@@ -175576,1 +178742,1 @@\n-      case 204: \/* expr ::= expr likeop expr *\/\n+      case 206: \/* expr ::= expr likeop expr *\/\n@@ -175581,5 +178747,5 @@\n-  pList = sqlite3ExprListAppend(pParse,0, yymsp[0].minor.yy528);\n-  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-2].minor.yy528);\n-  yymsp[-2].minor.yy528 = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy0, 0);\n-  if( bNot ) yymsp[-2].minor.yy528 = sqlite3PExpr(pParse, TK_NOT, yymsp[-2].minor.yy528, 0);\n-  if( yymsp[-2].minor.yy528 ) yymsp[-2].minor.yy528->flags |= EP_InfixFunc;\n+  pList = sqlite3ExprListAppend(pParse,0, yymsp[0].minor.yy590);\n+  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-2].minor.yy590);\n+  yymsp[-2].minor.yy590 = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy0, 0);\n+  if( bNot ) yymsp[-2].minor.yy590 = sqlite3PExpr(pParse, TK_NOT, yymsp[-2].minor.yy590, 0);\n+  if( yymsp[-2].minor.yy590 ) yymsp[-2].minor.yy590->flags |= EP_InfixFunc;\n@@ -175588,1 +178754,1 @@\n-      case 205: \/* expr ::= expr likeop expr ESCAPE expr *\/\n+      case 207: \/* expr ::= expr likeop expr ESCAPE expr *\/\n@@ -175593,6 +178759,6 @@\n-  pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy528);\n-  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-4].minor.yy528);\n-  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy528);\n-  yymsp[-4].minor.yy528 = sqlite3ExprFunction(pParse, pList, &yymsp[-3].minor.yy0, 0);\n-  if( bNot ) yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy528, 0);\n-  if( yymsp[-4].minor.yy528 ) yymsp[-4].minor.yy528->flags |= EP_InfixFunc;\n+  pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy590);\n+  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-4].minor.yy590);\n+  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy590);\n+  yymsp[-4].minor.yy590 = sqlite3ExprFunction(pParse, pList, &yymsp[-3].minor.yy0, 0);\n+  if( bNot ) yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy590, 0);\n+  if( yymsp[-4].minor.yy590 ) yymsp[-4].minor.yy590->flags |= EP_InfixFunc;\n@@ -175601,2 +178767,2 @@\n-      case 206: \/* expr ::= expr ISNULL|NOTNULL *\/\n-{yymsp[-1].minor.yy528 = sqlite3PExpr(pParse,yymsp[0].major,yymsp[-1].minor.yy528,0);}\n+      case 208: \/* expr ::= expr ISNULL|NOTNULL *\/\n+{yymsp[-1].minor.yy590 = sqlite3PExpr(pParse,yymsp[0].major,yymsp[-1].minor.yy590,0);}\n@@ -175604,2 +178770,2 @@\n-      case 207: \/* expr ::= expr NOT NULL *\/\n-{yymsp[-2].minor.yy528 = sqlite3PExpr(pParse,TK_NOTNULL,yymsp[-2].minor.yy528,0);}\n+      case 209: \/* expr ::= expr NOT NULL *\/\n+{yymsp[-2].minor.yy590 = sqlite3PExpr(pParse,TK_NOTNULL,yymsp[-2].minor.yy590,0);}\n@@ -175607,1 +178773,1 @@\n-      case 208: \/* expr ::= expr IS expr *\/\n+      case 210: \/* expr ::= expr IS expr *\/\n@@ -175609,2 +178775,2 @@\n-  yymsp[-2].minor.yy528 = sqlite3PExpr(pParse,TK_IS,yymsp[-2].minor.yy528,yymsp[0].minor.yy528);\n-  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy528, yymsp[-2].minor.yy528, TK_ISNULL);\n+  yymsp[-2].minor.yy590 = sqlite3PExpr(pParse,TK_IS,yymsp[-2].minor.yy590,yymsp[0].minor.yy590);\n+  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy590, yymsp[-2].minor.yy590, TK_ISNULL);\n@@ -175613,1 +178779,1 @@\n-      case 209: \/* expr ::= expr IS NOT expr *\/\n+      case 211: \/* expr ::= expr IS NOT expr *\/\n@@ -175615,2 +178781,2 @@\n-  yymsp[-3].minor.yy528 = sqlite3PExpr(pParse,TK_ISNOT,yymsp[-3].minor.yy528,yymsp[0].minor.yy528);\n-  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy528, yymsp[-3].minor.yy528, TK_NOTNULL);\n+  yymsp[-3].minor.yy590 = sqlite3PExpr(pParse,TK_ISNOT,yymsp[-3].minor.yy590,yymsp[0].minor.yy590);\n+  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy590, yymsp[-3].minor.yy590, TK_NOTNULL);\n@@ -175619,1 +178785,1 @@\n-      case 210: \/* expr ::= expr IS NOT DISTINCT FROM expr *\/\n+      case 212: \/* expr ::= expr IS NOT DISTINCT FROM expr *\/\n@@ -175621,2 +178787,2 @@\n-  yymsp[-5].minor.yy528 = sqlite3PExpr(pParse,TK_IS,yymsp[-5].minor.yy528,yymsp[0].minor.yy528);\n-  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy528, yymsp[-5].minor.yy528, TK_ISNULL);\n+  yymsp[-5].minor.yy590 = sqlite3PExpr(pParse,TK_IS,yymsp[-5].minor.yy590,yymsp[0].minor.yy590);\n+  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy590, yymsp[-5].minor.yy590, TK_ISNULL);\n@@ -175625,1 +178791,1 @@\n-      case 211: \/* expr ::= expr IS DISTINCT FROM expr *\/\n+      case 213: \/* expr ::= expr IS DISTINCT FROM expr *\/\n@@ -175627,2 +178793,2 @@\n-  yymsp[-4].minor.yy528 = sqlite3PExpr(pParse,TK_ISNOT,yymsp[-4].minor.yy528,yymsp[0].minor.yy528);\n-  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy528, yymsp[-4].minor.yy528, TK_NOTNULL);\n+  yymsp[-4].minor.yy590 = sqlite3PExpr(pParse,TK_ISNOT,yymsp[-4].minor.yy590,yymsp[0].minor.yy590);\n+  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy590, yymsp[-4].minor.yy590, TK_NOTNULL);\n@@ -175631,3 +178797,3 @@\n-      case 212: \/* expr ::= NOT expr *\/\n-      case 213: \/* expr ::= BITNOT expr *\/ yytestcase(yyruleno==213);\n-{yymsp[-1].minor.yy528 = sqlite3PExpr(pParse, yymsp[-1].major, yymsp[0].minor.yy528, 0);\/*A-overwrites-B*\/}\n+      case 214: \/* expr ::= NOT expr *\/\n+      case 215: \/* expr ::= BITNOT expr *\/ yytestcase(yyruleno==215);\n+{yymsp[-1].minor.yy590 = sqlite3PExpr(pParse, yymsp[-1].major, yymsp[0].minor.yy590, 0);\/*A-overwrites-B*\/}\n@@ -175635,1 +178801,1 @@\n-      case 214: \/* expr ::= PLUS|MINUS expr *\/\n+      case 216: \/* expr ::= PLUS|MINUS expr *\/\n@@ -175637,2 +178803,11 @@\n-  yymsp[-1].minor.yy528 = sqlite3PExpr(pParse, yymsp[-1].major==TK_PLUS ? TK_UPLUS : TK_UMINUS, yymsp[0].minor.yy528, 0);\n-  \/*A-overwrites-B*\/\n+  Expr *p = yymsp[0].minor.yy590;\n+  u8 op = yymsp[-1].major + (TK_UPLUS-TK_PLUS);\n+  assert( TK_UPLUS>TK_PLUS );\n+  assert( TK_UMINUS == TK_MINUS + (TK_UPLUS - TK_PLUS) );\n+  if( p && p->op==TK_UPLUS ){\n+    p->op = op;\n+    yymsp[-1].minor.yy590 = p;\n+  }else{\n+    yymsp[-1].minor.yy590 = sqlite3PExpr(pParse, op, p, 0);\n+    \/*A-overwrites-B*\/\n+  }\n@@ -175641,1 +178816,1 @@\n-      case 215: \/* expr ::= expr PTR expr *\/\n+      case 217: \/* expr ::= expr PTR expr *\/\n@@ -175643,3 +178818,3 @@\n-  ExprList *pList = sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy528);\n-  pList = sqlite3ExprListAppend(pParse, pList, yymsp[0].minor.yy528);\n-  yylhsminor.yy528 = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy0, 0);\n+  ExprList *pList = sqlite3ExprListAppend(pParse, 0, yymsp[-2].minor.yy590);\n+  pList = sqlite3ExprListAppend(pParse, pList, yymsp[0].minor.yy590);\n+  yylhsminor.yy590 = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy0, 0);\n@@ -175647,1 +178822,1 @@\n-  yymsp[-2].minor.yy528 = yylhsminor.yy528;\n+  yymsp[-2].minor.yy590 = yylhsminor.yy590;\n@@ -175649,3 +178824,3 @@\n-      case 216: \/* between_op ::= BETWEEN *\/\n-      case 219: \/* in_op ::= IN *\/ yytestcase(yyruleno==219);\n-{yymsp[0].minor.yy394 = 0;}\n+      case 218: \/* between_op ::= BETWEEN *\/\n+      case 221: \/* in_op ::= IN *\/ yytestcase(yyruleno==221);\n+{yymsp[0].minor.yy502 = 0;}\n@@ -175653,1 +178828,1 @@\n-      case 218: \/* expr ::= expr between_op expr AND expr *\/\n+      case 220: \/* expr ::= expr between_op expr AND expr *\/\n@@ -175655,5 +178830,5 @@\n-  ExprList *pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy528);\n-  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy528);\n-  yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, TK_BETWEEN, yymsp[-4].minor.yy528, 0);\n-  if( yymsp[-4].minor.yy528 ){\n-    yymsp[-4].minor.yy528->x.pList = pList;\n+  ExprList *pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy590);\n+  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy590);\n+  yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_BETWEEN, yymsp[-4].minor.yy590, 0);\n+  if( yymsp[-4].minor.yy590 ){\n+    yymsp[-4].minor.yy590->x.pList = pList;\n@@ -175663,1 +178838,1 @@\n-  if( yymsp[-3].minor.yy394 ) yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy528, 0);\n+  if( yymsp[-3].minor.yy502 ) yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy590, 0);\n@@ -175666,1 +178841,1 @@\n-      case 221: \/* expr ::= expr in_op LP exprlist RP *\/\n+      case 223: \/* expr ::= expr in_op LP exprlist RP *\/\n@@ -175668,1 +178843,1 @@\n-    if( yymsp[-1].minor.yy322==0 ){\n+    if( yymsp[-1].minor.yy402==0 ){\n@@ -175677,8 +178852,8 @@\n-      sqlite3ExprUnmapAndDelete(pParse, yymsp[-4].minor.yy528);\n-      yymsp[-4].minor.yy528 = sqlite3Expr(pParse->db, TK_STRING, yymsp[-3].minor.yy394 ? \"true\" : \"false\");\n-      if( yymsp[-4].minor.yy528 ) sqlite3ExprIdToTrueFalse(yymsp[-4].minor.yy528);\n-    }else{\n-      Expr *pRHS = yymsp[-1].minor.yy322->a[0].pExpr;\n-      if( yymsp[-1].minor.yy322->nExpr==1 && sqlite3ExprIsConstant(pRHS) && yymsp[-4].minor.yy528->op!=TK_VECTOR ){\n-        yymsp[-1].minor.yy322->a[0].pExpr = 0;\n-        sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy322);\n+      sqlite3ExprUnmapAndDelete(pParse, yymsp[-4].minor.yy590);\n+      yymsp[-4].minor.yy590 = sqlite3Expr(pParse->db, TK_STRING, yymsp[-3].minor.yy502 ? \"true\" : \"false\");\n+      if( yymsp[-4].minor.yy590 ) sqlite3ExprIdToTrueFalse(yymsp[-4].minor.yy590);\n+    }else{\n+      Expr *pRHS = yymsp[-1].minor.yy402->a[0].pExpr;\n+      if( yymsp[-1].minor.yy402->nExpr==1 && sqlite3ExprIsConstant(pParse,pRHS) && yymsp[-4].minor.yy590->op!=TK_VECTOR ){\n+        yymsp[-1].minor.yy402->a[0].pExpr = 0;\n+        sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy402);\n@@ -175686,4 +178861,4 @@\n-        yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, TK_EQ, yymsp[-4].minor.yy528, pRHS);\n-      }else if( yymsp[-1].minor.yy322->nExpr==1 && pRHS->op==TK_SELECT ){\n-        yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy528, 0);\n-        sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy528, pRHS->x.pSelect);\n+        yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_EQ, yymsp[-4].minor.yy590, pRHS);\n+      }else if( yymsp[-1].minor.yy402->nExpr==1 && pRHS->op==TK_SELECT ){\n+        yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy590, 0);\n+        sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy590, pRHS->x.pSelect);\n@@ -175691,8 +178866,8 @@\n-        sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy322);\n-      }else{\n-        yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy528, 0);\n-        if( yymsp[-4].minor.yy528==0 ){\n-          sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy322);\n-        }else if( yymsp[-4].minor.yy528->pLeft->op==TK_VECTOR ){\n-          int nExpr = yymsp[-4].minor.yy528->pLeft->x.pList->nExpr;\n-          Select *pSelectRHS = sqlite3ExprListToValues(pParse, nExpr, yymsp[-1].minor.yy322);\n+        sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy402);\n+      }else{\n+        yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy590, 0);\n+        if( yymsp[-4].minor.yy590==0 ){\n+          sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy402);\n+        }else if( yymsp[-4].minor.yy590->pLeft->op==TK_VECTOR ){\n+          int nExpr = yymsp[-4].minor.yy590->pLeft->x.pList->nExpr;\n+          Select *pSelectRHS = sqlite3ExprListToValues(pParse, nExpr, yymsp[-1].minor.yy402);\n@@ -175701,1 +178876,1 @@\n-            sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy528, pSelectRHS);\n+            sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy590, pSelectRHS);\n@@ -175704,2 +178879,2 @@\n-          yymsp[-4].minor.yy528->x.pList = yymsp[-1].minor.yy322;\n-          sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy528);\n+          yymsp[-4].minor.yy590->x.pList = yymsp[-1].minor.yy402;\n+          sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy590);\n@@ -175708,1 +178883,1 @@\n-      if( yymsp[-3].minor.yy394 ) yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy528, 0);\n+      if( yymsp[-3].minor.yy502 ) yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy590, 0);\n@@ -175712,1 +178887,1 @@\n-      case 222: \/* expr ::= LP select RP *\/\n+      case 224: \/* expr ::= LP select RP *\/\n@@ -175714,2 +178889,2 @@\n-    yymsp[-2].minor.yy528 = sqlite3PExpr(pParse, TK_SELECT, 0, 0);\n-    sqlite3PExprAddSelect(pParse, yymsp[-2].minor.yy528, yymsp[-1].minor.yy47);\n+    yymsp[-2].minor.yy590 = sqlite3PExpr(pParse, TK_SELECT, 0, 0);\n+    sqlite3PExprAddSelect(pParse, yymsp[-2].minor.yy590, yymsp[-1].minor.yy637);\n@@ -175718,1 +178893,1 @@\n-      case 223: \/* expr ::= expr in_op LP select RP *\/\n+      case 225: \/* expr ::= expr in_op LP select RP *\/\n@@ -175720,3 +178895,3 @@\n-    yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy528, 0);\n-    sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy528, yymsp[-1].minor.yy47);\n-    if( yymsp[-3].minor.yy394 ) yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy528, 0);\n+    yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy590, 0);\n+    sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy590, yymsp[-1].minor.yy637);\n+    if( yymsp[-3].minor.yy502 ) yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy590, 0);\n@@ -175725,1 +178900,1 @@\n-      case 224: \/* expr ::= expr in_op nm dbnm paren_exprlist *\/\n+      case 226: \/* expr ::= expr in_op nm dbnm paren_exprlist *\/\n@@ -175729,4 +178904,4 @@\n-    if( yymsp[0].minor.yy322 )  sqlite3SrcListFuncArgs(pParse, pSelect ? pSrc : 0, yymsp[0].minor.yy322);\n-    yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy528, 0);\n-    sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy528, pSelect);\n-    if( yymsp[-3].minor.yy394 ) yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy528, 0);\n+    if( yymsp[0].minor.yy402 )  sqlite3SrcListFuncArgs(pParse, pSelect ? pSrc : 0, yymsp[0].minor.yy402);\n+    yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy590, 0);\n+    sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy590, pSelect);\n+    if( yymsp[-3].minor.yy502 ) yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_NOT, yymsp[-4].minor.yy590, 0);\n@@ -175735,1 +178910,1 @@\n-      case 225: \/* expr ::= EXISTS LP select RP *\/\n+      case 227: \/* expr ::= EXISTS LP select RP *\/\n@@ -175738,2 +178913,2 @@\n-    p = yymsp[-3].minor.yy528 = sqlite3PExpr(pParse, TK_EXISTS, 0, 0);\n-    sqlite3PExprAddSelect(pParse, p, yymsp[-1].minor.yy47);\n+    p = yymsp[-3].minor.yy590 = sqlite3PExpr(pParse, TK_EXISTS, 0, 0);\n+    sqlite3PExprAddSelect(pParse, p, yymsp[-1].minor.yy637);\n@@ -175742,1 +178917,1 @@\n-      case 226: \/* expr ::= CASE case_operand case_exprlist case_else END *\/\n+      case 228: \/* expr ::= CASE case_operand case_exprlist case_else END *\/\n@@ -175744,4 +178919,4 @@\n-  yymsp[-4].minor.yy528 = sqlite3PExpr(pParse, TK_CASE, yymsp[-3].minor.yy528, 0);\n-  if( yymsp[-4].minor.yy528 ){\n-    yymsp[-4].minor.yy528->x.pList = yymsp[-1].minor.yy528 ? sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy322,yymsp[-1].minor.yy528) : yymsp[-2].minor.yy322;\n-    sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy528);\n+  yymsp[-4].minor.yy590 = sqlite3PExpr(pParse, TK_CASE, yymsp[-3].minor.yy590, 0);\n+  if( yymsp[-4].minor.yy590 ){\n+    yymsp[-4].minor.yy590->x.pList = yymsp[-1].minor.yy590 ? sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy402,yymsp[-1].minor.yy590) : yymsp[-2].minor.yy402;\n+    sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy590);\n@@ -175749,2 +178924,2 @@\n-    sqlite3ExprListDelete(pParse->db, yymsp[-2].minor.yy322);\n-    sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy528);\n+    sqlite3ExprListDelete(pParse->db, yymsp[-2].minor.yy402);\n+    sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy590);\n@@ -175754,1 +178929,1 @@\n-      case 227: \/* case_exprlist ::= case_exprlist WHEN expr THEN expr *\/\n+      case 229: \/* case_exprlist ::= case_exprlist WHEN expr THEN expr *\/\n@@ -175756,2 +178931,2 @@\n-  yymsp[-4].minor.yy322 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy322, yymsp[-2].minor.yy528);\n-  yymsp[-4].minor.yy322 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy322, yymsp[0].minor.yy528);\n+  yymsp[-4].minor.yy402 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy402, yymsp[-2].minor.yy590);\n+  yymsp[-4].minor.yy402 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy402, yymsp[0].minor.yy590);\n@@ -175760,1 +178935,1 @@\n-      case 228: \/* case_exprlist ::= WHEN expr THEN expr *\/\n+      case 230: \/* case_exprlist ::= WHEN expr THEN expr *\/\n@@ -175762,2 +178937,2 @@\n-  yymsp[-3].minor.yy322 = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy528);\n-  yymsp[-3].minor.yy322 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy322, yymsp[0].minor.yy528);\n+  yymsp[-3].minor.yy402 = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy590);\n+  yymsp[-3].minor.yy402 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy402, yymsp[0].minor.yy590);\n@@ -175766,2 +178941,2 @@\n-      case 233: \/* nexprlist ::= nexprlist COMMA expr *\/\n-{yymsp[-2].minor.yy322 = sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy322,yymsp[0].minor.yy528);}\n+      case 235: \/* nexprlist ::= nexprlist COMMA expr *\/\n+{yymsp[-2].minor.yy402 = sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy402,yymsp[0].minor.yy590);}\n@@ -175769,2 +178944,2 @@\n-      case 234: \/* nexprlist ::= expr *\/\n-{yymsp[0].minor.yy322 = sqlite3ExprListAppend(pParse,0,yymsp[0].minor.yy528); \/*A-overwrites-Y*\/}\n+      case 236: \/* nexprlist ::= expr *\/\n+{yymsp[0].minor.yy402 = sqlite3ExprListAppend(pParse,0,yymsp[0].minor.yy590); \/*A-overwrites-Y*\/}\n@@ -175772,3 +178947,3 @@\n-      case 236: \/* paren_exprlist ::= LP exprlist RP *\/\n-      case 241: \/* eidlist_opt ::= LP eidlist RP *\/ yytestcase(yyruleno==241);\n-{yymsp[-2].minor.yy322 = yymsp[-1].minor.yy322;}\n+      case 238: \/* paren_exprlist ::= LP exprlist RP *\/\n+      case 243: \/* eidlist_opt ::= LP eidlist RP *\/ yytestcase(yyruleno==243);\n+{yymsp[-2].minor.yy402 = yymsp[-1].minor.yy402;}\n@@ -175776,1 +178951,1 @@\n-      case 237: \/* cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt *\/\n+      case 239: \/* cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP sortlist RP where_opt *\/\n@@ -175779,2 +178954,2 @@\n-                     sqlite3SrcListAppend(pParse,0,&yymsp[-4].minor.yy0,0), yymsp[-2].minor.yy322, yymsp[-10].minor.yy394,\n-                      &yymsp[-11].minor.yy0, yymsp[0].minor.yy528, SQLITE_SO_ASC, yymsp[-8].minor.yy394, SQLITE_IDXTYPE_APPDEF);\n+                     sqlite3SrcListAppend(pParse,0,&yymsp[-4].minor.yy0,0), yymsp[-2].minor.yy402, yymsp[-10].minor.yy502,\n+                      &yymsp[-11].minor.yy0, yymsp[0].minor.yy590, SQLITE_SO_ASC, yymsp[-8].minor.yy502, SQLITE_IDXTYPE_APPDEF);\n@@ -175786,3 +178961,3 @@\n-      case 238: \/* uniqueflag ::= UNIQUE *\/\n-      case 280: \/* raisetype ::= ABORT *\/ yytestcase(yyruleno==280);\n-{yymsp[0].minor.yy394 = OE_Abort;}\n+      case 240: \/* uniqueflag ::= UNIQUE *\/\n+      case 282: \/* raisetype ::= ABORT *\/ yytestcase(yyruleno==282);\n+{yymsp[0].minor.yy502 = OE_Abort;}\n@@ -175790,2 +178965,2 @@\n-      case 239: \/* uniqueflag ::= *\/\n-{yymsp[1].minor.yy394 = OE_None;}\n+      case 241: \/* uniqueflag ::= *\/\n+{yymsp[1].minor.yy502 = OE_None;}\n@@ -175793,1 +178968,1 @@\n-      case 242: \/* eidlist ::= eidlist COMMA nm collate sortorder *\/\n+      case 244: \/* eidlist ::= eidlist COMMA nm collate sortorder *\/\n@@ -175795,1 +178970,1 @@\n-  yymsp[-4].minor.yy322 = parserAddExprIdListTerm(pParse, yymsp[-4].minor.yy322, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy394, yymsp[0].minor.yy394);\n+  yymsp[-4].minor.yy402 = parserAddExprIdListTerm(pParse, yymsp[-4].minor.yy402, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy502, yymsp[0].minor.yy502);\n@@ -175798,1 +178973,1 @@\n-      case 243: \/* eidlist ::= nm collate sortorder *\/\n+      case 245: \/* eidlist ::= nm collate sortorder *\/\n@@ -175800,1 +178975,1 @@\n-  yymsp[-2].minor.yy322 = parserAddExprIdListTerm(pParse, 0, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy394, yymsp[0].minor.yy394); \/*A-overwrites-Y*\/\n+  yymsp[-2].minor.yy402 = parserAddExprIdListTerm(pParse, 0, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy502, yymsp[0].minor.yy502); \/*A-overwrites-Y*\/\n@@ -175803,2 +178978,2 @@\n-      case 246: \/* cmd ::= DROP INDEX ifexists fullname *\/\n-{sqlite3DropIndex(pParse, yymsp[0].minor.yy131, yymsp[-1].minor.yy394);}\n+      case 248: \/* cmd ::= DROP INDEX ifexists fullname *\/\n+{sqlite3DropIndex(pParse, yymsp[0].minor.yy563, yymsp[-1].minor.yy502);}\n@@ -175806,2 +178981,2 @@\n-      case 247: \/* cmd ::= VACUUM vinto *\/\n-{sqlite3Vacuum(pParse,0,yymsp[0].minor.yy528);}\n+      case 249: \/* cmd ::= VACUUM vinto *\/\n+{sqlite3Vacuum(pParse,0,yymsp[0].minor.yy590);}\n@@ -175809,2 +178984,2 @@\n-      case 248: \/* cmd ::= VACUUM nm vinto *\/\n-{sqlite3Vacuum(pParse,&yymsp[-1].minor.yy0,yymsp[0].minor.yy528);}\n+      case 250: \/* cmd ::= VACUUM nm vinto *\/\n+{sqlite3Vacuum(pParse,&yymsp[-1].minor.yy0,yymsp[0].minor.yy590);}\n@@ -175812,1 +178987,1 @@\n-      case 251: \/* cmd ::= PRAGMA nm dbnm *\/\n+      case 253: \/* cmd ::= PRAGMA nm dbnm *\/\n@@ -175815,1 +178990,1 @@\n-      case 252: \/* cmd ::= PRAGMA nm dbnm EQ nmnum *\/\n+      case 254: \/* cmd ::= PRAGMA nm dbnm EQ nmnum *\/\n@@ -175818,1 +178993,1 @@\n-      case 253: \/* cmd ::= PRAGMA nm dbnm LP nmnum RP *\/\n+      case 255: \/* cmd ::= PRAGMA nm dbnm LP nmnum RP *\/\n@@ -175821,1 +178996,1 @@\n-      case 254: \/* cmd ::= PRAGMA nm dbnm EQ minus_num *\/\n+      case 256: \/* cmd ::= PRAGMA nm dbnm EQ minus_num *\/\n@@ -175824,1 +178999,1 @@\n-      case 255: \/* cmd ::= PRAGMA nm dbnm LP minus_num RP *\/\n+      case 257: \/* cmd ::= PRAGMA nm dbnm LP minus_num RP *\/\n@@ -175827,1 +179002,1 @@\n-      case 258: \/* cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END *\/\n+      case 260: \/* cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END *\/\n@@ -175832,1 +179007,1 @@\n-  sqlite3FinishTrigger(pParse, yymsp[-1].minor.yy33, &all);\n+  sqlite3FinishTrigger(pParse, yymsp[-1].minor.yy319, &all);\n@@ -175835,1 +179010,1 @@\n-      case 259: \/* trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause *\/\n+      case 261: \/* trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause *\/\n@@ -175837,1 +179012,1 @@\n-  sqlite3BeginTrigger(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, yymsp[-5].minor.yy394, yymsp[-4].minor.yy180.a, yymsp[-4].minor.yy180.b, yymsp[-2].minor.yy131, yymsp[0].minor.yy528, yymsp[-10].minor.yy394, yymsp[-8].minor.yy394);\n+  sqlite3BeginTrigger(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, yymsp[-5].minor.yy502, yymsp[-4].minor.yy28.a, yymsp[-4].minor.yy28.b, yymsp[-2].minor.yy563, yymsp[0].minor.yy590, yymsp[-10].minor.yy502, yymsp[-8].minor.yy502);\n@@ -175841,2 +179016,2 @@\n-      case 260: \/* trigger_time ::= BEFORE|AFTER *\/\n-{ yymsp[0].minor.yy394 = yymsp[0].major; \/*A-overwrites-X*\/ }\n+      case 262: \/* trigger_time ::= BEFORE|AFTER *\/\n+{ yymsp[0].minor.yy502 = yymsp[0].major; \/*A-overwrites-X*\/ }\n@@ -175844,2 +179019,2 @@\n-      case 261: \/* trigger_time ::= INSTEAD OF *\/\n-{ yymsp[-1].minor.yy394 = TK_INSTEAD;}\n+      case 263: \/* trigger_time ::= INSTEAD OF *\/\n+{ yymsp[-1].minor.yy502 = TK_INSTEAD;}\n@@ -175847,2 +179022,2 @@\n-      case 262: \/* trigger_time ::= *\/\n-{ yymsp[1].minor.yy394 = TK_BEFORE; }\n+      case 264: \/* trigger_time ::= *\/\n+{ yymsp[1].minor.yy502 = TK_BEFORE; }\n@@ -175850,3 +179025,3 @@\n-      case 263: \/* trigger_event ::= DELETE|INSERT *\/\n-      case 264: \/* trigger_event ::= UPDATE *\/ yytestcase(yyruleno==264);\n-{yymsp[0].minor.yy180.a = yymsp[0].major; \/*A-overwrites-X*\/ yymsp[0].minor.yy180.b = 0;}\n+      case 265: \/* trigger_event ::= DELETE|INSERT *\/\n+      case 266: \/* trigger_event ::= UPDATE *\/ yytestcase(yyruleno==266);\n+{yymsp[0].minor.yy28.a = yymsp[0].major; \/*A-overwrites-X*\/ yymsp[0].minor.yy28.b = 0;}\n@@ -175854,2 +179029,2 @@\n-      case 265: \/* trigger_event ::= UPDATE OF idlist *\/\n-{yymsp[-2].minor.yy180.a = TK_UPDATE; yymsp[-2].minor.yy180.b = yymsp[0].minor.yy254;}\n+      case 267: \/* trigger_event ::= UPDATE OF idlist *\/\n+{yymsp[-2].minor.yy28.a = TK_UPDATE; yymsp[-2].minor.yy28.b = yymsp[0].minor.yy204;}\n@@ -175857,3 +179032,3 @@\n-      case 266: \/* when_clause ::= *\/\n-      case 285: \/* key_opt ::= *\/ yytestcase(yyruleno==285);\n-{ yymsp[1].minor.yy528 = 0; }\n+      case 268: \/* when_clause ::= *\/\n+      case 287: \/* key_opt ::= *\/ yytestcase(yyruleno==287);\n+{ yymsp[1].minor.yy590 = 0; }\n@@ -175861,3 +179036,3 @@\n-      case 267: \/* when_clause ::= WHEN expr *\/\n-      case 286: \/* key_opt ::= KEY expr *\/ yytestcase(yyruleno==286);\n-{ yymsp[-1].minor.yy528 = yymsp[0].minor.yy528; }\n+      case 269: \/* when_clause ::= WHEN expr *\/\n+      case 288: \/* key_opt ::= KEY expr *\/ yytestcase(yyruleno==288);\n+{ yymsp[-1].minor.yy590 = yymsp[0].minor.yy590; }\n@@ -175865,1 +179040,1 @@\n-      case 268: \/* trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI *\/\n+      case 270: \/* trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI *\/\n@@ -175867,3 +179042,3 @@\n-  assert( yymsp[-2].minor.yy33!=0 );\n-  yymsp[-2].minor.yy33->pLast->pNext = yymsp[-1].minor.yy33;\n-  yymsp[-2].minor.yy33->pLast = yymsp[-1].minor.yy33;\n+  assert( yymsp[-2].minor.yy319!=0 );\n+  yymsp[-2].minor.yy319->pLast->pNext = yymsp[-1].minor.yy319;\n+  yymsp[-2].minor.yy319->pLast = yymsp[-1].minor.yy319;\n@@ -175872,1 +179047,1 @@\n-      case 269: \/* trigger_cmd_list ::= trigger_cmd SEMI *\/\n+      case 271: \/* trigger_cmd_list ::= trigger_cmd SEMI *\/\n@@ -175874,2 +179049,2 @@\n-  assert( yymsp[-1].minor.yy33!=0 );\n-  yymsp[-1].minor.yy33->pLast = yymsp[-1].minor.yy33;\n+  assert( yymsp[-1].minor.yy319!=0 );\n+  yymsp[-1].minor.yy319->pLast = yymsp[-1].minor.yy319;\n@@ -175878,1 +179053,1 @@\n-      case 270: \/* trnm ::= nm DOT nm *\/\n+      case 272: \/* trnm ::= nm DOT nm *\/\n@@ -175886,1 +179061,1 @@\n-      case 271: \/* tridxby ::= INDEXED BY nm *\/\n+      case 273: \/* tridxby ::= INDEXED BY nm *\/\n@@ -175893,1 +179068,1 @@\n-      case 272: \/* tridxby ::= NOT INDEXED *\/\n+      case 274: \/* tridxby ::= NOT INDEXED *\/\n@@ -175900,3 +179075,3 @@\n-      case 273: \/* trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist from where_opt scanpt *\/\n-{yylhsminor.yy33 = sqlite3TriggerUpdateStep(pParse, &yymsp[-6].minor.yy0, yymsp[-2].minor.yy131, yymsp[-3].minor.yy322, yymsp[-1].minor.yy528, yymsp[-7].minor.yy394, yymsp[-8].minor.yy0.z, yymsp[0].minor.yy522);}\n-  yymsp[-8].minor.yy33 = yylhsminor.yy33;\n+      case 275: \/* trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist from where_opt scanpt *\/\n+{yylhsminor.yy319 = sqlite3TriggerUpdateStep(pParse, &yymsp[-6].minor.yy0, yymsp[-2].minor.yy563, yymsp[-3].minor.yy402, yymsp[-1].minor.yy590, yymsp[-7].minor.yy502, yymsp[-8].minor.yy0.z, yymsp[0].minor.yy342);}\n+  yymsp[-8].minor.yy319 = yylhsminor.yy319;\n@@ -175904,1 +179079,1 @@\n-      case 274: \/* trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt *\/\n+      case 276: \/* trigger_cmd ::= scanpt insert_cmd INTO trnm idlist_opt select upsert scanpt *\/\n@@ -175906,1 +179081,1 @@\n-   yylhsminor.yy33 = sqlite3TriggerInsertStep(pParse,&yymsp[-4].minor.yy0,yymsp[-3].minor.yy254,yymsp[-2].minor.yy47,yymsp[-6].minor.yy394,yymsp[-1].minor.yy444,yymsp[-7].minor.yy522,yymsp[0].minor.yy522);\/*yylhsminor.yy33-overwrites-yymsp[-6].minor.yy394*\/\n+   yylhsminor.yy319 = sqlite3TriggerInsertStep(pParse,&yymsp[-4].minor.yy0,yymsp[-3].minor.yy204,yymsp[-2].minor.yy637,yymsp[-6].minor.yy502,yymsp[-1].minor.yy403,yymsp[-7].minor.yy342,yymsp[0].minor.yy342);\/*yylhsminor.yy319-overwrites-yymsp[-6].minor.yy502*\/\n@@ -175908,1 +179083,1 @@\n-  yymsp[-7].minor.yy33 = yylhsminor.yy33;\n+  yymsp[-7].minor.yy319 = yylhsminor.yy319;\n@@ -175910,3 +179085,3 @@\n-      case 275: \/* trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt *\/\n-{yylhsminor.yy33 = sqlite3TriggerDeleteStep(pParse, &yymsp[-3].minor.yy0, yymsp[-1].minor.yy528, yymsp[-5].minor.yy0.z, yymsp[0].minor.yy522);}\n-  yymsp[-5].minor.yy33 = yylhsminor.yy33;\n+      case 277: \/* trigger_cmd ::= DELETE FROM trnm tridxby where_opt scanpt *\/\n+{yylhsminor.yy319 = sqlite3TriggerDeleteStep(pParse, &yymsp[-3].minor.yy0, yymsp[-1].minor.yy590, yymsp[-5].minor.yy0.z, yymsp[0].minor.yy342);}\n+  yymsp[-5].minor.yy319 = yylhsminor.yy319;\n@@ -175914,3 +179089,3 @@\n-      case 276: \/* trigger_cmd ::= scanpt select scanpt *\/\n-{yylhsminor.yy33 = sqlite3TriggerSelectStep(pParse->db, yymsp[-1].minor.yy47, yymsp[-2].minor.yy522, yymsp[0].minor.yy522); \/*yylhsminor.yy33-overwrites-yymsp[-1].minor.yy47*\/}\n-  yymsp[-2].minor.yy33 = yylhsminor.yy33;\n+      case 278: \/* trigger_cmd ::= scanpt select scanpt *\/\n+{yylhsminor.yy319 = sqlite3TriggerSelectStep(pParse->db, yymsp[-1].minor.yy637, yymsp[-2].minor.yy342, yymsp[0].minor.yy342); \/*yylhsminor.yy319-overwrites-yymsp[-1].minor.yy637*\/}\n+  yymsp[-2].minor.yy319 = yylhsminor.yy319;\n@@ -175918,1 +179093,1 @@\n-      case 277: \/* expr ::= RAISE LP IGNORE RP *\/\n+      case 279: \/* expr ::= RAISE LP IGNORE RP *\/\n@@ -175920,3 +179095,3 @@\n-  yymsp[-3].minor.yy528 = sqlite3PExpr(pParse, TK_RAISE, 0, 0);\n-  if( yymsp[-3].minor.yy528 ){\n-    yymsp[-3].minor.yy528->affExpr = OE_Ignore;\n+  yymsp[-3].minor.yy590 = sqlite3PExpr(pParse, TK_RAISE, 0, 0);\n+  if( yymsp[-3].minor.yy590 ){\n+    yymsp[-3].minor.yy590->affExpr = OE_Ignore;\n@@ -175926,1 +179101,1 @@\n-      case 278: \/* expr ::= RAISE LP raisetype COMMA nm RP *\/\n+      case 280: \/* expr ::= RAISE LP raisetype COMMA expr RP *\/\n@@ -175928,3 +179103,3 @@\n-  yymsp[-5].minor.yy528 = sqlite3ExprAlloc(pParse->db, TK_RAISE, &yymsp[-1].minor.yy0, 1);\n-  if( yymsp[-5].minor.yy528 ) {\n-    yymsp[-5].minor.yy528->affExpr = (char)yymsp[-3].minor.yy394;\n+  yymsp[-5].minor.yy590 = sqlite3PExpr(pParse, TK_RAISE, yymsp[-1].minor.yy590, 0);\n+  if( yymsp[-5].minor.yy590 ) {\n+    yymsp[-5].minor.yy590->affExpr = (char)yymsp[-3].minor.yy502;\n@@ -175934,2 +179109,2 @@\n-      case 279: \/* raisetype ::= ROLLBACK *\/\n-{yymsp[0].minor.yy394 = OE_Rollback;}\n+      case 281: \/* raisetype ::= ROLLBACK *\/\n+{yymsp[0].minor.yy502 = OE_Rollback;}\n@@ -175937,2 +179112,2 @@\n-      case 281: \/* raisetype ::= FAIL *\/\n-{yymsp[0].minor.yy394 = OE_Fail;}\n+      case 283: \/* raisetype ::= FAIL *\/\n+{yymsp[0].minor.yy502 = OE_Fail;}\n@@ -175940,1 +179115,1 @@\n-      case 282: \/* cmd ::= DROP TRIGGER ifexists fullname *\/\n+      case 284: \/* cmd ::= DROP TRIGGER ifexists fullname *\/\n@@ -175942,1 +179117,1 @@\n-  sqlite3DropTrigger(pParse,yymsp[0].minor.yy131,yymsp[-1].minor.yy394);\n+  sqlite3DropTrigger(pParse,yymsp[0].minor.yy563,yymsp[-1].minor.yy502);\n@@ -175945,1 +179120,1 @@\n-      case 283: \/* cmd ::= ATTACH database_kw_opt expr AS expr key_opt *\/\n+      case 285: \/* cmd ::= ATTACH database_kw_opt expr AS expr key_opt *\/\n@@ -175947,1 +179122,1 @@\n-  sqlite3Attach(pParse, yymsp[-3].minor.yy528, yymsp[-1].minor.yy528, yymsp[0].minor.yy528);\n+  sqlite3Attach(pParse, yymsp[-3].minor.yy590, yymsp[-1].minor.yy590, yymsp[0].minor.yy590);\n@@ -175950,1 +179125,1 @@\n-      case 284: \/* cmd ::= DETACH database_kw_opt expr *\/\n+      case 286: \/* cmd ::= DETACH database_kw_opt expr *\/\n@@ -175952,1 +179127,1 @@\n-  sqlite3Detach(pParse, yymsp[0].minor.yy528);\n+  sqlite3Detach(pParse, yymsp[0].minor.yy590);\n@@ -175955,1 +179130,1 @@\n-      case 287: \/* cmd ::= REINDEX *\/\n+      case 289: \/* cmd ::= REINDEX *\/\n@@ -175958,1 +179133,1 @@\n-      case 288: \/* cmd ::= REINDEX nm dbnm *\/\n+      case 290: \/* cmd ::= REINDEX nm dbnm *\/\n@@ -175961,1 +179136,1 @@\n-      case 289: \/* cmd ::= ANALYZE *\/\n+      case 291: \/* cmd ::= ANALYZE *\/\n@@ -175964,1 +179139,1 @@\n-      case 290: \/* cmd ::= ANALYZE nm dbnm *\/\n+      case 292: \/* cmd ::= ANALYZE nm dbnm *\/\n@@ -175967,1 +179142,1 @@\n-      case 291: \/* cmd ::= ALTER TABLE fullname RENAME TO nm *\/\n+      case 293: \/* cmd ::= ALTER TABLE fullname RENAME TO nm *\/\n@@ -175969,1 +179144,1 @@\n-  sqlite3AlterRenameTable(pParse,yymsp[-3].minor.yy131,&yymsp[0].minor.yy0);\n+  sqlite3AlterRenameTable(pParse,yymsp[-3].minor.yy563,&yymsp[0].minor.yy0);\n@@ -175972,1 +179147,1 @@\n-      case 292: \/* cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist *\/\n+      case 294: \/* cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt columnname carglist *\/\n@@ -175978,1 +179153,1 @@\n-      case 293: \/* cmd ::= ALTER TABLE fullname DROP kwcolumn_opt nm *\/\n+      case 295: \/* cmd ::= ALTER TABLE fullname DROP kwcolumn_opt nm *\/\n@@ -175980,1 +179155,1 @@\n-  sqlite3AlterDropColumn(pParse, yymsp[-3].minor.yy131, &yymsp[0].minor.yy0);\n+  sqlite3AlterDropColumn(pParse, yymsp[-3].minor.yy563, &yymsp[0].minor.yy0);\n@@ -175983,1 +179158,1 @@\n-      case 294: \/* add_column_fullname ::= fullname *\/\n+      case 296: \/* add_column_fullname ::= fullname *\/\n@@ -175986,1 +179161,1 @@\n-  sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy131);\n+  sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy563);\n@@ -175989,1 +179164,1 @@\n-      case 295: \/* cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm *\/\n+      case 297: \/* cmd ::= ALTER TABLE fullname RENAME kwcolumn_opt nm TO nm *\/\n@@ -175991,1 +179166,1 @@\n-  sqlite3AlterRenameColumn(pParse, yymsp[-5].minor.yy131, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0);\n+  sqlite3AlterRenameColumn(pParse, yymsp[-5].minor.yy563, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0);\n@@ -175994,1 +179169,1 @@\n-      case 296: \/* cmd ::= create_vtab *\/\n+      case 298: \/* cmd ::= create_vtab *\/\n@@ -175997,1 +179172,1 @@\n-      case 297: \/* cmd ::= create_vtab LP vtabarglist RP *\/\n+      case 299: \/* cmd ::= create_vtab LP vtabarglist RP *\/\n@@ -176000,1 +179175,1 @@\n-      case 298: \/* create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm *\/\n+      case 300: \/* create_vtab ::= createkw VIRTUAL TABLE ifnotexists nm dbnm USING nm *\/\n@@ -176002,1 +179177,1 @@\n-    sqlite3VtabBeginParse(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, yymsp[-4].minor.yy394);\n+    sqlite3VtabBeginParse(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, yymsp[-4].minor.yy502);\n@@ -176005,1 +179180,1 @@\n-      case 299: \/* vtabarg ::= *\/\n+      case 301: \/* vtabarg ::= *\/\n@@ -176008,3 +179183,3 @@\n-      case 300: \/* vtabargtoken ::= ANY *\/\n-      case 301: \/* vtabargtoken ::= lp anylist RP *\/ yytestcase(yyruleno==301);\n-      case 302: \/* lp ::= LP *\/ yytestcase(yyruleno==302);\n+      case 302: \/* vtabargtoken ::= ANY *\/\n+      case 303: \/* vtabargtoken ::= lp anylist RP *\/ yytestcase(yyruleno==303);\n+      case 304: \/* lp ::= LP *\/ yytestcase(yyruleno==304);\n@@ -176013,3 +179188,3 @@\n-      case 303: \/* with ::= WITH wqlist *\/\n-      case 304: \/* with ::= WITH RECURSIVE wqlist *\/ yytestcase(yyruleno==304);\n-{ sqlite3WithPush(pParse, yymsp[0].minor.yy521, 1); }\n+      case 305: \/* with ::= WITH wqlist *\/\n+      case 306: \/* with ::= WITH RECURSIVE wqlist *\/ yytestcase(yyruleno==306);\n+{ sqlite3WithPush(pParse, yymsp[0].minor.yy125, 1); }\n@@ -176017,2 +179192,2 @@\n-      case 305: \/* wqas ::= AS *\/\n-{yymsp[0].minor.yy516 = M10d_Any;}\n+      case 307: \/* wqas ::= AS *\/\n+{yymsp[0].minor.yy444 = M10d_Any;}\n@@ -176020,2 +179195,2 @@\n-      case 306: \/* wqas ::= AS MATERIALIZED *\/\n-{yymsp[-1].minor.yy516 = M10d_Yes;}\n+      case 308: \/* wqas ::= AS MATERIALIZED *\/\n+{yymsp[-1].minor.yy444 = M10d_Yes;}\n@@ -176023,2 +179198,2 @@\n-      case 307: \/* wqas ::= AS NOT MATERIALIZED *\/\n-{yymsp[-2].minor.yy516 = M10d_No;}\n+      case 309: \/* wqas ::= AS NOT MATERIALIZED *\/\n+{yymsp[-2].minor.yy444 = M10d_No;}\n@@ -176026,1 +179201,1 @@\n-      case 308: \/* wqitem ::= nm eidlist_opt wqas LP select RP *\/\n+      case 310: \/* wqitem ::= withnm eidlist_opt wqas LP select RP *\/\n@@ -176028,1 +179203,1 @@\n-  yymsp[-5].minor.yy385 = sqlite3CteNew(pParse, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy322, yymsp[-1].minor.yy47, yymsp[-3].minor.yy516); \/*A-overwrites-X*\/\n+  yymsp[-5].minor.yy361 = sqlite3CteNew(pParse, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy402, yymsp[-1].minor.yy637, yymsp[-3].minor.yy444); \/*A-overwrites-X*\/\n@@ -176031,1 +179206,4 @@\n-      case 309: \/* wqlist ::= wqitem *\/\n+      case 311: \/* withnm ::= nm *\/\n+{pParse->bHasWith = 1;}\n+        break;\n+      case 312: \/* wqlist ::= wqitem *\/\n@@ -176033,1 +179211,1 @@\n-  yymsp[0].minor.yy521 = sqlite3WithAdd(pParse, 0, yymsp[0].minor.yy385); \/*A-overwrites-X*\/\n+  yymsp[0].minor.yy125 = sqlite3WithAdd(pParse, 0, yymsp[0].minor.yy361); \/*A-overwrites-X*\/\n@@ -176036,1 +179214,1 @@\n-      case 310: \/* wqlist ::= wqlist COMMA wqitem *\/\n+      case 313: \/* wqlist ::= wqlist COMMA wqitem *\/\n@@ -176038,1 +179216,1 @@\n-  yymsp[-2].minor.yy521 = sqlite3WithAdd(pParse, yymsp[-2].minor.yy521, yymsp[0].minor.yy385);\n+  yymsp[-2].minor.yy125 = sqlite3WithAdd(pParse, yymsp[-2].minor.yy125, yymsp[0].minor.yy361);\n@@ -176041,1 +179219,1 @@\n-      case 311: \/* windowdefn_list ::= windowdefn_list COMMA windowdefn *\/\n+      case 314: \/* windowdefn_list ::= windowdefn_list COMMA windowdefn *\/\n@@ -176043,4 +179221,4 @@\n-  assert( yymsp[0].minor.yy41!=0 );\n-  sqlite3WindowChain(pParse, yymsp[0].minor.yy41, yymsp[-2].minor.yy41);\n-  yymsp[0].minor.yy41->pNextWin = yymsp[-2].minor.yy41;\n-  yylhsminor.yy41 = yymsp[0].minor.yy41;\n+  assert( yymsp[0].minor.yy483!=0 );\n+  sqlite3WindowChain(pParse, yymsp[0].minor.yy483, yymsp[-2].minor.yy483);\n+  yymsp[0].minor.yy483->pNextWin = yymsp[-2].minor.yy483;\n+  yylhsminor.yy483 = yymsp[0].minor.yy483;\n@@ -176048,1 +179226,1 @@\n-  yymsp[-2].minor.yy41 = yylhsminor.yy41;\n+  yymsp[-2].minor.yy483 = yylhsminor.yy483;\n@@ -176050,1 +179228,1 @@\n-      case 312: \/* windowdefn ::= nm AS LP window RP *\/\n+      case 315: \/* windowdefn ::= nm AS LP window RP *\/\n@@ -176052,2 +179230,2 @@\n-  if( ALWAYS(yymsp[-1].minor.yy41) ){\n-    yymsp[-1].minor.yy41->zName = sqlite3DbStrNDup(pParse->db, yymsp[-4].minor.yy0.z, yymsp[-4].minor.yy0.n);\n+  if( ALWAYS(yymsp[-1].minor.yy483) ){\n+    yymsp[-1].minor.yy483->zName = sqlite3DbStrNDup(pParse->db, yymsp[-4].minor.yy0.z, yymsp[-4].minor.yy0.n);\n@@ -176055,1 +179233,1 @@\n-  yylhsminor.yy41 = yymsp[-1].minor.yy41;\n+  yylhsminor.yy483 = yymsp[-1].minor.yy483;\n@@ -176057,1 +179235,1 @@\n-  yymsp[-4].minor.yy41 = yylhsminor.yy41;\n+  yymsp[-4].minor.yy483 = yylhsminor.yy483;\n@@ -176059,1 +179237,1 @@\n-      case 313: \/* window ::= PARTITION BY nexprlist orderby_opt frame_opt *\/\n+      case 316: \/* window ::= PARTITION BY nexprlist orderby_opt frame_opt *\/\n@@ -176061,1 +179239,1 @@\n-  yymsp[-4].minor.yy41 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy41, yymsp[-2].minor.yy322, yymsp[-1].minor.yy322, 0);\n+  yymsp[-4].minor.yy483 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy483, yymsp[-2].minor.yy402, yymsp[-1].minor.yy402, 0);\n@@ -176064,1 +179242,1 @@\n-      case 314: \/* window ::= nm PARTITION BY nexprlist orderby_opt frame_opt *\/\n+      case 317: \/* window ::= nm PARTITION BY nexprlist orderby_opt frame_opt *\/\n@@ -176066,1 +179244,1 @@\n-  yylhsminor.yy41 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy41, yymsp[-2].minor.yy322, yymsp[-1].minor.yy322, &yymsp[-5].minor.yy0);\n+  yylhsminor.yy483 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy483, yymsp[-2].minor.yy402, yymsp[-1].minor.yy402, &yymsp[-5].minor.yy0);\n@@ -176068,1 +179246,1 @@\n-  yymsp[-5].minor.yy41 = yylhsminor.yy41;\n+  yymsp[-5].minor.yy483 = yylhsminor.yy483;\n@@ -176070,1 +179248,1 @@\n-      case 315: \/* window ::= ORDER BY sortlist frame_opt *\/\n+      case 318: \/* window ::= ORDER BY sortlist frame_opt *\/\n@@ -176072,1 +179250,1 @@\n-  yymsp[-3].minor.yy41 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy41, 0, yymsp[-1].minor.yy322, 0);\n+  yymsp[-3].minor.yy483 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy483, 0, yymsp[-1].minor.yy402, 0);\n@@ -176075,1 +179253,1 @@\n-      case 316: \/* window ::= nm ORDER BY sortlist frame_opt *\/\n+      case 319: \/* window ::= nm ORDER BY sortlist frame_opt *\/\n@@ -176077,1 +179255,1 @@\n-  yylhsminor.yy41 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy41, 0, yymsp[-1].minor.yy322, &yymsp[-4].minor.yy0);\n+  yylhsminor.yy483 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy483, 0, yymsp[-1].minor.yy402, &yymsp[-4].minor.yy0);\n@@ -176079,1 +179257,1 @@\n-  yymsp[-4].minor.yy41 = yylhsminor.yy41;\n+  yymsp[-4].minor.yy483 = yylhsminor.yy483;\n@@ -176081,1 +179259,1 @@\n-      case 317: \/* window ::= nm frame_opt *\/\n+      case 320: \/* window ::= nm frame_opt *\/\n@@ -176083,1 +179261,1 @@\n-  yylhsminor.yy41 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy41, 0, 0, &yymsp[-1].minor.yy0);\n+  yylhsminor.yy483 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy483, 0, 0, &yymsp[-1].minor.yy0);\n@@ -176085,1 +179263,1 @@\n-  yymsp[-1].minor.yy41 = yylhsminor.yy41;\n+  yymsp[-1].minor.yy483 = yylhsminor.yy483;\n@@ -176087,1 +179265,1 @@\n-      case 318: \/* frame_opt ::= *\/\n+      case 321: \/* frame_opt ::= *\/\n@@ -176089,1 +179267,1 @@\n-  yymsp[1].minor.yy41 = sqlite3WindowAlloc(pParse, 0, TK_UNBOUNDED, 0, TK_CURRENT, 0, 0);\n+  yymsp[1].minor.yy483 = sqlite3WindowAlloc(pParse, 0, TK_UNBOUNDED, 0, TK_CURRENT, 0, 0);\n@@ -176092,1 +179270,1 @@\n-      case 319: \/* frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt *\/\n+      case 322: \/* frame_opt ::= range_or_rows frame_bound_s frame_exclude_opt *\/\n@@ -176094,1 +179272,1 @@\n-  yylhsminor.yy41 = sqlite3WindowAlloc(pParse, yymsp[-2].minor.yy394, yymsp[-1].minor.yy595.eType, yymsp[-1].minor.yy595.pExpr, TK_CURRENT, 0, yymsp[0].minor.yy516);\n+  yylhsminor.yy483 = sqlite3WindowAlloc(pParse, yymsp[-2].minor.yy502, yymsp[-1].minor.yy205.eType, yymsp[-1].minor.yy205.pExpr, TK_CURRENT, 0, yymsp[0].minor.yy444);\n@@ -176096,1 +179274,1 @@\n-  yymsp[-2].minor.yy41 = yylhsminor.yy41;\n+  yymsp[-2].minor.yy483 = yylhsminor.yy483;\n@@ -176098,1 +179276,1 @@\n-      case 320: \/* frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt *\/\n+      case 323: \/* frame_opt ::= range_or_rows BETWEEN frame_bound_s AND frame_bound_e frame_exclude_opt *\/\n@@ -176100,1 +179278,1 @@\n-  yylhsminor.yy41 = sqlite3WindowAlloc(pParse, yymsp[-5].minor.yy394, yymsp[-3].minor.yy595.eType, yymsp[-3].minor.yy595.pExpr, yymsp[-1].minor.yy595.eType, yymsp[-1].minor.yy595.pExpr, yymsp[0].minor.yy516);\n+  yylhsminor.yy483 = sqlite3WindowAlloc(pParse, yymsp[-5].minor.yy502, yymsp[-3].minor.yy205.eType, yymsp[-3].minor.yy205.pExpr, yymsp[-1].minor.yy205.eType, yymsp[-1].minor.yy205.pExpr, yymsp[0].minor.yy444);\n@@ -176102,1 +179280,1 @@\n-  yymsp[-5].minor.yy41 = yylhsminor.yy41;\n+  yymsp[-5].minor.yy483 = yylhsminor.yy483;\n@@ -176104,4 +179282,4 @@\n-      case 322: \/* frame_bound_s ::= frame_bound *\/\n-      case 324: \/* frame_bound_e ::= frame_bound *\/ yytestcase(yyruleno==324);\n-{yylhsminor.yy595 = yymsp[0].minor.yy595;}\n-  yymsp[0].minor.yy595 = yylhsminor.yy595;\n+      case 325: \/* frame_bound_s ::= frame_bound *\/\n+      case 327: \/* frame_bound_e ::= frame_bound *\/ yytestcase(yyruleno==327);\n+{yylhsminor.yy205 = yymsp[0].minor.yy205;}\n+  yymsp[0].minor.yy205 = yylhsminor.yy205;\n@@ -176109,5 +179287,5 @@\n-      case 323: \/* frame_bound_s ::= UNBOUNDED PRECEDING *\/\n-      case 325: \/* frame_bound_e ::= UNBOUNDED FOLLOWING *\/ yytestcase(yyruleno==325);\n-      case 327: \/* frame_bound ::= CURRENT ROW *\/ yytestcase(yyruleno==327);\n-{yylhsminor.yy595.eType = yymsp[-1].major; yylhsminor.yy595.pExpr = 0;}\n-  yymsp[-1].minor.yy595 = yylhsminor.yy595;\n+      case 326: \/* frame_bound_s ::= UNBOUNDED PRECEDING *\/\n+      case 328: \/* frame_bound_e ::= UNBOUNDED FOLLOWING *\/ yytestcase(yyruleno==328);\n+      case 330: \/* frame_bound ::= CURRENT ROW *\/ yytestcase(yyruleno==330);\n+{yylhsminor.yy205.eType = yymsp[-1].major; yylhsminor.yy205.pExpr = 0;}\n+  yymsp[-1].minor.yy205 = yylhsminor.yy205;\n@@ -176115,3 +179293,3 @@\n-      case 326: \/* frame_bound ::= expr PRECEDING|FOLLOWING *\/\n-{yylhsminor.yy595.eType = yymsp[0].major; yylhsminor.yy595.pExpr = yymsp[-1].minor.yy528;}\n-  yymsp[-1].minor.yy595 = yylhsminor.yy595;\n+      case 329: \/* frame_bound ::= expr PRECEDING|FOLLOWING *\/\n+{yylhsminor.yy205.eType = yymsp[0].major; yylhsminor.yy205.pExpr = yymsp[-1].minor.yy590;}\n+  yymsp[-1].minor.yy205 = yylhsminor.yy205;\n@@ -176119,2 +179297,2 @@\n-      case 328: \/* frame_exclude_opt ::= *\/\n-{yymsp[1].minor.yy516 = 0;}\n+      case 331: \/* frame_exclude_opt ::= *\/\n+{yymsp[1].minor.yy444 = 0;}\n@@ -176122,2 +179300,2 @@\n-      case 329: \/* frame_exclude_opt ::= EXCLUDE frame_exclude *\/\n-{yymsp[-1].minor.yy516 = yymsp[0].minor.yy516;}\n+      case 332: \/* frame_exclude_opt ::= EXCLUDE frame_exclude *\/\n+{yymsp[-1].minor.yy444 = yymsp[0].minor.yy444;}\n@@ -176125,3 +179303,3 @@\n-      case 330: \/* frame_exclude ::= NO OTHERS *\/\n-      case 331: \/* frame_exclude ::= CURRENT ROW *\/ yytestcase(yyruleno==331);\n-{yymsp[-1].minor.yy516 = yymsp[-1].major; \/*A-overwrites-X*\/}\n+      case 333: \/* frame_exclude ::= NO OTHERS *\/\n+      case 334: \/* frame_exclude ::= CURRENT ROW *\/ yytestcase(yyruleno==334);\n+{yymsp[-1].minor.yy444 = yymsp[-1].major; \/*A-overwrites-X*\/}\n@@ -176129,2 +179307,2 @@\n-      case 332: \/* frame_exclude ::= GROUP|TIES *\/\n-{yymsp[0].minor.yy516 = yymsp[0].major; \/*A-overwrites-X*\/}\n+      case 335: \/* frame_exclude ::= GROUP|TIES *\/\n+{yymsp[0].minor.yy444 = yymsp[0].major; \/*A-overwrites-X*\/}\n@@ -176132,2 +179310,2 @@\n-      case 333: \/* window_clause ::= WINDOW windowdefn_list *\/\n-{ yymsp[-1].minor.yy41 = yymsp[0].minor.yy41; }\n+      case 336: \/* window_clause ::= WINDOW windowdefn_list *\/\n+{ yymsp[-1].minor.yy483 = yymsp[0].minor.yy483; }\n@@ -176135,1 +179313,1 @@\n-      case 334: \/* filter_over ::= filter_clause over_clause *\/\n+      case 337: \/* filter_over ::= filter_clause over_clause *\/\n@@ -176137,2 +179315,2 @@\n-  if( yymsp[0].minor.yy41 ){\n-    yymsp[0].minor.yy41->pFilter = yymsp[-1].minor.yy528;\n+  if( yymsp[0].minor.yy483 ){\n+    yymsp[0].minor.yy483->pFilter = yymsp[-1].minor.yy590;\n@@ -176140,1 +179318,1 @@\n-    sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy528);\n+    sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy590);\n@@ -176142,1 +179320,1 @@\n-  yylhsminor.yy41 = yymsp[0].minor.yy41;\n+  yylhsminor.yy483 = yymsp[0].minor.yy483;\n@@ -176144,1 +179322,1 @@\n-  yymsp[-1].minor.yy41 = yylhsminor.yy41;\n+  yymsp[-1].minor.yy483 = yylhsminor.yy483;\n@@ -176146,1 +179324,1 @@\n-      case 335: \/* filter_over ::= over_clause *\/\n+      case 338: \/* filter_over ::= over_clause *\/\n@@ -176148,1 +179326,1 @@\n-  yylhsminor.yy41 = yymsp[0].minor.yy41;\n+  yylhsminor.yy483 = yymsp[0].minor.yy483;\n@@ -176150,1 +179328,1 @@\n-  yymsp[0].minor.yy41 = yylhsminor.yy41;\n+  yymsp[0].minor.yy483 = yylhsminor.yy483;\n@@ -176152,1 +179330,1 @@\n-      case 336: \/* filter_over ::= filter_clause *\/\n+      case 339: \/* filter_over ::= filter_clause *\/\n@@ -176154,4 +179332,4 @@\n-  yylhsminor.yy41 = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));\n-  if( yylhsminor.yy41 ){\n-    yylhsminor.yy41->eFrmType = TK_FILTER;\n-    yylhsminor.yy41->pFilter = yymsp[0].minor.yy528;\n+  yylhsminor.yy483 = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));\n+  if( yylhsminor.yy483 ){\n+    yylhsminor.yy483->eFrmType = TK_FILTER;\n+    yylhsminor.yy483->pFilter = yymsp[0].minor.yy590;\n@@ -176159,1 +179337,1 @@\n-    sqlite3ExprDelete(pParse->db, yymsp[0].minor.yy528);\n+    sqlite3ExprDelete(pParse->db, yymsp[0].minor.yy590);\n@@ -176162,1 +179340,1 @@\n-  yymsp[0].minor.yy41 = yylhsminor.yy41;\n+  yymsp[0].minor.yy483 = yylhsminor.yy483;\n@@ -176164,1 +179342,1 @@\n-      case 337: \/* over_clause ::= OVER LP window RP *\/\n+      case 340: \/* over_clause ::= OVER LP window RP *\/\n@@ -176166,2 +179344,2 @@\n-  yymsp[-3].minor.yy41 = yymsp[-1].minor.yy41;\n-  assert( yymsp[-3].minor.yy41!=0 );\n+  yymsp[-3].minor.yy483 = yymsp[-1].minor.yy483;\n+  assert( yymsp[-3].minor.yy483!=0 );\n@@ -176170,1 +179348,1 @@\n-      case 338: \/* over_clause ::= OVER nm *\/\n+      case 341: \/* over_clause ::= OVER nm *\/\n@@ -176172,3 +179350,3 @@\n-  yymsp[-1].minor.yy41 = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));\n-  if( yymsp[-1].minor.yy41 ){\n-    yymsp[-1].minor.yy41->zName = sqlite3DbStrNDup(pParse->db, yymsp[0].minor.yy0.z, yymsp[0].minor.yy0.n);\n+  yymsp[-1].minor.yy483 = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));\n+  if( yymsp[-1].minor.yy483 ){\n+    yymsp[-1].minor.yy483->zName = sqlite3DbStrNDup(pParse->db, yymsp[0].minor.yy0.z, yymsp[0].minor.yy0.n);\n@@ -176178,2 +179356,9 @@\n-      case 339: \/* filter_clause ::= FILTER LP WHERE expr RP *\/\n-{ yymsp[-4].minor.yy528 = yymsp[-1].minor.yy528; }\n+      case 342: \/* filter_clause ::= FILTER LP WHERE expr RP *\/\n+{ yymsp[-4].minor.yy590 = yymsp[-1].minor.yy590; }\n+        break;\n+      case 343: \/* term ::= QNUMBER *\/\n+{\n+  yylhsminor.yy590=tokenExpr(pParse,yymsp[0].major,yymsp[0].minor.yy0);\n+  sqlite3DequoteNumber(pParse, yylhsminor.yy590);\n+}\n+  yymsp[0].minor.yy590 = yylhsminor.yy590;\n@@ -176182,65 +179367,65 @@\n-      \/* (340) input ::= cmdlist *\/ yytestcase(yyruleno==340);\n-      \/* (341) cmdlist ::= cmdlist ecmd *\/ yytestcase(yyruleno==341);\n-      \/* (342) cmdlist ::= ecmd (OPTIMIZED OUT) *\/ assert(yyruleno!=342);\n-      \/* (343) ecmd ::= SEMI *\/ yytestcase(yyruleno==343);\n-      \/* (344) ecmd ::= cmdx SEMI *\/ yytestcase(yyruleno==344);\n-      \/* (345) ecmd ::= explain cmdx SEMI (NEVER REDUCES) *\/ assert(yyruleno!=345);\n-      \/* (346) trans_opt ::= *\/ yytestcase(yyruleno==346);\n-      \/* (347) trans_opt ::= TRANSACTION *\/ yytestcase(yyruleno==347);\n-      \/* (348) trans_opt ::= TRANSACTION nm *\/ yytestcase(yyruleno==348);\n-      \/* (349) savepoint_opt ::= SAVEPOINT *\/ yytestcase(yyruleno==349);\n-      \/* (350) savepoint_opt ::= *\/ yytestcase(yyruleno==350);\n-      \/* (351) cmd ::= create_table create_table_args *\/ yytestcase(yyruleno==351);\n-      \/* (352) table_option_set ::= table_option (OPTIMIZED OUT) *\/ assert(yyruleno!=352);\n-      \/* (353) columnlist ::= columnlist COMMA columnname carglist *\/ yytestcase(yyruleno==353);\n-      \/* (354) columnlist ::= columnname carglist *\/ yytestcase(yyruleno==354);\n-      \/* (355) nm ::= ID|INDEXED|JOIN_KW *\/ yytestcase(yyruleno==355);\n-      \/* (356) nm ::= STRING *\/ yytestcase(yyruleno==356);\n-      \/* (357) typetoken ::= typename *\/ yytestcase(yyruleno==357);\n-      \/* (358) typename ::= ID|STRING *\/ yytestcase(yyruleno==358);\n-      \/* (359) signed ::= plus_num (OPTIMIZED OUT) *\/ assert(yyruleno!=359);\n-      \/* (360) signed ::= minus_num (OPTIMIZED OUT) *\/ assert(yyruleno!=360);\n-      \/* (361) carglist ::= carglist ccons *\/ yytestcase(yyruleno==361);\n-      \/* (362) carglist ::= *\/ yytestcase(yyruleno==362);\n-      \/* (363) ccons ::= NULL onconf *\/ yytestcase(yyruleno==363);\n-      \/* (364) ccons ::= GENERATED ALWAYS AS generated *\/ yytestcase(yyruleno==364);\n-      \/* (365) ccons ::= AS generated *\/ yytestcase(yyruleno==365);\n-      \/* (366) conslist_opt ::= COMMA conslist *\/ yytestcase(yyruleno==366);\n-      \/* (367) conslist ::= conslist tconscomma tcons *\/ yytestcase(yyruleno==367);\n-      \/* (368) conslist ::= tcons (OPTIMIZED OUT) *\/ assert(yyruleno!=368);\n-      \/* (369) tconscomma ::= *\/ yytestcase(yyruleno==369);\n-      \/* (370) defer_subclause_opt ::= defer_subclause (OPTIMIZED OUT) *\/ assert(yyruleno!=370);\n-      \/* (371) resolvetype ::= raisetype (OPTIMIZED OUT) *\/ assert(yyruleno!=371);\n-      \/* (372) selectnowith ::= oneselect (OPTIMIZED OUT) *\/ assert(yyruleno!=372);\n-      \/* (373) oneselect ::= values *\/ yytestcase(yyruleno==373);\n-      \/* (374) sclp ::= selcollist COMMA *\/ yytestcase(yyruleno==374);\n-      \/* (375) as ::= ID|STRING *\/ yytestcase(yyruleno==375);\n-      \/* (376) indexed_opt ::= indexed_by (OPTIMIZED OUT) *\/ assert(yyruleno!=376);\n-      \/* (377) returning ::= *\/ yytestcase(yyruleno==377);\n-      \/* (378) expr ::= term (OPTIMIZED OUT) *\/ assert(yyruleno!=378);\n-      \/* (379) likeop ::= LIKE_KW|MATCH *\/ yytestcase(yyruleno==379);\n-      \/* (380) case_operand ::= expr *\/ yytestcase(yyruleno==380);\n-      \/* (381) exprlist ::= nexprlist *\/ yytestcase(yyruleno==381);\n-      \/* (382) nmnum ::= plus_num (OPTIMIZED OUT) *\/ assert(yyruleno!=382);\n-      \/* (383) nmnum ::= nm (OPTIMIZED OUT) *\/ assert(yyruleno!=383);\n-      \/* (384) nmnum ::= ON *\/ yytestcase(yyruleno==384);\n-      \/* (385) nmnum ::= DELETE *\/ yytestcase(yyruleno==385);\n-      \/* (386) nmnum ::= DEFAULT *\/ yytestcase(yyruleno==386);\n-      \/* (387) plus_num ::= INTEGER|FLOAT *\/ yytestcase(yyruleno==387);\n-      \/* (388) foreach_clause ::= *\/ yytestcase(yyruleno==388);\n-      \/* (389) foreach_clause ::= FOR EACH ROW *\/ yytestcase(yyruleno==389);\n-      \/* (390) trnm ::= nm *\/ yytestcase(yyruleno==390);\n-      \/* (391) tridxby ::= *\/ yytestcase(yyruleno==391);\n-      \/* (392) database_kw_opt ::= DATABASE *\/ yytestcase(yyruleno==392);\n-      \/* (393) database_kw_opt ::= *\/ yytestcase(yyruleno==393);\n-      \/* (394) kwcolumn_opt ::= *\/ yytestcase(yyruleno==394);\n-      \/* (395) kwcolumn_opt ::= COLUMNKW *\/ yytestcase(yyruleno==395);\n-      \/* (396) vtabarglist ::= vtabarg *\/ yytestcase(yyruleno==396);\n-      \/* (397) vtabarglist ::= vtabarglist COMMA vtabarg *\/ yytestcase(yyruleno==397);\n-      \/* (398) vtabarg ::= vtabarg vtabargtoken *\/ yytestcase(yyruleno==398);\n-      \/* (399) anylist ::= *\/ yytestcase(yyruleno==399);\n-      \/* (400) anylist ::= anylist LP anylist RP *\/ yytestcase(yyruleno==400);\n-      \/* (401) anylist ::= anylist ANY *\/ yytestcase(yyruleno==401);\n-      \/* (402) with ::= *\/ yytestcase(yyruleno==402);\n-      \/* (403) windowdefn_list ::= windowdefn (OPTIMIZED OUT) *\/ assert(yyruleno!=403);\n-      \/* (404) window ::= frame_opt (OPTIMIZED OUT) *\/ assert(yyruleno!=404);\n+      \/* (344) input ::= cmdlist *\/ yytestcase(yyruleno==344);\n+      \/* (345) cmdlist ::= cmdlist ecmd *\/ yytestcase(yyruleno==345);\n+      \/* (346) cmdlist ::= ecmd (OPTIMIZED OUT) *\/ assert(yyruleno!=346);\n+      \/* (347) ecmd ::= SEMI *\/ yytestcase(yyruleno==347);\n+      \/* (348) ecmd ::= cmdx SEMI *\/ yytestcase(yyruleno==348);\n+      \/* (349) ecmd ::= explain cmdx SEMI (NEVER REDUCES) *\/ assert(yyruleno!=349);\n+      \/* (350) trans_opt ::= *\/ yytestcase(yyruleno==350);\n+      \/* (351) trans_opt ::= TRANSACTION *\/ yytestcase(yyruleno==351);\n+      \/* (352) trans_opt ::= TRANSACTION nm *\/ yytestcase(yyruleno==352);\n+      \/* (353) savepoint_opt ::= SAVEPOINT *\/ yytestcase(yyruleno==353);\n+      \/* (354) savepoint_opt ::= *\/ yytestcase(yyruleno==354);\n+      \/* (355) cmd ::= create_table create_table_args *\/ yytestcase(yyruleno==355);\n+      \/* (356) table_option_set ::= table_option (OPTIMIZED OUT) *\/ assert(yyruleno!=356);\n+      \/* (357) columnlist ::= columnlist COMMA columnname carglist *\/ yytestcase(yyruleno==357);\n+      \/* (358) columnlist ::= columnname carglist *\/ yytestcase(yyruleno==358);\n+      \/* (359) nm ::= ID|INDEXED|JOIN_KW *\/ yytestcase(yyruleno==359);\n+      \/* (360) nm ::= STRING *\/ yytestcase(yyruleno==360);\n+      \/* (361) typetoken ::= typename *\/ yytestcase(yyruleno==361);\n+      \/* (362) typename ::= ID|STRING *\/ yytestcase(yyruleno==362);\n+      \/* (363) signed ::= plus_num (OPTIMIZED OUT) *\/ assert(yyruleno!=363);\n+      \/* (364) signed ::= minus_num (OPTIMIZED OUT) *\/ assert(yyruleno!=364);\n+      \/* (365) carglist ::= carglist ccons *\/ yytestcase(yyruleno==365);\n+      \/* (366) carglist ::= *\/ yytestcase(yyruleno==366);\n+      \/* (367) ccons ::= NULL onconf *\/ yytestcase(yyruleno==367);\n+      \/* (368) ccons ::= GENERATED ALWAYS AS generated *\/ yytestcase(yyruleno==368);\n+      \/* (369) ccons ::= AS generated *\/ yytestcase(yyruleno==369);\n+      \/* (370) conslist_opt ::= COMMA conslist *\/ yytestcase(yyruleno==370);\n+      \/* (371) conslist ::= conslist tconscomma tcons *\/ yytestcase(yyruleno==371);\n+      \/* (372) conslist ::= tcons (OPTIMIZED OUT) *\/ assert(yyruleno!=372);\n+      \/* (373) tconscomma ::= *\/ yytestcase(yyruleno==373);\n+      \/* (374) defer_subclause_opt ::= defer_subclause (OPTIMIZED OUT) *\/ assert(yyruleno!=374);\n+      \/* (375) resolvetype ::= raisetype (OPTIMIZED OUT) *\/ assert(yyruleno!=375);\n+      \/* (376) selectnowith ::= oneselect (OPTIMIZED OUT) *\/ assert(yyruleno!=376);\n+      \/* (377) oneselect ::= values *\/ yytestcase(yyruleno==377);\n+      \/* (378) sclp ::= selcollist COMMA *\/ yytestcase(yyruleno==378);\n+      \/* (379) as ::= ID|STRING *\/ yytestcase(yyruleno==379);\n+      \/* (380) indexed_opt ::= indexed_by (OPTIMIZED OUT) *\/ assert(yyruleno!=380);\n+      \/* (381) returning ::= *\/ yytestcase(yyruleno==381);\n+      \/* (382) expr ::= term (OPTIMIZED OUT) *\/ assert(yyruleno!=382);\n+      \/* (383) likeop ::= LIKE_KW|MATCH *\/ yytestcase(yyruleno==383);\n+      \/* (384) case_operand ::= expr *\/ yytestcase(yyruleno==384);\n+      \/* (385) exprlist ::= nexprlist *\/ yytestcase(yyruleno==385);\n+      \/* (386) nmnum ::= plus_num (OPTIMIZED OUT) *\/ assert(yyruleno!=386);\n+      \/* (387) nmnum ::= nm (OPTIMIZED OUT) *\/ assert(yyruleno!=387);\n+      \/* (388) nmnum ::= ON *\/ yytestcase(yyruleno==388);\n+      \/* (389) nmnum ::= DELETE *\/ yytestcase(yyruleno==389);\n+      \/* (390) nmnum ::= DEFAULT *\/ yytestcase(yyruleno==390);\n+      \/* (391) plus_num ::= INTEGER|FLOAT *\/ yytestcase(yyruleno==391);\n+      \/* (392) foreach_clause ::= *\/ yytestcase(yyruleno==392);\n+      \/* (393) foreach_clause ::= FOR EACH ROW *\/ yytestcase(yyruleno==393);\n+      \/* (394) trnm ::= nm *\/ yytestcase(yyruleno==394);\n+      \/* (395) tridxby ::= *\/ yytestcase(yyruleno==395);\n+      \/* (396) database_kw_opt ::= DATABASE *\/ yytestcase(yyruleno==396);\n+      \/* (397) database_kw_opt ::= *\/ yytestcase(yyruleno==397);\n+      \/* (398) kwcolumn_opt ::= *\/ yytestcase(yyruleno==398);\n+      \/* (399) kwcolumn_opt ::= COLUMNKW *\/ yytestcase(yyruleno==399);\n+      \/* (400) vtabarglist ::= vtabarg *\/ yytestcase(yyruleno==400);\n+      \/* (401) vtabarglist ::= vtabarglist COMMA vtabarg *\/ yytestcase(yyruleno==401);\n+      \/* (402) vtabarg ::= vtabarg vtabargtoken *\/ yytestcase(yyruleno==402);\n+      \/* (403) anylist ::= *\/ yytestcase(yyruleno==403);\n+      \/* (404) anylist ::= anylist LP anylist RP *\/ yytestcase(yyruleno==404);\n+      \/* (405) anylist ::= anylist ANY *\/ yytestcase(yyruleno==405);\n+      \/* (406) with ::= *\/ yytestcase(yyruleno==406);\n+      \/* (407) windowdefn_list ::= windowdefn (OPTIMIZED OUT) *\/ assert(yyruleno!=407);\n+      \/* (408) window ::= frame_opt (OPTIMIZED OUT) *\/ assert(yyruleno!=408);\n@@ -176309,1 +179494,1 @@\n-    sqlite3ErrorMsg(pParse, \"near \\\"%T\\\": syntax error\", &TOKEN);\n+    parserSyntaxError(pParse, &TOKEN);\n@@ -176433,1 +179618,0 @@\n-#if YYSTACKDEPTH>0\n@@ -176435,5 +179619,0 @@\n-          yyStackOverflow(yypParser);\n-          break;\n-        }\n-#else\n-        if( yypParser->yytos>=&yypParser->yystack[yypParser->yystksz-1] ){\n@@ -176445,1 +179624,0 @@\n-#endif\n@@ -177367,1 +180545,1 @@\n-        *tokenType = TK_SPACE;   \/* IMP: R-22934-25134 *\/\n+        *tokenType = TK_COMMENT;\n@@ -177403,1 +180581,1 @@\n-      *tokenType = TK_SPACE;   \/* IMP: R-22934-25134 *\/\n+      *tokenType = TK_COMMENT;\n@@ -177516,3 +180694,10 @@\n-        for(i=3; sqlite3Isxdigit(z[i]); i++){}\n-        return i;\n-      }\n+        for(i=3; 1; i++){\n+          if( sqlite3Isxdigit(z[i])==0 ){\n+            if( z[i]==SQLITE_DIGIT_SEPARATOR ){\n+              *tokenType = TK_QNUMBER;\n+            }else{\n+              break;\n+            }\n+          }\n+        }\n+      }else\n@@ -177520,1 +180705,10 @@\n-      for(i=0; sqlite3Isdigit(z[i]); i++){}\n+        {\n+        for(i=0; 1; i++){\n+          if( sqlite3Isdigit(z[i])==0 ){\n+            if( z[i]==SQLITE_DIGIT_SEPARATOR ){\n+              *tokenType = TK_QNUMBER;\n+            }else{\n+              break;\n+            }\n+          }\n+        }\n@@ -177522,14 +180716,28 @@\n-      if( z[i]=='.' ){\n-        i++;\n-        while( sqlite3Isdigit(z[i]) ){ i++; }\n-        *tokenType = TK_FLOAT;\n-      }\n-      if( (z[i]=='e' || z[i]=='E') &&\n-           ( sqlite3Isdigit(z[i+1])\n-            || ((z[i+1]=='+' || z[i+1]=='-') && sqlite3Isdigit(z[i+2]))\n-           )\n-      ){\n-        i += 2;\n-        while( sqlite3Isdigit(z[i]) ){ i++; }\n-        *tokenType = TK_FLOAT;\n-      }\n+        if( z[i]=='.' ){\n+          if( *tokenType==TK_INTEGER ) *tokenType = TK_FLOAT;\n+          for(i++; 1; i++){\n+            if( sqlite3Isdigit(z[i])==0 ){\n+              if( z[i]==SQLITE_DIGIT_SEPARATOR ){\n+                *tokenType = TK_QNUMBER;\n+              }else{\n+                break;\n+              }\n+            }\n+          }\n+        }\n+        if( (z[i]=='e' || z[i]=='E') &&\n+             ( sqlite3Isdigit(z[i+1])\n+              || ((z[i+1]=='+' || z[i+1]=='-') && sqlite3Isdigit(z[i+2]))\n+             )\n+        ){\n+          if( *tokenType==TK_INTEGER ) *tokenType = TK_FLOAT;\n+          for(i+=2; 1; i++){\n+            if( sqlite3Isdigit(z[i])==0 ){\n+              if( z[i]==SQLITE_DIGIT_SEPARATOR ){\n+                *tokenType = TK_QNUMBER;\n+              }else{\n+                break;\n+              }\n+            }\n+          }\n+        }\n@@ -177537,0 +180745,1 @@\n+      }\n@@ -177701,0 +180910,1 @@\n+           || tokenType==TK_QNUMBER || tokenType==TK_COMMENT\n@@ -177704,1 +180914,3 @@\n-      assert( tokenType==TK_SPACE || tokenType==TK_ILLEGAL );\n+      assert( tokenType==TK_SPACE || tokenType==TK_ILLEGAL\n+           || tokenType==TK_QNUMBER || tokenType==TK_COMMENT\n+      );\n@@ -177737,1 +180949,4 @@\n-      }else{\n+      }else if( tokenType==TK_COMMENT && (db->flags & SQLITE_Comments)!=0 ){\n+        zSql += n;\n+        continue;\n+      }else if( tokenType!=TK_QNUMBER ){\n@@ -177773,1 +180988,3 @@\n-    sqlite3_log(pParse->rc, \"%s in \\\"%s\\\"\", pParse->zErrMsg, pParse->zTail);\n+    if( (pParse->prepFlags & SQLITE_PREPARE_DONT_LOG)==0 ){\n+      sqlite3_log(pParse->rc, \"%s in \\\"%s\\\"\", pParse->zErrMsg, pParse->zTail);\n+    }\n@@ -177841,0 +181058,1 @@\n+      case TK_COMMENT:\n@@ -178482,26 +181700,0 @@\n-\/*\n-** Determine whether or not high-precision (long double) floating point\n-** math works correctly on CPU currently running.\n-*\/\n-static SQLITE_NOINLINE int hasHighPrecisionDouble(int rc){\n-  if( sizeof(LONGDOUBLE_TYPE)<=8 ){\n-    \/* If the size of \"long double\" is not more than 8, then\n-    ** high-precision math is not possible. *\/\n-    return 0;\n-  }else{\n-    \/* Just because sizeof(long double)>8 does not mean that the underlying\n-    ** hardware actually supports high-precision floating point.  For example,\n-    ** clearing the 0x100 bit in the floating-point control word on Intel\n-    ** processors will make long double work like double, even though long\n-    ** double takes up more space.  The only way to determine if long double\n-    ** actually works is to run an experiment. *\/\n-    LONGDOUBLE_TYPE a, b, c;\n-    rc++;\n-    a = 1.0+rc*0.1;\n-    b = 1.0e+18+rc*25.0;\n-    c = a+b;\n-    return b!=c;\n-  }\n-}\n-\n-\n@@ -178702,7 +181894,0 @@\n-\n-  \/* Experimentally determine if high-precision floating point is\n-  ** available. *\/\n-#ifndef SQLITE_OMIT_WSD\n-  sqlite3Config.bUseLongDouble = hasHighPrecisionDouble(rc);\n-#endif\n-\n@@ -179123,1 +182308,1 @@\n-  sqlite3_int64 szAlloc = sz*(sqlite3_int64)cnt;\n+  sqlite3_int64 szAlloc;\n@@ -179142,0 +182327,1 @@\n+  if( sz>65528 ) sz = 65528;\n@@ -179143,0 +182329,1 @@\n+  szAlloc = (i64)sz*(i64)cnt;\n@@ -179157,1 +182344,1 @@\n-    nSm = (szAlloc - sz*nBig)\/LOOKASIDE_SMALL;\n+    nSm = (szAlloc - (i64)sz*(i64)nBig)\/LOOKASIDE_SMALL;\n@@ -179160,1 +182347,1 @@\n-    nSm = (szAlloc - sz*nBig)\/LOOKASIDE_SMALL;\n+    nSm = (szAlloc - (i64)sz*(i64)nBig)\/LOOKASIDE_SMALL;\n@@ -179315,1 +182502,1 @@\n-        u32 mask;    \/* Mask of the bit in sqlite3.flags to set\/clear *\/\n+        u64 mask;    \/* Mask of the bit in sqlite3.flags to set\/clear *\/\n@@ -179336,0 +182523,3 @@\n+        { SQLITE_DBCONFIG_ENABLE_ATTACH_CREATE,  SQLITE_AttachCreate   },\n+        { SQLITE_DBCONFIG_ENABLE_ATTACH_WRITE,   SQLITE_AttachWrite    },\n+        { SQLITE_DBCONFIG_ENABLE_COMMENTS,       SQLITE_Comments       },\n@@ -179779,4 +182969,0 @@\n-#if SQLITE_USER_AUTHENTICATION\n-  sqlite3_free(db->auth.zAuthUser);\n-  sqlite3_free(db->auth.zAuthPW);\n-#endif\n@@ -180249,1 +183435,2 @@\n-                       SQLITE_SUBTYPE|SQLITE_INNOCUOUS|SQLITE_RESULT_SUBTYPE);\n+                       SQLITE_SUBTYPE|SQLITE_INNOCUOUS|\n+                       SQLITE_RESULT_SUBTYPE|SQLITE_SELFORDER1);\n@@ -181216,2 +184403,2 @@\n-#if SQLITE_MAX_FUNCTION_ARG<0 || SQLITE_MAX_FUNCTION_ARG>127\n-# error SQLITE_MAX_FUNCTION_ARG must be between 0 and 127\n+#if SQLITE_MAX_FUNCTION_ARG<0 || SQLITE_MAX_FUNCTION_ARG>32767\n+# error SQLITE_MAX_FUNCTION_ARG must be between 0 and 32767\n@@ -181284,2 +184471,2 @@\n-    }else if( newLimit<1 && limitId==SQLITE_LIMIT_LENGTH ){\n-      newLimit = 1;\n+    }else if( newLimit<SQLITE_MIN_LENGTH && limitId==SQLITE_LIMIT_LENGTH ){\n+      newLimit = SQLITE_MIN_LENGTH;\n@@ -181680,0 +184867,3 @@\n+                 | SQLITE_AttachCreate\n+                 | SQLITE_AttachWrite\n+                 | SQLITE_Comments\n@@ -181804,0 +184994,1 @@\n+    if( zFilename==0 ) zFilename = \":memory:\";\n@@ -182628,1 +185819,0 @@\n-        sqlite3ShowExpr(0);\n@@ -182716,0 +185906,12 @@\n+    \/*  sqlite3_test_control(SQLITE_TESTCTRL_GETOPT, sqlite3 *db, int *N)\n+    **\n+    ** Write the current optimization settings into *N.  A zero bit means that\n+    ** the optimization is on, and a 1 bit means that the optimization is off.\n+    *\/\n+    case SQLITE_TESTCTRL_GETOPT: {\n+      sqlite3 *db = va_arg(ap, sqlite3*);\n+      int *pN = va_arg(ap, int*);\n+      *pN = db->dbOptFlags;\n+      break;\n+    }\n+\n@@ -182947,18 +186149,0 @@\n-#if !defined(SQLITE_OMIT_WSD)\n-    \/* sqlite3_test_control(SQLITE_TESTCTRL_USELONGDOUBLE, int X);\n-    **\n-    **   X<0     Make no changes to the bUseLongDouble.  Just report value.\n-    **   X==0    Disable bUseLongDouble\n-    **   X==1    Enable bUseLongDouble\n-    **   X>=2    Set bUseLongDouble to its default value for this platform\n-    *\/\n-    case SQLITE_TESTCTRL_USELONGDOUBLE: {\n-      int b = va_arg(ap, int);\n-      if( b>=2 ) b = hasHighPrecisionDouble(b);\n-      if( b>=0 ) sqlite3Config.bUseLongDouble = b>0;\n-      rc = sqlite3Config.bUseLongDouble!=0;\n-      break;\n-    }\n-#endif\n-\n-\n@@ -183272,0 +186456,3 @@\n+        Pager *pPager = sqlite3BtreePager(pBt);\n+        i64 dummy = 0;\n+        sqlite3PagerSnapshotOpen(pPager, (sqlite3_snapshot*)&dummy);\n@@ -183273,0 +186460,1 @@\n+        sqlite3PagerSnapshotOpen(pPager, 0);\n@@ -184987,0 +188175,1 @@\n+SQLITE_PRIVATE int sqlite3Fts3MsrCancel(Fts3Cursor*, Fts3Expr*);\n@@ -187062,0 +190251,3 @@\n+    \/* iCol1==0 indicates corruption. Column 0 does not have a POS_COLUMN\n+    ** entry, so this is actually end-of-doclist. *\/\n+    if( iCol1==0 ) return 0;\n@@ -187066,0 +190258,2 @@\n+    \/* As above, iCol2==0 indicates corruption. *\/\n+    if( iCol2==0 ) return 0;\n@@ -188732,1 +191926,1 @@\n-  int rc;\n+  int rc = SQLITE_OK;\n@@ -188737,2 +191931,2 @@\n-  assert( rc!=SQLITE_CORRUPT_VTAB || bOk==0 );\n-  if( rc!=SQLITE_OK && rc!=SQLITE_CORRUPT_VTAB ){\n+  assert( rc!=SQLITE_CORRUPT_VTAB );\n+  if( rc==SQLITE_ERROR || (rc&0xFF)==SQLITE_CORRUPT ){\n@@ -188742,1 +191936,2 @@\n-  }else if( bOk==0 ){\n+    if( *pzErr ) rc = SQLITE_OK;\n+  }else if( rc==SQLITE_OK && bOk==0 ){\n@@ -188745,0 +191940,1 @@\n+    if( *pzErr==0 ) rc = SQLITE_NOMEM;\n@@ -188747,1 +191943,1 @@\n-  return SQLITE_OK;\n+  return rc;\n@@ -190234,1 +193430,1 @@\n-    aTmp = sqlite3_malloc64(nTmp*2);\n+    aTmp = sqlite3_malloc64(nTmp*2 + FTS3_VARINT_MAX);\n@@ -190498,0 +193694,18 @@\n+\/*\n+** Expression node pExpr is an MSR phrase. This function restarts pExpr\n+** so that it is a regular phrase query, not an MSR. SQLITE_OK is returned\n+** if successful, or an SQLite error code otherwise.\n+*\/\n+SQLITE_PRIVATE int sqlite3Fts3MsrCancel(Fts3Cursor *pCsr, Fts3Expr *pExpr){\n+  int rc = SQLITE_OK;\n+  if( pExpr->bEof==0 ){\n+    i64 iDocid = pExpr->iDocid;\n+    fts3EvalRestart(pCsr, pExpr, &rc);\n+    while( rc==SQLITE_OK && pExpr->iDocid!=iDocid ){\n+      fts3EvalNextRow(pCsr, pExpr, &rc);\n+      if( pExpr->bEof ) rc = FTS_CORRUPT_VTAB;\n+    }\n+  }\n+  return rc;\n+}\n+\n@@ -190885,1 +194099,1 @@\n-#if !SQLITE_CORE\n+#if !defined(SQLITE_CORE)\n@@ -191787,2 +195001,0 @@\n-        if( !p ) goto no_mem;\n-\n@@ -191790,1 +195002,4 @@\n-        if( !zTemp ) goto no_mem;\n+        if( !zTemp || !p ){\n+          rc = SQLITE_NOMEM;\n+          goto getnextstring_out;\n+        }\n@@ -191805,3 +195020,0 @@\n-\n-    pModule->xClose(pCursor);\n-    pCursor = 0;\n@@ -191815,1 +195027,4 @@\n-    if( !p ) goto no_mem;\n+    if( !p ){\n+      rc = SQLITE_NOMEM;\n+      goto getnextstring_out;\n+    }\n@@ -191823,0 +195038,1 @@\n+    assert( nTemp==0 || zTemp );\n@@ -191825,3 +195041,0 @@\n-      sqlite3_free(zTemp);\n-    }else{\n-      assert( nTemp==0 );\n@@ -191837,4 +195050,1 @@\n-  *ppExpr = p;\n-  return rc;\n-no_mem:\n-\n+ getnextstring_out:\n@@ -191845,3 +195055,6 @@\n-  sqlite3_free(p);\n-  *ppExpr = 0;\n-  return SQLITE_NOMEM;\n+  if( rc!=SQLITE_OK ){\n+    sqlite3_free(p);\n+    p = 0;\n+  }\n+  *ppExpr = p;\n+  return rc;\n@@ -194041,5 +197254,1 @@\n-#if defined(INCLUDE_SQLITE_TCL_H)\n-#  include \"sqlite_tcl.h\"\n-#else\n-#  include \"tcl.h\"\n-#endif\n+#include \"tclsqlite.h\"\n@@ -200409,1 +203618,6 @@\n-  *pbOk = (rc==SQLITE_OK && cksum1==cksum2);\n+  if( rc==SQLITE_CORRUPT_VTAB ){\n+    rc = SQLITE_OK;\n+    *pbOk = 0;\n+  }else{\n+    *pbOk = (rc==SQLITE_OK && cksum1==cksum2);\n+  }\n@@ -201267,0 +204481,1 @@\n+    assert( pIter->nSnippet>=0 );\n@@ -201315,1 +204530,1 @@\n-        for(j=0; j<pPhrase->nToken; j++){\n+        for(j=0; j<pPhrase->nToken && j<pIter->nSnippet; j++){\n@@ -202454,0 +205669,16 @@\n+\/*\n+** If expression pExpr is a phrase expression that uses an MSR query,\n+** restart it as a regular, non-incremental query. Return SQLITE_OK\n+** if successful, or an SQLite error code otherwise.\n+*\/\n+static int fts3ExprRestartIfCb(Fts3Expr *pExpr, int iPhrase, void *ctx){\n+  TermOffsetCtx *p = (TermOffsetCtx*)ctx;\n+  int rc = SQLITE_OK;\n+  UNUSED_PARAMETER(iPhrase);\n+  if( pExpr->pPhrase && pExpr->pPhrase->bIncr ){\n+    rc = sqlite3Fts3MsrCancel(p->pCsr, pExpr);\n+    pExpr->pPhrase->bIncr = 0;\n+  }\n+  return rc;\n+}\n+\n@@ -202490,0 +205721,6 @@\n+  \/* If a query restart will be required, do it here, rather than later of\n+  ** after pointers to poslist buffers that may be invalidated by a restart\n+  ** have been saved.  *\/\n+  rc = sqlite3Fts3ExprIterate(pCsr->pExpr, fts3ExprRestartIfCb, (void*)&sCtx);\n+  if( rc!=SQLITE_OK ) goto offsets_out;\n+\n@@ -203976,1 +207213,0 @@\n-\n@@ -204034,0 +207270,34 @@\n+\/* c is a control character.  Append the canonical JSON representation\n+** of that control character to p.\n+**\n+** This routine assumes that the output buffer has already been enlarged\n+** sufficiently to hold the worst-case encoding plus a nul terminator.\n+*\/\n+static void jsonAppendControlChar(JsonString *p, u8 c){\n+  static const char aSpecial[] = {\n+     0, 0, 0, 0, 0, 0, 0, 0, 'b', 't', 'n', 0, 'f', 'r', 0, 0,\n+     0, 0, 0, 0, 0, 0, 0, 0,   0,   0,   0, 0,   0,   0, 0, 0\n+  };\n+  assert( sizeof(aSpecial)==32 );\n+  assert( aSpecial['\\b']=='b' );\n+  assert( aSpecial['\\f']=='f' );\n+  assert( aSpecial['\\n']=='n' );\n+  assert( aSpecial['\\r']=='r' );\n+  assert( aSpecial['\\t']=='t' );\n+  assert( c>=0 && c<sizeof(aSpecial) );\n+  assert( p->nUsed+7 <= p->nAlloc );\n+  if( aSpecial[c] ){\n+    p->zBuf[p->nUsed] = '\\\\';\n+    p->zBuf[p->nUsed+1] = aSpecial[c];\n+    p->nUsed += 2;\n+  }else{\n+    p->zBuf[p->nUsed] = '\\\\';\n+    p->zBuf[p->nUsed+1] = 'u';\n+    p->zBuf[p->nUsed+2] = '0';\n+    p->zBuf[p->nUsed+3] = '0';\n+    p->zBuf[p->nUsed+4] = \"0123456789abcdef\"[c>>4];\n+    p->zBuf[p->nUsed+5] = \"0123456789abcdef\"[c&0xf];\n+    p->nUsed += 6;\n+  }\n+}\n+\n@@ -204093,1 +207363,0 @@\n-      json_simple_escape:\n@@ -204100,15 +207369,0 @@\n-      static const char aSpecial[] = {\n-         0, 0, 0, 0, 0, 0, 0, 0, 'b', 't', 'n', 0, 'f', 'r', 0, 0,\n-         0, 0, 0, 0, 0, 0, 0, 0,   0,   0,   0, 0,   0,   0, 0, 0\n-      };\n-      assert( sizeof(aSpecial)==32 );\n-      assert( aSpecial['\\b']=='b' );\n-      assert( aSpecial['\\f']=='f' );\n-      assert( aSpecial['\\n']=='n' );\n-      assert( aSpecial['\\r']=='r' );\n-      assert( aSpecial['\\t']=='t' );\n-      assert( c>=0 && c<sizeof(aSpecial) );\n-      if( aSpecial[c] ){\n-        c = aSpecial[c];\n-        goto json_simple_escape;\n-      }\n@@ -204116,6 +207370,1 @@\n-      p->zBuf[p->nUsed++] = '\\\\';\n-      p->zBuf[p->nUsed++] = 'u';\n-      p->zBuf[p->nUsed++] = '0';\n-      p->zBuf[p->nUsed++] = '0';\n-      p->zBuf[p->nUsed++] = \"0123456789abcdef\"[c>>4];\n-      p->zBuf[p->nUsed++] = \"0123456789abcdef\"[c&0xf];\n+      jsonAppendControlChar(p, c);\n@@ -204822,1 +208071,4 @@\n-          }else if( z[j]!='\\\\' || j+1>=k ){\n+          }else if( z[j]<=0x1f ){\n+            \/* Control characters in JSON5 string literals are ok *\/\n+            if( x==JSONB_TEXTJ ) return j+1;\n+          }else if( NEVER(z[j]!='\\\\') || j+1>=k ){\n@@ -205117,3 +208369,8 @@\n-        \/* Control characters are not allowed in strings *\/\n-        pParse->iErr = j;\n-        return -1;\n+        if( c==0 ){\n+          pParse->iErr = j;\n+          return -1;\n+        }\n+        \/* Control characters are not allowed in canonical JSON string\n+        ** literals, but are allowed in JSON5 string literals. *\/\n+        opcode = JSONB_TEXT5;\n+        pParse->hasNonstd = 1;\n@@ -205335,0 +208592,1 @@\n+    \/* no break *\/ deliberate_fall_through\n@@ -205603,1 +208861,1 @@\n-        for(k=0; k<sz2 && zIn[k]!='\\\\' && zIn[k]!='\"'; k++){}\n+        for(k=0; k<sz2 && (jsonIsOk[(u8)zIn[k]] || zIn[k]=='\\''); k++){}\n@@ -205618,0 +208876,7 @@\n+        if( zIn[0]<=0x1f ){\n+          if( pOut->nUsed+7>pOut->nAlloc && jsonStringGrow(pOut,7) ) break;\n+          jsonAppendControlChar(pOut, zIn[0]);\n+          zIn++;\n+          sz2--;\n+          continue;\n+        }\n@@ -205720,0 +208985,106 @@\n+\/* Context for recursion of json_pretty()\n+*\/\n+typedef struct JsonPretty JsonPretty;\n+struct JsonPretty {\n+  JsonParse *pParse;        \/* The BLOB being rendered *\/\n+  JsonString *pOut;         \/* Generate pretty output into this string *\/\n+  const char *zIndent;      \/* Use this text for indentation *\/\n+  u32 szIndent;             \/* Bytes in zIndent[] *\/\n+  u32 nIndent;              \/* Current level of indentation *\/\n+};\n+\n+\/* Append indentation to the pretty JSON under construction *\/\n+static void jsonPrettyIndent(JsonPretty *pPretty){\n+  u32 jj;\n+  for(jj=0; jj<pPretty->nIndent; jj++){\n+    jsonAppendRaw(pPretty->pOut, pPretty->zIndent, pPretty->szIndent);\n+  }\n+}\n+\n+\/*\n+** Translate the binary JSONB representation of JSON beginning at\n+** pParse->aBlob[i] into a JSON text string.  Append the JSON\n+** text onto the end of pOut.  Return the index in pParse->aBlob[]\n+** of the first byte past the end of the element that is translated.\n+**\n+** This is a variant of jsonTranslateBlobToText() that \"pretty-prints\"\n+** the output.  Extra whitespace is inserted to make the JSON easier\n+** for humans to read.\n+**\n+** If an error is detected in the BLOB input, the pOut->eErr flag\n+** might get set to JSTRING_MALFORMED.  But not all BLOB input errors\n+** are detected.  So a malformed JSONB input might either result\n+** in an error, or in incorrect JSON.\n+**\n+** The pOut->eErr JSTRING_OOM flag is set on a OOM.\n+*\/\n+static u32 jsonTranslateBlobToPrettyText(\n+  JsonPretty *pPretty,       \/* Pretty-printing context *\/\n+  u32 i                      \/* Start rendering at this index *\/\n+){\n+  u32 sz, n, j, iEnd;\n+  const JsonParse *pParse = pPretty->pParse;\n+  JsonString *pOut = pPretty->pOut;\n+  n = jsonbPayloadSize(pParse, i, &sz);\n+  if( n==0 ){\n+    pOut->eErr |= JSTRING_MALFORMED;\n+    return pParse->nBlob+1;\n+  }\n+  switch( pParse->aBlob[i] & 0x0f ){\n+    case JSONB_ARRAY: {\n+      j = i+n;\n+      iEnd = j+sz;\n+      jsonAppendChar(pOut, '[');\n+      if( j<iEnd ){\n+        jsonAppendChar(pOut, '\\n');\n+        pPretty->nIndent++;\n+        while( pOut->eErr==0 ){\n+          jsonPrettyIndent(pPretty);\n+          j = jsonTranslateBlobToPrettyText(pPretty, j);\n+          if( j>=iEnd ) break;\n+          jsonAppendRawNZ(pOut, \",\\n\", 2);\n+        }\n+        jsonAppendChar(pOut, '\\n');\n+        pPretty->nIndent--;\n+        jsonPrettyIndent(pPretty);\n+      }\n+      jsonAppendChar(pOut, ']');\n+      i = iEnd;\n+      break;\n+    }\n+    case JSONB_OBJECT: {\n+      j = i+n;\n+      iEnd = j+sz;\n+      jsonAppendChar(pOut, '{');\n+      if( j<iEnd ){\n+        jsonAppendChar(pOut, '\\n');\n+        pPretty->nIndent++;\n+        while( pOut->eErr==0 ){\n+          jsonPrettyIndent(pPretty);\n+          j = jsonTranslateBlobToText(pParse, j, pOut);\n+          if( j>iEnd ){\n+            pOut->eErr |= JSTRING_MALFORMED;\n+            break;\n+          }\n+          jsonAppendRawNZ(pOut, \": \", 2);\n+          j = jsonTranslateBlobToPrettyText(pPretty, j);\n+          if( j>=iEnd ) break;\n+          jsonAppendRawNZ(pOut, \",\\n\", 2);\n+        }\n+        jsonAppendChar(pOut, '\\n');\n+        pPretty->nIndent--;\n+        jsonPrettyIndent(pPretty);\n+      }\n+      jsonAppendChar(pOut, '}');\n+      i = iEnd;\n+      break;\n+    }\n+    default: {\n+      i = jsonTranslateBlobToText(pParse, i, pOut);\n+      break;\n+    }\n+  }\n+  return i;\n+}\n+\n+\n@@ -206126,1 +209497,3 @@\n-      for(i=1; zPath[i] && zPath[i]!='\"'; i++){}\n+      for(i=1; zPath[i] && zPath[i]!='\"'; i++){\n+        if( zPath[i]=='\\\\' && zPath[i+1]!=0 ) i++;\n+      }\n@@ -206970,1 +210343,1 @@\n-    sqlite3_result_text64(ctx, out.zText, out.nChar, SQLITE_DYNAMIC, SQLITE_UTF8);\n+    sqlite3_result_text64(ctx,out.zText,out.nChar,SQLITE_TRANSIENT,SQLITE_UTF8);\n@@ -206975,0 +210348,1 @@\n+  sqlite3_str_reset(&out);\n@@ -207073,7 +210447,0 @@\n-\/* True if the string is all digits *\/\n-static int jsonAllDigits(const char *z, int n){\n-  int i;\n-  for(i=0; i<n && sqlite3Isdigit(z[i]); i++){}\n-  return i==n;\n-}\n-\n@@ -207142,0 +210509,5 @@\n+      **\n+      ** Updated 2024-05-27:  If the NUMBER is negative, then PG counts from\n+      ** the right of the array.  Hence for negative NUMBER:\n+      **\n+      **     NUMBER   ==>  $[#NUMBER]    \/\/ PG compatible\n@@ -207144,1 +210516,1 @@\n-      if( jsonAllDigits(zPath, nPath) ){\n+      if( sqlite3_value_type(argv[i])==SQLITE_INTEGER ){\n@@ -207146,0 +210518,1 @@\n+        if( zPath[0]=='-' ) jsonAppendRawNZ(&jx,\"#\",1);\n@@ -207638,0 +211011,34 @@\n+\/*\n+** json_pretty(JSON)\n+** json_pretty(JSON, INDENT)\n+**\n+** Return text that is a pretty-printed rendering of the input JSON.\n+** If the argument is not valid JSON, return NULL.\n+**\n+** The INDENT argument is text that is used for indentation.  If omitted,\n+** it defaults to four spaces (the same as PostgreSQL).\n+*\/\n+static void jsonPrettyFunc(\n+  sqlite3_context *ctx,\n+  int argc,\n+  sqlite3_value **argv\n+){\n+  JsonString s;          \/* The output string *\/\n+  JsonPretty x;          \/* Pretty printing context *\/\n+\n+  memset(&x, 0, sizeof(x));\n+  x.pParse = jsonParseFuncArg(ctx, argv[0], 0);\n+  if( x.pParse==0 ) return;\n+  x.pOut = &s;\n+  jsonStringInit(&s, ctx);\n+  if( argc==1 || (x.zIndent = (const char*)sqlite3_value_text(argv[1]))==0 ){\n+    x.zIndent = \"    \";\n+    x.szIndent = 4;\n+  }else{\n+    x.szIndent = (u32)strlen(x.zIndent);\n+  }\n+  jsonTranslateBlobToPrettyText(&x, 0);\n+  jsonReturnString(&s, 0, 0);\n+  jsonParseFree(x.pParse);\n+}\n+\n@@ -208652,0 +212059,2 @@\n+    JFUNCTION(json_pretty,        1,1,0, 0,0,0,          jsonPrettyFunc),\n+    JFUNCTION(json_pretty,        2,1,0, 0,0,0,          jsonPrettyFunc),\n@@ -210551,0 +213960,2 @@\n+SQLITE_PRIVATE int sqlite3IntFloatCompare(i64,double);\n+\n@@ -210580,1 +213991,2 @@\n-     || (eType==SQLITE_FLOAT && sqlite3_value_double(argv[0])==iRowid)\n+     || (eType==SQLITE_FLOAT\n+         && 0==sqlite3IntFloatCompare(iRowid,sqlite3_value_double(argv[0])))\n@@ -211935,0 +215347,1 @@\n+  assert( pRtree->inWrTrans==0 );\n@@ -212481,1 +215894,0 @@\n-  sqlite3_result_text(ctx, sqlite3_str_finish(pOut), -1, sqlite3_free);\n@@ -212483,0 +215895,1 @@\n+  sqlite3_result_text(ctx, sqlite3_str_finish(pOut), -1, sqlite3_free);\n@@ -214998,1 +218411,1 @@\n-#if !SQLITE_CORE\n+#ifndef SQLITE_CORE\n@@ -215489,1 +218902,1 @@\n-  assert(nArg==2);\n+  assert(nArg==2 || nArg==3);\n@@ -215504,1 +218917,33 @@\n-\n+  if(nArg==3){\n+    const char *zOption = (const char*)sqlite3_value_text(apArg[2]);\n+    static const struct {\n+       const char *zName;\n+       UColAttributeValue val;\n+    } aStrength[] = {\n+      {  \"PRIMARY\",      UCOL_PRIMARY           },\n+      {  \"SECONDARY\",    UCOL_SECONDARY         },\n+      {  \"TERTIARY\",     UCOL_TERTIARY          },\n+      {  \"DEFAULT\",      UCOL_DEFAULT_STRENGTH  },\n+      {  \"QUARTERNARY\",  UCOL_QUATERNARY        },\n+      {  \"IDENTICAL\",    UCOL_IDENTICAL         },\n+    };\n+    unsigned int i;\n+    for(i=0; i<sizeof(aStrength)\/sizeof(aStrength[0]); i++){\n+      if( sqlite3_stricmp(zOption,aStrength[i].zName)==0 ){\n+        ucol_setStrength(pUCollator, aStrength[i].val);\n+        break;\n+      }\n+    }\n+    if( i>=sizeof(aStrength)\/sizeof(aStrength[0]) ){\n+      sqlite3_str *pStr = sqlite3_str_new(sqlite3_context_db_handle(p));\n+      sqlite3_str_appendf(pStr,\n+         \"unknown collation strength \\\"%s\\\" - should be one of:\",\n+         zOption);\n+      for(i=0; i<sizeof(aStrength)\/sizeof(aStrength[0]); i++){\n+         sqlite3_str_appendf(pStr, \" %s\", aStrength[i].zName);\n+      }\n+      sqlite3_result_error(p, sqlite3_str_value(pStr), -1);\n+      sqlite3_free(sqlite3_str_finish(pStr));\n+      return;\n+    }\n+  }\n@@ -215527,0 +218972,1 @@\n+    {\"icu_load_collation\",3,SQLITE_UTF8|SQLITE_DIRECTONLY,1, icuLoadCollation},\n@@ -215556,1 +219002,1 @@\n-#if !SQLITE_CORE\n+#ifndef SQLITE_CORE\n@@ -216677,0 +220123,1 @@\n+typedef sqlite3_uint64 u64;\n@@ -216813,0 +220260,21 @@\n+#ifndef UNUSED_PARAMETER\n+\/*\n+** The following macros are used to suppress compiler warnings and to\n+** make it clear to human readers when a function parameter is deliberately\n+** left unused within the body of a function. This usually happens when\n+** a function is called via a function pointer. For example the\n+** implementation of an SQL aggregate step callback may not use the\n+** parameter indicating the number of arguments passed to the aggregate,\n+** if it knows that this is enforced elsewhere.\n+**\n+** When a function parameter is not used at all within the body of a function,\n+** it is generally named \"NotUsed\" or \"NotUsed2\" to make things even clearer.\n+** However, these macros may also be used to suppress warnings related to\n+** parameters that may or may not be used depending on compilation options.\n+** For example those parameters only used in assert() statements. In these\n+** cases the parameters are named as per the usual conventions.\n+*\/\n+#define UNUSED_PARAMETER(x) (void)(x)\n+#define UNUSED_PARAMETER2(x,y) UNUSED_PARAMETER(x),UNUSED_PARAMETER(y)\n+#endif\n+\n@@ -216864,1 +220332,1 @@\n-  int nProgress;                  \/* Rows processed for all objects *\/\n+  sqlite3_int64 nProgress;        \/* Rows processed for all objects *\/\n@@ -216981,1 +220449,1 @@\n-  *pLen -= z - zStart;\n+  *pLen -= (int)(z - zStart);\n@@ -217166,0 +220634,1 @@\n+  UNUSED_PARAMETER(argc);\n@@ -217363,0 +220832,1 @@\n+          pIter->zDataTbl = 0;\n@@ -218744,1 +222214,1 @@\n-              int nSpan = &zSql[i] - pIter->aIdxCol[iIdxCol].zSpan;\n+              int nSpan = (int)(&zSql[i] - pIter->aIdxCol[iIdxCol].zSpan);\n@@ -218750,1 +222220,1 @@\n-            int nSpan = &zSql[i] - pIter->aIdxCol[iIdxCol].zSpan;\n+            int nSpan = (int)(&zSql[i] - pIter->aIdxCol[iIdxCol].zSpan);\n@@ -219440,0 +222910,2 @@\n+#else\n+  UNUSED_PARAMETER2(zBase,z);\n@@ -219457,1 +222929,1 @@\n-      iRet = ((i64)ptr[10] << 32) + ptr[11];\n+      iRet = (i64)(((u64)ptr[10] << 32) + ptr[11]);\n@@ -220024,1 +223496,1 @@\n-          \"(%d, %d), \"\n+          \"(%d, %lld), \"\n@@ -220382,0 +223854,1 @@\n+  UNUSED_PARAMETER(nVal);\n@@ -220657,1 +224130,1 @@\n-    int n = strlen(zState);\n+    size_t n = strlen(zState);\n@@ -220874,0 +224347,1 @@\n+  UNUSED_PARAMETER(pArg);\n@@ -221778,0 +225252,3 @@\n+  UNUSED_PARAMETER(pVfs);\n+  UNUSED_PARAMETER(a);\n+  UNUSED_PARAMETER(b);\n@@ -222176,0 +225653,1 @@\n+  pIdxInfo->idxFlags |= SQLITE_INDEX_SCAN_HEX;\n@@ -222833,1 +226311,7 @@\n-** update fails.  Rows may not be deleted or inserted.\n+** update fails.  INSERT operations also work, and operate as if they\n+** where REPLACE.  The size of the database can be extended by INSERT-ing\n+** new pages on the end.\n+**\n+** Rows may not be deleted.  However, doing an INSERT to page number N\n+** with NULL page data causes the N-th page and all subsequent pages to be\n+** deleted and the database to be truncated.\n@@ -222856,0 +226340,2 @@\n+  int iDbTrunc;                   \/* Database to truncate *\/\n+  Pgno pgnoTrunc;                 \/* Size to truncate to *\/\n@@ -222864,1 +226350,0 @@\n-\n@@ -223115,0 +226600,18 @@\n+\/*\n+** Open write transactions. Since we do not know in advance which database\n+** files will be written by the sqlite_dbpage virtual table, start a write\n+** transaction on them all.\n+**\n+** Return SQLITE_OK if successful, or an SQLite error code otherwise.\n+*\/\n+static int dbpageBeginTrans(DbpageTable *pTab){\n+  sqlite3 *db = pTab->db;\n+  int rc = SQLITE_OK;\n+  int i;\n+  for(i=0; rc==SQLITE_OK && i<db->nDb; i++){\n+    Btree *pBt = db->aDb[i].pBt;\n+    if( pBt ) rc = sqlite3BtreeBeginTrans(pBt, 1, 0);\n+  }\n+  return rc;\n+}\n+\n@@ -223126,1 +226629,0 @@\n-  const char *zSchema;\n@@ -223131,0 +226633,1 @@\n+  int isInsert;\n@@ -223141,6 +226644,10 @@\n-  pgno = sqlite3_value_int(argv[0]);\n-  if( sqlite3_value_type(argv[0])==SQLITE_NULL\n-   || (Pgno)sqlite3_value_int(argv[1])!=pgno\n-  ){\n-    zErr = \"cannot insert\";\n-    goto update_fail;\n+  if( sqlite3_value_type(argv[0])==SQLITE_NULL ){\n+    pgno = (Pgno)sqlite3_value_int(argv[2]);\n+    isInsert = 1;\n+  }else{\n+    pgno = sqlite3_value_int(argv[0]);\n+    if( (Pgno)sqlite3_value_int(argv[1])!=pgno ){\n+      zErr = \"cannot insert\";\n+      goto update_fail;\n+    }\n+    isInsert = 0;\n@@ -223148,5 +226655,9 @@\n-  zSchema = (const char*)sqlite3_value_text(argv[4]);\n-  iDb = ALWAYS(zSchema) ? sqlite3FindDbName(pTab->db, zSchema) : -1;\n-  if( NEVER(iDb<0) ){\n-    zErr = \"no such schema\";\n-    goto update_fail;\n+  if( sqlite3_value_type(argv[4])==SQLITE_NULL ){\n+    iDb = 0;\n+  }else{\n+    const char *zSchema = (const char*)sqlite3_value_text(argv[4]);\n+    iDb = sqlite3FindDbName(pTab->db, zSchema);\n+    if( iDb<0 ){\n+      zErr = \"no such schema\";\n+      goto update_fail;\n+    }\n@@ -223155,1 +226666,1 @@\n-  if( NEVER(pgno<1) || NEVER(pBt==0) || NEVER(pgno>sqlite3BtreeLastPage(pBt)) ){\n+  if( pgno<1 || NEVER(pBt==0) ){\n@@ -223163,1 +226674,14 @@\n-    zErr = \"bad page value\";\n+    if( sqlite3_value_type(argv[3])==SQLITE_NULL && isInsert && pgno>1 ){\n+      \/* \"INSERT INTO dbpage($PGNO,NULL)\" causes page number $PGNO and\n+      ** all subsequent pages to be deleted. *\/\n+      pTab->iDbTrunc = iDb;\n+      pgno--;\n+      pTab->pgnoTrunc = pgno;\n+    }else{\n+      zErr = \"bad page value\";\n+      goto update_fail;\n+    }\n+  }\n+\n+  if( dbpageBeginTrans(pTab)!=SQLITE_OK ){\n+    zErr = \"failed to open transaction\";\n@@ -223166,0 +226690,1 @@\n+\n@@ -223170,5 +226695,4 @@\n-    assert( pData!=0 || pTab->db->mallocFailed );\n-    if( pData\n-     && (rc = sqlite3PagerWrite(pDbPage))==SQLITE_OK\n-    ){\n-      memcpy(sqlite3PagerGetData(pDbPage), pData, szPage);\n+    if( (rc = sqlite3PagerWrite(pDbPage))==SQLITE_OK && pData ){\n+      unsigned char *aPage = sqlite3PagerGetData(pDbPage);\n+      memcpy(aPage, pData, szPage);\n+      pTab->pgnoTrunc = 0;\n@@ -223176,0 +226700,2 @@\n+  }else{\n+    pTab->pgnoTrunc = 0;\n@@ -223181,0 +226707,1 @@\n+  pTab->pgnoTrunc = 0;\n@@ -223186,4 +226713,0 @@\n-\/* Since we do not know in advance which database files will be\n-** written by the sqlite_dbpage virtual table, start a write transaction\n-** on them all.\n-*\/\n@@ -223192,5 +226715,16 @@\n-  sqlite3 *db = pTab->db;\n-  int i;\n-  for(i=0; i<db->nDb; i++){\n-    Btree *pBt = db->aDb[i].pBt;\n-    if( pBt ) (void)sqlite3BtreeBeginTrans(pBt, 1, 0);\n+  pTab->pgnoTrunc = 0;\n+  return SQLITE_OK;\n+}\n+\n+\/* Invoke sqlite3PagerTruncate() as necessary, just prior to COMMIT\n+*\/\n+static int dbpageSync(sqlite3_vtab *pVtab){\n+  DbpageTable *pTab = (DbpageTable *)pVtab;\n+  if( pTab->pgnoTrunc>0 ){\n+    Btree *pBt = pTab->db->aDb[pTab->iDbTrunc].pBt;\n+    Pager *pPager = sqlite3BtreePager(pBt);\n+    sqlite3BtreeEnter(pBt);\n+    if( pTab->pgnoTrunc<sqlite3BtreeLastPage(pBt) ){\n+      sqlite3PagerTruncateImage(pPager, pTab->pgnoTrunc);\n+    }\n+    sqlite3BtreeLeave(pBt);\n@@ -223198,0 +226732,1 @@\n+  pTab->pgnoTrunc = 0;\n@@ -223201,0 +226736,8 @@\n+\/* Cancel any pending truncate.\n+*\/\n+static int dbpageRollbackTo(sqlite3_vtab *pVtab, int notUsed1){\n+  DbpageTable *pTab = (DbpageTable *)pVtab;\n+  pTab->pgnoTrunc = 0;\n+  (void)notUsed1;\n+  return SQLITE_OK;\n+}\n@@ -223207,1 +226750,1 @@\n-    0,                            \/* iVersion *\/\n+    2,                            \/* iVersion *\/\n@@ -223222,1 +226765,1 @@\n-    0,                            \/* xSync *\/\n+    dbpageSync,                   \/* xSync *\/\n@@ -223229,1 +226772,1 @@\n-    0,                            \/* xRollbackTo *\/\n+    dbpageRollbackTo,             \/* xRollbackTo *\/\n@@ -223317,0 +226860,4 @@\n+**\n+** bNoDiscard:\n+**   If true, then the only time data is discarded is as a result of explicit\n+**   sessionDiscardData() calls. Not within every sessionInputBuffer() call.\n@@ -223378,1 +226925,2 @@\n-  int nCol;                       \/* Number of columns in table zName *\/\n+  int nCol;                       \/* Number of non-hidden columns *\/\n+  int nTotalCol;                  \/* Number of columns including hidden *\/\n@@ -223383,0 +226931,1 @@\n+  int *aiIdx;                     \/* Index to pass to xNew\/xOld *\/\n@@ -223785,0 +227334,1 @@\n+  assert( pTab->nTotalCol==pSession->hook.xCount(pSession->hook.pCtx) );\n@@ -223786,1 +227336,0 @@\n-    assert( pTab->nCol-1==pSession->hook.xCount(pSession->hook.pCtx) );\n@@ -223790,1 +227339,0 @@\n-    assert( pTab->nCol==pSession->hook.xCount(pSession->hook.pCtx) );\n@@ -223796,0 +227344,1 @@\n+        int iIdx = pTab->aiIdx[i];\n@@ -223798,1 +227347,1 @@\n-          rc = pSession->hook.xNew(pSession->hook.pCtx, i, &pVal);\n+          rc = pSession->hook.xNew(pSession->hook.pCtx, iIdx, &pVal);\n@@ -223800,1 +227349,1 @@\n-          rc = pSession->hook.xOld(pSession->hook.pCtx, i, &pVal);\n+          rc = pSession->hook.xOld(pSession->hook.pCtx, iIdx, &pVal);\n@@ -224137,0 +227686,1 @@\n+      int iIdx = pTab->aiIdx[iCol];\n@@ -224145,1 +227695,1 @@\n-        rc = pSession->hook.xNew(pSession->hook.pCtx, iCol, &pVal);\n+        rc = pSession->hook.xNew(pSession->hook.pCtx, iIdx, &pVal);\n@@ -224148,1 +227698,1 @@\n-        rc = pSession->hook.xOld(pSession->hook.pCtx, iCol, &pVal);\n+        rc = pSession->hook.xOld(pSession->hook.pCtx, iIdx, &pVal);\n@@ -224273,0 +227823,1 @@\n+  int *pnTotalCol,                \/* OUT: number of hidden columns *\/\n@@ -224276,0 +227827,1 @@\n+  int **paiIdx,                   \/* OUT: Array of xNew\/xOld indexes *\/\n@@ -224290,0 +227842,1 @@\n+  int *aiIdx = 0;\n@@ -224297,0 +227850,2 @@\n+  if( pnTotalCol ) *pnTotalCol = 0;\n+  if( paiIdx ) *paiIdx = 0;\n@@ -224306,3 +227861,3 @@\n-          \"SELECT 0, 'tbl',  '', 0, '', 1     UNION ALL \"\n-          \"SELECT 1, 'idx',  '', 0, '', 2     UNION ALL \"\n-          \"SELECT 2, 'stat', '', 0, '', 0\"\n+          \"SELECT 0, 'tbl',  '', 0, '', 1, 0     UNION ALL \"\n+          \"SELECT 1, 'idx',  '', 0, '', 2, 0     UNION ALL \"\n+          \"SELECT 2, 'stat', '', 0, '', 0, 0\"\n@@ -224316,1 +227871,1 @@\n-    zPragma = sqlite3_mprintf(\"PRAGMA '%q'.table_info('%q')\", zDb, zThis);\n+    zPragma = sqlite3_mprintf(\"PRAGMA '%q'.table_xinfo('%q')\", zDb, zThis);\n@@ -224333,1 +227888,3 @@\n-    nDbCol++;\n+    if( sqlite3_column_int(pStmt, 6)==0 ){            \/* !hidden *\/\n+      nDbCol++;\n+    }\n@@ -224342,1 +227899,1 @@\n-    nByte += nDbCol * (sizeof(const char *)*2 + sizeof(u8) + 1 + 1);\n+    nByte += nDbCol * (sizeof(const char *)*2 +sizeof(int)+sizeof(u8) + 1 + 1);\n@@ -224353,2 +227910,2 @@\n-    pAlloc = (u8 *)&azDflt[nDbCol];\n-    abPK = (u8 *)pAlloc;\n+    aiIdx = (int*)&azDflt[nDbCol];\n+    abPK = (u8 *)&aiIdx[nDbCol];\n@@ -224369,0 +227926,1 @@\n+      aiIdx[i] = -1;\n@@ -224372,15 +227930,20 @@\n-      int nName = sqlite3_column_bytes(pStmt, 1);\n-      int nDflt = sqlite3_column_bytes(pStmt, 4);\n-      const unsigned char *zName = sqlite3_column_text(pStmt, 1);\n-      const unsigned char *zDflt = sqlite3_column_text(pStmt, 4);\n-\n-      if( zName==0 ) break;\n-      memcpy(pAlloc, zName, nName+1);\n-      azCol[i] = (char *)pAlloc;\n-      pAlloc += nName+1;\n-      if( zDflt ){\n-        memcpy(pAlloc, zDflt, nDflt+1);\n-        azDflt[i] = (char *)pAlloc;\n-        pAlloc += nDflt+1;\n-      }else{\n-        azDflt[i] = 0;\n+      if( sqlite3_column_int(pStmt, 6)==0 ){            \/* !hidden *\/\n+        int nName = sqlite3_column_bytes(pStmt, 1);\n+        int nDflt = sqlite3_column_bytes(pStmt, 4);\n+        const unsigned char *zName = sqlite3_column_text(pStmt, 1);\n+        const unsigned char *zDflt = sqlite3_column_text(pStmt, 4);\n+\n+        if( zName==0 ) break;\n+        memcpy(pAlloc, zName, nName+1);\n+        azCol[i] = (char *)pAlloc;\n+        pAlloc += nName+1;\n+        if( zDflt ){\n+          memcpy(pAlloc, zDflt, nDflt+1);\n+          azDflt[i] = (char *)pAlloc;\n+          pAlloc += nDflt+1;\n+        }else{\n+          azDflt[i] = 0;\n+        }\n+        abPK[i] = sqlite3_column_int(pStmt, 5);\n+        aiIdx[i] = sqlite3_column_int(pStmt, 0);\n+        i++;\n@@ -224388,2 +227951,1 @@\n-      abPK[i] = sqlite3_column_int(pStmt, 5);\n-      i++;\n+      if( pnTotalCol ) (*pnTotalCol)++;\n@@ -224402,0 +227964,1 @@\n+    if( paiIdx ) *paiIdx = aiIdx;\n@@ -224433,1 +227996,2 @@\n-        pTab->zName, &pTab->nCol, 0, &pTab->azCol, &pTab->azDflt, &abPK,\n+        pTab->zName, &pTab->nCol, &pTab->nTotalCol, 0, &pTab->azCol,\n+        &pTab->azDflt, &pTab->aiIdx, &abPK,\n@@ -224468,0 +228032,1 @@\n+  int nTotalCol = 0;\n@@ -224470,0 +228035,1 @@\n+  int *aiIdx = 0;\n@@ -224476,1 +228042,1 @@\n-      pTab->zName, &nCol, 0, &azCol, &azDflt, &abPK,\n+      pTab->zName, &nCol, &nTotalCol, 0, &azCol, &azDflt, &aiIdx, &abPK,\n@@ -224499,0 +228065,1 @@\n+        pTab->nTotalCol = nTotalCol;\n@@ -224501,0 +228068,1 @@\n+        pTab->aiIdx = aiIdx;\n@@ -224818,1 +228386,1 @@\n-        pSession->hook.xNew(pSession->hook.pCtx, ii, &p);\n+        pSession->hook.xNew(pSession->hook.pCtx, pTab->aiIdx[ii], &p);\n@@ -224838,0 +228406,1 @@\n+      int iIdx = pTab->aiIdx[ii];\n@@ -224839,1 +228408,1 @@\n-      pSession->hook.xNew(pSession->hook.pCtx, ii-pTab->bRowid, &p);\n+      pSession->hook.xNew(pSession->hook.pCtx, iIdx, &p);\n@@ -224936,1 +228505,1 @@\n-  if( (pTab->nCol-pTab->bRowid)<nExpect ){\n+  if( pTab->nTotalCol<nExpect ){\n@@ -224940,1 +228509,1 @@\n-  if( (pTab->nCol-pTab->bRowid)!=nExpect ){\n+  if( pTab->nTotalCol!=nExpect ){\n@@ -224997,1 +228566,2 @@\n-      for(i=0; i<(pTab->nCol-pTab->bRowid); i++){\n+      for(i=pTab->bRowid; i<pTab->nCol; i++){\n+        int iIdx = pTab->aiIdx[i];\n@@ -225000,2 +228570,3 @@\n-          TESTONLY(int trc = ) pSession->hook.xOld(pSession->hook.pCtx, i, &p);\n-          assert( trc==SQLITE_OK );\n+          \/* This may fail if the column has a non-NULL default and was added\n+          ** using ALTER TABLE ADD COLUMN after this record was created. *\/\n+          rc = pSession->hook.xOld(pSession->hook.pCtx, iIdx, &p);\n@@ -225003,1 +228574,1 @@\n-          TESTONLY(int trc = ) pSession->hook.xNew(pSession->hook.pCtx, i, &p);\n+          TESTONLY(int trc = ) pSession->hook.xNew(pSession->hook.pCtx,iIdx,&p);\n@@ -225007,3 +228578,5 @@\n-        \/* This may fail if SQLite value p contains a utf-16 string that must\n-        ** be converted to utf-8 and an OOM error occurs while doing so. *\/\n-        rc = sessionSerializeValue(0, p, &nByte);\n+        if( rc==SQLITE_OK ){\n+          \/* This may fail if SQLite value p contains a utf-16 string that must\n+          ** be converted to utf-8 and an OOM error occurs while doing so. *\/\n+          rc = sessionSerializeValue(0, p, &nByte);\n+        }\n@@ -225036,1 +228609,1 @@\n-      for(i=0; i<(pTab->nCol-pTab->bRowid); i++){\n+      for(i=pTab->bRowid; i<pTab->nCol; i++){\n@@ -225038,0 +228611,1 @@\n+        int iIdx = pTab->aiIdx[i];\n@@ -225039,1 +228613,1 @@\n-          pSession->hook.xOld(pSession->hook.pCtx, i, &p);\n+          pSession->hook.xOld(pSession->hook.pCtx, iIdx, &p);\n@@ -225041,1 +228615,1 @@\n-          pSession->hook.xNew(pSession->hook.pCtx, i, &p);\n+          pSession->hook.xNew(pSession->hook.pCtx, iIdx, &p);\n@@ -225443,1 +229017,2 @@\n-      rc = sessionTableInfo(0, db, zFrom, zTbl, &nCol, 0, &azCol, 0, &abPK,\n+      rc = sessionTableInfo(0, db, zFrom, zTbl,\n+          &nCol, 0, 0, &azCol, 0, 0, &abPK,\n@@ -225767,3 +229342,5 @@\n-    while( *zIn ){\n-      if( *zIn=='\"' ) *zOut++ = '\"';\n-      *zOut++ = *(zIn++);\n+    if( zIn!=0 ){\n+      while( *zIn ){\n+        if( *zIn=='\"' ) *zOut++ = '\"';\n+        *zOut++ = *(zIn++);\n+      }\n@@ -226020,1 +229597,0 @@\n-  const char *zCols = bRowid ? SESSIONS_ROWID \", *\" : \"*\";\n@@ -226024,0 +229600,1 @@\n+  SessionBuffer cols = {0, 0, 0};\n@@ -226036,1 +229613,1 @@\n-    zCols = \"tbl, ?2, stat\";\n+    sessionAppendStr(&cols, \"tbl, ?2, stat\", &rc);\n@@ -226038,0 +229615,5 @@\n+  #if 0\n+    if( bRowid ){\n+      sessionAppendStr(&cols, SESSIONS_ROWID, &rc);\n+    }\n+    #endif\n@@ -226039,0 +229621,2 @@\n+      if( cols.nBuf ) sessionAppendStr(&cols, \", \", &rc);\n+      sessionAppendIdent(&cols, azCol[i], &rc);\n@@ -226056,1 +229640,1 @@\n-        zCols, (bIgnoreNoop ? (char*)nooptest.aBuf : \"\"),\n+        (char*)cols.aBuf, (bIgnoreNoop ? (char*)nooptest.aBuf : \"\"),\n@@ -226099,0 +229683,1 @@\n+  sqlite3_free(cols.aBuf);\n@@ -226928,0 +230513,3 @@\n+  sessionDiscardData(&p->in);\n+  p->in.iCurrent = p->in.iNext;\n+\n@@ -226933,3 +230521,0 @@\n-  sessionDiscardData(&p->in);\n-  p->in.iCurrent = p->in.iNext;\n-\n@@ -228367,0 +231952,1 @@\n+  u64 savedFlag = db->flags & SQLITE_FkNoAction;\n@@ -228370,0 +231956,6 @@\n+  sqlite3_mutex_enter(sqlite3_db_mutex(db));\n+  if( flags & SQLITE_CHANGESETAPPLY_FKNOACTION ){\n+    db->flags |= ((u64)SQLITE_FkNoAction);\n+    db->aDb[0].pSchema->schema_cookie -= 32;\n+  }\n+\n@@ -228375,1 +231967,0 @@\n-  sqlite3_mutex_enter(sqlite3_db_mutex(db));\n@@ -228433,1 +232024,2 @@\n-            &sApply.nCol, &zTab, &sApply.azCol, 0, &sApply.abPK, &sApply.bRowid\n+            &sApply.nCol, 0, &zTab, &sApply.azCol, 0, 0,\n+            &sApply.abPK, &sApply.bRowid\n@@ -228513,1 +232105,5 @@\n-  sqlite3_exec(db, \"PRAGMA defer_foreign_keys = 0\", 0, 0, 0);\n+\n+  {\n+    int rc2 = sqlite3_exec(db, \"PRAGMA defer_foreign_keys = 0\", 0, 0, 0);\n+    if( rc==SQLITE_OK ) rc = rc2;\n+  }\n@@ -228518,1 +232114,2 @@\n-    }else{\n+    }\n+    if( rc!=SQLITE_OK ){\n@@ -228537,0 +232134,6 @@\n+\n+  if( (flags & SQLITE_CHANGESETAPPLY_FKNOACTION) && savedFlag==0 ){\n+    assert( db->flags & SQLITE_FkNoAction );\n+    db->flags &= ~((u64)SQLITE_FkNoAction);\n+    db->aDb[0].pSchema->schema_cookie -= 32;\n+  }\n@@ -228565,6 +232168,0 @@\n-  u64 savedFlag = db->flags & SQLITE_FkNoAction;\n-\n-  if( flags & SQLITE_CHANGESETAPPLY_FKNOACTION ){\n-    db->flags |= ((u64)SQLITE_FkNoAction);\n-    db->aDb[0].pSchema->schema_cookie -= 32;\n-  }\n@@ -228578,5 +232175,0 @@\n-  if( (flags & SQLITE_CHANGESETAPPLY_FKNOACTION) && savedFlag==0 ){\n-    assert( db->flags & SQLITE_FkNoAction );\n-    db->flags &= ~((u64)SQLITE_FkNoAction);\n-    db->aDb[0].pSchema->schema_cookie -= 32;\n-  }\n@@ -228670,0 +232262,1 @@\n+  SessionBuffer rec;\n@@ -228902,0 +232495,3 @@\n+      if( rc==SQLITE_OK && SQLITE_ROW!=sqlite3_step(pTab->pDfltStmt) ){\n+        rc = sqlite3_errcode(pGrp->db);\n+      }\n@@ -228918,0 +232514,1 @@\n+            pOut->nBuf += 8;\n@@ -228968,2 +232565,5 @@\n-** Add all changes in the changeset traversed by the iterator passed as\n-** the first argument to the changegroup hash tables.\n+** Locate or create a SessionTable object that may be used to add the\n+** change currently pointed to by iterator pIter to changegroup pGrp.\n+** If successful, set output variable (*ppTab) to point to the table\n+** object and return SQLITE_OK. Otherwise, if some error occurs, return\n+** an SQLite error code and leave (*ppTab) set to NULL.\n@@ -228971,4 +232571,5 @@\n-static int sessionChangesetToHash(\n-  sqlite3_changeset_iter *pIter,   \/* Iterator to read from *\/\n-  sqlite3_changegroup *pGrp,       \/* Changegroup object to add changeset to *\/\n-  int bRebase                      \/* True if hash table is for rebasing *\/\n+static int sessionChangesetFindTable(\n+  sqlite3_changegroup *pGrp,\n+  const char *zTab,\n+  sqlite3_changeset_iter *pIter,\n+  SessionTable **ppTab\n@@ -228976,2 +232577,0 @@\n-  u8 *aRec;\n-  int nRec;\n@@ -228980,21 +232579,3 @@\n-  SessionBuffer rec = {0, 0, 0};\n-\n-  while( SQLITE_ROW==sessionChangesetNext(pIter, &aRec, &nRec, 0) ){\n-    const char *zNew;\n-    int nCol;\n-    int op;\n-    int iHash;\n-    int bIndirect;\n-    SessionChange *pChange;\n-    SessionChange *pExist = 0;\n-    SessionChange **pp;\n-\n-    \/* Ensure that only changesets, or only patchsets, but not a mixture\n-    ** of both, are being combined. It is an error to try to combine a\n-    ** changeset and a patchset.  *\/\n-    if( pGrp->pList==0 ){\n-      pGrp->bPatch = pIter->bPatchset;\n-    }else if( pIter->bPatchset!=pGrp->bPatch ){\n-      rc = SQLITE_ERROR;\n-      break;\n-    }\n+  int nTab = (int)strlen(zTab);\n+  u8 *abPK = 0;\n+  int nCol = 0;\n@@ -229002,5 +232583,2 @@\n-    sqlite3changeset_op(pIter, &zNew, &nCol, &op, &bIndirect);\n-    if( !pTab || sqlite3_stricmp(zNew, pTab->zName) ){\n-      \/* Search the list for a matching table *\/\n-      int nNew = (int)strlen(zNew);\n-      u8 *abPK;\n+  *ppTab = 0;\n+  sqlite3changeset_pk(pIter, &abPK, &nCol);\n@@ -229008,6 +232586,4 @@\n-      sqlite3changeset_pk(pIter, &abPK, 0);\n-      for(pTab = pGrp->pList; pTab; pTab=pTab->pNext){\n-        if( 0==sqlite3_strnicmp(pTab->zName, zNew, nNew+1) ) break;\n-      }\n-      if( !pTab ){\n-        SessionTable **ppTab;\n+  \/* Search the list for an existing table *\/\n+  for(pTab = pGrp->pList; pTab; pTab=pTab->pNext){\n+    if( 0==sqlite3_strnicmp(pTab->zName, zTab, nTab+1) ) break;\n+  }\n@@ -229015,21 +232591,3 @@\n-        pTab = sqlite3_malloc64(sizeof(SessionTable) + nCol + nNew+1);\n-        if( !pTab ){\n-          rc = SQLITE_NOMEM;\n-          break;\n-        }\n-        memset(pTab, 0, sizeof(SessionTable));\n-        pTab->nCol = nCol;\n-        pTab->abPK = (u8*)&pTab[1];\n-        memcpy(pTab->abPK, abPK, nCol);\n-        pTab->zName = (char*)&pTab->abPK[nCol];\n-        memcpy(pTab->zName, zNew, nNew+1);\n-\n-        if( pGrp->db ){\n-          pTab->nCol = 0;\n-          rc = sessionInitTable(0, pTab, pGrp->db, pGrp->zDb);\n-          if( rc ){\n-            assert( pTab->azCol==0 );\n-            sqlite3_free(pTab);\n-            break;\n-          }\n-        }\n+  \/* If one was not found above, create a new table now *\/\n+  if( !pTab ){\n+    SessionTable **ppNew;\n@@ -229037,7 +232595,10 @@\n-        \/* The new object must be linked on to the end of the list, not\n-        ** simply added to the start of it. This is to ensure that the\n-        ** tables within the output of sqlite3changegroup_output() are in\n-        ** the right order.  *\/\n-        for(ppTab=&pGrp->pList; *ppTab; ppTab=&(*ppTab)->pNext);\n-        *ppTab = pTab;\n-      }\n+    pTab = sqlite3_malloc64(sizeof(SessionTable) + nCol + nTab+1);\n+    if( !pTab ){\n+      return SQLITE_NOMEM;\n+    }\n+    memset(pTab, 0, sizeof(SessionTable));\n+    pTab->nCol = nCol;\n+    pTab->abPK = (u8*)&pTab[1];\n+    memcpy(pTab->abPK, abPK, nCol);\n+    pTab->zName = (char*)&pTab->abPK[nCol];\n+    memcpy(pTab->zName, zTab, nTab+1);\n@@ -229045,3 +232606,7 @@\n-      if( !sessionChangesetCheckCompat(pTab, nCol, abPK) ){\n-        rc = SQLITE_SCHEMA;\n-        break;\n+    if( pGrp->db ){\n+      pTab->nCol = 0;\n+      rc = sessionInitTable(0, pTab, pGrp->db, pGrp->zDb);\n+      if( rc ){\n+        assert( pTab->azCol==0 );\n+        sqlite3_free(pTab);\n+        return rc;\n@@ -229051,7 +232616,7 @@\n-    if( nCol<pTab->nCol ){\n-      assert( pGrp->db );\n-      rc = sessionChangesetExtendRecord(pGrp, pTab, nCol, op, aRec, nRec, &rec);\n-      if( rc ) break;\n-      aRec = rec.aBuf;\n-      nRec = rec.nBuf;\n-    }\n+    \/* The new object must be linked on to the end of the list, not\n+    ** simply added to the start of it. This is to ensure that the\n+    ** tables within the output of sqlite3changegroup_output() are in\n+    ** the right order.  *\/\n+    for(ppNew=&pGrp->pList; *ppNew; ppNew=&(*ppNew)->pNext);\n+    *ppNew = pTab;\n+  }\n@@ -229059,4 +232624,62 @@\n-    if( sessionGrowHash(0, pIter->bPatchset, pTab) ){\n-      rc = SQLITE_NOMEM;\n-      break;\n-    }\n+  \/* Check that the table is compatible. *\/\n+  if( !sessionChangesetCheckCompat(pTab, nCol, abPK) ){\n+    rc = SQLITE_SCHEMA;\n+  }\n+\n+  *ppTab = pTab;\n+  return rc;\n+}\n+\n+\/*\n+** Add the change currently indicated by iterator pIter to the hash table\n+** belonging to changegroup pGrp.\n+*\/\n+static int sessionOneChangeToHash(\n+  sqlite3_changegroup *pGrp,\n+  sqlite3_changeset_iter *pIter,\n+  int bRebase\n+){\n+  int rc = SQLITE_OK;\n+  int nCol = 0;\n+  int op = 0;\n+  int iHash = 0;\n+  int bIndirect = 0;\n+  SessionChange *pChange = 0;\n+  SessionChange *pExist = 0;\n+  SessionChange **pp = 0;\n+  SessionTable *pTab = 0;\n+  u8 *aRec = &pIter->in.aData[pIter->in.iCurrent + 2];\n+  int nRec = (pIter->in.iNext - pIter->in.iCurrent) - 2;\n+\n+  assert( nRec>0 );\n+\n+  \/* Ensure that only changesets, or only patchsets, but not a mixture\n+  ** of both, are being combined. It is an error to try to combine a\n+  ** changeset and a patchset.  *\/\n+  if( pGrp->pList==0 ){\n+    pGrp->bPatch = pIter->bPatchset;\n+  }else if( pIter->bPatchset!=pGrp->bPatch ){\n+    rc = SQLITE_ERROR;\n+  }\n+\n+  if( rc==SQLITE_OK ){\n+    const char *zTab = 0;\n+    sqlite3changeset_op(pIter, &zTab, &nCol, &op, &bIndirect);\n+    rc = sessionChangesetFindTable(pGrp, zTab, pIter, &pTab);\n+  }\n+\n+  if( rc==SQLITE_OK && nCol<pTab->nCol ){\n+    SessionBuffer *pBuf = &pGrp->rec;\n+    rc = sessionChangesetExtendRecord(pGrp, pTab, nCol, op, aRec, nRec, pBuf);\n+    aRec = pBuf->aBuf;\n+    nRec = pBuf->nBuf;\n+    assert( pGrp->db );\n+  }\n+\n+  if( rc==SQLITE_OK && sessionGrowHash(0, pIter->bPatchset, pTab) ){\n+    rc = SQLITE_NOMEM;\n+  }\n+\n+  if( rc==SQLITE_OK ){\n+    \/* Search for existing entry. If found, remove it from the hash table.\n+    ** Code below may link it back in.  *\/\n@@ -229066,4 +232689,0 @@\n-\n-    \/* Search for existing entry. If found, remove it from the hash table.\n-    ** Code below may link it back in.\n-    *\/\n@@ -229084,0 +232703,1 @@\n+  }\n@@ -229085,0 +232705,1 @@\n+  if( rc==SQLITE_OK ){\n@@ -229088,6 +232709,28 @@\n-    if( rc ) break;\n-    if( pChange ){\n-      pChange->pNext = pTab->apChange[iHash];\n-      pTab->apChange[iHash] = pChange;\n-      pTab->nEntry++;\n-    }\n+  }\n+  if( rc==SQLITE_OK && pChange ){\n+    pChange->pNext = pTab->apChange[iHash];\n+    pTab->apChange[iHash] = pChange;\n+    pTab->nEntry++;\n+  }\n+\n+  if( rc==SQLITE_OK ) rc = pIter->rc;\n+  return rc;\n+}\n+\n+\/*\n+** Add all changes in the changeset traversed by the iterator passed as\n+** the first argument to the changegroup hash tables.\n+*\/\n+static int sessionChangesetToHash(\n+  sqlite3_changeset_iter *pIter,   \/* Iterator to read from *\/\n+  sqlite3_changegroup *pGrp,       \/* Changegroup object to add changeset to *\/\n+  int bRebase                      \/* True if hash table is for rebasing *\/\n+){\n+  u8 *aRec;\n+  int nRec;\n+  int rc = SQLITE_OK;\n+\n+  pIter->in.bNoDiscard = 1;\n+  while( SQLITE_ROW==(sessionChangesetNext(pIter, &aRec, &nRec, 0)) ){\n+    rc = sessionOneChangeToHash(pGrp, pIter, bRebase);\n+    if( rc!=SQLITE_OK ) break;\n@@ -229096,1 +232739,0 @@\n-  sqlite3_free(rec.aBuf);\n@@ -229224,0 +232866,17 @@\n+\/*\n+** Add a single change to a changeset-group.\n+*\/\n+SQLITE_API int sqlite3changegroup_add_change(\n+  sqlite3_changegroup *pGrp,\n+  sqlite3_changeset_iter *pIter\n+){\n+  if( pIter->in.iCurrent==pIter->in.iNext\n+   || pIter->rc!=SQLITE_OK\n+   || pIter->bInvert\n+  ){\n+    \/* Iterator does not point to any valid entry or is an INVERT iterator. *\/\n+    return SQLITE_ERROR;\n+  }\n+  return sessionOneChangeToHash(pGrp, pIter, 0);\n+}\n+\n@@ -229273,0 +232932,1 @@\n+    sqlite3_free(pGrp->rec.aBuf);\n@@ -229674,0 +233334,1 @@\n+    sqlite3_free(p->grp.rec.aBuf);\n@@ -229704,1 +233365,21 @@\n-\n+\/*\n+** This, the \"fts5.c\" source file, is a composite file that is itself\n+** assembled from the following files:\n+**\n+**    fts5.h\n+**    fts5Int.h\n+**    fts5parse.h          <--- Generated from fts5parse.y by Lemon\n+**    fts5parse.c          <--- Generated from fts5parse.y by Lemon\n+**    fts5_aux.c\n+**    fts5_buffer.c\n+**    fts5_config.c\n+**    fts5_expr.c\n+**    fts5_hash.c\n+**    fts5_index.c\n+**    fts5_main.c\n+**    fts5_storage.c\n+**    fts5_tokenize.c\n+**    fts5_unicode2.c\n+**    fts5_varint.c\n+**    fts5_vocab.c\n+*\/\n@@ -229714,0 +233395,6 @@\n+#ifdef HAVE_STDINT_H\n+\/* #include <stdint.h> *\/\n+#endif\n+#ifdef HAVE_INTTYPES_H\n+\/* #include <inttypes.h> *\/\n+#endif\n@@ -229771,2 +233458,2 @@\n-**   Return a copy of the context pointer the extension function was\n-**   registered with.\n+**   Return a copy of the pUserData pointer passed to the xCreateFunction()\n+**   API when the extension function was registered.\n@@ -229954,0 +233641,4 @@\n+**   In all cases, matches are visited in (column ASC, offset ASC) order.\n+**   i.e. all those in column 0, sorted by offset, followed by those in\n+**   column 1, etc.\n+**\n@@ -230010,3 +233701,1 @@\n-**   bytes. This API is not available if the specified token matches a\n-**   prefix query term. In that case both output variables are always set\n-**   to 0.\n+**   bytes.\n@@ -230018,0 +233707,17 @@\n+**   This API may be slow in some cases if the token identified by parameters\n+**   iIdx and iToken matched a prefix token in the query. In most cases, the\n+**   first call to this API for each prefix token in the query is forced\n+**   to scan the portion of the full-text index that matches the prefix\n+**   token to collect the extra data required by this API. If the prefix\n+**   token matches a large number of token instances in the document set,\n+**   this may be a performance problem.\n+**\n+**   If the user knows in advance that a query may use this API for a\n+**   prefix token, FTS5 may be configured to collect all required data as part\n+**   of the initial querying of the full-text index, avoiding the second scan\n+**   entirely. This also causes prefix queries that do not use this API to\n+**   run more slowly and use more memory. FTS5 may be configured in this way\n+**   either on a per-table basis using the [FTS5 insttoken | 'insttoken']\n+**   option, or on a per-query basis using the\n+**   [fts5_insttoken | fts5_insttoken()] user function.\n+**\n@@ -230020,0 +233726,23 @@\n+**\n+** xColumnLocale(pFts5, iIdx, pzLocale, pnLocale)\n+**   If parameter iCol is less than zero, or greater than or equal to the\n+**   number of columns in the table, SQLITE_RANGE is returned.\n+**\n+**   Otherwise, this function attempts to retrieve the locale associated\n+**   with column iCol of the current row. Usually, there is no associated\n+**   locale, and output parameters (*pzLocale) and (*pnLocale) are set\n+**   to NULL and 0, respectively. However, if the fts5_locale() function\n+**   was used to associate a locale with the value when it was inserted\n+**   into the fts5 table, then (*pzLocale) is set to point to a nul-terminated\n+**   buffer containing the name of the locale in utf-8 encoding. (*pnLocale)\n+**   is set to the size in bytes of the buffer, not including the\n+**   nul-terminator.\n+**\n+**   If successful, SQLITE_OK is returned. Or, if an error occurs, an\n+**   SQLite error code is returned. The final value of the output parameters\n+**   is undefined in this case.\n+**\n+** xTokenize_v2:\n+**   Tokenize text using the tokenizer belonging to the FTS5 table. This\n+**   API is the same as the xTokenize() API, except that it allows a tokenizer\n+**   locale to be specified.\n@@ -230022,1 +233751,1 @@\n-  int iVersion;                   \/* Currently always set to 3 *\/\n+  int iVersion;                   \/* Currently always set to 4 *\/\n@@ -230064,0 +233793,9 @@\n+\n+  \/* Below this point are iVersion>=4 only *\/\n+  int (*xColumnLocale)(Fts5Context*, int iCol, const char **pz, int *pn);\n+  int (*xTokenize_v2)(Fts5Context*,\n+    const char *pText, int nText,      \/* Text to tokenize *\/\n+    const char *pLocale, int nLocale,  \/* Locale to pass to tokenizer *\/\n+    void *pCtx,                        \/* Context passed to xToken() *\/\n+    int (*xToken)(void*, int, const char*, int, int, int)       \/* Callback *\/\n+  );\n@@ -230084,1 +233822,1 @@\n-**   pointer provided by the application when the fts5_tokenizer object\n+**   pointer provided by the application when the fts5_tokenizer_v2 object\n@@ -230108,1 +233846,1 @@\n-**   The second argument indicates the reason that FTS5 is requesting\n+**   The third argument indicates the reason that FTS5 is requesting\n@@ -230132,0 +233870,7 @@\n+**   The sixth and seventh arguments passed to xTokenize() - pLocale and\n+**   nLocale - are a pointer to a buffer containing the locale to use for\n+**   tokenization (e.g. \"en_US\") and its size in bytes, respectively. The\n+**   pLocale buffer is not nul-terminated. pLocale may be passed NULL (in\n+**   which case nLocale is always 0) to indicate that the tokenizer should\n+**   use its default locale.\n+**\n@@ -230155,0 +233900,24 @@\n+**   If the tokenizer is registered using an fts5_tokenizer_v2 object,\n+**   then the xTokenize() method has two additional arguments - pLocale\n+**   and nLocale. These specify the locale that the tokenizer should use\n+**   for the current request. If pLocale and nLocale are both 0, then the\n+**   tokenizer should use its default locale. Otherwise, pLocale points to\n+**   an nLocale byte buffer containing the name of the locale to use as utf-8\n+**   text. pLocale is not nul-terminated.\n+**\n+** FTS5_TOKENIZER\n+**\n+** There is also an fts5_tokenizer object. This is an older, deprecated,\n+** version of fts5_tokenizer_v2. It is similar except that:\n+**\n+**  <ul>\n+**    <li> There is no \"iVersion\" field, and\n+**    <li> The xTokenize() method does not take a locale argument.\n+**  <\/ul>\n+**\n+** Legacy fts5_tokenizer tokenizers must be registered using the\n+** legacy xCreateTokenizer() function, instead of xCreateTokenizer_v2().\n+**\n+** Tokenizer implementations registered using either API may be retrieved\n+** using both xFindTokenizer() and xFindTokenizer_v2().\n+**\n@@ -230263,0 +234032,27 @@\n+typedef struct fts5_tokenizer_v2 fts5_tokenizer_v2;\n+struct fts5_tokenizer_v2 {\n+  int iVersion;             \/* Currently always 2 *\/\n+\n+  int (*xCreate)(void*, const char **azArg, int nArg, Fts5Tokenizer **ppOut);\n+  void (*xDelete)(Fts5Tokenizer*);\n+  int (*xTokenize)(Fts5Tokenizer*,\n+      void *pCtx,\n+      int flags,            \/* Mask of FTS5_TOKENIZE_* flags *\/\n+      const char *pText, int nText,\n+      const char *pLocale, int nLocale,\n+      int (*xToken)(\n+        void *pCtx,         \/* Copy of 2nd argument to xTokenize() *\/\n+        int tflags,         \/* Mask of FTS5_TOKEN_* flags *\/\n+        const char *pToken, \/* Pointer to buffer containing token *\/\n+        int nToken,         \/* Size of token in bytes *\/\n+        int iStart,         \/* Byte offset of token within input text *\/\n+        int iEnd            \/* Byte offset of end of token within input text *\/\n+      )\n+  );\n+};\n+\n+\/*\n+** New code should use the fts5_tokenizer_v2 type to define tokenizer\n+** implementations. The following type is included for legacy applications\n+** that still use it.\n+*\/\n@@ -230282,0 +234078,1 @@\n+\n@@ -230301,1 +234098,1 @@\n-  int iVersion;                   \/* Currently always set to 2 *\/\n+  int iVersion;                   \/* Currently always set to 3 *\/\n@@ -230328,0 +234125,19 @@\n+\n+  \/* APIs below this point are only available if iVersion>=3 *\/\n+\n+  \/* Create a new tokenizer *\/\n+  int (*xCreateTokenizer_v2)(\n+    fts5_api *pApi,\n+    const char *zName,\n+    void *pUserData,\n+    fts5_tokenizer_v2 *pTokenizer,\n+    void (*xDestroy)(void*)\n+  );\n+\n+  \/* Find an existing tokenizer *\/\n+  int (*xFindTokenizer_v2)(\n+    fts5_api *pApi,\n+    const char *zName,\n+    void **ppUserData,\n+    fts5_tokenizer_v2 **ppTokenizer\n+  );\n@@ -230401,0 +234217,16 @@\n+\/* The uptr type is an unsigned integer large enough to hold a pointer\n+*\/\n+#if defined(HAVE_STDINT_H)\n+  typedef uintptr_t uptr;\n+#elif SQLITE_PTRSIZE==4\n+  typedef u32 uptr;\n+#else\n+  typedef u64 uptr;\n+#endif\n+\n+#ifdef SQLITE_4_BYTE_ALIGNED_MALLOC\n+# define EIGHT_BYTE_ALIGNMENT(X)   ((((uptr)(X) - (uptr)0)&3)==0)\n+#else\n+# define EIGHT_BYTE_ALIGNMENT(X)   ((((uptr)(X) - (uptr)0)&7)==0)\n+#endif\n+\n@@ -230484,0 +234316,12 @@\n+typedef struct Fts5TokenizerConfig Fts5TokenizerConfig;\n+\n+struct Fts5TokenizerConfig {\n+  Fts5Tokenizer *pTok;\n+  fts5_tokenizer_v2 *pApi2;\n+  fts5_tokenizer *pApi1;\n+  const char **azArg;\n+  int nArg;\n+  int ePattern;                   \/* FTS_PATTERN_XXX constant *\/\n+  const char *pLocale;            \/* Current locale to use *\/\n+  int nLocale;                    \/* Size of pLocale in bytes *\/\n+};\n@@ -230523,0 +234367,2 @@\n+** bLocale:\n+**   Set to true if locale=1 was specified when the table was created.\n@@ -230526,0 +234372,1 @@\n+  Fts5Global *pGlobal;            \/* Global fts5 object for handle db *\/\n@@ -230535,0 +234382,1 @@\n+  int bContentlessUnindexed;      \/* \"contentless_unindexed=\" option (dflt=0) *\/\n@@ -230539,0 +234387,1 @@\n+  int bLocale;                    \/* \"locale=\" option value (dflt==0) *\/\n@@ -230541,2 +234390,1 @@\n-  Fts5Tokenizer *pTok;\n-  fts5_tokenizer *pTokApi;\n+  Fts5TokenizerConfig t;\n@@ -230544,1 +234392,1 @@\n-  int ePattern;                   \/* FTS_PATTERN_XXX constant *\/\n+\n@@ -230557,1 +234405,2 @@\n-  int nDeleteMerge;           \/* 'deletemerge' *\/\n+  int nDeleteMerge;               \/* 'deletemerge' *\/\n+  int bPrefixInsttoken;           \/* 'prefix-insttoken' *\/\n@@ -230573,3 +234422,4 @@\n-#define FTS5_CONTENT_NORMAL   0\n-#define FTS5_CONTENT_NONE     1\n-#define FTS5_CONTENT_EXTERNAL 2\n+#define FTS5_CONTENT_NORMAL    0\n+#define FTS5_CONTENT_NONE      1\n+#define FTS5_CONTENT_EXTERNAL  2\n+#define FTS5_CONTENT_UNINDEXED 3\n@@ -230610,0 +234460,2 @@\n+static void sqlite3Fts5ConfigErrmsg(Fts5Config *pConfig, const char *zFmt, ...);\n+\n@@ -230654,1 +234506,1 @@\n-#define FTS5_POS2COLUMN(iPos) (int)(iPos >> 32)\n+#define FTS5_POS2COLUMN(iPos) (int)((iPos >> 32) & 0x7FFFFFFF)\n@@ -230811,1 +234663,8 @@\n-static int sqlite3Fts5IterToken(Fts5IndexIter*, i64, int, int, const char**, int*);\n+static int sqlite3Fts5IterToken(\n+  Fts5IndexIter *pIndexIter,\n+  const char *pToken, int nToken,\n+  i64 iRowid,\n+  int iCol,\n+  int iOff,\n+  const char **ppOut, int *pnOut\n+);\n@@ -230939,7 +234798,1 @@\n-static int sqlite3Fts5GetTokenizer(\n-  Fts5Global*,\n-  const char **azArg,\n-  int nArg,\n-  Fts5Config*,\n-  char **pzErr\n-);\n+static int sqlite3Fts5LoadTokenizer(Fts5Config *pConfig);\n@@ -230951,0 +234804,8 @@\n+static void sqlite3Fts5ClearLocale(Fts5Config *pConfig);\n+static void sqlite3Fts5SetLocale(Fts5Config *pConfig, const char *pLoc, int nLoc);\n+\n+static int sqlite3Fts5IsLocaleValue(Fts5Config *pConfig, sqlite3_value *pVal);\n+static int sqlite3Fts5DecodeLocaleValue(sqlite3_value *pVal,\n+    const char **ppText, int *pnText, const char **ppLoc, int *pnLoc\n+);\n+\n@@ -231030,2 +234891,2 @@\n-static int sqlite3Fts5StorageDelete(Fts5Storage *p, i64, sqlite3_value**);\n-static int sqlite3Fts5StorageContentInsert(Fts5Storage *p, sqlite3_value**, i64*);\n+static int sqlite3Fts5StorageDelete(Fts5Storage *p, i64, sqlite3_value**, int);\n+static int sqlite3Fts5StorageContentInsert(Fts5Storage *p, int, sqlite3_value**, i64*);\n@@ -231056,0 +234917,3 @@\n+static void sqlite3Fts5StorageReleaseDeleteRow(Fts5Storage*);\n+static int sqlite3Fts5StorageFindDeleteRow(Fts5Storage *p, i64 iDel);\n+\n@@ -231208,0 +235072,1 @@\n+static int sqlite3Fts5TokenizerPreload(Fts5TokenizerConfig*);\n@@ -231368,0 +235233,3 @@\n+**    fts5YYREALLOC          Name of the realloc() function to use\n+**    fts5YYFREE             Name of the free() function to use\n+**    fts5YYDYNSTACK         True if stack space should be extended on heap\n@@ -231381,0 +235249,2 @@\n+**    fts5YY_MIN_DSTRCTR     Minimum symbol value that has a destructor\n+**    fts5YY_MAX_DSTRCTR     Maximum symbol value that has a destructor\n@@ -231407,0 +235277,3 @@\n+#define fts5YYREALLOC realloc\n+#define fts5YYFREE free\n+#define fts5YYDYNSTACK 0\n@@ -231424,0 +235297,2 @@\n+#define fts5YY_MIN_DSTRCTR       16\n+#define fts5YY_MAX_DSTRCTR       24\n@@ -231439,0 +235314,16 @@\n+\/* Macro to determine if stack space has the ability to grow using\n+** heap memory.\n+*\/\n+#if fts5YYSTACKDEPTH<=0 || fts5YYDYNSTACK\n+# define fts5YYGROWABLESTACK 1\n+#else\n+# define fts5YYGROWABLESTACK 0\n+#endif\n+\n+\/* Guarantee a minimum number of initial stack slots.\n+*\/\n+#if fts5YYSTACKDEPTH<=0\n+# undef fts5YYSTACKDEPTH\n+# define fts5YYSTACKDEPTH 2  \/* Need a minimum stack size *\/\n+#endif\n+\n@@ -231599,8 +235490,3 @@\n-#if fts5YYSTACKDEPTH<=0\n-  int fts5yystksz;                  \/* Current side of the stack *\/\n-  fts5yyStackEntry *fts5yystack;        \/* The parser's stack *\/\n-  fts5yyStackEntry fts5yystk0;          \/* First stack entry *\/\n-#else\n-  fts5yyStackEntry fts5yystack[fts5YYSTACKDEPTH];  \/* The parser's stack *\/\n-  fts5yyStackEntry *fts5yystackEnd;            \/* Last entry in the stack *\/\n-#endif\n+  fts5yyStackEntry *fts5yystackEnd;           \/* Last entry in the stack *\/\n+  fts5yyStackEntry *fts5yystack;              \/* The parser stack *\/\n+  fts5yyStackEntry fts5yystk0[fts5YYSTACKDEPTH];  \/* Initial stack space *\/\n@@ -231713,1 +235599,1 @@\n-#if fts5YYSTACKDEPTH<=0\n+#if fts5YYGROWABLESTACK\n@@ -231719,0 +235605,1 @@\n+  int oldSize = 1 + (int)(p->fts5yystackEnd - p->fts5yystack);\n@@ -231723,5 +235610,6 @@\n-  newSize = p->fts5yystksz*2 + 100;\n-  idx = p->fts5yytos ? (int)(p->fts5yytos - p->fts5yystack) : 0;\n-  if( p->fts5yystack==&p->fts5yystk0 ){\n-    pNew = malloc(newSize*sizeof(pNew[0]));\n-    if( pNew ) pNew[0] = p->fts5yystk0;\n+  newSize = oldSize*2 + 100;\n+  idx = (int)(p->fts5yytos - p->fts5yystack);\n+  if( p->fts5yystack==p->fts5yystk0 ){\n+    pNew = fts5YYREALLOC(0, newSize*sizeof(pNew[0]));\n+    if( pNew==0 ) return 1;\n+    memcpy(pNew, p->fts5yystack, oldSize*sizeof(pNew[0]));\n@@ -231729,1 +235617,2 @@\n-    pNew = realloc(p->fts5yystack, newSize*sizeof(pNew[0]));\n+    pNew = fts5YYREALLOC(p->fts5yystack, newSize*sizeof(pNew[0]));\n+    if( pNew==0 ) return 1;\n@@ -231731,3 +235620,2 @@\n-  if( pNew ){\n-    p->fts5yystack = pNew;\n-    p->fts5yytos = &p->fts5yystack[idx];\n+  p->fts5yystack = pNew;\n+  p->fts5yytos = &p->fts5yystack[idx];\n@@ -231735,6 +235623,3 @@\n-    if( fts5yyTraceFILE ){\n-      fprintf(fts5yyTraceFILE,\"%sStack grows from %d to %d entries.\\n\",\n-              fts5yyTracePrompt, p->fts5yystksz, newSize);\n-    }\n-#endif\n-    p->fts5yystksz = newSize;\n+  if( fts5yyTraceFILE ){\n+    fprintf(fts5yyTraceFILE,\"%sStack grows from %d to %d entries.\\n\",\n+            fts5yyTracePrompt, oldSize, newSize);\n@@ -231742,1 +235627,3 @@\n-  return pNew==0;\n+#endif\n+  p->fts5yystackEnd = &p->fts5yystack[newSize-1];\n+  return 0;\n@@ -231744,0 +235631,7 @@\n+#endif \/* fts5YYGROWABLESTACK *\/\n+\n+#if !fts5YYGROWABLESTACK\n+\/* For builds that do no have a growable stack, fts5yyGrowStack always\n+** returns an error.\n+*\/\n+# define fts5yyGrowStack(X) 1\n@@ -231763,9 +235657,2 @@\n-#if fts5YYSTACKDEPTH<=0\n-  fts5yypParser->fts5yytos = NULL;\n-  fts5yypParser->fts5yystack = NULL;\n-  fts5yypParser->fts5yystksz = 0;\n-  if( fts5yyGrowStack(fts5yypParser) ){\n-    fts5yypParser->fts5yystack = &fts5yypParser->fts5yystk0;\n-    fts5yypParser->fts5yystksz = 1;\n-  }\n-#endif\n+  fts5yypParser->fts5yystack = fts5yypParser->fts5yystk0;\n+  fts5yypParser->fts5yystackEnd = &fts5yypParser->fts5yystack[fts5YYSTACKDEPTH-1];\n@@ -231778,3 +235665,0 @@\n-#if fts5YYSTACKDEPTH>0\n-  fts5yypParser->fts5yystackEnd = &fts5yypParser->fts5yystack[fts5YYSTACKDEPTH-1];\n-#endif\n@@ -231894,3 +235778,20 @@\n-  while( pParser->fts5yytos>pParser->fts5yystack ) fts5yy_pop_parser_stack(pParser);\n-#if fts5YYSTACKDEPTH<=0\n-  if( pParser->fts5yystack!=&pParser->fts5yystk0 ) free(pParser->fts5yystack);\n+\n+  \/* In-lined version of calling fts5yy_pop_parser_stack() for each\n+  ** element left in the stack *\/\n+  fts5yyStackEntry *fts5yytos = pParser->fts5yytos;\n+  while( fts5yytos>pParser->fts5yystack ){\n+#ifndef NDEBUG\n+    if( fts5yyTraceFILE ){\n+      fprintf(fts5yyTraceFILE,\"%sPopping %s\\n\",\n+        fts5yyTracePrompt,\n+        fts5yyTokenName[fts5yytos->major]);\n+    }\n+#endif\n+    if( fts5yytos->major>=fts5YY_MIN_DSTRCTR ){\n+      fts5yy_destructor(pParser, fts5yytos->major, &fts5yytos->minor);\n+    }\n+    fts5yytos--;\n+  }\n+\n+#if fts5YYGROWABLESTACK\n+  if( pParser->fts5yystack!=pParser->fts5yystk0 ) fts5YYFREE(pParser->fts5yystack);\n@@ -232123,8 +236024,2 @@\n-#if fts5YYSTACKDEPTH>0\n-  if( fts5yypParser->fts5yytos>fts5yypParser->fts5yystackEnd ){\n-    fts5yypParser->fts5yytos--;\n-    fts5yyStackOverflow(fts5yypParser);\n-    return;\n-  }\n-#else\n-  if( fts5yypParser->fts5yytos>=&fts5yypParser->fts5yystack[fts5yypParser->fts5yystksz] ){\n+  fts5yytos = fts5yypParser->fts5yytos;\n+  if( fts5yytos>fts5yypParser->fts5yystackEnd ){\n@@ -232136,0 +236031,2 @@\n+    fts5yytos = fts5yypParser->fts5yytos;\n+    assert( fts5yytos <= fts5yypParser->fts5yystackEnd );\n@@ -232137,1 +236034,0 @@\n-#endif\n@@ -232141,1 +236037,0 @@\n-  fts5yytos = fts5yypParser->fts5yytos;\n@@ -232578,1 +236473,0 @@\n-#if fts5YYSTACKDEPTH>0\n@@ -232580,5 +236474,0 @@\n-          fts5yyStackOverflow(fts5yypParser);\n-          break;\n-        }\n-#else\n-        if( fts5yypParser->fts5yytos>=&fts5yypParser->fts5yystack[fts5yypParser->fts5yystksz-1] ){\n@@ -232590,1 +236479,0 @@\n-#endif\n@@ -232962,0 +236850,1 @@\n+\n@@ -232992,0 +236881,2 @@\n+    const char *pLoc = 0;         \/* Locale of column iCol *\/\n+    int nLoc = 0;                 \/* Size of pLoc in bytes *\/\n@@ -232997,1 +236888,6 @@\n-      rc = pApi->xTokenize(pFts, ctx.zIn, ctx.nIn, (void*)&ctx,fts5HighlightCb);\n+      rc = pApi->xColumnLocale(pFts, iCol, &pLoc, &nLoc);\n+    }\n+    if( rc==SQLITE_OK ){\n+      rc = pApi->xTokenize_v2(\n+          pFts, ctx.zIn, ctx.nIn, pLoc, nLoc, (void*)&ctx, fts5HighlightCb\n+      );\n@@ -233194,0 +237090,2 @@\n+      const char *pLoc = 0;       \/* Locale of column iCol *\/\n+      int nLoc = 0;               \/* Size of pLoc in bytes *\/\n@@ -233201,2 +237099,4 @@\n-      rc = pApi->xTokenize(pFts,\n-          sFinder.zDoc, nDoc, (void*)&sFinder,fts5SentenceFinderCb\n+      rc = pApi->xColumnLocale(pFts, i, &pLoc, &nLoc);\n+      if( rc!=SQLITE_OK ) break;\n+      rc = pApi->xTokenize_v2(pFts,\n+          sFinder.zDoc, nDoc, pLoc, nLoc, (void*)&sFinder, fts5SentenceFinderCb\n@@ -233260,0 +237160,3 @@\n+    const char *pLoc = 0;         \/* Locale of column iBestCol *\/\n+    int nLoc = 0;                 \/* Bytes in pLoc *\/\n+\n@@ -233278,1 +237181,6 @@\n-      rc = pApi->xTokenize(pFts, ctx.zIn, ctx.nIn, (void*)&ctx,fts5HighlightCb);\n+      rc = pApi->xColumnLocale(pFts, iBestCol, &pLoc, &nLoc);\n+    }\n+    if( rc==SQLITE_OK ){\n+      rc = pApi->xTokenize_v2(\n+          pFts, ctx.zIn, ctx.nIn, pLoc, nLoc, (void*)&ctx,fts5HighlightCb\n+      );\n@@ -233462,0 +237370,47 @@\n+\/*\n+** Implementation of fts5_get_locale() function.\n+*\/\n+static void fts5GetLocaleFunction(\n+  const Fts5ExtensionApi *pApi,   \/* API offered by current FTS version *\/\n+  Fts5Context *pFts,              \/* First arg to pass to pApi functions *\/\n+  sqlite3_context *pCtx,          \/* Context for returning result\/error *\/\n+  int nVal,                       \/* Number of values in apVal[] array *\/\n+  sqlite3_value **apVal           \/* Array of trailing arguments *\/\n+){\n+  int iCol = 0;\n+  int eType = 0;\n+  int rc = SQLITE_OK;\n+  const char *zLocale = 0;\n+  int nLocale = 0;\n+\n+  \/* xColumnLocale() must be available *\/\n+  assert( pApi->iVersion>=4 );\n+\n+  if( nVal!=1 ){\n+    const char *z = \"wrong number of arguments to function fts5_get_locale()\";\n+    sqlite3_result_error(pCtx, z, -1);\n+    return;\n+  }\n+\n+  eType = sqlite3_value_numeric_type(apVal[0]);\n+  if( eType!=SQLITE_INTEGER ){\n+    const char *z = \"non-integer argument passed to function fts5_get_locale()\";\n+    sqlite3_result_error(pCtx, z, -1);\n+    return;\n+  }\n+\n+  iCol = sqlite3_value_int(apVal[0]);\n+  if( iCol<0 || iCol>=pApi->xColumnCount(pFts) ){\n+    sqlite3_result_error_code(pCtx, SQLITE_RANGE);\n+    return;\n+  }\n+\n+  rc = pApi->xColumnLocale(pFts, iCol, &zLocale, &nLocale);\n+  if( rc!=SQLITE_OK ){\n+    sqlite3_result_error_code(pCtx, rc);\n+    return;\n+  }\n+\n+  sqlite3_result_text(pCtx, zLocale, nLocale, SQLITE_TRANSIENT);\n+}\n+\n@@ -233469,3 +237424,4 @@\n-    { \"snippet\",   0, fts5SnippetFunction, 0 },\n-    { \"highlight\", 0, fts5HighlightFunction, 0 },\n-    { \"bm25\",      0, fts5Bm25Function,    0 },\n+    { \"snippet\",         0, fts5SnippetFunction,   0 },\n+    { \"highlight\",       0, fts5HighlightFunction, 0 },\n+    { \"bm25\",            0, fts5Bm25Function,      0 },\n+    { \"fts5_get_locale\", 0, fts5GetLocaleFunction, 0 },\n@@ -234136,1 +238092,0 @@\n-  Fts5Global *pGlobal,\n@@ -234144,0 +238099,1 @@\n+\n@@ -234200,3 +238156,1 @@\n-    char **azArg = sqlite3Fts5MallocZero(&rc, sizeof(char*) * nArg);\n-    char *pDel = sqlite3Fts5MallocZero(&rc, nArg * 2);\n-    char *pSpace = pDel;\n+    char **azArg = sqlite3Fts5MallocZero(&rc, (sizeof(char*) + 2) * nArg);\n@@ -234204,2 +238158,3 @@\n-    if( azArg && pSpace ){\n-      if( pConfig->pTok ){\n+    if( azArg ){\n+      char *pSpace = (char*)&azArg[nArg];\n+      if( pConfig->t.azArg ){\n@@ -234228,4 +238183,3 @@\n-          rc = sqlite3Fts5GetTokenizer(pGlobal,\n-              (const char**)azArg, (int)nArg, pConfig,\n-              pzErr\n-          );\n+          pConfig->t.azArg = (const char**)azArg;\n+          pConfig->t.nArg = nArg;\n+          azArg = 0;\n@@ -234235,1 +238189,0 @@\n-\n@@ -234237,1 +238190,1 @@\n-    sqlite3_free(pDel);\n+\n@@ -234266,0 +238219,10 @@\n+  if( sqlite3_strnicmp(\"contentless_unindexed\", zCmd, nCmd)==0 ){\n+    if( (zArg[0]!='0' && zArg[0]!='1') || zArg[1]!='\\0' ){\n+      *pzErr = sqlite3_mprintf(\"malformed contentless_delete=... directive\");\n+      rc = SQLITE_ERROR;\n+    }else{\n+      pConfig->bContentlessUnindexed = (zArg[0]=='1');\n+    }\n+    return rc;\n+  }\n+\n@@ -234286,0 +238249,10 @@\n+  if( sqlite3_strnicmp(\"locale\", zCmd, nCmd)==0 ){\n+    if( (zArg[0]!='0' && zArg[0]!='1') || zArg[1]!='\\0' ){\n+      *pzErr = sqlite3_mprintf(\"malformed locale=... directive\");\n+      rc = SQLITE_ERROR;\n+    }else{\n+      pConfig->bLocale = (zArg[0]=='1');\n+    }\n+    return rc;\n+  }\n+\n@@ -234314,10 +238287,0 @@\n-\/*\n-** Allocate an instance of the default tokenizer (\"simple\") at\n-** Fts5Config.pTokenizer. Return SQLITE_OK if successful, or an SQLite error\n-** code if an error occurs.\n-*\/\n-static int fts5ConfigDefaultTokenizer(Fts5Global *pGlobal, Fts5Config *pConfig){\n-  assert( pConfig->pTok==0 && pConfig->pTokApi==0 );\n-  return sqlite3Fts5GetTokenizer(pGlobal, 0, 0, pConfig, 0);\n-}\n-\n@@ -234383,1 +238346,2 @@\n-  char **pzErr\n+  char **pzErr,\n+  int *pbUnindexed\n@@ -234394,0 +238358,1 @@\n+      *pbUnindexed = 1;\n@@ -234414,0 +238379,4 @@\n+    assert( p->eContent==FTS5_CONTENT_EXTERNAL\n+         || p->eContent==FTS5_CONTENT_NORMAL\n+         || p->eContent==FTS5_CONTENT_UNINDEXED\n+    );\n@@ -234417,1 +238386,1 @@\n-      }else{\n+      }else if( p->eContent==FTS5_CONTENT_NORMAL || p->abUnindexed[i] ){\n@@ -234419,0 +238388,11 @@\n+      }else{\n+        sqlite3Fts5BufferAppendPrintf(&rc, &buf, \", NULL\");\n+      }\n+    }\n+  }\n+  if( p->eContent==FTS5_CONTENT_NORMAL && p->bLocale ){\n+    for(i=0; i<p->nCol; i++){\n+      if( p->abUnindexed[i]==0 ){\n+        sqlite3Fts5BufferAppendPrintf(&rc, &buf, \", T.l%d\", i);\n+      }else{\n+        sqlite3Fts5BufferAppendPrintf(&rc, &buf, \", NULL\");\n@@ -234452,0 +238432,1 @@\n+  int bUnindexed = 0;             \/* True if there are one or more UNINDEXED *\/\n@@ -234456,0 +238437,1 @@\n+  pRet->pGlobal = pGlobal;\n@@ -234504,1 +238486,1 @@\n-          rc = fts5ConfigParseSpecial(pGlobal, pRet,\n+          rc = fts5ConfigParseSpecial(pRet,\n@@ -234510,1 +238492,1 @@\n-          rc = fts5ConfigParseColumn(pRet, zOne, zTwo, pzErr);\n+          rc = fts5ConfigParseColumn(pRet, zOne, zTwo, pzErr, &bUnindexed);\n@@ -234542,5 +238524,11 @@\n-  \/* If a tokenizer= option was successfully parsed, the tokenizer has\n-  ** already been allocated. Otherwise, allocate an instance of the default\n-  ** tokenizer (unicode61) now.  *\/\n-  if( rc==SQLITE_OK && pRet->pTok==0 ){\n-    rc = fts5ConfigDefaultTokenizer(pGlobal, pRet);\n+  \/* We only allow contentless_unindexed=1 if the table is actually a\n+  ** contentless one.\n+  *\/\n+  if( rc==SQLITE_OK\n+   && pRet->bContentlessUnindexed\n+   && pRet->eContent!=FTS5_CONTENT_NONE\n+  ){\n+    *pzErr = sqlite3_mprintf(\n+        \"contentless_unindexed=1 requires a contentless table\"\n+    );\n+    rc = SQLITE_ERROR;\n@@ -234557,0 +238545,3 @@\n+    }else if( bUnindexed && pRet->bContentlessUnindexed ){\n+      pRet->eContent = FTS5_CONTENT_UNINDEXED;\n+      zTail = \"content\";\n@@ -234590,2 +238581,6 @@\n-    if( pConfig->pTok ){\n-      pConfig->pTokApi->xDelete(pConfig->pTok);\n+    if( pConfig->t.pTok ){\n+      if( pConfig->t.pApi1 ){\n+        pConfig->t.pApi1->xDelete(pConfig->t.pTok);\n+      }else{\n+        pConfig->t.pApi2->xDelete(pConfig->t.pTok);\n+      }\n@@ -234593,0 +238588,1 @@\n+    sqlite3_free((char*)pConfig->t.azArg);\n@@ -234667,4 +238663,18 @@\n-  if( pText==0 ) return SQLITE_OK;\n-  return pConfig->pTokApi->xTokenize(\n-      pConfig->pTok, pCtx, flags, pText, nText, xToken\n-  );\n+  int rc = SQLITE_OK;\n+  if( pText ){\n+    if( pConfig->t.pTok==0 ){\n+      rc = sqlite3Fts5LoadTokenizer(pConfig);\n+    }\n+    if( rc==SQLITE_OK ){\n+      if( pConfig->t.pApi1 ){\n+        rc = pConfig->t.pApi1->xTokenize(\n+            pConfig->t.pTok, pCtx, flags, pText, nText, xToken\n+        );\n+      }else{\n+        rc = pConfig->t.pApi2->xTokenize(pConfig->t.pTok, pCtx, flags,\n+            pText, nText, pConfig->t.pLocale, pConfig->t.nLocale, xToken\n+        );\n+      }\n+    }\n+  }\n+  return rc;\n@@ -234874,0 +238884,13 @@\n+  }\n+\n+  else if( 0==sqlite3_stricmp(zKey, \"insttoken\") ){\n+    int bVal = -1;\n+    if( SQLITE_INTEGER==sqlite3_value_numeric_type(pVal) ){\n+      bVal = sqlite3_value_int(pVal);\n+    }\n+    if( bVal<0 ){\n+      *pbBadkey = 1;\n+    }else{\n+      pConfig->bPrefixInsttoken = (bVal ? 1 : 0);\n+    }\n+\n@@ -234924,7 +238947,4 @@\n-    if( pConfig->pzErrmsg ){\n-      assert( 0==*pConfig->pzErrmsg );\n-      *pConfig->pzErrmsg = sqlite3_mprintf(\"invalid fts5 file format \"\n-          \"(found %d, expected %d or %d) - run 'rebuild'\",\n-          iVersion, FTS5_CURRENT_VERSION, FTS5_CURRENT_VERSION_SECUREDELETE\n-      );\n-    }\n+    sqlite3Fts5ConfigErrmsg(pConfig, \"invalid fts5 file format \"\n+        \"(found %d, expected %d or %d) - run 'rebuild'\",\n+        iVersion, FTS5_CURRENT_VERSION, FTS5_CURRENT_VERSION_SECUREDELETE\n+    );\n@@ -234941,0 +238961,23 @@\n+\/*\n+** Set (*pConfig->pzErrmsg) to point to an sqlite3_malloc()ed buffer\n+** containing the error message created using printf() style formatting\n+** string zFmt and its trailing arguments.\n+*\/\n+static void sqlite3Fts5ConfigErrmsg(Fts5Config *pConfig, const char *zFmt, ...){\n+  va_list ap;                     \/* ... printf arguments *\/\n+  char *zMsg = 0;\n+\n+  va_start(ap, zFmt);\n+  zMsg = sqlite3_vmprintf(zFmt, ap);\n+  if( pConfig->pzErrmsg ){\n+    assert( *pConfig->pzErrmsg==0 );\n+    *pConfig->pzErrmsg = zMsg;\n+  }else{\n+    sqlite3_free(zMsg);\n+  }\n+\n+  va_end(ap);\n+}\n+\n+\n+\n@@ -234997,1 +239040,1 @@\n-**   Expression node type. Always one of:\n+**   Expression node type. Usually one of:\n@@ -235005,0 +239048,4 @@\n+**   An expression node with eType==0 may also exist. It always matches zero\n+**   rows. This is created when a phrase containing no tokens is parsed.\n+**   e.g. \"\".\n+**\n@@ -235225,0 +239272,1 @@\n+  assert( sParse.pExpr || sParse.rc!=SQLITE_OK );\n@@ -235229,1 +239277,1 @@\n-  if( iCol<pConfig->nCol && sParse.pExpr && sParse.rc==SQLITE_OK ){\n+  if( sParse.rc==SQLITE_OK && iCol<pConfig->nCol ){\n@@ -235246,9 +239294,1 @@\n-      if( !sParse.pExpr ){\n-        const int nByte = sizeof(Fts5ExprNode);\n-        pNew->pRoot = (Fts5ExprNode*)sqlite3Fts5MallocZero(&sParse.rc, nByte);\n-        if( pNew->pRoot ){\n-          pNew->pRoot->bEof = 1;\n-        }\n-      }else{\n-        pNew->pRoot = sParse.pExpr;\n-      }\n+      pNew->pRoot = sParse.pExpr;\n@@ -235267,1 +239307,5 @@\n-  *pzErr = sParse.zErr;\n+  if( 0==*pzErr ){\n+    *pzErr = sParse.zErr;\n+  }else{\n+    sqlite3_free(sParse.zErr);\n+  }\n@@ -236068,1 +240112,1 @@\n-          if( pIter->iRowid==iLast || pIter->bEof ) continue;\n+          if( pIter->iRowid==iLast ) continue;\n@@ -236590,3 +240634,0 @@\n-    if( pPhrase==0 ){\n-      return pNear;\n-    }\n@@ -236814,0 +240855,1 @@\n+    assert( pParse->apPhrase!=0 );\n@@ -236833,1 +240875,1 @@\n-  if( iPhrase<0 || iPhrase>=pExpr->nPhrase ){\n+  if( !pExpr || iPhrase<0 || iPhrase>=pExpr->nPhrase ){\n@@ -237201,0 +241243,3 @@\n+\/*\n+** Add pSub as a child of p.\n+*\/\n@@ -237345,1 +241390,1 @@\n-              sqlite3_free(pRet);\n+              sqlite3Fts5ParseNodeFree(pRet);\n@@ -237347,0 +241392,2 @@\n+              pNear = 0;\n+              assert( pLeft==0 && pRight==0 );\n@@ -237350,0 +241397,1 @@\n+          assert( pNear==0 );\n@@ -237352,0 +241400,1 @@\n+          pLeft = pRight = 0;\n@@ -237357,1 +241406,1 @@\n-            sqlite3_free(pRet);\n+            sqlite3Fts5ParseNodeFree(pRet);\n@@ -237395,0 +241444,1 @@\n+        || (pRight->eType==FTS5_AND && pParse->bPhraseToAnd)\n@@ -237408,0 +241458,2 @@\n+      assert( pParse->apPhrase!=0 );\n+      assert( pParse->nPhrase>0 );\n@@ -237980,1 +242032,1 @@\n-        if( rc==SQLITE_OK && pExpr->pConfig->bTokendata && !pT->bPrefix ){\n+        if( rc==SQLITE_OK && (pExpr->pConfig->bTokendata || pT->bPrefix) ){\n@@ -238040,0 +242092,1 @@\n+    case 0:\n@@ -238172,9 +242225,8 @@\n-  if( pTerm->bPrefix==0 ){\n-    if( pExpr->pConfig->bTokendata ){\n-      rc = sqlite3Fts5IterToken(\n-          pTerm->pIter, iRowid, iCol, iOff+iToken, ppOut, pnOut\n-      );\n-    }else{\n-      *ppOut = pTerm->pTerm;\n-      *pnOut = pTerm->nFullTerm;\n-    }\n+  if( pExpr->pConfig->bTokendata || pTerm->bPrefix ){\n+    rc = sqlite3Fts5IterToken(\n+        pTerm->pIter, pTerm->pTerm, pTerm->nQueryTerm,\n+        iRowid, iCol, iOff+iToken, ppOut, pnOut\n+    );\n+  }else{\n+    *ppOut = pTerm->pTerm;\n+    *pnOut = pTerm->nFullTerm;\n@@ -239570,1 +243622,1 @@\n-static void sqlite3Fts5IndexCloseReader(Fts5Index *p){\n+static void fts5IndexCloseReader(Fts5Index *p){\n@@ -239572,0 +243624,1 @@\n+    int rc;\n@@ -239574,1 +243627,2 @@\n-    sqlite3_blob_close(pReader);\n+    rc = sqlite3_blob_close(pReader);\n+    if( p->rc==SQLITE_OK ) p->rc = rc;\n@@ -239599,1 +243653,1 @@\n-        sqlite3Fts5IndexCloseReader(p);\n+        fts5IndexCloseReader(p);\n@@ -239623,1 +243677,2 @@\n-      sqlite3_int64 nAlloc = sizeof(Fts5Data) + nByte + FTS5_DATA_PADDING;\n+      int szData = (sizeof(Fts5Data) + 7) & ~7;\n+      sqlite3_int64 nAlloc = szData + nByte + FTS5_DATA_PADDING;\n@@ -239627,1 +243682,1 @@\n-        aOut = pRet->p = (u8*)&pRet[1];\n+        aOut = pRet->p = (u8*)pRet + szData;\n@@ -239650,0 +243705,1 @@\n+  assert( pRet==0 || EIGHT_BYTE_ALIGNMENT( pRet->p ) );\n@@ -239681,1 +243737,1 @@\n-      p->rc = sqlite3_prepare_v3(p->pConfig->db, zSql, -1,\n+      int rc = sqlite3_prepare_v3(p->pConfig->db, zSql, -1,\n@@ -239684,0 +243740,4 @@\n+      \/* If this prepare() call fails with SQLITE_ERROR, then one of the\n+      ** %_idx or %_data tables has been removed or modified. Call this\n+      ** corruption.  *\/\n+      p->rc = (rc==SQLITE_ERROR ? SQLITE_CORRUPT : rc);\n@@ -240975,1 +245035,1 @@\n-    i64 iDelta;\n+    u64 iDelta;\n@@ -243679,0 +247739,5 @@\n+\n+      \/* If pLvl is already the input level to an ongoing merge, look no\n+      ** further for a merge candidate. The caller should be allowed to\n+      ** continue merging from pLvl first.  *\/\n+      if( pLvl->nMerge ) break;\n@@ -243790,0 +247855,8 @@\n+\/*\n+** Close the read-only blob handle, if it is open.\n+*\/\n+static void sqlite3Fts5IndexCloseReader(Fts5Index *p){\n+  fts5IndexCloseReader(p);\n+  fts5IndexReturn(p);\n+}\n+\n@@ -244247,0 +248320,3 @@\n+**\n+** Return SQLITE_OK if successful, or an SQLite error code if an error\n+** has occurred. Any error code is also stored in the Fts5Index handle.\n@@ -244248,1 +248324,1 @@\n-static void fts5FlushSecureDelete(\n+static int fts5FlushSecureDelete(\n@@ -244258,0 +248334,18 @@\n+  \/* If the version number has not been set to SECUREDELETE, do so now. *\/\n+  if( p->pConfig->iVersion!=FTS5_CURRENT_VERSION_SECUREDELETE ){\n+    Fts5Config *pConfig = p->pConfig;\n+    sqlite3_stmt *pStmt = 0;\n+    fts5IndexPrepareStmt(p, &pStmt, sqlite3_mprintf(\n+          \"REPLACE INTO %Q.'%q_config' VALUES ('version', %d)\",\n+          pConfig->zDb, pConfig->zName, FTS5_CURRENT_VERSION_SECUREDELETE\n+    ));\n+    if( p->rc==SQLITE_OK ){\n+      int rc;\n+      sqlite3_step(pStmt);\n+      rc = sqlite3_finalize(pStmt);\n+      if( p->rc==SQLITE_OK ) p->rc = rc;\n+      pConfig->iCookie++;\n+      pConfig->iVersion = FTS5_CURRENT_VERSION_SECUREDELETE;\n+    }\n+  }\n+\n@@ -244275,0 +248369,1 @@\n+  return p->rc;\n@@ -244358,2 +248453,3 @@\n-                if( iOff<nDoclist && pDoclist[iOff]==0x00 ){\n-                  fts5FlushSecureDelete(p, pStruct, zTerm, nTerm, iRowid);\n+                if( iOff<nDoclist && pDoclist[iOff]==0x00\n+                 && !fts5FlushSecureDelete(p, pStruct, zTerm, nTerm, iRowid)\n+                ){\n@@ -244368,2 +248464,3 @@\n-              }else if( (pDoclist[iOff] & 0x01) ){\n-                fts5FlushSecureDelete(p, pStruct, zTerm, nTerm, iRowid);\n+              }else if( (pDoclist[iOff] & 0x01)\n+                && !fts5FlushSecureDelete(p, pStruct, zTerm, nTerm, iRowid)\n+              ){\n@@ -244988,0 +249085,377 @@\n+\n+\/*\n+** Iterate through a range of entries in the FTS index, invoking the xVisit\n+** callback for each of them.\n+**\n+** Parameter pToken points to an nToken buffer containing an FTS index term\n+** (i.e. a document term with the preceding 1 byte index identifier -\n+** FTS5_MAIN_PREFIX or similar). If bPrefix is true, then the call visits\n+** all entries for terms that have pToken\/nToken as a prefix. If bPrefix\n+** is false, then only entries with pToken\/nToken as the entire key are\n+** visited.\n+**\n+** If the current table is a tokendata=1 table, then if bPrefix is true then\n+** each index term is treated separately. However, if bPrefix is false, then\n+** all index terms corresponding to pToken\/nToken are collapsed into a single\n+** term before the callback is invoked.\n+**\n+** The callback invoked for each entry visited is specified by paramter xVisit.\n+** Each time it is invoked, it is passed a pointer to the Fts5Index object,\n+** a copy of the 7th paramter to this function (pCtx) and a pointer to the\n+** iterator that indicates the current entry. If the current entry is the\n+** first with a new term (i.e. different from that of the previous entry,\n+** including the very first term), then the final two parameters are passed\n+** a pointer to the term and its size in bytes, respectively. If the current\n+** entry is not the first associated with its term, these two parameters\n+** are passed 0.\n+**\n+** If parameter pColset is not NULL, then it is used to filter entries before\n+** the callback is invoked.\n+*\/\n+static int fts5VisitEntries(\n+  Fts5Index *p,                   \/* Fts5 index object *\/\n+  Fts5Colset *pColset,            \/* Columns filter to apply, or NULL *\/\n+  u8 *pToken,                     \/* Buffer containing token *\/\n+  int nToken,                     \/* Size of buffer pToken in bytes *\/\n+  int bPrefix,                    \/* True for a prefix scan *\/\n+  void (*xVisit)(Fts5Index*, void *pCtx, Fts5Iter *pIter, const u8*, int),\n+  void *pCtx                      \/* Passed as second argument to xVisit() *\/\n+){\n+  const int flags = (bPrefix ? FTS5INDEX_QUERY_SCAN : 0)\n+                  | FTS5INDEX_QUERY_SKIPEMPTY\n+                  | FTS5INDEX_QUERY_NOOUTPUT;\n+  Fts5Iter *p1 = 0;     \/* Iterator used to gather data from index *\/\n+  int bNewTerm = 1;\n+  Fts5Structure *pStruct = fts5StructureRead(p);\n+\n+  fts5MultiIterNew(p, pStruct, flags, pColset, pToken, nToken, -1, 0, &p1);\n+  fts5IterSetOutputCb(&p->rc, p1);\n+  for( \/* no-op *\/ ;\n+      fts5MultiIterEof(p, p1)==0;\n+      fts5MultiIterNext2(p, p1, &bNewTerm)\n+  ){\n+    Fts5SegIter *pSeg = &p1->aSeg[ p1->aFirst[1].iFirst ];\n+    int nNew = 0;\n+    const u8 *pNew = 0;\n+\n+    p1->xSetOutputs(p1, pSeg);\n+    if( p->rc ) break;\n+\n+    if( bNewTerm ){\n+      nNew = pSeg->term.n;\n+      pNew = pSeg->term.p;\n+      if( nNew<nToken || memcmp(pToken, pNew, nToken) ) break;\n+    }\n+\n+    xVisit(p, pCtx, p1, pNew, nNew);\n+  }\n+  fts5MultiIterFree(p1);\n+\n+  fts5StructureRelease(pStruct);\n+  return p->rc;\n+}\n+\n+\n+\/*\n+** Usually, a tokendata=1 iterator (struct Fts5TokenDataIter) accumulates an\n+** array of these for each row it visits (so all iRowid fields are the same).\n+** Or, for an iterator used by an \"ORDER BY rank\" query, it accumulates an\n+** array of these for the entire query (in which case iRowid fields may take\n+** a variety of values).\n+**\n+** Each instance in the array indicates the iterator (and therefore term)\n+** associated with position iPos of rowid iRowid. This is used by the\n+** xInstToken() API.\n+**\n+** iRowid:\n+**   Rowid for the current entry.\n+**\n+** iPos:\n+**   Position of current entry within row. In the usual ((iCol<<32)+iOff)\n+**   format (e.g. see macros FTS5_POS2COLUMN() and FTS5_POS2OFFSET()).\n+**\n+** iIter:\n+**   If the Fts5TokenDataIter iterator that the entry is part of is\n+**   actually an iterator (i.e. with nIter>0, not just a container for\n+**   Fts5TokenDataMap structures), then this variable is an index into\n+**   the apIter[] array. The corresponding term is that which the iterator\n+**   at apIter[iIter] currently points to.\n+**\n+**   Or, if the Fts5TokenDataIter iterator is just a container object\n+**   (nIter==0), then iIter is an index into the term.p[] buffer where\n+**   the term is stored.\n+**\n+** nByte:\n+**   In the case where iIter is an index into term.p[], this variable\n+**   is the size of the term in bytes. If iIter is an index into apIter[],\n+**   this variable is unused.\n+*\/\n+struct Fts5TokenDataMap {\n+  i64 iRowid;                     \/* Row this token is located in *\/\n+  i64 iPos;                       \/* Position of token *\/\n+  int iIter;                      \/* Iterator token was read from *\/\n+  int nByte;                      \/* Length of token in bytes (or 0) *\/\n+};\n+\n+\/*\n+** An object used to supplement Fts5Iter for tokendata=1 iterators.\n+**\n+** This object serves two purposes. The first is as a container for an array\n+** of Fts5TokenDataMap structures, which are used to find the token required\n+** when the xInstToken() API is used. This is done by the nMapAlloc, nMap and\n+** aMap[] variables.\n+*\/\n+struct Fts5TokenDataIter {\n+  int nMapAlloc;                  \/* Allocated size of aMap[] in entries *\/\n+  int nMap;                       \/* Number of valid entries in aMap[] *\/\n+  Fts5TokenDataMap *aMap;         \/* Array of (rowid+pos -> token) mappings *\/\n+\n+  \/* The following are used for prefix-queries only. *\/\n+  Fts5Buffer terms;\n+\n+  \/* The following are used for other full-token tokendata queries only. *\/\n+  int nIter;\n+  int nIterAlloc;\n+  Fts5PoslistReader *aPoslistReader;\n+  int *aPoslistToIter;\n+  Fts5Iter *apIter[1];\n+};\n+\n+\/*\n+** The two input arrays - a1[] and a2[] - are in sorted order. This function\n+** merges the two arrays together and writes the result to output array\n+** aOut[]. aOut[] is guaranteed to be large enough to hold the result.\n+**\n+** Duplicate entries are copied into the output. So the size of the output\n+** array is always (n1+n2) entries.\n+*\/\n+static void fts5TokendataMerge(\n+  Fts5TokenDataMap *a1, int n1,   \/* Input array 1 *\/\n+  Fts5TokenDataMap *a2, int n2,   \/* Input array 2 *\/\n+  Fts5TokenDataMap *aOut          \/* Output array *\/\n+){\n+  int i1 = 0;\n+  int i2 = 0;\n+\n+  assert( n1>=0 && n2>=0 );\n+  while( i1<n1 || i2<n2 ){\n+    Fts5TokenDataMap *pOut = &aOut[i1+i2];\n+    if( i2>=n2 || (i1<n1 && (\n+        a1[i1].iRowid<a2[i2].iRowid\n+     || (a1[i1].iRowid==a2[i2].iRowid && a1[i1].iPos<=a2[i2].iPos)\n+    ))){\n+      memcpy(pOut, &a1[i1], sizeof(Fts5TokenDataMap));\n+      i1++;\n+    }else{\n+      memcpy(pOut, &a2[i2], sizeof(Fts5TokenDataMap));\n+      i2++;\n+    }\n+  }\n+}\n+\n+\n+\/*\n+** Append a mapping to the token-map belonging to object pT.\n+*\/\n+static void fts5TokendataIterAppendMap(\n+  Fts5Index *p,\n+  Fts5TokenDataIter *pT,\n+  int iIter,\n+  int nByte,\n+  i64 iRowid,\n+  i64 iPos\n+){\n+  if( p->rc==SQLITE_OK ){\n+    if( pT->nMap==pT->nMapAlloc ){\n+      int nNew = pT->nMapAlloc ? pT->nMapAlloc*2 : 64;\n+      int nAlloc = nNew * sizeof(Fts5TokenDataMap);\n+      Fts5TokenDataMap *aNew;\n+\n+      aNew = (Fts5TokenDataMap*)sqlite3_realloc(pT->aMap, nAlloc);\n+      if( aNew==0 ){\n+        p->rc = SQLITE_NOMEM;\n+        return;\n+      }\n+\n+      pT->aMap = aNew;\n+      pT->nMapAlloc = nNew;\n+    }\n+\n+    pT->aMap[pT->nMap].iRowid = iRowid;\n+    pT->aMap[pT->nMap].iPos = iPos;\n+    pT->aMap[pT->nMap].iIter = iIter;\n+    pT->aMap[pT->nMap].nByte = nByte;\n+    pT->nMap++;\n+  }\n+}\n+\n+\/*\n+** Sort the contents of the pT->aMap[] array.\n+**\n+** The sorting algorithm requries a malloc(). If this fails, an error code\n+** is left in Fts5Index.rc before returning.\n+*\/\n+static void fts5TokendataIterSortMap(Fts5Index *p, Fts5TokenDataIter *pT){\n+  Fts5TokenDataMap *aTmp = 0;\n+  int nByte = pT->nMap * sizeof(Fts5TokenDataMap);\n+\n+  aTmp = (Fts5TokenDataMap*)sqlite3Fts5MallocZero(&p->rc, nByte);\n+  if( aTmp ){\n+    Fts5TokenDataMap *a1 = pT->aMap;\n+    Fts5TokenDataMap *a2 = aTmp;\n+    i64 nHalf;\n+\n+    for(nHalf=1; nHalf<pT->nMap; nHalf=nHalf*2){\n+      int i1;\n+      for(i1=0; i1<pT->nMap; i1+=(nHalf*2)){\n+        int n1 = MIN(nHalf, pT->nMap-i1);\n+        int n2 = MIN(nHalf, pT->nMap-i1-n1);\n+        fts5TokendataMerge(&a1[i1], n1, &a1[i1+n1], n2, &a2[i1]);\n+      }\n+      SWAPVAL(Fts5TokenDataMap*, a1, a2);\n+    }\n+\n+    if( a1!=pT->aMap ){\n+      memcpy(pT->aMap, a1, pT->nMap*sizeof(Fts5TokenDataMap));\n+    }\n+    sqlite3_free(aTmp);\n+\n+#ifdef SQLITE_DEBUG\n+    {\n+      int ii;\n+      for(ii=1; ii<pT->nMap; ii++){\n+        Fts5TokenDataMap *p1 = &pT->aMap[ii-1];\n+        Fts5TokenDataMap *p2 = &pT->aMap[ii];\n+        assert( p1->iRowid<p2->iRowid\n+             || (p1->iRowid==p2->iRowid && p1->iPos<=p2->iPos)\n+        );\n+      }\n+    }\n+#endif\n+  }\n+}\n+\n+\/*\n+** Delete an Fts5TokenDataIter structure and its contents.\n+*\/\n+static void fts5TokendataIterDelete(Fts5TokenDataIter *pSet){\n+  if( pSet ){\n+    int ii;\n+    for(ii=0; ii<pSet->nIter; ii++){\n+      fts5MultiIterFree(pSet->apIter[ii]);\n+    }\n+    fts5BufferFree(&pSet->terms);\n+    sqlite3_free(pSet->aPoslistReader);\n+    sqlite3_free(pSet->aMap);\n+    sqlite3_free(pSet);\n+  }\n+}\n+\n+\n+\/*\n+** fts5VisitEntries() context object used by fts5SetupPrefixIterTokendata()\n+** to pass data to prefixIterSetupTokendataCb().\n+*\/\n+typedef struct TokendataSetupCtx TokendataSetupCtx;\n+struct TokendataSetupCtx {\n+  Fts5TokenDataIter *pT;          \/* Object being populated with mappings *\/\n+  int iTermOff;                   \/* Offset of current term in terms.p[] *\/\n+  int nTermByte;                  \/* Size of current term in bytes *\/\n+};\n+\n+\/*\n+** fts5VisitEntries() callback used by fts5SetupPrefixIterTokendata(). This\n+** callback adds an entry to the Fts5TokenDataIter.aMap[] array for each\n+** position in the current position-list. It doesn't matter that some of\n+** these may be out of order - they will be sorted later.\n+*\/\n+static void prefixIterSetupTokendataCb(\n+  Fts5Index *p,\n+  void *pCtx,\n+  Fts5Iter *p1,\n+  const u8 *pNew,\n+  int nNew\n+){\n+  TokendataSetupCtx *pSetup = (TokendataSetupCtx*)pCtx;\n+  int iPosOff = 0;\n+  i64 iPos = 0;\n+\n+  if( pNew ){\n+    pSetup->nTermByte = nNew-1;\n+    pSetup->iTermOff = pSetup->pT->terms.n;\n+    fts5BufferAppendBlob(&p->rc, &pSetup->pT->terms, nNew-1, pNew+1);\n+  }\n+\n+  while( 0==sqlite3Fts5PoslistNext64(\n+     p1->base.pData, p1->base.nData, &iPosOff, &iPos\n+  ) ){\n+    fts5TokendataIterAppendMap(p,\n+        pSetup->pT, pSetup->iTermOff, pSetup->nTermByte, p1->base.iRowid, iPos\n+    );\n+  }\n+}\n+\n+\n+\/*\n+** Context object passed by fts5SetupPrefixIter() to fts5VisitEntries().\n+*\/\n+typedef struct PrefixSetupCtx PrefixSetupCtx;\n+struct PrefixSetupCtx {\n+  void (*xMerge)(Fts5Index*, Fts5Buffer*, int, Fts5Buffer*);\n+  void (*xAppend)(Fts5Index*, u64, Fts5Iter*, Fts5Buffer*);\n+  i64 iLastRowid;\n+  int nMerge;\n+  Fts5Buffer *aBuf;\n+  int nBuf;\n+  Fts5Buffer doclist;\n+  TokendataSetupCtx *pTokendata;\n+};\n+\n+\/*\n+** fts5VisitEntries() callback used by fts5SetupPrefixIter()\n+*\/\n+static void prefixIterSetupCb(\n+  Fts5Index *p,\n+  void *pCtx,\n+  Fts5Iter *p1,\n+  const u8 *pNew,\n+  int nNew\n+){\n+  PrefixSetupCtx *pSetup = (PrefixSetupCtx*)pCtx;\n+  const int nMerge = pSetup->nMerge;\n+\n+  if( p1->base.nData>0 ){\n+    if( p1->base.iRowid<=pSetup->iLastRowid && pSetup->doclist.n>0 ){\n+      int i;\n+      for(i=0; p->rc==SQLITE_OK && pSetup->doclist.n; i++){\n+        int i1 = i*nMerge;\n+        int iStore;\n+        assert( i1+nMerge<=pSetup->nBuf );\n+        for(iStore=i1; iStore<i1+nMerge; iStore++){\n+          if( pSetup->aBuf[iStore].n==0 ){\n+            fts5BufferSwap(&pSetup->doclist, &pSetup->aBuf[iStore]);\n+            fts5BufferZero(&pSetup->doclist);\n+            break;\n+          }\n+        }\n+        if( iStore==i1+nMerge ){\n+          pSetup->xMerge(p, &pSetup->doclist, nMerge, &pSetup->aBuf[i1]);\n+          for(iStore=i1; iStore<i1+nMerge; iStore++){\n+            fts5BufferZero(&pSetup->aBuf[iStore]);\n+          }\n+        }\n+      }\n+      pSetup->iLastRowid = 0;\n+    }\n+\n+    pSetup->xAppend(\n+        p, (u64)p1->base.iRowid-(u64)pSetup->iLastRowid, p1, &pSetup->doclist\n+    );\n+    pSetup->iLastRowid = p1->base.iRowid;\n+  }\n+\n+  if( pSetup->pTokendata ){\n+    prefixIterSetupTokendataCb(p, (void*)pSetup->pTokendata, p1, pNew, nNew);\n+  }\n+}\n+\n@@ -244998,3 +249472,16 @@\n-  Fts5Buffer *aBuf;\n-  int nBuf = 32;\n-  int nMerge = 1;\n+  PrefixSetupCtx s;\n+  TokendataSetupCtx s2;\n+\n+  memset(&s, 0, sizeof(s));\n+  memset(&s2, 0, sizeof(s2));\n+\n+  s.nMerge = 1;\n+  s.iLastRowid = 0;\n+  s.nBuf = 32;\n+  if( iIdx==0\n+   && p->pConfig->eDetail==FTS5_DETAIL_FULL\n+   && p->pConfig->bPrefixInsttoken\n+  ){\n+    s.pTokendata = &s2;\n+    s2.pT = (Fts5TokenDataIter*)fts5IdxMalloc(p, sizeof(*s2.pT));\n+  }\n@@ -245002,2 +249489,0 @@\n-  void (*xMerge)(Fts5Index*, Fts5Buffer*, int, Fts5Buffer*);\n-  void (*xAppend)(Fts5Index*, u64, Fts5Iter*, Fts5Buffer*);\n@@ -245005,2 +249490,2 @@\n-    xMerge = fts5MergeRowidLists;\n-    xAppend = fts5AppendRowid;\n+    s.xMerge = fts5MergeRowidLists;\n+    s.xAppend = fts5AppendRowid;\n@@ -245008,4 +249493,4 @@\n-    nMerge = FTS5_MERGE_NLIST-1;\n-    nBuf = nMerge*8;   \/* Sufficient to merge (16^8)==(2^32) lists *\/\n-    xMerge = fts5MergePrefixLists;\n-    xAppend = fts5AppendPoslist;\n+    s.nMerge = FTS5_MERGE_NLIST-1;\n+    s.nBuf = s.nMerge*8;   \/* Sufficient to merge (16^8)==(2^32) lists *\/\n+    s.xMerge = fts5MergePrefixLists;\n+    s.xAppend = fts5AppendPoslist;\n@@ -245014,1 +249499,1 @@\n-  aBuf = (Fts5Buffer*)fts5IdxMalloc(p, sizeof(Fts5Buffer)*nBuf);\n+  s.aBuf = (Fts5Buffer*)fts5IdxMalloc(p, sizeof(Fts5Buffer)*s.nBuf);\n@@ -245016,1 +249501,1 @@\n-  assert( p->rc!=SQLITE_OK || (aBuf && pStruct) );\n+  assert( p->rc!=SQLITE_OK || (s.aBuf && pStruct) );\n@@ -245019,3 +249504,1 @@\n-    const int flags = FTS5INDEX_QUERY_SCAN\n-                    | FTS5INDEX_QUERY_SKIPEMPTY\n-                    | FTS5INDEX_QUERY_NOOUTPUT;\n+    void *pCtx = (void*)&s;\n@@ -245023,2 +249506,0 @@\n-    i64 iLastRowid = 0;\n-    Fts5Iter *p1 = 0;     \/* Iterator used to gather data from index *\/\n@@ -245026,4 +249507,0 @@\n-    Fts5Buffer doclist;\n-    int bNewTerm = 1;\n-\n-    memset(&doclist, 0, sizeof(doclist));\n@@ -245037,2 +249514,0 @@\n-      int dummy = 0;\n-      const int f2 = FTS5INDEX_QUERY_SKIPEMPTY|FTS5INDEX_QUERY_NOOUTPUT;\n@@ -245040,14 +249515,1 @@\n-      fts5MultiIterNew(p, pStruct, f2, pColset, pToken, nToken, -1, 0, &p1);\n-      fts5IterSetOutputCb(&p->rc, p1);\n-      for(;\n-        fts5MultiIterEof(p, p1)==0;\n-        fts5MultiIterNext2(p, p1, &dummy)\n-      ){\n-        Fts5SegIter *pSeg = &p1->aSeg[ p1->aFirst[1].iFirst ];\n-        p1->xSetOutputs(p1, pSeg);\n-        if( p1->base.nData ){\n-          xAppend(p, (u64)p1->base.iRowid-(u64)iLastRowid, p1, &doclist);\n-          iLastRowid = p1->base.iRowid;\n-        }\n-      }\n-      fts5MultiIterFree(p1);\n+      fts5VisitEntries(p, pColset, pToken, nToken, 0, prefixIterSetupCb, pCtx);\n@@ -245057,43 +249519,1 @@\n-    fts5MultiIterNew(p, pStruct, flags, pColset, pToken, nToken, -1, 0, &p1);\n-    fts5IterSetOutputCb(&p->rc, p1);\n-\n-    for( \/* no-op *\/ ;\n-        fts5MultiIterEof(p, p1)==0;\n-        fts5MultiIterNext2(p, p1, &bNewTerm)\n-    ){\n-      Fts5SegIter *pSeg = &p1->aSeg[ p1->aFirst[1].iFirst ];\n-      int nTerm = pSeg->term.n;\n-      const u8 *pTerm = pSeg->term.p;\n-      p1->xSetOutputs(p1, pSeg);\n-\n-      assert_nc( memcmp(pToken, pTerm, MIN(nToken, nTerm))<=0 );\n-      if( bNewTerm ){\n-        if( nTerm<nToken || memcmp(pToken, pTerm, nToken) ) break;\n-      }\n-\n-      if( p1->base.nData==0 ) continue;\n-      if( p1->base.iRowid<=iLastRowid && doclist.n>0 ){\n-        for(i=0; p->rc==SQLITE_OK && doclist.n; i++){\n-          int i1 = i*nMerge;\n-          int iStore;\n-          assert( i1+nMerge<=nBuf );\n-          for(iStore=i1; iStore<i1+nMerge; iStore++){\n-            if( aBuf[iStore].n==0 ){\n-              fts5BufferSwap(&doclist, &aBuf[iStore]);\n-              fts5BufferZero(&doclist);\n-              break;\n-            }\n-          }\n-          if( iStore==i1+nMerge ){\n-            xMerge(p, &doclist, nMerge, &aBuf[i1]);\n-            for(iStore=i1; iStore<i1+nMerge; iStore++){\n-              fts5BufferZero(&aBuf[iStore]);\n-            }\n-          }\n-        }\n-        iLastRowid = 0;\n-      }\n-\n-      xAppend(p, (u64)p1->base.iRowid-(u64)iLastRowid, p1, &doclist);\n-      iLastRowid = p1->base.iRowid;\n-    }\n+    fts5VisitEntries(p, pColset, pToken, nToken, 1, prefixIterSetupCb, pCtx);\n@@ -245101,2 +249521,2 @@\n-    assert( (nBuf%nMerge)==0 );\n-    for(i=0; i<nBuf; i+=nMerge){\n+    assert( (s.nBuf%s.nMerge)==0 );\n+    for(i=0; i<s.nBuf; i+=s.nMerge){\n@@ -245105,1 +249525,1 @@\n-        xMerge(p, &doclist, nMerge, &aBuf[i]);\n+        s.xMerge(p, &s.doclist, s.nMerge, &s.aBuf[i]);\n@@ -245107,2 +249527,2 @@\n-      for(iFree=i; iFree<i+nMerge; iFree++){\n-        fts5BufferFree(&aBuf[iFree]);\n+      for(iFree=i; iFree<i+s.nMerge; iFree++){\n+        fts5BufferFree(&s.aBuf[iFree]);\n@@ -245111,1 +249531,0 @@\n-    fts5MultiIterFree(p1);\n@@ -245113,1 +249532,2 @@\n-    pData = fts5IdxMalloc(p, sizeof(*pData)+doclist.n+FTS5_DATA_ZERO_PADDING);\n+    pData = fts5IdxMalloc(p, sizeof(*pData)+s.doclist.n+FTS5_DATA_ZERO_PADDING);\n+    assert( pData!=0 || p->rc!=SQLITE_OK );\n@@ -245116,2 +249536,2 @@\n-      pData->nn = pData->szLeaf = doclist.n;\n-      if( doclist.n ) memcpy(pData->p, doclist.p, doclist.n);\n+      pData->nn = pData->szLeaf = s.doclist.n;\n+      if( s.doclist.n ) memcpy(pData->p, s.doclist.p, s.doclist.n);\n@@ -245120,1 +249540,7 @@\n-    fts5BufferFree(&doclist);\n+\n+    assert( (*ppIter)!=0 || p->rc!=SQLITE_OK );\n+    if( p->rc==SQLITE_OK && s.pTokendata ){\n+      fts5TokendataIterSortMap(p, s2.pT);\n+      (*ppIter)->pTokenDataIter = s2.pT;\n+      s2.pT = 0;\n+    }\n@@ -245123,0 +249549,2 @@\n+  fts5TokendataIterDelete(s2.pT);\n+  fts5BufferFree(&s.doclist);\n@@ -245124,1 +249552,1 @@\n-  sqlite3_free(aBuf);\n+  sqlite3_free(s.aBuf);\n@@ -245162,1 +249590,1 @@\n-  sqlite3Fts5IndexCloseReader(p);\n+  fts5IndexCloseReader(p);\n@@ -245173,1 +249601,1 @@\n-  sqlite3Fts5IndexCloseReader(p);\n+  fts5IndexCloseReader(p);\n@@ -245176,2 +249604,1 @@\n-  \/* assert( p->rc==SQLITE_OK ); *\/\n-  return SQLITE_OK;\n+  return fts5IndexReturn(p);\n@@ -245378,31 +249805,9 @@\n-\/*\n-** Usually, a tokendata=1 iterator (struct Fts5TokenDataIter) accumulates an\n-** array of these for each row it visits. Or, for an iterator used by an\n-** \"ORDER BY rank\" query, it accumulates an array of these for the entire\n-** query.\n-**\n-** Each instance in the array indicates the iterator (and therefore term)\n-** associated with position iPos of rowid iRowid. This is used by the\n-** xInstToken() API.\n-*\/\n-struct Fts5TokenDataMap {\n-  i64 iRowid;                     \/* Row this token is located in *\/\n-  i64 iPos;                       \/* Position of token *\/\n-  int iIter;                      \/* Iterator token was read from *\/\n-};\n-\n-\/*\n-** An object used to supplement Fts5Iter for tokendata=1 iterators.\n-*\/\n-struct Fts5TokenDataIter {\n-  int nIter;\n-  int nIterAlloc;\n-\n-  int nMap;\n-  int nMapAlloc;\n-  Fts5TokenDataMap *aMap;\n-\n-  Fts5PoslistReader *aPoslistReader;\n-  int *aPoslistToIter;\n-  Fts5Iter *apIter[1];\n-};\n+static void fts5IterClose(Fts5IndexIter *pIndexIter){\n+  if( pIndexIter ){\n+    Fts5Iter *pIter = (Fts5Iter*)pIndexIter;\n+    Fts5Index *pIndex = pIter->pIndex;\n+    fts5TokendataIterDelete(pIter->pTokenDataIter);\n+    fts5MultiIterFree(pIter);\n+    fts5IndexCloseReader(pIndex);\n+  }\n+}\n@@ -245437,1 +249842,1 @@\n-    sqlite3Fts5IterClose((Fts5IndexIter*)pAppend);\n+    fts5IterClose((Fts5IndexIter*)pAppend);\n@@ -245446,48 +249851,0 @@\n-\/*\n-** Delete an Fts5TokenDataIter structure and its contents.\n-*\/\n-static void fts5TokendataIterDelete(Fts5TokenDataIter *pSet){\n-  if( pSet ){\n-    int ii;\n-    for(ii=0; ii<pSet->nIter; ii++){\n-      fts5MultiIterFree(pSet->apIter[ii]);\n-    }\n-    sqlite3_free(pSet->aPoslistReader);\n-    sqlite3_free(pSet->aMap);\n-    sqlite3_free(pSet);\n-  }\n-}\n-\n-\/*\n-** Append a mapping to the token-map belonging to object pT.\n-*\/\n-static void fts5TokendataIterAppendMap(\n-  Fts5Index *p,\n-  Fts5TokenDataIter *pT,\n-  int iIter,\n-  i64 iRowid,\n-  i64 iPos\n-){\n-  if( p->rc==SQLITE_OK ){\n-    if( pT->nMap==pT->nMapAlloc ){\n-      int nNew = pT->nMapAlloc ? pT->nMapAlloc*2 : 64;\n-      int nByte = nNew * sizeof(Fts5TokenDataMap);\n-      Fts5TokenDataMap *aNew;\n-\n-      aNew = (Fts5TokenDataMap*)sqlite3_realloc(pT->aMap, nByte);\n-      if( aNew==0 ){\n-        p->rc = SQLITE_NOMEM;\n-        return;\n-      }\n-\n-      pT->aMap = aNew;\n-      pT->nMapAlloc = nNew;\n-    }\n-\n-    pT->aMap[pT->nMap].iRowid = iRowid;\n-    pT->aMap[pT->nMap].iPos = iPos;\n-    pT->aMap[pT->nMap].iIter = iIter;\n-    pT->nMap++;\n-  }\n-}\n-\n@@ -245534,1 +249891,1 @@\n-      fts5TokendataIterAppendMap(pIter->pIndex, pT, iMin, iRowid, -1);\n+      fts5TokendataIterAppendMap(pIter->pIndex, pT, iMin, 0, iRowid, -1);\n@@ -245698,1 +250055,1 @@\n-      sqlite3Fts5IterClose((Fts5IndexIter*)pNew);\n+      fts5IterClose((Fts5IndexIter*)pNew);\n@@ -245763,1 +250120,1 @@\n-      sqlite3Fts5IterClose((Fts5IndexIter*)pNew);\n+      fts5IterClose((Fts5IndexIter*)pNew);\n@@ -245787,0 +250144,1 @@\n+    pRet->nSeg = 0;\n@@ -245802,1 +250160,0 @@\n-\n@@ -245825,0 +250182,1 @@\n+    assert( buf.p!=0 );\n@@ -245827,0 +250185,5 @@\n+    \/* The NOTOKENDATA flag is set when each token in a tokendata=1 table\n+    ** should be treated individually, instead of merging all those with\n+    ** a common prefix into a single entry. This is used, for example, by\n+    ** queries performed as part of an integrity-check, or by the fts5vocab\n+    ** module.  *\/\n@@ -245857,1 +250220,1 @@\n-      buf.p[0] = '0';\n+      buf.p[0] = FTS5_MAIN_PREFIX;\n@@ -245870,1 +250233,1 @@\n-      \/* Scan multiple terms in the main index *\/\n+      \/* Scan multiple terms in the main index for a prefix query. *\/\n@@ -245886,1 +250249,1 @@\n-      sqlite3Fts5IterClose((Fts5IndexIter*)pRet);\n+      fts5IterClose((Fts5IndexIter*)pRet);\n@@ -245888,1 +250251,1 @@\n-      sqlite3Fts5IndexCloseReader(p);\n+      fts5IndexCloseReader(p);\n@@ -245906,1 +250269,2 @@\n-  if( pIter->pTokenDataIter ){\n+  if( pIter->nSeg==0 ){\n+    assert( pIter->pTokenDataIter );\n@@ -245943,1 +250307,2 @@\n-  if( pIter->pTokenDataIter ){\n+  if( pIter->nSeg==0 ){\n+    assert( pIter->pTokenDataIter );\n@@ -245962,0 +250327,44 @@\n+\/*\n+** pIter is a prefix query. This function populates pIter->pTokenDataIter\n+** with an Fts5TokenDataIter object containing mappings for all rows\n+** matched by the query.\n+*\/\n+static int fts5SetupPrefixIterTokendata(\n+  Fts5Iter *pIter,\n+  const char *pToken,             \/* Token prefix to search for *\/\n+  int nToken                      \/* Size of pToken in bytes *\/\n+){\n+  Fts5Index *p = pIter->pIndex;\n+  Fts5Buffer token = {0, 0, 0};\n+  TokendataSetupCtx ctx;\n+\n+  memset(&ctx, 0, sizeof(ctx));\n+\n+  fts5BufferGrow(&p->rc, &token, nToken+1);\n+  assert( token.p!=0 || p->rc!=SQLITE_OK );\n+  ctx.pT = (Fts5TokenDataIter*)sqlite3Fts5MallocZero(&p->rc, sizeof(*ctx.pT));\n+\n+  if( p->rc==SQLITE_OK ){\n+\n+    \/* Fill in the token prefix to search for *\/\n+    token.p[0] = FTS5_MAIN_PREFIX;\n+    memcpy(&token.p[1], pToken, nToken);\n+    token.n = nToken+1;\n+\n+    fts5VisitEntries(\n+        p, 0, token.p, token.n, 1, prefixIterSetupTokendataCb, (void*)&ctx\n+    );\n+\n+    fts5TokendataIterSortMap(p, ctx.pT);\n+  }\n+\n+  if( p->rc==SQLITE_OK ){\n+    pIter->pTokenDataIter = ctx.pT;\n+  }else{\n+    fts5TokendataIterDelete(ctx.pT);\n+  }\n+  fts5BufferFree(&token);\n+\n+  return fts5IndexReturn(p);\n+}\n+\n@@ -245967,0 +250376,2 @@\n+**\n+** pToken\/nToken:\n@@ -245970,0 +250381,1 @@\n+  const char *pToken, int nToken,\n@@ -245977,1 +250389,0 @@\n-  Fts5TokenDataMap *aMap = pT->aMap;\n@@ -245979,1 +250390,1 @@\n-\n+  Fts5TokenDataMap *aMap = 0;\n@@ -245981,1 +250392,1 @@\n-  int i2 = pT->nMap;\n+  int i2 = 0;\n@@ -245984,0 +250395,10 @@\n+  assert( pT || (pToken && pIter->nSeg>0) );\n+  if( pT==0 ){\n+    int rc = fts5SetupPrefixIterTokendata(pIter, pToken, nToken);\n+    if( rc!=SQLITE_OK ) return rc;\n+    pT = pIter->pTokenDataIter;\n+  }\n+\n+  i2 = pT->nMap;\n+  aMap = pT->aMap;\n+\n@@ -246006,3 +250427,9 @@\n-    Fts5Iter *pMap = pT->apIter[aMap[iTest].iIter];\n-    *ppOut = (const char*)pMap->aSeg[0].term.p+1;\n-    *pnOut = pMap->aSeg[0].term.n-1;\n+    if( pIter->nSeg==0 ){\n+      Fts5Iter *pMap = pT->apIter[aMap[iTest].iIter];\n+      *ppOut = (const char*)pMap->aSeg[0].term.p+1;\n+      *pnOut = pMap->aSeg[0].term.n-1;\n+    }else{\n+      Fts5TokenDataMap *p = &aMap[iTest];\n+      *ppOut = (const char*)&pT->terms.p[p->iIter];\n+      *pnOut = aMap[iTest].nByte;\n+    }\n@@ -246020,1 +250447,3 @@\n-  if( pIter && pIter->pTokenDataIter ){\n+  if( pIter && pIter->pTokenDataIter\n+   && (pIter->nSeg==0 || pIter->pIndex->pConfig->eDetail!=FTS5_DETAIL_FULL)\n+  ){\n@@ -246040,1 +250469,1 @@\n-  int ii;\n+  i64 iPos = (((i64)iCol)<<32) + iOff;\n@@ -246043,8 +250472,20 @@\n-  assert( pIter->pTokenDataIter );\n-\n-  for(ii=0; ii<pT->nIter; ii++){\n-    Fts5Buffer *pTerm = &pT->apIter[ii]->aSeg[0].term;\n-    if( nToken==pTerm->n-1 && memcmp(pToken, pTerm->p+1, nToken)==0 ) break;\n-  }\n-  if( ii<pT->nIter ){\n-    fts5TokendataIterAppendMap(p, pT, ii, iRowid, (((i64)iCol)<<32) + iOff);\n+  assert( pIter->pTokenDataIter || pIter->nSeg>0 );\n+  if( pIter->nSeg>0 ){\n+    \/* This is a prefix term iterator. *\/\n+    if( pT==0 ){\n+      pT = (Fts5TokenDataIter*)sqlite3Fts5MallocZero(&p->rc, sizeof(*pT));\n+      pIter->pTokenDataIter = pT;\n+    }\n+    if( pT ){\n+      fts5TokendataIterAppendMap(p, pT, pT->terms.n, nToken, iRowid, iPos);\n+      fts5BufferAppendBlob(&p->rc, &pT->terms, nToken, (const u8*)pToken);\n+    }\n+  }else{\n+    int ii;\n+    for(ii=0; ii<pT->nIter; ii++){\n+      Fts5Buffer *pTerm = &pT->apIter[ii]->aSeg[0].term;\n+      if( nToken==pTerm->n-1 && memcmp(pToken, pTerm->p+1, nToken)==0 ) break;\n+    }\n+    if( ii<pT->nIter ){\n+      fts5TokendataIterAppendMap(p, pT, ii, 0, iRowid, iPos);\n+    }\n@@ -246060,5 +250501,3 @@\n-    Fts5Iter *pIter = (Fts5Iter*)pIndexIter;\n-    Fts5Index *pIndex = pIter->pIndex;\n-    fts5TokendataIterDelete(pIter->pTokenDataIter);\n-    fts5MultiIterFree(pIter);\n-    sqlite3Fts5IndexCloseReader(pIndex);\n+    Fts5Index *pIndex = ((Fts5Iter*)pIndexIter)->pIndex;\n+    fts5IterClose(pIndexIter);\n+    fts5IndexReturn(pIndex);\n@@ -246594,1 +251033,1 @@\n-  sqlite3Fts5IterClose(pIter);\n+  fts5IterClose(pIter);\n@@ -247603,1 +252042,1 @@\n-** into the xFilter method.  If there is no valid stmt=? constraint,\n+** into the xFilter method.  If there is no valid struct=? constraint,\n@@ -247945,0 +252384,1 @@\n+  u32 aLocaleHdr[4];\n@@ -247947,0 +252387,9 @@\n+\/*\n+** Size of header on fts5_locale() values. And macro to access a buffer\n+** containing a copy of the header from an Fts5Config pointer.\n+*\/\n+#define FTS5_LOCALE_HDR_SIZE ((int)sizeof( ((Fts5Global*)0)->aLocaleHdr ))\n+#define FTS5_LOCALE_HDR(pConfig) ((const u8*)(pConfig->pGlobal->aLocaleHdr))\n+\n+#define FTS5_INSTTOKEN_SUBTYPE 73\n+\n@@ -247965,0 +252414,15 @@\n+**\n+** bV2Native:\n+**  True if the tokenizer was registered using xCreateTokenizer_v2(), false\n+**  for xCreateTokenizer(). If this variable is true, then x2 is populated\n+**  with the routines as supplied by the caller and x1 contains synthesized\n+**  wrapper routines. In this case the user-data pointer passed to\n+**  x1.xCreate should be a pointer to the Fts5TokenizerModule structure,\n+**  not a copy of pUserData.\n+**\n+**  Of course, if bV2Native is false, then x1 contains the real routines and\n+**  x2 the synthesized ones. In this case a pointer to the Fts5TokenizerModule\n+**  object should be passed to x2.xCreate.\n+**\n+**  The synthesized wrapper routines are necessary for xFindTokenizer(_v2)\n+**  calls.\n@@ -247969,1 +252433,3 @@\n-  fts5_tokenizer x;               \/* Tokenizer functions *\/\n+  int bV2Native;                  \/* True if v2 native tokenizer *\/\n+  fts5_tokenizer x1;              \/* Tokenizer functions *\/\n+  fts5_tokenizer_v2 x2;           \/* V2 tokenizer functions *\/\n@@ -248057,1 +252523,1 @@\n-  \/* Cache used by auxiliary functions xInst() and xInstCount() *\/\n+  \/* Cache used by auxiliary API functions xInst() and xInstCount() *\/\n@@ -248168,1 +252634,3 @@\n-** Return true if pTab is a contentless table.\n+** Return true if pTab is a contentless table. If parameter bIncludeUnindexed\n+** is true, this includes contentless tables that store UNINDEXED columns\n+** only.\n@@ -248170,2 +252638,6 @@\n-static int fts5IsContentless(Fts5FullTable *pTab){\n-  return pTab->p.pConfig->eContent==FTS5_CONTENT_NONE;\n+static int fts5IsContentless(Fts5FullTable *pTab, int bIncludeUnindexed){\n+  int eContent = pTab->p.pConfig->eContent;\n+  return (\n+    eContent==FTS5_CONTENT_NONE\n+    || (bIncludeUnindexed && eContent==FTS5_CONTENT_UNINDEXED)\n+  );\n@@ -248239,0 +252711,1 @@\n+    pConfig->pzErrmsg = pzErr;\n@@ -248241,0 +252714,3 @@\n+    if( bCreate || sqlite3Fts5TokenizerPreload(&pConfig->t) ){\n+      rc = sqlite3Fts5LoadTokenizer(pConfig);\n+    }\n@@ -248262,5 +252738,1 @@\n-    assert( pConfig->pzErrmsg==0 );\n-    pConfig->pzErrmsg = pzErr;\n-    rc = sqlite3Fts5IndexLoadConfig(pTab->p.pIndex);\n-    sqlite3Fts5IndexRollback(pTab->p.pIndex);\n-    pConfig->pzErrmsg = 0;\n+    rc = sqlite3Fts5ConfigLoad(pTab->p.pConfig, pTab->p.pConfig->iCookie-1);\n@@ -248276,0 +252748,1 @@\n+  if( pConfig ) pConfig->pzErrmsg = 0;\n@@ -248343,1 +252816,1 @@\n-  if( pConfig->ePattern==FTS5_PATTERN_GLOB && p->op==FTS5_PATTERN_GLOB ){\n+  if( pConfig->t.ePattern==FTS5_PATTERN_GLOB && p->op==FTS5_PATTERN_GLOB ){\n@@ -248346,1 +252819,1 @@\n-  if( pConfig->ePattern==FTS5_PATTERN_LIKE\n+  if( pConfig->t.ePattern==FTS5_PATTERN_LIKE\n@@ -248393,1 +252866,2 @@\n-** Costs are assigned as follows:\n+** If an unusable MATCH operator is present in the WHERE clause, then\n+** SQLITE_CONSTRAINT is returned.\n@@ -248395,2 +252869,1 @@\n-**  a) If an unusable MATCH operator is present in the WHERE clause, the\n-**     cost is unconditionally set to 1e50 (a really big number).\n+** Costs are assigned as follows:\n@@ -248429,1 +252902,1 @@\n-  int bSeenMatch = 0;\n+  int nSeenMatch = 0;\n@@ -248460,3 +252933,1 @@\n-        ** unusable plan. Set a prohibitively high cost. *\/\n-        pInfo->estimatedCost = 1e50;\n-        assert( iIdxStr < pInfo->nConstraint*6 + 1 );\n+        ** unusable plan. Return SQLITE_CONSTRAINT. *\/\n@@ -248464,1 +252935,1 @@\n-        return SQLITE_OK;\n+        return SQLITE_CONSTRAINT;\n@@ -248470,2 +252941,2 @@\n-        }else if( iCol>=0 ){\n-          bSeenMatch = 1;\n+        }else{\n+          nSeenMatch++;\n@@ -248488,0 +252959,1 @@\n+        nSeenMatch++;\n@@ -248524,1 +252996,1 @@\n-    if( iSort==(pConfig->nCol+1) && bSeenMatch ){\n+    if( iSort==(pConfig->nCol+1) && nSeenMatch>0 ){\n@@ -248539,2 +253011,2 @@\n-    pInfo->estimatedCost = bSeenMatch ? 100.0 : 10.0;\n-    if( bSeenMatch==0 ) fts5SetUniqueFlag(pInfo);\n+    pInfo->estimatedCost = nSeenMatch ? 1000.0 : 10.0;\n+    if( nSeenMatch==0 ) fts5SetUniqueFlag(pInfo);\n@@ -248542,1 +253014,1 @@\n-    pInfo->estimatedCost = bSeenMatch ? 500.0 : 250000.0;\n+    pInfo->estimatedCost = nSeenMatch ? 5000.0 : 250000.0;\n@@ -248544,1 +253016,1 @@\n-    pInfo->estimatedCost = bSeenMatch ? 750.0 : 750000.0;\n+    pInfo->estimatedCost = nSeenMatch ? 7500.0 : 750000.0;\n@@ -248546,1 +253018,4 @@\n-    pInfo->estimatedCost = bSeenMatch ? 1000.0 : 1000000.0;\n+    pInfo->estimatedCost = nSeenMatch ? 10000.0 : 1000000.0;\n+  }\n+  for(i=1; i<nSeenMatch; i++){\n+    pInfo->estimatedCost *= 0.4;\n@@ -248822,0 +253297,1 @@\n+          CsrFlagSet(pCsr, FTS5CSR_REQUIRE_DOCSIZE);\n@@ -248851,1 +253327,1 @@\n-      *pConfig->pzErrmsg = sqlite3_mprintf(\"%s\", sqlite3_errmsg(pConfig->db));\n+      sqlite3Fts5ConfigErrmsg(pConfig, \"%s\", sqlite3_errmsg(pConfig->db));\n@@ -249075,0 +253551,139 @@\n+\/*\n+** Set the error message on the virtual table passed as the first argument.\n+*\/\n+static void fts5SetVtabError(Fts5FullTable *p, const char *zFormat, ...){\n+  va_list ap;                     \/* ... printf arguments *\/\n+  va_start(ap, zFormat);\n+  sqlite3_free(p->p.base.zErrMsg);\n+  p->p.base.zErrMsg = sqlite3_vmprintf(zFormat, ap);\n+  va_end(ap);\n+}\n+\n+\/*\n+** Arrange for subsequent calls to sqlite3Fts5Tokenize() to use the locale\n+** specified by pLocale\/nLocale. The buffer indicated by pLocale must remain\n+** valid until after the final call to sqlite3Fts5Tokenize() that will use\n+** the locale.\n+*\/\n+static void sqlite3Fts5SetLocale(\n+  Fts5Config *pConfig,\n+  const char *zLocale,\n+  int nLocale\n+){\n+  Fts5TokenizerConfig *pT = &pConfig->t;\n+  pT->pLocale = zLocale;\n+  pT->nLocale = nLocale;\n+}\n+\n+\/*\n+** Clear any locale configured by an earlier call to sqlite3Fts5SetLocale().\n+*\/\n+static void sqlite3Fts5ClearLocale(Fts5Config *pConfig){\n+  sqlite3Fts5SetLocale(pConfig, 0, 0);\n+}\n+\n+\/*\n+** Return true if the value passed as the only argument is an\n+** fts5_locale() value.\n+*\/\n+static int sqlite3Fts5IsLocaleValue(Fts5Config *pConfig, sqlite3_value *pVal){\n+  int ret = 0;\n+  if( sqlite3_value_type(pVal)==SQLITE_BLOB ){\n+    \/* Call sqlite3_value_bytes() after sqlite3_value_blob() in this case.\n+    ** If the blob was created using zeroblob(), then sqlite3_value_blob()\n+    ** may call malloc(). If this malloc() fails, then the values returned\n+    ** by both value_blob() and value_bytes() will be 0. If value_bytes() were\n+    ** called first, then the NULL pointer returned by value_blob() might\n+    ** be dereferenced.  *\/\n+    const u8 *pBlob = sqlite3_value_blob(pVal);\n+    int nBlob = sqlite3_value_bytes(pVal);\n+    if( nBlob>FTS5_LOCALE_HDR_SIZE\n+     && 0==memcmp(pBlob, FTS5_LOCALE_HDR(pConfig), FTS5_LOCALE_HDR_SIZE)\n+    ){\n+      ret = 1;\n+    }\n+  }\n+  return ret;\n+}\n+\n+\/*\n+** Value pVal is guaranteed to be an fts5_locale() value, according to\n+** sqlite3Fts5IsLocaleValue(). This function extracts the text and locale\n+** from the value and returns them separately.\n+**\n+** If successful, SQLITE_OK is returned and (*ppText) and (*ppLoc) set\n+** to point to buffers containing the text and locale, as utf-8,\n+** respectively. In this case output parameters (*pnText) and (*pnLoc) are\n+** set to the sizes in bytes of these two buffers.\n+**\n+** Or, if an error occurs, then an SQLite error code is returned. The final\n+** value of the four output parameters is undefined in this case.\n+*\/\n+static int sqlite3Fts5DecodeLocaleValue(\n+  sqlite3_value *pVal,\n+  const char **ppText,\n+  int *pnText,\n+  const char **ppLoc,\n+  int *pnLoc\n+){\n+  const char *p = sqlite3_value_blob(pVal);\n+  int n = sqlite3_value_bytes(pVal);\n+  int nLoc = 0;\n+\n+  assert( sqlite3_value_type(pVal)==SQLITE_BLOB );\n+  assert( n>FTS5_LOCALE_HDR_SIZE );\n+\n+  for(nLoc=FTS5_LOCALE_HDR_SIZE; p[nLoc]; nLoc++){\n+    if( nLoc==(n-1) ){\n+      return SQLITE_MISMATCH;\n+    }\n+  }\n+  *ppLoc = &p[FTS5_LOCALE_HDR_SIZE];\n+  *pnLoc = nLoc - FTS5_LOCALE_HDR_SIZE;\n+\n+  *ppText = &p[nLoc+1];\n+  *pnText = n - nLoc - 1;\n+  return SQLITE_OK;\n+}\n+\n+\/*\n+** Argument pVal is the text of a full-text search expression. It may or\n+** may not have been wrapped by fts5_locale(). This function extracts\n+** the text of the expression, and sets output variable (*pzText) to\n+** point to a nul-terminated buffer containing the expression.\n+**\n+** If pVal was an fts5_locale() value, then sqlite3Fts5SetLocale() is called\n+** to set the tokenizer to use the specified locale.\n+**\n+** If output variable (*pbFreeAndReset) is set to true, then the caller\n+** is required to (a) call sqlite3Fts5ClearLocale() to reset the tokenizer\n+** locale, and (b) call sqlite3_free() to free (*pzText).\n+*\/\n+static int fts5ExtractExprText(\n+  Fts5Config *pConfig,            \/* Fts5 configuration *\/\n+  sqlite3_value *pVal,            \/* Value to extract expression text from *\/\n+  char **pzText,                  \/* OUT: nul-terminated buffer of text *\/\n+  int *pbFreeAndReset             \/* OUT: Free (*pzText) and clear locale *\/\n+){\n+  int rc = SQLITE_OK;\n+\n+  if( sqlite3Fts5IsLocaleValue(pConfig, pVal) ){\n+    const char *pText = 0;\n+    int nText = 0;\n+    const char *pLoc = 0;\n+    int nLoc = 0;\n+    rc = sqlite3Fts5DecodeLocaleValue(pVal, &pText, &nText, &pLoc, &nLoc);\n+    *pzText = sqlite3Fts5Mprintf(&rc, \"%.*s\", nText, pText);\n+    if( rc==SQLITE_OK ){\n+      sqlite3Fts5SetLocale(pConfig, pLoc, nLoc);\n+    }\n+    *pbFreeAndReset = 1;\n+  }else{\n+    *pzText = (char*)sqlite3_value_text(pVal);\n+    *pbFreeAndReset = 0;\n+  }\n+\n+  return rc;\n+}\n+\n+\n@@ -249105,0 +253720,1 @@\n+  int bPrefixInsttoken = pConfig->bPrefixInsttoken;\n@@ -249109,7 +253725,1 @@\n-  if( pConfig->bLock ){\n-    pTab->p.base.zErrMsg = sqlite3_mprintf(\n-        \"recursively defined fts5 content table\"\n-    );\n-    return SQLITE_ERROR;\n-  }\n-\n+  assert( pConfig->bLock==0 );\n@@ -249139,1 +253749,6 @@\n-        const char *zText = (const char*)sqlite3_value_text(apVal[i]);\n+        char *zText = 0;\n+        int bFreeAndReset = 0;\n+        int bInternal = 0;\n+\n+        rc = fts5ExtractExprText(pConfig, apVal[i], &zText, &bFreeAndReset);\n+        if( rc!=SQLITE_OK ) goto filter_out;\n@@ -249141,0 +253756,4 @@\n+        if( sqlite3_value_subtype(apVal[i])==FTS5_INSTTOKEN_SUBTYPE ){\n+          pConfig->bPrefixInsttoken = 1;\n+        }\n+\n@@ -249152,1 +253771,1 @@\n-          goto filter_out;\n+          bInternal = 1;\n@@ -249160,1 +253779,0 @@\n-          if( rc!=SQLITE_OK ) goto filter_out;\n@@ -249163,0 +253781,7 @@\n+        if( bFreeAndReset ){\n+          sqlite3_free(zText);\n+          sqlite3Fts5ClearLocale(pConfig);\n+        }\n+\n+        if( bInternal || rc!=SQLITE_OK ) goto filter_out;\n+\n@@ -249250,3 +253875,1 @@\n-    *pConfig->pzErrmsg = sqlite3_mprintf(\n-        \"%s: table does not support scanning\", pConfig->zName\n-    );\n+    fts5SetVtabError(pTab,\"%s: table does not support scanning\",pConfig->zName);\n@@ -249276,0 +253899,1 @@\n+  pConfig->bPrefixInsttoken = bPrefixInsttoken;\n@@ -249295,0 +253919,2 @@\n+       || pCsr->ePlan==FTS5_PLAN_SCAN\n+       || pCsr->ePlan==FTS5_PLAN_ROWID\n@@ -249298,0 +253924,2 @@\n+  }else if( pCsr->ePlan>=FTS5_PLAN_SCAN ){\n+    return sqlite3_column_int64(pCsr->pStmt, 0);\n@@ -249314,14 +253942,4 @@\n-  switch( ePlan ){\n-    case FTS5_PLAN_SPECIAL:\n-      *pRowid = 0;\n-      break;\n-\n-    case FTS5_PLAN_SOURCE:\n-    case FTS5_PLAN_MATCH:\n-    case FTS5_PLAN_SORTED_MATCH:\n-      *pRowid = fts5CursorRowid(pCsr);\n-      break;\n-\n-    default:\n-      *pRowid = sqlite3_column_int64(pCsr->pStmt, 0);\n-      break;\n+  if( ePlan==FTS5_PLAN_SPECIAL ){\n+    *pRowid = 0;\n+  }else{\n+    *pRowid = fts5CursorRowid(pCsr);\n@@ -249333,0 +253951,1 @@\n+\n@@ -249369,0 +253988,5 @@\n+        fts5SetVtabError((Fts5FullTable*)pTab,\n+            \"fts5: missing row %lld from content table %s\",\n+            fts5CursorRowid(pCsr),\n+            pTab->pConfig->zContent\n+        );\n@@ -249370,1 +253994,1 @@\n-        *pTab->pConfig->pzErrmsg = sqlite3_mprintf(\n+        fts5SetVtabError((Fts5FullTable*)pTab,\n@@ -249379,8 +254003,0 @@\n-static void fts5SetVtabError(Fts5FullTable *p, const char *zFormat, ...){\n-  va_list ap;                     \/* ... printf arguments *\/\n-  va_start(ap, zFormat);\n-  assert( p->p.base.zErrMsg==0 );\n-  p->p.base.zErrMsg = sqlite3_vmprintf(zFormat, ap);\n-  va_end(ap);\n-}\n-\n@@ -249424,1 +254040,1 @@\n-    if( pConfig->eContent==FTS5_CONTENT_NONE ){\n+    if( fts5IsContentless(pTab, 1) ){\n@@ -249480,1 +254096,1 @@\n-    rc = sqlite3Fts5StorageDelete(pTab->pStorage, iDel, &apVal[2]);\n+    rc = sqlite3Fts5StorageDelete(pTab->pStorage, iDel, &apVal[2], 0);\n@@ -249493,1 +254109,1 @@\n-    rc = sqlite3Fts5StorageContentInsert(pTab->pStorage, apVal, piRowid);\n+    rc = sqlite3Fts5StorageContentInsert(pTab->pStorage, 0, apVal, piRowid);\n@@ -249501,0 +254117,61 @@\n+\/*\n+**\n+** This function is called when the user attempts an UPDATE on a contentless\n+** table. Parameter bRowidModified is true if the UPDATE statement modifies\n+** the rowid value. Parameter apVal[] contains the new values for each user\n+** defined column of the fts5 table. pConfig is the configuration object of the\n+** table being updated (guaranteed to be contentless). The contentless_delete=1\n+** and contentless_unindexed=1 options may or may not be set.\n+**\n+** This function returns SQLITE_OK if the UPDATE can go ahead, or an SQLite\n+** error code if it cannot. In this case an error message is also loaded into\n+** pConfig. Output parameter (*pbContent) is set to true if the caller should\n+** update the %_content table only - not the FTS index or any other shadow\n+** table. This occurs when an UPDATE modifies only UNINDEXED columns of the\n+** table.\n+**\n+** An UPDATE may proceed if:\n+**\n+**   * The only columns modified are UNINDEXED columns, or\n+**\n+**   * The contentless_delete=1 option was specified and all of the indexed\n+**     columns (not a subset) have been modified.\n+*\/\n+static int fts5ContentlessUpdate(\n+  Fts5Config *pConfig,\n+  sqlite3_value **apVal,\n+  int bRowidModified,\n+  int *pbContent\n+){\n+  int ii;\n+  int bSeenIndex = 0;             \/* Have seen modified indexed column *\/\n+  int bSeenIndexNC = 0;           \/* Have seen unmodified indexed column *\/\n+  int rc = SQLITE_OK;\n+\n+  for(ii=0; ii<pConfig->nCol; ii++){\n+    if( pConfig->abUnindexed[ii]==0 ){\n+      if( sqlite3_value_nochange(apVal[ii]) ){\n+        bSeenIndexNC++;\n+      }else{\n+        bSeenIndex++;\n+      }\n+    }\n+  }\n+\n+  if( bSeenIndex==0 && bRowidModified==0 ){\n+    *pbContent = 1;\n+  }else{\n+    if( bSeenIndexNC || pConfig->bContentlessDelete==0 ){\n+      rc = SQLITE_ERROR;\n+      sqlite3Fts5ConfigErrmsg(pConfig,\n+          (pConfig->bContentlessDelete ?\n+          \"%s a subset of columns on fts5 contentless-delete table: %s\" :\n+          \"%s contentless fts5 table: %s\")\n+          , \"cannot UPDATE\", pConfig->zName\n+      );\n+    }\n+  }\n+\n+  return rc;\n+}\n+\n@@ -249525,1 +254202,0 @@\n-  int bUpdateOrDelete = 0;\n@@ -249537,1 +254213,1 @@\n-    rc = sqlite3Fts5IndexLoadConfig(pTab->p.pIndex);\n+    rc = sqlite3Fts5ConfigLoad(pTab->p.pConfig, pTab->p.pConfig->iCookie);\n@@ -249586,14 +254262,0 @@\n-    \/* Filter out attempts to run UPDATE or DELETE on contentless tables.\n-    ** This is not suported. Except - they are both supported if the CREATE\n-    ** VIRTUAL TABLE statement contained \"contentless_delete=1\". *\/\n-    if( eType0==SQLITE_INTEGER\n-     && pConfig->eContent==FTS5_CONTENT_NONE\n-     && pConfig->bContentlessDelete==0\n-    ){\n-      pTab->p.base.zErrMsg = sqlite3_mprintf(\n-          \"cannot %s contentless fts5 table: %s\",\n-          (nArg>1 ? \"UPDATE\" : \"DELETE from\"), pConfig->zName\n-      );\n-      rc = SQLITE_ERROR;\n-    }\n-\n@@ -249601,4 +254263,12 @@\n-    else if( nArg==1 ){\n-      i64 iDel = sqlite3_value_int64(apVal[0]);  \/* Rowid to delete *\/\n-      rc = sqlite3Fts5StorageDelete(pTab->pStorage, iDel, 0);\n-      bUpdateOrDelete = 1;\n+    if( nArg==1 ){\n+      \/* It is only possible to DELETE from a contentless table if the\n+      ** contentless_delete=1 flag is set. *\/\n+      if( fts5IsContentless(pTab, 1) && pConfig->bContentlessDelete==0 ){\n+        fts5SetVtabError(pTab,\n+            \"cannot DELETE from contentless fts5 table: %s\", pConfig->zName\n+        );\n+        rc = SQLITE_ERROR;\n+      }else{\n+        i64 iDel = sqlite3_value_int64(apVal[0]);  \/* Rowid to delete *\/\n+        rc = sqlite3Fts5StorageDelete(pTab->pStorage, iDel, 0, 0);\n+      }\n@@ -249611,2 +254281,12 @@\n-      if( eType1!=SQLITE_INTEGER && eType1!=SQLITE_NULL ){\n-        rc = SQLITE_MISMATCH;\n+      \/* It is an error to write an fts5_locale() value to a table without\n+      ** the locale=1 option. *\/\n+      if( pConfig->bLocale==0 ){\n+        int ii;\n+        for(ii=0; ii<pConfig->nCol; ii++){\n+          sqlite3_value *pVal = apVal[ii+2];\n+          if( sqlite3Fts5IsLocaleValue(pConfig, pVal) ){\n+            fts5SetVtabError(pTab, \"fts5_locale() requires locale=1\");\n+            rc = SQLITE_MISMATCH;\n+            goto update_out;\n+          }\n+        }\n@@ -249615,1 +254295,1 @@\n-      else if( eType0!=SQLITE_INTEGER ){\n+      if( eType0!=SQLITE_INTEGER ){\n@@ -249620,2 +254300,1 @@\n-          rc = sqlite3Fts5StorageDelete(pTab->pStorage, iNew, 0);\n-          bUpdateOrDelete = 1;\n+          rc = sqlite3Fts5StorageDelete(pTab->pStorage, iNew, 0, 0);\n@@ -249628,0 +254307,1 @@\n+        Fts5Storage *pStorage = pTab->pStorage;\n@@ -249630,1 +254310,13 @@\n-        if( eType1==SQLITE_INTEGER && iOld!=iNew ){\n+        int bContent = 0;         \/* Content only update *\/\n+\n+        \/* If this is a contentless table (including contentless_unindexed=1\n+        ** tables), check if the UPDATE may proceed.  *\/\n+        if( fts5IsContentless(pTab, 1) ){\n+          rc = fts5ContentlessUpdate(pConfig, &apVal[2], iOld!=iNew, &bContent);\n+          if( rc!=SQLITE_OK ) goto update_out;\n+        }\n+\n+        if( eType1!=SQLITE_INTEGER ){\n+          rc = SQLITE_MISMATCH;\n+        }else if( iOld!=iNew ){\n+          assert( bContent==0 );\n@@ -249632,1 +254324,1 @@\n-            rc = sqlite3Fts5StorageDelete(pTab->pStorage, iOld, 0);\n+            rc = sqlite3Fts5StorageDelete(pStorage, iOld, 0, 1);\n@@ -249634,1 +254326,1 @@\n-              rc = sqlite3Fts5StorageDelete(pTab->pStorage, iNew, 0);\n+              rc = sqlite3Fts5StorageDelete(pStorage, iNew, 0, 0);\n@@ -249638,1 +254330,1 @@\n-            rc = sqlite3Fts5StorageContentInsert(pTab->pStorage, apVal, pRowid);\n+            rc = sqlite3Fts5StorageFindDeleteRow(pStorage, iOld);\n@@ -249640,1 +254332,1 @@\n-              rc = sqlite3Fts5StorageDelete(pTab->pStorage, iOld, 0);\n+              rc = sqlite3Fts5StorageContentInsert(pStorage, 0, apVal, pRowid);\n@@ -249643,1 +254335,4 @@\n-              rc = sqlite3Fts5StorageIndexInsert(pTab->pStorage, apVal,*pRowid);\n+              rc = sqlite3Fts5StorageDelete(pStorage, iOld, 0, 0);\n+            }\n+            if( rc==SQLITE_OK ){\n+              rc = sqlite3Fts5StorageIndexInsert(pStorage, apVal, *pRowid);\n@@ -249646,0 +254341,9 @@\n+        }else if( bContent ){\n+          \/* This occurs when an UPDATE on a contentless table affects *only*\n+          ** UNINDEXED columns. This is a no-op for contentless_unindexed=0\n+          ** tables, or a write to the %_content table only for =1 tables.  *\/\n+          assert( fts5IsContentless(pTab, 1) );\n+          rc = sqlite3Fts5StorageFindDeleteRow(pStorage, iOld);\n+          if( rc==SQLITE_OK ){\n+            rc = sqlite3Fts5StorageContentInsert(pStorage, 1, apVal, pRowid);\n+          }\n@@ -249647,1 +254351,1 @@\n-          rc = sqlite3Fts5StorageDelete(pTab->pStorage, iOld, 0);\n+          rc = sqlite3Fts5StorageDelete(pStorage, iOld, 0, 1);\n@@ -249650,1 +254354,1 @@\n-        bUpdateOrDelete = 1;\n+        sqlite3Fts5StorageReleaseDeleteRow(pStorage);\n@@ -249655,13 +254359,1 @@\n-  if( rc==SQLITE_OK\n-   && bUpdateOrDelete\n-   && pConfig->bSecureDelete\n-   && pConfig->iVersion==FTS5_CURRENT_VERSION\n-  ){\n-    rc = sqlite3Fts5StorageConfigValue(\n-        pTab->pStorage, \"version\", 0, FTS5_CURRENT_VERSION_SECUREDELETE\n-    );\n-    if( rc==SQLITE_OK ){\n-      pConfig->iVersion = FTS5_CURRENT_VERSION_SECUREDELETE;\n-    }\n-  }\n-\n+ update_out:\n@@ -249689,3 +254381,5 @@\n-  fts5CheckTransactionState((Fts5FullTable*)pVtab, FTS5_BEGIN, 0);\n-  fts5NewTransaction((Fts5FullTable*)pVtab);\n-  return SQLITE_OK;\n+  int rc = fts5NewTransaction((Fts5FullTable*)pVtab);\n+  if( rc==SQLITE_OK ){\n+    fts5CheckTransactionState((Fts5FullTable*)pVtab, FTS5_BEGIN, 0);\n+  }\n+  return rc;\n@@ -249714,0 +254408,1 @@\n+  pTab->p.pConfig->pgsz = 0;\n@@ -249745,1 +254440,4 @@\n-static int fts5ApiTokenize(\n+\/*\n+** Implementation of xTokenize_v2() API.\n+*\/\n+static int fts5ApiTokenize_v2(\n@@ -249748,0 +254446,1 @@\n+  const char *pLoc, int nLoc,\n@@ -249753,2 +254452,5 @@\n-  return sqlite3Fts5Tokenize(\n-      pTab->pConfig, FTS5_TOKENIZE_AUX, pText, nText, pUserData, xToken\n+  int rc = SQLITE_OK;\n+\n+  sqlite3Fts5SetLocale(pTab->pConfig, pLoc, nLoc);\n+  rc = sqlite3Fts5Tokenize(pTab->pConfig,\n+      FTS5_TOKENIZE_AUX, pText, nText, pUserData, xToken\n@@ -249756,0 +254458,16 @@\n+  sqlite3Fts5SetLocale(pTab->pConfig, 0, 0);\n+\n+  return rc;\n+}\n+\n+\/*\n+** Implementation of xTokenize() API. This is just xTokenize_v2() with NULL\/0\n+** passed as the locale.\n+*\/\n+static int fts5ApiTokenize(\n+  Fts5Context *pCtx,\n+  const char *pText, int nText,\n+  void *pUserData,\n+  int (*xToken)(void*, int, const char*, int, int, int)\n+){\n+  return fts5ApiTokenize_v2(pCtx, pText, nText, 0, 0, pUserData, xToken);\n@@ -249768,0 +254486,43 @@\n+\/*\n+** Argument pStmt is an SQL statement of the type used by Fts5Cursor. This\n+** function extracts the text value of column iCol of the current row.\n+** Additionally, if there is an associated locale, it invokes\n+** sqlite3Fts5SetLocale() to configure the tokenizer. In all cases the caller\n+** should invoke sqlite3Fts5ClearLocale() to clear the locale at some point\n+** after this function returns.\n+**\n+** If successful, (*ppText) is set to point to a buffer containing the text\n+** value as utf-8 and SQLITE_OK returned. (*pnText) is set to the size of that\n+** buffer in bytes. It is not guaranteed to be nul-terminated. If an error\n+** occurs, an SQLite error code is returned. The final values of the two\n+** output parameters are undefined in this case.\n+*\/\n+static int fts5TextFromStmt(\n+  Fts5Config *pConfig,\n+  sqlite3_stmt *pStmt,\n+  int iCol,\n+  const char **ppText,\n+  int *pnText\n+){\n+  sqlite3_value *pVal = sqlite3_column_value(pStmt, iCol+1);\n+  const char *pLoc = 0;\n+  int nLoc = 0;\n+  int rc = SQLITE_OK;\n+\n+  if( pConfig->bLocale\n+   && pConfig->eContent==FTS5_CONTENT_EXTERNAL\n+   && sqlite3Fts5IsLocaleValue(pConfig, pVal)\n+  ){\n+    rc = sqlite3Fts5DecodeLocaleValue(pVal, ppText, pnText, &pLoc, &nLoc);\n+  }else{\n+    *ppText = (const char*)sqlite3_value_text(pVal);\n+    *pnText = sqlite3_value_bytes(pVal);\n+    if( pConfig->bLocale && pConfig->eContent==FTS5_CONTENT_NORMAL ){\n+      pLoc = (const char*)sqlite3_column_text(pStmt, iCol+1+pConfig->nCol);\n+      nLoc = sqlite3_column_bytes(pStmt, iCol+1+pConfig->nCol);\n+    }\n+  }\n+  sqlite3Fts5SetLocale(pConfig, pLoc, nLoc);\n+  return rc;\n+}\n+\n@@ -249777,0 +254538,2 @@\n+\n+  assert( pCsr->ePlan!=FTS5_PLAN_SPECIAL );\n@@ -249779,3 +254542,1 @@\n-  }else if( fts5IsContentless((Fts5FullTable*)(pCsr->base.pVtab))\n-   || pCsr->ePlan==FTS5_PLAN_SPECIAL\n-  ){\n+  }else if( fts5IsContentless((Fts5FullTable*)(pCsr->base.pVtab), 0) ){\n@@ -249787,2 +254548,2 @@\n-      *pz = (const char*)sqlite3_column_text(pCsr->pStmt, iCol+1);\n-      *pn = sqlite3_column_bytes(pCsr->pStmt, iCol+1);\n+      rc = fts5TextFromStmt(pTab->pConfig, pCsr->pStmt, iCol, pz, pn);\n+      sqlite3Fts5ClearLocale(pTab->pConfig);\n@@ -249794,0 +254555,7 @@\n+\/*\n+** This is called by various API functions - xInst, xPhraseFirst,\n+** xPhraseFirstColumn etc. - to obtain the position list for phrase iPhrase\n+** of the current row. This function works for both detail=full tables (in\n+** which case the position-list was read from the fts index) or for other\n+** detail= modes if the row content is available.\n+*\/\n@@ -249795,4 +254563,4 @@\n-  Fts5Cursor *pCsr,\n-  int iPhrase,\n-  const u8 **pa,\n-  int *pn\n+  Fts5Cursor *pCsr,               \/* Fts5 cursor object *\/\n+  int iPhrase,                    \/* Phrase to find position list for *\/\n+  const u8 **pa,                  \/* OUT: Pointer to position list buffer *\/\n+  int *pn                         \/* OUT: Size of (*pa) in bytes *\/\n@@ -249806,0 +254574,6 @@\n+  }else if( pConfig->eDetail!=FTS5_DETAIL_FULL\n+         && fts5IsContentless((Fts5FullTable*)pCsr->base.pVtab, 1)\n+  ){\n+    *pa = 0;\n+    *pn = 0;\n+    return SQLITE_OK;\n@@ -249810,0 +254584,1 @@\n+\n@@ -249812,0 +254587,3 @@\n+      if( rc==SQLITE_OK ){\n+        rc = fts5SeekCursor(pCsr, 0);\n+      }\n@@ -249813,2 +254591,3 @@\n-        int n; const char *z;\n-        rc = fts5ApiColumnText((Fts5Context*)pCsr, i, &z, &n);\n+        const char *z = 0;\n+        int n = 0;\n+        rc = fts5TextFromStmt(pConfig, pCsr->pStmt, i, &z, &n);\n@@ -249820,0 +254599,1 @@\n+        sqlite3Fts5ClearLocale(pConfig);\n@@ -249844,1 +254624,0 @@\n-\n@@ -249913,1 +254692,2 @@\n-        if( aInst[1]<0 || aInst[1]>=nCol ){\n+        assert( aInst[1]>=0 );\n+        if( aInst[1]>=nCol ){\n@@ -249991,1 +254771,1 @@\n-    }else if( pConfig->zContent==0 ){\n+    }else if( !pConfig->zContent || pConfig->eContent==FTS5_CONTENT_UNINDEXED ){\n@@ -250000,0 +254780,1 @@\n+      rc = fts5SeekCursor(pCsr, 0);\n@@ -250002,2 +254783,2 @@\n-          const char *z; int n;\n-          void *p = (void*)(&pCsr->aColumnSize[i]);\n+          const char *z = 0;\n+          int n = 0;\n@@ -250005,1 +254786,1 @@\n-          rc = fts5ApiColumnText(pCtx, i, &z, &n);\n+          rc = fts5TextFromStmt(pConfig, pCsr->pStmt, i, &z, &n);\n@@ -250007,2 +254788,2 @@\n-            rc = sqlite3Fts5Tokenize(\n-                pConfig, FTS5_TOKENIZE_AUX, z, n, p, fts5ColumnSizeCb\n+            rc = sqlite3Fts5Tokenize(pConfig, FTS5_TOKENIZE_AUX,\n+                z, n, (void*)&pCsr->aColumnSize[i], fts5ColumnSizeCb\n@@ -250011,0 +254792,1 @@\n+          sqlite3Fts5ClearLocale(pConfig);\n@@ -250090,1 +254872,1 @@\n-  Fts5Context *pUnused,\n+  Fts5Context *pCtx,\n@@ -250094,1 +254876,0 @@\n-  UNUSED_PARAM(pUnused);\n@@ -250102,0 +254883,4 @@\n+      \/* Avoid returning a (*piCol) value that is too large for the table,\n+      ** even if the position-list is corrupt. The caller might not be\n+      ** expecting it.  *\/\n+      int nCol = ((Fts5Table*)(((Fts5Cursor*)pCtx)->base.pVtab))->pConfig->nCol;\n@@ -250103,1 +254888,1 @@\n-      *piCol = iVal;\n+      *piCol = (iVal>=nCol ? nCol-1 : iVal);\n@@ -250253,0 +255038,40 @@\n+\/*\n+** The xColumnLocale() API.\n+*\/\n+static int fts5ApiColumnLocale(\n+  Fts5Context *pCtx,\n+  int iCol,\n+  const char **pzLocale,\n+  int *pnLocale\n+){\n+  int rc = SQLITE_OK;\n+  Fts5Cursor *pCsr = (Fts5Cursor*)pCtx;\n+  Fts5Config *pConfig = ((Fts5Table*)(pCsr->base.pVtab))->pConfig;\n+\n+  *pzLocale = 0;\n+  *pnLocale = 0;\n+\n+  assert( pCsr->ePlan!=FTS5_PLAN_SPECIAL );\n+  if( iCol<0 || iCol>=pConfig->nCol ){\n+    rc = SQLITE_RANGE;\n+  }else if(\n+      pConfig->abUnindexed[iCol]==0\n+   && 0==fts5IsContentless((Fts5FullTable*)pCsr->base.pVtab, 1)\n+   && pConfig->bLocale\n+  ){\n+    rc = fts5SeekCursor(pCsr, 0);\n+    if( rc==SQLITE_OK ){\n+      const char *zDummy = 0;\n+      int nDummy = 0;\n+      rc = fts5TextFromStmt(pConfig, pCsr->pStmt, iCol, &zDummy, &nDummy);\n+      if( rc==SQLITE_OK ){\n+        *pzLocale = pConfig->t.pLocale;\n+        *pnLocale = pConfig->t.nLocale;\n+      }\n+      sqlite3Fts5ClearLocale(pConfig);\n+    }\n+  }\n+\n+  return rc;\n+}\n+\n@@ -250254,1 +255079,1 @@\n-  3,                            \/* iVersion *\/\n+  4,                            \/* iVersion *\/\n@@ -250275,1 +255100,3 @@\n-  fts5ApiInstToken\n+  fts5ApiInstToken,\n+  fts5ApiColumnLocale,\n+  fts5ApiTokenize_v2\n@@ -250326,0 +255153,1 @@\n+  assert( pCsr->ePlan!=FTS5_PLAN_SPECIAL );\n@@ -250339,0 +255167,15 @@\n+\/*\n+** Parameter zFmt is a printf() style formatting string. This function\n+** formats it using the trailing arguments and returns the result as\n+** an error message to the context passed as the first argument.\n+*\/\n+static void fts5ResultError(sqlite3_context *pCtx, const char *zFmt, ...){\n+  char *zErr = 0;\n+  va_list ap;\n+  va_start(ap, zFmt);\n+  zErr = sqlite3_vmprintf(zFmt, ap);\n+  sqlite3_result_error(pCtx, zErr, -1);\n+  sqlite3_free(zErr);\n+  va_end(ap);\n+}\n+\n@@ -250354,4 +255197,2 @@\n-  if( pCsr==0 || pCsr->ePlan==0 ){\n-    char *zErr = sqlite3_mprintf(\"no such cursor: %lld\", iCsrId);\n-    sqlite3_result_error(context, zErr, -1);\n-    sqlite3_free(zErr);\n+  if( pCsr==0 || (pCsr->ePlan==0 || pCsr->ePlan==FTS5_PLAN_SPECIAL) ){\n+    fts5ResultError(context, \"no such cursor: %lld\", iCsrId);\n@@ -250359,0 +255200,1 @@\n+    sqlite3_vtab *pTab = pCsr->base.pVtab;\n@@ -250360,0 +255202,2 @@\n+    sqlite3_free(pTab->zErrMsg);\n+    pTab->zErrMsg = 0;\n@@ -250477,1 +255321,0 @@\n-\n@@ -250479,0 +255322,1 @@\n+\n@@ -250489,5 +255333,23 @@\n-  }else if( !fts5IsContentless(pTab) ){\n-    pConfig->pzErrmsg = &pTab->p.base.zErrMsg;\n-    rc = fts5SeekCursor(pCsr, 1);\n-    if( rc==SQLITE_OK ){\n-      sqlite3_result_value(pCtx, sqlite3_column_value(pCsr->pStmt, iCol+1));\n+  }else{\n+    if( !sqlite3_vtab_nochange(pCtx) && pConfig->eContent!=FTS5_CONTENT_NONE ){\n+      pConfig->pzErrmsg = &pTab->p.base.zErrMsg;\n+      rc = fts5SeekCursor(pCsr, 1);\n+      if( rc==SQLITE_OK ){\n+        sqlite3_value *pVal = sqlite3_column_value(pCsr->pStmt, iCol+1);\n+        if( pConfig->bLocale\n+         && pConfig->eContent==FTS5_CONTENT_EXTERNAL\n+         && sqlite3Fts5IsLocaleValue(pConfig, pVal)\n+        ){\n+          const char *z = 0;\n+          int n = 0;\n+          rc = fts5TextFromStmt(pConfig, pCsr->pStmt, iCol, &z, &n);\n+          if( rc==SQLITE_OK ){\n+            sqlite3_result_text(pCtx, z, n, SQLITE_TRANSIENT);\n+          }\n+          sqlite3Fts5ClearLocale(pConfig);\n+        }else{\n+          sqlite3_result_value(pCtx, pVal);\n+        }\n+      }\n+\n+      pConfig->pzErrmsg = 0;\n@@ -250495,7 +255357,0 @@\n-    pConfig->pzErrmsg = 0;\n-  }else if( pConfig->bContentlessDelete && sqlite3_vtab_nochange(pCtx) ){\n-    char *zErr = sqlite3_mprintf(\"cannot UPDATE a subset of \"\n-        \"columns on fts5 contentless-delete table: %s\", pConfig->zName\n-    );\n-    sqlite3_result_error(pCtx, zErr, -1);\n-    sqlite3_free(zErr);\n@@ -250503,0 +255358,1 @@\n+\n@@ -250642,2 +255498,13 @@\n-** Register a new tokenizer. This is the implementation of the\n-** fts5_api.xCreateTokenizer() method.\n+** This function is used by xCreateTokenizer_v2() and xCreateTokenizer().\n+** It allocates and partially populates a new Fts5TokenizerModule object.\n+** The new object is already linked into the Fts5Global context before\n+** returning.\n+**\n+** If successful, SQLITE_OK is returned and a pointer to the new\n+** Fts5TokenizerModule object returned via output parameter (*ppNew). All\n+** that is required is for the caller to fill in the methods in\n+** Fts5TokenizerModule.x1 and x2, and to set Fts5TokenizerModule.bV2Native\n+** as appropriate.\n+**\n+** If an error occurs, an SQLite error code is returned and the final value\n+** of (*ppNew) undefined.\n@@ -250645,2 +255512,2 @@\n-static int fts5CreateTokenizer(\n-  fts5_api *pApi,                 \/* Global context (one per db handle) *\/\n+static int fts5NewTokenizerModule(\n+  Fts5Global *pGlobal,            \/* Global context (one per db handle) *\/\n@@ -250649,2 +255516,2 @@\n-  fts5_tokenizer *pTokenizer,     \/* Tokenizer implementation *\/\n-  void(*xDestroy)(void*)          \/* Destructor for pUserData *\/\n+  void(*xDestroy)(void*),         \/* Destructor for pUserData *\/\n+  Fts5TokenizerModule **ppNew\n@@ -250652,4 +255519,0 @@\n-  Fts5Global *pGlobal = (Fts5Global*)pApi;\n-  Fts5TokenizerModule *pNew;\n-  sqlite3_int64 nName;            \/* Size of zName and its \\0 terminator *\/\n-  sqlite3_int64 nByte;            \/* Bytes of space to allocate *\/\n@@ -250657,0 +255520,3 @@\n+  Fts5TokenizerModule *pNew;\n+  sqlite3_int64 nName;          \/* Size of zName and its \\0 terminator *\/\n+  sqlite3_int64 nByte;          \/* Bytes of space to allocate *\/\n@@ -250660,1 +255526,1 @@\n-  pNew = (Fts5TokenizerModule*)sqlite3_malloc64(nByte);\n+  *ppNew = pNew = (Fts5TokenizerModule*)sqlite3Fts5MallocZero(&rc, nByte);\n@@ -250662,1 +255528,0 @@\n-    memset(pNew, 0, (size_t)nByte);\n@@ -250666,1 +255531,0 @@\n-    pNew->x = *pTokenizer;\n@@ -250673,0 +255537,117 @@\n+  }\n+\n+  return rc;\n+}\n+\n+\/*\n+** An instance of this type is used as the Fts5Tokenizer object for\n+** wrapper tokenizers - those that provide access to a v1 tokenizer via\n+** the fts5_tokenizer_v2 API, and those that provide access to a v2 tokenizer\n+** via the fts5_tokenizer API.\n+*\/\n+typedef struct Fts5VtoVTokenizer Fts5VtoVTokenizer;\n+struct Fts5VtoVTokenizer {\n+  int bV2Native;                  \/* True if v2 native tokenizer *\/\n+  fts5_tokenizer x1;              \/* Tokenizer functions *\/\n+  fts5_tokenizer_v2 x2;           \/* V2 tokenizer functions *\/\n+  Fts5Tokenizer *pReal;\n+};\n+\n+\/*\n+** Create a wrapper tokenizer. The context argument pCtx points to the\n+** Fts5TokenizerModule object.\n+*\/\n+static int fts5VtoVCreate(\n+  void *pCtx,\n+  const char **azArg,\n+  int nArg,\n+  Fts5Tokenizer **ppOut\n+){\n+  Fts5TokenizerModule *pMod = (Fts5TokenizerModule*)pCtx;\n+  Fts5VtoVTokenizer *pNew = 0;\n+  int rc = SQLITE_OK;\n+\n+  pNew = (Fts5VtoVTokenizer*)sqlite3Fts5MallocZero(&rc, sizeof(*pNew));\n+  if( rc==SQLITE_OK ){\n+    pNew->x1 = pMod->x1;\n+    pNew->x2 = pMod->x2;\n+    pNew->bV2Native = pMod->bV2Native;\n+    if( pMod->bV2Native ){\n+      rc = pMod->x2.xCreate(pMod->pUserData, azArg, nArg, &pNew->pReal);\n+    }else{\n+      rc = pMod->x1.xCreate(pMod->pUserData, azArg, nArg, &pNew->pReal);\n+    }\n+    if( rc!=SQLITE_OK ){\n+      sqlite3_free(pNew);\n+      pNew = 0;\n+    }\n+  }\n+\n+  *ppOut = (Fts5Tokenizer*)pNew;\n+  return rc;\n+}\n+\n+\/*\n+** Delete an Fts5VtoVTokenizer wrapper tokenizer.\n+*\/\n+static void fts5VtoVDelete(Fts5Tokenizer *pTok){\n+  Fts5VtoVTokenizer *p = (Fts5VtoVTokenizer*)pTok;\n+  if( p ){\n+    if( p->bV2Native ){\n+      p->x2.xDelete(p->pReal);\n+    }else{\n+      p->x1.xDelete(p->pReal);\n+    }\n+    sqlite3_free(p);\n+  }\n+}\n+\n+\n+\/*\n+** xTokenizer method for a wrapper tokenizer that offers the v1 interface\n+** (no support for locales).\n+*\/\n+static int fts5V1toV2Tokenize(\n+  Fts5Tokenizer *pTok,\n+  void *pCtx, int flags,\n+  const char *pText, int nText,\n+  int (*xToken)(void*, int, const char*, int, int, int)\n+){\n+  Fts5VtoVTokenizer *p = (Fts5VtoVTokenizer*)pTok;\n+  assert( p->bV2Native );\n+  return p->x2.xTokenize(p->pReal, pCtx, flags, pText, nText, 0, 0, xToken);\n+}\n+\n+\/*\n+** xTokenizer method for a wrapper tokenizer that offers the v2 interface\n+** (with locale support).\n+*\/\n+static int fts5V2toV1Tokenize(\n+  Fts5Tokenizer *pTok,\n+  void *pCtx, int flags,\n+  const char *pText, int nText,\n+  const char *pLocale, int nLocale,\n+  int (*xToken)(void*, int, const char*, int, int, int)\n+){\n+  Fts5VtoVTokenizer *p = (Fts5VtoVTokenizer*)pTok;\n+  assert( p->bV2Native==0 );\n+  UNUSED_PARAM2(pLocale,nLocale);\n+  return p->x1.xTokenize(p->pReal, pCtx, flags, pText, nText, xToken);\n+}\n+\n+\/*\n+** Register a new tokenizer. This is the implementation of the\n+** fts5_api.xCreateTokenizer_v2() method.\n+*\/\n+static int fts5CreateTokenizer_v2(\n+  fts5_api *pApi,                 \/* Global context (one per db handle) *\/\n+  const char *zName,              \/* Name of new function *\/\n+  void *pUserData,                \/* User data for aux. function *\/\n+  fts5_tokenizer_v2 *pTokenizer,  \/* Tokenizer implementation *\/\n+  void(*xDestroy)(void*)          \/* Destructor for pUserData *\/\n+){\n+  Fts5Global *pGlobal = (Fts5Global*)pApi;\n+  int rc = SQLITE_OK;\n+\n+  if( pTokenizer->iVersion>2 ){\n+    rc = SQLITE_ERROR;\n@@ -250674,1 +255655,9 @@\n-    rc = SQLITE_NOMEM;\n+    Fts5TokenizerModule *pNew = 0;\n+    rc = fts5NewTokenizerModule(pGlobal, zName, pUserData, xDestroy, &pNew);\n+    if( pNew ){\n+      pNew->x2 = *pTokenizer;\n+      pNew->bV2Native = 1;\n+      pNew->x1.xCreate = fts5VtoVCreate;\n+      pNew->x1.xTokenize = fts5V1toV2Tokenize;\n+      pNew->x1.xDelete = fts5VtoVDelete;\n+    }\n@@ -250680,0 +255669,30 @@\n+\/*\n+** The fts5_api.xCreateTokenizer() method.\n+*\/\n+static int fts5CreateTokenizer(\n+  fts5_api *pApi,                 \/* Global context (one per db handle) *\/\n+  const char *zName,              \/* Name of new function *\/\n+  void *pUserData,                \/* User data for aux. function *\/\n+  fts5_tokenizer *pTokenizer,     \/* Tokenizer implementation *\/\n+  void(*xDestroy)(void*)          \/* Destructor for pUserData *\/\n+){\n+  Fts5TokenizerModule *pNew = 0;\n+  int rc = SQLITE_OK;\n+\n+  rc = fts5NewTokenizerModule(\n+      (Fts5Global*)pApi, zName, pUserData, xDestroy, &pNew\n+  );\n+  if( pNew ){\n+    pNew->x1 = *pTokenizer;\n+    pNew->x2.xCreate = fts5VtoVCreate;\n+    pNew->x2.xTokenize = fts5V2toV1Tokenize;\n+    pNew->x2.xDelete = fts5VtoVDelete;\n+  }\n+  return rc;\n+}\n+\n+\/*\n+** Search the global context passed as the first argument for a tokenizer\n+** module named zName. If found, return a pointer to the Fts5TokenizerModule\n+** object. Otherwise, return NULL.\n+*\/\n@@ -250681,2 +255700,2 @@\n-  Fts5Global *pGlobal,\n-  const char *zName\n+  Fts5Global *pGlobal,            \/* Global (one per db handle) object *\/\n+  const char *zName               \/* Name of tokenizer module to find *\/\n@@ -250697,0 +255716,30 @@\n+\/*\n+** Find a tokenizer. This is the implementation of the\n+** fts5_api.xFindTokenizer_v2() method.\n+*\/\n+static int fts5FindTokenizer_v2(\n+  fts5_api *pApi,                 \/* Global context (one per db handle) *\/\n+  const char *zName,              \/* Name of tokenizer *\/\n+  void **ppUserData,\n+  fts5_tokenizer_v2 **ppTokenizer \/* Populate this object *\/\n+){\n+  int rc = SQLITE_OK;\n+  Fts5TokenizerModule *pMod;\n+\n+  pMod = fts5LocateTokenizer((Fts5Global*)pApi, zName);\n+  if( pMod ){\n+    if( pMod->bV2Native ){\n+      *ppUserData = pMod->pUserData;\n+    }else{\n+      *ppUserData = (void*)pMod;\n+    }\n+    *ppTokenizer = &pMod->x2;\n+  }else{\n+    *ppTokenizer = 0;\n+    *ppUserData = 0;\n+    rc = SQLITE_ERROR;\n+  }\n+\n+  return rc;\n+}\n+\n@@ -250712,2 +255761,6 @@\n-    *pTokenizer = pMod->x;\n-    *ppUserData = pMod->pUserData;\n+    if( pMod->bV2Native==0 ){\n+      *ppUserData = pMod->pUserData;\n+    }else{\n+      *ppUserData = (void*)pMod;\n+    }\n+    *pTokenizer = pMod->x1;\n@@ -250715,1 +255768,2 @@\n-    memset(pTokenizer, 0, sizeof(fts5_tokenizer));\n+    memset(pTokenizer, 0, sizeof(*pTokenizer));\n+    *ppUserData = 0;\n@@ -250722,8 +255776,7 @@\n-static int sqlite3Fts5GetTokenizer(\n-  Fts5Global *pGlobal,\n-  const char **azArg,\n-  int nArg,\n-  Fts5Config *pConfig,\n-  char **pzErr\n-){\n-  Fts5TokenizerModule *pMod;\n+\/*\n+** Attempt to instantiate the tokenizer.\n+*\/\n+static int sqlite3Fts5LoadTokenizer(Fts5Config *pConfig){\n+  const char **azArg = pConfig->t.azArg;\n+  const int nArg = pConfig->t.nArg;\n+  Fts5TokenizerModule *pMod = 0;\n@@ -250732,1 +255785,1 @@\n-  pMod = fts5LocateTokenizer(pGlobal, nArg==0 ? 0 : azArg[0]);\n+  pMod = fts5LocateTokenizer(pConfig->pGlobal, nArg==0 ? 0 : azArg[0]);\n@@ -250736,1 +255789,1 @@\n-    *pzErr = sqlite3_mprintf(\"no such tokenizer: %s\", azArg[0]);\n+    sqlite3Fts5ConfigErrmsg(pConfig, \"no such tokenizer: %s\", azArg[0]);\n@@ -250738,2 +255791,11 @@\n-    rc = pMod->x.xCreate(\n-        pMod->pUserData, (azArg?&azArg[1]:0), (nArg?nArg-1:0), &pConfig->pTok\n+    int (*xCreate)(void*, const char**, int, Fts5Tokenizer**) = 0;\n+    if( pMod->bV2Native ){\n+      xCreate = pMod->x2.xCreate;\n+      pConfig->t.pApi2 = &pMod->x2;\n+    }else{\n+      pConfig->t.pApi1 = &pMod->x1;\n+      xCreate = pMod->x1.xCreate;\n+    }\n+\n+    rc = xCreate(pMod->pUserData,\n+        (azArg?&azArg[1]:0), (nArg?nArg-1:0), &pConfig->t.pTok\n@@ -250741,1 +255803,1 @@\n-    pConfig->pTokApi = &pMod->x;\n+\n@@ -250743,4 +255805,6 @@\n-      if( pzErr ) *pzErr = sqlite3_mprintf(\"error in tokenizer constructor\");\n-    }else{\n-      pConfig->ePattern = sqlite3Fts5TokenizerPattern(\n-          pMod->x.xCreate, pConfig->pTok\n+      if( rc!=SQLITE_NOMEM ){\n+        sqlite3Fts5ConfigErrmsg(pConfig, \"error in tokenizer constructor\");\n+      }\n+    }else if( pMod->bV2Native==0 ){\n+      pConfig->t.ePattern = sqlite3Fts5TokenizerPattern(\n+          pMod->x1.xCreate, pConfig->t.pTok\n@@ -250752,2 +255816,3 @@\n-    pConfig->pTokApi = 0;\n-    pConfig->pTok = 0;\n+    pConfig->t.pApi1 = 0;\n+    pConfig->t.pApi2 = 0;\n+    pConfig->t.pTok = 0;\n@@ -250759,0 +255824,6 @@\n+\n+\/*\n+** xDestroy callback passed to sqlite3_create_module(). This is invoked\n+** when the db handle is being closed. Free memory associated with\n+** tokenizers and aux functions registered with this db handle.\n+*\/\n@@ -250779,0 +255850,4 @@\n+\/*\n+** Implementation of the fts5() function used by clients to obtain the\n+** API pointer.\n+*\/\n@@ -250802,1 +255877,76 @@\n-  sqlite3_result_text(pCtx, \"fts5: 2024-04-15 13:34:05 8653b758870e6ef0c98d46b3ace27849054af85da891eb121e9aaa537f1e8355\", -1, SQLITE_TRANSIENT);\n+  sqlite3_result_text(pCtx, \"fts5: 2025-02-18 13:38:58 873d4e274b4988d260ba8354a9718324a1c26187a4ab4c1cc0227c03d0f10e70\", -1, SQLITE_TRANSIENT);\n+}\n+\n+\/*\n+** Implementation of fts5_locale(LOCALE, TEXT) function.\n+**\n+** If parameter LOCALE is NULL, or a zero-length string, then a copy of\n+** TEXT is returned. Otherwise, both LOCALE and TEXT are interpreted as\n+** text, and the value returned is a blob consisting of:\n+**\n+**     * The 4 bytes 0x00, 0xE0, 0xB2, 0xEb (FTS5_LOCALE_HEADER).\n+**     * The LOCALE, as utf-8 text, followed by\n+**     * 0x00, followed by\n+**     * The TEXT, as utf-8 text.\n+**\n+** There is no final nul-terminator following the TEXT value.\n+*\/\n+static void fts5LocaleFunc(\n+  sqlite3_context *pCtx,          \/* Function call context *\/\n+  int nArg,                       \/* Number of args *\/\n+  sqlite3_value **apArg           \/* Function arguments *\/\n+){\n+  const char *zLocale = 0;\n+  int nLocale = 0;\n+  const char *zText = 0;\n+  int nText = 0;\n+\n+  assert( nArg==2 );\n+  UNUSED_PARAM(nArg);\n+\n+  zLocale = (const char*)sqlite3_value_text(apArg[0]);\n+  nLocale = sqlite3_value_bytes(apArg[0]);\n+\n+  zText = (const char*)sqlite3_value_text(apArg[1]);\n+  nText = sqlite3_value_bytes(apArg[1]);\n+\n+  if( zLocale==0 || zLocale[0]=='\\0' ){\n+    sqlite3_result_text(pCtx, zText, nText, SQLITE_TRANSIENT);\n+  }else{\n+    Fts5Global *p = (Fts5Global*)sqlite3_user_data(pCtx);\n+    u8 *pBlob = 0;\n+    u8 *pCsr = 0;\n+    int nBlob = 0;\n+\n+    nBlob = FTS5_LOCALE_HDR_SIZE + nLocale + 1 + nText;\n+    pBlob = (u8*)sqlite3_malloc(nBlob);\n+    if( pBlob==0 ){\n+      sqlite3_result_error_nomem(pCtx);\n+      return;\n+    }\n+\n+    pCsr = pBlob;\n+    memcpy(pCsr, (const u8*)p->aLocaleHdr, FTS5_LOCALE_HDR_SIZE);\n+    pCsr += FTS5_LOCALE_HDR_SIZE;\n+    memcpy(pCsr, zLocale, nLocale);\n+    pCsr += nLocale;\n+    (*pCsr++) = 0x00;\n+    if( zText ) memcpy(pCsr, zText, nText);\n+    assert( &pCsr[nText]==&pBlob[nBlob] );\n+\n+    sqlite3_result_blob(pCtx, pBlob, nBlob, sqlite3_free);\n+  }\n+}\n+\n+\/*\n+** Implementation of fts5_insttoken() function.\n+*\/\n+static void fts5InsttokenFunc(\n+  sqlite3_context *pCtx,          \/* Function call context *\/\n+  int nArg,                       \/* Number of args *\/\n+  sqlite3_value **apArg           \/* Function arguments *\/\n+){\n+  assert( nArg==1 );\n+  (void)nArg;\n+  sqlite3_result_value(pCtx, apArg[0]);\n+  sqlite3_result_subtype(pCtx, FTS5_INSTTOKEN_SUBTYPE);\n@@ -250837,0 +255987,2 @@\n+  assert( pTab->p.pConfig->pzErrmsg==0 );\n+  pTab->p.pConfig->pzErrmsg = pzErr;\n@@ -250838,7 +255990,10 @@\n-  if( (rc&0xff)==SQLITE_CORRUPT ){\n-    *pzErr = sqlite3_mprintf(\"malformed inverted index for FTS5 table %s.%s\",\n-                zSchema, zTabname);\n-  }else if( rc!=SQLITE_OK ){\n-    *pzErr = sqlite3_mprintf(\"unable to validate the inverted index for\"\n-                             \" FTS5 table %s.%s: %s\",\n-                zSchema, zTabname, sqlite3_errstr(rc));\n+  if( *pzErr==0 && rc!=SQLITE_OK ){\n+    if( (rc&0xff)==SQLITE_CORRUPT ){\n+      *pzErr = sqlite3_mprintf(\"malformed inverted index for FTS5 table %s.%s\",\n+          zSchema, zTabname);\n+      rc = (*pzErr) ? SQLITE_OK : SQLITE_NOMEM;\n+    }else{\n+      *pzErr = sqlite3_mprintf(\"unable to validate the inverted index for\"\n+          \" FTS5 table %s.%s: %s\",\n+          zSchema, zTabname, sqlite3_errstr(rc));\n+    }\n@@ -250846,0 +256001,1 @@\n+\n@@ -250847,0 +256003,1 @@\n+  pTab->p.pConfig->pzErrmsg = 0;\n@@ -250848,1 +256005,1 @@\n-  return SQLITE_OK;\n+  return rc;\n@@ -250890,1 +256047,1 @@\n-    pGlobal->api.iVersion = 2;\n+    pGlobal->api.iVersion = 3;\n@@ -250894,0 +256051,12 @@\n+    pGlobal->api.xCreateTokenizer_v2 = fts5CreateTokenizer_v2;\n+    pGlobal->api.xFindTokenizer_v2 = fts5FindTokenizer_v2;\n+\n+    \/* Initialize pGlobal->aLocaleHdr[] to a 128-bit pseudo-random vector.\n+    ** The constants below were generated randomly.  *\/\n+    sqlite3_randomness(sizeof(pGlobal->aLocaleHdr), pGlobal->aLocaleHdr);\n+    pGlobal->aLocaleHdr[0] ^= 0xF924976D;\n+    pGlobal->aLocaleHdr[1] ^= 0x16596E13;\n+    pGlobal->aLocaleHdr[2] ^= 0x7C80BEAA;\n+    pGlobal->aLocaleHdr[3] ^= 0x9B03A67F;\n+    assert( sizeof(pGlobal->aLocaleHdr)==16 );\n+\n@@ -250912,0 +256081,14 @@\n+    if( rc==SQLITE_OK ){\n+      rc = sqlite3_create_function(\n+          db, \"fts5_locale\", 2,\n+          SQLITE_UTF8|SQLITE_INNOCUOUS|SQLITE_RESULT_SUBTYPE|SQLITE_SUBTYPE,\n+          p, fts5LocaleFunc, 0, 0\n+      );\n+    }\n+    if( rc==SQLITE_OK ){\n+      rc = sqlite3_create_function(\n+          db, \"fts5_insttoken\", 1,\n+          SQLITE_UTF8|SQLITE_INNOCUOUS|SQLITE_RESULT_SUBTYPE,\n+          p, fts5InsttokenFunc, 0, 0\n+      );\n+    }\n@@ -250986,0 +256169,26 @@\n+\/*\n+** pSavedRow:\n+**   SQL statement FTS5_STMT_LOOKUP2 is a copy of FTS5_STMT_LOOKUP, it\n+**   does a by-rowid lookup to retrieve a single row from the %_content\n+**   table or equivalent external-content table\/view.\n+**\n+**   However, FTS5_STMT_LOOKUP2 is only used when retrieving the original\n+**   values for a row being UPDATEd. In that case, the SQL statement is\n+**   not reset and pSavedRow is set to point at it. This is so that the\n+**   insert operation that follows the delete may access the original\n+**   row values for any new values for which sqlite3_value_nochange() returns\n+**   true. i.e. if the user executes:\n+**\n+**        CREATE VIRTUAL TABLE ft USING fts5(a, b, c, locale=1);\n+**        ...\n+**        UPDATE fts SET a=?, b=? WHERE rowid=?;\n+**\n+**   then the value passed to the xUpdate() method of this table as the\n+**   new.c value is an sqlite3_value_nochange() value. So in this case it\n+**   must be read from the saved row stored in Fts5Storage.pSavedRow.\n+**\n+**   This is necessary - using sqlite3_value_nochange() instead of just having\n+**   SQLite pass the original value back via xUpdate() - so as not to discard\n+**   any locale information associated with such values.\n+**\n+*\/\n@@ -250992,1 +256201,2 @@\n-  sqlite3_stmt *aStmt[11];\n+  sqlite3_stmt *pSavedRow;\n+  sqlite3_stmt *aStmt[12];\n@@ -251006,8 +256216,9 @@\n-#define FTS5_STMT_INSERT_CONTENT  3\n-#define FTS5_STMT_REPLACE_CONTENT 4\n-#define FTS5_STMT_DELETE_CONTENT  5\n-#define FTS5_STMT_REPLACE_DOCSIZE  6\n-#define FTS5_STMT_DELETE_DOCSIZE  7\n-#define FTS5_STMT_LOOKUP_DOCSIZE  8\n-#define FTS5_STMT_REPLACE_CONFIG 9\n-#define FTS5_STMT_SCAN 10\n+#define FTS5_STMT_LOOKUP2         3\n+#define FTS5_STMT_INSERT_CONTENT  4\n+#define FTS5_STMT_REPLACE_CONTENT 5\n+#define FTS5_STMT_DELETE_CONTENT  6\n+#define FTS5_STMT_REPLACE_DOCSIZE 7\n+#define FTS5_STMT_DELETE_DOCSIZE  8\n+#define FTS5_STMT_LOOKUP_DOCSIZE  9\n+#define FTS5_STMT_REPLACE_CONFIG 10\n+#define FTS5_STMT_SCAN           11\n@@ -251043,0 +256254,1 @@\n+      \"SELECT %s FROM %s T WHERE T.%Q=?\",               \/* LOOKUP2  *\/\n@@ -251058,0 +256270,2 @@\n+    assert( ArraySize(azStmt)==ArraySize(p->aStmt) );\n+\n@@ -251074,0 +256288,1 @@\n+      case FTS5_STMT_LOOKUP2:\n@@ -251081,2 +256296,1 @@\n-        int nCol = pC->nCol + 1;\n-        char *zBind;\n+        char *zBind = 0;\n@@ -251085,5 +256299,11 @@\n-        zBind = sqlite3_malloc64(1 + nCol*2);\n-        if( zBind ){\n-          for(i=0; i<nCol; i++){\n-            zBind[i*2] = '?';\n-            zBind[i*2 + 1] = ',';\n+        assert( pC->eContent==FTS5_CONTENT_NORMAL\n+             || pC->eContent==FTS5_CONTENT_UNINDEXED\n+        );\n+\n+        \/* Add bindings for the \"c*\" columns - those that store the actual\n+        ** table content. If eContent==NORMAL, then there is one binding\n+        ** for each column. Or, if eContent==UNINDEXED, then there are only\n+        ** bindings for the UNINDEXED columns. *\/\n+        for(i=0; rc==SQLITE_OK && i<(pC->nCol+1); i++){\n+          if( !i || pC->eContent==FTS5_CONTENT_NORMAL || pC->abUnindexed[i-1] ){\n+            zBind = sqlite3Fts5Mprintf(&rc, \"%z%s?%d\", zBind, zBind?\",\":\"\",i+1);\n@@ -251091,3 +256311,0 @@\n-          zBind[i*2-1] = '\\0';\n-          zSql = sqlite3_mprintf(azStmt[eStmt], pC->zDb, pC->zName, zBind);\n-          sqlite3_free(zBind);\n@@ -251095,0 +256312,13 @@\n+\n+        \/* Add bindings for any \"l*\" columns. Only non-UNINDEXED columns\n+        ** require these.  *\/\n+        if( pC->bLocale && pC->eContent==FTS5_CONTENT_NORMAL ){\n+          for(i=0; rc==SQLITE_OK && i<pC->nCol; i++){\n+            if( pC->abUnindexed[i]==0 ){\n+              zBind = sqlite3Fts5Mprintf(&rc, \"%z,?%d\", zBind, pC->nCol+i+2);\n+            }\n+          }\n+        }\n+\n+        zSql = sqlite3Fts5Mprintf(&rc, azStmt[eStmt], pC->zDb, pC->zName,zBind);\n+        sqlite3_free(zBind);\n@@ -251120,1 +256350,1 @@\n-      if( eStmt>FTS5_STMT_LOOKUP ) f |= SQLITE_PREPARE_NO_VTAB;\n+      if( eStmt>FTS5_STMT_LOOKUP2 ) f |= SQLITE_PREPARE_NO_VTAB;\n@@ -251128,0 +256358,5 @@\n+      if( rc==SQLITE_ERROR && eStmt>FTS5_STMT_LOOKUP2 && eStmt<FTS5_STMT_SCAN ){\n+        \/* One of the internal tables - not the %_content table - is missing.\n+        ** This counts as a corrupted table.  *\/\n+       rc = SQLITE_CORRUPT;\n+      }\n@@ -251280,1 +256515,3 @@\n-    if( pConfig->eContent==FTS5_CONTENT_NORMAL ){\n+    if( pConfig->eContent==FTS5_CONTENT_NORMAL\n+     || pConfig->eContent==FTS5_CONTENT_UNINDEXED\n+    ){\n@@ -251282,1 +256519,1 @@\n-      char *zDefn = sqlite3_malloc64(32 + (sqlite3_int64)pConfig->nCol * 10);\n+      char *zDefn = sqlite3_malloc64(32 + (sqlite3_int64)pConfig->nCol * 20);\n@@ -251291,2 +256528,14 @@\n-          sqlite3_snprintf(nDefn-iOff, &zDefn[iOff], \", c%d\", i);\n-          iOff += (int)strlen(&zDefn[iOff]);\n+          if( pConfig->eContent==FTS5_CONTENT_NORMAL\n+           || pConfig->abUnindexed[i]\n+          ){\n+            sqlite3_snprintf(nDefn-iOff, &zDefn[iOff], \", c%d\", i);\n+            iOff += (int)strlen(&zDefn[iOff]);\n+          }\n+        }\n+        if( pConfig->bLocale ){\n+          for(i=0; i<pConfig->nCol; i++){\n+            if( pConfig->abUnindexed[i]==0 ){\n+              sqlite3_snprintf(nDefn-iOff, &zDefn[iOff], \", l%d\", i);\n+              iOff += (int)strlen(&zDefn[iOff]);\n+            }\n+          }\n@@ -251369,0 +256618,28 @@\n+\/*\n+** This function is used as part of an UPDATE statement that modifies the\n+** rowid of a row. In that case, this function is called first to set\n+** Fts5Storage.pSavedRow to point to a statement that may be used to\n+** access the original values of the row being deleted - iDel.\n+**\n+** SQLITE_OK is returned if successful, or an SQLite error code otherwise.\n+** It is not considered an error if row iDel does not exist. In this case\n+** pSavedRow is not set and SQLITE_OK returned.\n+*\/\n+static int sqlite3Fts5StorageFindDeleteRow(Fts5Storage *p, i64 iDel){\n+  int rc = SQLITE_OK;\n+  sqlite3_stmt *pSeek = 0;\n+\n+  assert( p->pSavedRow==0 );\n+  rc = fts5StorageGetStmt(p, FTS5_STMT_LOOKUP+1, &pSeek, 0);\n+  if( rc==SQLITE_OK ){\n+    sqlite3_bind_int64(pSeek, 1, iDel);\n+    if( sqlite3_step(pSeek)!=SQLITE_ROW ){\n+      rc = sqlite3_reset(pSeek);\n+    }else{\n+      p->pSavedRow = pSeek;\n+    }\n+  }\n+\n+  return rc;\n+}\n+\n@@ -251373,0 +256650,5 @@\n+**\n+** If parameter bSaveRow is true, then Fts5Storage.pSavedRow is left\n+** pointing to a statement (FTS5_STMT_LOOKUP2) that may be used to access\n+** the original values of the row being deleted. This is used by UPDATE\n+** statements.\n@@ -251377,1 +256659,2 @@\n-  sqlite3_value **apVal\n+  sqlite3_value **apVal,\n+  int bSaveRow                    \/* True to set pSavedRow *\/\n@@ -251386,0 +256669,4 @@\n+  assert( bSaveRow==0 || apVal==0 );\n+  assert( bSaveRow==0 || bSaveRow==1 );\n+  assert( FTS5_STMT_LOOKUP2==FTS5_STMT_LOOKUP+1 );\n+\n@@ -251387,5 +256674,10 @@\n-    rc = fts5StorageGetStmt(p, FTS5_STMT_LOOKUP, &pSeek, 0);\n-    if( rc!=SQLITE_OK ) return rc;\n-    sqlite3_bind_int64(pSeek, 1, iDel);\n-    if( sqlite3_step(pSeek)!=SQLITE_ROW ){\n-      return sqlite3_reset(pSeek);\n+    if( p->pSavedRow && bSaveRow ){\n+      pSeek = p->pSavedRow;\n+      p->pSavedRow = 0;\n+    }else{\n+      rc = fts5StorageGetStmt(p, FTS5_STMT_LOOKUP+bSaveRow, &pSeek, 0);\n+      if( rc!=SQLITE_OK ) return rc;\n+      sqlite3_bind_int64(pSeek, 1, iDel);\n+      if( sqlite3_step(pSeek)!=SQLITE_ROW ){\n+        return sqlite3_reset(pSeek);\n+      }\n@@ -251399,2 +256691,6 @@\n-      const char *zText;\n-      int nText;\n+      sqlite3_value *pVal = 0;\n+      const char *pText = 0;\n+      int nText = 0;\n+      const char *pLoc = 0;\n+      int nLoc = 0;\n+\n@@ -251404,5 +256700,1 @@\n-        zText = (const char*)sqlite3_column_text(pSeek, iCol);\n-        nText = sqlite3_column_bytes(pSeek, iCol);\n-      }else if( ALWAYS(apVal) ){\n-        zText = (const char*)sqlite3_value_text(apVal[iCol-1]);\n-        nText = sqlite3_value_bytes(apVal[iCol-1]);\n+        pVal = sqlite3_column_value(pSeek, iCol);\n@@ -251410,1 +256702,1 @@\n-        continue;\n+        pVal = apVal[iCol-1];\n@@ -251412,7 +256704,23 @@\n-      ctx.szCol = 0;\n-      rc = sqlite3Fts5Tokenize(pConfig, FTS5_TOKENIZE_DOCUMENT,\n-          zText, nText, (void*)&ctx, fts5StorageInsertCallback\n-      );\n-      p->aTotalSize[iCol-1] -= (i64)ctx.szCol;\n-      if( p->aTotalSize[iCol-1]<0 ){\n-        rc = FTS5_CORRUPT;\n+\n+      if( pConfig->bLocale && sqlite3Fts5IsLocaleValue(pConfig, pVal) ){\n+        rc = sqlite3Fts5DecodeLocaleValue(pVal, &pText, &nText, &pLoc, &nLoc);\n+      }else{\n+        pText = (const char*)sqlite3_value_text(pVal);\n+        nText = sqlite3_value_bytes(pVal);\n+        if( pConfig->bLocale && pSeek ){\n+          pLoc = (const char*)sqlite3_column_text(pSeek, iCol + pConfig->nCol);\n+          nLoc = sqlite3_column_bytes(pSeek, iCol + pConfig->nCol);\n+        }\n+      }\n+\n+      if( rc==SQLITE_OK ){\n+        sqlite3Fts5SetLocale(pConfig, pLoc, nLoc);\n+        ctx.szCol = 0;\n+        rc = sqlite3Fts5Tokenize(pConfig, FTS5_TOKENIZE_DOCUMENT,\n+            pText, nText, (void*)&ctx, fts5StorageInsertCallback\n+        );\n+        p->aTotalSize[iCol-1] -= (i64)ctx.szCol;\n+        if( rc==SQLITE_OK && p->aTotalSize[iCol-1]<0 ){\n+          rc = FTS5_CORRUPT;\n+        }\n+        sqlite3Fts5ClearLocale(pConfig);\n@@ -251428,2 +256736,7 @@\n-  rc2 = sqlite3_reset(pSeek);\n-  if( rc==SQLITE_OK ) rc = rc2;\n+  if( rc==SQLITE_OK && bSaveRow ){\n+    assert( p->pSavedRow==0 );\n+    p->pSavedRow = pSeek;\n+  }else{\n+    rc2 = sqlite3_reset(pSeek);\n+    if( rc==SQLITE_OK ) rc = rc2;\n+  }\n@@ -251433,0 +256746,13 @@\n+\/*\n+** Reset any saved statement pSavedRow. Zero pSavedRow as well. This\n+** should be called by the xUpdate() method of the fts5 table before\n+** returning from any operation that may have set Fts5Storage.pSavedRow.\n+*\/\n+static void sqlite3Fts5StorageReleaseDeleteRow(Fts5Storage *pStorage){\n+  assert( pStorage->pSavedRow==0\n+       || pStorage->pSavedRow==pStorage->aStmt[FTS5_STMT_LOOKUP2]\n+  );\n+  sqlite3_reset(pStorage->pSavedRow);\n+  pStorage->pSavedRow = 0;\n+}\n+\n@@ -251445,1 +256771,3 @@\n-  assert( p->pConfig->eContent==FTS5_CONTENT_NONE );\n+  assert( p->pConfig->eContent==FTS5_CONTENT_NONE\n+       || p->pConfig->eContent==FTS5_CONTENT_UNINDEXED\n+  );\n@@ -251489,6 +256817,6 @@\n-      if( rc==SQLITE_OK ){\n-        sqlite3_bind_blob(pReplace, 2, pBuf->p, pBuf->n, SQLITE_STATIC);\n-        sqlite3_step(pReplace);\n-        rc = sqlite3_reset(pReplace);\n-        sqlite3_bind_null(pReplace, 2);\n-      }\n+    }\n+    if( rc==SQLITE_OK ){\n+      sqlite3_bind_blob(pReplace, 2, pBuf->p, pBuf->n, SQLITE_STATIC);\n+      sqlite3_step(pReplace);\n+      rc = sqlite3_reset(pReplace);\n+      sqlite3_bind_null(pReplace, 2);\n@@ -251548,1 +256876,6 @@\n-static int sqlite3Fts5StorageDelete(Fts5Storage *p, i64 iDel, sqlite3_value **apVal){\n+static int sqlite3Fts5StorageDelete(\n+  Fts5Storage *p,                 \/* Storage object *\/\n+  i64 iDel,                       \/* Rowid to delete from table *\/\n+  sqlite3_value **apVal,          \/* Optional - values to remove from index *\/\n+  int bSaveRow                    \/* If true, set pSavedRow for deleted row *\/\n+){\n@@ -251564,0 +256897,6 @@\n+      if( rc==SQLITE_OK\n+       && bSaveRow\n+       && p->pConfig->eContent==FTS5_CONTENT_UNINDEXED\n+      ){\n+        rc = sqlite3Fts5StorageFindDeleteRow(p, iDel);\n+      }\n@@ -251565,1 +256904,1 @@\n-      rc = fts5StorageDeleteFromIndex(p, iDel, apVal);\n+      rc = fts5StorageDeleteFromIndex(p, iDel, apVal, bSaveRow);\n@@ -251580,1 +256919,3 @@\n-  if( pConfig->eContent==FTS5_CONTENT_NORMAL ){\n+  if( pConfig->eContent==FTS5_CONTENT_NORMAL\n+   || pConfig->eContent==FTS5_CONTENT_UNINDEXED\n+  ){\n@@ -251612,2 +256953,7 @@\n-        \"DELETE FROM %Q.'%q_docsize';\",\n-        pConfig->zDb, pConfig->zName\n+        \"DELETE FROM %Q.'%q_docsize';\", pConfig->zDb, pConfig->zName\n+    );\n+  }\n+\n+  if( rc==SQLITE_OK && pConfig->eContent==FTS5_CONTENT_UNINDEXED ){\n+    rc = fts5ExecPrintf(pConfig->db, 0,\n+        \"DELETE FROM %Q.'%q_content';\", pConfig->zDb, pConfig->zName\n@@ -251654,8 +257000,30 @@\n-        const char *zText = (const char*)sqlite3_column_text(pScan, ctx.iCol+1);\n-        int nText = sqlite3_column_bytes(pScan, ctx.iCol+1);\n-        rc = sqlite3Fts5Tokenize(pConfig,\n-            FTS5_TOKENIZE_DOCUMENT,\n-            zText, nText,\n-            (void*)&ctx,\n-            fts5StorageInsertCallback\n-        );\n+        int nText = 0;            \/* Size of pText in bytes *\/\n+        const char *pText = 0;    \/* Pointer to buffer containing text value *\/\n+        int nLoc = 0;             \/* Size of pLoc in bytes *\/\n+        const char *pLoc = 0;     \/* Pointer to buffer containing text value *\/\n+\n+        sqlite3_value *pVal = sqlite3_column_value(pScan, ctx.iCol+1);\n+        if( pConfig->eContent==FTS5_CONTENT_EXTERNAL\n+         && sqlite3Fts5IsLocaleValue(pConfig, pVal)\n+        ){\n+          rc = sqlite3Fts5DecodeLocaleValue(pVal, &pText, &nText, &pLoc, &nLoc);\n+        }else{\n+          pText = (const char*)sqlite3_value_text(pVal);\n+          nText = sqlite3_value_bytes(pVal);\n+          if( pConfig->bLocale ){\n+            int iCol = ctx.iCol + 1 + pConfig->nCol;\n+            pLoc = (const char*)sqlite3_column_text(pScan, iCol);\n+            nLoc = sqlite3_column_bytes(pScan, iCol);\n+          }\n+        }\n+\n+        if( rc==SQLITE_OK ){\n+          sqlite3Fts5SetLocale(pConfig, pLoc, nLoc);\n+          rc = sqlite3Fts5Tokenize(pConfig,\n+              FTS5_TOKENIZE_DOCUMENT,\n+              pText, nText,\n+              (void*)&ctx,\n+              fts5StorageInsertCallback\n+          );\n+          sqlite3Fts5ClearLocale(pConfig);\n+        }\n@@ -251727,0 +257095,1 @@\n+  int bReplace,                   \/* True to use REPLACE instead of INSERT *\/\n@@ -251734,1 +257103,3 @@\n-  if( pConfig->eContent!=FTS5_CONTENT_NORMAL ){\n+  if( pConfig->eContent!=FTS5_CONTENT_NORMAL\n+   && pConfig->eContent!=FTS5_CONTENT_UNINDEXED\n+  ){\n@@ -251743,3 +257114,46 @@\n-    rc = fts5StorageGetStmt(p, FTS5_STMT_INSERT_CONTENT, &pInsert, 0);\n-    for(i=1; rc==SQLITE_OK && i<=pConfig->nCol+1; i++){\n-      rc = sqlite3_bind_value(pInsert, i, apVal[i]);\n+\n+    assert( FTS5_STMT_INSERT_CONTENT+1==FTS5_STMT_REPLACE_CONTENT );\n+    assert( bReplace==0 || bReplace==1 );\n+    rc = fts5StorageGetStmt(p, FTS5_STMT_INSERT_CONTENT+bReplace, &pInsert, 0);\n+    if( pInsert ) sqlite3_clear_bindings(pInsert);\n+\n+    \/* Bind the rowid value *\/\n+    sqlite3_bind_value(pInsert, 1, apVal[1]);\n+\n+    \/* Loop through values for user-defined columns. i=2 is the leftmost\n+    ** user-defined column. As is column 1 of pSavedRow.  *\/\n+    for(i=2; rc==SQLITE_OK && i<=pConfig->nCol+1; i++){\n+      int bUnindexed = pConfig->abUnindexed[i-2];\n+      if( pConfig->eContent==FTS5_CONTENT_NORMAL || bUnindexed ){\n+        sqlite3_value *pVal = apVal[i];\n+\n+        if( sqlite3_value_nochange(pVal) && p->pSavedRow ){\n+          \/* This is an UPDATE statement, and user-defined column (i-2) was not\n+          ** modified.  Retrieve the value from Fts5Storage.pSavedRow.  *\/\n+          pVal = sqlite3_column_value(p->pSavedRow, i-1);\n+          if( pConfig->bLocale && bUnindexed==0 ){\n+            sqlite3_bind_value(pInsert, pConfig->nCol + i,\n+                sqlite3_column_value(p->pSavedRow, pConfig->nCol + i - 1)\n+            );\n+          }\n+        }else if( sqlite3Fts5IsLocaleValue(pConfig, pVal) ){\n+          const char *pText = 0;\n+          const char *pLoc = 0;\n+          int nText = 0;\n+          int nLoc = 0;\n+          assert( pConfig->bLocale );\n+\n+          rc = sqlite3Fts5DecodeLocaleValue(pVal, &pText, &nText, &pLoc, &nLoc);\n+          if( rc==SQLITE_OK ){\n+            sqlite3_bind_text(pInsert, i, pText, nText, SQLITE_TRANSIENT);\n+            if( bUnindexed==0 ){\n+              int iLoc = pConfig->nCol + i;\n+              sqlite3_bind_text(pInsert, iLoc, pLoc, nLoc, SQLITE_TRANSIENT);\n+            }\n+          }\n+\n+          continue;\n+        }\n+\n+        rc = sqlite3_bind_value(pInsert, i, pVal);\n+      }\n@@ -251780,8 +257194,32 @@\n-      const char *zText = (const char*)sqlite3_value_text(apVal[ctx.iCol+2]);\n-      int nText = sqlite3_value_bytes(apVal[ctx.iCol+2]);\n-      rc = sqlite3Fts5Tokenize(pConfig,\n-          FTS5_TOKENIZE_DOCUMENT,\n-          zText, nText,\n-          (void*)&ctx,\n-          fts5StorageInsertCallback\n-      );\n+      int nText = 0;              \/* Size of pText in bytes *\/\n+      const char *pText = 0;      \/* Pointer to buffer containing text value *\/\n+      int nLoc = 0;               \/* Size of pText in bytes *\/\n+      const char *pLoc = 0;       \/* Pointer to buffer containing text value *\/\n+\n+      sqlite3_value *pVal = apVal[ctx.iCol+2];\n+      if( p->pSavedRow && sqlite3_value_nochange(pVal) ){\n+        pVal = sqlite3_column_value(p->pSavedRow, ctx.iCol+1);\n+        if( pConfig->eContent==FTS5_CONTENT_NORMAL && pConfig->bLocale ){\n+          int iCol = ctx.iCol + 1 + pConfig->nCol;\n+          pLoc = (const char*)sqlite3_column_text(p->pSavedRow, iCol);\n+          nLoc = sqlite3_column_bytes(p->pSavedRow, iCol);\n+        }\n+      }else{\n+        pVal = apVal[ctx.iCol+2];\n+      }\n+\n+      if( pConfig->bLocale && sqlite3Fts5IsLocaleValue(pConfig, pVal) ){\n+        rc = sqlite3Fts5DecodeLocaleValue(pVal, &pText, &nText, &pLoc, &nLoc);\n+      }else{\n+        pText = (const char*)sqlite3_value_text(pVal);\n+        nText = sqlite3_value_bytes(pVal);\n+      }\n+\n+      if( rc==SQLITE_OK ){\n+        sqlite3Fts5SetLocale(pConfig, pLoc, nLoc);\n+        rc = sqlite3Fts5Tokenize(pConfig,\n+            FTS5_TOKENIZE_DOCUMENT, pText, nText, (void*)&ctx,\n+            fts5StorageInsertCallback\n+        );\n+        sqlite3Fts5ClearLocale(pConfig);\n+      }\n@@ -251951,23 +257389,55 @@\n-          if( pConfig->abUnindexed[i] ) continue;\n-          ctx.iCol = i;\n-          ctx.szCol = 0;\n-          if( pConfig->eDetail==FTS5_DETAIL_COLUMNS ){\n-            rc = sqlite3Fts5TermsetNew(&ctx.pTermset);\n-          }\n-          if( rc==SQLITE_OK ){\n-            const char *zText = (const char*)sqlite3_column_text(pScan, i+1);\n-            int nText = sqlite3_column_bytes(pScan, i+1);\n-            rc = sqlite3Fts5Tokenize(pConfig,\n-                FTS5_TOKENIZE_DOCUMENT,\n-                zText, nText,\n-                (void*)&ctx,\n-                fts5StorageIntegrityCallback\n-            );\n-          }\n-          if( rc==SQLITE_OK && pConfig->bColumnsize && ctx.szCol!=aColSize[i] ){\n-            rc = FTS5_CORRUPT;\n-          }\n-          aTotalSize[i] += ctx.szCol;\n-          if( pConfig->eDetail==FTS5_DETAIL_COLUMNS ){\n-            sqlite3Fts5TermsetFree(ctx.pTermset);\n-            ctx.pTermset = 0;\n+          if( pConfig->abUnindexed[i]==0 ){\n+            const char *pText = 0;\n+            int nText = 0;\n+            const char *pLoc = 0;\n+            int nLoc = 0;\n+            sqlite3_value *pVal = sqlite3_column_value(pScan, i+1);\n+\n+            if( pConfig->eContent==FTS5_CONTENT_EXTERNAL\n+             && sqlite3Fts5IsLocaleValue(pConfig, pVal)\n+            ){\n+              rc = sqlite3Fts5DecodeLocaleValue(\n+                  pVal, &pText, &nText, &pLoc, &nLoc\n+              );\n+            }else{\n+              if( pConfig->eContent==FTS5_CONTENT_NORMAL && pConfig->bLocale ){\n+                int iCol = i + 1 + pConfig->nCol;\n+                pLoc = (const char*)sqlite3_column_text(pScan, iCol);\n+                nLoc = sqlite3_column_bytes(pScan, iCol);\n+              }\n+              pText = (const char*)sqlite3_value_text(pVal);\n+              nText = sqlite3_value_bytes(pVal);\n+            }\n+\n+            ctx.iCol = i;\n+            ctx.szCol = 0;\n+\n+            if( rc==SQLITE_OK && pConfig->eDetail==FTS5_DETAIL_COLUMNS ){\n+              rc = sqlite3Fts5TermsetNew(&ctx.pTermset);\n+            }\n+\n+            if( rc==SQLITE_OK ){\n+              sqlite3Fts5SetLocale(pConfig, pLoc, nLoc);\n+              rc = sqlite3Fts5Tokenize(pConfig,\n+                  FTS5_TOKENIZE_DOCUMENT,\n+                  pText, nText,\n+                  (void*)&ctx,\n+                  fts5StorageIntegrityCallback\n+              );\n+              sqlite3Fts5ClearLocale(pConfig);\n+            }\n+\n+            \/* If this is not a columnsize=0 database, check that the number\n+            ** of tokens in the value matches the aColSize[] value read from\n+            ** the %_docsize table.  *\/\n+            if( rc==SQLITE_OK\n+             && pConfig->bColumnsize\n+             && ctx.szCol!=aColSize[i]\n+            ){\n+              rc = FTS5_CORRUPT;\n+            }\n+            aTotalSize[i] += ctx.szCol;\n+            if( pConfig->eDetail==FTS5_DETAIL_COLUMNS ){\n+              sqlite3Fts5TermsetFree(ctx.pTermset);\n+              ctx.pTermset = 0;\n+            }\n@@ -252399,1 +257869,1 @@\n-    while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){            \\\n+    while( zIn<zTerm && (*zIn & 0xc0)==0x80 ){             \\\n@@ -252587,1 +258057,0 @@\n-\n@@ -252617,1 +258086,0 @@\n-\n@@ -252756,1 +258224,1 @@\n-  fts5_tokenizer tokenizer;       \/* Parent tokenizer module *\/\n+  fts5_tokenizer_v2 tokenizer_v2; \/* Parent tokenizer module *\/\n@@ -252768,1 +258236,1 @@\n-      p->tokenizer.xDelete(p->pTokenizer);\n+      p->tokenizer_v2.xDelete(p->pTokenizer);\n@@ -252787,0 +258255,1 @@\n+  fts5_tokenizer_v2 *pV2 = 0;\n@@ -252795,1 +258264,1 @@\n-    rc = pApi->xFindTokenizer(pApi, zBase, &pUserdata, &pRet->tokenizer);\n+    rc = pApi->xFindTokenizer_v2(pApi, zBase, &pUserdata, &pV2);\n@@ -252801,2 +258270,3 @@\n-    const char **azArg2 = (nArg2 ? &azArg[1] : 0);\n-    rc = pRet->tokenizer.xCreate(pUserdata, azArg2, nArg2, &pRet->pTokenizer);\n+    const char **az2 = (nArg2 ? &azArg[1] : 0);\n+    memcpy(&pRet->tokenizer_v2, pV2, sizeof(fts5_tokenizer_v2));\n+    rc = pRet->tokenizer_v2.xCreate(pUserdata, az2, nArg2, &pRet->pTokenizer);\n@@ -253453,0 +258923,1 @@\n+  const char *pLoc, int nLoc,\n@@ -253460,2 +258931,2 @@\n-  return p->tokenizer.xTokenize(\n-      p->pTokenizer, (void*)&sCtx, flags, pText, nText, fts5PorterCb\n+  return p->tokenizer_v2.xTokenize(\n+      p->pTokenizer, (void*)&sCtx, flags, pText, nText, pLoc, nLoc, fts5PorterCb\n@@ -253491,1 +258962,1 @@\n-  TrigramTokenizer *pNew = (TrigramTokenizer*)sqlite3_malloc(sizeof(*pNew));\n+  TrigramTokenizer *pNew = 0;\n@@ -253493,2 +258964,2 @@\n-  if( pNew==0 ){\n-    rc = SQLITE_NOMEM;\n+  if( nArg%2 ){\n+    rc = SQLITE_ERROR;\n@@ -253497,7 +258968,21 @@\n-    pNew->bFold = 1;\n-    pNew->iFoldParam = 0;\n-    for(i=0; rc==SQLITE_OK && i<nArg; i+=2){\n-      const char *zArg = azArg[i+1];\n-      if( 0==sqlite3_stricmp(azArg[i], \"case_sensitive\") ){\n-        if( (zArg[0]!='0' && zArg[0]!='1') || zArg[1] ){\n-          rc = SQLITE_ERROR;\n+    pNew = (TrigramTokenizer*)sqlite3_malloc(sizeof(*pNew));\n+    if( pNew==0 ){\n+      rc = SQLITE_NOMEM;\n+    }else{\n+      pNew->bFold = 1;\n+      pNew->iFoldParam = 0;\n+\n+      for(i=0; rc==SQLITE_OK && i<nArg; i+=2){\n+        const char *zArg = azArg[i+1];\n+        if( 0==sqlite3_stricmp(azArg[i], \"case_sensitive\") ){\n+          if( (zArg[0]!='0' && zArg[0]!='1') || zArg[1] ){\n+            rc = SQLITE_ERROR;\n+          }else{\n+            pNew->bFold = (zArg[0]=='0');\n+          }\n+        }else if( 0==sqlite3_stricmp(azArg[i], \"remove_diacritics\") ){\n+          if( (zArg[0]!='0' && zArg[0]!='1' && zArg[0]!='2') || zArg[1] ){\n+            rc = SQLITE_ERROR;\n+          }else{\n+            pNew->iFoldParam = (zArg[0]!='0') ? 2 : 0;\n+          }\n@@ -253505,4 +258990,0 @@\n-          pNew->bFold = (zArg[0]=='0');\n-        }\n-      }else if( 0==sqlite3_stricmp(azArg[i], \"remove_diacritics\") ){\n-        if( (zArg[0]!='0' && zArg[0]!='1' && zArg[0]!='2') || zArg[1] ){\n@@ -253510,2 +258991,0 @@\n-        }else{\n-          pNew->iFoldParam = (zArg[0]!='0') ? 2 : 0;\n@@ -253513,2 +258992,0 @@\n-      }else{\n-        rc = SQLITE_ERROR;\n@@ -253516,1 +258993,0 @@\n-    }\n@@ -253518,3 +258994,3 @@\n-    if( pNew->iFoldParam!=0 && pNew->bFold==0 ){\n-      rc = SQLITE_ERROR;\n-    }\n+      if( pNew->iFoldParam!=0 && pNew->bFold==0 ){\n+        rc = SQLITE_ERROR;\n+      }\n@@ -253522,3 +258998,4 @@\n-    if( rc!=SQLITE_OK ){\n-      fts5TriDelete((Fts5Tokenizer*)pNew);\n-      pNew = 0;\n+      if( rc!=SQLITE_OK ){\n+        fts5TriDelete((Fts5Tokenizer*)pNew);\n+        pNew = 0;\n+      }\n@@ -253547,2 +259024,2 @@\n-  const unsigned char *zEof = &zIn[nText];\n-  u32 iCode;\n+  const unsigned char *zEof = (zIn ? &zIn[nText] : 0);\n+  u32 iCode = 0;\n@@ -253557,0 +259034,1 @@\n+      if( zIn>=zEof ) return SQLITE_OK;\n@@ -253558,1 +259036,0 @@\n-      if( iCode==0 ) return SQLITE_OK;\n@@ -253579,0 +259056,4 @@\n+      if( zIn>=zEof ){\n+        iCode = 0;\n+        break;\n+      }\n@@ -253580,1 +259061,0 @@\n-      if( iCode==0 ) break;\n@@ -253629,0 +259109,10 @@\n+\/*\n+** Return true if the tokenizer described by p->azArg[] is the trigram\n+** tokenizer. This tokenizer needs to be loaded before xBestIndex is\n+** called for the first time in order to correctly handle LIKE\/GLOB.\n+*\/\n+static int sqlite3Fts5TokenizerPreload(Fts5TokenizerConfig *p){\n+  return (p->nArg>=1 && 0==sqlite3_stricmp(p->azArg[0], \"trigram\"));\n+}\n+\n+\n@@ -253639,1 +259129,0 @@\n-    { \"porter\",    {fts5PorterCreate, fts5PorterDelete, fts5PorterTokenize }},\n@@ -253654,1 +259143,14 @@\n-\n+  if( rc==SQLITE_OK ){\n+    fts5_tokenizer_v2 sPorter = {\n+      2,\n+      fts5PorterCreate,\n+      fts5PorterDelete,\n+      fts5PorterTokenize\n+    };\n+    rc = pApi->xCreateTokenizer_v2(pApi,\n+        \"porter\",\n+        (void*)pApi,\n+        &sPorter,\n+        0\n+    );\n+  }\n@@ -254024,0 +259526,3 @@\n+\n+    default:\n+      return 1;\n@@ -254848,0 +260353,1 @@\n+  int colUsed;                    \/* Copy of sqlite3_index_info.colUsed *\/\n@@ -254874,3 +260380,5 @@\n-#define FTS5_VOCAB_TERM_EQ 0x01\n-#define FTS5_VOCAB_TERM_GE 0x02\n-#define FTS5_VOCAB_TERM_LE 0x04\n+#define FTS5_VOCAB_TERM_EQ 0x0100\n+#define FTS5_VOCAB_TERM_GE 0x0200\n+#define FTS5_VOCAB_TERM_LE 0x0400\n+\n+#define FTS5_VOCAB_COLUSED_MASK 0xFF\n@@ -255053,1 +260561,1 @@\n-  int idxNum = 0;\n+  int idxNum = (int)pInfo->colUsed;\n@@ -255058,0 +260566,2 @@\n+  assert( (pInfo->colUsed & FTS5_VOCAB_COLUSED_MASK)==pInfo->colUsed );\n+\n@@ -255149,1 +260659,1 @@\n-            );\n+        );\n@@ -255309,3 +260819,13 @@\n-            if( eDetail==FTS5_DETAIL_FULL ){\n-              while( 0==sqlite3Fts5PoslistNext64(pPos, nPos, &iOff, &iPos) ){\n-                pCsr->aCnt[0]++;\n+            \/* Do not bother counting the number of instances if the \"cnt\"\n+            ** column is not being read (according to colUsed).  *\/\n+            if( eDetail==FTS5_DETAIL_FULL && (pCsr->colUsed & 0x04) ){\n+              while( iPos<nPos ){\n+                u32 ii;\n+                fts5FastGetVarint32(pPos, iPos, ii);\n+                if( ii==1 ){\n+                  \/* New column in the position list *\/\n+                  fts5FastGetVarint32(pPos, iPos, ii);\n+                }else{\n+                  \/* An instance - increment pCsr->aCnt[] *\/\n+                  pCsr->aCnt[0]++;\n+                }\n@@ -255409,0 +260929,1 @@\n+  pCsr->colUsed = (idxNum & FTS5_VOCAB_COLUSED_MASK);\n@@ -255576,1 +261097,1 @@\n-\n+\/* Here ends the fts5.c composite file. *\/\n@@ -255932,0 +261453,1 @@\n+#endif \/* SQLITE_AMALGAMATION *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/sqlite\/sqlite3.c","additions":11936,"deletions":6414,"binary":false,"changes":18350,"status":"modified"},{"patch":"@@ -149,3 +149,3 @@\n-#define SQLITE_VERSION        \"3.45.3\"\n-#define SQLITE_VERSION_NUMBER 3045003\n-#define SQLITE_SOURCE_ID      \"2024-04-15 13:34:05 8653b758870e6ef0c98d46b3ace27849054af85da891eb121e9aaa537f1e8355\"\n+#define SQLITE_VERSION        \"3.49.1\"\n+#define SQLITE_VERSION_NUMBER 3049001\n+#define SQLITE_SOURCE_ID      \"2025-02-18 13:38:58 873d4e274b4988d260ba8354a9718324a1c26187a4ab4c1cc0227c03d0f10e70\"\n@@ -655,0 +655,7 @@\n+**\n+** The SQLITE_IOCAP_SUBPAGE_READ property means that it is ok to read\n+** from the database file in amounts that are not a multiple of the\n+** page size and that do not begin at a page boundary.  Without this\n+** property, SQLite is careful to only do full-page reads and write\n+** on aligned pages, with the one exception that it will do a sub-page\n+** read of the first page to access the database header.\n@@ -671,0 +678,1 @@\n+#define SQLITE_IOCAP_SUBPAGE_READ           0x00008000\n@@ -767,1 +775,1 @@\n-** xLock() is always on of SHARED, RESERVED, PENDING, or EXCLUSIVE, never\n+** xLock() is always one of SHARED, RESERVED, PENDING, or EXCLUSIVE, never\n@@ -771,1 +779,1 @@\n-*  If the lock is already at or below the requested lock state, then the call\n+** If the lock is already at or below the requested lock state, then the call\n@@ -775,2 +783,2 @@\n-** PENDING, or EXCLUSIVE lock on the file.  It returns true\n-** if such a lock exists and false otherwise.\n+** PENDING, or EXCLUSIVE lock on the file.  It returns, via its output\n+** pointer parameter, true if such a lock exists and false otherwise.\n@@ -817,0 +825,1 @@\n+** <li> [SQLITE_IOCAP_SUBPAGE_READ]\n@@ -1094,0 +1103,5 @@\n+** <li>[[SQLITE_FCNTL_NULL_IO]]\n+** The [SQLITE_FCNTL_NULL_IO] opcode sets the low-level file descriptor\n+** or file handle for the [sqlite3_file] object such that it will no longer\n+** read or write to the database file.\n+**\n@@ -1247,0 +1261,1 @@\n+#define SQLITE_FCNTL_NULL_IO                43\n@@ -2199,1 +2214,9 @@\n-** can be passed as the second argument to the [sqlite3_db_config()] interface.\n+** can be passed as the second parameter to the [sqlite3_db_config()] interface.\n+**\n+** The [sqlite3_db_config()] interface is a var-args functions.  It takes a\n+** variable number of parameters, though always at least two.  The number of\n+** parameters passed into sqlite3_db_config() depends on which of these\n+** constants is given as the second parameter.  This documentation page\n+** refers to parameters beyond the second as \"arguments\".  Thus, when this\n+** page says \"the N-th argument\" it means \"the N-th parameter past the\n+** configuration option\" or \"the (N+2)-th parameter to sqlite3_db_config()\".\n@@ -2211,2 +2234,8 @@\n-** <dd> ^This option takes three additional arguments that determine the\n-** [lookaside memory allocator] configuration for the [database connection].\n+** <dd> The SQLITE_DBCONFIG_LOOKASIDE option is used to adjust the\n+** configuration of the lookaside memory allocator within a database\n+** connection.\n+** The arguments to the SQLITE_DBCONFIG_LOOKASIDE option are <i>not<\/i>\n+** in the [DBCONFIG arguments|usual format].\n+** The SQLITE_DBCONFIG_LOOKASIDE option takes three arguments, not two,\n+** so that a call to [sqlite3_db_config()] that uses SQLITE_DBCONFIG_LOOKASIDE\n+** should have a total of five parameters.\n@@ -2235,1 +2264,2 @@\n-** [foreign key constraints].  There should be two additional arguments.\n+** [foreign key constraints].  This is the same setting that is\n+** enabled or disabled by the [PRAGMA foreign_keys] statement.\n@@ -2257,1 +2287,1 @@\n-** triggers in the main database schema or in the schemas of ATTACH-ed\n+** triggers in the main database schema or in the schemas of [ATTACH]-ed\n@@ -2263,1 +2293,1 @@\n-** There should be two additional arguments.\n+** There must be two additional arguments.\n@@ -2282,1 +2312,1 @@\n-** There should be two additional arguments.\n+** There must be two additional arguments.\n@@ -2297,1 +2327,1 @@\n-** There should be two additional arguments.\n+** There must be two additional arguments.\n@@ -2311,5 +2341,9 @@\n-** schema.  ^The sole argument is a pointer to a constant UTF8 string\n-** which will become the new schema name in place of \"main\".  ^SQLite\n-** does not make a copy of the new main schema name string, so the application\n-** must ensure that the argument passed into this DBCONFIG option is unchanged\n-** until after the database connection closes.\n+** schema.  This option does not follow the\n+** [DBCONFIG arguments|usual SQLITE_DBCONFIG argument format].\n+** This option takes exactly one additional argument so that the\n+** [sqlite3_db_config()] call has a total of three parameters.  The\n+** extra argument must be a pointer to a constant UTF8 string which\n+** will become the new schema name in place of \"main\".  ^SQLite does\n+** not make a copy of the new main schema name string, so the application\n+** must ensure that the argument passed into SQLITE_DBCONFIG MAINDBNAME\n+** is unchanged until after the database connection closes.\n@@ -2320,8 +2354,11 @@\n-** <dd> Usually, when a database in wal mode is closed or detached from a\n-** database handle, SQLite checks if this will mean that there are now no\n-** connections at all to the database. If so, it performs a checkpoint\n-** operation before closing the connection. This option may be used to\n-** override this behavior. The first parameter passed to this operation\n-** is an integer - positive to disable checkpoints-on-close, or zero (the\n-** default) to enable them, and negative to leave the setting unchanged.\n-** The second parameter is a pointer to an integer\n+** <dd> Usually, when a database in [WAL mode] is closed or detached from a\n+** database handle, SQLite checks if if there are other connections to the\n+** same database, and if there are no other database connection (if the\n+** connection being closed is the last open connection to the database),\n+** then SQLite performs a [checkpoint] before closing the connection and\n+** deletes the WAL file.  The SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE option can\n+** be used to override that behavior. The first argument passed to this\n+** operation (the third parameter to [sqlite3_db_config()]) is an integer\n+** which is positive to disable checkpoints-on-close, or zero (the default)\n+** to enable them, and negative to leave the setting unchanged.\n+** The second argument (the fourth parameter) is a pointer to an integer\n@@ -2488,1 +2525,1 @@\n-** by default.  This option takes two arguments: an integer and a pointer to\n+** by default. <p>This option takes two arguments: an integer and a pointer to\n@@ -2502,1 +2539,1 @@\n-** same as setting [PRAGMA reverse_unordered_selects].  This option takes\n+** same as setting [PRAGMA reverse_unordered_selects]. <p>This option takes\n@@ -2511,0 +2548,50 @@\n+** [[SQLITE_DBCONFIG_ENABLE_ATTACH_CREATE]]\n+** <dt>SQLITE_DBCONFIG_ENABLE_ATTACH_CREATE<\/dt>\n+** <dd>The SQLITE_DBCONFIG_ENABLE_ATTACH_CREATE option enables or disables\n+** the ability of the [ATTACH DATABASE] SQL command to create a new database\n+** file if the database filed named in the ATTACH command does not already\n+** exist.  This ability of ATTACH to create a new database is enabled by\n+** default.  Applications can disable or reenable the ability for ATTACH to\n+** create new database files using this DBCONFIG option.<p>\n+** This option takes two arguments which are an integer and a pointer\n+** to an integer.  The first argument is 1, 0, or -1 to enable, disable, or\n+** leave unchanged the attach-create flag, respectively.  If the second\n+** argument is not NULL, then 0 or 1 is written into the integer that the\n+** second argument points to depending on if the attach-create flag is set\n+** after processing the first argument.\n+** <\/dd>\n+**\n+** [[SQLITE_DBCONFIG_ENABLE_ATTACH_WRITE]]\n+** <dt>SQLITE_DBCONFIG_ENABLE_ATTACH_WRITE<\/dt>\n+** <dd>The SQLITE_DBCONFIG_ENABLE_ATTACH_WRITE option enables or disables the\n+** ability of the [ATTACH DATABASE] SQL command to open a database for writing.\n+** This capability is enabled by default.  Applications can disable or\n+** reenable this capability using the current DBCONFIG option.  If the\n+** the this capability is disabled, the [ATTACH] command will still work,\n+** but the database will be opened read-only.  If this option is disabled,\n+** then the ability to create a new database using [ATTACH] is also disabled,\n+** regardless of the value of the [SQLITE_DBCONFIG_ENABLE_ATTACH_CREATE]\n+** option.<p>\n+** This option takes two arguments which are an integer and a pointer\n+** to an integer.  The first argument is 1, 0, or -1 to enable, disable, or\n+** leave unchanged the ability to ATTACH another database for writing,\n+** respectively.  If the second argument is not NULL, then 0 or 1 is written\n+** into the integer to which the second argument points, depending on whether\n+** the ability to ATTACH a read\/write database is enabled or disabled\n+** after processing the first argument.\n+** <\/dd>\n+**\n+** [[SQLITE_DBCONFIG_ENABLE_COMMENTS]]\n+** <dt>SQLITE_DBCONFIG_ENABLE_COMMENTS<\/dt>\n+** <dd>The SQLITE_DBCONFIG_ENABLE_COMMENTS option enables or disables the\n+** ability to include comments in SQL text.  Comments are enabled by default.\n+** An application can disable or reenable comments in SQL text using this\n+** DBCONFIG option.<p>\n+** This option takes two arguments which are an integer and a pointer\n+** to an integer.  The first argument is 1, 0, or -1 to enable, disable, or\n+** leave unchanged the ability to use comments in SQL text,\n+** respectively.  If the second argument is not NULL, then 0 or 1 is written\n+** into the integer that the second argument points to depending on if\n+** comments are allowed in SQL text after processing the first argument.\n+** <\/dd>\n+**\n@@ -2512,0 +2599,19 @@\n+**\n+** [[DBCONFIG arguments]] <h3>Arguments To SQLITE_DBCONFIG Options<\/h3>\n+**\n+** <p>Most of the SQLITE_DBCONFIG options take two arguments, so that the\n+** overall call to [sqlite3_db_config()] has a total of four parameters.\n+** The first argument (the third parameter to sqlite3_db_config()) is a integer.\n+** The second argument is a pointer to an integer.  If the first argument is 1,\n+** then the option becomes enabled.  If the first integer argument is 0, then the\n+** option is disabled.  If the first argument is -1, then the option setting\n+** is unchanged.  The second argument, the pointer to an integer, may be NULL.\n+** If the second argument is not NULL, then a value of 0 or 1 is written into\n+** the integer to which the second argument points, depending on whether the\n+** setting is disabled or enabled after applying any changes specified by\n+** the first argument.\n+**\n+** <p>While most SQLITE_DBCONFIG options use the argument format\n+** described in the previous paragraph, the [SQLITE_DBCONFIG_MAINDBNAME]\n+** and [SQLITE_DBCONFIG_LOOKASIDE] options are different.  See the\n+** documentation of those exceptional options for details.\n@@ -2533,1 +2639,4 @@\n-#define SQLITE_DBCONFIG_MAX                   1019 \/* Largest DBCONFIG *\/\n+#define SQLITE_DBCONFIG_ENABLE_ATTACH_CREATE  1020 \/* int int* *\/\n+#define SQLITE_DBCONFIG_ENABLE_ATTACH_WRITE   1021 \/* int int* *\/\n+#define SQLITE_DBCONFIG_ENABLE_COMMENTS       1022 \/* int int* *\/\n+#define SQLITE_DBCONFIG_MAX                   1022 \/* Largest DBCONFIG *\/\n@@ -2625,1 +2734,1 @@\n-** and that if the number of rows modified by the most recent INSERT, UPDATE\n+** and that if the number of rows modified by the most recent INSERT, UPDATE,\n@@ -2629,0 +2738,4 @@\n+** For the purposes of this interface, a CREATE TABLE AS SELECT statement\n+** does not count as an INSERT, UPDATE or DELETE statement and hence the rows\n+** added to the new table by the CREATE TABLE AS SELECT statement are not\n+** counted.\n@@ -3308,2 +3421,2 @@\n-** CAPI3REF: Tracing And Profiling Functions\n-** METHOD: sqlite3\n+** CAPI3REF: Deprecated Tracing And Profiling Functions\n+** DEPRECATED\n@@ -3573,2 +3686,2 @@\n-** In other words, the database behaves has if\n-** [sqlite3_extended_result_codes(db,1)] where called on the database\n+** In other words, the database behaves as if\n+** [sqlite3_extended_result_codes(db,1)] were called on the database\n@@ -4188,0 +4301,10 @@\n+**\n+** [[SQLITE_PREPARE_DONT_LOG]] <dt>SQLITE_PREPARE_DONT_LOG<\/dt>\n+** <dd>The SQLITE_PREPARE_DONT_LOG flag prevents SQL compiler\n+** errors from being sent to the error log defined by\n+** [SQLITE_CONFIG_LOG].  This can be used, for example, to do test\n+** compiles to see if some SQL syntax is well-formed, without generating\n+** messages on the global error log when it is not.  If the test compile\n+** fails, the sqlite3_prepare_v3() call returns the same error indications\n+** with or without this flag; it just omits the call to [sqlite3_log()] that\n+** logs the error.\n@@ -4193,0 +4316,1 @@\n+#define SQLITE_PREPARE_DONT_LOG                0x10\n@@ -4225,2 +4349,4 @@\n-** first zero terminator. ^If nByte is positive, then it is the\n-** number of bytes read from zSql.  ^If nByte is zero, then no prepared\n+** first zero terminator. ^If nByte is positive, then it is the maximum\n+** number of bytes read from zSql.  When nByte is positive, zSql is read\n+** up to the first zero terminator or until the nByte bytes have been read,\n+** whichever comes first.  ^If nByte is zero, then no prepared\n@@ -4232,0 +4358,2 @@\n+** Note that nByte measure the length of the input in bytes, not\n+** characters, even for the UTF-16 interfaces.\n@@ -5602,1 +5730,1 @@\n-** SQL functions that invokes [sqlite3_value_subtype()] should have this\n+** All SQL functions that invoke [sqlite3_value_subtype()] should have this\n@@ -5618,0 +5746,9 @@\n+**\n+** [[SQLITE_SELFORDER1]] <dt>SQLITE_SELFORDER1<\/dt><dd>\n+** The SQLITE_SELFORDER1 flag indicates that the function is an aggregate\n+** that internally orders the values provided to the first argument.  The\n+** ordered-set aggregate SQL notation with a single ORDER BY term can be\n+** used to invoke this function.  If the ordered-set aggregate notation is\n+** used on a function that lacks this flag, then an error is raised. Note\n+** that the ordered-set aggregate syntax is only available if SQLite is\n+** built using the -DSQLITE_ENABLE_ORDERED_SET_AGGREGATES compile-time option.\n@@ -5626,0 +5763,1 @@\n+#define SQLITE_SELFORDER1       0x002000000\n@@ -5823,1 +5961,1 @@\n-** Every [application-defined SQL function] that invoke this interface\n+** Every [application-defined SQL function] that invokes this interface\n@@ -6890,0 +7028,6 @@\n+** Whether the update hook is invoked before or after the\n+** corresponding change is currently unspecified and may differ\n+** depending on the type of change. Do not rely on the order of the\n+** hook call with regards to the final result of the operation which\n+** triggers the hook.\n+**\n@@ -7424,3 +7568,5 @@\n-** mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag -\n-** SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite\n-** assumes that the strategy may visit at most one row.\n+** mask of SQLITE_INDEX_SCAN_* flags. One such flag is\n+** [SQLITE_INDEX_SCAN_HEX], which if set causes the [EXPLAIN QUERY PLAN]\n+** output to show the idxNum has hex instead of as decimal.  Another flag is\n+** SQLITE_INDEX_SCAN_UNIQUE, which if set indicates that the query plan will\n+** return at most one row.\n@@ -7490,1 +7636,3 @@\n-#define SQLITE_INDEX_SCAN_UNIQUE      1     \/* Scan visits at most 1 row *\/\n+#define SQLITE_INDEX_SCAN_UNIQUE 0x00000001 \/* Scan visits at most 1 row *\/\n+#define SQLITE_INDEX_SCAN_HEX    0x00000002 \/* Display idxNum as hex *\/\n+                                            \/* in EXPLAIN QUERY PLAN *\/\n@@ -8327,0 +8475,1 @@\n+#define SQLITE_TESTCTRL_GETOPT                  16\n@@ -8346,1 +8495,1 @@\n-#define SQLITE_TESTCTRL_USELONGDOUBLE           34\n+#define SQLITE_TESTCTRL_USELONGDOUBLE           34  \/* NOT USED *\/\n@@ -8360,1 +8509,1 @@\n-** The sqlite3_keyword_name(N,Z,L) interface finds the N-th keyword and\n+** The sqlite3_keyword_name(N,Z,L) interface finds the 0-based N-th keyword and\n@@ -9322,0 +9471,10 @@\n+**\n+** <b>Alternatives To Using The Backup API<\/b>\n+**\n+** Other techniques for safely creating a consistent backup of an SQLite\n+** database include:\n+**\n+** <ul>\n+** <li> The [VACUUM INTO] command.\n+** <li> The [sqlite3_rsync] utility program.\n+** <\/ul>\n@@ -9939,8 +10098,7 @@\n-** order, as long as rows with the same values in all \"aOrderBy\" columns\n-** are adjacent.)^  ^(Furthermore, only a single row for each particular\n-** combination of values in the columns identified by the \"aOrderBy\" field\n-** needs to be returned.)^  ^It is always ok for two or more rows with the same\n-** values in all \"aOrderBy\" columns to be returned, as long as all such rows\n-** are adjacent.  ^The virtual table may, if it chooses, omit extra rows\n-** that have the same value for all columns identified by \"aOrderBy\".\n-** ^However omitting the extra rows is optional.\n+** order, as long as rows with the same values in all columns identified\n+** by \"aOrderBy\" are adjacent.)^  ^(Furthermore, when two or more rows\n+** contain the same values for all columns identified by \"colUsed\", all but\n+** one such row may optionally be omitted from the result.)^\n+** The virtual table is not required to omit rows that are duplicates\n+** over the \"colUsed\" columns, but if the virtual table can do that without\n+** too much extra effort, it could potentially help the query to run faster.\n@@ -9949,5 +10107,10 @@\n-** ^(If the sqlite3_vtab_distinct() interface returns 3, that means\n-** that the query planner needs only distinct rows but it does need the\n-** rows to be sorted.)^ ^The virtual table implementation is free to omit\n-** rows that are identical in all aOrderBy columns, if it wants to, but\n-** it is not required to omit any rows.  This mode is used for queries\n+** ^(If the sqlite3_vtab_distinct() interface returns 3, that means the\n+** virtual table must return rows in the order defined by \"aOrderBy\" as\n+** if the sqlite3_vtab_distinct() interface had returned 0.  However if\n+** two or more rows in the result have the same values for all columns\n+** identified by \"colUsed\", then all but one such row may optionally be\n+** omitted.)^  Like when the return value is 2, the virtual table\n+** is not required to omit rows that are duplicates over the \"colUsed\"\n+** columns, but if the virtual table can do that without\n+** too much extra effort, it could potentially help the query to run faster.\n+** This mode is used for queries\n@@ -9957,0 +10120,17 @@\n+** <p>The following table summarizes the conditions under which the\n+** virtual table is allowed to set the \"orderByConsumed\" flag based on\n+** the value returned by sqlite3_vtab_distinct().  This table is a\n+** restatement of the previous four paragraphs:\n+**\n+** <table border=1 cellspacing=0 cellpadding=10 width=\"90%\">\n+** <tr>\n+** <td valign=\"top\">sqlite3_vtab_distinct() return value\n+** <td valign=\"top\">Rows are returned in aOrderBy order\n+** <td valign=\"top\">Rows with the same value in all aOrderBy columns are adjacent\n+** <td valign=\"top\">Duplicates over all colUsed columns may be omitted\n+** <tr><td>0<td>yes<td>yes<td>no\n+** <tr><td>1<td>no<td>yes<td>no\n+** <tr><td>2<td>no<td>yes<td>yes\n+** <tr><td>3<td>yes<td>yes<td>yes\n+** <\/table>\n+**\n@@ -10500,0 +10680,8 @@\n+** If a read-transaction is opened by this function, then it is guaranteed\n+** that the returned snapshot object may not be invalidated by a database\n+** writer or checkpointer until after the read-transaction is closed. This\n+** is not guaranteed if a read-transaction is already open when this\n+** function is called. In that case, any subsequent write or checkpoint\n+** operation on the database may invalidate the returned snapshot handle,\n+** even while the read-transaction remains open.\n+**\n@@ -10657,2 +10845,3 @@\n-** The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory\n-** that is a serialization of the S database on [database connection] D.\n+** The sqlite3_serialize(D,S,P,F) interface returns a pointer to\n+** memory that is a serialization of the S database on\n+** [database connection] D.  If S is a NULL pointer, the main database is used.\n@@ -10808,2 +10997,0 @@\n-# undef SQLITE_OMIT_WAL\n-# define SQLITE_OMIT_WAL 1\/* because it requires shared memory APIs *\/\n@@ -10821,1 +11008,1 @@\n-#endif \/* SQLITE3_H *\/\n+\/* #endif for SQLITE3_H will be added by mksqlite3.tcl *\/\n@@ -12001,0 +12188,24 @@\n+\/*\n+** CAPI3REF: Add A Single Change To A Changegroup\n+** METHOD: sqlite3_changegroup\n+**\n+** This function adds the single change currently indicated by the iterator\n+** passed as the second argument to the changegroup object. The rules for\n+** adding the change are just as described for [sqlite3changegroup_add()].\n+**\n+** If the change is successfully added to the changegroup, SQLITE_OK is\n+** returned. Otherwise, an SQLite error code is returned.\n+**\n+** The iterator must point to a valid entry when this function is called.\n+** If it does not, SQLITE_ERROR is returned and no change is added to the\n+** changegroup. Additionally, the iterator must not have been opened with\n+** the SQLITE_CHANGESETAPPLY_INVERT flag. In this case SQLITE_ERROR is also\n+** returned.\n+*\/\n+SQLITE_API int sqlite3changegroup_add_change(\n+  sqlite3_changegroup*,\n+  sqlite3_changeset_iter*\n+);\n+\n+\n+\n@@ -12805,2 +13016,2 @@\n-**   Return a copy of the context pointer the extension function was\n-**   registered with.\n+**   Return a copy of the pUserData pointer passed to the xCreateFunction()\n+**   API when the extension function was registered.\n@@ -12988,0 +13199,4 @@\n+**   In all cases, matches are visited in (column ASC, offset ASC) order.\n+**   i.e. all those in column 0, sorted by offset, followed by those in\n+**   column 1, etc.\n+**\n@@ -13044,3 +13259,1 @@\n-**   bytes. This API is not available if the specified token matches a\n-**   prefix query term. In that case both output variables are always set\n-**   to 0.\n+**   bytes.\n@@ -13052,0 +13265,17 @@\n+**   This API may be slow in some cases if the token identified by parameters\n+**   iIdx and iToken matched a prefix token in the query. In most cases, the\n+**   first call to this API for each prefix token in the query is forced\n+**   to scan the portion of the full-text index that matches the prefix\n+**   token to collect the extra data required by this API. If the prefix\n+**   token matches a large number of token instances in the document set,\n+**   this may be a performance problem.\n+**\n+**   If the user knows in advance that a query may use this API for a\n+**   prefix token, FTS5 may be configured to collect all required data as part\n+**   of the initial querying of the full-text index, avoiding the second scan\n+**   entirely. This also causes prefix queries that do not use this API to\n+**   run more slowly and use more memory. FTS5 may be configured in this way\n+**   either on a per-table basis using the [FTS5 insttoken | 'insttoken']\n+**   option, or on a per-query basis using the\n+**   [fts5_insttoken | fts5_insttoken()] user function.\n+**\n@@ -13054,0 +13284,23 @@\n+**\n+** xColumnLocale(pFts5, iIdx, pzLocale, pnLocale)\n+**   If parameter iCol is less than zero, or greater than or equal to the\n+**   number of columns in the table, SQLITE_RANGE is returned.\n+**\n+**   Otherwise, this function attempts to retrieve the locale associated\n+**   with column iCol of the current row. Usually, there is no associated\n+**   locale, and output parameters (*pzLocale) and (*pnLocale) are set\n+**   to NULL and 0, respectively. However, if the fts5_locale() function\n+**   was used to associate a locale with the value when it was inserted\n+**   into the fts5 table, then (*pzLocale) is set to point to a nul-terminated\n+**   buffer containing the name of the locale in utf-8 encoding. (*pnLocale)\n+**   is set to the size in bytes of the buffer, not including the\n+**   nul-terminator.\n+**\n+**   If successful, SQLITE_OK is returned. Or, if an error occurs, an\n+**   SQLite error code is returned. The final value of the output parameters\n+**   is undefined in this case.\n+**\n+** xTokenize_v2:\n+**   Tokenize text using the tokenizer belonging to the FTS5 table. This\n+**   API is the same as the xTokenize() API, except that it allows a tokenizer\n+**   locale to be specified.\n@@ -13056,1 +13309,1 @@\n-  int iVersion;                   \/* Currently always set to 3 *\/\n+  int iVersion;                   \/* Currently always set to 4 *\/\n@@ -13098,0 +13351,9 @@\n+\n+  \/* Below this point are iVersion>=4 only *\/\n+  int (*xColumnLocale)(Fts5Context*, int iCol, const char **pz, int *pn);\n+  int (*xTokenize_v2)(Fts5Context*,\n+    const char *pText, int nText,      \/* Text to tokenize *\/\n+    const char *pLocale, int nLocale,  \/* Locale to pass to tokenizer *\/\n+    void *pCtx,                        \/* Context passed to xToken() *\/\n+    int (*xToken)(void*, int, const char*, int, int, int)       \/* Callback *\/\n+  );\n@@ -13118,1 +13380,1 @@\n-**   pointer provided by the application when the fts5_tokenizer object\n+**   pointer provided by the application when the fts5_tokenizer_v2 object\n@@ -13142,1 +13404,1 @@\n-**   The second argument indicates the reason that FTS5 is requesting\n+**   The third argument indicates the reason that FTS5 is requesting\n@@ -13166,0 +13428,7 @@\n+**   The sixth and seventh arguments passed to xTokenize() - pLocale and\n+**   nLocale - are a pointer to a buffer containing the locale to use for\n+**   tokenization (e.g. \"en_US\") and its size in bytes, respectively. The\n+**   pLocale buffer is not nul-terminated. pLocale may be passed NULL (in\n+**   which case nLocale is always 0) to indicate that the tokenizer should\n+**   use its default locale.\n+**\n@@ -13189,0 +13458,24 @@\n+**   If the tokenizer is registered using an fts5_tokenizer_v2 object,\n+**   then the xTokenize() method has two additional arguments - pLocale\n+**   and nLocale. These specify the locale that the tokenizer should use\n+**   for the current request. If pLocale and nLocale are both 0, then the\n+**   tokenizer should use its default locale. Otherwise, pLocale points to\n+**   an nLocale byte buffer containing the name of the locale to use as utf-8\n+**   text. pLocale is not nul-terminated.\n+**\n+** FTS5_TOKENIZER\n+**\n+** There is also an fts5_tokenizer object. This is an older, deprecated,\n+** version of fts5_tokenizer_v2. It is similar except that:\n+**\n+**  <ul>\n+**    <li> There is no \"iVersion\" field, and\n+**    <li> The xTokenize() method does not take a locale argument.\n+**  <\/ul>\n+**\n+** Legacy fts5_tokenizer tokenizers must be registered using the\n+** legacy xCreateTokenizer() function, instead of xCreateTokenizer_v2().\n+**\n+** Tokenizer implementations registered using either API may be retrieved\n+** using both xFindTokenizer() and xFindTokenizer_v2().\n+**\n@@ -13297,0 +13590,27 @@\n+typedef struct fts5_tokenizer_v2 fts5_tokenizer_v2;\n+struct fts5_tokenizer_v2 {\n+  int iVersion;             \/* Currently always 2 *\/\n+\n+  int (*xCreate)(void*, const char **azArg, int nArg, Fts5Tokenizer **ppOut);\n+  void (*xDelete)(Fts5Tokenizer*);\n+  int (*xTokenize)(Fts5Tokenizer*,\n+      void *pCtx,\n+      int flags,            \/* Mask of FTS5_TOKENIZE_* flags *\/\n+      const char *pText, int nText,\n+      const char *pLocale, int nLocale,\n+      int (*xToken)(\n+        void *pCtx,         \/* Copy of 2nd argument to xTokenize() *\/\n+        int tflags,         \/* Mask of FTS5_TOKEN_* flags *\/\n+        const char *pToken, \/* Pointer to buffer containing token *\/\n+        int nToken,         \/* Size of token in bytes *\/\n+        int iStart,         \/* Byte offset of token within input text *\/\n+        int iEnd            \/* Byte offset of end of token within input text *\/\n+      )\n+  );\n+};\n+\n+\/*\n+** New code should use the fts5_tokenizer_v2 type to define tokenizer\n+** implementations. The following type is included for legacy applications\n+** that still use it.\n+*\/\n@@ -13316,0 +13636,1 @@\n+\n@@ -13335,1 +13656,1 @@\n-  int iVersion;                   \/* Currently always set to 2 *\/\n+  int iVersion;                   \/* Currently always set to 3 *\/\n@@ -13362,0 +13683,19 @@\n+\n+  \/* APIs below this point are only available if iVersion>=3 *\/\n+\n+  \/* Create a new tokenizer *\/\n+  int (*xCreateTokenizer_v2)(\n+    fts5_api *pApi,\n+    const char *zName,\n+    void *pUserData,\n+    fts5_tokenizer_v2 *pTokenizer,\n+    void (*xDestroy)(void*)\n+  );\n+\n+  \/* Find an existing tokenizer *\/\n+  int (*xFindTokenizer_v2)(\n+    fts5_api *pApi,\n+    const char *zName,\n+    void **ppUserData,\n+    fts5_tokenizer_v2 **ppTokenizer\n+  );\n@@ -13375,0 +13715,1 @@\n+#endif \/* SQLITE3_H *\/\n","filename":"modules\/javafx.web\/src\/main\/native\/Source\/ThirdParty\/sqlite\/sqlite3.h","additions":414,"deletions":73,"binary":false,"changes":487,"status":"modified"}]}