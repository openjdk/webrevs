{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -469,1 +469,2 @@\n-        (context->transform.xx > 0) && (context->transform.yy > 0))\n+        (context->transform.xx > 0) && (context->transform.yy > 0) &&\n+        (context->transform.xx == context->transform.yy))\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/freetypeScaler.c","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Font;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.imageio.ImageIO;\n+\n+import static java.awt.GraphicsEnvironment.getLocalGraphicsEnvironment;\n+import static java.awt.RenderingHints.KEY_TEXT_ANTIALIASING;\n+import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_LCD_HRGB;\n+import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_OFF;\n+import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON;\n+import static java.awt.image.BufferedImage.TYPE_3BYTE_BGR;\n+\n+\/*\n+ * @test\n+ * @bug 8312555\n+ * @summary Verifies that hieroglyphs are stretched by AffineTransform.scale(2, 1)\n+ * @run main StretchedFontTest\n+ *\/\n+public final class StretchedFontTest {\n+    private static final String TEXT = \"\\u6F22\";\n+    private static final int FONT_SIZE = 20;\n+\n+    private static final Color BACKGROUND = Color.WHITE;\n+    private static final Color[] FOREGROUNDS = {\n+            new Color(0xFF000000, true),\n+            new Color(0x7F000000, true)\n+    };\n+\n+    private static final AffineTransform STRETCH_TRANSFORM =\n+            AffineTransform.getScaleInstance(2.0, 1.0);\n+\n+    public static void main(String[] args) {\n+        List<String> errors =\n+                Arrays.stream(getLocalGraphicsEnvironment()\n+                              .getAvailableFontFamilyNames(Locale.ENGLISH))\n+                      .map(family -> new Font(family, Font.PLAIN, FONT_SIZE))\n+                      .filter(font -> font.canDisplay(TEXT.codePointAt(0)))\n+                      .map(font -> font.deriveFont(STRETCH_TRANSFORM))\n+                      .flatMap(StretchedFontTest::testFont)\n+                      .filter(Objects::nonNull)\n+                      .collect(Collectors.toList());\n+\n+        if (!errors.isEmpty()) {\n+            errors.forEach(System.err::println);\n+            throw new Error(errors.size() + \" failure(s) found;\"\n+                            + \" the first one: \" + errors.get(0));\n+        }\n+    }\n+\n+    \/**\n+     * Tests the font with a set of text antialiasing hints.\n+     *\n+     * @param font the font to test\n+     * @return a stream of test results\n+     * @see #testFont(Font, Object)\n+     *\/\n+    private static Stream<String> testFont(final Font font) {\n+        return Stream.of(VALUE_TEXT_ANTIALIAS_OFF,\n+                         VALUE_TEXT_ANTIALIAS_ON,\n+                         VALUE_TEXT_ANTIALIAS_LCD_HRGB)\n+                     .flatMap(hint -> testFont(font, hint));\n+    }\n+\n+    \/**\n+     * Tests the font with the specified text antialiasing hint and a set of\n+     * foreground colors.\n+     *\n+     * @param font the font to test\n+     * @param hint the text antialiasing hint to test\n+     * @return a stream of test results\n+     * @see #testFont(Font, Object, Color)\n+     *\/\n+    private static Stream<String> testFont(final Font font, final Object hint) {\n+        return Stream.of(FOREGROUNDS)\n+                     .map(foreground -> testFont(font, hint, foreground));\n+    }\n+\n+    \/**\n+     * Tests the font with the specified text antialiasing hint and\n+     * foreground color. In case of failure, it saves the rendered\n+     * image to a file.\n+     *\n+     * @param font the font to test\n+     * @param hint the text antialiasing hint to test\n+     * @param foreground the foreground color to use\n+     * @return {@code null} if the text rendered correctly; otherwise,\n+     *         a {@code String} with the font family name, the value of\n+     *         the rendering hint and the color in hex\n+     *\/\n+    private static String testFont(final Font font,\n+                                   final Object hint,\n+                                   final Color foreground) {\n+        final Dimension size = getTextSize(font);\n+        final BufferedImage image =\n+                new BufferedImage(size.width, size.height, TYPE_3BYTE_BGR);\n+\n+        final Graphics2D g2d = image.createGraphics();\n+        try {\n+            g2d.setColor(BACKGROUND);\n+            g2d.fillRect(0, 0, size.width, size.height);\n+\n+            g2d.setRenderingHint(KEY_TEXT_ANTIALIASING, hint);\n+            g2d.setColor(foreground);\n+            g2d.setFont(font);\n+            g2d.drawString(TEXT, 0, g2d.getFontMetrics(font).getAscent());\n+        } finally {\n+            g2d.dispose();\n+        }\n+\n+        if (verifyImage(image)) {\n+            return null;\n+        }\n+        String fontName = font.getFontName(Locale.ENGLISH);\n+        String hintValue = getHintString(hint);\n+        String hexColor = String.format(\"0x%08x\", foreground.getRGB());\n+        saveImage(image, fontName + \"-\" + hintValue + \"-\" + hexColor);\n+        return \"Font: \" + fontName + \", Hint: \" + hintValue + \", Color: \" + hexColor;\n+    }\n+\n+    \/**\n+     * Verifies the rendered image of the hieroglyph. The hieroglyph\n+     * should be stretched across the entire width of the image.\n+     * If the right half of the image contains only pixels of the background\n+     * color, the hieroglyph isn't stretched correctly\n+     * &mdash; it's a failure.\n+     *\n+     * @param image the image to verify\n+     * @return {@code true} if the hieroglyph is stretched correctly; or\n+     *         {@code false} if right half of the image contains only\n+     *         background-colored pixels, which means the hieroglyph isn't\n+     *         stretched.\n+     *\/\n+    private static boolean verifyImage(final BufferedImage image) {\n+        final int width = image.getWidth();\n+        final int height = image.getHeight();\n+        for (int x = width \/ 2; x < width; x++) {\n+            for (int y = 0; y < height; y++) {\n+                if (image.getRGB(x, y) != BACKGROUND.getRGB()) {\n+                    \/\/ Any other color but background means the glyph is stretched\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        \/\/ The right side of the image is filled with the background color only,\n+        \/\/ the glyph isn't stretched.\n+        return false;\n+    }\n+\n+    private static String getHintString(final Object hint) {\n+        if (hint == VALUE_TEXT_ANTIALIAS_OFF) {\n+            return \"off\";\n+        } else if (hint == VALUE_TEXT_ANTIALIAS_ON) {\n+            return \"on\";\n+        } else if (hint == VALUE_TEXT_ANTIALIAS_LCD_HRGB) {\n+            return \"lcd\";\n+        } else {\n+            throw new IllegalArgumentException(\"Unexpected hint: \" + hint);\n+        }\n+    }\n+\n+    private static final BufferedImage dummyImage =\n+            new BufferedImage(5, 5, TYPE_3BYTE_BGR);\n+\n+    private static Dimension getTextSize(final Font font) {\n+        final Graphics g = dummyImage.getGraphics();\n+        try {\n+            return g.getFontMetrics(font)\n+                    .getStringBounds(TEXT, g)\n+                    .getBounds()\n+                    .getSize();\n+        } finally {\n+            g.dispose();\n+        }\n+    }\n+\n+    private static void saveImage(final BufferedImage image,\n+                                  final String fileName) {\n+        try {\n+            ImageIO.write(image,\n+                          \"png\",\n+                          new File(fileName + \".png\"));\n+        } catch (IOException ignored) {\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/font\/FontScaling\/StretchedFontTest.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"}]}