{"files":[{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -86,1 +86,1 @@\n-void C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n+void C1_MacroAssembler::lock_object(Register Rmark, Register Roop, Register Rbox, Label& slow_case) {\n@@ -88,1 +88,0 @@\n-  assert_different_registers(hdr, obj, disp_hdr);\n@@ -90,1 +89,5 @@\n-  verify_oop(obj, FILE_AND_LINE);\n+  const Register tmp   = Z_R1_scratch;\n+\n+  assert_different_registers(Rmark, Roop, Rbox, tmp);\n+\n+  verify_oop(Roop, FILE_AND_LINE);\n@@ -93,1 +96,1 @@\n-  z_lg(hdr, Address(obj, hdr_offset));\n+  z_lg(Rmark, Address(Roop, hdr_offset));\n@@ -96,1 +99,1 @@\n-  z_stg(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n+  z_stg(Roop, Address(Rbox, BasicObjectLock::obj_offset()));\n@@ -99,2 +102,2 @@\n-    load_klass(Z_R1_scratch, obj);\n-    testbit(Address(Z_R1_scratch, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    load_klass(tmp, Roop);\n+    testbit(Address(tmp, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n@@ -107,1 +110,1 @@\n-    Unimplemented();\n+    fast_lock(Roop, Rmark, tmp, slow_case);\n@@ -111,1 +114,1 @@\n-    z_oill(hdr, markWord::unlocked_value);\n+    z_oill(Rmark, markWord::unlocked_value);\n@@ -113,1 +116,1 @@\n-    z_stg(hdr, Address(disp_hdr, (intptr_t) 0));\n+    z_stg(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n@@ -117,1 +120,1 @@\n-    z_csg(hdr, disp_hdr, hdr_offset, obj);\n+    z_csg(Rmark, Rbox, hdr_offset, Roop);\n@@ -120,1 +123,1 @@\n-    \/\/ If the object header was not the same, it is now in the hdr register.\n+    \/\/ If the object header was not the same, it is now in the Rmark register.\n@@ -123,3 +126,3 @@\n-    \/\/ 1) (hdr & markWord::lock_mask_in_place) == 0\n-    \/\/ 2) rsp <= hdr\n-    \/\/ 3) hdr <= rsp + page_size\n+    \/\/ 1) (Rmark & markWord::lock_mask_in_place) == 0\n+    \/\/ 2) rsp <= Rmark\n+    \/\/ 3) Rmark <= rsp + page_size\n@@ -129,1 +132,1 @@\n-    \/\/ (hdr - Z_SP) & (~(page_size-1) | markWord::lock_mask_in_place)\n+    \/\/ (Rmark - Z_SP) & (~(page_size-1) | markWord::lock_mask_in_place)\n@@ -133,1 +136,1 @@\n-    z_sgr(hdr, Z_SP);\n+    z_sgr(Rmark, Z_SP);\n@@ -136,1 +139,1 @@\n-    z_ngr(hdr, Z_R0_scratch); \/\/ AND sets CC (result eq\/ne 0).\n+    z_ngr(Rmark, Z_R0_scratch); \/\/ AND sets CC (result eq\/ne 0).\n@@ -138,2 +141,2 @@\n-    \/\/ location (null in the displaced hdr location indicates recursive locking).\n-    z_stg(hdr, Address(disp_hdr, (intptr_t) 0));\n+    \/\/ location (null in the displaced Rmark location indicates recursive locking).\n+    z_stg(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n@@ -147,2 +150,1 @@\n-void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n-  const int aligned_mask = BytesPerWord -1;\n+void C1_MacroAssembler::unlock_object(Register Rmark, Register Roop, Register Rbox, Label& slow_case) {\n@@ -150,1 +152,3 @@\n-  assert_different_registers(hdr, obj, disp_hdr);\n+\n+  assert_different_registers(Rmark, Roop, Rbox);\n+\n@@ -155,2 +159,2 @@\n-    z_ltg(hdr, Address(disp_hdr, (intptr_t) 0));\n-    \/\/ If the loaded hdr is null we had recursive locking, and we are done.\n+    z_ltg(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n+    \/\/ If the loaded Rmark is null we had recursive locking, and we are done.\n@@ -161,2 +165,2 @@\n-  z_lg(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n-  verify_oop(obj, FILE_AND_LINE);\n+  z_lg(Roop, Address(Rbox, BasicObjectLock::obj_offset()));\n+  verify_oop(Roop, FILE_AND_LINE);\n@@ -165,2 +169,7 @@\n-    Unimplemented();\n-  } else {\n+    const Register tmp = Z_R1_scratch;\n+    z_lg(Rmark, Address(Roop, hdr_offset));\n+    z_lgr(tmp, Rmark);\n+    z_nill(tmp, markWord::monitor_value);\n+    z_brnz(slow_case);\n+    fast_unlock(Roop, Rmark, tmp, slow_case);\n+  } else if (LockingMode == LM_LEGACY) {\n@@ -170,1 +179,1 @@\n-    z_csg(disp_hdr, hdr, hdr_offset, obj);\n+    z_csg(Rbox, Rmark, hdr_offset, Roop);\n@@ -174,1 +183,0 @@\n-    \/\/ done\n@@ -176,0 +184,1 @@\n+  \/\/ done\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":41,"deletions":32,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -44,5 +44,5 @@\n-  \/\/ hdr     : Used to hold locked markWord to be CASed into obj, contents destroyed.\n-  \/\/ obj     : Must point to the object to lock, contents preserved.\n-  \/\/ disp_hdr: Must point to the displaced header location, contents preserved.\n-  \/\/ Returns code offset at which to add null check debug information.\n-  void lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case);\n+  \/\/ Rmark        : Used to hold locked markWord to be CASed into obj, contents destroyed.\n+  \/\/ Roop         : Must point to the object to lock, contents preserved.\n+  \/\/ Rbox         : Must point to the displaced header location, contents preserved.\n+  \/\/ Z_R1_scratch : Used as temp and will be killed\n+  void lock_object(Register Rmark, Register Roop, Register Rbox, Label& slow_case);\n@@ -51,4 +51,5 @@\n-  \/\/ hdr     : Used to hold original markWord to be CASed back into obj, contents destroyed.\n-  \/\/ obj     : Must point to the object to lock, contents preserved.\n-  \/\/ disp_hdr: Must point to the displaced header location, contents destroyed.\n-  void unlock_object(Register hdr, Register obj, Register lock, Label& slow_case);\n+  \/\/ Rmark        : Used to hold original markWord to be CASed back into obj, contents destroyed.\n+  \/\/ Roop         : Must point to the object to lock, contents preserved.\n+  \/\/ Rbox         : Must point to the displaced header location, contents destroyed.\n+  \/\/ Z_R1_scratch : Used as temp and will be killed\n+  void unlock_object(Register Rmark, Register Roop, Register Rbox, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.hpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -980,1 +980,1 @@\n-\/\/   monitor - Address of the BasicObjectLock to be used for locking,\n+\/\/   monitor (Z_R10) - Address of the BasicObjectLock to be used for locking,\n@@ -982,1 +982,2 @@\n-\/\/   object  - Address of the object to be locked.\n+\/\/   object  (Z_R11, Z_R2) - Address of the object to be locked.\n+\/\/  templateTable (monitorenter) is using Z_R2 for object\n@@ -990,1 +991,1 @@\n-  \/\/ template code:\n+  \/\/ template code: (for LM_LEGACY)\n@@ -1004,1 +1005,3 @@\n-  const Register displaced_header = Z_ARG5;\n+  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n+\n+  const Register header           = Z_ARG5;\n@@ -1007,0 +1010,1 @@\n+  const Register tmp              = Z_R1_scratch;\n@@ -1008,2 +1012,1 @@\n-  NearLabel done;\n-  NearLabel slow_case;\n+  NearLabel done, slow_case;\n@@ -1011,1 +1014,1 @@\n-  \/\/ markWord displaced_header = obj->mark().set_unlocked();\n+  \/\/ markWord header = obj->mark().set_unlocked();\n@@ -1013,2 +1016,2 @@\n-  \/\/ Load markWord from object into displaced_header.\n-  z_lg(displaced_header, oopDesc::mark_offset_in_bytes(), object);\n+  \/\/ Load markWord from object into header.\n+  z_lg(header, hdr_offset, object);\n@@ -1017,2 +1020,2 @@\n-    load_klass(Z_R1_scratch, object);\n-    testbit(Address(Z_R1_scratch, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    load_klass(tmp, object);\n+    testbit(Address(tmp, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n@@ -1022,2 +1025,3 @@\n-  \/\/ Set displaced_header to be (markWord of object | UNLOCK_VALUE).\n-  z_oill(displaced_header, markWord::unlocked_value);\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    fast_lock(object, \/* mark word *\/ header, tmp, slow_case);\n+  } else if (LockingMode == LM_LEGACY) {\n@@ -1025,1 +1029,3 @@\n-  \/\/ monitor->lock()->set_displaced_header(displaced_header);\n+    \/\/ Set header to be (markWord of object | UNLOCK_VALUE).\n+    \/\/ This will not change anything if it was unlocked before.\n+    z_oill(header, markWord::unlocked_value);\n@@ -1027,3 +1033,3 @@\n-  \/\/ Initialize the box (Must happen before we update the object mark!).\n-  z_stg(displaced_header, in_bytes(BasicObjectLock::lock_offset()) +\n-                          BasicLock::displaced_header_offset_in_bytes(), monitor);\n+    \/\/ monitor->lock()->set_displaced_header(displaced_header);\n+    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n+    const int mark_offset = lock_offset + BasicLock::displaced_header_offset_in_bytes();\n@@ -1031,1 +1037,2 @@\n-  \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n+    \/\/ Initialize the box (Must happen before we update the object mark!).\n+    z_stg(header, mark_offset, monitor);\n@@ -1033,2 +1040,1 @@\n-  \/\/ Store stack address of the BasicObjectLock (this is monitor) into object.\n-  add2reg(object_mark_addr, oopDesc::mark_offset_in_bytes(), object);\n+    \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n@@ -1036,2 +1042,2 @@\n-  z_csg(displaced_header, monitor, 0, object_mark_addr);\n-  assert(current_header==displaced_header, \"must be same register\"); \/\/ Identified two registers from z\/Architecture.\n+    \/\/ not necessary, use offset in instruction directly.\n+    \/\/ add2reg(object_mark_addr, hdr_offset, object);\n@@ -1039,1 +1045,4 @@\n-  z_bre(done);\n+    \/\/ Store stack address of the BasicObjectLock (this is monitor) into object.\n+    z_csg(header, monitor, hdr_offset, object);\n+    assert(current_header == header,\n+           \"must be same register\"); \/\/ Identified two registers from z\/Architecture.\n@@ -1041,3 +1050,1 @@\n-  \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-  \/\/   \/\/ Simple recursive case.\n-  \/\/   monitor->lock()->set_displaced_header(nullptr);\n+    z_bre(done);\n@@ -1045,1 +1052,3 @@\n-  \/\/ We did not see an unlocked object so try the fast recursive case.\n+    \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n+    \/\/   \/\/ Simple recursive case.\n+    \/\/   monitor->lock()->set_displaced_header(nullptr);\n@@ -1047,3 +1056,1 @@\n-  \/\/ Check if owner is self by comparing the value in the markWord of object\n-  \/\/ (current_header) with the stack pointer.\n-  z_sgr(current_header, Z_SP);\n+    \/\/ We did not see an unlocked object so try the fast recursive case.\n@@ -1051,1 +1058,3 @@\n-  assert(os::vm_page_size() > 0xfff, \"page size too small - change the constant\");\n+    \/\/ Check if owner is self by comparing the value in the markWord of object\n+    \/\/ (current_header) with the stack pointer.\n+    z_sgr(current_header, Z_SP);\n@@ -1053,4 +1062,1 @@\n-  \/\/ The prior sequence \"LGR, NGR, LTGR\" can be done better\n-  \/\/ (Z_R1 is temp and not used after here).\n-  load_const_optimized(Z_R0, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n-  z_ngr(Z_R0, current_header); \/\/ AND sets CC (result eq\/ne 0)\n+    assert(os::vm_page_size() > 0xfff, \"page size too small - change the constant\");\n@@ -1058,7 +1064,4 @@\n-  \/\/ If condition is true we are done and hence we can store 0 in the displaced\n-  \/\/ header indicating it is a recursive lock and be done.\n-  z_brne(slow_case);\n-  z_release();  \/\/ Membar unnecessary on zarch AND because the above csg does a sync before and after.\n-  z_stg(Z_R0\/*==0!*\/, in_bytes(BasicObjectLock::lock_offset()) +\n-                      BasicLock::displaced_header_offset_in_bytes(), monitor);\n-  z_bru(done);\n+    \/\/ The prior sequence \"LGR, NGR, LTGR\" can be done better\n+    \/\/ (Z_R1 is temp and not used after here).\n+    load_const_optimized(Z_R0, (~(os::vm_page_size() - 1) | markWord::lock_mask_in_place));\n+    z_ngr(Z_R0, current_header); \/\/ AND sets CC (result eq\/ne 0)\n@@ -1066,0 +1069,7 @@\n+    \/\/ If condition is true we are done and hence we can store 0 in the displaced\n+    \/\/ header indicating it is a recursive lock and be done.\n+    z_brne(slow_case);\n+    z_release();  \/\/ Member unnecessary on zarch AND because the above csg does a sync before and after.\n+    z_stg(Z_R0\/*==0!*\/, mark_offset, monitor);\n+  }\n+  z_bru(done);\n@@ -1073,2 +1083,10 @@\n-  call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n-\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    \/\/ for fast locking we need to use monitorenter_obj, see interpreterRuntime.cpp\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj),\n+            object);\n+  } else {\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+            monitor);\n+  }\n@@ -1095,1 +1113,1 @@\n-  \/\/ template code:\n+  \/\/ template code: (for LM_LEGACY):\n@@ -1108,2 +1126,4 @@\n-  const Register displaced_header = Z_ARG4;\n-  const Register current_header   = Z_R1;\n+  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n+\n+  const Register header         = Z_ARG4;\n+  const Register current_header = Z_R1_scratch;\n@@ -1111,1 +1131,1 @@\n-  Label done;\n+  Label done, slow_case;\n@@ -1121,1 +1141,1 @@\n-  assert_different_registers(monitor, object, displaced_header, current_header);\n+  assert_different_registers(monitor, object, header, current_header);\n@@ -1127,1 +1147,3 @@\n-  clear_mem(obj_entry, sizeof(oop));\n+  \/\/ monitor->lock()->set_displaced_header(displaced_header);\n+  const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n+  const int mark_offset = lock_offset + BasicLock::displaced_header_offset_in_bytes();\n@@ -1129,5 +1151,6 @@\n-  \/\/ Test first if we are in the fast recursive case.\n-  MacroAssembler::load_and_test_long(displaced_header,\n-                                     Address(monitor, in_bytes(BasicObjectLock::lock_offset()) +\n-                                                      BasicLock::displaced_header_offset_in_bytes()));\n-  z_bre(done); \/\/ displaced_header == 0 -> goto done\n+  clear_mem(obj_entry, sizeof(oop));\n+  if (LockingMode != LM_LIGHTWEIGHT) {\n+    \/\/ Test first if we are in the fast recursive case.\n+    MacroAssembler::load_and_test_long(header, Address(monitor, mark_offset));\n+    z_bre(done); \/\/ header == 0 -> goto done\n+  }\n@@ -1140,0 +1163,9 @@\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    \/\/ Check for non-symmetric locking. This is allowed by the spec and the interpreter\n+    \/\/ must handle it.\n+\n+    Register tmp = current_header;\n+\n+    \/\/ First check for lock-stack underflow.\n+    z_lgf(tmp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n+    compareU32_and_branch(tmp, (unsigned)LockStack::start_offset(), Assembler::bcondNotHigh, slow_case);\n@@ -1141,2 +1173,4 @@\n-  \/\/ The markword is expected to be at offset 0.\n-  assert(oopDesc::mark_offset_in_bytes() == 0, \"unlock_object: review code below\");\n+    \/\/ Then check if the top of the lock-stack matches the unlocked object.\n+    z_aghi(tmp, -oopSize);\n+    z_lg(tmp, Address(Z_thread, tmp));\n+    compare64_and_branch(tmp, object, Assembler::bcondNotEqual, slow_case);\n@@ -1144,6 +1178,20 @@\n-  \/\/ We have the displaced header in displaced_header. If the lock is still\n-  \/\/ lightweight, it will contain the monitor address and we'll store the\n-  \/\/ displaced header back into the object's mark word.\n-  z_lgr(current_header, monitor);\n-  z_csg(current_header, displaced_header, 0, object);\n-  z_bre(done);\n+    z_lg(header, Address(object, hdr_offset));\n+    z_lgr(tmp, header);\n+    z_nill(tmp, markWord::monitor_value);\n+    z_brne(slow_case);\n+\n+    fast_unlock(object, header, tmp, slow_case);\n+\n+    z_bru(done);\n+  } else {\n+    \/\/ The markword is expected to be at offset 0.\n+    \/\/ This is not required on s390, at least not here.\n+    assert(hdr_offset == 0, \"unlock_object: review code below\");\n+\n+    \/\/ We have the displaced header in header. If the lock is still\n+    \/\/ lightweight, it will contain the monitor address and we'll store the\n+    \/\/ displaced header back into the object's mark word.\n+    z_lgr(current_header, monitor);\n+    z_csg(current_header, header, hdr_offset, object);\n+    z_bre(done);\n+  }\n@@ -1157,0 +1205,1 @@\n+  bind(slow_case);\n@@ -2217,1 +2266,1 @@\n-    unimplemented(\"verfiyFPU\");\n+    unimplemented(\"verifyFPU\");\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":113,"deletions":64,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -3168,1 +3168,1 @@\n-  z_lr(temp, displacedHeader);\n+  z_lgr(temp, displacedHeader);\n@@ -3172,1 +3172,5 @@\n-  if (LockingMode != LM_MONITOR) {\n+  if (LockingMode == LM_MONITOR) {\n+    \/\/ Set NE to indicate 'failure' -> take slow-path\n+    z_ltgr(oop, oop);\n+    z_bru(done);\n+  } else if (LockingMode == LM_LEGACY) {\n@@ -3189,5 +3193,0 @@\n-  } else {\n-    \/\/ Set NE to indicate 'failure' -> take slow-path\n-    z_ltgr(oop, oop);\n-    z_bru(done);\n-  }\n@@ -3195,1 +3194,1 @@\n-  \/\/ We did not see an unlocked object so try the fast recursive case.\n+    \/\/ We did not see an unlocked object so try the fast recursive case.\n@@ -3197,2 +3196,2 @@\n-  z_sgr(currentHeader, Z_SP);\n-  load_const_optimized(temp, (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n+    z_sgr(currentHeader, Z_SP);\n+    load_const_optimized(temp, (~(os::vm_page_size() - 1) | markWord::lock_mask_in_place));\n@@ -3200,4 +3199,4 @@\n-  z_ngr(currentHeader, temp);\n-  \/\/   z_brne(done);\n-  \/\/   z_release();\n-  z_stg(currentHeader\/*==0 or not 0*\/, BasicLock::displaced_header_offset_in_bytes(), box);\n+    z_ngr(currentHeader, temp);\n+    \/\/   z_brne(done);\n+    \/\/   z_release();\n+    z_stg(currentHeader\/*==0 or not 0*\/, BasicLock::displaced_header_offset_in_bytes(), box);\n@@ -3205,1 +3204,6 @@\n-  z_bru(done);\n+    z_bru(done);\n+  } else {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+    fast_lock(oop, displacedHeader, temp, done);\n+    z_bru(done);\n+  }\n@@ -3217,2 +3221,4 @@\n-  \/\/ Store a non-null value into the box.\n-  z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);\n+  if (LockingMode != LM_LIGHTWEIGHT) {\n+    \/\/ Store a non-null value into the box.\n+    z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);\n+  }\n@@ -3241,0 +3247,2 @@\n+  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n+\n@@ -3245,1 +3253,1 @@\n-  if (LockingMode != LM_MONITOR) {\n+  if (LockingMode == LM_LEGACY) {\n@@ -3254,1 +3262,1 @@\n-  z_lg(currentHeader, oopDesc::mark_offset_in_bytes(), oop);\n+  z_lg(currentHeader, hdr_offset, oop);\n@@ -3256,0 +3264,3 @@\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    z_lgr(temp, currentHeader);\n+  }\n@@ -3259,1 +3270,5 @@\n-  if (LockingMode != LM_MONITOR) {\n+  if (LockingMode == LM_MONITOR) {\n+    \/\/ Set NE to indicate 'failure' -> take slow-path\n+    z_ltgr(oop, oop);\n+    z_bru(done);\n+  } else if (LockingMode == LM_LEGACY) {\n@@ -3265,1 +3280,1 @@\n-    z_bru(done); \/\/ Csg sets CR as desired.\n+    z_bru(done); \/\/ csg sets CR as desired.\n@@ -3267,2 +3282,6 @@\n-    \/\/ Set NE to indicate 'failure' -> take slow-path\n-    z_ltgr(oop, oop);\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+\n+    \/\/ don't load currentHead again from stack-top after monitor check, as it is possible\n+    \/\/ some other thread modified it.\n+    \/\/ currentHeader is altered, but it's contents are copied in temp as well\n+    fast_unlock(oop, temp, currentHeader, done);\n@@ -3272,0 +3291,3 @@\n+  \/\/ In case of LM_LIGHTWEIGHT, we may reach here with (temp & ObjectMonitor::ANONYMOUS_OWNER) != 0.\n+  \/\/ This is handled like owner thread mismatches: We take the slow path.\n+\n@@ -3274,1 +3296,1 @@\n-  z_lg(currentHeader, oopDesc::mark_offset_in_bytes(), oop);    \/\/ CurrentHeader is tagged with monitor_value set.\n+  z_lg(currentHeader, hdr_offset, oop);    \/\/ CurrentHeader is tagged with monitor_value set.\n@@ -5624,0 +5646,100 @@\n+\n+\/\/ Implements fast-locking.\n+\/\/ Branches to slow upon failure to lock the object.\n+\/\/ Falls through upon success.\n+\/\/\n+\/\/  - obj: the object to be locked, contents preserved.\n+\/\/  - hdr: the header, already loaded from obj, contents destroyed.\n+\/\/  Note: make sure Z_R1 is not manipulated here when C2 compiler is in play\n+void MacroAssembler::fast_lock(Register obj, Register hdr, Register temp, Label& slow_case) {\n+\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n+  assert_different_registers(obj, hdr, temp);\n+\n+  \/\/ First we need to check if the lock-stack has room for pushing the object reference.\n+  z_lgf(temp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n+\n+  compareU32_and_branch(temp, (unsigned)LockStack::end_offset()-1, bcondHigh, slow_case);\n+\n+  \/\/ attempting a fast_lock\n+  \/\/ Load (object->mark() | 1) into hdr\n+  z_oill(hdr, markWord::unlocked_value);\n+\n+  z_lgr(temp, hdr);\n+\n+  \/\/ Clear lock-bits from hdr (locked state)\n+  z_xilf(temp, markWord::unlocked_value);\n+\n+  z_csg(hdr, temp, oopDesc::mark_offset_in_bytes(), obj);\n+  branch_optimized(Assembler::bcondNotEqual, slow_case);\n+\n+  \/\/ After successful lock, push object on lock-stack\n+  z_lgf(temp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n+  z_stg(obj, Address(Z_thread, temp));\n+  z_ahi(temp, oopSize);\n+  z_st(temp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n+\n+  \/\/ as locking was successful, set CC to EQ\n+  z_cr(temp, temp);\n+}\n+\n+\/\/ Implements fast-unlocking.\n+\/\/ Branches to slow upon failure.\n+\/\/ Falls through upon success.\n+\/\/\n+\/\/ - obj: the object to be unlocked\n+\/\/ - hdr: the (pre-loaded) header of the object, will be destroyed\n+\/\/ - Z_R1_scratch: will be killed in case of Interpreter & C1 Compiler\n+void MacroAssembler::fast_unlock(Register obj, Register hdr, Register tmp, Label& slow) {\n+\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n+  assert_different_registers(obj, hdr, tmp);\n+\n+#ifdef ASSERT\n+  {\n+    \/\/ Check that hdr is fast-locked.\n+    Label hdr_ok;\n+    z_lgr(tmp, hdr);\n+    z_nill(tmp, markWord::lock_mask_in_place);\n+    z_bre(hdr_ok);\n+    stop(\"Header is not fast-locked\");\n+    bind(hdr_ok);\n+  }\n+  {\n+    \/\/ The following checks rely on the fact that LockStack is only ever modified by\n+    \/\/ its owning thread, even if the lock got inflated concurrently; removal of LockStack\n+    \/\/ entries after inflation will happen delayed in that case.\n+\n+    \/\/ Check for lock-stack underflow.\n+    Label stack_ok;\n+    z_lgf(tmp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n+    compareU32_and_branch(tmp, (unsigned)LockStack::start_offset(), Assembler::bcondHigh, stack_ok);\n+    stop(\"Lock-stack underflow\");\n+    bind(stack_ok);\n+  }\n+  {\n+    \/\/ Check if the top of the lock-stack matches the unlocked object.\n+    Label tos_ok;\n+    z_aghi(tmp, -oopSize);\n+    z_lg(tmp, Address(Z_thread, tmp));\n+    compare64_and_branch(tmp, obj, Assembler::bcondEqual, tos_ok);\n+    stop(\"Top of lock-stack does not match the unlocked object\");\n+    bind(tos_ok);\n+  }\n+#endif \/\/ ASSERT\n+\n+  z_lgr(tmp, hdr);\n+  z_oill(tmp, markWord::unlocked_value);\n+  z_csg(hdr, tmp, oopDesc::mark_offset_in_bytes(), obj);\n+  branch_optimized(Assembler::bcondNotEqual, slow);\n+\n+  \/\/ After successful unlock, pop object from lock-stack\n+#ifdef ASSERT\n+  z_lgf(tmp, Address(Z_thread, JavaThread::lock_stack_top_offset()));\n+  z_aghi(tmp, -oopSize);\n+  z_agr(tmp, Z_thread);\n+  z_xc(0, oopSize-1, tmp, 0, tmp);  \/\/ wipe out lock-stack entry\n+#endif\n+  z_alsi(in_bytes(JavaThread::lock_stack_top_offset()), Z_thread, -oopSize);  \/\/ pop object\n+  z_cr(tmp, tmp); \/\/ set CC to EQ\n+}\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":146,"deletions":24,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -725,0 +725,2 @@\n+  void fast_lock(Register obj, Register hdr, Register tmp, Label& slow);\n+  void fast_unlock(Register obj, Register hdr, Register tmp, Label& slow);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1719,1 +1719,3 @@\n-    \/\/ Fast_lock kills r_temp_1, r_temp_2. (Don't use R1 as temp, won't work!)\n+    \/\/ Fast_lock kills r_temp_1, r_temp_2.\n+    \/\/ in case of DiagnoseSyncOnValueBasedClasses content for Z_R1_scratch\n+    \/\/ will be destroyed, So avoid using Z_R1 as temp here.\n@@ -1918,1 +1920,2 @@\n-    __ compiler_fast_unlock_object(r_oop, r_box, r_tmp1, r_tmp2); \/\/ Don't use R1 as temp.\n+    \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n+    __ compiler_fast_unlock_object(r_oop, r_box, r_tmp1, r_tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1907,2 +1907,1 @@\n-\n-#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM) && !defined(PPC64)\n+#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM) && !defined(PPC64) && !defined(S390)\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}