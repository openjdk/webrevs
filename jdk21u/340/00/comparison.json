{"files":[{"patch":"@@ -2673,1 +2673,1 @@\n-                return loader.nameAndId();\n+                return loader != null ? loader.nameAndId() : \"null\";\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4227192 8004928 8072656\n+ * @bug 4227192 8004928 8072656 8319436\n@@ -31,1 +31,1 @@\n- * @run main ClassRestrictions\n+ * @run junit ClassRestrictions\n@@ -40,0 +40,7 @@\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -55,76 +62,12 @@\n-    public static final String nonPublicIntrfaceName = \"java.util.zip.ZipConstants\";\n-\n-    public static void main(String[] args) {\n-\n-        System.err.println(\n-            \"\\nTest of restrictions on parameters to Proxy.getProxyClass\\n\");\n-\n-        try {\n-            ClassLoader loader = ClassRestrictions.class.getClassLoader();\n-            Class<?>[] interfaces;\n-            Class<?> proxyClass;\n-\n-            \/*\n-             * All of the Class objects in the interfaces array must represent\n-             * interfaces, not classes or primitive types.\n-             *\/\n-            try {\n-                interfaces = new Class<?>[] { Object.class };\n-                proxyClass = Proxy.getProxyClass(loader, interfaces);\n-                throw new Error(\n-                    \"proxy class created with java.lang.Object as interface\");\n-            } catch (IllegalArgumentException e) {\n-                e.printStackTrace();\n-                System.err.println();\n-                \/\/ assume exception is for intended failure\n-            }\n-            try {\n-                interfaces = new Class<?>[] { Integer.TYPE };\n-                proxyClass = Proxy.getProxyClass(loader, interfaces);\n-                throw new Error(\n-                    \"proxy class created with int.class as interface\");\n-            } catch (IllegalArgumentException e) {\n-                e.printStackTrace();\n-                System.err.println();\n-                \/\/ assume exception is for intended failure\n-            }\n-\n-            \/*\n-             * No two elements in the interfaces array may refer to identical\n-             * Class objects.\n-             *\/\n-            try {\n-                interfaces = new Class<?>[] { Bar.class, Bar.class };\n-                proxyClass = Proxy.getProxyClass(loader, interfaces);\n-                throw new Error(\n-                    \"proxy class created with repeated interfaces\");\n-            } catch (IllegalArgumentException e) {\n-                e.printStackTrace();\n-                System.err.println();\n-                \/\/ assume exception is for intended failure\n-            }\n-\n-            \/*\n-             * All of the interfaces types must be visible by name though the\n-             * specified class loader.\n-             *\/\n-            String[] cpaths = System.getProperty(\"test.classes\", \".\")\n-                                    .split(File.pathSeparator);\n-            URL[] urls = new URL[cpaths.length];\n-            for (int i=0; i < cpaths.length; i++) {\n-                urls[i] = Paths.get(cpaths[i]).toUri().toURL();\n-            }\n-            ClassLoader altLoader = new URLClassLoader(urls, null);\n-            Class altBarClass;\n-            altBarClass = Class.forName(Bar.class.getName(), false, altLoader);\n-            try {\n-                interfaces = new Class<?>[] { altBarClass };\n-                proxyClass = Proxy.getProxyClass(loader, interfaces);\n-                throw new Error(\n-                    \"proxy class created with interface \" +\n-                    \"not visible to class loader\");\n-            } catch (IllegalArgumentException e) {\n-                e.printStackTrace();\n-                System.err.println();\n-                \/\/ assume exception is for intended failure\n-            }\n+    private static final String TEST_CLASSES = System.getProperty(\"test.classes\", \".\");\n+    private static final ClassLoader LOADER = ClassRestrictions.class.getClassLoader();\n+\n+    static Stream<List<Class<?>>> badProxyInterfaces() {\n+        return Stream.of(\n+                List.of(Object.class),          \/\/ proxy interface cannot be a class\n+                List.of(int.class),             \/\/ proxy interface can't be primitive type\n+                List.of(Bar.class, Bar.class),  \/\/ cannot have repeated interfaces\n+                \/\/ two proxy interfaces have the method of same method name but different return type\n+                List.of(Bar.class, Baz.class)\n+        );\n+    }\n@@ -132,21 +75,8 @@\n-            \/*\n-             * All non-public interfaces must be in the same package.\n-             *\/\n-            Class<?> nonPublic1 = Bashful.class;\n-            Class<?> nonPublic2 = Class.forName(nonPublicIntrfaceName);\n-            if (Modifier.isPublic(nonPublic2.getModifiers())) {\n-                throw new Error(\n-                    \"Interface \" + nonPublicIntrfaceName +\n-                    \" is public and need to be changed!\");\n-            }\n-            try {\n-                interfaces = new Class<?>[] { nonPublic1, nonPublic2 };\n-                proxyClass = Proxy.getProxyClass(loader, interfaces);\n-                throw new Error(\n-                    \"proxy class created with two non-public interfaces \" +\n-                    \"in different packages\");\n-            } catch (IllegalArgumentException e) {\n-                e.printStackTrace();\n-                System.err.println();\n-                \/\/ assume exception is for intended failure\n-            }\n+    \/*\n+     * Test cases for illegal proxy interfaces\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"badProxyInterfaces\")\n+    void testForName(List<Class<?>> interfaces) {\n+        assertThrows(IllegalArgumentException.class, () -> Proxy.getProxyClass(LOADER, interfaces.toArray(Class[]::new)));\n+    }\n@@ -154,14 +84,14 @@\n-            \/*\n-             * No two interfaces may each have a method with the same name and\n-             * parameter signature but different return type.\n-             *\/\n-            try {\n-                interfaces = new Class<?>[] { Bar.class, Baz.class };\n-                proxyClass = Proxy.getProxyClass(loader, interfaces);\n-                throw new Error(\n-                    \"proxy class created with conflicting methods\");\n-            } catch (IllegalArgumentException e) {\n-                e.printStackTrace();\n-                System.err.println();\n-                \/\/ assume exception is for intended failure\n-            }\n+    private static final String nonPublicIntrfaceName = \"java.util.zip.ZipConstants\";\n+\n+    \/*\n+     * All non-public interfaces must be in the same package.\n+     *\/\n+    @Test\n+    void testNonPublicIntfs() throws Exception {\n+        var nonPublic1 = Bashful.class;\n+        var nonPublic2 = Class.forName(nonPublicIntrfaceName);\n+        assertFalse(Modifier.isPublic(nonPublic2.getModifiers()),\n+            \"Interface \" + nonPublicIntrfaceName + \" is public and need to be changed!\");\n+        var interfaces = new Class<?>[] { nonPublic1, nonPublic2 };\n+        assertThrows(IllegalArgumentException.class, () -> Proxy.getProxyClass(LOADER, interfaces));\n+    }\n@@ -169,4 +99,6 @@\n-            \/*\n-             * All components of this test have passed.\n-             *\/\n-            System.err.println(\"\\nTEST PASSED\");\n+    static Stream<ClassLoader> loaders() {\n+        return Stream.of(null,\n+                         ClassLoader.getPlatformClassLoader(),\n+                         ClassLoader.getSystemClassLoader(),\n+                         LOADER);\n+    }\n@@ -174,4 +106,11 @@\n-        } catch (Throwable e) {\n-            System.err.println(\"\\nTEST FAILED:\");\n-            e.printStackTrace();\n-            throw new Error(\"TEST FAILED: \", e);\n+    \/*\n+     * All of the interfaces types must be visible by name though the\n+     * specified class loader.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"loaders\")\n+    void testNonVisibleInterface(ClassLoader loader) throws Exception {\n+        String[] cpaths = TEST_CLASSES.split(File.pathSeparator);\n+        URL[] urls = new URL[cpaths.length];\n+        for (int i = 0; i < cpaths.length; i++) {\n+            urls[i] = Paths.get(cpaths[i]).toUri().toURL();\n@@ -179,0 +118,4 @@\n+        var altLoader = new URLClassLoader(urls, null);\n+        var altBarClass = Class.forName(Bar.class.getName(), false, altLoader);\n+        var interfaces = new Class<?>[]{ altBarClass };\n+        assertThrows(IllegalArgumentException.class, () -> Proxy.getProxyClass(loader, interfaces));\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ClassRestrictions.java","additions":65,"deletions":122,"binary":false,"changes":187,"status":"modified"}]}