{"files":[{"patch":"@@ -678,0 +678,7 @@\n+  if (is_array) {\n+    \/\/ Ensure the array payload size is rounded up to the next BytesPerLong\n+    \/\/ multiple when converting to double-words. This is necessary because array\n+    \/\/ size does not include object alignment padding, so it might not be a\n+    \/\/ multiple of BytesPerLong for sub-long element types.\n+    payload_size = kit->gvn().transform(new AddXNode(payload_size, kit->MakeConX(BytesPerLong - 1)));\n+  }\n@@ -679,1 +686,1 @@\n-  ArrayCopyNode* ac = ArrayCopyNode::make(kit, false, src_base, offset,  dst_base, offset, payload_size, true, false);\n+  ArrayCopyNode* ac = ArrayCopyNode::make(kit, false, src_base, offset, dst_base, offset, payload_size, true, false);\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -137,4 +137,6 @@\n-      \/\/ length input to ArrayCopyNode is constant, length of input\n-      \/\/ array must be too.\n-\n-      assert((get_length_if_constant(phase) == -1) != ary_src->size()->is_con() ||\n+      \/\/ length of the input array is constant, ArrayCopyNode::Length\n+      \/\/ must be too. Note that the opposite does not need to hold,\n+      \/\/ because different input array lengths (e.g. int arrays with\n+      \/\/ 3 or 4 elements) might lead to the same length input\n+      \/\/ (e.g. 2 double-words).\n+      assert(!ary_src->size()->is_con() || (get_length_if_constant(phase) >= 0) ||\n@@ -142,1 +144,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3731,1 +3731,4 @@\n-\/\/ See comments on new_instance for the meaning of the other arguments.\n+\/\/ The optional arguments are for specialized use by intrinsics:\n+\/\/  - If 'return_size_val', report the non-padded array size (sum of header size\n+\/\/    and array body) to the caller.\n+\/\/  - deoptimize_on_exception controls how Java exceptions are handled (rethrow vs deoptimize)\n@@ -3782,1 +3785,0 @@\n-  int   header_size_min  = arrayOopDesc::base_offset_in_bytes(T_BYTE);\n@@ -3787,1 +3789,0 @@\n-    BasicType etype  = Klass::layout_helper_element_type(layout_con);\n@@ -3791,0 +3792,1 @@\n+    int header_size_min = arrayOopDesc::base_offset_in_bytes(T_BYTE);\n@@ -3792,2 +3794,1 @@\n-    header_size_min = hsize;\n-    header_size = intcon(hsize + round_mask);\n+    header_size = intcon(hsize);\n@@ -3797,4 +3798,2 @@\n-    Node* hsize = _gvn.transform( new URShiftINode(layout_val, hss) );\n-    hsize       = _gvn.transform( new AndINode(hsize, hsm) );\n-    Node* mask  = intcon(round_mask);\n-    header_size = _gvn.transform( new AddINode(hsize, mask) );\n+    header_size = _gvn.transform(new URShiftINode(layout_val, hss));\n+    header_size = _gvn.transform(new AndINode(header_size, hsm));\n@@ -3852,4 +3851,4 @@\n-  \/\/ Combine header size (plus rounding) and body size.  Then round down.\n-  \/\/ This computation cannot overflow, because it is used only in two\n-  \/\/ places, one where the length is sharply limited, and the other\n-  \/\/ after a successful allocation.\n+  \/\/ Combine header size and body size for the array copy part, then align (if\n+  \/\/ necessary) for the allocation part. This computation cannot overflow,\n+  \/\/ because it is used only in two places, one where the length is sharply\n+  \/\/ limited, and the other after a successful allocation.\n@@ -3857,6 +3856,2 @@\n-  if (elem_shift != nullptr)\n-    abody     = _gvn.transform( new LShiftXNode(lengthx, elem_shift) );\n-  Node* size  = _gvn.transform( new AddXNode(headerx, abody) );\n-  if (round_mask != 0) {\n-    Node* mask = MakeConX(~round_mask);\n-    size       = _gvn.transform( new AndXNode(size, mask) );\n+  if (elem_shift != nullptr) {\n+    abody = _gvn.transform(new LShiftXNode(lengthx, elem_shift));\n@@ -3864,1 +3859,1 @@\n-  \/\/ else if round_mask == 0, the size computation is self-rounding\n+  Node* non_rounded_size = _gvn.transform(new AddXNode(headerx, abody));\n@@ -3868,1 +3863,1 @@\n-    (*return_size_val) = size;\n+    (*return_size_val) = non_rounded_size;\n@@ -3871,0 +3866,9 @@\n+  Node* size = non_rounded_size;\n+  if (round_mask != 0) {\n+    Node* mask1 = MakeConX(round_mask);\n+    size = _gvn.transform(new AddXNode(size, mask1));\n+    Node* mask2 = MakeConX(~round_mask);\n+    size = _gvn.transform(new AndXNode(size, mask2));\n+  }\n+  \/\/ else if round_mask == 0, the size computation is self-rounding\n+\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":25,"deletions":21,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -4995,2 +4995,2 @@\n-      Node* obj_size  = nullptr;\n-      Node* alloc_obj = new_array(obj_klass, obj_length, 0, &obj_size, \/*deoptimize_on_exception=*\/true);\n+      Node* array_size = nullptr; \/\/ Size of the array without object alignment padding.\n+      Node* alloc_obj = new_array(obj_klass, obj_length, 0, &array_size, \/*deoptimize_on_exception=*\/true);\n@@ -5029,1 +5029,1 @@\n-        copy_to_clone(obj, alloc_obj, obj_size, true);\n+        copy_to_clone(obj, alloc_obj, array_size, true);\n@@ -5069,1 +5069,1 @@\n-      Node* obj_size  = nullptr;\n+      Node* obj_size = nullptr; \/\/ Total object size, including object alignment padding.\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy;\n+\n+\/**\n+ * @test\n+ * @bug 8315082\n+ * @summary Test that idealization of clone-derived ArrayCopy nodes does not\n+ *          trigger assertion failures for different combinations of\n+ *          constant\/variable array length (in number of elements) and array\n+ *          copy length (in words).\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ *                   -XX:CompileOnly=compiler.arraycopy.TestCloneArrayWithDifferentLengthConstness::test*\n+ *                   compiler.arraycopy.TestCloneArrayWithDifferentLengthConstness\n+ *\/\n+\n+public class TestCloneArrayWithDifferentLengthConstness {\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 10_000; i++) {\n+            testConstantArrayLengthAndConstantArrayCopyLength();\n+        }\n+        for (int i = 0; i < 10_000; i++) {\n+            testVariableArrayLengthAndConstantArrayCopyLength(i % 2 == 0);\n+        }\n+        for (int i = 0; i < 10_000; i++) {\n+            testVariableArrayLengthAndVariableArrayCopyLength(i % 2 == 0);\n+        }\n+    }\n+\n+    static int[] testConstantArrayLengthAndConstantArrayCopyLength() {\n+        int[] src = new int[3];\n+        return (int[])src.clone();\n+    }\n+\n+    static int[] testVariableArrayLengthAndConstantArrayCopyLength(boolean p) {\n+        int[] src = new int[p ? 3 : 4];\n+        return (int[])src.clone();\n+    }\n+\n+    static int[] testVariableArrayLengthAndVariableArrayCopyLength(boolean p) {\n+        int[] src = new int[p ? 3 : 42];\n+        return (int[])src.clone();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestCloneArrayWithDifferentLengthConstness.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.gcbarriers;\n+\n+import java.util.Arrays;\n+\n+\/**\n+ * @test\n+ * @bug 8312749\n+ * @summary Test that, when using a larger object alignment, ZGC arraycopy\n+ *          barriers are only applied to actual OOPs, and not to object\n+ *          alignment padding words.\n+ * @requires vm.gc.ZGenerational\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ *                   -XX:CompileOnly=compiler.gcbarriers.TestArrayCopyWithLargeObjectAlignment::*\n+ *                   -XX:ObjectAlignmentInBytes=16\n+ *                   -XX:+UseZGC -XX:+ZGenerational\n+ *                   compiler.gcbarriers.TestArrayCopyWithLargeObjectAlignment\n+ *\/\n+\n+public class TestArrayCopyWithLargeObjectAlignment {\n+\n+    static Object[] doCopyOf(Object[] array) {\n+        return Arrays.copyOf(array, array.length);\n+    }\n+\n+    static Object[] doClone(Object[] array) {\n+        return array.clone();\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 10_000; i++) {\n+            \/\/ This test allocates an array 'a', copies it into a new array 'b'\n+            \/\/ using Arrays.copyOf, and clones 'b' into yet another array. For\n+            \/\/ ObjectAlignmentInBytes=16, the intrinsic implementation of\n+            \/\/ Arrays.copyOf leaves the object alignment padding word \"b[1]\"\n+            \/\/ untouched, preserving the badHeapWordVal value '0xbaadbabe'. The\n+            \/\/ test checks that this padding word is not processed as a valid\n+            \/\/ OOP by the ZGC arraycopy stub underlying the intrinsic\n+            \/\/ implementation of Object.clone. Allocating b using the intrinsic\n+            \/\/ implementation of Arrays.copyOf is key to reproducing the issue\n+            \/\/ because, unlike regular (fast or slow) array allocation,\n+            \/\/ Arrays.copyOf does not zero-clear the padding word.\n+            Object[] a = {new Object()};\n+            Object[] b = doCopyOf(a);\n+            doClone(b);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestArrayCopyWithLargeObjectAlignment.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"}]}