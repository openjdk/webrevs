{"files":[{"patch":"@@ -799,1 +799,1 @@\n-      DISABLED_WARNINGS_gcc_png.c := maybe-uninitialized unused-function, \\\n+      DISABLED_WARNINGS_gcc_png.c := maybe-uninitialized, \\\n@@ -807,1 +807,0 @@\n-      DISABLED_WARNINGS_clang_png.c := unused-function, \\\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## libpng v1.6.47\n+## libpng v1.6.51\n@@ -12,1 +12,1 @@\n-Copyright (c) 1995-2025 The PNG Reference Library Authors.\n+Copyright (C) 1995-2025 The PNG Reference Library Authors.\n@@ -176,0 +176,1 @@\n+ * Manfred Schlaegl\n@@ -187,0 +188,1 @@\n+ * Tobias Stoeckmann\n@@ -196,1 +198,1 @@\n- * Google Inc.\n+ * Google LLC\n@@ -198,0 +200,1 @@\n+    - Drago»ô Tiselice\n@@ -207,0 +210,2 @@\n+ * Samsung Group\n+    - Filip Wasil\n@@ -217,0 +222,1 @@\n+\n","filename":"src\/java.desktop\/share\/legal\/libpng.md","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -6254,0 +6254,53 @@\n+Version 1.6.48 [April 30, 2025]\n+  Fixed the floating-point version of the mDCv setter `png_set_mDCv`.\n+    (Reported by Mohit Bakshi; fixed by John Bowler)\n+  Added #error directives to discourage the inclusion of private\n+    libpng implementation header files in PNG-supporting applications.\n+  Added the CMake build option `PNG_LIBCONF_HEADER`, to be used as an\n+    alternative to `DFA_XTRA`.\n+  Removed the Travis CI configuration files, with heartfelt thanks for\n+    their generous support of our project over the past five years!\n+\n+Version 1.6.49 [June 12, 2025]\n+  Added SIMD-optimized code for the RISC-V Vector Extension (RVV).\n+    (Contributed by Manfred Schlaegl, Dragos Tiselice and Filip Wasil)\n+  Added various fixes and improvements to the build scripts and to\n+    the sample code.\n+\n+Version 1.6.50 [July 1, 2025]\n+  Improved the detection of the RVV Extension on the RISC-V platform.\n+    (Contributed by Filip Wasil)\n+  Replaced inline ASM with C intrinsics in the RVV code.\n+    (Contributed by Filip Wasil)\n+  Fixed a decoder defect in which unknown chunks trailing IDAT, set\n+    to go through the unknown chunk handler, incorrectly triggered\n+    out-of-place IEND errors.\n+    (Contributed by John Bowler)\n+  Fixed the CMake file for cross-platform builds that require `libm`.\n+\n+Version 1.6.51 [November 21, 2025]\n+  Fixed CVE-2025-64505 (moderate severity):\n+    Heap buffer overflow in `png_do_quantize` via malformed palette index.\n+    (Reported by Samsung; analyzed by Fabio Gritti.)\n+  Fixed CVE-2025-64506 (moderate severity):\n+    Heap buffer over-read in `png_write_image_8bit` with 8-bit input and\n+    `convert_to_8bit` enabled.\n+    (Reported by Samsung and <weijinjinnihao@users.noreply.github.com>;\n+    analyzed by Fabio Gritti.)\n+  Fixed CVE-2025-64720 (high severity):\n+    Buffer overflow in `png_image_read_composite` via incorrect palette\n+    premultiplication.\n+    (Reported by Samsung; analyzed by John Bowler.)\n+  Fixed CVE-2025-65018 (high severity):\n+    Heap buffer overflow in `png_combine_row` triggered via\n+    `png_image_finish_read`.\n+    (Reported by <yosiimich@users.noreply.github.com>.)\n+  Fixed a memory leak in `png_set_quantize`.\n+    (Reported by Samsung; analyzed by Fabio Gritti.)\n+  Removed the experimental and incomplete ERROR_NUMBERS code.\n+    (Contributed by Tobias Stoeckmann.)\n+  Improved the RISC-V vector extension support; required RVV 1.0 or newer.\n+    (Contributed by Filip Wasil.)\n+  Added GitHub Actions workflows for automated testing.\n+  Performed various refactorings and cleanups.\n+\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/CHANGES","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-README for libpng version 1.6.47\n+README for libpng version 1.6.51\n@@ -150,0 +150,1 @@\n+    riscv\/        =>  Optimized code for the RISC-V platform\n@@ -165,0 +166,1 @@\n+        riscv-rvv\/    =>  Optimized code for the RISC-V Vector platform\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/README","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-typedef png_libpng_version_1_6_47 Your_png_h_is_not_version_1_6_47;\n+typedef png_libpng_version_1_6_51 Your_png_h_is_not_version_1_6_51;\n@@ -140,1 +140,7 @@\n-   if (items >= (~(png_alloc_size_t)0)\/size)\n+   \/* This check against overflow is vestigial, dating back from\n+    * the old times when png_zalloc used to be an exported function.\n+    * We're still keeping it here for now, as an extra-cautious\n+    * prevention against programming errors inside zlib, although it\n+    * should rather be a debug-time assertion instead.\n+    *\/\n+   if (size != 0 && items >= (~(png_alloc_size_t)0) \/ size)\n@@ -142,2 +148,2 @@\n-      png_warning (png_voidcast(png_structrp, png_ptr),\n-          \"Potential overflow in png_zalloc()\");\n+      png_warning(png_voidcast(png_structrp, png_ptr),\n+                  \"Potential overflow in png_zalloc()\");\n@@ -270,4 +276,0 @@\n-#ifdef PNG_ERROR_NUMBERS_SUPPORTED\n-      png_ptr->flags = 0;\n-#endif\n-\n@@ -732,1 +734,1 @@\n-png_init_io(png_structrp png_ptr, png_FILE_p fp)\n+png_init_io(png_structrp png_ptr, FILE *fp)\n@@ -847,1 +849,1 @@\n-      \"libpng version 1.6.47\" PNG_STRING_NEWLINE \\\n+      \"libpng version 1.6.51\" PNG_STRING_NEWLINE \\\n@@ -1523,1 +1525,1 @@\n-#ifdef PNG_iCCP_SUPPORTED\n+#ifdef PNG_READ_iCCP_SUPPORTED\n@@ -1599,1 +1601,0 @@\n-#endif \/* iCCP *\/\n@@ -1601,1 +1602,0 @@\n-#ifdef PNG_READ_iCCP_SUPPORTED\n@@ -4001,1 +4001,1 @@\n-         FILE *fp = png_voidcast(FILE*, cp->png_ptr->io_ptr);\n+         FILE *fp = png_voidcast(FILE *, cp->png_ptr->io_ptr);\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/png.c","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * libpng version 1.6.47\n+ * libpng version 1.6.51\n@@ -46,1 +46,1 @@\n- *   libpng versions 1.6.36, December 2018, through 1.6.47, February 2025:\n+ *   libpng versions 1.6.36, December 2018, through 1.6.51, November 2025:\n@@ -270,1 +270,1 @@\n- *    1.6.47                  16    10647  16.so.16.47[.0]\n+ *    1.6.51                  16    10651  16.so.16.51[.0]\n@@ -306,1 +306,1 @@\n-#define PNG_LIBPNG_VER_STRING \"1.6.47\"\n+#define PNG_LIBPNG_VER_STRING \"1.6.51\"\n@@ -317,1 +317,1 @@\n-#define PNG_LIBPNG_VER_RELEASE 47\n+#define PNG_LIBPNG_VER_RELEASE 51\n@@ -348,1 +348,1 @@\n-#define PNG_LIBPNG_VER 10647 \/* 1.6.47 *\/\n+#define PNG_LIBPNG_VER 10651 \/* 1.6.51 *\/\n@@ -458,1 +458,1 @@\n-typedef char* png_libpng_version_1_6_47;\n+typedef char* png_libpng_version_1_6_51;\n@@ -1602,1 +1602,1 @@\n-PNG_EXPORT(74, void, png_init_io, (png_structrp png_ptr, png_FILE_p fp));\n+PNG_EXPORT(74, void, png_init_io, (png_structrp png_ptr, FILE *fp));\n@@ -3120,1 +3120,1 @@\n-   FILE* file));\n+   FILE *file));\n@@ -3195,1 +3195,1 @@\n-   \/* Write the image to the given (FILE*). *\/\n+   \/* Write the image to the given FILE object. *\/\n@@ -3335,0 +3335,2 @@\n+\n+\/* HARDWARE: ARM Neon SIMD instructions supported *\/\n@@ -3336,1 +3338,1 @@\n-#  define PNG_ARM_NEON   0 \/* HARDWARE: ARM Neon SIMD instructions supported *\/\n+#  define PNG_ARM_NEON 0\n@@ -3338,2 +3340,8 @@\n-#define PNG_MAXIMUM_INFLATE_WINDOW 2 \/* SOFTWARE: force maximum window *\/\n-#define PNG_SKIP_sRGB_CHECK_PROFILE 4 \/* SOFTWARE: Check ICC profile for sRGB *\/\n+\n+\/* SOFTWARE: Force maximum window *\/\n+#define PNG_MAXIMUM_INFLATE_WINDOW 2\n+\n+\/* SOFTWARE: Check ICC profile for sRGB *\/\n+#define PNG_SKIP_sRGB_CHECK_PROFILE 4\n+\n+\/* HARDWARE: MIPS MSA SIMD instructions supported *\/\n@@ -3341,1 +3349,1 @@\n-#  define PNG_MIPS_MSA   6 \/* HARDWARE: MIPS Msa SIMD instructions supported *\/\n+#  define PNG_MIPS_MSA 6\n@@ -3343,0 +3351,2 @@\n+\n+\/* SOFTWARE: Disable Adler32 check on IDAT *\/\n@@ -3344,1 +3354,1 @@\n-#  define PNG_IGNORE_ADLER32 8 \/* SOFTWARE: disable Adler32 check on IDAT *\/\n+#  define PNG_IGNORE_ADLER32 8\n@@ -3346,0 +3356,2 @@\n+\n+\/* HARDWARE: PowerPC VSX SIMD instructions supported *\/\n@@ -3347,2 +3359,1 @@\n-#  define PNG_POWERPC_VSX   10 \/* HARDWARE: PowerPC VSX SIMD instructions\n-                                * supported *\/\n+#  define PNG_POWERPC_VSX 10\n@@ -3350,0 +3361,2 @@\n+\n+\/* HARDWARE: MIPS MMI SIMD instructions supported *\/\n@@ -3351,1 +3364,6 @@\n-#  define PNG_MIPS_MMI   12 \/* HARDWARE: MIPS MMI SIMD instructions supported *\/\n+#  define PNG_MIPS_MMI 12\n+#endif\n+\n+\/* HARDWARE: RISC-V RVV SIMD instructions supported *\/\n+#ifdef PNG_RISCV_RVV_API_SUPPORTED\n+#  define PNG_RISCV_RVV 14\n@@ -3354,1 +3372,2 @@\n-#define PNG_OPTION_NEXT  14 \/* Next option - numbers must be even *\/\n+\/* Next option - numbers must be even *\/\n+#define PNG_OPTION_NEXT 16\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/png.h","additions":38,"deletions":19,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * libpng version 1.6.47\n+ * libpng version 1.6.51\n@@ -251,1 +251,1 @@\n-#     error \"PNG_USER_PRIVATEBUILD must be defined if PNGAPI is changed\"\n+#     error PNG_USER_PRIVATEBUILD must be defined if PNGAPI is changed\n@@ -254,16 +254,4 @@\n-#  if (defined(_MSC_VER) && _MSC_VER < 800) ||\\\n-      (defined(__BORLANDC__) && __BORLANDC__ < 0x500)\n-   \/* older Borland and MSC\n-    * compilers used '__export' and required this to be after\n-    * the type.\n-    *\/\n-#    ifndef PNG_EXPORT_TYPE\n-#      define PNG_EXPORT_TYPE(type) type PNG_IMPEXP\n-#    endif\n-#    define PNG_DLL_EXPORT __export\n-#  else \/* newer compiler *\/\n-#    define PNG_DLL_EXPORT __declspec(dllexport)\n-#    ifndef PNG_DLL_IMPORT\n-#      define PNG_DLL_IMPORT __declspec(dllimport)\n-#    endif\n-#  endif \/* compiler *\/\n+#  define PNG_DLL_EXPORT __declspec(dllexport)\n+#  ifndef PNG_DLL_IMPORT\n+#    define PNG_DLL_IMPORT __declspec(dllimport)\n+#  endif\n@@ -511,1 +499,1 @@\n-#  error \"libpng requires 8-bit bytes\"\n+#  error libpng requires 8-bit bytes\n@@ -519,1 +507,1 @@\n-#  error \"libpng requires a signed 16-bit type\"\n+#  error libpng requires a signed 16-bit integer type\n@@ -527,1 +515,1 @@\n-#  error \"libpng requires an unsigned 16-bit type\"\n+#  error libpng requires an unsigned 16-bit integer type\n@@ -535,1 +523,1 @@\n-#  error \"libpng requires a signed 32-bit (or more) type\"\n+#  error libpng requires a signed 32-bit (or longer) integer type\n@@ -543,1 +531,1 @@\n-#  error \"libpng requires an unsigned 32-bit (or more) type\"\n+#  error libpng requires an unsigned 32-bit (or longer) integer type\n@@ -624,4 +612,0 @@\n-#ifdef PNG_STDIO_SUPPORTED\n-typedef FILE            * png_FILE_p;\n-#endif\n-\n@@ -649,0 +633,9 @@\n+#ifdef PNG_STDIO_SUPPORTED\n+\/* With PNG_STDIO_SUPPORTED it was possible to use I\/O streams that were\n+ * not necessarily stdio FILE streams, to allow building Windows applications\n+ * before Win32 and Windows CE applications before WinCE 3.0, but that kind\n+ * of support has long been discontinued.\n+ *\/\n+typedef FILE            * png_FILE_p; \/* [Deprecated] *\/\n+#endif\n+\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngconf.h","additions":20,"deletions":27,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/* pngdebug.h - Debugging macros for libpng, also used in pngtest.c\n+\/* pngdebug.h - internal debugging macros for libpng\n@@ -32,1 +32,1 @@\n- * Copyright (c) 2018 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -42,0 +42,4 @@\n+#ifndef PNGPRIV_H\n+#  error This file must not be included by applications; please include <png.h>\n+#endif\n+\n@@ -66,3 +70,0 @@\n-#  ifndef PNG_LITERAL_SHARP\n-#    define PNG_LITERAL_SHARP 0x23\n-#  endif\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngdebug.h","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018-2024 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -71,40 +71,0 @@\n-#ifdef PNG_ERROR_NUMBERS_SUPPORTED\n-   char msg[16];\n-   if (png_ptr != NULL)\n-   {\n-      if ((png_ptr->flags &\n-         (PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT)) != 0)\n-      {\n-         if (*error_message == PNG_LITERAL_SHARP)\n-         {\n-            \/* Strip \"#nnnn \" from beginning of error message. *\/\n-            int offset;\n-            for (offset = 1; offset<15; offset++)\n-               if (error_message[offset] == ' ')\n-                  break;\n-\n-            if ((png_ptr->flags & PNG_FLAG_STRIP_ERROR_TEXT) != 0)\n-            {\n-               int i;\n-               for (i = 0; i < offset - 1; i++)\n-                  msg[i] = error_message[i + 1];\n-               msg[i - 1] = '\\0';\n-               error_message = msg;\n-            }\n-\n-            else\n-               error_message += offset;\n-         }\n-\n-         else\n-         {\n-            if ((png_ptr->flags & PNG_FLAG_STRIP_ERROR_TEXT) != 0)\n-            {\n-               msg[0] = '0';\n-               msg[1] = '\\0';\n-               error_message = msg;\n-            }\n-         }\n-      }\n-   }\n-#endif\n@@ -248,15 +208,0 @@\n-   if (png_ptr != NULL)\n-   {\n-#ifdef PNG_ERROR_NUMBERS_SUPPORTED\n-   if ((png_ptr->flags &\n-       (PNG_FLAG_STRIP_ERROR_NUMBERS|PNG_FLAG_STRIP_ERROR_TEXT)) != 0)\n-#endif\n-      {\n-         if (*warning_message == PNG_LITERAL_SHARP)\n-         {\n-            for (offset = 1; offset < 15; offset++)\n-               if (warning_message[offset] == ' ')\n-                  break;\n-         }\n-      }\n-   }\n@@ -744,36 +689,3 @@\n-#ifdef PNG_ERROR_NUMBERS_SUPPORTED\n-   \/* Check on NULL only added in 1.5.4 *\/\n-   if (error_message != NULL && *error_message == PNG_LITERAL_SHARP)\n-   {\n-      \/* Strip \"#nnnn \" from beginning of error message. *\/\n-      int offset;\n-      char error_number[16];\n-      for (offset = 0; offset<15; offset++)\n-      {\n-         error_number[offset] = error_message[offset + 1];\n-         if (error_message[offset] == ' ')\n-            break;\n-      }\n-\n-      if ((offset > 1) && (offset < 15))\n-      {\n-         error_number[offset - 1] = '\\0';\n-         fprintf(stderr, \"libpng error no. %s: %s\",\n-             error_number, error_message + offset + 1);\n-         fprintf(stderr, PNG_STRING_NEWLINE);\n-      }\n-\n-      else\n-      {\n-         fprintf(stderr, \"libpng error: %s, offset=%d\",\n-             error_message, offset);\n-         fprintf(stderr, PNG_STRING_NEWLINE);\n-      }\n-   }\n-   else\n-#endif\n-   {\n-      fprintf(stderr, \"libpng error: %s\", error_message ? error_message :\n-         \"undefined\");\n-      fprintf(stderr, PNG_STRING_NEWLINE);\n-   }\n+   fprintf(stderr, \"libpng error: %s\", error_message ? error_message :\n+      \"undefined\");\n+   fprintf(stderr, PNG_STRING_NEWLINE);\n@@ -817,34 +729,2 @@\n-#  ifdef PNG_ERROR_NUMBERS_SUPPORTED\n-   if (*warning_message == PNG_LITERAL_SHARP)\n-   {\n-      int offset;\n-      char warning_number[16];\n-      for (offset = 0; offset < 15; offset++)\n-      {\n-         warning_number[offset] = warning_message[offset + 1];\n-         if (warning_message[offset] == ' ')\n-            break;\n-      }\n-\n-      if ((offset > 1) && (offset < 15))\n-      {\n-         warning_number[offset + 1] = '\\0';\n-         fprintf(stderr, \"libpng warning no. %s: %s\",\n-             warning_number, warning_message + offset);\n-         fprintf(stderr, PNG_STRING_NEWLINE);\n-      }\n-\n-      else\n-      {\n-         fprintf(stderr, \"libpng warning: %s\",\n-             warning_message);\n-         fprintf(stderr, PNG_STRING_NEWLINE);\n-      }\n-   }\n-   else\n-#  endif\n-\n-   {\n-      fprintf(stderr, \"libpng warning: %s\", warning_message);\n-      fprintf(stderr, PNG_STRING_NEWLINE);\n-   }\n+   fprintf(stderr, \"libpng warning: %s\", warning_message);\n+   fprintf(stderr, PNG_STRING_NEWLINE);\n@@ -898,6 +778,2 @@\n-   if (png_ptr != NULL)\n-   {\n-      png_ptr->flags &=\n-         ((~(PNG_FLAG_STRIP_ERROR_NUMBERS |\n-         PNG_FLAG_STRIP_ERROR_TEXT))&strip_mode);\n-   }\n+   PNG_UNUSED(png_ptr)\n+   PNG_UNUSED(strip_mode)\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngerror.c","additions":8,"deletions":132,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018-2024 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngget.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/* pnginfo.h - header file for PNG reference library\n+\/* pnginfo.h - internal structures for libpng\n@@ -32,1 +32,1 @@\n- * Copyright (c) 2018 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -42,19 +42,5 @@\n- \/* png_info is a structure that holds the information in a PNG file so\n- * that the application can find out the characteristics of the image.\n- * If you are reading the file, this structure will tell you what is\n- * in the PNG file.  If you are writing the file, fill in the information\n- * you want to put into the PNG file, using png_set_*() functions, then\n- * call png_write_info().\n- *\n- * The names chosen should be very close to the PNG specification, so\n- * consult that document for information about the meaning of each field.\n- *\n- * With libpng < 0.95, it was only possible to directly set and read the\n- * the values in the png_info_struct, which meant that the contents and\n- * order of the values had to remain fixed.  With libpng 0.95 and later,\n- * however, there are now functions that abstract the contents of\n- * png_info_struct from the application, so this makes it easier to use\n- * libpng with dynamic libraries, and even makes it possible to use\n- * libraries that don't have all of the libpng ancillary chunk-handing\n- * functionality.  In libpng-1.5.0 this was moved into a separate private\n- * file that is not visible to applications.\n+#ifndef PNGPRIV_H\n+#  error This file must not be included by applications; please include <png.h>\n+#endif\n+\n+\/* INTERNAL, PRIVATE definition of a PNG.\n@@ -62,7 +48,3 @@\n- * The following members may have allocated storage attached that should be\n- * cleaned up before the structure is discarded: palette, trans, text,\n- * pcal_purpose, pcal_units, pcal_params, hist, iccp_name, iccp_profile,\n- * splt_palettes, scal_unit, row_pointers, and unknowns.   By default, these\n- * are automatically freed when the info structure is deallocated, if they were\n- * allocated internally by libpng.  This behavior can be changed by means\n- * of the png_data_freer() function.\n+ * png_info is a modifiable description of a PNG datastream.  The fields inside\n+ * this structure are accessed through png_get_<CHUNK>() functions and modified\n+ * using png_set_<CHUNK>() functions.\n@@ -70,9 +52,4 @@\n- * More allocation details: all the chunk-reading functions that\n- * change these members go through the corresponding png_set_*\n- * functions.  A function to clear these members is available: see\n- * png_free_data().  The png_set_* functions do not depend on being\n- * able to point info structure members to any of the storage they are\n- * passed (they make their own copies), EXCEPT that the png_set_text\n- * functions use the same storage passed to them in the text_ptr or\n- * itxt_ptr structure argument, and the png_set_rows and png_set_unknowns\n- * functions do not make their own copies.\n+ * Some functions in libpng do directly access members of png_info.  However,\n+ * this should be avoided.  png_struct objects contain members which hold\n+ * caches, sometimes optimised, of the values from png_info objects, and\n+ * png_info is not passed to the functions which read and write image data.\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pnginfo.h","additions":14,"deletions":37,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-\/* libpng version 1.6.47 *\/\n+\/* libpng version 1.6.51 *\/\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pnglibconf.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngmem.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018-2024 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -261,0 +261,8 @@\n+   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n+   {\n+      \/* These flags must be set consistently for all non-IDAT chunks,\n+       * including the unknown chunks.\n+       *\/\n+      png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT | PNG_AFTER_IDAT;\n+   }\n+\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngpread.c","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018-2024 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -51,0 +51,5 @@\n+\n+\/* pngpriv.h must be included first in each translation unit inside libpng.\n+ * On the other hand, it must not be included at all, directly or indirectly,\n+ * by any application code that uses the libpng API.\n+ *\/\n@@ -52,1 +57,8 @@\n-#define PNGPRIV_H\n+#  define PNGPRIV_H\n+#else\n+#  error Duplicate inclusion of pngpriv.h; please check the libpng source files\n+#endif\n+\n+#if defined(PNG_H) || defined(PNGCONF_H) || defined(PNGLCONF_H)\n+#  error This file must not be included by applications; please include <png.h>\n+#endif\n@@ -89,1 +101,0 @@\n-\n@@ -99,3 +110,1 @@\n-#ifndef PNGLCONF_H\n-#  include \"pnglibconf.h\"\n-#endif\n+#include \"pnglibconf.h\"\n@@ -166,0 +175,14 @@\n+#ifndef PNG_RISCV_RVV_OPT\n+   \/* RISCV_RVV optimizations are being controlled by the compiler settings,\n+    * typically the target compiler will define __riscv but the rvv extension\n+    * availability has to be explicitly stated. This is why if no\n+    * PNG_RISCV_RVV_OPT was defined then a runtime check will be executed.\n+    *\n+    * To enable RISCV_RVV optimizations unconditionally, and compile the\n+    * associated code, pass --enable-riscv-rvv=yes or --enable-riscv-rvv=on\n+    * to configure or put -DPNG_RISCV_RVV_OPT=2 in CPPFLAGS.\n+    *\/\n+\n+#  define PNG_RISCV_RVV_OPT 0\n+#endif\n+\n@@ -311,0 +334,10 @@\n+#if PNG_RISCV_RVV_OPT > 0 && __riscv_v >= 1000000\n+#  define PNG_FILTER_OPTIMIZATIONS png_init_filter_functions_rvv\n+#  ifndef PNG_RISCV_RVV_IMPLEMENTATION\n+      \/* Use the intrinsics code by default. *\/\n+#     define PNG_RISCV_RVV_IMPLEMENTATION 1\n+#  endif\n+#else\n+#  define PNG_RISCV_RVV_IMPLEMENTATION 0\n+#endif \/* PNG_RISCV_RVV_OPT > 0 && __riscv_v >= 1000000 *\/\n+\n@@ -709,1 +742,1 @@\n-#define PNG_FLAG_STRIP_ERROR_NUMBERS     0x40000U\n+                                  \/*     0x40000U    unused *\/\n@@ -1023,7 +1056,5 @@\n-#  error ZLIB_VERNUM != PNG_ZLIB_VERNUM \\\n-      \"-I (include path) error: see the notes in pngpriv.h\"\n-   \/* This means that when pnglibconf.h was built the copy of zlib.h that it\n-    * used is not the same as the one being used here.  Because the build of\n-    * libpng makes decisions to use inflateInit2 and inflateReset2 based on the\n-    * zlib version number and because this affects handling of certain broken\n-    * PNG files the -I directives must match.\n+#  error The include path of <zlib.h> is incorrect\n+   \/* When pnglibconf.h was built, the copy of zlib.h that it used was not the\n+    * same as the one being used here.  Considering how libpng makes decisions\n+    * to use the zlib API based on the zlib version number, the -I options must\n+    * match.\n@@ -1031,3 +1062,3 @@\n-    * The most likely explanation is that you passed a -I in CFLAGS. This will\n-    * not work; all the preprocessor directives and in particular all the -I\n-    * directives must be in CPPFLAGS.\n+    * A possible cause of this mismatch is that you passed an -I option in\n+    * CFLAGS, which is unlikely to work.  All the preprocessor options, and all\n+    * the -I options in particular, should be in CPPFLAGS.\n@@ -1547,0 +1578,17 @@\n+#if PNG_RISCV_RVV_IMPLEMENTATION == 1\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_up_rvv,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_sub3_rvv,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_sub4_rvv,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_avg3_rvv,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_avg4_rvv,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_paeth3_rvv,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+PNG_INTERNAL_FUNCTION(void,png_read_filter_row_paeth4_rvv,(png_row_infop\n+    row_info, png_bytep row, png_const_bytep prev_row),PNG_EMPTY);\n+#endif\n+\n@@ -2159,0 +2207,5 @@\n+#  if PNG_RISCV_RVV_IMPLEMENTATION == 1\n+PNG_INTERNAL_FUNCTION(void, png_init_filter_functions_rvv,\n+   (png_structp png_ptr, unsigned int bpp), PNG_EMPTY);\n+#endif\n+\n@@ -2194,1 +2247,0 @@\n-#endif \/* PNGPRIV_H *\/\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngpriv.h","additions":70,"deletions":18,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -734,1 +734,6 @@\n-         png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT;\n+      {\n+         \/* These flags must be set consistently for all non-IDAT chunks,\n+          * including the unknown chunks.\n+          *\/\n+         png_ptr->mode |= PNG_HAVE_CHUNK_AFTER_IDAT | PNG_AFTER_IDAT;\n+      }\n@@ -841,1 +846,2 @@\n-    defined(PNG_ARM_NEON_IMPLEMENTATION)\n+    (defined(PNG_ARM_NEON_IMPLEMENTATION) || \\\n+     defined(PNG_RISCV_RVV_IMPLEMENTATION))\n@@ -1360,1 +1366,1 @@\n-png_image_begin_read_from_stdio(png_imagep image, FILE* file)\n+png_image_begin_read_from_stdio(png_imagep image, FILE *file)\n@@ -3155,0 +3161,48 @@\n+\/* Row reading for interlaced 16-to-8 bit depth conversion with local buffer. *\/\n+static int\n+png_image_read_direct_scaled(png_voidp argument)\n+{\n+   png_image_read_control *display = png_voidcast(png_image_read_control*,\n+       argument);\n+   png_imagep image = display->image;\n+   png_structrp png_ptr = image->opaque->png_ptr;\n+   png_bytep local_row = png_voidcast(png_bytep, display->local_row);\n+   png_bytep first_row = png_voidcast(png_bytep, display->first_row);\n+   ptrdiff_t row_bytes = display->row_bytes;\n+   int passes;\n+\n+   \/* Handle interlacing. *\/\n+   switch (png_ptr->interlaced)\n+   {\n+      case PNG_INTERLACE_NONE:\n+         passes = 1;\n+         break;\n+\n+      case PNG_INTERLACE_ADAM7:\n+         passes = PNG_INTERLACE_ADAM7_PASSES;\n+         break;\n+\n+      default:\n+         png_error(png_ptr, \"unknown interlace type\");\n+   }\n+\n+   \/* Read each pass using local_row as intermediate buffer. *\/\n+   while (--passes >= 0)\n+   {\n+      png_uint_32 y = image->height;\n+      png_bytep output_row = first_row;\n+\n+      for (; y > 0; --y)\n+      {\n+         \/* Read into local_row (gets transformed 8-bit data). *\/\n+         png_read_row(png_ptr, local_row, NULL);\n+\n+         \/* Copy from local_row to user buffer. *\/\n+         memcpy(output_row, local_row, (size_t)row_bytes);\n+         output_row += row_bytes;\n+      }\n+   }\n+\n+   return 1;\n+}\n+\n@@ -3573,0 +3627,1 @@\n+   int do_local_scale = 0; \/* for interlaced 16-to-8 bit conversion *\/\n@@ -3706,0 +3761,1 @@\n+         {\n@@ -3708,0 +3764,7 @@\n+            \/* For interlaced images, use local_row buffer to avoid overflow\n+             * in png_combine_row() which writes using IHDR bit-depth.\n+             *\/\n+            if (png_ptr->interlaced != 0)\n+               do_local_scale = 1;\n+         }\n+\n@@ -3983,0 +4046,18 @@\n+   else if (do_local_scale != 0)\n+   {\n+      \/* For interlaced 16-to-8 conversion, use an intermediate row buffer\n+       * to avoid buffer overflows in png_combine_row. The local_row is sized\n+       * for the transformed (8-bit) output, preventing the overflow that would\n+       * occur if png_combine_row wrote 16-bit data directly to the user buffer.\n+       *\/\n+      int result;\n+      png_voidp row = png_malloc(png_ptr, png_get_rowbytes(png_ptr, info_ptr));\n+\n+      display->local_row = row;\n+      result = png_safe_execute(image, png_image_read_direct_scaled, display);\n+      display->local_row = NULL;\n+      png_free(png_ptr, row);\n+\n+      return result;\n+   }\n+\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngread.c","additions":84,"deletions":3,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -88,1 +88,1 @@\n-   check = fread(data, 1, length, png_voidcast(png_FILE_p, png_ptr->io_ptr));\n+   check = fread(data, 1, length, png_voidcast(FILE *, png_ptr->io_ptr));\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngrio.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018-2024 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -60,0 +60,6 @@\n+#ifdef PNG_RISCV_RVV_IMPLEMENTATION\n+#  if PNG_RISCV_RVV_IMPLEMENTATION == 1\n+#    define PNG_RISCV_RVV_INTRINSICS_AVAILABLE\n+#  endif\n+#endif\n+\n@@ -527,0 +533,10 @@\n+      \/* Initialize the array to index colors.\n+       *\n+       * Ensure quantize_index can fit 256 elements (PNG_MAX_PALETTE_LENGTH)\n+       * rather than num_palette elements. This is to prevent buffer overflows\n+       * caused by malformed PNG files with out-of-range palette indices.\n+       *\n+       * Be careful to avoid leaking memory. Applications are allowed to call\n+       * this function more than once per png_struct.\n+       *\/\n+      png_free(png_ptr, png_ptr->quantize_index);\n@@ -528,2 +544,2 @@\n-          (png_alloc_size_t)num_palette);\n-      for (i = 0; i < num_palette; i++)\n+          PNG_MAX_PALETTE_LENGTH);\n+      for (i = 0; i < PNG_MAX_PALETTE_LENGTH; i++)\n@@ -541,1 +557,2 @@\n-         int i;\n+         png_bytep quantize_sort;\n+         int i, j;\n@@ -543,2 +560,2 @@\n-         \/* Initialize an array to sort colors *\/\n-         png_ptr->quantize_sort = (png_bytep)png_malloc(png_ptr,\n+         \/* Initialize the local array to sort colors. *\/\n+         quantize_sort = (png_bytep)png_malloc(png_ptr,\n@@ -546,2 +563,0 @@\n-\n-         \/* Initialize the quantize_sort array *\/\n@@ -549,1 +564,1 @@\n-            png_ptr->quantize_sort[i] = (png_byte)i;\n+            quantize_sort[i] = (png_byte)i;\n@@ -561,1 +576,0 @@\n-            int j;\n@@ -566,2 +580,2 @@\n-               if (histogram[png_ptr->quantize_sort[j]]\n-                   < histogram[png_ptr->quantize_sort[j + 1]])\n+               if (histogram[quantize_sort[j]]\n+                   < histogram[quantize_sort[j + 1]])\n@@ -571,3 +585,3 @@\n-                  t = png_ptr->quantize_sort[j];\n-                  png_ptr->quantize_sort[j] = png_ptr->quantize_sort[j + 1];\n-                  png_ptr->quantize_sort[j + 1] = t;\n+                  t = quantize_sort[j];\n+                  quantize_sort[j] = quantize_sort[j + 1];\n+                  quantize_sort[j + 1] = t;\n@@ -585,1 +599,1 @@\n-            int j = num_palette;\n+            j = num_palette;\n@@ -592,1 +606,1 @@\n-               if ((int)png_ptr->quantize_sort[i] >= maximum_colors)\n+               if ((int)quantize_sort[i] >= maximum_colors)\n@@ -596,1 +610,1 @@\n-                  while ((int)png_ptr->quantize_sort[j] >= maximum_colors);\n+                  while ((int)quantize_sort[j] >= maximum_colors);\n@@ -604,1 +618,1 @@\n-            int j = num_palette;\n+            j = num_palette;\n@@ -612,1 +626,1 @@\n-               if ((int)png_ptr->quantize_sort[i] >= maximum_colors)\n+               if ((int)quantize_sort[i] >= maximum_colors)\n@@ -618,1 +632,1 @@\n-                  while ((int)png_ptr->quantize_sort[j] >= maximum_colors);\n+                  while ((int)quantize_sort[j] >= maximum_colors);\n@@ -656,2 +670,1 @@\n-         png_free(png_ptr, png_ptr->quantize_sort);\n-         png_ptr->quantize_sort = NULL;\n+         png_free(png_ptr, quantize_sort);\n@@ -1800,13 +1813,45 @@\n-                     png_byte v, w;\n-\n-                     v = png_ptr->gamma_to_1[palette[i].red];\n-                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.red);\n-                     palette[i].red = png_ptr->gamma_from_1[w];\n-\n-                     v = png_ptr->gamma_to_1[palette[i].green];\n-                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.green);\n-                     palette[i].green = png_ptr->gamma_from_1[w];\n-\n-                     v = png_ptr->gamma_to_1[palette[i].blue];\n-                     png_composite(w, v, png_ptr->trans_alpha[i], back_1.blue);\n-                     palette[i].blue = png_ptr->gamma_from_1[w];\n+                     if ((png_ptr->flags & PNG_FLAG_OPTIMIZE_ALPHA) != 0)\n+                     {\n+                        \/* Premultiply only:\n+                         * component = round((component * alpha) \/ 255)\n+                         *\/\n+                        png_uint_32 component;\n+\n+                        component = png_ptr->gamma_to_1[palette[i].red];\n+                        component =\n+                            (component * png_ptr->trans_alpha[i] + 128) \/ 255;\n+                        palette[i].red = png_ptr->gamma_from_1[component];\n+\n+                        component = png_ptr->gamma_to_1[palette[i].green];\n+                        component =\n+                            (component * png_ptr->trans_alpha[i] + 128) \/ 255;\n+                        palette[i].green = png_ptr->gamma_from_1[component];\n+\n+                        component = png_ptr->gamma_to_1[palette[i].blue];\n+                        component =\n+                            (component * png_ptr->trans_alpha[i] + 128) \/ 255;\n+                        palette[i].blue = png_ptr->gamma_from_1[component];\n+                     }\n+                     else\n+                     {\n+                        \/* Composite with background color:\n+                         * component =\n+                         *    alpha * component + (1 - alpha) * background\n+                         *\/\n+                        png_byte v, w;\n+\n+                        v = png_ptr->gamma_to_1[palette[i].red];\n+                        png_composite(w, v,\n+                            png_ptr->trans_alpha[i], back_1.red);\n+                        palette[i].red = png_ptr->gamma_from_1[w];\n+\n+                        v = png_ptr->gamma_to_1[palette[i].green];\n+                        png_composite(w, v,\n+                            png_ptr->trans_alpha[i], back_1.green);\n+                        palette[i].green = png_ptr->gamma_from_1[w];\n+\n+                        v = png_ptr->gamma_to_1[palette[i].blue];\n+                        png_composite(w, v,\n+                            png_ptr->trans_alpha[i], back_1.blue);\n+                        palette[i].blue = png_ptr->gamma_from_1[w];\n+                     }\n@@ -5035,1 +5080,0 @@\n-   {\n@@ -5038,4 +5082,0 @@\n-\n-      if (row_info->rowbytes == 0)\n-         png_error(png_ptr, \"png_do_quantize returned rowbytes=0\");\n-   }\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngrtran.c","additions":81,"deletions":41,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018-2024 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -2444,4 +2444,0 @@\n-   \/* TODO: this doesn't work and shouldn't be necessary. *\/\n-   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n-      png_ptr->mode |= PNG_AFTER_IDAT;\n-\n@@ -2518,4 +2514,0 @@\n-   \/* TODO: should not be necessary. *\/\n-   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n-      png_ptr->mode |= PNG_AFTER_IDAT;\n-\n@@ -2638,4 +2630,0 @@\n-   \/* TODO: should not be necessary. *\/\n-   if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n-      png_ptr->mode |= PNG_AFTER_IDAT;\n-\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngrutil.c","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -332,11 +332,8 @@\n-      \/* The ITU approach is to scale by 50,000, not 100,000 so just divide\n-       * the input values by 2 and use png_fixed:\n-       *\/\n-      png_fixed(png_ptr, white_x \/ 2, \"png_set_mDCV(white(x))\"),\n-      png_fixed(png_ptr, white_y \/ 2, \"png_set_mDCV(white(y))\"),\n-      png_fixed(png_ptr, red_x \/ 2, \"png_set_mDCV(red(x))\"),\n-      png_fixed(png_ptr, red_y \/ 2, \"png_set_mDCV(red(y))\"),\n-      png_fixed(png_ptr, green_x \/ 2, \"png_set_mDCV(green(x))\"),\n-      png_fixed(png_ptr, green_y \/ 2, \"png_set_mDCV(green(y))\"),\n-      png_fixed(png_ptr, blue_x \/ 2, \"png_set_mDCV(blue(x))\"),\n-      png_fixed(png_ptr, blue_y \/ 2, \"png_set_mDCV(blue(y))\"),\n+      png_fixed(png_ptr, white_x, \"png_set_mDCV(white(x))\"),\n+      png_fixed(png_ptr, white_y, \"png_set_mDCV(white(y))\"),\n+      png_fixed(png_ptr, red_x, \"png_set_mDCV(red(x))\"),\n+      png_fixed(png_ptr, red_y, \"png_set_mDCV(red(y))\"),\n+      png_fixed(png_ptr, green_x, \"png_set_mDCV(green(x))\"),\n+      png_fixed(png_ptr, green_y, \"png_set_mDCV(green(y))\"),\n+      png_fixed(png_ptr, blue_x, \"png_set_mDCV(blue(x))\"),\n+      png_fixed(png_ptr, blue_y, \"png_set_mDCV(blue(y))\"),\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngset.c","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-\/* pngstruct.h - header file for PNG reference library\n+\/* pngstruct.h - internal structures for libpng\n@@ -32,1 +32,1 @@\n- * Copyright (c) 2018-2022 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -42,5 +42,3 @@\n-\/* The structure that holds the information to read and write PNG files.\n- * The only people who need to care about what is inside of this are the\n- * people who will be modifying the library for their own special needs.\n- * It should NOT be accessed directly by an application.\n- *\/\n+#ifndef PNGPRIV_H\n+#  error This file must not be included by applications; please include <png.h>\n+#endif\n@@ -409,1 +407,2 @@\n-    defined(PNG_ARM_NEON_IMPLEMENTATION)\n+    (defined(PNG_ARM_NEON_IMPLEMENTATION) || \\\n+     defined(PNG_RISCV_RVV_IMPLEMENTATION))\n@@ -438,1 +437,0 @@\n-   png_bytep quantize_sort;          \/* working sort array *\/\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngstruct.h","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"}]}