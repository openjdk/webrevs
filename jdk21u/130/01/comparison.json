{"files":[{"patch":"@@ -65,0 +65,1 @@\n+    stackMapData               = type.getAddressField(\"_stackmap_data\");\n@@ -111,0 +112,1 @@\n+  private static AddressField stackMapData; \/\/ Raw stackmap data for the method (#entries + entries)\n@@ -139,0 +141,9 @@\n+  public boolean hasStackMapTable() {\n+    return stackMapData.getValue(getAddress()) != null;\n+  }\n+\n+  public U1Array getStackMapData() {\n+    Address addr = stackMapData.getValue(getAddress());\n+    return VMObjectFactory.newObject(U1Array.class, addr);\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ConstMethod.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import sun.jvm.hotspot.utilities.U1Array;\n@@ -121,0 +122,6 @@\n+  public boolean      hasStackMapTable()              {\n+    return getConstMethod().hasStackMapTable();\n+  }\n+  public U1Array      getStackMapData()               {\n+    return getConstMethod().getStackMapData();\n+  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Method.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+    protected short  _stackMapTableIndex;\n@@ -171,0 +172,5 @@\n+        Short stackMapTableIndex = utf8ToIndex.get(\"StackMapTable\");\n+        _stackMapTableIndex = (stackMapTableIndex != null) ?\n+                              stackMapTableIndex.shortValue() : 0;\n+        if (DEBUG) debugMessage(\"StackMapTable index = \" + _stackMapTableIndex);\n+\n@@ -518,0 +524,21 @@\n+            boolean hasStackMapTable = m.hasStackMapTable();\n+            U1Array stackMapData = null;\n+            int stackMapAttrLen = 0;\n+\n+            if (hasStackMapTable) {\n+                if (DEBUG) debugMessage(\"\\tmethod has stack map table\");\n+                stackMapData = m.getStackMapData();\n+                if (DEBUG) debugMessage(\"\\t\\tstack map table length = \" + stackMapData.length());\n+\n+                stackMapAttrLen = stackMapData.length();\n+\n+                codeSize += 2 \/* stack map table attr index *\/ +\n+                            4 \/* stack map table attr length *\/ +\n+                            stackMapAttrLen;\n+\n+                if (DEBUG) debugMessage(\"\\t\\tstack map table attr size = \" +\n+                                        stackMapAttrLen);\n+\n+                codeAttrCount++;\n+            }\n+\n@@ -604,0 +631,11 @@\n+            \/\/ write StackMapTable, if available\n+            if (hasStackMapTable) {\n+                writeIndex(_stackMapTableIndex);\n+                dos.writeInt(stackMapAttrLen);\n+                \/\/ We write bytes directly as stackMapData is\n+                \/\/ raw data (#entries + entries)\n+                for (int i = 0; i < stackMapData.length(); i++) {\n+                    dos.writeByte(stackMapData.at(i));\n+                }\n+            }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/jcore\/ClassWriter.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -78,0 +78,2 @@\n+            \/\/ Let javap print additional info, e.g., StackMapTable\n+            launcher.addToolArg(\"-verbose\");\n@@ -89,0 +91,4 @@\n+            \/\/ StackMapTable might not be generated for a class\n+            \/\/ containing only methods with sequential control flows.\n+            \/\/ But the class used here (LingeredApp) is not such a case.\n+            out.shouldContain(\"StackMapTable:\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbDumpclass.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}