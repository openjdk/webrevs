{"files":[{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/spinYield.hpp\"\n@@ -126,7 +127,7 @@\n-\/\/ postcondition: ret is a dirty card or end_card\n-CardTable::CardValue* PSCardTable::find_first_dirty_card(CardValue* const start_card,\n-                                                         CardValue* const end_card) {\n-  for (CardValue* i_card = start_card; i_card < end_card; ++i_card) {\n-    if (*i_card != PSCardTable::clean_card_val()) {\n-      return i_card;\n-    }\n+void PSCardTable::scan_obj_with_limit(PSPromotionManager* pm,\n+                                      oop obj,\n+                                      HeapWord* start,\n+                                      HeapWord* end) {\n+  if (!obj->is_typeArray()) {\n+    prefetch_write(start);\n+    pm->push_contents_bounded(obj, start, end);\n@@ -134,1 +135,0 @@\n-  return end_card;\n@@ -137,24 +137,57 @@\n-\/\/ postcondition: ret is a clean card or end_card\n-\/\/ Note: if a part of an object is on a dirty card, all cards this object\n-\/\/ resides on are considered dirty.\n-CardTable::CardValue* PSCardTable::find_first_clean_card(ObjectStartArray* const start_array,\n-                                                         CardValue* const start_card,\n-                                                         CardValue* const end_card) {\n-  assert(start_card == end_card ||\n-         *start_card != PSCardTable::clean_card_val(), \"precondition\");\n-  \/\/ Skip the first dirty card.\n-  CardValue* i_card = start_card + 1;\n-  while (i_card < end_card) {\n-    if (*i_card != PSCardTable::clean_card_val()) {\n-      i_card++;\n-      continue;\n-    }\n-    assert(i_card - 1 >= start_card, \"inv\");\n-    assert(*(i_card - 1) != PSCardTable::clean_card_val(), \"prev card must be dirty\");\n-    \/\/ Find the final obj on the prev dirty card.\n-    HeapWord* obj_addr = start_array->object_start(addr_for(i_card)-1);\n-    HeapWord* obj_end_addr = obj_addr + cast_to_oop(obj_addr)->size();\n-    CardValue* final_card_by_obj = byte_for(obj_end_addr - 1);\n-    assert(final_card_by_obj < end_card, \"inv\");\n-    if (final_card_by_obj <= i_card) {\n-      return i_card;\n+void PSCardTable::pre_scavenge(HeapWord* old_gen_bottom, uint active_workers) {\n+  _preprocessing_active_workers = active_workers;\n+}\n+\n+\/\/ The \"shadow\" table is a copy of the card table entries of the current stripe.\n+\/\/ It is used to separate card reading, clearing and redirtying which reduces\n+\/\/ complexity significantly.\n+class PSStripeShadowCardTable {\n+  typedef CardTable::CardValue CardValue;\n+\n+  const uint _card_shift;\n+  const uint _card_size;\n+  CardValue _table[PSCardTable::num_cards_in_stripe];\n+  const CardValue* _table_base;\n+\n+public:\n+  PSStripeShadowCardTable(PSCardTable* pst, HeapWord* const start, HeapWord* const end) :\n+    _card_shift(CardTable::card_shift()),\n+    _card_size(CardTable::card_size()),\n+    _table_base(_table - (uintptr_t(start) >> _card_shift)) {\n+    size_t stripe_byte_size = pointer_delta(end, start) * HeapWordSize;\n+    size_t copy_length = align_up(stripe_byte_size, _card_size) >> _card_shift;\n+    \/\/ The end of the last stripe may not be card aligned as it is equal to old\n+    \/\/ gen top at scavenge start. We should not clear the card containing old gen\n+    \/\/ top if not card aligned because there can be promoted objects on that\n+    \/\/ same card. If it was marked dirty because of the promoted objects and we\n+    \/\/ cleared it, we would loose a card mark.\n+    size_t clear_length = align_down(stripe_byte_size, _card_size) >> _card_shift;\n+    CardValue* stripe_start_card = pst->byte_for(start);\n+    memcpy(_table, stripe_start_card, copy_length);\n+    memset(stripe_start_card, CardTable::clean_card_val(), clear_length);\n+  }\n+\n+  HeapWord* addr_for(const CardValue* const card) {\n+    assert(card >= _table && card <=  &_table[PSCardTable::num_cards_in_stripe], \"out of bounds\");\n+    return (HeapWord*) ((card - _table_base) << _card_shift);\n+  }\n+\n+  const CardValue* card_for(HeapWord* addr) {\n+    return &_table_base[uintptr_t(addr) >> _card_shift];\n+  }\n+\n+  bool is_dirty(const CardValue* const card) {\n+    return !is_clean(card);\n+  }\n+\n+  bool is_clean(const CardValue* const card) {\n+    assert(card >= _table && card <  &_table[PSCardTable::num_cards_in_stripe], \"out of bounds\");\n+    return *card == PSCardTable::clean_card_val();\n+  }\n+\n+  const CardValue* find_first_dirty_card(const CardValue* const start,\n+                                         const CardValue* const end) {\n+    for (const CardValue* i = start; i < end; ++i) {\n+      if (is_dirty(i)) {\n+        return i;\n+      }\n@@ -162,3 +195,9 @@\n-    \/\/ This final obj extends beyond i_card, check if this new card is dirty.\n-    if (*final_card_by_obj == PSCardTable::clean_card_val()) {\n-      return final_card_by_obj;\n+    return end;\n+  }\n+\n+  const CardValue* find_first_clean_card(const CardValue* const start,\n+                                         const CardValue* const end) {\n+    for (const CardValue* i = start; i < end; ++i) {\n+      if (is_clean(i)) {\n+        return i;\n+      }\n@@ -166,2 +205,1 @@\n-    \/\/ This new card is dirty, continuing the search...\n-    i_card = final_card_by_obj + 1;\n+    return end;\n@@ -169,2 +207,14 @@\n-  return end_card;\n-}\n+};\n+\n+template <typename Func>\n+void PSCardTable::process_range(Func&& object_start,\n+                                PSPromotionManager* pm,\n+                                HeapWord* const start,\n+                                HeapWord* const end) {\n+  assert(start < end, \"precondition\");\n+  assert(is_card_aligned(start), \"precondition\");\n+\n+  PSStripeShadowCardTable sct(this, start, end);\n+\n+  \/\/ end might not be card-aligned.\n+  const CardValue* end_card = sct.card_for(end - 1) + 1;\n@@ -172,3 +222,49 @@\n-void PSCardTable::clear_cards(CardValue* const start, CardValue* const end) {\n-  for (CardValue* i_card = start; i_card < end; ++i_card) {\n-    *i_card = clean_card;\n+  for (HeapWord* i_addr = start; i_addr < end; \/* empty *\/) {\n+    const CardValue* dirty_l = sct.find_first_dirty_card(sct.card_for(i_addr), end_card);\n+    const CardValue* dirty_r = sct.find_first_clean_card(dirty_l, end_card);\n+\n+    assert(dirty_l <= dirty_r, \"inv\");\n+\n+    if (dirty_l == dirty_r) {\n+      assert(dirty_r == end_card, \"inv\");\n+      break;\n+    }\n+\n+    \/\/ Located a non-empty dirty chunk [dirty_l, dirty_r).\n+    HeapWord* addr_l = sct.addr_for(dirty_l);\n+    HeapWord* addr_r = MIN2(sct.addr_for(dirty_r), end);\n+\n+    \/\/ Scan objects overlapping [addr_l, addr_r) limited to [start, end).\n+    HeapWord* obj_addr = object_start(addr_l);\n+\n+    while (true) {\n+      assert(obj_addr < addr_r, \"inv\");\n+\n+      oop obj = cast_to_oop(obj_addr);\n+      const bool is_obj_array = obj->is_objArray();\n+      HeapWord* const obj_end_addr = obj_addr + obj->size();\n+\n+      if (is_obj_array) {\n+        \/\/ Always scan obj arrays precisely (they are always marked precisely)\n+        \/\/ to avoid unnecessary work.\n+        scan_obj_with_limit(pm, obj, addr_l, addr_r);\n+      } else {\n+        if (obj_addr < i_addr && i_addr > start) {\n+          \/\/ Already scanned this object. Has been one that spans multiple dirty chunks.\n+          \/\/ The second condition makes sure objects reaching in the stripe are scanned once.\n+        } else {\n+          scan_obj_with_limit(pm, obj, addr_l, end);\n+        }\n+      }\n+\n+      if (obj_end_addr >= addr_r) {\n+        i_addr = is_obj_array ? addr_r : obj_end_addr;\n+        break;\n+      }\n+\n+      \/\/ Move to next obj inside this dirty chunk.\n+      obj_addr = obj_end_addr;\n+    }\n+\n+    \/\/ Finished a dirty chunk.\n+    pm->drain_stacks_cond_depth();\n@@ -178,10 +274,30 @@\n-void PSCardTable::scan_objects_in_range(PSPromotionManager* pm,\n-                                        HeapWord* start,\n-                                        HeapWord* end) {\n-  HeapWord* obj_addr = start;\n-  while (obj_addr < end) {\n-    oop obj = cast_to_oop(obj_addr);\n-    assert(oopDesc::is_oop(obj), \"inv\");\n-    prefetch_write(obj_addr);\n-    pm->push_contents(obj);\n-    obj_addr += obj->size();\n+template <typename Func>\n+void PSCardTable::preprocess_card_table_parallel(Func&& object_start,\n+                                                 HeapWord* old_gen_bottom,\n+                                                 HeapWord* old_gen_top,\n+                                                 uint stripe_index,\n+                                                 uint n_stripes) {\n+  const size_t num_cards_in_slice = num_cards_in_stripe * n_stripes;\n+  CardValue* cur_card = byte_for(old_gen_bottom) + stripe_index * num_cards_in_stripe;\n+  CardValue* const end_card = byte_for(old_gen_top - 1) + 1;\n+\n+  for (\/* empty *\/; cur_card < end_card; cur_card += num_cards_in_slice) {\n+    HeapWord* stripe_addr = addr_for(cur_card);\n+    if (is_dirty(cur_card)) {\n+      \/\/ The first card of this stripe is already dirty, no need to see if the\n+      \/\/ reaching-in object is a potentially imprecisely marked non-array\n+      \/\/ object.\n+      continue;\n+    }\n+    HeapWord* first_obj_addr = object_start(stripe_addr);\n+    if (first_obj_addr == stripe_addr) {\n+      \/\/ No object reaching into this stripe.\n+      continue;\n+    }\n+    oop first_obj = cast_to_oop(first_obj_addr);\n+    if (!first_obj->is_array() && is_dirty(byte_for(first_obj_addr))) {\n+      \/\/ Found a non-array object reaching into the stripe that has\n+      \/\/ potentially been marked imprecisely. Mark first card of the stripe\n+      \/\/ dirty so it will be processed later.\n+      *cur_card = dirty_card_val();\n+    }\n@@ -189,1 +305,0 @@\n-  pm->drain_stacks_cond_depth();\n@@ -230,0 +345,8 @@\n+\/\/ Scavenging and accesses to the card table are strictly limited to the stripe.\n+\/\/ In particular scavenging of an object crossing stripe boundaries is shared\n+\/\/ among the threads assigned to the stripes it resides on. This reduces\n+\/\/ complexity and enables shared scanning of large objects.\n+\/\/ It requires preprocessing of the card table though where imprecise card marks of\n+\/\/ objects crossing stripe boundaries are propagated to the first card of\n+\/\/ each stripe covered by the individual object.\n+\n@@ -231,2 +354,2 @@\n-                                             MutableSpace* sp,\n-                                             HeapWord* space_top,\n+                                             HeapWord* old_gen_bottom,\n+                                             HeapWord* old_gen_top,\n@@ -236,14 +359,11 @@\n-  const size_t num_cards_in_stripe = 128;\n-  const size_t stripe_size_in_words = num_cards_in_stripe * _card_size_in_words;\n-  const size_t slice_size_in_words = stripe_size_in_words * n_stripes;\n-\n-  HeapWord* cur_stripe_addr = sp->bottom() + stripe_index * stripe_size_in_words;\n-\n-  for (\/* empty *\/; cur_stripe_addr < space_top; cur_stripe_addr += slice_size_in_words) {\n-    \/\/ exclusive\n-    HeapWord* const cur_stripe_end_addr = MIN2(cur_stripe_addr + stripe_size_in_words,\n-                                               space_top);\n-\n-    \/\/ Process a stripe iff it contains any obj-start\n-    if (!start_array->object_starts_in_range(cur_stripe_addr, cur_stripe_end_addr)) {\n-      continue;\n+  \/\/ ObjectStartArray queries can be expensive for large objects. We cache known objects.\n+  struct {\n+    HeapWord* start_addr;\n+    HeapWord* end_addr;\n+  } cached_obj {nullptr, old_gen_bottom};\n+\n+  \/\/ Queries must be monotonic because we don't check addr >= cached_obj.start_addr.\n+  auto object_start = [&] (HeapWord* addr) {\n+    if (addr < cached_obj.end_addr) {\n+      assert(cached_obj.start_addr != nullptr, \"inv\");\n+      return cached_obj.start_addr;\n@@ -251,0 +371,1 @@\n+    HeapWord* result = start_array->object_start(addr);\n@@ -252,21 +373,2 @@\n-    \/\/ Constraints:\n-    \/\/ 1. range of cards checked for being dirty or clean: [iter_limit_l, iter_limit_r)\n-    \/\/ 2. range of cards can be cleared: [clear_limit_l, clear_limit_r)\n-    \/\/ 3. range of objs (obj-start) can be scanned: [first_obj_addr, cur_stripe_end_addr)\n-\n-    CardValue* iter_limit_l;\n-    CardValue* iter_limit_r;\n-    CardValue* clear_limit_l;\n-    CardValue* clear_limit_r;\n-\n-    \/\/ Identify left ends and the first obj-start inside this stripe.\n-    HeapWord* first_obj_addr = start_array->object_start(cur_stripe_addr);\n-    if (first_obj_addr < cur_stripe_addr) {\n-      \/\/ this obj belongs to previous stripe; can't clear any cards it occupies\n-      first_obj_addr += cast_to_oop(first_obj_addr)->size();\n-      clear_limit_l = byte_for(first_obj_addr - 1) + 1;\n-      iter_limit_l = byte_for(first_obj_addr);\n-    } else {\n-      assert(first_obj_addr == cur_stripe_addr, \"inv\");\n-      iter_limit_l = clear_limit_l = byte_for(cur_stripe_addr);\n-    }\n+    cached_obj.start_addr = result;\n+    cached_obj.end_addr = result + cast_to_oop(result)->size();\n@@ -274,2 +376,2 @@\n-    assert(cur_stripe_addr <= first_obj_addr, \"inside this stripe\");\n-    assert(first_obj_addr <= cur_stripe_end_addr, \"can be empty\");\n+    return result;\n+  };\n@@ -277,31 +379,2 @@\n-    {\n-      \/\/ Identify right ends.\n-      HeapWord* obj_addr = start_array->object_start(cur_stripe_end_addr - 1);\n-      HeapWord* obj_end_addr = obj_addr + cast_to_oop(obj_addr)->size();\n-      assert(obj_end_addr >= cur_stripe_end_addr, \"inv\");\n-      clear_limit_r = byte_for(obj_end_addr);\n-      iter_limit_r = byte_for(obj_end_addr - 1) + 1;\n-    }\n-\n-    assert(iter_limit_l <= clear_limit_l &&\n-           clear_limit_r <= iter_limit_r, \"clear cards only if we iterate over them\");\n-\n-    \/\/ Process dirty chunks, i.e. consecutive dirty cards [dirty_l, dirty_r),\n-    \/\/ chunk by chunk inside [iter_limit_l, iter_limit_r).\n-    CardValue* dirty_l;\n-    CardValue* dirty_r;\n-\n-    for (CardValue* cur_card = iter_limit_l; cur_card < iter_limit_r; cur_card = dirty_r + 1) {\n-      dirty_l = find_first_dirty_card(cur_card, iter_limit_r);\n-      dirty_r = find_first_clean_card(start_array, dirty_l, iter_limit_r);\n-      assert(dirty_l <= dirty_r, \"inv\");\n-\n-      \/\/ empty\n-      if (dirty_l == dirty_r) {\n-        assert(dirty_r == iter_limit_r, \"no more dirty cards in this stripe\");\n-        break;\n-      }\n-\n-      assert(*dirty_l != clean_card, \"inv\");\n-      assert(*dirty_r == clean_card || dirty_r >= clear_limit_r,\n-             \"clean card or belonging to next stripe\");\n+  \/\/ Prepare scavenge.\n+  preprocess_card_table_parallel(object_start, old_gen_bottom, old_gen_top, stripe_index, n_stripes);\n@@ -309,11 +382,6 @@\n-      \/\/ Process this non-empty dirty chunk in two steps:\n-      {\n-        \/\/ 1. Clear card in [dirty_l, dirty_r) subject to [clear_limit_l, clear_limit_r) constraint\n-        clear_cards(MAX2(dirty_l, clear_limit_l),\n-                    MIN2(dirty_r, clear_limit_r));\n-      }\n-\n-      {\n-        \/\/ 2. Scan objs in [dirty_l, dirty_r) subject to [first_obj_addr, cur_stripe_end_addr) constraint\n-        HeapWord* obj_l = MAX2(start_array->object_start(addr_for(dirty_l)),\n-                               first_obj_addr);\n+  \/\/ Sync with other workers.\n+  Atomic::dec(&_preprocessing_active_workers);\n+  SpinYield spin_yield;\n+  while (Atomic::load_acquire(&_preprocessing_active_workers) > 0) {\n+    spin_yield.wait();\n+  }\n@@ -321,2 +389,9 @@\n-        HeapWord* obj_r = MIN2(addr_for(dirty_r),\n-                               cur_stripe_end_addr);\n+  \/\/ Scavenge\n+  cached_obj = {nullptr, old_gen_bottom};\n+  const size_t stripe_size_in_words = num_cards_in_stripe * _card_size_in_words;\n+  const size_t slice_size_in_words = stripe_size_in_words * n_stripes;\n+  HeapWord* cur_addr = old_gen_bottom + stripe_index * stripe_size_in_words;\n+  for (\/* empty *\/; cur_addr < old_gen_top; cur_addr += slice_size_in_words) {\n+    HeapWord* const stripe_l = cur_addr;\n+    HeapWord* const stripe_r = MIN2(cur_addr + stripe_size_in_words,\n+                                    old_gen_top);\n@@ -324,3 +399,1 @@\n-        scan_objects_in_range(pm, obj_l, obj_r);\n-      }\n-    }\n+    process_range(object_start, pm, stripe_l, stripe_r);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":212,"deletions":139,"binary":false,"changes":351,"status":"modified"},{"patch":"@@ -36,1 +36,29 @@\n- private:\n+  friend class PSStripeShadowCardTable;\n+  static constexpr size_t num_cards_in_stripe = 128;\n+  static_assert(num_cards_in_stripe >= 1, \"progress\");\n+\n+  volatile int _preprocessing_active_workers;\n+\n+  bool is_dirty(CardValue* card) {\n+    return !is_clean(card);\n+  }\n+\n+  bool is_clean(CardValue* card) {\n+    return *card == clean_card_val();\n+  }\n+\n+  \/\/ Iterate the stripes with the given index and copy imprecise card marks of\n+  \/\/ objects reaching into a stripe to its first card.\n+  template <typename Func>\n+  void preprocess_card_table_parallel(Func&& object_start,\n+                                      HeapWord* old_gen_bottom,\n+                                      HeapWord* old_gen_top,\n+                                      uint stripe_index,\n+                                      uint n_stripes);\n+\n+  \/\/ Scavenge contents on dirty cards of the given stripe [start, end).\n+  template <typename Func>\n+  void process_range(Func&& object_start,\n+                     PSPromotionManager* pm,\n+                     HeapWord* const start,\n+                     HeapWord* const end);\n@@ -45,12 +73,4 @@\n-  CardValue* find_first_dirty_card(CardValue* const start_card,\n-                                   CardValue* const end_card);\n-\n-  CardValue* find_first_clean_card(ObjectStartArray* start_array,\n-                                   CardValue* const start_card,\n-                                   CardValue* const end_card);\n-\n-  void clear_cards(CardValue* const start, CardValue* const end);\n-\n-  void scan_objects_in_range(PSPromotionManager* pm,\n-                             HeapWord* start,\n-                             HeapWord* end);\n+  void scan_obj_with_limit(PSPromotionManager* pm,\n+                           oop obj,\n+                           HeapWord* start,\n+                           HeapWord* end);\n@@ -59,1 +79,2 @@\n-  PSCardTable(MemRegion whole_heap) : CardTable(whole_heap) {}\n+  PSCardTable(MemRegion whole_heap) : CardTable(whole_heap),\n+                                      _preprocessing_active_workers(0) {}\n@@ -65,0 +86,2 @@\n+  void pre_scavenge(HeapWord* old_gen_bottom, uint active_workers);\n+  \/\/ Scavenge contents of stripes with the given index.\n@@ -66,2 +89,2 @@\n-                                  MutableSpace* sp,\n-                                  HeapWord* space_top,\n+                                  HeapWord* old_gen_bottom,\n+                                  HeapWord* old_gen_top,\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.hpp","additions":39,"deletions":16,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -180,0 +180,1 @@\n+  void push_contents_bounded(oop obj, HeapWord* left, HeapWord* right);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -134,0 +134,5 @@\n+inline void PSPromotionManager::push_contents_bounded(oop obj, HeapWord* left, HeapWord* right) {\n+  PSPushContentsClosure pcc(this);\n+  obj->oop_iterate(&pcc, MemRegion(left, right));\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -90,1 +90,0 @@\n-  PSScavengeRootsClosure roots_closure(pm);\n@@ -304,0 +303,5 @@\n+\n+    if (!_is_old_gen_empty) {\n+      PSCardTable* card_table = ParallelScavengeHeap::heap()->card_table();\n+      card_table->pre_scavenge(_old_gen->object_space()->bottom(), active_workers);\n+    }\n@@ -317,0 +321,1 @@\n+        \/\/ The top of the old gen changes during scavenge when objects are promoted.\n@@ -318,1 +323,1 @@\n-                                               _old_gen->object_space(),\n+                                               _old_gen->object_space()->bottom(),\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"}]}