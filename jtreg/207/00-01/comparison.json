{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,3 @@\n+import java.time.Duration;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n@@ -33,0 +36,1 @@\n+import java.util.Map;\n@@ -112,0 +116,4 @@\n+        \/\/ keeps track of the test start time for each test\n+        private final Map<ITestResult, Long> startTimeNanos =\n+                Collections.synchronizedMap(new IdentityHashMap<>());\n+\n@@ -115,1 +123,5 @@\n-\/\/            report(itr);\n+            \/\/ Although testng itself provides getStartMillis() and getEndMillis()\n+            \/\/ on ITestResult for duration tracking, the testng implementation uses\n+            \/\/ System.currentTimeMillis(). We instead prefer using System.nanoTime() API\n+            \/\/ for duration tracking.\n+            startTimeNanos.put(itr, System.nanoTime());\n@@ -188,1 +200,5 @@\n-            long durationMillis = itr.getEndMillis() - itr.getStartMillis();\n+            Long startNanos = startTimeNanos.remove(itr);\n+            Duration duration = startNanos == null\n+                    ? Duration.ZERO\n+                    : Duration.ofNanos(System.nanoTime() - startNanos);\n+            long durationMillis = duration.toMillis();\n","filename":"src\/share\/classes\/com\/sun\/javatest\/regtest\/agent\/TestNGRunner.java","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    public void alwaysSkip() {\n+    public void alwaysSkip() throws Exception {\n@@ -49,0 +49,1 @@\n+        Thread.sleep(2);\n","filename":"test\/testngTestDuration\/Test.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}