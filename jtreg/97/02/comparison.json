{"files":[{"patch":"@@ -285,2 +285,2 @@\n-        final Set<String> platforms = new TreeSet<>();\n-        final Map<String, Info> infoTable = new HashMap<>();\n+        final transient Set<String> platforms = new TreeSet<>();\n+        final transient Map<String, Info> infoTable = new HashMap<>();\n","filename":"src\/share\/classes\/com\/sun\/javatest\/diff\/SuperDiff.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-    protected long getProcessId(Process proc) {\n+    public long getProcessId(Process proc) {\n","filename":"src\/share\/classes\/com\/sun\/javatest\/regtest\/TimeoutHandler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.ProcessHandle;\n@@ -36,0 +37,2 @@\n+import java.util.Optional;\n+import java.util.stream.Stream;\n@@ -246,0 +249,1 @@\n+            Alarm pre_alarm = Alarm.NONE;\n@@ -248,0 +252,1 @@\n+            final long PRE_ALARM_TIME_MS = 5000;\n@@ -251,3 +256,20 @@\n-                alarm = Alarm.schedule(timeout, TimeUnit.MILLISECONDS, out, new Runnable() {\n-                    public void run() {\n-                        invokeTimeoutHandler(timeoutHandler, timeoutHandlerDone, process, victim);\n+                pre_alarm = Alarm.schedule(timeout, TimeUnit.MILLISECONDS, out, new Runnable() {\n+                  \/\/ at the timeout, as the last resort, we will exit all the (possibly hanging),\n+                  \/\/ descendants of the process, in the hope that doing so will unstuck the process itself\n+                  public void run() {\n+                    long pid = getTimeoutHandler().getProcessId(process);\n+                    Optional<ProcessHandle> oph = ProcessHandle.of(pid);\n+                    if (oph.isPresent()) {\n+                      ProcessHandle processHandle = oph.get();\n+                      Stream<ProcessHandle> descendants = processHandle.descendants();\n+                      long count = descendants.count();\n+                      if (count > 0) {\n+                        err.println(\"Detected a possibly stuck process (pid:\"+pid+\") with \"+count+\" descendants\");\n+                        err.println(\"Attempting to kill:\");\n+                        descendants = processHandle.descendants();\n+                        descendants.forEachOrdered(child -> err.println(\" child process with pid:\"+child.pid()));\n+                        descendants = processHandle.descendants();\n+                        descendants.forEachOrdered(child -> child.destroy());\n+                        descendants = processHandle.descendants();\n+                        descendants.forEachOrdered(child -> child.destroyForcibly());\n+                      }\n@@ -255,0 +277,7 @@\n+                  }\n+                });\n+                alarm = Alarm.schedule(timeout+PRE_ALARM_TIME_MS, TimeUnit.MILLISECONDS, out, new Runnable() {\n+                  \/\/ if we reach here, then we tried everything and the only option now is to timeout\n+                  public void run() {\n+                    invokeTimeoutHandler(timeoutHandler, timeoutHandlerDone, process, victim);\n+                  }\n@@ -274,0 +303,1 @@\n+                pre_alarm.cancel();\n@@ -280,0 +310,1 @@\n+                pre_alarm.cancel();\n","filename":"src\/share\/classes\/com\/sun\/javatest\/regtest\/exec\/ProcessCommand.java","additions":34,"deletions":3,"binary":false,"changes":37,"status":"modified"}]}