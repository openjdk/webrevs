{"files":[{"patch":"@@ -58,0 +58,2 @@\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+\n@@ -62,0 +64,6 @@\n+    \/**\n+     * The handshake bytes that the AgentServer sends over a Socket to the Agent\n+     * to complete the communication handshake\n+     *\/\n+    public static final byte[] JTREG_AGENT_HANDSHAKE_MAGIC = \"jtreg\".getBytes(US_ASCII);\n+\n@@ -185,1 +193,1 @@\n-        }   else {\n+            } else {\n@@ -213,0 +221,3 @@\n+            log(\"Connected to \" + s.getRemoteSocketAddress() + \", now sending handshake bytes\");\n+            \/\/ before doing anything, complete the handshake with the other side\n+            writeHandshakeMagicBytes(s);\n@@ -234,0 +245,6 @@\n+    private static void writeHandshakeMagicBytes(final Socket s) throws IOException {\n+        final OutputStream os = s.getOutputStream();\n+        os.write(JTREG_AGENT_HANDSHAKE_MAGIC);\n+        os.flush();\n+    }\n+\n","filename":"src\/share\/classes\/com\/sun\/javatest\/regtest\/agent\/AgentServer.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import java.util.Arrays;\n@@ -150,1 +151,5 @@\n-            ss.bind(new InetSocketAddress(loopbackAddr, \/*port:*\/ 0), \/*backlog:*\/ 1);\n+            \/\/ We allow for some unexpected processes to connect to the port we listen on.\n+            \/\/ We discard such connections if, after connecting, our internal handshake fails.\n+            final int maxAcceptAttempts = 3;\n+            final int backlog = maxAcceptAttempts;\n+            ss.bind(new InetSocketAddress(loopbackAddr, \/*port:*\/ 0), backlog);\n@@ -185,6 +190,18 @@\n-                log(\"Waiting up to \" + ACCEPT_TIMEOUT + \" milli seconds for a\" +\n-                        \" socket connection on port \" + port +\n-                        (pid != UNKNOWN_PID ? \" from process \" + pid : \"\"));\n-                Socket s = ss.accept();\n-                log(\"Received connection on port \" + port + \" from \" + s);\n-                s.setSoTimeout((int)(KeepAlive.READ_TIMEOUT * timeoutFactor));\n+                final int readTimeout = (int) (KeepAlive.READ_TIMEOUT * timeoutFactor);\n+                Socket s = null;\n+                for (int i = 0; i < maxAcceptAttempts; i++) {\n+                    log(\"Waiting up to \" + ACCEPT_TIMEOUT + \" milliseconds for a\" +\n+                            \" socket connection on port \" + port +\n+                            (pid != UNKNOWN_PID ? \" from process \" + pid : \"\"));\n+                    s = acceptAndHandshake(ss, readTimeout);\n+                    if (s != null) {\n+                        \/\/ successful accept() and handshake\n+                        break;\n+                    }\n+                }\n+                if (s == null) {\n+                    throw new IOException(\"could not complete handshake with AgentServer after \"\n+                            + maxAcceptAttempts + \" attempts\");\n+                }\n+                log(\"Successful handshake on port \" + port + \" from \" + s);\n+                s.setSoTimeout(readTimeout);\n@@ -215,0 +232,40 @@\n+    \/\/ accept()s a connection over the ServerSocket and then reads handshake bytes\n+    \/\/ from the connected socket. If the read bytes match the expected handshake bytes\n+    \/\/ then the connection and handshake is considered successful and the accepted\n+    \/\/ Socket is returned. If the read bytes don't match the expected handshake bytes\n+    \/\/ or if the read times out after accept()ing an connection, then this method\n+    \/\/ closes the accepted connection and returns null.\n+    private Socket acceptAndHandshake(final ServerSocket ss, final int handshakeReadTimeout)\n+            throws IOException {\n+        final Socket s = ss.accept();\n+        try {\n+            log(\"Received connection on port \" + ss.getLocalPort() + \" from \" + s);\n+            s.setSoTimeout(handshakeReadTimeout);\n+            \/\/ read the handshake bytes\n+            final byte[] handshakeBytes = new byte[JTREG_AGENT_HANDSHAKE_MAGIC.length];\n+            final int numRead = s.getInputStream().read(handshakeBytes);\n+            if (numRead == -1) {\n+                \/\/ EOF\n+                log(\"Received EOF before handshake from \" + s);\n+                return null;\n+            }\n+            \/\/ verify the handshake bytes\n+            if (!Arrays.equals(JTREG_AGENT_HANDSHAKE_MAGIC, handshakeBytes)) {\n+                log(\"Unexpected handshake bytes from socket: \" + s + \", expected: \"\n+                        + Arrays.toString(JTREG_AGENT_HANDSHAKE_MAGIC)\n+                        + \", actual: \" + Arrays.toString(handshakeBytes));\n+                return null;\n+            }\n+        } catch (IOException ioe) {\n+            log(\"closing connection to \" + s + \" due to: \" + ioe);\n+            try {\n+                s.close();\n+            } catch (IOException ignored) {\n+                \/\/ ignore\n+            }\n+            return null;\n+        }\n+        \/\/ got the expected handshake bytes\n+        return s;\n+    }\n+\n","filename":"src\/share\/classes\/com\/sun\/javatest\/regtest\/exec\/Agent.java","additions":64,"deletions":7,"binary":false,"changes":71,"status":"modified"}]}