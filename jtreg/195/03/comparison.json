{"files":[{"patch":"@@ -58,0 +58,2 @@\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+\n@@ -62,0 +64,6 @@\n+    \/**\n+     * The handshake bytes that the AgentServer sends over a Socket to the Agent\n+     * to complete the communication handshake\n+     *\/\n+    public static final byte[] JTREG_AGENT_HANDSHAKE_MAGIC = \"jtreg\".getBytes(US_ASCII);\n+\n@@ -185,1 +193,1 @@\n-        }   else {\n+            } else {\n@@ -213,0 +221,3 @@\n+            log(\"Connected to \" + s.getRemoteSocketAddress() + \", now sending handshake bytes\");\n+            \/\/ before doing anything, complete the handshake with the other side\n+            writeHandshakeMagicBytes(s);\n@@ -234,0 +245,6 @@\n+    private static void writeHandshakeMagicBytes(final Socket s) throws IOException {\n+        final OutputStream os = s.getOutputStream();\n+        os.write(JTREG_AGENT_HANDSHAKE_MAGIC);\n+        os.flush();\n+    }\n+\n","filename":"src\/share\/classes\/com\/sun\/javatest\/regtest\/agent\/AgentServer.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import java.util.Arrays;\n@@ -102,0 +103,5 @@\n+    \/\/ We tolerate a certain number of connection attempts from unexpected processes\n+    \/\/ on the port we listen on. We discard such connections if, after connecting,\n+    \/\/ our internal handshake fails.\n+    private static final int MAX_ACCEPT_ATTEMPTS = 3;\n+\n@@ -150,1 +156,2 @@\n-            ss.bind(new InetSocketAddress(loopbackAddr, \/*port:*\/ 0), \/*backlog:*\/ 1);\n+            final int backlog = MAX_ACCEPT_ATTEMPTS;\n+            ss.bind(new InetSocketAddress(loopbackAddr, \/*port:*\/ 0), backlog);\n@@ -185,6 +192,18 @@\n-                log(\"Waiting up to \" + ACCEPT_TIMEOUT + \" milli seconds for a\" +\n-                        \" socket connection on port \" + port +\n-                        (pid != UNKNOWN_PID ? \" from process \" + pid : \"\"));\n-                Socket s = ss.accept();\n-                log(\"Received connection on port \" + port + \" from \" + s);\n-                s.setSoTimeout((int)(KeepAlive.READ_TIMEOUT * timeoutFactor));\n+                final int readTimeout = (int) (KeepAlive.READ_TIMEOUT * timeoutFactor);\n+                Socket s = null;\n+                for (int i = 0; i < MAX_ACCEPT_ATTEMPTS; i++) {\n+                    log(\"Waiting up to \" + ACCEPT_TIMEOUT + \" milliseconds for a\" +\n+                            \" socket connection on port \" + port +\n+                            (pid != UNKNOWN_PID ? \" from process \" + pid : \"\"));\n+                    s = acceptAndHandshake(ss, readTimeout);\n+                    if (s != null) {\n+                        \/\/ successful accept() and handshake\n+                        break;\n+                    }\n+                }\n+                if (s == null) {\n+                    throw new IOException(\"could not complete handshake with AgentServer after \"\n+                            + MAX_ACCEPT_ATTEMPTS + \" attempts\");\n+                }\n+                log(\"Successful handshake on port \" + port + \" from \" + s);\n+                s.setSoTimeout(readTimeout);\n@@ -215,0 +234,54 @@\n+    \/\/ accept()s a connection over the ServerSocket and then reads handshake bytes\n+    \/\/ from the connected socket. If the read bytes match the expected handshake bytes\n+    \/\/ then the connection and handshake is considered successful and the accepted\n+    \/\/ Socket is returned. If the read bytes don't match the expected handshake bytes\n+    \/\/ or if the read times out after accept()ing an connection, then this method\n+    \/\/ closes the accepted connection and returns null.\n+    private Socket acceptAndHandshake(final ServerSocket ss, final int handshakeReadTimeout)\n+            throws IOException {\n+        final byte[] handshakeBytes;\n+        int totalRead = 0;\n+        final Socket s = ss.accept();\n+        try {\n+            log(\"Received connection on port \" + ss.getLocalPort() + \" from \" + s);\n+            s.setSoTimeout(handshakeReadTimeout);\n+            \/\/ read the handshake bytes\n+            handshakeBytes = new byte[JTREG_AGENT_HANDSHAKE_MAGIC.length];\n+            while (totalRead < JTREG_AGENT_HANDSHAKE_MAGIC.length) {\n+                final int numRead = s.getInputStream().read(handshakeBytes,\n+                        totalRead, (JTREG_AGENT_HANDSHAKE_MAGIC.length - totalRead));\n+                if (numRead == -1) {\n+                    break;\n+                }\n+                totalRead += numRead;\n+            }\n+        } catch (IOException ioe) {\n+            try {\n+                s.close();\n+            } catch (IOException closeFailure) {\n+                if (closeFailure != ioe) {\n+                    ioe.addSuppressed(closeFailure);\n+                }\n+            }\n+            log(\"closed the connection to \" + s + \" due to: \" + ioe);\n+            ioe.printStackTrace(); \/\/ log the read failure stacktrace\n+            return null;\n+        }\n+        if (totalRead != JTREG_AGENT_HANDSHAKE_MAGIC.length) {\n+            \/\/ we don't expect to read more than handshake bytes in this method\n+            assert totalRead < JTREG_AGENT_HANDSHAKE_MAGIC.length : \"unexpected number of\" +\n+                    \" handshake bytes read: \" + totalRead;\n+            log(\"handshake failed - \" + totalRead + \" bytes received from \" + s);\n+            return null;\n+        }\n+        \/\/ verify the handshake bytes\n+        if (!Arrays.equals(JTREG_AGENT_HANDSHAKE_MAGIC, handshakeBytes)) {\n+            log(\"Unexpected handshake bytes from socket: \" + s\n+                    + \", expected: \" + Arrays.toString(JTREG_AGENT_HANDSHAKE_MAGIC)\n+                    + \", actual: \" + Arrays.toString(handshakeBytes));\n+            return null;\n+        }\n+        \/\/ got the expected handshake bytes\n+        return s;\n+    }\n+\n","filename":"src\/share\/classes\/com\/sun\/javatest\/regtest\/exec\/Agent.java","additions":80,"deletions":7,"binary":false,"changes":87,"status":"modified"}]}