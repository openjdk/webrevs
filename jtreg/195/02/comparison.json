{"files":[{"patch":"@@ -58,0 +58,2 @@\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+\n@@ -62,0 +64,6 @@\n+    \/**\n+     * The handshake bytes that the AgentServer sends over a Socket to the Agent\n+     * to complete the communication handshake\n+     *\/\n+    public static final byte[] JTREG_AGENT_HANDSHAKE_MAGIC = \"jtreg\".getBytes(US_ASCII);\n+\n@@ -185,1 +193,1 @@\n-        }   else {\n+            } else {\n@@ -213,0 +221,3 @@\n+            log(\"Connected to \" + s.getRemoteSocketAddress() + \", now sending handshake bytes\");\n+            \/\/ before doing anything, complete the handshake with the other side\n+            writeHandshakeMagicBytes(s);\n@@ -234,0 +245,6 @@\n+    private static void writeHandshakeMagicBytes(final Socket s) throws IOException {\n+        final OutputStream os = s.getOutputStream();\n+        os.write(JTREG_AGENT_HANDSHAKE_MAGIC);\n+        os.flush();\n+    }\n+\n","filename":"src\/share\/classes\/com\/sun\/javatest\/regtest\/agent\/AgentServer.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import java.util.Arrays;\n@@ -150,1 +151,5 @@\n-            ss.bind(new InetSocketAddress(loopbackAddr, \/*port:*\/ 0), \/*backlog:*\/ 1);\n+            \/\/ We allow for some unexpected processes to connect to the port we listen on.\n+            \/\/ We discard such connections if, after connecting, our internal handshake fails.\n+            final int maxAcceptAttempts = 3;\n+            final int backlog = maxAcceptAttempts;\n+            ss.bind(new InetSocketAddress(loopbackAddr, \/*port:*\/ 0), backlog);\n@@ -185,6 +190,18 @@\n-                log(\"Waiting up to \" + ACCEPT_TIMEOUT + \" milli seconds for a\" +\n-                        \" socket connection on port \" + port +\n-                        (pid != UNKNOWN_PID ? \" from process \" + pid : \"\"));\n-                Socket s = ss.accept();\n-                log(\"Received connection on port \" + port + \" from \" + s);\n-                s.setSoTimeout((int)(KeepAlive.READ_TIMEOUT * timeoutFactor));\n+                final int readTimeout = (int) (KeepAlive.READ_TIMEOUT * timeoutFactor);\n+                Socket s = null;\n+                for (int i = 0; i < maxAcceptAttempts; i++) {\n+                    log(\"Waiting up to \" + ACCEPT_TIMEOUT + \" milliseconds for a\" +\n+                            \" socket connection on port \" + port +\n+                            (pid != UNKNOWN_PID ? \" from process \" + pid : \"\"));\n+                    s = acceptAndHandshake(ss, readTimeout);\n+                    if (s != null) {\n+                        \/\/ successful accept() and handshake\n+                        break;\n+                    }\n+                }\n+                if (s == null) {\n+                    throw new IOException(\"could not complete handshake with AgentServer after \"\n+                            + maxAcceptAttempts + \" attempts\");\n+                }\n+                log(\"Successful handshake on port \" + port + \" from \" + s);\n+                s.setSoTimeout(readTimeout);\n@@ -215,0 +232,53 @@\n+    \/\/ accept()s a connection over the ServerSocket and then reads handshake bytes\n+    \/\/ from the connected socket. If the read bytes match the expected handshake bytes\n+    \/\/ then the connection and handshake is considered successful and the accepted\n+    \/\/ Socket is returned. If the read bytes don't match the expected handshake bytes\n+    \/\/ or if the read times out after accept()ing an connection, then this method\n+    \/\/ closes the accepted connection and returns null.\n+    private Socket acceptAndHandshake(final ServerSocket ss, final int handshakeReadTimeout)\n+            throws IOException {\n+        final Socket s = ss.accept();\n+        final byte[] handshakeBytes;\n+        int totalRead = 0;\n+        try {\n+            log(\"Received connection on port \" + ss.getLocalPort() + \" from \" + s);\n+            s.setSoTimeout(handshakeReadTimeout);\n+            \/\/ read the handshake bytes\n+            handshakeBytes = new byte[JTREG_AGENT_HANDSHAKE_MAGIC.length];\n+            while (totalRead < JTREG_AGENT_HANDSHAKE_MAGIC.length) {\n+                final int numRead = s.getInputStream().read(handshakeBytes,\n+                        totalRead, (JTREG_AGENT_HANDSHAKE_MAGIC.length - totalRead));\n+                if (numRead == -1) {\n+                    break;\n+                }\n+                totalRead += numRead;\n+            }\n+        } catch (IOException ioe) {\n+            log(\"closing connection to \" + s + \" due to: \" + ioe);\n+            try {\n+                s.close();\n+            } catch (IOException ignored) {\n+                \/\/ ignore\n+            }\n+            return null;\n+        }\n+        \/\/ we don't read more than handshake bytes in this method\n+        assert totalRead <= JTREG_AGENT_HANDSHAKE_MAGIC.length : \"unexpected number of handshake\" +\n+                \" bytes read: \" + totalRead;\n+\n+        if (totalRead < JTREG_AGENT_HANDSHAKE_MAGIC.length) {\n+            \/\/ EOF\n+            log(\"handshake failed - \" + totalRead + \" bytes received from \" + s);\n+            return null;\n+        }\n+        \/\/ verify the handshake bytes\n+        if (!Arrays.equals(JTREG_AGENT_HANDSHAKE_MAGIC, handshakeBytes)) {\n+            log(\"Unexpected handshake bytes from socket: \" + s\n+                    + \", expected: \" + Arrays.toString(JTREG_AGENT_HANDSHAKE_MAGIC)\n+                    + \", actual: \" + Arrays.toString(handshakeBytes));\n+            return null;\n+        }\n+        \/\/ got the expected handshake bytes\n+        return s;\n+    }\n+\n","filename":"src\/share\/classes\/com\/sun\/javatest\/regtest\/exec\/Agent.java","additions":77,"deletions":7,"binary":false,"changes":84,"status":"modified"}]}