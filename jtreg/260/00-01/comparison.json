{"files":[{"patch":"@@ -36,0 +36,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -46,0 +47,2 @@\n+    private static final AtomicReference<String> CURRENT_WRITER = new AtomicReference<>();\n+\n@@ -48,9 +51,2 @@\n-        tcSuiteStarted(testResult.getTestName(), getFileLocationHint(testResult));\n-    }\n-\n-    private static String getFileLocationHint(TestResult testResult) {\n-        try {\n-            return \"file:\/\/\" + testResult.getDescription().getFile().getCanonicalPath();\n-        } catch (TestResult.Fault | IOException e) {\n-            \/\/do nothing (leave location empty)\n-            return null;\n+        if (tryLock(testResult)) {\n+            tcSuiteStarted(testResult.getTestName(), getFileLocationHint(testResult));\n@@ -62,3 +58,42 @@\n-        reportJTRegResult(testResult);\n-        tryReportJUnitResults(testResult);\n-        tcSuiteFinished(testResult.getTestName());\n+        \/\/ For now, we synchronize all output, so that events displays correctly in the IDE\n+        \/\/ even when running tests concurrently (e.g. with -conc:auto).\n+        \/\/ There doesn't seem to be a way to write test events out of order, but still\n+        \/\/ have them display correctly in the IDE, except for writing out the entire\n+        \/\/ even tree first before any testing starts, but we can not do this as we don't\n+        \/\/ know which nested events we are going to get when running tests.\n+        \/\/ The downside of this is that some tests will only start to show up in the UI once they finish,\n+        \/\/ and some test events might 'stall' until a longer running test that grabbed the lock early has finished.\n+         try {\n+            if (!hasLock(testResult)) {\n+                lock(testResult);\n+                \/\/ The lock was held by another test in 'startingTest', so we write this event here.\n+                tcSuiteStarted(testResult.getTestName(), getFileLocationHint(testResult));\n+            }\n+            reportJTRegResult(testResult);\n+            tryReportJUnitResults(testResult);\n+            tcSuiteFinished(testResult.getTestName());\n+        } finally {\n+            \/\/ Release lock if we managed to grab it\/held it when entering this method\n+            \/\/ This might be false if an exception occurred before we managed to grab the lock.\n+            if (hasLock(testResult)) {\n+                releaseLock();\n+            }\n+        }\n+    }\n+\n+    private boolean tryLock(TestResult testResult) {\n+        return CURRENT_WRITER.compareAndSet(null, testResult.getTestName());\n+    }\n+\n+    private boolean hasLock(TestResult testResult) {\n+        return Objects.equals(CURRENT_WRITER.get(), testResult.getTestName());\n+    }\n+\n+    private void lock(TestResult testResult) {\n+        while (!CURRENT_WRITER.compareAndSet(null, testResult.getTestName())) {\n+            Thread.onSpinWait();\n+        }\n+    }\n+\n+    private void releaseLock() {\n+        CURRENT_WRITER.set(null);\n@@ -130,0 +165,9 @@\n+    private static String getFileLocationHint(TestResult testResult) {\n+        try {\n+            return \"file:\/\/\" + testResult.getDescription().getFile().getCanonicalPath();\n+        } catch (TestResult.Fault | IOException e) {\n+            \/\/do nothing (leave location empty)\n+            return null;\n+        }\n+    }\n+\n@@ -289,0 +333,6 @@\n+\n+    private static class ExclusiveLock<T> {\n+        private final AtomicReference<T> lock = new AtomicReference<>();\n+\n+    }\n+\n","filename":"plugins\/idea\/src\/main\/java\/com\/oracle\/plugin\/jtreg\/runtime\/JTRegTestListener.java","additions":62,"deletions":12,"binary":false,"changes":74,"status":"modified"}]}