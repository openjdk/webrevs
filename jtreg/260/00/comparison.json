{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import com.intellij.execution.Location;\n+import com.intellij.execution.PsiLocation;\n@@ -32,0 +34,1 @@\n+import com.intellij.execution.testframework.sm.runner.SMTestLocator;\n@@ -33,0 +36,8 @@\n+import com.intellij.openapi.project.Project;\n+import com.intellij.psi.JavaPsiFacade;\n+import com.intellij.psi.PsiClass;\n+import com.intellij.psi.PsiElement;\n+import com.intellij.psi.PsiMethod;\n+import com.intellij.psi.search.GlobalSearchScope;\n+import org.jetbrains.annotations.NonNls;\n+import org.jetbrains.annotations.NotNull;\n@@ -35,0 +46,2 @@\n+import java.util.List;\n+\n@@ -48,0 +61,54 @@\n+\n+    @Override\n+    public @Nullable SMTestLocator getTestLocator() {\n+        return JTRegTestLocator.INSTANCE;\n+    }\n+\n+    private static class JTRegTestLocator implements SMTestLocator {\n+\n+        private static final JTRegTestLocator INSTANCE = new JTRegTestLocator();\n+\n+        \/\/ parse our custom 'jtreg:\/\/...' location hint emitted by JTRegTestListener\n+        @Override\n+        public @NotNull List<Location> getLocation(@NonNls @NotNull String protocol,\n+                                                   @NonNls @NotNull String path,\n+                                                   @NonNls @NotNull Project project,\n+                                                   @NotNull GlobalSearchScope scope) {\n+            if (!protocol.equals(\"jtreg\")) {\n+                return List.of();\n+            }\n+\n+            String[] pathParts = path.split(\"\/\");\n+            String className = pathParts[0];\n+            String methodName = null;\n+            if (pathParts.length > 1) {\n+                methodName = pathParts[1];\n+            }\n+            JavaPsiFacade facade = JavaPsiFacade.getInstance(project);\n+            PsiClass cls = facade.findClass(className, scope);\n+            if (cls == null) {\n+                return List.of();\n+            }\n+\n+            if (methodName == null) {\n+                return List.of(PsiLocation.fromPsiElement(cls));\n+            }\n+\n+            PsiMethod[] methods = cls.findMethodsByName(methodName, false);\n+            if (methods.length == 1) {\n+                Location<PsiElement> location = PsiLocation.fromPsiElement(methods[0]);\n+                if (pathParts.length > 2) {\n+                    try {\n+                        int iterationNum = Integer.parseInt(pathParts[2]);\n+                        String iterationName = pathParts[3];\n+                        return List.of(new JTRegIterationLocation(location, iterationNum, iterationName));\n+                    } catch (NumberFormatException e) {\n+                        \/\/ fallthrough\n+                    }\n+                }\n+                return List.of(location);\n+            }\n+\n+            return List.of();\n+        }\n+    }\n","filename":"plugins\/idea\/src\/main\/java\/com\/oracle\/plugin\/jtreg\/configuration\/JTRegConfigurationConsoleProperties.java","additions":68,"deletions":1,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.oracle.plugin.jtreg.configuration;\n+\n+import com.intellij.execution.Location;\n+import com.intellij.openapi.module.Module;\n+import com.intellij.openapi.project.Project;\n+import com.intellij.psi.PsiElement;\n+import org.jetbrains.annotations.NotNull;\n+import org.jetbrains.annotations.Nullable;\n+\n+import java.util.Iterator;\n+\n+public class JTRegIterationLocation extends Location<PsiElement> {\n+\n+    private final Location<PsiElement> delegate;\n+    private final int testIteration;\n+    private final String iterationName;\n+\n+    public JTRegIterationLocation(Location<PsiElement> delegate, int testIteration, String iterationName) {\n+        this.delegate = delegate;\n+        this.testIteration = testIteration;\n+        this.iterationName = iterationName;\n+    }\n+\n+    public int getIteration() {\n+        return testIteration;\n+    }\n+\n+    public String getIterationName() {\n+        return iterationName;\n+    }\n+\n+    @Override\n+    public @NotNull PsiElement getPsiElement() {\n+        return delegate.getPsiElement();\n+    }\n+\n+    @Override\n+    public @NotNull Project getProject() {\n+        return delegate.getProject();\n+    }\n+\n+    @Override\n+    public @NotNull <T extends PsiElement> Iterator<Location<T>> getAncestors(Class<T> aClass, boolean b) {\n+        return delegate.getAncestors(aClass, b);\n+    }\n+\n+    @Override\n+    public @Nullable Module getModule() {\n+        return delegate.getModule();\n+    }\n+}\n","filename":"plugins\/idea\/src\/main\/java\/com\/oracle\/plugin\/jtreg\/configuration\/JTRegIterationLocation.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -47,0 +47,1 @@\n+import com.oracle.plugin.jtreg.configuration.JTRegIterationLocation;\n@@ -71,4 +72,3 @@\n-     * @see #isConfigurationFromContext\n-     * @see com.intellij.execution.application.AbstractApplicationConfigurationProducer#setupConfigurationFromContext\n-     * @see com.intellij.execution.testframework.AbstractInClassConfigurationProducer#setupConfigurationFromContext\n-     * @see com.intellij.psi.util.PsiTreeUtil#isAncestor\n+     * @see #setupConfigurationFromContext\n+     * @see com.intellij.execution.application.AbstractApplicationConfigurationProducer#isConfigurationFromContext\n+     * @see com.intellij.execution.testframework.AbstractInClassConfigurationProducer#isConfigurationFromContext\n@@ -100,0 +100,1 @@\n+            configuration.setName(nameForElement(element));\n@@ -110,1 +111,7 @@\n-            configuration.setQuery(getQuery(element));\n+            if (contextLocation instanceof JTRegIterationLocation iterationLocation) {\n+                configuration.setQuery(getQuery(element, iterationLocation.getIteration()));\n+                configuration.setName(nameForElement(element) + \" [\" + iterationLocation.getIterationName() + \"]\");\n+            } else {\n+                configuration.setQuery(getQuery(element, -1));\n+                configuration.setName(nameForElement(element));\n+            }\n@@ -112,1 +119,0 @@\n-        configuration.setName(nameForElement(element));\n@@ -197,1 +203,2 @@\n-        String contextQuery = getQuery(element);\n+        int iteration = contextLocation instanceof JTRegIterationLocation il ? il.getIteration() : -1;\n+        String contextQuery = getQuery(element, iteration);\n@@ -227,1 +234,1 @@\n-     * @see #getQuery(PsiElement)\n+     * @see #getQuery(PsiElement,int)\n@@ -254,1 +261,1 @@\n-    protected static String getQuery(PsiElement element) {\n+    private static String getQuery(PsiElement element, int iteration) {\n@@ -257,1 +264,9 @@\n-                return \"junit-select:method:\" + getJUnitMethodQuery(psiMethod);\n+                String query = \"junit-select:\";\n+                if (iteration != -1) {\n+                    query += \"iteration:\";\n+                }\n+                query += \"method:\" + getJUnitMethodQuery(psiMethod);\n+                if (iteration != -1) {\n+                    query += \"[\" + iteration + \"]\";\n+                }\n+                return query;\n","filename":"plugins\/idea\/src\/main\/java\/com\/oracle\/plugin\/jtreg\/configuration\/producers\/JTRegConfigurationProducer.java","additions":25,"deletions":10,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import com.sun.javatest.Parameters;\n@@ -34,1 +33,0 @@\n-import com.oracle.plugin.jtreg.util.MapSerializerUtil;\n@@ -36,1 +34,0 @@\n-import java.io.File;\n@@ -38,2 +35,4 @@\n-import java.nio.file.Files;\n-import java.util.stream.Collectors;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n@@ -48,2 +47,2 @@\n-    public void startingTestRun(Parameters parameters) {\n-        System.out.println(\"##teamcity[testSuiteStarted name=\\'jtreg\\']\");\n+    public void startingTest(TestResult testResult) {\n+        tcSuiteStarted(testResult.getTestName(), getFileLocationHint(testResult));\n@@ -52,3 +51,1 @@\n-    @Override\n-    public void startingTest(TestResult testResult) {\n-        String location = \"\";\n+    private static String getFileLocationHint(TestResult testResult) {\n@@ -56,1 +53,1 @@\n-            location = \"locationHint=\\'file:\/\/\" + testResult.getDescription().getFile().getCanonicalPath() + \"\\'\";\n+            return \"file:\/\/\" + testResult.getDescription().getFile().getCanonicalPath();\n@@ -59,0 +56,1 @@\n+            return null;\n@@ -60,2 +58,0 @@\n-        System.out.println(\"##teamcity[testStarted name=\\'\" + escapeName(testResult.getTestName()) + \"\\' \" +\n-                location + \"]\");\n@@ -66,2 +62,9 @@\n-        final Status status = testResult.getStatus();\n-        final File file = testResult.getFile();\n+        reportJTRegResult(testResult);\n+        tryReportJUnitResults(testResult);\n+        tcSuiteFinished(testResult.getTestName());\n+    }\n+\n+    private static void reportJTRegResult(TestResult testResult) {\n+        \/\/ report the overall jtreg results as a pseudo test called 'jtreg'\n+        tcTestStarted(\"jtreg\");\n+        Status status = testResult.getStatus();\n@@ -69,9 +72,1 @@\n-            if (file.isFile()) {\n-                final String output = loadText(file);\n-                if (output != null && output.length() > 0) {\n-                    System.out.println(\"##teamcity[testStdOut name=\\'\" + escapeName(testResult.getTestName()) + \"\\' \" +\n-                            \"out=\\'\" + escapeName(output) + \"\\']\");\n-                }\n-            }\n-            System.out.println(\"##teamcity[testFailed name=\\'\" + escapeName(testResult.getTestName()) + \"\\' \" +\n-                    \"message=\\'\" + escapeName(status.getReason()) + \"\\']\");\n+            tcTestFailed(\"jtreg\", status.getReason());\n@@ -79,1 +74,1 @@\n-            System.out.println(\"##teamcity[testIgnored name=\\'\" + escapeName(testResult.getTestName()) + \"\\']\");\n+            tcTestIgnored(\"jtreg\");\n@@ -82,1 +77,1 @@\n-        String duration = \"0\";\n+        String duration = null;\n@@ -88,4 +83,1 @@\n-        System.out.println(\"##teamcity[testFinished name=\\'\" + escapeName(testResult.getTestName()) + \"\\' \" +\n-                (!duration.equals(\"0\") ? \"duration=\\'\" + duration : \"\") + \"\\'\" +\n-                (!status.isFailed() ? \"outputFile=\\'\" + escapeName(file.getAbsolutePath()) + \"\\'\" : \"\") +\n-                \" ]\");\n+        tcTestFinished(\"jtreg\", duration, testResult.getFile().getAbsolutePath());\n@@ -94,3 +86,21 @@\n-    @Override\n-    public void stoppingTestRun() {\n-        \/\/do nothing\n+    private void tryReportJUnitResults(TestResult testResult) {\n+        \/\/ try to report each 'junit' section of the test results\n+        \/\/ by parsing the junit results from stderr\n+        for (int i = 0; i < testResult.getSectionCount(); i++) {\n+            try {\n+                TestResult.Section section = testResult.getSection(i);\n+                if (section.getTitle().equals(\"junit\")) {\n+                    try (Stream<String> lines = section.getOutput(\"System.err\").lines()) {\n+                        Collection<JUnitResults.TestClass> classes = JUnitResults.parse(lines.iterator());\n+                        tcSuiteStarted(\"junit\");\n+                        for (JUnitResults.TestClass cls : classes) {\n+                            reportTestClass(cls);\n+                        }\n+                        tcSuiteFinished(\"junit\");\n+                    }\n+                }\n+            } catch (Throwable t) {\n+                t.printStackTrace();\n+                \/\/ failed. ignore.\n+            }\n+        }\n@@ -99,3 +109,10 @@\n-    @Override\n-    public void finishedTesting() {\n-        \/\/do nothing\n+    private static void reportTestClass(JUnitResults.TestClass testClass) {\n+        tcSuiteStarted(testClass.simpleName(), classLocationHint(testClass.name()));\n+        for (JUnitResults.TestMethod test : testClass.testMethods()) {\n+            reportTestMethod(test, testClass.name());\n+        }\n+        for (JUnitResults.TestClass nestedTestClass : testClass.nestedClasses().values()) {\n+            reportTestClass(nestedTestClass);\n+        }\n+        tcSuiteFinished(testClass.simpleName());\n+    }\n@@ -103,0 +120,8 @@\n+    private static void reportTestMethod(JUnitResults.TestMethod test, String className) {\n+        tcTestStarted(test.name(), methodLocationHint(className, test.methodName(), test.iteration()));\n+        tcTestStdErr(test.name(), test.stderrLines());\n+        switch (test.result()) {\n+            case FAILED -> tcTestFailed(test.name(), \"\");\n+            case SKIPPED -> tcTestIgnored(test.name());\n+        }\n+        tcTestFinished(test.name(), test.duration());\n@@ -105,3 +130,60 @@\n-    @Override\n-    public void finishedTestRun(boolean b) {\n-        System.out.println(\"##teamcity[testSuiteFinished name=\\'jtreg\\']\");\n+    private static String classLocationHint(String className) {\n+        return \"jtreg:\/\/\" + className;\n+    }\n+\n+    private static String methodLocationHint(String className, String methodName,\n+                                             JUnitResults.TestMethod.Iteration iteration) {\n+        String path = className + \"\/\" + methodName;\n+        if (iteration != null) {\n+            path += \"\/\" + iteration.num() + \"\/\" + iteration.name();\n+        }\n+        return \"jtreg:\/\/\" + path;\n+    }\n+\n+    private static void tcSuiteStarted(String suiteName) {\n+        tcSuiteStarted(suiteName, null);\n+    }\n+\n+    private static void tcSuiteStarted(String suiteName, String locationHint) {\n+        System.out.println(\"##teamcity[testSuiteStarted name='\" + escapeName(suiteName) + \"'\"\n+                + (locationHint != null ? \" locationHint='\" + escapeName(locationHint) + \"'\" : \"\")\n+                + \" ]\");\n+    }\n+\n+    private static void tcSuiteFinished(String suiteName) {\n+        System.out.println(\"##teamcity[testSuiteFinished name='\" + escapeName(suiteName) + \"' ]\");\n+    }\n+\n+    private static void tcTestStarted(String testName) {\n+        tcTestStarted(testName, null);\n+    }\n+\n+    private static void tcTestStarted(String testName, String locationHint) {\n+        System.out.println(\"##teamcity[testStarted name='\" + escapeName(testName) + \"'\"\n+                + (locationHint != null ? \" locationHint='\" + escapeName(locationHint) + \"'\" : \"\")\n+                + \" ]\");\n+    }\n+\n+    private static void tcTestStdErr(String testName, List<String> lines) {\n+        System.out.println(\"##teamcity[testStdErr name='\" + escapeName(testName) + \"' \" +\n+                \"out='\" + escapeName(String.join(\"\\n\", lines) + '\\n') + \"']\");\n+    }\n+\n+    private static void tcTestFailed(String testName, String message) {\n+        System.out.println(\"##teamcity[testFailed name='\" + escapeName(testName) + \"' \" +\n+                \"message='\" + escapeName(message) + \"' ]\");\n+    }\n+\n+    private static void tcTestIgnored(String testName) {\n+        System.out.println(\"##teamcity[testIgnored name='\" + escapeName(testName) + \"']\");\n+    }\n+\n+    private static void tcTestFinished(String testName, String duration) {\n+        tcTestFinished(testName, duration, null);\n+    }\n+\n+    private static void tcTestFinished(String testName, String duration, String outputFile) {\n+        System.out.println(\"##teamcity[testFinished name='\" + escapeName(testName)  + \"'\"\n+                + (duration != null ? \"duration='\" + duration + \"'\" : \"\")\n+                + (outputFile != null ? \"outputFile='\" + escapeName(outputFile) + \"'\" : \"\")\n+                + \" ]\");\n@@ -119,5 +201,86 @@\n-    private static String loadText(File file) {\n-        try {\n-            return Files.readAllLines(file.toPath()).stream().collect(Collectors.joining(\"\\n\"));\n-        } catch (IOException e) {\n-            return \"Failed to load test results.\";\n+    private static class JUnitResults {\n+        private record TestMethod(String name, String methodName, Iteration iteration, Result result,\n+                                  List<String> stderrLines, String duration) {\n+            enum Result {SUCCESSFUL, SKIPPED, FAILED}\n+\n+            private record Iteration(int num, String name) {\n+                private static final Pattern PATTERN = Pattern.compile(\"'\\\\[(?<num>\\\\d+)] (?<name>.*)'\");\n+\n+                private static Iteration parse(String iteration) {\n+                    Matcher m = PATTERN.matcher(iteration);\n+                    if (!m.find()) {\n+                        return null;\n+                    }\n+                    int iterationNum = Integer.parseInt(m.group(\"num\")) - 1; \/\/ convert to zero indexed\n+                    return new Iteration(iterationNum, m.group(\"name\"));\n+                }\n+            }\n+        }\n+\n+        private record TestClass(String name, String simpleName, List<TestMethod> testMethods,\n+                                 Map<String, TestClass> nestedClasses) {\n+            public TestClass(String name, String simpleName) {\n+                this(name, simpleName, new ArrayList<>(), new HashMap<>());\n+            }\n+        }\n+\n+        private static final Pattern JUNIT_TEST_START = Pattern.compile(\n+                \"STARTED\\\\s+(?<class>[A-Za-z0-9._$]+)::(?<method>[A-Za-z0-9._$]+)\\\\s+(?<rest>.*)\");\n+\n+        private static Collection<TestClass> parse(Iterator<String> itt) {\n+            Map<String, TestClass> classesByName = new HashMap<>();\n+            while (itt.hasNext()) {\n+                String line = itt.next();\n+                if (line.startsWith(\"result:\")) {\n+                    break; \/\/ end of section. Stop parsing\n+                }\n+                Matcher m = JUNIT_TEST_START.matcher(line);\n+                if (m.find()) {\n+                    List<String> stdErr = new ArrayList<>();\n+                    stdErr.add(line);\n+                    String className = m.group(\"class\");\n+                    String methodName = m.group(\"method\");\n+                    TestMethod.Iteration iteration = TestMethod.Iteration.parse(m.group(\"rest\"));\n+                    String displayTestName = methodName + (iteration != null ? \" [\" + iteration.name() + \"]\" : \"\");\n+\n+                    do {\n+                        line = itt.next();\n+                        if (line.startsWith(\"JT Harness has limited the test output\")) {\n+                            \/\/ jtharness truncated the output. Discard this result\n+                            \/\/ and look for the next one.\n+                            continue;\n+                        }\n+                        stdErr.add(line);\n+                    } while (!line.startsWith(\"SUCCESSFUL\") && !line.startsWith(\"ABORTED\")\n+                            && !line.startsWith(\"SKIPPED\") && !line.startsWith(\"FAILED\"));\n+\n+                    TestMethod.Result result;\n+                    if (line.startsWith(\"SKIPPED\")) {\n+                        result = TestMethod.Result.SKIPPED;\n+                    } else if (line.startsWith(\"FAILED\") || line.startsWith(\"ABORTED\")) {\n+                        result = TestMethod.Result.FAILED;\n+                    } else {\n+                        result = TestMethod.Result.SUCCESSFUL;\n+                    }\n+                    String[] lineParts = line.split(\" \");\n+                    String duration = lineParts[lineParts.length -1]; \/\/ e.g. '[64ms]'\n+                    duration = duration.substring(1, duration.length() - 3); \/\/ drop '[' and 'ms]'\n+\n+                    TestMethod test = new TestMethod(displayTestName, methodName, iteration, result, stdErr, duration);\n+                    String[] nestedClasses = dropPackage(className).split(\"\\\\$\");\n+                    String classNameForLookup = className.replace('$', '.');\n+                    TestClass current = classesByName.computeIfAbsent(nestedClasses[0],\n+                            k -> new TestClass(classNameForLookup, k));\n+                    for (int i = 1; i < nestedClasses.length; i++) {\n+                        current = current.nestedClasses().computeIfAbsent(nestedClasses[i],\n+                                k -> new TestClass(classNameForLookup, k));\n+                    }\n+                    current.testMethods().add(test);\n+                }\n+            }\n+            return classesByName.values();\n+        }\n+\n+        private static String dropPackage(String className) {\n+            int lastDot = className.lastIndexOf(\".\");\n+            return lastDot != -1 ? className.substring(lastDot + 1) : className;\n","filename":"plugins\/idea\/src\/main\/java\/com\/oracle\/plugin\/jtreg\/runtime\/JTRegTestListener.java","additions":208,"deletions":45,"binary":false,"changes":253,"status":"modified"}]}