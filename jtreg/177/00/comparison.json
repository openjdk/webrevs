{"files":[{"patch":"@@ -0,0 +1,1616 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+# This program will download\/build the dependencies for jtreg and then\n+# build jtreg. Downloaded files are verified against known\/specified\n+# checksums.\n+#\n+# The program can be executed directly as a single source-file program\n+# by the Java launcher, using JDK 12 or later.\n+#\n+#     $ \/path\/to\/jdk  make\/Build.java  options\n+#\n+# For help on command-line options, use the --help option.\n+# Note: jtreg itself requires JDK 11 or later.\n+\n+# As a side effect, the program writes a file build\/make.sh which\n+# can subsequently be used directly to build apidiff, bypassing\n+# the need to rerun this program if all the dependencies are still\n+# available.\n+\n+# The default version to use when building jtreg can be found in the\n+# make\/version-numbers file, where the default versions and\n+# corresponding known checksums for the dependencies are also\n+# specified. Almost all the defaults can be overridden by setting\n+# the properties on the command line, or in a properties file,\n+# or as environment variables.\n+\n+# For each of the dependency the following steps are applied and the\n+# first successful one is used:\n+#\n+# 1. Check if the dependency is available locally\n+# 2. Download a prebuilt version of the dependency\n+# 3. Build the dependency from source, downloading the source archive\n+#    first\n+#\n+# In particular, when not found locally the dependencies will be\n+# handled as follows:\n+#\n+# * JUnit, TestNG, JCommander, Google Guice, and Ant jar are by default\n+#   downloaded from Maven central.\n+# * JT Harness and AsmTools are downloaded or built from source.\n+\n+\n+# Some noteworthy control variables:\n+#\n+# MAVEN_REPO_URL_BASE (e.g. \"https:\/\/repo1.maven.org\/maven2\")\n+#     The base URL for the maven central repository.\n+#\n+# CODE_TOOLS_URL_BASE (e.g. \"https:\/\/git.openjdk.java.net\")\n+#     The base URL for the code tools source repositories.\n+#\n+# ANT_ARCHIVE_URL_BASE (e.g. \"https:\/\/archive.apache.org\/dist\/ant\/binaries\")\n+#     The base URL for Ant dist binaries.\n+#\n+# JTREG_VERSION         (e.g. \"5.2\")\n+# JTREG_VERSION_STRING  (e.g. \"jtreg-5.2+8\"\n+# JTREG_BUILD_NUMBER    (e.g. \"8\")\n+# JTREG_BUILD_MILESTONE (e.g. \"dev\")\n+#     The version information to use for when building jtreg.\n+#\n+# RM, TAR, UNZIP\n+#     Paths to standard POSIX commands.\n+\n+# The control variables for dependencies are on the following general\n+# form (not all of them are relevant for all dependencies):\n+#\n+# <dependency>_URL (e.g. JTHARNESS_ARCHIVE_URL)\n+#     The full URL for the dependency.\n+#\n+# <dependency>_URL_BASE (e.g. JTHARNESS_ARCHIVE_URL_BASE)\n+#     The base URL for the dependency. Requires additional dependency\n+#     specific variables to be specified.\n+#\n+# <dependency>_CHECKSUM (e.g. JTHARNESS_ARCHIVE_CHECKSUM)\n+#     The expected checksum of the download file.\n+#\n+# <dependency>_SRC_TAG (e.g. JTHARNESS_SRC_TAG)\n+#     The SCM tag to use when building from source. The special value\n+#     \"tip\" can be used to get the most recent version.\n+#\n+# <dependency>_SRC_ARCHIVE_CHECKSUM (e.g. JTHARNESS_SRC_ARCHIVE_CHECKSUM)\n+#     The checksum of the source archive.\n+\n+# The below outlines the details of how the dependencies are\n+# handled. For each dependency the steps are tried in order and the\n+# first successful one will be used.\n+#\n+# Ant (required to build AsmTools and JT Harness)\n+#     Checksum variables:\n+#         ANT_ARCHIVE_CHECKSUM: checksum of binary archive\n+#\n+#     1. ANT\n+#         The path to the ant executable.\n+#     2a. ANT_ARCHIVE_URL\n+#         The full URL for the archive.\n+#     2b. ANT_ARCHIVE_URL_BASE + ANT_VERSION\n+#         The individual URL components used to construct the full URL.\n+#\n+# AsmTools\n+#     Checksum variables:\n+#         ASMTOOLS_ARCHIVE_CHECKSUM: checksum of binary archive\n+#         ASMTOOLS_SRC_ARCHIVE_CHECKSUM: checksum of source archive\n+#\n+#     1. ASMTOOLS_JAR + ASMTOOLS_LICENSE\n+#         The path to asmtools.jar and LICENSE respectively.\n+#     2a. ASMTOOLS_ARCHIVE_URL\n+#         The full URL for the archive.\n+#     2b. ASMTOOLS_ARCHIVE_URL_BASE + ASMTOOLS_VERSION + ASMTOOLS_BUILD_NUMBER + ASMTOOLS_FILE\n+#         The individual URL components used to construct the full URL.\n+#     3. ASMTOOLS_SRC_TAG\n+#         The SCM repository tag to use when building from source.\n+#\n+# Google Guice (required by TestNG)\n+#     Checksum variables:\n+#         GOOGLE_GUICE_JAR_CHECKSUM: checksum of jar\n+#\n+#     1. GOOGLE_GUICE_JAR\n+#         The path to guice.jar.\n+#     2a. GOOGLE_GUICE_JAR_URL\n+#         The full URL for the jar.\n+#     2b. GOOGLE_GUICE_JAR_URL_BASE + GOOGLE_GUICE_VERSION\n+#         The individual URL components used to construct the full URL.\n+#\n+# JCommander (required by TestNG)\n+#     Checksum variables:\n+#         JCOMMANDER_JAR_CHECKSUM: checksum of jar\n+#\n+#     1. JCOMMANDER_JAR\n+#         The path to jcommander.jar.\n+#     2a. JCOMMANDER_JAR_URL\n+#         The full URL for the jar.\n+#     2b. JCOMMANDER_JAR_URL_BASE + JCOMMANDER_VERSION\n+#         The individual URL components used to construct the full URL.\n+#\n+# JT Harness\n+#     Checksum variables:\n+#         JTHARNESS_ARCHIVE_CHECKSUM: checksum of binary archive\n+#         JTHARNESS_SRC_ARCHIVE_CHECKSUM: checksum of source archive\n+#\n+#     1. JTHARNESS_JAVATEST_JAR + JTHARNESS_LICENSE + JTHARNESS_COPYRIGHT\n+#         The path to javatest.jar, LICENSE, and copyright.txt respectively.\n+#     2a. JTHARNESS_ARCHIVE_URL\n+#         The full URL for the archive.\n+#     2b. JTHARNESS_ARCHIVE_URL_BASE + JTHARNESS_VERSION + JTHARNESS_BUILD_NUMBER + JTHARNESS_FILE\n+#         The individual URL components used to construct the full URL.\n+#     3. JTHARNESS_SRC_TAG\n+#         The SCM repository tag to use when building from source.\n+#\n+# JUnit\n+#     Checksum variables:\n+#         JUNIT_JAR_CHECKSUM: checksum of binary archive\n+#\n+#     1. JUNIT_JAR + JUNIT_LICENSE\n+#         The path to junit.jar and LICENSE respectively.\n+#     2a. JUNIT_JAR_URL\n+#         The full URL for the jar.\n+#     2b. JUNIT_JAR_URL_BASE + JUNIT_VERSION + JUNIT_FILE\n+#         The individual URL components used to construct the full URL.\n+#\n+# TestNG (requires JCommander, Google Guice)\n+#     Checksum variables:\n+#         TESTNG_JAR_CHECKSUM: checksum of binary archive\n+#         TESTNG_LICENSE_CHECKSUM: checksum of LICENSE file\n+#\n+#     1. TESTNG_JAR + TESTNG_LICENSE\n+#         The path to testng.jar and LICENSE.txt respectively.\n+#     2a. TESTNG_JAR_URL\n+#         The full URL for the jar.\n+#     2b. TESTNG_JAR_URL_BASE + TESTNG_VERSION + TESTNG_FILE\n+#         The individual URL components used to construct the full URL.\n+*\/\n+\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.PrintWriter;\n+import java.io.Reader;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.reflect.Field;\n+import java.net.MalformedURLException;\n+import java.net.URISyntaxException;\n+import java.net.URL;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.FileTime;\n+import java.security.DigestInputStream;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+\n+\/**\n+ * Utility to download the dependencies needed to build jtreg,\n+ * based on command-line parameters and info in\n+ * make\/build-support\/version-numbers.\n+ *\n+ * <p>The class can be executed directly by the Java source code launcher,\n+ * using JDK 12 or later.\n+ *\/\n+public class Build {\n+    public enum Exit {\n+        OK, BAD_OPTION, ERROR\n+    }\n+\n+    \/**\n+     * Execute the main program.\n+     *\n+     * @param args command-line arguments\n+     *\/\n+    public static void main(String... args) {\n+        try {\n+            PrintWriter outWriter = new PrintWriter(System.out);\n+            PrintWriter errWriter = new PrintWriter(System.err, true);\n+            try {\n+                try {\n+                    new Build().run(outWriter, errWriter, args);\n+                } finally {\n+                    outWriter.flush();\n+                }\n+            } finally {\n+                errWriter.flush();\n+            }\n+            System.exit(Exit.OK.ordinal());\n+        } catch (BadOption e) {\n+            System.err.println(\"Error: \" + e.getMessage());\n+            System.exit(Exit.BAD_OPTION.ordinal());\n+        } catch (Fault e) {\n+            System.err.println(\"Error: \" + e.getMessage());\n+            System.exit(Exit.ERROR.ordinal());\n+        }\n+    }\n+\n+    \/**\n+     * The root directory for the repo containing this class.\n+     *\/\n+    private final Path rootDir;\n+\n+    \/**\n+     * The minimum version of JDK required to build jtreg.\n+     *\/\n+    private static final int requiredJDKVersion = 11;\n+\n+    \/**\n+     * Creates an instance of the utility.\n+     *\n+     * @throws Fault if an unrecoverable error occurs while determining the root directory\n+     *\/\n+    Build() throws Fault {\n+        rootDir = getRootDir();\n+    }\n+\n+    \/**\n+     * The main worker method for the utility.\n+     *\n+     * @param out the stream to which to write any requested output\n+     * @param err the stream to which to write any logging or error output\n+     * @param args any command-line arguments\n+     * @throws BadOption if there is an error in any of the command-line arguments\n+     * @throws Fault if there is an unrecoverable error\n+     *\/\n+    public void run(PrintWriter out, PrintWriter err, String... args) throws BadOption, Fault {\n+\n+        \/\/ The collection of values specified by the command-line options.\n+        var options = Options.handle(rootDir, List.of(args));\n+\n+        \/\/ The collection of values derived from command-line options,\n+        \/\/ the make\/build-support\/version-numbers file, and default values.\n+        var config = new Config(rootDir, options, out, err);\n+\n+        var done = false;\n+\n+        if (options.help) {\n+            options.showCommandHelp(config.out);\n+            done = true;\n+        }\n+\n+        if (options.showDefaultVersions) {\n+            showProperties(config.properties, config.out);\n+            done = true;\n+        }\n+\n+        if (options.showConfigDetails) {\n+            if (config.properties.isEmpty()) {\n+                config.out.println(\"no custom configuration values\");\n+            } else {\n+                showProperties(config.properties, config.out);\n+            }\n+            done = true;\n+        }\n+\n+        if (done) {\n+            return;\n+        }\n+\n+        Tools tools = new Tools(config);\n+        Ant ant = new Ant(config, tools);\n+\n+        var dependencies = List.of(\n+                new BuildInfo(config, tools),\n+                new AsmTools(config, tools, ant),\n+                new JTHarness(config, tools, ant),\n+                new JUnit(config, tools),\n+                new TestNG(config, tools)\n+        );\n+\n+        if (dependencies.stream().anyMatch(Dependency::isAntRequired)) {\n+            ant.setup();\n+            ant.verify();\n+        }\n+\n+        for (var d : dependencies) {\n+            d.setup();\n+        }\n+\n+        for (var d : dependencies) {\n+            d.verify();\n+        }\n+\n+        var makeScript = config.buildDir.resolve(\"make.sh\");\n+        new MakeScript(config).writeFile(makeScript, dependencies);\n+\n+        if (!options.skipMake) {\n+            config.log(\"Building\");\n+            config.out.flush();\n+            config.err.flush();\n+            tools.runScript(makeScript, config.options.makeArgs);\n+        }\n+    }\n+\n+    \/**\n+     * Writes a set of properties to a given output stream.\n+     *\n+     * @param p the properties\n+     * @param out the output stream\n+     *\/\n+    private static void showProperties(Properties p, PrintWriter out) {\n+        p.stringPropertyNames().stream()\n+                .sorted()\n+                .forEach(k -> out.println(k + \"=\" + p.getProperty(k)));\n+    }\n+\n+    \/**\n+     * Forms a single list from a string and a list of strings.\n+     *\n+     * @param cmd the string\n+     * @param args the list of strings\n+     * @return a list formed from the string and list of strings\n+     *\/\n+    private static List<String> join(String cmd, List<String> args) {\n+        if (args.isEmpty()) {\n+            return List.of(cmd);\n+        }\n+        var list = new ArrayList<String>();\n+        list.add(cmd);\n+        list.addAll(args);\n+        return list;\n+    }\n+\n+    \/**\n+     * Returns the root directory for the repo containing this class,\n+     * as determined by checking enclosing directories for the marker\n+     * file make\/Makefile.\n+     *\n+     * @return the root directory\n+     * @throws Fault if the root directory cannot be determined\n+     *\/\n+    private static Path getRootDir() throws Fault {\n+        Path dir = getThisClass().getParent();\n+        Path marker = Path.of(\"make\").resolve(\"Makefile\");\n+        while (dir != null) {\n+            if (Files.isRegularFile(dir.resolve(marker))) {\n+                return dir;\n+            }\n+            dir = dir.getParent();\n+        }\n+        throw new Fault(\"cannot determine root directory\");\n+    }\n+\n+    \/**\n+     * Returns the path for this class, determined from the location in\n+     * the class' protection domain.\n+     *\n+     * @return the path\n+     * @throws Fault if an error occurs\n+     *\/\n+    private static Path getThisClass() throws Fault {\n+        try {\n+            return Path.of(Build.class.getProtectionDomain().getCodeSource().getLocation().toURI());\n+        } catch (URISyntaxException e) {\n+            throw new Fault(\"cannot determine location of this class\");\n+        }\n+    }\n+\n+    \/**\n+     * Exception used to report a bad command-line option.\n+     *\/\n+    static class BadOption extends Exception {\n+        BadOption(String message) {\n+            super(message);\n+        }\n+        BadOption(String message, Throwable cause) {\n+            super(message, cause);\n+        }\n+    }\n+\n+    \/**\n+     * Exception used to report an unrecoverable error.\n+     *\/\n+    static class Fault extends Exception {\n+        Fault(String message) {\n+            super(message);\n+        }\n+        Fault(String message, Throwable cause) {\n+            super(message, cause);\n+        }\n+    }\n+\n+    \/**\n+     * The set of allowable command-line options.\n+     *\/\n+    enum Option {\n+        @Description(\"Show this message\")\n+        HELP(\"--help -h -help -?\", null) {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.help = true;\n+            }\n+        },\n+\n+        @Description(\"Path to JDK; must be JDK \" + requiredJDKVersion + \" or higher\")\n+        JDK(\"--jdk\", \"<jdk>\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.jdk = asExistingPath(arg);\n+            }\n+        },\n+\n+        @Description(\"Reduce the logging output\")\n+        QUIET(\"--quiet -q\", null) {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.quiet = true;\n+            }\n+        },\n+\n+        @Description(\"Show default versions of external components\")\n+        SHOW_DEFAULT_VERSIONS(\"--show-default-versions\", null) {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.showDefaultVersions = true;\n+            }\n+        },\n+\n+        @Description(\"Show configuration details\")\n+        SHOW_CONFIG_DETAILS(\"--show-config-details\", null) {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.showConfigDetails = true;\n+            }\n+        },\n+\n+        @Description(\"Skip checksum check\")\n+        SKIP_CHECKSUM_CHECK(\"--skip-checksum-check\", null) {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.skipChecksumCheck = true;\n+            }\n+        },\n+\n+        @Description(\"Skip downloads if file available locally\")\n+        SKIP_DOWNLOAD(\"--skip-download\", null) {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.skipDownloads = true;\n+            }\n+        },\n+\n+        @Description(\"Skip running 'make' (just download dependencies if needed)\")\n+        SKIP_MAKE(\"--skip-make\", null) {\n+            @Override\n+            void process(String opt, String arg, Options options) {\n+                options.skipMake = true;\n+            }\n+        },\n+\n+        @Description(\"Provide an alternate file containing dependency version information\")\n+        VERSION_NUMBERS(\"--version-numbers\", \"<file>\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption {\n+                options.versionNumbers = asExistingPath(arg);\n+            }\n+        },\n+\n+        @Description(\"Provide an alternate file containing configuration details\")\n+        CONFIG_FILE(\"--config\", \"<file>\") {\n+            @Override\n+            void process(String opt, String arg, Options options) throws BadOption, Fault {\n+                var p = asExistingPath(arg);\n+                try (BufferedReader r = Files.newBufferedReader(p)) {\n+                    options.configProperties.load(r);\n+                } catch (IOException e) {\n+                    throw new Fault(\"error reading \" + p + \": \" + e, e);\n+                }\n+            }\n+        },\n+\n+        @Description(\"Override a specific configuration value\")\n+        CONFIG_VALUE(\"NAME=VALUE\", null),\n+\n+        @Description(\"Subsequent arguments are for 'make'\")\n+        MAKE_ARGS(\"--\", null);\n+\n+        @Retention(RetentionPolicy.RUNTIME)\n+        @interface Description {\n+            String value();\n+        }\n+\n+        final List<String> names;\n+        final String arg;\n+\n+        Option(String names, String arg) {\n+            this.names = Arrays.asList(names.split(\"\\\\s+\"));\n+            this.arg = arg;\n+        }\n+\n+        void process(String opt, String arg, Options options) throws BadOption, Fault {\n+            throw new Error(\"internal error\");\n+        }\n+\n+        static Path asPath(String p) throws BadOption {\n+            try {\n+                return Path.of(p);\n+            } catch (InvalidPathException e) {\n+                throw new BadOption(\"File not found: \" + p, e);\n+            }\n+        }\n+\n+        static Path asExistingPath(String p) throws BadOption {\n+            var path = asPath(p);\n+            if (!Files.exists(path)) {\n+                throw new BadOption(\"File not found: \" + p);\n+            }\n+            return path;\n+        }\n+    }\n+\n+    \/**\n+     * The set of values given by the command-line options.\n+     *\/\n+    static class Options {\n+        boolean help;\n+        Path jdk;\n+        boolean quiet;\n+        boolean showDefaultVersions;\n+        boolean showConfigDetails;\n+        boolean skipChecksumCheck;\n+        boolean skipDownloads;\n+        boolean skipMake;\n+        private Path versionNumbers;\n+        private List<String> makeArgs = List.of();\n+\n+        final private Properties configProperties;\n+\n+        Options(Path rootDir) {\n+            var dir = rootDir.resolve(\"make\").resolve(\"build-support\");\n+            versionNumbers = dir.resolve(\"version-numbers\");\n+            configProperties = new Properties();\n+        }\n+\n+        static Options handle(Path rootDir, List<String> args) throws BadOption, Fault {\n+            Options options = new Options(rootDir);\n+\n+            Map<String, Option> map = new HashMap<>();\n+            for (Option o : Option.values()) {\n+                o.names.forEach(n -> map.put(n, o));\n+            }\n+\n+            for (int i = 0; i < args.size(); i++) {\n+                String arg = args.get(i);\n+                \/\/ currently no support for positional args\n+                String optName, optValue;\n+                int eq = arg.indexOf(\"=\");\n+                if (eq == -1) {\n+                    optName = arg;\n+                    optValue = null;\n+                } else {\n+                    optName = arg.substring(0, eq);\n+                    optValue = arg.substring(eq + 1);\n+                }\n+                if (optName.isEmpty()) {\n+                    throw new BadOption(\"bad argument: \" + arg);\n+                } else {\n+                    Option opt = map.get(optName);\n+                    if (opt == null) {\n+                        if (optName.matches(\"[A-Z_]+\")) {\n+                            options.configProperties.setProperty(optName, optValue);\n+                        } else {\n+                            throw new BadOption(\"unknown option: \" + optName);\n+                        }\n+                    } else {\n+                        if (opt == Option.MAKE_ARGS) {\n+                            options.makeArgs = args.subList(i + 1, args.size());\n+                            i = args.size();\n+                        } else if (opt.arg == null) {\n+                            \/\/ no value for option required\n+                            if (optValue != null) {\n+                                throw new BadOption(\"unexpected value for \" + optName + \" option: \" + optValue);\n+                            } else {\n+                                opt.process(optName, null, options);\n+                            }\n+                        } else {\n+                            \/\/ value for option required; use next arg if not found after '='\n+                            if (optValue == null) {\n+                                if (i + 1 < args.size()) {\n+                                    optValue = args.get(++i);\n+                                } else {\n+                                    throw new BadOption(\"no value for \" + optName + \" option\");\n+                                }\n+                            }\n+                            opt.process(optName, optValue, options);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            return options;\n+        }\n+\n+        void showCommandHelp(PrintWriter out) {\n+            out.println(\"Usage: java \" + Build.class.getSimpleName() + \".java \"\n+                    + \"<options> [ -- <make options and target>]\" );\n+            out.println(\"Options:\");\n+            for (var o : Option.values()) {\n+                out.println(o.names.stream()\n+                        .map(n -> n + (o.arg == null ? \"\" : \" \" + o.arg))\n+                        .collect(Collectors.joining(\", \", \"  \", \"\")));\n+                try {\n+                    Field f = Option.class.getDeclaredField(o.name());\n+                    Option.Description d = f.getAnnotation(Option.Description.class);\n+                    out.println(\"      \" + d.value());\n+                } catch (ReflectiveOperationException e) {\n+                    throw new Error(e);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * The set of configuration values determined from command-line options,\n+     * the make\/build-support\/version-numbers file, and any defaults.\n+     *\/\n+    static class Config {\n+        final Path rootDir;\n+        final Options options;\n+        final PrintWriter out;\n+        final PrintWriter err;\n+        private final Path buildDir;\n+        private final Properties properties;\n+        private final Path jdk;\n+        private final Map<String, String>sysEnv;\n+\n+        Config(Path rootDir, Options options, PrintWriter out, PrintWriter err) throws Fault {\n+            this.rootDir = rootDir;\n+            this.options = options;\n+            this.out = out;\n+            this.err = err;\n+\n+            this.buildDir = rootDir.resolve(\"build\");\n+\n+            var versionNumbers = readProperties(options.versionNumbers);\n+\n+            var asmToolsVersionNumbers = readProperties(\n+                    options.versionNumbers.getParent().resolve(\"asmtools\").resolve(\"version-numbers\"));\n+            versionNumbers.putAll(asmToolsVersionNumbers);\n+\n+            var jtHarnessVersionNumbers = readProperties(\n+                    options.versionNumbers.getParent().resolve(\"jtharness\").resolve(\"version-numbers\"));\n+            versionNumbers.putAll(jtHarnessVersionNumbers);\n+\n+            properties = new Properties(versionNumbers);\n+            properties.putAll(options.configProperties);\n+\n+            sysEnv = System.getenv();\n+\n+            var jdk = options.jdk;\n+            if (jdk == null) {\n+                jdk = getPath(\"JAVA_HOME\");\n+            }\n+            if (jdk == null) {\n+                jdk = Path.of(System.getProperty(\"java.home\"));\n+            }\n+            this.jdk = jdk;\n+        }\n+\n+        void log(String line) {\n+            if (!options.quiet) {\n+                err.println(line);\n+            }\n+        }\n+\n+        void error(String lines) {\n+            lines.lines().forEach(err::println);\n+        }\n+\n+        private String getString(String key) {\n+            var v = properties.getProperty(key);\n+            if (v == null) {\n+                if (key.endsWith(\"_VERSION\")\n+                        || key.endsWith(\"_CHECKSUM\")\n+                        || key.endsWith(\"_SRC_TAG\")\n+                        || key.contains(\"_LICENSE_\")) {\n+                    v = properties.getProperty(\"DEFAULT_\" + key);\n+                }\n+\n+                if (v == null) {\n+                    v = sysEnv.get(key);\n+                }\n+            }\n+            return v;\n+        }\n+\n+        private String getRequiredString(String key) throws Fault {\n+            var v = getString(key);\n+            if (v == null) {\n+                throw new Fault(\"no configuration value for \" + key);\n+            }\n+            return v;\n+        }\n+\n+        public Path getPath(String key) throws Fault {\n+            String v = getString(key);\n+            try {\n+                return v == null ? null : Path.of(v);\n+            } catch (InvalidPathException e) {\n+                throw new Fault(\"bad path: \" + v + \": \" + e);\n+            }\n+        }\n+\n+        public URL getURL(String key) {\n+            var v = getString(key);\n+            try {\n+                return v == null ? null : new URL(v);\n+            } catch (MalformedURLException e) {\n+                throw new Error(\"Bad URL for \" + key + \": \" + v + \": \" + e);\n+            }\n+        }\n+\n+        private Properties readProperties(Path file) throws Fault {\n+            Properties p = new Properties();\n+            if (file != null) {\n+                try (Reader r = Files.newBufferedReader(file)) {\n+                    p.load(r);\n+                } catch (IOException e) {\n+                    throw new Fault(\"error reading \" + file + \": \" + e, e);\n+                }\n+            }\n+            return p;\n+        }\n+    }\n+\n+    \/**\n+     * Utility class to interact with host-system tools.\n+     *\/\n+    static class Tools {\n+        private final Config config;\n+        private final boolean isWindows;\n+        private final List<Path> sysPath;\n+        private final Map<String, Path> commandPaths;\n+\n+        Tools(Config config) {\n+            this.config = config;\n+            isWindows = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+            sysPath = Arrays.stream(System.getenv(\"PATH\")\n+                            .split(Pattern.quote(File.pathSeparator)))\n+                    .filter(c -> !c.isEmpty())\n+                    .map(Path::of)\n+                    .collect(Collectors.toList());\n+            commandPaths = new HashMap<>();\n+        }\n+\n+        void deleteDirectory(Path dir) throws Fault {\n+            if (isWindows) {\n+                exec(\"rmdir\", \"\/Q\", \"\/S\", dir.toString());\n+            } else {\n+                exec(getCommandPath(\"rm\"),\"-rf\", dir.toString());\n+            }\n+        }\n+\n+        String java(Path javaHome, List<String> args, Predicate<String> filter) throws Fault {\n+            Path java = javaHome.resolve(\"bin\").resolve(\"java\" + (isWindows ? \".exe\" : \"\"));\n+            return exec(java, args, filter);\n+        }\n+\n+        void runScript(Path script, List<String> args) throws Fault {\n+            exec(getCommandPath(\"sh\").toString(), join(script.toString(), args));\n+        }\n+\n+        void tar(String... args) throws Fault {\n+            exec(getCommandPath(\"tar\"), args);\n+        }\n+\n+        void unzip(String... args) throws Fault {\n+            exec(getCommandPath(\"unzip\"), args);\n+        }\n+\n+        Path getCommandPath(String name) throws Fault {\n+            Path p = commandPaths.get(name);\n+            if (p == null) {\n+                p = config.getPath(name.toUpperCase(Locale.ROOT));\n+                if (p == null) {\n+                    p = which(name);\n+                }\n+                commandPaths.put(name, p);\n+            }\n+            return p;\n+        }\n+\n+        private Path which(String command) throws Fault {\n+            var c = isWindows ? command + \".exe\" : command;\n+            return sysPath.stream()\n+                    .map(p -> p.resolve(c))\n+                    .filter(f -> Files.exists(f) && Files.isExecutable(f))\n+                    .findFirst()\n+                    .orElseThrow(() -> new Fault(\"cannot find path for \" + command + \" command\"));\n+        }\n+\n+        public void exec(Path command, String... args) throws Fault {\n+            exec(command.toString(), List.of(args));\n+        }\n+\n+        public void exec(String command, String... args) throws Fault {\n+            exec(command, List.of(args));\n+        }\n+\n+        public void exec(String command, List<String> args) throws Fault {\n+            config.out.flush();\n+            config.err.flush();\n+            try {\n+                Process p = new ProcessBuilder(join(command, args))\n+                        .redirectError(ProcessBuilder.Redirect.INHERIT)\n+                        .redirectOutput(ProcessBuilder.Redirect.INHERIT)\n+                        .start();\n+                p.waitFor();\n+                int rc = p.exitValue();\n+                if (rc != 0) {\n+                    throw new Fault(\"error running '\" + command + \"': rc=\" + rc);\n+                }\n+            } catch (IOException | InterruptedException e) {\n+                throw new Fault(\"error running '\" + command + \"': \" + e);\n+            }\n+        }\n+\n+        public String exec(Path command, List<String> args, Predicate<String> filter) throws Fault {\n+            config.out.flush();\n+            config.err.flush();\n+            try {\n+                Process p = new ProcessBuilder(join(command.toString(), args))\n+                        .redirectErrorStream(true)\n+                        .start();\n+                String out;\n+                try (var r = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n+                    out = r.lines()\n+                            .filter(filter)\n+                            .findFirst()\n+                            .orElse(\"\");\n+                }\n+                int rc = p.waitFor();\n+                if (rc != 0) {\n+                    throw new Fault(\"Error running '\" + command + \": rc=\" + rc);\n+                }\n+                return out;\n+            } catch (IOException | InterruptedException e) {\n+                throw new Fault(\"Error running '\" + command + \": \" + e, e);\n+            }\n+        }\n+\n+        public void exec(Path command, List<String> args, Map<String, String> envExtras, Path outFile) throws Fault {\n+            config.out.flush();\n+            config.err.flush();\n+            try {\n+                var pb = new ProcessBuilder(join(command.toString(), args))\n+                        .redirectErrorStream(true);\n+                var env = pb.environment();\n+                env.putAll(envExtras);\n+                var p = pb.start();\n+                try (var in = new BufferedReader(new InputStreamReader(p.getInputStream()));\n+                     var out = Files.newBufferedWriter(outFile)) {\n+                    String line;\n+                    while ((line = in.readLine()) != null) {\n+                        out.write(line);\n+                        out.newLine();\n+                    }\n+                }\n+                int rc = p.waitFor();\n+                if (rc != 0) {\n+                    throw new Fault(command + \" failed: rc=\" + rc);\n+                }\n+            } catch (IOException | InterruptedException e) {\n+                throw new Fault(\"error while running \" + command + \": \" + e, e);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Base class for a dependency to be made available for the build.\n+     *\/\n+    static abstract class Dependency {\n+        protected final String name;\n+        protected final Path depsDir;\n+        protected final Config config;\n+        protected final Tools tools;\n+\n+        private static final String DEFAULT_MAVEN_URL = \"https:\/\/repo1.maven.org\/maven2\";\n+\n+        Dependency(String name, Config config, Tools tools) {\n+            this.name = name;\n+            this.config = config;\n+            this.tools = tools;\n+            this.depsDir = config.rootDir.resolve(\"build\").resolve(\"deps\").resolve(name);\n+        }\n+\n+        public boolean isAntRequired() {\n+            return false;\n+        }\n+\n+        public abstract void setup() throws Fault;\n+\n+        public abstract void verify() throws Fault;\n+\n+        public Map<String, String> getMakeArgs() {\n+            return Collections.emptyMap();\n+        }\n+\n+        protected void createDepsDir() throws Fault {\n+            try {\n+                Files.createDirectories(depsDir);\n+            } catch (IOException e) {\n+                throw new Fault(\"Failed to create \" + depsDir + \": \" + e, e);\n+            }\n+        }\n+\n+        protected Path download(URL url, Path file, String checksum) throws Fault {\n+            if (Files.isDirectory(file)) {\n+                file = file.resolve(baseName(url));\n+            }\n+\n+            if (Files.isReadable(file) && config.options.skipDownloads) {\n+                return file;\n+            }\n+\n+            config.log(\"Downloading \" + url);\n+            try {\n+                Files.createDirectories(file.getParent());\n+            } catch (IOException e) {\n+                throw new Fault(\"Error creating directory for \" + file + \": \" + e);\n+            }\n+\n+            try (var in = url.openStream()) {\n+                var md = MessageDigest.getInstance(\"SHA-1\");\n+                try (var in2 = new DigestInputStream(in, md)) {\n+                    Files.copy(in2, file, StandardCopyOption.REPLACE_EXISTING);\n+                }\n+                var digest = toString(md.digest());\n+                if ((!config.options.skipChecksumCheck && !checksum.equals(\"--\"))\n+                        && !checksum.equals(digest)) {\n+                    config.error(\"Checksum error for \" + url + \"\\n\"\n+                            + \"  expect: \" + checksum + \"\\n\"\n+                            + \"  actual: \" + digest);\n+                }\n+            } catch (IOException | NoSuchAlgorithmException e) {\n+                throw new Fault(\"Error downloading \" + url + \": \" + e, e);\n+            }\n+\n+            return file;\n+        }\n+\n+        protected Path downloadStandardJar(BiFunction<URL, String, String> makeDefaultURL) throws Fault {\n+            createDepsDir();\n+            var prefix = name.toUpperCase(Locale.ROOT).replaceAll(\"[^A-Z_]+\", \"\");\n+            var jarURL = config.getURL(prefix + \"_JAR_URL\");\n+            if (jarURL == null) {\n+                var jarURLBase = config.getURL(prefix + \"_JAR_URL_BASE\");\n+                if (jarURLBase == null) {\n+                    jarURLBase = config.getURL(\"MAVEN_REPO_URL_BASE\");\n+                    if (jarURLBase == null) {\n+                        jarURLBase = newURL(DEFAULT_MAVEN_URL);\n+                    }\n+                }\n+                var version = config.getString(prefix + \"_VERSION\");\n+                jarURL = newURL(makeDefaultURL.apply(jarURLBase, version));\n+            }\n+            var checksum = config.getString(prefix + \"_JAR_CHECKSUM\");\n+            return download(jarURL, depsDir, checksum);\n+        }\n+\n+        protected Path unpack(Path archive, Path dir) throws Fault {\n+            try (var ds = Files.newDirectoryStream(depsDir, Files::isDirectory)) {\n+                for (var d : ds) {\n+                    tools.deleteDirectory(d);\n+                }\n+            } catch (IOException e) {\n+                throw new Fault(\"error listing \" + depsDir +\": \" + e, e);\n+            }\n+\n+            String s = archive.getFileName().toString();\n+            if (s.endsWith(\".tar.gz\")) {\n+                tools.tar(\"-xzf\", archive.toString(), \"-C\", dir.toString());\n+            } else if (s.endsWith(\".zip\")) {\n+                \/\/ cannot extract files with permissions using standard ZipFile API\n+                \/\/ so resort to the unzip command\n+                tools.unzip(\"-q\", archive.toString(), \"-d\", dir.toString());\n+            } else {\n+                throw new Fault(\"unrecognized archive type for file \" + archive);\n+            }\n+\n+            try (DirectoryStream<Path> ds = Files.newDirectoryStream(dir, Files::isDirectory)) {\n+                Path bestSoFar = null;\n+                FileTime bestSoFarTime = null;\n+                for (var p : ds) {\n+                    var pTime = Files.getLastModifiedTime(p);\n+                    if (bestSoFar == null || pTime.compareTo(bestSoFarTime) > 0) {\n+                        bestSoFar = p;\n+                    }\n+                    bestSoFarTime = pTime;\n+                }\n+                return bestSoFar;\n+            } catch (IOException e) {\n+                throw new Fault(\"Error listing contents of \" + dir + \": \" + e, e);\n+            }\n+        }\n+\n+        protected Path extract(Path zipFile, String name, Path file) throws Fault {\n+            var outFile = Files.isDirectory(file) ? file.resolve(name) : file;\n+            try (var zf = new ZipFile(zipFile.toFile())) {\n+                var ze = zf.getEntry(name);\n+                try (var in = zf.getInputStream(ze)) {\n+                    Files.copy(in, outFile, StandardCopyOption.REPLACE_EXISTING);\n+                }\n+                return outFile;\n+            } catch (IOException e) {\n+                throw new Fault(\"error extracting \" + name + \" from \" + zipFile + \": \" + e, e);\n+            }\n+        }\n+\n+        protected void checkFile(Path file) throws Fault {\n+            config.log(\"Checking \" + file);\n+            if (!(Files.isRegularFile(file) && Files.isReadable(file))) {\n+                throw new Fault(file + \" is not a readable file\");\n+            }\n+        }\n+\n+        private String toString(byte[] bytes) {\n+            StringBuilder sb = new StringBuilder();\n+            for (var b : bytes) {\n+                sb.append(String.format(\"%02x\", b));\n+            }\n+            return sb.toString();\n+        }\n+\n+        protected URL newURL(String u) throws Fault {\n+            try {\n+                return new URL(u);\n+            } catch (MalformedURLException e) {\n+                throw new Fault(\"Error creating URL \" + u + \": \" + e);\n+            }\n+        }\n+\n+        protected String baseName(URL url) {\n+            var p = url.getPath();\n+            var lastSep = p.lastIndexOf(\"\/\");\n+            return lastSep == -1 ? p : p.substring(lastSep+ 1);\n+        }\n+    }\n+\n+    \/**\n+     * A pseudo-dependency to provide build version details.\n+     *\/\n+    static class BuildInfo extends Dependency {\n+        String version;\n+        String buildMileStone;\n+        String buildNumber;\n+        String versionString;\n+\n+        BuildInfo(Config config, Tools tools) {\n+            super(\"jtreg\", config, tools);\n+        }\n+\n+        @Override\n+        public void setup() throws Fault {\n+            var prefix = name.toUpperCase(Locale.ROOT);\n+            version = config.getRequiredString(prefix + \"_VERSION\");\n+\n+            buildMileStone = config.getString(prefix + \"_BUILD_MILESTONE\");\n+            if (buildMileStone == null) {\n+                buildMileStone = \"dev\";\n+            }\n+\n+            buildNumber = config.getString(prefix + \"_BUILD_NUMBER\");\n+            if (buildNumber == null) {\n+                buildNumber = \"0\";\n+            }\n+\n+            versionString = config.getString(prefix + \"_VERSION_STRING\");\n+            if (versionString == null) {\n+                versionString = version\n+                        + (buildMileStone.isEmpty() ? \"\" : \"-\" + buildMileStone)\n+                        + \"+\" + buildNumber;\n+            }\n+        }\n+\n+        @Override\n+        public void verify() throws Fault {\n+            int version;\n+            if (config.jdk.equals(Path.of(System.getProperty(\"java.home\")))) {\n+                version = Runtime.version().feature();\n+            } else {\n+                var v = tools.java(config.jdk, List.of(\"-version\"),\n+                        l -> l.matches(\".*(java|openjdk).*\"));\n+                var m = Pattern.compile(\"\\\"(1.)?(?<v>[0-9]+)\\\"\").matcher(v);\n+                if (m.find()) {\n+                    version = Integer.parseInt(m.group(\"v\"));\n+                } else {\n+                    throw new Fault(\"version info not found in output from '\" + config.jdk + \"\/bin\/java -version'\");\n+                }\n+            }\n+\n+            if (version < requiredJDKVersion) {\n+                throw new Fault(\"JDK \" + requiredJDKVersion + \" or newer is required to build apidiff\");\n+            }\n+        }\n+\n+        @Override\n+        public Map<String, String> getMakeArgs() {\n+            return Map.of(\n+                    \"BUILDDIR\", config.buildDir.toString(),\n+                    \"JDKHOME\", config.jdk.toString(),\n+                    \"BUILD_VERSION\", version,\n+                    \"BUILD_MILESTONE\", buildMileStone,\n+                    \"BUILD_NUMBER\", buildNumber,\n+                    \"BUILD_VERSION_STRING\", versionString\n+            );\n+        }\n+    }\n+\n+    \/**\n+     * Ant, required to build AsmTools and JTHarness from source,\n+     * if pre-built binaries are not available.\n+     *\/\n+    static class Ant extends Dependency {\n+        Path ant;\n+\n+        private static final String DEFAULT_ANT_ARCHIVE_URL_BASE =\n+                \"https:\/\/archive.apache.org\/dist\/ant\/binaries\";\n+\n+        public Ant(Config config, Tools tools) {\n+            super(\"ant\", config, tools);\n+        }\n+\n+        @Override\n+        public void setup() throws Fault {\n+            ant = config.getPath(\"ANT\");\n+            if (ant == null) {\n+                createDepsDir();\n+                var archiveURL = config.getURL(\"ANT_ARCHIVE_URL\");\n+                if (archiveURL == null) {\n+                    var archiveURLBase = config.getURL(\"ANT_ARCHIVE_URL_BASE\");\n+                    if (archiveURLBase == null) {\n+                        archiveURLBase = newURL(DEFAULT_ANT_ARCHIVE_URL_BASE);\n+                    }\n+                    var version = config.getRequiredString(\"ANT_VERSION\");\n+                    archiveURL = newURL(\n+                            archiveURLBase\n+                            + \"\/apache-ant-\" + version + \"-bin.zip\");\n+                }\n+                var checksum = config.getRequiredString(\"ANT_ARCHIVE_CHECKSUM\");\n+                var archive = download(archiveURL, depsDir, checksum);\n+                var unpackDir = unpack(archive, depsDir);\n+                ant = unpackDir.resolve(\"bin\").resolve(\"ant\");\n+            }\n+        }\n+\n+        @Override\n+        public void verify() throws Fault {\n+            checkFile(ant);\n+        }\n+\n+        void exec(Path file, List<String> args, Path outFile) throws Fault {\n+            config.log(\"Building \" + file);\n+            var antArgs = new ArrayList<String>();\n+            antArgs.addAll(List.of(\"-f\", file.toString()));\n+            antArgs.addAll(args);\n+            tools.exec(ant, antArgs, Map.of(\"JAVA_HOME\", config.jdk.toString()), outFile);\n+        }\n+    }\n+\n+    static class AsmTools extends Dependency {\n+        private final Ant ant;\n+\n+        Path jar;\n+        Path license;\n+\n+        public AsmTools(Config config, Tools tools, Ant ant) {\n+            super(\"asmtools\", config, tools);\n+            this.ant = ant;\n+        }\n+\n+        @Override\n+        public boolean isAntRequired() {\n+            return config.properties.stringPropertyNames().stream()\n+                    .noneMatch(k -> k.equals(\"ASMTOOLS_JAR\") || k.contains(\"ASMTOOLS_ARCHIVE_URL\"));\n+        }\n+\n+        @Override\n+        public void setup() throws Fault {\n+            jar = config.getPath(\"ASMTOOLS_JAR\");\n+            if (jar == null) {\n+                createDepsDir();\n+                var jarArchiveURL = config.getURL(\"ASMTOOLS_ARCHIVE_URL\");\n+                if (jarArchiveURL == null) {\n+                    var jarArchiveURLBase = config.getURL(\"ASMTOOLS_ARCHIVE_URL_BASE\");\n+                    if (jarArchiveURLBase != null) {\n+                        var version = config.getRequiredString(\"ASMTOOLS_VERSION\");\n+                        var buildNumber = config.getRequiredString(\"ASMTOOLS_BUILD_NUMBER\");\n+                        var file = config.getRequiredString(\"ASMTOOLS_FILE\");\n+                        jarArchiveURL = newURL(\n+                                jarArchiveURLBase\n+                                + \"\/\" + version\n+                                + \"\/\" + buildNumber\n+                                + \"\/\" + file);\n+                    }\n+                }\n+\n+                if (jarArchiveURL != null) {\n+                    var checksum = config.getRequiredString(\"ASMTOOLS_ARCHIVE_CHECKSUM\");\n+                    var jarArchive = download(jarArchiveURL, depsDir, checksum);\n+                    var unpackDir = unpack(jarArchive, depsDir);\n+                    jar = unpackDir.resolve(\"lib\").resolve(\"asmtools.jar\");\n+                    license = unpackDir.resolve(\"LICENSE\");\n+                } else {\n+                    config.log(\"None of ASMTOOLS_JAR, ASMTOOLS_ARCHIVE_URL or ASMTOOLS_ARCHIVE_URL_BASE are set; \"\n+                            + \"building from source\");\n+                    var codeToolsURLBase = config.getURL(\"CODETOOLS_URL_BASE\");\n+                    if (codeToolsURLBase == null) {\n+                        codeToolsURLBase = newURL(\"https:\/\/git.openjdk.java.net\");\n+                    }\n+                    var srcTag = config.getRequiredString(\"ASMTOOLS_SRC_TAG\");\n+                    Path srcArchive;\n+                    if (srcTag.equals(\"tip\") || srcTag.equals(\"master\")) {\n+                        var branch = \"master\";\n+                        var srcArchiveURL = config.getURL(\n+                                codeToolsURLBase\n+                                + \"\/asmtools\/archive\/\"\n+                                + branch + \".zip\");\n+                        srcArchive = download(srcArchiveURL, depsDir, \"--\");\n+                    } else {\n+                        var srcArchiveURL = newURL(\n+                                codeToolsURLBase\n+                                + \"\/asmtools\/archive\/\"\n+                                + srcTag + \".zip\");\n+                        var checksum = config.getRequiredString(\"ASMTOOLS_SRC_ARCHIVE_CHECKSUM\");\n+                        srcArchive = download(srcArchiveURL, depsDir, checksum);\n+                    }\n+                    var unpackDir= unpack(srcArchive, depsDir);\n+                    var buildDir = depsDir.resolve(\"build\");\n+                    ant.exec(unpackDir.resolve(\"build\").resolve(\"build.xml\"),\n+                            List.of(\"-DBUILD_DIR=\" + buildDir),\n+                            depsDir.resolve(\"build.log\"));\n+                    var buildBinDir = buildDir.resolve(\"binaries\");\n+                    jar = buildBinDir.resolve(\"lib\").resolve(\"asmtools.jar\");\n+                    license = buildBinDir.resolve(\"LICENSE\");\n+                }\n+            }\n+\n+            if (license == null) {\n+                license = config.getPath(\"ASMTOOLS_LICENSE\");\n+                if (license == null) {\n+                    var licenseFile = \"LICENSE\";\n+                    license = extract(jar, licenseFile, depsDir);\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void verify() throws Fault {\n+            checkFile(jar);\n+            checkFile(license);\n+        }\n+\n+        @Override\n+        public Map<String, String> getMakeArgs() {\n+            return Map.of(\n+                    \"ASMTOOLS_JAR\", jar.toString(),\n+                    \"ASMTOOLS_NOTICES\", license.toString());\n+        }\n+    }\n+\n+    static class JTHarness extends Dependency {\n+        private final Ant ant;\n+\n+        Path jar;\n+        Path license;\n+        Path copyright;\n+\n+\n+        public JTHarness(Config config, Tools tools, Ant ant) {\n+            super(\"jtharness\", config, tools);\n+            this.ant = ant;\n+        }\n+\n+        @Override\n+        public boolean isAntRequired() {\n+            return config.properties.stringPropertyNames().stream()\n+                    .noneMatch(k -> k.equals(\"JTHARNESS_JAVATEST_JAR\") || k.contains(\"JTHARNESS_ARCHIVE_URL\"));\n+        }\n+\n+        @Override\n+        public void setup() throws Fault {\n+            jar = config.getPath(\"JTHARNESS_JAVATEST_JAR\");\n+            if (jar == null) {\n+                createDepsDir();\n+                var jarArchiveURL = config.getURL(\"JTHARNESS_ARCHIVE_URL\");\n+                if (jarArchiveURL == null) {\n+                    var jarArchiveURLBase = config.getURL(\"JTHARNESS_ARCHIVE_URL_BASE\");\n+                    if (jarArchiveURLBase != null) {\n+                        var version = config.getRequiredString(\"JTHARNESS_VERSION\");\n+                        var buildNumber = config.getRequiredString(\"JTHARNESS_BUILD_NUMBER\");\n+                        var file = config.getRequiredString(\"JTHARNESS_FILE\");\n+                        jarArchiveURL = newURL(\n+                                jarArchiveURLBase\n+                                        + \"\/\" + version\n+                                        + \"\/\" + buildNumber\n+                                        + \"\/\" + file);\n+                    }\n+                }\n+\n+                if (jarArchiveURL != null) {\n+                    var checksum = config.getRequiredString(\"JTHARNESS_ARCHIVE_CHECKSUM\");\n+                    var jarArchive = download(jarArchiveURL, depsDir, checksum);\n+                    var unpackDir = unpack(jarArchive, depsDir);\n+                    jar = unpackDir.resolve(\"lib\").resolve(\"javatest.jar\");\n+                    license = unpackDir.resolve(\"LICENSE\");\n+                    copyright = unpackDir.resolve(\"legal\").resolve(\"copyright.txt\");\n+                } else {\n+                    config.log(\"None of JTHARNESS_JAR, JTHARNESS_ARCHIVE_URL or JTHARNESS_ARCHIVE_URL_BASE are set; \"\n+                            + \"building from source\");\n+                    var codeToolsURLBase = config.getURL(\"CODETOOLS_URL_BASE\");\n+                    if (codeToolsURLBase == null) {\n+                        codeToolsURLBase = newURL(\"https:\/\/git.openjdk.java.net\");\n+                    }\n+                    var srcTag = config.getRequiredString(\"JTHARNESS_SRC_TAG\");\n+                    Path srcArchive;\n+                    if (srcTag.equals(\"tip\") || srcTag.equals(\"master\")) {\n+                        var branch = \"master\";\n+                        var srcArchiveURL = config.getURL(\n+                                codeToolsURLBase\n+                                        + \"\/jtharness\/archive\/\"\n+                                        + branch + \".zip\");\n+                        srcArchive = download(srcArchiveURL, depsDir, \"--\");\n+                    } else {\n+                        var srcArchiveURL = newURL(\n+                                codeToolsURLBase\n+                                        + \"\/jtharness\/archive\/\"\n+                                        + srcTag + \".zip\");\n+                        var checksum = config.getRequiredString(\"JTHARNESS_SRC_ARCHIVE_CHECKSUM\");\n+                        srcArchive = download(srcArchiveURL, depsDir, checksum);\n+                    }\n+                    var unpackDir = unpack(srcArchive, depsDir);\n+                    var buildDir = depsDir.resolve(\"build\");\n+                    ant.exec(unpackDir.resolve(\"build\").resolve(\"build.xml\"),\n+                            List.of(\"-DBUILD_DIR=\" + buildDir),\n+                            depsDir.resolve(\"build.log\"));\n+                    jar = buildDir.resolve(\"binaries\").resolve(\"lib\").resolve(\"javatest.jar\");\n+                    \/\/ The default build target for JTHarness build.xml does not build LICENSE and copyright.txt,\n+                    \/\/ and the dist target, which does build them, has too many other dependencies.\n+                    \/\/ So, pick up the license and copyright.txt from the source directory.\n+                    license = unpackDir.resolve(\"LICENSE\");\n+                    copyright = unpackDir.resolve(\"legal\").resolve(\"copyright.txt\");\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void verify() throws Fault {\n+            checkFile(jar);\n+            checkFile(license);\n+            checkFile(copyright);\n+        }\n+\n+        @Override\n+        public Map<String, String> getMakeArgs() {\n+            var notices = List.of(license, copyright);\n+            return Map.of(\"JAVATEST_JAR\", jar.toString(),\n+                    \"JTHARNESS_NOTICES\",  notices.stream()\n+                            .map(Path::toString)\n+                            .collect(Collectors.joining(\" \")));\n+        }\n+    }\n+\n+    static class JUnit extends Dependency {\n+        Path jar;\n+        Path license;\n+\n+        public JUnit(Config config, Tools tools) {\n+            super(\"junit\", config, tools);\n+        }\n+\n+        @Override\n+        public void setup() throws Fault {\n+            jar = config.getPath(\"JUNIT_JAR\");\n+            if (jar == null) {\n+                jar = downloadStandardJar(((urlBase, version) ->\n+                        urlBase\n+                        + \"\/org\/junit\/platform\/junit-platform-console-standalone\/\"\n+                        + version\n+                        + \"\/junit-platform-console-standalone-\" + version + \".jar\"\n+                ));\n+            }\n+\n+            license = config.getPath(\"JUNIT_LICENSE\");\n+            if (license == null) {\n+                var licenseFile = config.getString(\"JUNIT_LICENSE_FILE\");\n+                license = extract(jar, licenseFile, depsDir);\n+            }\n+        }\n+\n+        @Override\n+        public void verify() throws Fault {\n+            checkFile(jar);\n+            checkFile(license);\n+        }\n+\n+        @Override\n+        public Map<String, String> getMakeArgs() {\n+            return Map.of(\"JUNIT_JARS\", jar.toString(),\n+                    \"JUNIT_NOTICES\", license.toString());\n+        }\n+    }\n+\n+    static class TestNG extends Dependency {\n+        private Path jar;\n+        private Path license;\n+        private final Guice guice;\n+        private final JCommander jcommander;\n+\n+        public TestNG(Config config, Tools tools) {\n+            super(\"testng\", config, tools);\n+            this.guice = new Guice(config, tools);\n+            this.jcommander = new JCommander(config, tools);\n+        }\n+\n+        @Override\n+        public void setup() throws Fault {\n+            guice.setup();\n+            jcommander.setup();\n+\n+            jar = config.getPath(\"TESTNG_JAR\");\n+            if (jar == null) {\n+                jar = downloadStandardJar(((urlBase, version) ->\n+                        urlBase\n+                        + \"\/org\/testng\/testng\/\"\n+                        + version\n+                        + \"\/testng-\" + version + \".jar\"\n+                ));\n+            }\n+\n+            license = config.getPath(\"TESTNG_LICENSE\");\n+            if (license == null) {\n+                var licenseVersion = config.getRequiredString(\"TESTNG_LICENSE_VERSION\");\n+                var licenseURL = newURL(\n+                        \"https:\/\/raw.githubusercontent.com\/cbeust\/testng\/\" + licenseVersion + \"\/LICENSE.txt\");\n+                var checksum = config.getRequiredString(\"TESTNG_LICENSE_CHECKSUM\");\n+                license = download(licenseURL, depsDir, checksum);\n+            }\n+\n+        }\n+\n+        @Override\n+        public void verify() throws Fault {\n+            guice.verify();\n+            jcommander.verify();\n+\n+            checkFile(jar);\n+            checkFile(license);\n+        }\n+\n+        @Override\n+        public Map<String, String> getMakeArgs() {\n+            var jars = List.of(jar, jcommander.jar, guice.jar);\n+            return Map.of(\n+                    \"TESTNG_JARS\", jars.stream()\n+                            .map(Path::toString)\n+                            .collect(Collectors.joining(\" \")),\n+                    \"TESTNG_NOTICES\", license.toString());\n+        }\n+    }\n+\n+    static class Guice extends Dependency {\n+        Path jar;\n+\n+        public Guice(Config config, Tools tools) {\n+            super(\"google_guice\", config, tools);\n+        }\n+\n+        @Override\n+        public void setup() throws Fault {\n+            jar = config.getPath(\"GUICE_JAR\");\n+            if (jar == null) {\n+                jar = downloadStandardJar(((urlBase, version) ->\n+                        urlBase\n+                                + \"\/com\/google\/inject\/guice\/\"\n+                                + version\n+                                + \"\/guice-\" + version + \".jar\"\n+                ));\n+            }\n+        }\n+\n+        @Override\n+        public void verify() throws Fault {\n+            checkFile(jar);\n+        }\n+    }\n+\n+    static class JCommander extends Dependency {\n+        Path jar;\n+\n+        public JCommander(Config config, Tools tools) {\n+            super(\"jcommander\", config, tools);\n+        }\n+\n+        @Override\n+        public void setup() throws Fault {\n+            jar = config.getPath(\"JCOMMANDER_JAR\");\n+            if (jar == null) {\n+                jar = downloadStandardJar(((urlBase, version) ->\n+                        urlBase\n+                                + \"\/com\/beust\/jcommander\/\"\n+                                + version\n+                                + \"\/jcommander-\" + version + \".jar\"\n+                ));\n+            }\n+        }\n+\n+        @Override\n+        public void verify() throws Fault {\n+            checkFile(jar);\n+        }\n+    }\n+\n+    \/**\n+     * Generates a script to run \"make\", based on the set of dependencies.\n+     *\/\n+    static class MakeScript {\n+        private final Config config;\n+        MakeScript(Config config) {\n+            this.config = config;\n+        }\n+\n+        void writeFile(Path file, List<? extends Dependency> deps) throws Fault {\n+            var allMakeArgs = new TreeMap<String, String>();\n+            deps.forEach(d -> allMakeArgs.putAll(d.getMakeArgs()));\n+\n+            try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(file))) {\n+                out.println(\"#!\/bin\/sh\");\n+                out.println();\n+                out.println(\"cd \\\"\" + config.rootDir.resolve(\"make\") + \"\\\"\");\n+                out.println(\"make \\\\\");\n+                allMakeArgs.forEach((name, value) ->\n+                        out.printf(\"    %s=\\\"%s\\\" \\\\%n\", name, value));\n+                out.println(\"    \\\"$@\\\"\");\n+            } catch (IOException e) {\n+                throw new Fault(\"Error writing make command script: \" + file + \": \" + e);\n+            }\n+        }\n+    }\n+}\n","filename":"make\/Build.java","additions":1616,"deletions":0,"binary":false,"changes":1616,"status":"added"}]}