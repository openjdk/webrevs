{"files":[{"patch":"@@ -37,0 +37,1 @@\n+include jtdiff.gmk\n","filename":"make\/Makefile","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+#\n+# Copyright (c) 1999, 2016, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#----------------------------------------------------------------------\n+#\n+# compile com.sun.javatest.diff\n+\n+JAVAFILES.com.sun.javatest.diff := \\\n+\t$(shell $(FIND) $(JAVADIR)\/com\/sun\/javatest\/diff -name \\*.java )\n+\n+$(BUILDDIR)\/classes.com.sun.javatest.diff.ok: \\\n+\t\t$(JAVAFILES.com.sun.javatest.diff) \\\n+\t\t$(BUILDDIR)\/classes.com.sun.javatest.regtest.ok\n+\tCLASSPATH=\"$(CLASSDIR)$(PS)$(JAVATEST_JAR)$(PS)$(ANT_JAR)\" \\\n+\t    $(REGTEST_TOOL_JAVAC) $(REGTEST_TOOL_JAVAC_OPTIONS) \\\n+\t\t-d $(CLASSDIR) \\\n+\t\t-encoding ASCII \\\n+\t\t$(JAVAFILES.com.sun.javatest.diff)\n+\techo \"classes built at `date`\" > $@\n+\n+TARGETS.com.sun.javatest.diff += $(BUILDDIR)\/classes.com.sun.javatest.diff.ok\n+\n+#----------------------------------------------------------------------\n+#\n+# resources required for com.sun.javatest.diff\n+\n+RESOURCES.com.sun.javatest.diff = \\\n+\t$(CLASSDIR)\/com\/sun\/javatest\/diff\/i18n.properties\n+\n+TARGETS.com.sun.javatest.diff += $(RESOURCES.com.sun.javatest.diff)\n+\n+#----------------------------------------------------------------------\n+#\n+# include jtdiff in jtreg.jar\n+\n+PKGS.JAR.jtreg += com.sun.javatest.diff\n+TARGETS.JAR.jtreg += $(TARGETS.com.sun.javatest.diff)\n+\n+#----------------------------------------------------------------------\n+#\n+# executable scripts\n+\n+$(JTREG_IMAGEDIR)\/bin\/jtdiff: $(SRCSHAREBINDIR)\/jtdiff.sh\n+\t$(MKDIR) -p $(@D)\n+\t$(RM) $@\n+\t$(CP) $<  $@\n+\t$(CHMOD) a+x,a-w $@\n+\n+TARGETS.ZIP.jtreg += \\\n+\t$(JTREG_IMAGEDIR)\/bin\/jtdiff\n+\n+#----------------------------------------------------------------------\n+\n+TESTS += $(TESTS.jtdiff)\n+\n+\n","filename":"make\/jtdiff.gmk","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -54,1 +54,1 @@\n-### The following files are for the jtreg tool\n+### The following files are for the jtreg and jtdiff tools\n","filename":"make\/jtreg.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+#!\/bin\/sh\n+#\n+# Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# Usage:\n+#    jtdiff ...args....\n+#\n+# jtdiff requires a version of Java equivalent to JDK 1.5.0 or higher.\n+\n+# $JT_HOME can be used to specify the jtdiff installation directory\n+#   (e.g. \/usr\/local\/java\/jct-tools\/3.2.2)\n+#\n+# $JT_JAVA is used to specify the version of java to use when running JavaTest\n+#   (e.g. \/usr\/local\/java\/jdk1.5.0\/solaris-sparc\/bin\/java)\n+#\n+# jtdiff also provides an Ant task for direct invocation from Ant.\n+\n+# Determine jtdiff\/JavaTest installation directory\n+if [ -n \"$JT_HOME\" ]; then\n+    if [ ! -r $JT_HOME\/lib\/jtreg.jar ];then\n+        echo \"Invalid JT_HOME=$JT_HOME. Cannot find or read $JT_HOME\/lib\/jtreg.jar\"\n+       exit 1;\n+    fi\n+else\n+    # Deduce where script is installed\n+    # - should work on most derivatives of Bourne shell, like ash, bash, ksh,\n+    #   sh, zsh, etc, including on Windows, MKS (ksh) and Cygwin (ash or bash)\n+    if type -p type 1>\/dev\/null 2>&1 && test -z \"`type -p type`\" ; then\n+        myname=`type -p \"$0\"`\n+    elif type type 1>\/dev\/null 2>&1 ; then\n+        myname=`type \"$0\" | sed -e 's\/^.* is a tracked alias for \/\/' -e 's\/^.* is \/\/'`\n+    elif whence whence 1>\/dev\/null 2>&1 ; then\n+        myname=`whence \"$0\"`\n+    fi\n+    mydir=`dirname \"$myname\"`\n+    p=`cd \"$mydir\" ; pwd`\n+    while [ -n \"$p\" -a \"$p\" != \"\/\" ]; do\n+        if [ -r \"$p\"\/lib\/jtreg.jar ]; then JT_HOME=\"$p\" ; break; fi\n+        p=`dirname \"$p\"`\n+    done\n+    if [ -z \"$JT_HOME\" ]; then\n+        echo \"Cannot determine JT_HOME; please set it explicitly\"; exit 1\n+    fi\n+fi\n+\n+# Normalize JT_HOME if using Cygwin\n+case \"`uname -s`\" in\n+    CYGWIN* ) cygwin=1 ; JT_HOME=`cygpath -a -m \"$JT_HOME\"` ;;\n+esac\n+\n+\n+# Separate out -J* options for the JVM\n+# Unset IFS and use newline as arg separator to preserve spaces in args\n+DUALCASE=1  # for MKS: make case statement case-sensitive (6709498)\n+saveIFS=\"$IFS\"\n+nl='\n+'\n+for i in \"$@\" ; do\n+    IFS=\n+    if [ -n \"$cygwin\" ]; then i=`echo $i | sed -e 's|\/cygdrive\/\\([A-Za-z]\\)\/|\\1:\/|'` ; fi\n+    case $i in\n+    -J* )       javaOpts=$javaOpts$nl`echo $i | sed -e 's\/^-J\/\/'` ;;\n+    *   )       jtdiffOpts=$jtdiffOpts$nl$i ;;\n+    esac\n+    IFS=\"$saveIFS\"\n+done\n+unset DUALCASE\n+\n+# Determine java for jtdiff, from JT_JAVA, JAVA_HOME, java\n+if [ -n \"$JT_JAVA\" ]; then\n+    if [ -d \"$JT_JAVA\" ]; then\n+        JT_JAVA=\"$JT_JAVA\/bin\/java\"\n+    fi\n+elif [ -n \"$JAVA_HOME\" ]; then\n+    JT_JAVA=\"$JAVA_HOME\/bin\/java\"\n+else\n+    JT_JAVA=java\n+fi\n+\n+# Verify java version (1.)5 or newer used to run jtdiff\n+version=`\"$JT_JAVA\" -classpath \"${JT_HOME}\/lib\/jtreg.jar\" com.sun.javatest.regtest.agent.GetSystemProperty java.version 2>&1 |\n+        grep 'java.version=' | sed -e 's\/^.*=\/\/' -e 's\/^1\\.\/\/' -e 's\/\\([1-9][0-9]*\\).*\/\\1\/'`\n+\n+if [ -z \"$version\" ]; then\n+    echo \"Cannot determine version of java to run jtdiff\"\n+    exit 1;\n+elif [ \"$version\" -lt 5 ]; then\n+    echo \"java version 5 or later is required to run jtdiff\"\n+    exit 1;\n+fi\n+\n+# And finally ...\n+\n+IFS=$nl\n+\n+\"${JT_JAVA:-${JAVA_HOME:+$JAVA_HOME\/bin\/}java}\" \\\n+    $javaOpts \\\n+    -Dprogram=`basename \"$0\"` \\\n+    -cp \"${JT_HOME}\/lib\/jtreg.jar\" \\\n+    com.sun.javatest.diff.Main \\\n+    $jtdiffOpts\n","filename":"src\/share\/bin\/jtdiff.sh","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,160 @@\n+\/*\n+ * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javatest.diff;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import com.sun.javatest.Status;\n+import com.sun.javatest.TestResult;\n+import com.sun.javatest.TestSuite;\n+import com.sun.javatest.WorkDirectory;\n+import com.sun.javatest.util.I18NResourceBundle;\n+\n+public abstract class Diff {\n+\n+    public abstract boolean report(File outFile) throws Fault, InterruptedException;\n+\n+    protected boolean diff(List<File> files, File outFile)\n+            throws Fault, InterruptedException {\n+        this.outFile = outFile;\n+        List<DiffReader> list = new ArrayList<>();\n+        for (File f: files)\n+            list.add(open(f));\n+\n+        PrintWriter prevOut = out;\n+        if (outFile != null) {\n+            try {\n+                out = new PrintWriter(new BufferedWriter(new FileWriter(outFile))); \/\/ FIXME don't want to use PrintWriter\n+            } catch (IOException e) {\n+                throw new Fault(i18n, \"diff.cantOpenFile\", outFile, e);\n+            }\n+        }\n+\n+        try {\n+            initComparator();\n+\n+            initReporter();\n+            reporter.setTitle(title);\n+            reporter.setComparator(comparator);\n+            reporter.setReaders(list);\n+\n+            List<int[]> testCounts = new ArrayList<>();\n+            MultiMap<String, TestResult> table = new MultiMap<>();\n+            for (DiffReader r: list) {\n+                int index = table.addColumn(r.getFile().getPath());\n+                int[] counts = new int[Status.NUM_STATES];\n+                for (TestResult tr: r) {\n+                    table.addRow(index, tr.getTestName(), tr);\n+                    counts[tr.getStatus().getType()]++;\n+                }\n+                testCounts.add(counts);\n+            }\n+            reporter.setTestCounts(testCounts);\n+\n+            try {\n+                reporter.write(table);\n+            } catch (IOException e) {\n+                throw new Fault(i18n, \"diff.ioError\", e);\n+            }\n+\n+            return (reporter.diffs == 0);\n+        } finally {\n+            if (out != prevOut) {\n+\/\/                try {\n+                    out.close();\n+\/\/                } catch (IOException e) {\n+\/\/                    throw new Fault(i18n, \"main.ioError\", e);\n+\/\/                }\n+                out = prevOut;\n+            }\n+        }\n+    }\n+\n+    protected void initFormat() {\n+        if (format == null && outFile != null) {\n+            String name = outFile.getName();\n+            int dot = name.lastIndexOf(\".\");\n+            if (dot != -1)\n+                format = name.substring(dot + 1).toLowerCase();\n+        }\n+    }\n+\n+    protected void initReporter() throws Fault {\n+        if (reporter == null) {\n+            try {\n+                initFormat();\n+                if (format != null && format.equals(\"html\"))\n+                    reporter = new HTMLReporter(out);\n+                else\n+                    reporter = new SimpleReporter(out);\n+            } catch (IOException e) {\n+                throw new Fault(i18n, \"diff.cantOpenReport\", e);\n+            }\n+        }\n+    }\n+\n+    protected void initComparator() {\n+        if (comparator == null)\n+            comparator = new StatusComparator(includeReason);\n+    }\n+\n+    protected DiffReader open(File f) throws Fault {\n+        if (!f.exists())\n+            throw new Fault(i18n, \"main.cantFindFile\", f);\n+\n+        try {\n+            if (WorkDirectoryReader.accepts(f))\n+                return new WorkDirectoryReader(f);\n+\n+            if (ReportReader.accepts(f))\n+                return new ReportReader(f);\n+\n+            throw new Fault(i18n, \"main.unrecognizedFile\", f);\n+\n+        } catch (TestSuite.Fault\n+                 | WorkDirectory.Fault\n+                 | IOException e) {\n+            throw new Fault(i18n, \"main.cantOpenFile\", f, e);\n+        }\n+\n+    }\n+\n+    protected File outFile;\n+    protected PrintWriter out;\n+    protected Comparator<TestResult> comparator;\n+    protected Reporter reporter;\n+    protected boolean includeReason;\n+    protected String format;\n+    protected String title;\n+    private static final I18NResourceBundle i18n = I18NResourceBundle.getBundleForClass(Diff.class);\n+}\n","filename":"src\/share\/classes\/com\/sun\/javatest\/diff\/Diff.java","additions":160,"deletions":0,"binary":false,"changes":160,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javatest.diff;\n+\n+import java.io.File;\n+\n+import com.sun.javatest.TestResult;\n+\n+\/**\n+ * Interface for reading a series of test-status results.\n+ *\/\n+public interface DiffReader extends Iterable<TestResult> {\n+    File getWorkDirectory();\n+    String getFileType();\n+    File getFile();\n+}\n+\n","filename":"src\/share\/classes\/com\/sun\/javatest\/diff\/DiffReader.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javatest.diff;\n+\n+import com.sun.javatest.util.I18NResourceBundle;\n+\n+\/**\n+ * Exception to report a problem while executing in Main.\n+ *\/\n+public class Fault extends Exception {\n+\n+    static final long serialVersionUID = 1607979458544175906L;\n+\n+    Fault(I18NResourceBundle i18n, String s, Object... args) {\n+        super(i18n.getString(s, args));\n+    }\n+}\n","filename":"src\/share\/classes\/com\/sun\/javatest\/diff\/Fault.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,350 @@\n+\/*\n+ * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javatest.diff;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.Date;\n+import java.util.Map;\n+\n+import com.sun.javatest.Status;\n+import com.sun.javatest.TestResult;\n+import com.sun.javatest.util.I18NResourceBundle;\n+\n+import static com.sun.javatest.util.HTMLWriter.*;\n+\n+\/*\n+ * TODO: import CSS\n+ * TODO: links to .jtr files\n+ *\/\n+\n+\/**\n+ * Report differences to an HTML file.\n+ *\/\n+public class HTMLReporter extends Reporter {\n+\n+    \/** Creates a new instance of HTMLReporter *\/\n+    public HTMLReporter(Writer out) throws IOException {\n+        this.out = new HTMLWriter(out, DOCTYPE);\n+        this.out.setI18NResourceBundle(i18n);\n+    }\n+\n+    public void write(MultiMap<String, TestResult> table) throws IOException {\n+        this.table = table;\n+        size = table.getColumns();\n+\n+        startReport(title);\n+\n+        out.startTag(H1);\n+        if (title == null)\n+            out.writeI18N(\"html.head.notitle\");\n+        else\n+            out.writeI18N(\"html.head.title\", title);\n+        out.endTag(H1);\n+\n+        writeIndexTable();\n+        writeMainTable();\n+        writeSummary();\n+\n+        endReport();\n+    }\n+\n+    protected void startReport(String title) throws IOException {\n+        out.startTag(HTML);\n+        writeHead(title);\n+        out.startTag(BODY);\n+    }\n+\n+    protected void endReport() throws IOException {\n+        out.startTag(HR);\n+        out.writeI18N(\"html.generatedAt\", new Date());\n+        out.endTag(BODY);\n+\n+        out.endTag(HTML);\n+        out.flush();\n+    }\n+\n+    protected void writeHead(String title) throws IOException {\n+        out.startTag(HEAD);\n+        out.startTag(TITLE);\n+        if (title == null)\n+            out.writeI18N(\"html.head.notitle\");\n+        else\n+            out.writeI18N(\"html.head.title\", title);\n+        out.endTag(TITLE);\n+        out.startTag(STYLE);\n+        out.writeAttr(TYPE, \"text\/css\");\n+        out.write(\"\\n\");\n+        out.write(\"table   { background-color:white }\");\n+        out.write(\"tr.head { background-color:#dddddd }\");\n+        out.write(\"tr.odd  { background-color:#eeeeee }\");\n+        out.write(\"tr.even { background-color:white } \");\n+        out.write(\"td { padding: 0 .5em }\");\n+        out.write(\"td.pass { background-color:#ddffdd } \");\n+        out.write(\"td.fail { background-color:#ffdddd } \");\n+        out.write(\"td.error { background-color:#ddddff } \");\n+        out.write(\"td.notRun { background-color:#dddddd } \");\n+        out.write(\"th { padding: 0 .5em }\");\n+        out.write(\"hr      { margin-top:30px; }\");\n+        out.write(\"\\n\");\n+        out.endTag(STYLE);\n+        out.endTag(HEAD);\n+\n+    }\n+\n+    private void writeIndexTable() throws IOException {\n+        out.startTag(H2);\n+        out.writeI18N(\"html.head.sets\");\n+        out.endTag(H2);\n+\n+        out.startTag(TABLE);\n+        out.writeAttr(FRAME, BOX);\n+        out.writeAttr(RULES, GROUPS);\n+        out.startTag(THEAD);\n+        out.startTag(TR);\n+        out.writeAttr(CLASS, HEAD);\n+        out.startTag(TH);\n+        out.writeI18N(\"html.th.set\");\n+        out.endTag(TH);\n+        out.startTag(TH);\n+        out.writeI18N(\"html.th.location\");\n+        out.endTag(TH);\n+        writeIndexTableInfoHeadings();\n+\/\/        out.startTag(TH);\n+\/\/        out.writeI18N(\"html.th.type\");\n+\/\/        out.endTag(TH);\n+        for (int c = 0; c < Status.NUM_STATES; c++) {\n+            out.startTag(TH);\n+            switch (c) {\n+                case Status.PASSED:\n+                    out.writeI18N(\"html.th.pass\");\n+                    break;\n+                case Status.FAILED:\n+                    out.writeI18N(\"html.th.fail\");\n+                    break;\n+                case Status.ERROR:\n+                    out.writeI18N(\"html.th.error\");\n+                    break;\n+                default:\n+                    out.writeI18N(\"html.th.notRun\");\n+                    break;\n+            }\n+            out.endTag(TH);\n+        }\n+        out.startTag(TH);\n+        out.writeI18N(\"html.th.total\");\n+        out.endTag(TH);\n+        out.endTag(TR);\n+        out.endTag(THEAD);\n+\n+        out.startTag(TBODY);\n+        for (int i = 0; i < size; i++) {\n+            out.startTag(TR);\n+            out.writeAttr(CLASS, (i % 2 == 0 ? EVEN : ODD));\n+            out.startTag(TD);\n+            out.write(String.valueOf(i + 1));\n+            out.endTag(TD);\n+            out.startTag(TD);\n+            out.write(table.getColumnName(i));\n+            out.endTag(TD);\n+            writeIndexTableInfoValues(table.getColumnName(i));\n+\/\/            out.startTag(TD);\n+\/\/            out.write(\"??\");\n+\/\/            out.endTag(TD);\n+            int total = 0;\n+            int[] counts = testCounts.get(i);\n+            for (int c = 0; c < Status.NUM_STATES; c++) {\n+                out.startTag(TD);\n+                if (counts[c] > 0)\n+                    out.write(String.valueOf(counts[c]));\n+                else\n+                    out.writeEntity(\"&nbsp;\");\n+                total += counts[c];\n+                out.endTag(TD);\n+            }\n+            out.startTag(TD);\n+            out.write(String.valueOf(total));\n+            out.endTag(TD);\n+            out.endTag(TR);\n+        }\n+        out.endTag(TBODY);\n+        out.endTag(TABLE);\n+    }\n+\n+    protected void writeIndexTableInfoHeadings() throws IOException {\n+    }\n+\n+    protected void writeIndexTableInfoValues(String name) throws IOException {\n+    }\n+\n+    private void writeMainTable() throws IOException {\n+        diffs = 0;\n+        for (Map.Entry<String, MultiMap.Entry<TestResult>> e: table.entrySet()) {\n+            String testName = e.getKey();\n+            MultiMap.Entry<TestResult> result = e.getValue();\n+            if (result.allEqual(comparator))\n+                continue;\n+            if (diffs == 0) {\n+                out.startTag(H2);\n+                out.writeI18N(\"html.head.differences\");\n+                out.endTag(H2);\n+                out.startTag(TABLE);\n+                out.writeAttr(FRAME, BOX);\n+                out.writeAttr(RULES, GROUPS);\n+                out.startTag(THEAD);\n+                out.startTag(TR);\n+                out.writeAttr(CLASS, HEAD);\n+                out.startTag(TH);\n+                out.writeI18N(\"html.th.test\");\n+                out.endTag(TH);\n+                for (int i = 0; i < result.getSize(); i++) {\n+                    out.startTag(TH);\n+                    if (compact)\n+                        out.write(String.valueOf(i + 1));\n+                    else\n+                        out.writeI18N(\"html.th.setN\", i + 1);\n+                    out.endTag(TH);\n+                }\n+                out.endTag(TR);\n+                out.endTag(THEAD);\n+                out.startTag(TBODY);\n+            }\n+            out.startTag(TR);\n+            out.writeAttr(CLASS, (diffs % 2 == 0 ? EVEN : ODD));\n+            out.startTag(TD);\n+            out.write(testName);\n+            out.endTag(TD);\n+            for (int i = 0; i < result.getSize(); i++) {\n+                TestResult tr = result.get(i);\n+                File trFile = (tr == null ? null : tr.getFile());\n+                if (trFile == null) {\n+                    File wd = readers.get(i).getWorkDirectory();\n+                    if (wd != null)\n+                        trFile = new File(wd, tr.getWorkRelativePath());\n+                }\n+                out.startTag(TD);\n+                Status s = (tr == null ? null : tr.getStatus());\n+                out.writeAttr(CLASS, getClassAttr(s));\n+                String text = getText(s);\n+                if (trFile != null && trFile.exists()) {\n+                    out.startTag(A);\n+                    out.writeAttr(HREF, trFile.toURI().toString());\n+                    if (text.startsWith(\"&\"))\n+                        out.writeEntity(text);\n+                    else\n+                        out.write(text);\n+                    out.endTag(A);\n+                } else {\n+                    if (text.startsWith(\"&\"))\n+                        out.writeEntity(text);\n+                    else\n+                        out.write(text);\n+                }\n+                out.endTag(TD);\n+            }\n+            out.endTag(TR);\n+            diffs++;\n+        }\n+        if (diffs > 0) {\n+            out.endTag(TBODY);\n+            out.endTag(TABLE);\n+        }\n+    }\n+\n+    private void writeSummary() throws IOException {\n+        out.startTag(P);\n+        if (diffs == 0)\n+            out.writeI18N(\"html.diffs.none\");\n+        else\n+            out.writeI18N(\"html.diffs.count\", diffs);\n+        out.endTag(P);\n+    }\n+\n+    protected String getClassAttr(Status s) {\n+        switch (s == null ? Status.NOT_RUN : s.getType()) {\n+            case Status.PASSED:\n+                return PASS;\n+            case Status.FAILED:\n+                return FAIL;\n+            case Status.ERROR:\n+                return ERROR;\n+            default:\n+                return NOT_RUN;\n+        }\n+    }\n+\n+    protected String getText(Status s) {\n+        if (statusStrings == null) {\n+            statusStrings = new String[Status.NUM_STATES];\n+            if (compact) {\n+                statusStrings[Status.PASSED] = i18n.getString(\"html.pass.compact\");\n+                statusStrings[Status.FAILED] = i18n.getString(\"html.fail.compact\");\n+                statusStrings[Status.ERROR] = i18n.getString(\"html.error.compact\");\n+                statusStrings[Status.NOT_RUN] = i18n.getString(\"html.notRun.compact\");\n+            } else {\n+                statusStrings[Status.PASSED] = i18n.getString(\"html.pass\");\n+                statusStrings[Status.FAILED] = i18n.getString(\"html.fail\");\n+                statusStrings[Status.ERROR] = i18n.getString(\"html.error\");\n+                statusStrings[Status.NOT_RUN] = i18n.getString(\"html.notRun\");\n+            }\n+        }\n+        return statusStrings[s == null ? Status.NOT_RUN : s.getType()];\n+    }\n+\n+    private String[] statusStrings;\n+\n+    protected final HTMLWriter out;\n+    private MultiMap<String, TestResult> table;\n+    private int size;\n+\n+    private static final String DOCTYPE = \"<!DOCTYPE HTML>\";\n+\n+    \/\/ HTML tags\n+    private static final String THEAD = \"thead\";\n+    private static final String TBODY = \"tbody\";\n+\n+    \/\/ HTML attribute names\n+    private static final String CLASS = \"class\";\n+    private static final String FRAME = \"frame\";\n+    private static final String RULES = \"rules\";\n+\n+    \/\/ HTML attribute values\n+    private static final String BOX = \"box\";\n+    private static final String GROUPS = \"groups\";\n+\n+    \/\/ HTML class values\n+    private static final String HEAD = \"head\";\n+    private static final String ODD  = \"odd\";\n+    private static final String EVEN = \"even\";\n+    private static final String PASS = \"pass\";\n+    private static final String FAIL = \"fail\";\n+    private static final String ERROR = \"error\";\n+    private static final String NOT_RUN = \"notRun\";\n+\n+    private boolean compact = Boolean.TRUE.equals(Boolean.getBoolean(\"jtdiff.html.compact\"));\n+    private static I18NResourceBundle i18n = I18NResourceBundle.getBundleForClass(HTMLReporter.class);\n+}\n","filename":"src\/share\/classes\/com\/sun\/javatest\/diff\/HTMLReporter.java","additions":350,"deletions":0,"binary":false,"changes":350,"status":"added"},{"patch":"@@ -0,0 +1,559 @@\n+\/*\n+ * Copyright (c) 1996, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javatest.diff;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.net.URL;\n+\n+import com.sun.javatest.util.I18NResourceBundle;\n+\n+\/**\n+ * A class to facilitate writing HTML via a stream.\n+ *\/\n+public class HTMLWriter\n+{\n+    \/**\n+     * Create an HTMLWriter object, using a default doctype for HTML 3.2.\n+     * @param out a Writer to which to write the generated HTML\n+     * @throws IOException if there is a problem writing to the underlying stream\n+     *\/\n+    public HTMLWriter(Writer out) throws IOException {\n+        this(out, \"<!DOCTYPE HTML PUBLIC \\\"-\/\/W3C\/\/DTD HTML 3.2\/\/EN\\\">\");\n+    }\n+\n+    \/**\n+     * Create an HTMLWriter object, using a specifed doctype header.\n+     * @param out a Writer to which to write the generated HTML\n+     * @param docType a string containing a doctype header for the HTML to be generetaed\n+     * @throws IOException if there is a problem writing to the underlying stream\n+     *\/\n+    public HTMLWriter(Writer out, String docType) throws IOException {\n+        if (out instanceof BufferedWriter)\n+            this.out = (BufferedWriter) out;\n+        else\n+            this.out = new BufferedWriter(out);\n+        this.out.write(docType);\n+        this.out.newLine();\n+    }\n+\n+    \/**\n+     * Create an HTMLWriter object, using a specified bundle for l0calizing messages.\n+     * @param out a Writer to which to write the generated HTML\n+     * @param i18n a resource bundle to use to localize messages\n+     * @throws IOException if there is a problem writing to the underlying stream\n+     *\/\n+    public HTMLWriter(Writer out, I18NResourceBundle i18n) throws IOException {\n+        this(out);\n+        this.i18n = i18n;\n+    }\n+\n+\n+    \/**\n+     * Create an HTMLWriter object, using a specifed doctype header and\n+     * using a specified bundle for l0calizing messages.\n+     * @param out a Writer to which to write the generated HTML\n+     * @param docType a string containing a doctype header for the HTML to be generetaed\n+     * @param i18n a resource bundle to use to localize messages\n+     * @throws IOException if there is a problem writing to the underlying stream\n+     *\/\n+    public HTMLWriter(Writer out, String docType, I18NResourceBundle i18n) throws IOException {\n+        this(out, docType);\n+        this.i18n = i18n;\n+    }\n+\n+    \/**\n+     * Set the reource bundle to be used for localizing messages.\n+     * @param i18n the resource bundle to be used for localizing messages\n+     *\/\n+    public void setI18NResourceBundle(I18NResourceBundle i18n) {\n+        this.i18n = i18n;\n+    }\n+\n+    \/**\n+     * Flush the stream, and the underlying output stream.\n+     * @throws IOException if there is a problem writing to the underlying stream\n+     *\/\n+    public void flush() throws IOException {\n+        out.flush();\n+    }\n+\n+    \/**\n+     * Close the stream, and the underlying output stream.\n+     * @throws IOException if there is a problem closing the underlying stream\n+     *\/\n+    public void close() throws IOException {\n+        out.close();\n+    }\n+\n+    \/**\n+     * Write a newline to the underlying output stream.\n+     * @throws IOException if there is a problem writing to the underlying stream\n+     *\/\n+    public void newLine() throws IOException {\n+        out.newLine();\n+    }\n+\n+    \/**\n+     * Start an HTML tag.  If a prior tag has been started, it will\n+     * be closed first. Once a tag has been opened, attributes for the\n+     * tag may be written out, followed by body content before finally\n+     * ending the tag.\n+     * @param tag the tag to be started\n+     * @throws IOException if there is a problem writing to the underlying stream\n+     * @see #writeAttr\n+     * @see #write\n+     * @see #endTag\n+     *\/\n+    public void startTag(String tag) throws IOException {\n+        if (state == IN_TAG) {\n+            out.write(\">\");\n+            state = IN_BODY;\n+        }\n+        newLine();\n+        out.write(\"<\");\n+        out.write(tag);\n+        state = IN_TAG;\n+    }\n+\n+    \/**\n+     * Finish an HTML tag. It is expected that a call to endTag will match\n+     * a corresponding earlier call to startTag, but there is no formal check\n+     * for this.\n+     * @param tag the tag to be closed.\n+     * @throws IOException if there is a problem writing to the underlying stream\n+     *\/\n+    public void endTag(String tag) throws IOException {\n+        if (state == IN_TAG) {\n+            out.write(\">\");\n+            state = IN_BODY;\n+            out.newLine();\n+        }\n+        out.write(\"<\/\");\n+        out.write(tag);\n+        out.write(\">\");\n+        \/\/out.newLine();   \/\/ PATCHED, jjg\n+        state = IN_BODY;\n+    }\n+\n+    \/**\n+     * Finish an empty element tag, such as a META, BASE or LINK tag.\n+     * This is expected to correspond with a startTag.\n+     * @param tag the tag which is being closed.  this is only useful for\n+     *        validation, it is not written out\n+     * @throws IllegalStateException if this call does not follow startTag\n+     *         (stream is not currently inside a tag)\n+     * @throws IOException if there is a problem writing to the underlying stream\n+     *\/\n+    public void endEmptyTag(String tag) throws IOException {\n+        if (state != IN_TAG)\n+            throw new IllegalStateException();\n+\n+        out.write(\">\");\n+        state = IN_BODY;\n+        out.newLine();\n+    }\n+\n+    \/**\n+     * Write an attribute for a tag. A tag must previously have been started.\n+     * All tag attributes must be written before any body text is written.\n+     * The value will be quoted if necessary when writing it to the underlying\n+     * stream. No check is made that the attribute is valid for the current tag.\n+     * @param name the name of the attribute to be written\n+     * @param value the value of the attribute to be written\n+     * @throws IllegalStateException if the stream is not in a state to\n+     * write attributes -- e.g. if this call does not follow startTag or other\n+     * calls of writteAttr\n+     * @throws IOException if there is a problem writing to the underlying stream\n+     *\/\n+    public void writeAttr(String name, String value) throws IOException {\n+        if (state != IN_TAG)\n+            throw new IllegalStateException();\n+\n+        out.write(\" \");\n+        out.write(name);\n+        out.write(\"=\");\n+        boolean alpha = true;\n+        for (int i = 0; i < value.length() && alpha; i++)\n+            alpha = Character.isLetter(value.charAt(i));\n+        if (!alpha)\n+            out.write(\"\\\"\");\n+        out.write(value);\n+        if (!alpha)\n+            out.write(\"\\\"\");\n+    }\n+\n+    \/**\n+     * Write an attribute for a tag. A tag must previously have been started.\n+     * All tag attributes must be written before any body text is written.\n+     * The value will be quoted if necessary when writing it to the underlying\n+     * stream. No check is made that the attribute is valid for the current tag.\n+     * @param name the name of the attribute to be written\n+     * @param value the value of the attribute to be written\n+     * @throws IllegalStateException if the stream is not in a state to\n+     * write attributes -- e.g. if this call does not follow startTag or other\n+     * calls of writteAttr\n+     * @throws IOException if there is a problem writing to the underlying stream\n+     *\/\n+    public void writeAttr(String name, int value) throws IOException {\n+        writeAttr(name, Integer.toString(value));\n+    }\n+\n+    \/**\n+     * Write a line of text, followed by a newline.\n+     * The text will be escaped as necessary.\n+     * @param text the text to be written.\n+     * @throws IOException if there is a problem closing the underlying stream\n+     *\/\n+    public void writeLine(String text) throws IOException {\n+        write(text);\n+        out.newLine();\n+    }\n+\n+    \/**\n+     * Write body text, escaping it as necessary.\n+     * If this call follows a call of startTag, the open tag will be\n+     * closed -- meaning that no more attributes can be written until another\n+     * tag is started.  If the text value is null, the current tag will still\n+     * be closed, but no other text will be written.\n+     * @param text the text to be written, may be null or zero length.\n+     * @throws IOException if there is a problem writing to the underlying stream\n+     *\/\n+    public void write(String text) throws IOException {\n+        if (state == IN_TAG) {\n+            out.write(\">\");\n+            state = IN_BODY;\n+        }\n+\n+        if (text == null)\n+            return;\n+\n+        \/\/ check to see if there are any special characters\n+        boolean specialChars = false;\n+        for (int i = 0; i < text.length() && !specialChars; i++) {\n+            switch (text.charAt(i)) {\n+            case '<': case '>': case '&':\n+                specialChars = true;\n+            }\n+        }\n+\n+        \/\/ if there are special characters write the string character at a time;\n+        \/\/ otherwise, write it out as is\n+        if (specialChars) {\n+            for (int i = 0; i < text.length(); i++) {\n+                char c = text.charAt(i);\n+                switch (c) {\n+                case '<': out.write(\"&lt;\"); break;\n+                case '>': out.write(\"&gt;\"); break;\n+                case '&': out.write(\"&amp;\"); break;\n+                default: out.write(c);\n+                }\n+            }\n+        }\n+        else\n+            out.write(text);\n+    }\n+\n+    \/**\n+     * Write a basic HTML entity, such as &nbsp; or &#123; .\n+     * @param entity the entity to write\n+     * @throws IOException if there is a problem writing to the underlying stream\n+     *\/\n+    public void writeEntity(String entity) throws IOException {\n+        if (state == IN_TAG) {\n+            out.write(\">\");\n+            state = IN_BODY;\n+        }\n+        out.write(entity);\n+    }\n+\n+    \/**\n+     * Write an image tag, using a specified path for the image source attribute.\n+     * @param imagePath the path for the image source\n+     * @throws IOException if there is a problem closing the underlying stream\n+     *\/\n+    public void writeImage(String imagePath) throws IOException {\n+        startTag(IMAGE);\n+        writeAttr(SRC, imagePath);\n+    }\n+\n+    \/**\n+     * Write an image tag, using a specified path for the image source attribute.\n+     * @param imageURL the url for the image source\n+     * @throws IOException if there is a problem closing the underlying stream\n+     *\/\n+    public void writeImage(URL imageURL) throws IOException {\n+        writeImage(imageURL.toString());\n+    }\n+\n+    \/**\n+     * Write a hypertext link.\n+     * @param anchor the target for the link\n+     * @param body the body text for the link\n+     * @throws IOException if there is a problem closing the underlying stream\n+     *\/\n+    public void writeLink(String anchor, String body) throws IOException {\n+        startTag(A);\n+        writeAttr(HREF, anchor);\n+        write(body);\n+        endTag(A);\n+    }\n+\n+    \/**\n+     * Write a hypertext link.\n+     * @param file the target for the link\n+     * @param body the body text for the link\n+     * @throws IOException if there is a problem closing the underlying stream\n+     *\/\n+    public void writeLink(File file, String body) throws IOException {\n+        startTag(A);\n+        StringBuilder sb = new StringBuilder();\n+        String path = file.getPath().replace(File.separatorChar, '\/');\n+        if (file.isAbsolute() && !path.startsWith(\"\/\"))\n+            sb.append('\/');\n+        sb.append(path);\n+        writeAttr(HREF, sb.toString());\n+        write(body);\n+        endTag(A);\n+    }\n+\n+    \/**\n+     * Write a hypertext link.\n+     * @param file the target and body for the link\n+     * @throws IOException if there is a problem closing the underlying stream\n+     *\/\n+    public void writeLink(File file) throws IOException {\n+        writeLink(file, file.getPath());\n+    }\n+\n+    \/**\n+     * Write a hypertext link.\n+     * @param url the target for the link\n+     * @param body the body text for the link\n+     * @throws IOException if there is a problem closing the underlying stream\n+     *\/\n+    public void writeLink(URL url, String body) throws IOException {\n+        startTag(A);\n+        writeAttr(HREF, url.toString());\n+        write(body);\n+        endTag(A);\n+    }\n+\n+    \/**\n+     * Write the destination marker for a hypertext link.\n+     * @param anchor the destination marker for hypertext links\n+     * @param body the body text for the marker\n+     * @throws IOException if there is a problem closing the underlying stream\n+     *\/\n+    public void writeLinkDestination(String anchor, String body) throws IOException {\n+        startTag(A);\n+        writeAttr(NAME, anchor);\n+        write(body);\n+        endTag(A);\n+    }\n+\n+    \/**\n+     * Write a parameter tag.\n+     * @param name the name of the parameter\n+     * @param value the value of the parameter\n+     * @throws IOException if there is a problem closing the underlying stream\n+     *\/\n+    public void writeParam(String name, String value) throws IOException {\n+        startTag(PARAM);\n+        writeAttr(NAME, name);\n+        writeAttr(VALUE, value);\n+    }\n+\n+    \/**\n+     * Write a style attribute.\n+     * @param value the value for the style atrtribute\n+     * @throws IOException if there is a problem closing the underlying stream\n+     *\/\n+    public void writeStyleAttr(String value) throws IOException {\n+        writeAttr(STYLE, value);\n+    }\n+\n+    \/**\n+     * Write a localized message, using a specified resource bundle.\n+     * @param i18n the resource bundle used to localize the message\n+     * @param key the key for the message to be localized\n+     * @throws IOException if there is a problem closing the underlying stream\n+     *\/\n+    public void write(I18NResourceBundle i18n, String key) throws IOException {\n+        write(i18n.getString(key));\n+    }\n+\n+    \/**\n+     * Write a localized message, using a specified resource bundle.\n+     * @param i18n the resource bundle used to localize the message\n+     * @param key the key for the message to be localized\n+     * @param arg an argument to be formatted into the localized message\n+     * @throws IOException if there is a problem closing the underlying stream\n+     *\/\n+    public void write(I18NResourceBundle i18n, String key, Object arg) throws IOException {\n+        write(i18n.getString(key, arg));\n+    }\n+\n+    \/**\n+     * Write a localized message, using a specified resource bundle.\n+     * @param i18n the resource bundle used to localize the message\n+     * @param key the key for the message to be localized\n+     * @param args arguments to be formatted into the localized message\n+     * @throws IOException if there is a problem closing the underlying stream\n+     *\/\n+    public void write(I18NResourceBundle i18n, String key, Object[] args) throws IOException {\n+        write(i18n.getString(key, args));\n+    }\n+\n+    \/**\n+     * Write a localized message, using the default resource bundle.\n+     * @param key the key for the message to be localized\n+     * @throws IOException if there is a problem closing the underlying stream\n+     *\/\n+    public void writeI18N(String key) throws IOException {\n+        write(i18n.getString(key));\n+    }\n+\n+    \/**\n+     * Write a localized message, using the default resource bundle.\n+     * @param key the key for the message to be localized\n+     * @param arg an argument to be formatted into the localized message\n+     * @throws IOException if there is a problem closing the underlying stream\n+     *\/\n+    public void writeI18N(String key, Object arg) throws IOException {\n+        write(i18n.getString(key, arg));\n+    }\n+\n+    \/**\n+     * Write a localized message, using the default resource bundle.\n+     * @param key the key for the message to be localized\n+     * @param args arguments to be formatted into the localized message\n+     * @throws IOException if there is a problem closing the underlying stream\n+     *\/\n+    public void writeI18N(String key, Object[] args) throws IOException {\n+        write(i18n.getString(key, args));\n+    }\n+\n+    \/** The HTML \"a\" tag. *\/\n+    public static final String A = \"a\";\n+    \/** The HTML \"align\" attribute. *\/\n+    public static final String ALIGN = \"align\";\n+    \/** The HTML \"b\" tag. *\/\n+    public static final String B = \"b\";\n+    \/** The HTML \"body\" tag. *\/\n+    public static final String BODY = \"body\";\n+    \/** The HTML \"border\" attribute. *\/\n+    public static final String BORDER = \"border\";\n+    \/** The HTML \"br\" tag. *\/\n+    public static final String BR = \"br\";\n+    \/** The HTML \"classid\" attribute. *\/\n+    public static final String CLASSID  = \"classid\";\n+    \/** The HTML \"code\" tag. *\/\n+    public static final String CODE  = \"code\";\n+    \/** The HTML \"color\" attribte. *\/\n+    public static final String COLOR  = \"color\";\n+    \/** The HTML \"col\" attribute value. *\/\n+    public static final String COL = \"col\";\n+    \/** The HTML \"font\" tag. *\/\n+    public static final String FONT = \"font\";\n+    \/** The HTML \"h1\" tag. *\/\n+    public static final String H1 = \"h1\";\n+    \/** The HTML \"h2\" tag. *\/\n+    public static final String H2 = \"h2\";\n+    \/** The HTML \"h3\" tag. *\/\n+    public static final String H3 = \"h3\";\n+    \/** The HTML \"h4\" tag. *\/\n+    public static final String H4 = \"h4\";\n+    \/** The HTML \"head\" tag. *\/\n+    public static final String HEAD = \"head\";\n+    \/** The HTML \"href\" attribute. *\/\n+    public static final String HREF = \"href\";\n+    \/** The HTML \"html\" tag. *\/\n+    public static final String HTML = \"html\";\n+    \/** The HTML \"hr\" tag. *\/\n+    public static final String HR = \"hr\";\n+    \/** The HTML \"i\" tag. *\/\n+    public static final String I = \"i\";\n+    \/** The HTML \"image\" tag. *\/\n+    public static final String IMAGE = \"image\";\n+    \/** The HTML \"left\" attribute value. *\/\n+    public static final String LEFT = \"left\";\n+    \/** The HTML \"li\" tag. *\/\n+    public static final String LI = \"li\";\n+    \/** The HTML \"link\" tag. *\/\n+    public static final String LINK = \"link\";\n+    \/** The HTML \"name\" attribute. *\/\n+    public static final String NAME = \"name\";\n+    \/** The HTML \"object\" tag. *\/\n+    public static final String OBJECT = \"object\";\n+    \/** The HTML \"p\" tag. *\/\n+    public static final String PARAM = \"param\";\n+    \/** The HTML \"param\" tag. *\/\n+    public static final String P = \"p\";\n+    \/** The HTML \"rel\" attribute value. *\/\n+    public static final String REL = \"rel\";\n+    \/** The HTML \"right\" attribute value. *\/\n+    public static final String RIGHT = \"right\";\n+    \/** The HTML \"row\" attribute value. *\/\n+    public static final String ROW = \"row\";\n+    \/** The HTML \"small\" tag. *\/\n+    public static final String SMALL = \"small\";\n+    \/** The HTML \"src\" attribute. *\/\n+    public static final String SRC = \"src\";\n+    \/** The HTML \"scope\" attribute. *\/\n+    public static final String SCOPE = \"scope\";\n+    \/** The HTML \"style\" attribute. *\/\n+    public static final String STYLE = \"style\";\n+    \/** The HTML \"table\" tag. *\/\n+    public static final String TABLE = \"table\";\n+    \/** The HTML \"td\" tag. *\/\n+    public static final String TD = \"td\";\n+    \/** The HTML \"title\"attribute. *\/\n+    public static final String TITLE = \"title\";\n+    \/** The HTML \"th\" tag. *\/\n+    public static final String TH = \"th\";\n+    \/** The HTML \"top\" attribute value. *\/\n+    public static final String TOP = \"top\";\n+    \/** The HTML \"tr\" tag. *\/\n+    public static final String TR = \"tr\";\n+    \/** The HTML \"type\" attribute. *\/\n+    public static final String TYPE = \"type\";\n+    \/** The HTML \"ul\" tag. *\/\n+    public static final String UL = \"ul\";\n+    \/** The HTML \"valign\" attribute. *\/\n+    public static final String VALIGN = \"valign\";\n+    \/** The HTML \"value\" attribute. *\/\n+    public static final String VALUE = \"value\";\n+\n+\n+    private BufferedWriter out;\n+    private int state;\n+    private I18NResourceBundle i18n;\n+    private static final int IN_TAG = 1;\n+    private static final int IN_BODY = 2;\n+}\n","filename":"src\/share\/classes\/com\/sun\/javatest\/diff\/HTMLWriter.java","additions":559,"deletions":0,"binary":false,"changes":559,"status":"added"},{"patch":"@@ -0,0 +1,375 @@\n+\/*\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javatest.diff;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.text.DateFormat;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.Enumeration;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.TreeMap;\n+\n+import com.sun.javatest.regtest.tool.Option;\n+import com.sun.javatest.util.HelpTree;\n+import com.sun.javatest.util.I18NResourceBundle;\n+import com.sun.javatest.util.WrapWriter;\n+\n+\/**\n+ * Handles help options for main program\n+ *\/\n+public class Help {\n+\n+    \/** Creates a new instance of Help *\/\n+    public Help(List<Option> options) {\n+        this.options = options;\n+    }\n+\n+    void setVersionFlag(boolean yes) {\n+        versionFlag = yes;\n+    }\n+\n+    void setCommandLineHelpQuery(String query) {\n+        if (commandLineHelpQuery == null)\n+            commandLineHelpQuery = new ArrayList<>();\n+        if (query != null)\n+            commandLineHelpQuery.addAll(List.of(query.trim().split(\"\\\\s+\")));\n+    }\n+\n+    void show(PrintStream out) {\n+        PrintWriter w = new PrintWriter(out);\n+        show(w);\n+        w.flush();\n+    }\n+\n+    void show(PrintWriter out) {\n+\n+        if (versionFlag)\n+            showVersion(out);\n+\n+        if (commandLineHelpQuery != null)\n+            showCommandLineHelp(out);\n+    }\n+\n+    \/**\n+     * Show version information for JavaTest.\n+     * @param out the stream to which to write the information\n+     *\/\n+    void showVersion(PrintWriter out) {\n+        Properties manifest = getManifestForClass(getClass());\n+        if (manifest == null)\n+            manifest = new Properties();\n+\n+        String unknown = i18n.getString(\"help.version.unknown\");\n+\n+        \/\/ build properties, from manifest\n+        String prefix = \"jtreg\"; \/\/ base name of containing .jar file\n+        String product = \"jtdiff\"; \/\/ manifest.getProperty(productPrefix + \"-Name\", unknown);\n+        String version = manifest.getProperty(prefix + \"-Version\", unknown);\n+        String milestone = manifest.getProperty(prefix + \"-Milestone\", unknown);\n+        String build = manifest.getProperty(prefix + \"-Build\", unknown);\n+        String buildJavaVersion = manifest.getProperty(prefix + \"-BuildJavaVersion\", unknown);\n+        String buildDate = manifest.getProperty(prefix + \"-BuildDate\", unknown);\n+\n+        String thisJavaHome = System.getProperty(\"java.home\");\n+        String thisJavaVersion = System.getProperty(\"java.version\");\n+\n+        File classPathFile = getClassPathFileForClass(Main.class);\n+        String classPath = (classPathFile == null ? unknown : classPathFile.getPath());\n+\n+        DateFormat df = DateFormat.getDateInstance(DateFormat.LONG);\n+\n+        Object[] versionArgs = {\n+            product,\n+            version,\n+            milestone,\n+            build,\n+            classPath,\n+            thisJavaVersion,\n+            thisJavaHome,\n+            buildJavaVersion,\n+            buildDate\n+        };\n+\n+        \/*\n+         * Example format string:\n+         *\n+         * {0}, version {1} {2} {3}\n+         * Installed in {4}\n+         * Running on platform version {5} from {6}.\n+         * Built with {7} on {8}.\n+         *\n+         * Example output:\n+         *\n+         * jtdiff, version 3.2.2 dev b00\n+         * Installed in \/tl\/ws\/jct-tools-322dev\/dist\/jtreg\/lib\/jtreg.jar\n+         * Running on platform version 1.5.0_06 from \/opt\/java\/5.0\/jre.\n+         * Built with 1.5.0_06 on 09\/11\/2006 07:52 PM.\n+         *\/\n+\n+        out.println(i18n.getString(\"help.version.txt\", versionArgs));\n+        out.println(i18n.getString(\"help.copyright.txt\"));\n+    }\n+\n+    private File getDocDir() {\n+        File classPathFile = getClassPathFileForClass(Main.class);\n+        if (classPathFile == null)\n+            return null;\n+        File lib = classPathFile.getParentFile();\n+        File home = lib.getParentFile();\n+        File doc = new File(new File(home, \"doc\"), \"jtreg\");\n+        if (doc.exists())\n+            return doc;\n+        return null;\n+    }\n+\n+    private URL getClassPathEntryForClass(Class<?> c) {\n+        try {\n+            URL url = c.getResource(\"\/\" + c.getName().replace('.', '\/') + \".class\");\n+            if (url.getProtocol().equals(\"jar\")) {\n+                String path = url.getPath();\n+                int sep = path.lastIndexOf(\"!\");\n+                return new URL(path.substring(0, sep));\n+            }\n+        } catch (MalformedURLException ignore) {\n+        }\n+        return null;\n+    }\n+\n+    private File getClassPathFileForClass(Class<?> c) {\n+        URL url = getClassPathEntryForClass(c);\n+        if (url.getProtocol().equals(\"file\"))\n+            return new File(url.getPath());\n+        return null;\n+    }\n+\n+    private Properties getManifestForClass(Class<?> c) {\n+        URL classPathEntry = getClassPathEntryForClass(c);\n+        if (classPathEntry == null)\n+            return null;\n+\n+        try {\n+            Enumeration<URL> e = getClass().getClassLoader().getResources(\"META-INF\/MANIFEST.MF\");\n+            while (e.hasMoreElements()) {\n+                URL url = e.nextElement();\n+                if (url.getProtocol().equals(\"jar\")) {\n+                    String path = url.getPath();\n+                    int sep = path.lastIndexOf(\"!\");\n+                    URL u = new URL(path.substring(0, sep));\n+                    if (u.equals(classPathEntry)) {\n+                        Properties p = new Properties();\n+                        InputStream in = url.openStream();\n+                        p.load(in);\n+                        in.close();\n+                        return p;\n+                    }\n+                }\n+            }\n+        } catch (IOException ignore) {\n+        }\n+        return null;\n+    }\n+\n+\n+    \/**\n+     * Print out info about the options accepted by the command line decoder.\n+     * @param out A stream to which to write the information.\n+     *\/\n+    void showCommandLineHelp(PrintWriter out) {\n+        HelpTree commandHelpTree = new HelpTree();\n+\n+        Integer nodeIndent = Integer.getInteger(\"javatest.help.nodeIndent\");\n+        if (nodeIndent != null)\n+            commandHelpTree.setNodeIndent(nodeIndent);\n+\n+        Integer descIndent = Integer.getInteger(\"javatest.help.descIndent\");\n+        if (descIndent != null)\n+            commandHelpTree.setDescriptionIndent(descIndent);\n+\n+        \/\/ first, group the options by their group, and sort within group\n+        \/\/ by their first name\n+        Set<String> groups = new LinkedHashSet<>();\n+        for (Option o: options)\n+            groups.add(o.group);\n+        Map<String, SortedMap<String, Option>> map =\n+            new LinkedHashMap<>();\n+        for (String g: groups)\n+            map.put(g, new TreeMap<>(new CaseInsensitiveStringComparator()));\n+        for (Option o: options) {\n+            if (o.names.length > 0)\n+                map.get(o.group).put(o.names[0], o);\n+        }\n+\n+        \/\/ now build the help tree nodes and add then into the primary help node\n+        for (String g: groups) {\n+            SortedMap<String, Option> optionsForGroup = map.get(g);\n+\/\/                continue;\n+            List<HelpTree.Node> nodesForGroup = new ArrayList<>();\n+            for (Option o: optionsForGroup.values())\n+                nodesForGroup.add(createOptionHelpNode(o));\n+            HelpTree.Node groupNode = new HelpTree.Node(i18n, \"help.\" + g.toLowerCase(),\n+                    nodesForGroup.toArray(new HelpTree.Node[0]));\n+            commandHelpTree.addNode(groupNode);\n+        }\n+\n+        String progName = getProgramName();\n+\n+        try {\n+            WrapWriter ww = new WrapWriter(out);\n+\n+            if (commandLineHelpQuery == null || commandLineHelpQuery.isEmpty()) {\n+                \/\/ no keywords given\n+                ww.write(i18n.getString(\"help.cmd.proto\", progName));\n+                ww.write(\"\\n\\n\");\n+                ww.write(i18n.getString(\"help.cmd.introHead\"));\n+                ww.write('\\n');\n+                commandHelpTree.writeSummary(ww);\n+            } else if (commandLineHelpQuery.contains(\"all\")) {\n+                \/\/ -help all\n+                ww.write(i18n.getString(\"help.cmd.proto\", progName));\n+                ww.write(\"\\n\\n\");\n+                ww.write(i18n.getString(\"help.cmd.fullHead\"));\n+                ww.write('\\n');\n+                commandHelpTree.write(ww);\n+            } else {\n+                String[] query = commandLineHelpQuery.toArray(new String[0]);\n+                HelpTree.Selection s = commandHelpTree.find(query);\n+                if (s != null)\n+                    commandHelpTree.write(ww, s);\n+                else {\n+                    ww.write(i18n.getString(\"help.cmd.noEntriesFound\"));\n+                    ww.write(\"\\n\\n\");\n+                    ww.write(i18n.getString(\"help.cmd.summaryHead\"));\n+                    ww.write('\\n');\n+                    commandHelpTree.writeSummary(ww);\n+                }\n+            }\n+\n+            ww.write('\\n');\n+            ww.write(i18n.getString(\"help.cmd.tail\"));\n+            ww.write(\"\\n\\n\");\n+            ww.write(i18n.getString(\"help.cmd.ant\"));\n+            ww.write(\"\\n\\n\");\n+            ww.write(i18n.getString(\"help.copyright.txt\"));\n+            ww.write(\"\\n\\n\");\n+\n+            ww.flush();\n+        } catch (IOException e) {\n+            \/\/ should not happen, from PrintWriter\n+        }\n+\n+    }\n+\n+    private HelpTree.Node createOptionHelpNode(Option o) {\n+        String prefix = \"help.\" + o.group.toLowerCase() + \".\"\n+                + o.names[0].replaceAll(\"^-+\", \"\").replaceAll(\"[^A-Za-z0-9.]+\", \"_\");\n+        String arg = (o.argType == Option.ArgType.NONE ? null : i18n.getString(prefix + \".arg\"));\n+        StringBuilder sb = new StringBuilder();\n+        for (String n: o.names) {\n+            if (sb.length() > 0)\n+                sb.append(\"  |  \");\n+            sb.append(n);\n+            switch (o.argType) {\n+                case NONE:\n+                    break;\n+\n+                case OLD:       \/\/ old is deprecated, so just show preferred format\n+                case STD:\n+                case FILE:\n+                    sb.append(\":\").append(arg);\n+                    break;\n+\n+                case GNU:\n+                case SEP:\n+                case REST:\n+                    sb.append(\" \").append(arg);\n+                    break;\n+\n+                case WILDCARD:\n+                    sb.append(arg);\n+                    break;\n+\n+                case OPT:\n+                    sb.append(\"  |  -\").append(n).append(\":\").append(arg);\n+                    break;\n+\n+                default:\n+                    throw new AssertionError();\n+            }\n+        }\n+\n+        String name = sb.toString();\n+        String desc = i18n.getString(prefix + \".desc\");\n+        String[] values = o.getChoices();\n+        if (values == null || values.length == 0)\n+            return new HelpTree.Node(name, desc);\n+        else {\n+            HelpTree.Node[] children = new HelpTree.Node[values.length];\n+            for (int i = 0; i < children.length; i++)\n+                children[i] = new HelpTree.Node(values[i], i18n.getString(prefix + \".\" + values[i] + \".desc\"));\n+            return new HelpTree.Node(name, desc, children);\n+        }\n+    }\n+\n+    private static String getProgramName() {\n+        String p = System.getProperty(\"program\");\n+        if (p != null)\n+            return p;\n+\n+        return \"java \" + Main.class.getName();\n+    }\n+\n+    private static class CaseInsensitiveStringComparator implements Comparator<String> {\n+        public int compare(String s1, String s2) {\n+            if (s1 == null && s2 == null)\n+                return 0;\n+\n+            if (s1 == null || s2 == null)\n+                return (s1 == null ? -1 : +1);\n+\n+            return s1.compareToIgnoreCase(s2);\n+        }\n+\n+    }\n+\n+    private final List<Option> options;\n+    private boolean versionFlag;\n+    private List<String> commandLineHelpQuery;\n+\n+    private static final I18NResourceBundle i18n = I18NResourceBundle.getBundleForClass(Main.class);\n+}\n","filename":"src\/share\/classes\/com\/sun\/javatest\/diff\/Help.java","additions":375,"deletions":0,"binary":false,"changes":375,"status":"added"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * TODO: XMLReporter\n+ * TODO: filter options\n+ * TODO: comparator option\n+ * TODO: css option\n+ **\/\n+\n+package com.sun.javatest.diff;\n+\n+import java.io.File;\n+import java.io.PrintWriter;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import com.sun.javatest.regtest.BadArgs;\n+import com.sun.javatest.regtest.tool.Option;\n+import com.sun.javatest.regtest.tool.OptionDecoder;\n+import com.sun.javatest.util.I18NResourceBundle;\n+\n+import static com.sun.javatest.regtest.tool.Option.ArgType.*;\n+\n+\n+\/**\n+ * Main entry point for jtdiff.\n+ *\/\n+public class Main {\n+    \/\/---------- command line option decoding ----------------------------------\n+\n+    private static final String COMPARE = \"compare\";\n+    private static final String OUTPUT = \"output\";\n+    private static final String DOC = \"doc\";\n+    private static final String FILES = \"files\";\n+\n+    List<Option> options = List.of(\n+        new Option(NONE, COMPARE, \"r\", \"-r\", \"-reason\") {\n+            @Override\n+            public void process(String opt, String arg) {\n+                includeReason = true;\n+            }\n+        },\n+        new Option(NONE, COMPARE, \"s\", \"-s\", \"-super\") {\n+            @Override\n+            public void process(String opt, String arg) {\n+                superMode = true;\n+            }\n+        },\n+        new Option(OLD, OUTPUT, \"o\", \"-o\", \"-outFile\") {\n+            @Override\n+            public void process(String opt, String arg) {\n+                outFile = new File(arg);\n+            }\n+        },\n+        new Option(STD, OUTPUT, \"format\", \"-format\") {\n+            @Override\n+            public void process(String opt, String arg) {\n+                format = arg;\n+            }\n+        },\n+        new Option(OLD, OUTPUT, \"title\", \"-title\") {\n+            @Override\n+            public void process(String opt, String arg) {\n+                title = arg;\n+            }\n+        },\n+        new Option(REST, DOC, \"help\", \"-h\", \"-help\", \"--help\", \"-usage\") {\n+            @Override\n+            public void process(String opt, String arg) {\n+                if (help == null)\n+                    help = new Help(options);\n+                help.setCommandLineHelpQuery(arg);\n+            }\n+        },\n+        new Option(NONE, DOC, \"help\", \"-version\") {\n+            @Override\n+            public void process(String opt, String arg) {\n+                if (help == null)\n+                    help = new Help(options);\n+                help.setVersionFlag(true);\n+            }\n+        },\n+        new Option(FILE, FILES, null) {\n+            @Override\n+            public void process(String opt, String arg) {\n+                File f = new File(arg);\n+                fileArgs.add(f);\n+            }\n+        }\n+    );\n+\n+    \/\/---------- Command line invocation support -------------------------------\n+\n+    \/**\n+     * Standard entry point. Only returns if GUI mode is initiated; otherwise, it calls System.exit\n+     * with an appropriate exit code.\n+     * @param args An array of args, such as might be supplied on the command line.\n+     *\/\n+    public static void main(String[] args) {\n+        PrintWriter out = new PrintWriter(System.out, true);\n+        PrintWriter err = new PrintWriter(System.err, true);\n+        Main m = new Main(out, err);\n+        try {\n+            boolean ok;\n+            try {\n+                ok = m.run(args);\n+                if (!ok && (m.outFile != null)) {\n+                    \/\/ no need for an additional message if outFile == null\n+                    err.println(i18n.getString(\"main.diffsFound\"));\n+                }\n+            } finally {\n+                out.flush();\n+            }\n+\n+            if (!ok) {\n+                \/\/ take care not to exit if GUI might be around,\n+                \/\/ and take care to ensure JavaTestSecurityManager will\n+                \/\/ permit the exit\n+                exit(1);\n+            }\n+        } catch (Fault e) {\n+            err.println(i18n.getString(\"main.error\", e.getMessage()));\n+            exit(2);\n+        } catch (BadArgs e) {\n+            err.println(i18n.getString(\"main.badArgs\", e.getMessage()));\n+            new Help(m.options).showCommandLineHelp(out);\n+            exit(2);\n+        } catch (InterruptedException e) {\n+            err.println(i18n.getString(\"main.interrupted\"));\n+            exit(2);\n+        } catch (Exception e) {\n+            err.println(i18n.getString(\"main.unexpectedException\"));\n+            e.printStackTrace(System.err);\n+            exit(3);\n+        }\n+    } \/\/ main()\n+\n+    public Main() {\n+        this(new PrintWriter(System.out, true), new PrintWriter(System.err, true));\n+    }\n+\n+    public Main(PrintWriter out, PrintWriter err) {\n+        this.out = out;\n+        this.err = err;\n+    }\n+\n+    \/**\n+     * Decode command line args and perform the requested operations.\n+     * @param args An array of args, such as might be supplied on the command line.\n+     * @throws BadArgs if problems are found with any of the supplied args\n+     * @throws Fault if exception problems are found while trying to compare the results\n+     * @throws InterruptedException if the tool is interrupted while comparing the results\n+     *\/\n+    public final boolean run(String[] args) throws BadArgs, Fault, InterruptedException {\n+        new OptionDecoder(options).decodeArgs(args);\n+\n+        if (superMode) {\n+            if (fileArgs.size() != 1 || !fileArgs.get(0).isDirectory())\n+                throw new Fault(i18n, \"main.bad.super.dir\");\n+            if (format != null)\n+                throw new Fault(i18n, \"main.bad.super.format\");\n+            if (outFile == null)\n+                throw new Fault(i18n, \"main.no.output.dir\");\n+        }\n+\n+        return run();\n+    }\n+\n+    private boolean run() throws Fault, InterruptedException {\n+        if (fileArgs.isEmpty() && !superMode && help == null) {\n+            help = new Help(options);\n+            help.setCommandLineHelpQuery(null);\n+        }\n+\n+        if (help != null) {\n+            help.show(out);\n+            return true;\n+        }\n+\n+        Diff d;\n+        if (superMode)\n+            d = new SuperDiff(fileArgs.get(0));\n+        else\n+            d = new StandardDiff(fileArgs);\n+\n+        d.out = out;\n+        d.includeReason = includeReason;\n+        d.format = format;\n+        d.title = title;\n+\n+        return d.report(outFile);\n+    }\n+\n+    private static void exit(int exitCode) {\n+        System.exit(exitCode);\n+    }\n+\n+    private final PrintWriter out;\n+    private final PrintWriter err;\n+\n+    private boolean includeReason;\n+    private String format;\n+    private String title;\n+    private File outFile;\n+    private final List<File> fileArgs = new ArrayList<>();\n+    private boolean superMode;\n+    private Help help;\n+\n+    private static final I18NResourceBundle i18n = I18NResourceBundle.getBundleForClass(Main.class);\n+}\n","filename":"src\/share\/classes\/com\/sun\/javatest\/diff\/Main.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javatest.diff;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+\/**\n+ * A Map from a key to a possibly sparse array of values.\n+ *\/\n+public class MultiMap<K, V> implements Map<K, MultiMap.Entry<V>> {\n+    public static class Entry<V> {\n+\n+        private Entry(MultiMap<?, ?> t) {\n+            table = t;\n+        }\n+\n+        V get(int index) {\n+            return (index < list.size() ? list.get(index) : null);\n+        }\n+\n+        int getSize() {\n+            return table.getColumns();\n+        }\n+\n+        void put(int index, V value) {\n+            if (index >= table.getColumns())\n+                throw new IndexOutOfBoundsException();\n+\n+            if (list == null)\n+                list = new ArrayList<>(index);\n+\n+            if (index < list.size())\n+                list.set(index, value);\n+            else {\n+                while (index > list.size())\n+                    list.add(null);\n+                list.add(value);\n+            }\n+        }\n+\n+        boolean allEqual(Comparator<V> c) {\n+            if (list.size() == 0)\n+                return true;\n+            int size = table.getColumns();\n+            V v0 = list.get(0);\n+            for (int i = 1; i < size; i++) {\n+                V v = get(i);\n+                if (c.compare(v, v0) != 0)\n+                    return false;\n+            }\n+            return true;\n+        }\n+\n+        private List<V> list;\n+        private MultiMap<?, ?> table;\n+    }\n+\n+    \/** Creates a new instance of MultiMap *\/\n+    public MultiMap() {\n+        names = new ArrayList<>();\n+        map = new TreeMap<>();\n+    }\n+\n+    int getColumns() {\n+        return names.size();\n+    }\n+\n+    String getColumnName(int index) {\n+        return names.get(index);\n+    }\n+\n+    int addColumn(String name) {\n+        names.add(name);\n+        return names.size() - 1;\n+    }\n+\n+    void addColumn(String name, Map<K, V> map) {\n+        addColumn(name, map.entrySet());\n+    }\n+\n+    void addColumn(String name, Iterable<Map.Entry<K, V>> iter) {\n+        int index = addColumn(name);\n+        for (Map.Entry<K, V> e: iter)\n+            addRow(index, e.getKey(), e.getValue());\n+    }\n+\n+    void addRow(int index, K k, V v) {\n+        Entry<V> de = get(k);\n+        if (de == null)\n+            put(k, de = new Entry<>(this));\n+        de.put(index, v);\n+    }\n+\n+    public int size() {\n+        return map.size();\n+    }\n+\n+    public Entry<V> get(Object path) {\n+        return map.get(path);\n+    }\n+\n+    public boolean isEmpty() {\n+        return map.isEmpty();\n+    }\n+\n+    public boolean containsKey(Object key) {\n+        return map.containsKey(key);\n+    }\n+\n+    public boolean containsValue(Object value) {\n+        return map.containsValue(value);\n+    }\n+\n+    public Entry<V> put(K key, Entry<V> value) {\n+        return map.put(key, value);\n+    }\n+\n+    public Entry<V> remove(Object key) {\n+        return map.remove(key);\n+    }\n+\n+    public void putAll(Map<? extends K, ? extends Entry<V>> t) {\n+        map.putAll(t);\n+    }\n+\n+    public void clear() {\n+        map.clear();\n+    }\n+\n+    public Set<Map.Entry<K, Entry<V>>> entrySet() {\n+        return map.entrySet();\n+    }\n+\n+    public Set<K> keySet() {\n+        return map.keySet();\n+    }\n+\n+    public Collection<Entry<V>> values() {\n+        return map.values();\n+    }\n+\n+    private List<String> names;\n+    private TreeMap<K, Entry<V>> map;\n+}\n","filename":"src\/share\/classes\/com\/sun\/javatest\/diff\/MultiMap.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2007, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javatest.diff;\n+\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import com.sun.javatest.Status;\n+import com.sun.javatest.TestDescription;\n+import com.sun.javatest.TestResult;\n+import com.sun.javatest.util.I18NResourceBundle;\n+\n+\/**\n+ * Read a set of test results from summary.txt, possibly located in a\n+ * report directory.\n+ *\/\n+public class ReportReader implements DiffReader {\n+    private static final String SUMMARY_TXT = \"summary.txt\";\n+\n+    public static boolean accepts(File f) {\n+        if (!f.exists())\n+            return false;\n+\n+        if (f.isFile() && f.getName().equals(SUMMARY_TXT))\n+            return true;\n+\n+        if (f.isDirectory() && new File(f, SUMMARY_TXT).exists())\n+            return true;\n+\n+        if (f.isDirectory() && new File(new File(f, \"text\"), SUMMARY_TXT).exists())\n+            return true;\n+\n+        return false;\n+    }\n+\n+    \/** Creates a new instance of SummaryReader *\/\n+    public ReportReader(File file) {\n+        this.file = file;\n+    }\n+\n+    public File getFile() {\n+        return file;\n+    }\n+\n+    public String getFileType() {\n+        if (file != null && file.isDirectory())\n+            return i18n.getString(\"report.reportDir\");\n+        else\n+            return i18n.getString(\"report.reportFile\");\n+    }\n+\n+    public File getWorkDirectory() {\n+        return null;\n+    }\n+\n+    public Iterator<TestResult> iterator() {\n+        return readSummary().iterator();\n+    }\n+\n+    private List<TestResult> readSummary() {\n+        List<TestResult> list = new ArrayList<>();\n+        File root = getRoot();\n+        File f;\n+        if (file.isFile() && file.getName().equals(SUMMARY_TXT))\n+            f = file;\n+        else if (file.isDirectory() && new File(file, SUMMARY_TXT).exists())\n+            f = new File(file, SUMMARY_TXT);\n+        else if (file.isDirectory() && new File(new File(file, \"text\"), SUMMARY_TXT).exists())\n+            f = new File(new File(file, \"text\"), SUMMARY_TXT);\n+        else\n+            throw new IllegalStateException();\n+\n+        try {\n+            BufferedReader in = new BufferedReader(new FileReader(f));\n+            String line;\n+            while ((line = in.readLine()) != null) {\n+                int sp = line.indexOf(' ');\n+                String t = line.substring(0, sp);\n+                Status s = Status.parse(line.substring(sp).trim());\n+                TestDescription td = new TestDescription(root, new File(t), Collections.emptyMap());\n+                TestResult tr = new TestResult(td, s);\n+                list.add(tr);\n+            }\n+        } catch (IOException e) {\n+        }\n+        return list;\n+    }\n+\n+    private File getRoot() {\n+        return UNKNOWN;\n+    }\n+\n+    private static File UNKNOWN = new File(\"unknown\");\n+\n+    private File file;\n+\n+    private static I18NResourceBundle i18n = I18NResourceBundle.getBundleForClass(WorkDirectoryReader.class);\n+}\n","filename":"src\/share\/classes\/com\/sun\/javatest\/diff\/ReportReader.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javatest.diff;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+import com.sun.javatest.TestResult;\n+\n+\n+\/**\n+ * Interface for generating reports.\n+ *\/\n+public abstract class Reporter {\n+\n+    public String getTitle() {\n+        return title;\n+    }\n+\n+    public void setTitle(String title) {\n+        this.title = title;\n+    }\n+\n+    public Comparator<TestResult> getComparator() {\n+        return comparator;\n+    }\n+\n+    public void setComparator(Comparator<TestResult> c) {\n+        this.comparator = c;\n+    }\n+\n+    public void setReaders(List<DiffReader> readers) {\n+        this.readers = readers;\n+    }\n+\n+    public void setTestCounts(List<int[]> testCounts) {\n+        this.testCounts = testCounts;\n+    }\n+\n+    public int getDiffCount() {\n+        return diffs;\n+    }\n+\n+    abstract void write(MultiMap<String, TestResult> table) throws IOException;\n+\n+    protected List<DiffReader> readers;\n+    protected List<int[]> testCounts = new ArrayList<>();\n+    protected Comparator<TestResult> comparator;\n+    protected String title;\n+    protected int diffs;\n+}\n","filename":"src\/share\/classes\/com\/sun\/javatest\/diff\/Reporter.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ TODO: colorize output?\n+\n+package com.sun.javatest.diff;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.util.Map;\n+\n+import com.sun.javatest.Status;\n+import com.sun.javatest.TestResult;\n+import com.sun.javatest.util.I18NResourceBundle;\n+\n+\/**\n+ * Write simple reports to a text file.\n+ *\/\n+public class SimpleReporter extends Reporter {\n+\n+    \/**\n+     * Creates a new instance of SimpleReporter\n+     *\/\n+    public SimpleReporter(PrintWriter out) {\n+        if (out == null)\n+            throw new NullPointerException();\n+\n+        this.out = out;\n+\n+        statusStrings = new String[4];\n+        statusStrings[Status.PASSED] = i18n.getString(\"simple.pass\");\n+        statusStrings[Status.FAILED] = i18n.getString(\"simple.fail\");\n+        statusStrings[Status.ERROR] = i18n.getString(\"simple.error\");\n+        statusStrings[Status.NOT_RUN] = i18n.getString(\"simple.notRun\");\n+        for (String ss: statusStrings)\n+            maxStatusStringLength = Math.max(maxStatusStringLength, ss.length());\n+    }\n+\n+    public void write(MultiMap<String, TestResult> table) throws IOException {\n+        this.table = table;\n+        size = table.getColumns();\n+\n+        if (title != null) {\n+            println(title);\n+            println();\n+        }\n+\n+        writeHead();\n+        writeBody();\n+        writeSummary();\n+    }\n+\n+    private void writeHead() throws IOException {\n+        for (int i = 0; i < size; i++) {\n+            int[] c = testCounts.get(i);\n+            int passed = c[Status.PASSED];\n+            int failed = c[Status.FAILED];\n+            int error = c[Status.ERROR];\n+            int notRun = c[Status.NOT_RUN];\n+            writeI18N(\"simple.set\", i, table.getColumnName(i));\n+            print(\"  \");\n+            writeI18N(\"simple.counts\",\n+                    passed,\n+                    (passed > 0) && (failed + error + notRun > 0) ? 1 : 0,\n+                    failed,\n+                    (failed > 0) && (error + notRun > 0) ? 1 : 0,\n+                    error,\n+                    (error > 0) && (notRun > 0) ? 1 : 0,\n+                    notRun);\n+            println();\n+        }\n+    }\n+\n+    private void writeBody() throws IOException {\n+        diffs = 0;\n+        for (Map.Entry<String, MultiMap.Entry<TestResult>> e: table.entrySet()) {\n+            String testName = e.getKey();\n+            MultiMap.Entry<TestResult> result = e.getValue();\n+            if (result.allEqual(comparator))\n+                continue;\n+            if (diffs == 0) {\n+                println();\n+                for (int i = 0; i < result.getSize(); i++) {\n+                    print(String.valueOf(i), maxStatusStringLength + 2);\n+                }\n+                writeI18N(\"simple.test\");\n+                println();\n+            }\n+            for (int i = 0; i < result.getSize(); i++) {\n+                TestResult tr = result.get(i);\n+                Status s = (tr == null ? null : tr.getStatus());\n+                print(getStatusString(s), maxStatusStringLength + 2);\n+            }\n+            println(testName);\n+            diffs++;\n+        }\n+    }\n+\n+    private void writeSummary() throws IOException {\n+        println();\n+        if (diffs == 0)\n+            writeI18N(\"simple.diffs.none\");\n+        else\n+            writeI18N(\"simple.diffs.count\", diffs);\n+        println();\n+    }\n+\n+    private void writeI18N(String key, Object... args) throws IOException {\n+        print(i18n.getString(key, args));\n+    }\n+\n+    private void print(Object o) throws IOException {\n+        out.print(o.toString());\n+    }\n+\n+    private void print(String s, int width) throws IOException {\n+        out.print(s);\n+        for (int i = s.length(); i < width; i++)\n+            out.print(' ');\n+    }\n+\n+    private void println() throws IOException {\n+        out.println();\n+    }\n+\n+    private void println(Object o) throws IOException {\n+        out.println(o.toString());\n+    }\n+\n+    private String getStatusString(Status s) {\n+        return statusStrings[s == null ? Status.NOT_RUN : s.getType()];\n+    }\n+\n+    private MultiMap<String, TestResult> table;\n+    private int size;\n+    private PrintWriter out;\n+\n+    private String[] statusStrings;\n+    private int maxStatusStringLength;\n+\n+    private static I18NResourceBundle i18n = I18NResourceBundle.getBundleForClass(SimpleReporter.class);\n+}\n","filename":"src\/share\/classes\/com\/sun\/javatest\/diff\/SimpleReporter.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javatest.diff;\n+\n+import java.io.File;\n+import java.util.List;\n+\n+public class StandardDiff extends Diff {\n+    StandardDiff(List<File> files) {\n+        this.files = files;\n+    }\n+\n+    @Override\n+    public boolean report(File outFile) throws Fault, InterruptedException {\n+        return diff(files, outFile);\n+    }\n+\n+    List<File> files;\n+}\n","filename":"src\/share\/classes\/com\/sun\/javatest\/diff\/StandardDiff.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javatest.diff;\n+\n+import java.util.Comparator;\n+\n+import com.sun.javatest.Status;\n+import com.sun.javatest.TestResult;\n+\n+\/**\n+ * A comparator for the status contained in a test result.\n+ *\/\n+public class StatusComparator implements Comparator<TestResult> {\n+\n+    \/** Creates a new instance of StatusComparator *\/\n+    public StatusComparator() {\n+    }\n+\n+    \/** Creates a new instance of StatusComparator *\/\n+    public StatusComparator(boolean includeReason) {\n+        this.includeReason = includeReason;\n+    }\n+\n+    public int compare(TestResult o1, TestResult o2) {\n+        int t1 = getType(o1);\n+        int t2 = getType(o2);\n+\n+        if (t1 < t2)\n+            return -1;\n+\n+        if (t1 > t2)\n+            return +1;\n+\n+        if (!includeReason)\n+            return 0;\n+\n+        String r1 = getReason(o1);\n+        String r2 = getReason(o2);\n+        return r1.compareTo(r2);\n+    }\n+\n+    private static int getType(TestResult tr) {\n+        if (tr == null)\n+            return Status.NOT_RUN;\n+        Status s = tr.getStatus();\n+        return (s == null ? Status.NOT_RUN : s.getType());\n+    }\n+\n+    private static String getReason(TestResult tr) {\n+        if (tr == null)\n+            return \"\";\n+        Status s = tr.getStatus();\n+        return (s == null ? \"\" : s.getReason());\n+    }\n+\n+    private boolean includeReason;\n+}\n","filename":"src\/share\/classes\/com\/sun\/javatest\/diff\/StatusComparator.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,344 @@\n+\/*\n+ * Copyright (c) 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javatest.diff;\n+\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.Writer;\n+import java.text.DateFormat;\n+import java.text.SimpleDateFormat;\n+import java.util.ArrayList;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import com.sun.javatest.util.I18NResourceBundle;\n+\n+import static com.sun.javatest.util.HTMLWriter.*;\n+\n+class SuperDiff extends Diff {\n+    SuperDiff(File dir) {\n+        table = new SuperTable(dir, resultPath);\n+    }\n+\n+    @Override\n+    public boolean report(File outDir) throws Fault, InterruptedException {\n+        baseTitle = title;\n+        boolean ok = true;\n+        for (YearDay yearDay: table.getRecentKeys(historySize))\n+            ok &= diffPlatforms(yearDay, outDir);\n+        for (String platform : table.platforms) {\n+            ok &= diffHistory(platform, outDir);\n+        }\n+        writeIndex(outDir, baseTitle);\n+        return ok;\n+    }\n+\n+    protected boolean diff(List<File> files, File outFile, String title) throws Fault, InterruptedException {\n+        this.title = title;\n+        reporter = null;\n+        return diff(files, outFile);\n+    }\n+\n+    @Override\n+    protected void initReporter() throws Fault {\n+        try {\n+             reporter = new SuperReporter(out);\n+        } catch (IOException e) {\n+            throw new Fault(i18n, \"main.cantOpenReport\", e);\n+        }\n+    }\n+\n+    private boolean diffPlatforms(YearDay yearDay, File outDir) throws Fault, InterruptedException {\n+        Map<String, File> pMap = table.get(yearDay);\n+        List<File> pDirs = new ArrayList<>();\n+        for (String platform : table.platforms) {\n+            File dir = pMap.get(platform);\n+            if (dir != null) {\n+                pDirs.add(dir);\n+            }\n+        }\n+        File file = new File(outDir, yearDay.year + \"_\" + yearDay.dayOfYear + \".html\");\n+        platformIndex.put(yearDay.toDateString(monthDayFormat), file);\n+        String prefix = baseTitle == null ? \"\" : baseTitle + \": \";\n+        return diff(pDirs, file, prefix + yearDay.toDateString(mediumDateFormat)); \/\/ I18N a better title?\n+    }\n+\n+    private boolean diffHistory(String platform, File outDir) throws Fault, InterruptedException {\n+        List<File> pDirs = new ArrayList<>();\n+        for (YearDay yearDay: table.getRecentKeys(historySize, platform)) {\n+            pDirs.add(table.get(yearDay).get(platform));\n+        }\n+        File file = new File(outDir, platform + \".html\");\n+        historyIndex.put(platform, file);\n+        String prefix = baseTitle == null ? \"\" : baseTitle + \": \";\n+        return diff(pDirs, file, prefix + platform); \/\/ I18N a better title?\n+    }\n+\n+    private void writeIndex(File outDir, String title) throws Fault {\n+        PrintWriter out;\n+        try {\n+            out = new PrintWriter(new BufferedWriter(new FileWriter(new File(outDir, \"index.html\"))));\n+        } catch (IOException e) {\n+            throw new Fault(i18n, \"main.cantOpenReport\", e);\n+        }\n+\n+        try {\n+            SuperReporter r = new SuperReporter(out);\n+            r.writeMainIndex(title);\n+        } catch (IOException e) {\n+            throw new Fault(i18n, \"main.ioError\", e);\n+        } finally {\n+            out.close();\n+        }\n+    }\n+\n+    protected String resultPath = System.getProperty(\"jtdiff.super.testResults\", \"JTreport\/text\/summary.txt\");\n+    protected int historySize = Integer.getInteger(\"jtdiff.super.history\", 21);\n+\n+    private SuperTable table;\n+    private String baseTitle;\n+    private Map<String, File> historyIndex = new LinkedHashMap<>();\n+    private Map<String, File> platformIndex = new LinkedHashMap<>();\n+\n+    private static DateFormat monthDayFormat = new SimpleDateFormat(\"MMM d\");\n+    private static DateFormat mediumDateFormat = DateFormat.getDateInstance(DateFormat.MEDIUM);\n+    private static I18NResourceBundle i18n = I18NResourceBundle.getBundleForClass(Main.class);\n+\n+    static class Info {\n+        Info(String platform, Date date) {\n+            this.platform = platform;\n+            this.date = date;\n+        }\n+\n+        final String platform;\n+        final Date date;\n+    }\n+\n+    class SuperReporter extends HTMLReporter {\n+        SuperReporter(Writer out) throws IOException {\n+            super(out);\n+        }\n+\n+        protected void writeIndexTableInfoHeadings() throws IOException {\n+            out.startTag(TH);\n+            out.writeI18N(\"super.th.platform\");\n+            out.endTag(TH);\n+            out.startTag(TH);\n+            out.writeI18N(\"super.th.date\");\n+            out.endTag(TH);\n+        }\n+\n+        protected void writeIndexTableInfoValues(String path) throws IOException {\n+            Info info = table.getInfo(path);\n+            out.startTag(TD);\n+            if (info != null)\n+                out.write(info.platform);\n+            out.endTag(TD);\n+            out.startTag(TD);\n+            if (info != null)\n+                out.write(monthDayFormat.format(info.date));\n+            out.endTag(TD);\n+        }\n+\n+        void writeMainIndex(String title) throws IOException {\n+            startReport(title);\n+\n+            if (baseTitle != null) {\n+                out.startTag(H1);\n+                out.write(baseTitle);\n+                out.endTag(H1);\n+            }\n+\n+            writeMainIndexList(i18n.getString(\"super.platforms\"), platformIndex);\n+            writeMainIndexList(i18n.getString(\"super.history\"), historyIndex);\n+\n+            endReport();\n+        }\n+\n+        void writeMainIndexList(String head, Map<String, File> map) throws IOException {\n+            out.startTag(H2);\n+            out.write(head);\n+            out.endTag(H2);\n+            out.startTag(P);\n+            String comma = \"\";\n+            for (Map.Entry<String, File> e: map.entrySet()) {\n+                out.write(comma);\n+                out.startTag(A);\n+                out.writeAttr(HREF, e.getValue().getName());\n+                String nbsp = \"\";\n+                for (String s: e.getKey().split(\" \")) {\n+                    out.writeEntity(nbsp);\n+                    out.write(s);\n+                    nbsp = \"&nbsp;\";\n+                }\n+                out.endTag(A);\n+                comma = \", \";\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"serial\")\n+    static class SuperTable extends TreeMap<YearDay, Map<String, File>> {\n+\n+        SuperTable(File inDir, String resultPath) {\n+            super();\n+            for (File pDir : inDir.listFiles()) {\n+                if (!pDir.isDirectory()) {\n+                    continue;\n+                }\n+                for (File yDir : pDir.listFiles()) {\n+                    if (!yDir.isDirectory()) {\n+                        continue;\n+                    }\n+                    for (File dDir : yDir.listFiles()) {\n+                        if (!dDir.isDirectory()) {\n+                            continue;\n+                        }\n+                        File resultDir = new File(dDir, resultPath);\n+                        if (resultDir.exists()) {\n+                            add(pDir.getName(), yDir.getName(), dDir.getName(), resultDir);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        private void add(String platform, String year, String day, File dir) {\n+            platforms.add(platform);\n+            YearDay yd = new YearDay(year, day);\n+            Map<String, File> pMap = get(yd);\n+            if (pMap == null) {\n+                pMap = new HashMap<>();\n+                put(yd, pMap);\n+            }\n+            pMap.put(platform, dir);\n+\n+            Date date;\n+            try {\n+                Calendar c = Calendar.getInstance();\n+                c.clear();\n+                c.set(Calendar.YEAR, Integer.parseInt(year));\n+                c.set(Calendar.DAY_OF_YEAR, Integer.parseInt(day));\n+                date = c.getTime();\n+            } catch (NumberFormatException e) {\n+                date = null;\n+            }\n+            infoTable.put(dir.getPath(), new Info(platform, date));\n+        }\n+\n+        List<YearDay> getRecentKeys(int n) {\n+            return getRecentKeys(n, null);\n+        }\n+\n+        List<YearDay> getRecentKeys(int n, String platform) {\n+            LinkedList<YearDay> results = new LinkedList<>();\n+            List<YearDay> keys = new ArrayList<>(keySet());\n+            for (ListIterator<YearDay> iter = keys.listIterator(keys.size());\n+                    iter.hasPrevious() && results.size() < n; ) {\n+                YearDay key = iter.previous();\n+                if (platform == null || get(key).get(platform) != null)\n+                    results.addFirst(key);\n+            }\n+            return results;\n+        }\n+\n+        Info getInfo(String path) {\n+            return infoTable.get(path);\n+        }\n+\n+        final Set<String> platforms = new TreeSet<>();\n+        final Map<String, Info> infoTable = new HashMap<>();\n+    }\n+\n+    static class YearDay implements Comparable<YearDay> {\n+        YearDay(String year, String dayOfYear) {\n+            year.getClass();\n+            dayOfYear.getClass();\n+            this.year = year;\n+            this.dayOfYear = dayOfYear;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (!(o instanceof YearDay))\n+                return false;\n+            YearDay ydo = (YearDay) o;\n+            return year.equals(ydo.year) && dayOfYear.equals(ydo.dayOfYear);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return year.hashCode() * 37 + dayOfYear.hashCode();\n+        }\n+\n+        \/\/@Override\n+        public int compareTo(YearDay o) {\n+            int c = compare(year, o.year);\n+            return (c == 0 ? compare(dayOfYear, o.dayOfYear) : c);\n+        }\n+\n+        public String toString() {\n+            return year + \":\" + dayOfYear;\n+        }\n+\n+        public Date asDate() {\n+            try {\n+                Calendar c = Calendar.getInstance();\n+                c.clear();\n+                c.set(Calendar.YEAR, Integer.parseInt(year));\n+                c.set(Calendar.DAY_OF_YEAR, Integer.parseInt(dayOfYear));\n+                return c.getTime();\n+            } catch (NumberFormatException e) {\n+                return null;\n+            }\n+        }\n+\n+        public String toDateString(DateFormat f) {\n+            Date d = asDate();\n+            return (d == null ? toString() : f.format(d));\n+        }\n+\n+        private int compare(String left, String right) {\n+            return left.compareTo(right);\n+        }\n+\n+        final String year;\n+        final String dayOfYear;\n+    }\n+\n+}\n","filename":"src\/share\/classes\/com\/sun\/javatest\/diff\/SuperDiff.java","additions":344,"deletions":0,"binary":false,"changes":344,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.javatest.diff;\n+\n+import java.io.BufferedInputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Iterator;\n+import java.util.Properties;\n+\n+import com.sun.javatest.TestResult;\n+import com.sun.javatest.TestResultTable;\n+import com.sun.javatest.TestSuite;\n+import com.sun.javatest.WorkDirectory;\n+import com.sun.javatest.regtest.config.RegressionTestSuite;\n+import com.sun.javatest.util.I18NResourceBundle;\n+\n+\/**\n+ * Read test results from a work directory.\n+ *\/\n+public class WorkDirectoryReader implements DiffReader {\n+    public static boolean accepts(File f) {\n+        return WorkDirectory.isWorkDirectory(f);\n+    }\n+\n+    \/** Creates a new instance of WorkDirectoryReader *\/\n+    public WorkDirectoryReader(File file)\n+            throws FileNotFoundException, WorkDirectory.Fault, TestSuite.Fault {\n+        this.file = file;\n+\n+        \/\/ Because regtest testsuites don't contain testsuite.jtt\n+        \/\/ files, we can't use the standard WorkDirectory.open call.\n+        File tsp = getTestSuitePath(file);\n+        if (tsp != null && new File(tsp, \"TEST.ROOT\").exists()) {\n+            TestSuite ts = new RegressionTestSuite(tsp, WorkDirectoryReader.this::error);\n+            wd = WorkDirectory.open(file, ts);\n+        } else\n+            wd = WorkDirectory.open(file);\n+    }\n+\n+    public File getFile() {\n+        return file;\n+    }\n+\n+    public String getFileType() {\n+        return i18n.getString(\"wd.name\");\n+    }\n+\n+    public File getWorkDirectory() {\n+        return wd.getRoot();\n+    }\n+\n+    public Iterator<TestResult> iterator() {\n+        TestResultTable trt = wd.getTestResultTable();\n+        trt.waitUntilReady();\n+        return trt.getIterator();\n+    }\n+\n+    private static File getTestSuitePath(File workDir) {\n+        File f = new File(new File(workDir, \"jtData\"), \"testsuite\");\n+        if (!f.exists())\n+            return null;\n+\n+        InputStream in = null;\n+        try {\n+            in = new BufferedInputStream(new FileInputStream(f));\n+            Properties p = new Properties();\n+            p.load(in);\n+            in.close();\n+            String ts = p.getProperty(\"root\");\n+            return (ts == null ? null : new File(ts));\n+        } catch (IOException e) {\n+            try {\n+                if (in != null)\n+                    in.close();\n+            } catch (IOException ignore) {\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private void error(String msg) {\n+        System.err.println(\"Error: \" + msg);\n+    }\n+\n+    private final File file;\n+    private final WorkDirectory wd;\n+\n+    private static final I18NResourceBundle i18n = I18NResourceBundle.getBundleForClass(WorkDirectoryReader.class);\n+}\n","filename":"src\/share\/classes\/com\/sun\/javatest\/diff\/WorkDirectoryReader.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+#\n+# Copyright (c) 2007, 2013, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+diff.cantOpenFile=Cannot open file {0}: {1}\n+diff.cantOpenReport=Cannot open report: {0}\n+diff.ioError=Error: {0}\n+\n+help.cmd.ant=jtdiff can also be run with Ant.\n+help.cmd.fullHead=\n+help.cmd.introHead=For brief details about a topic, use \"-help <term> ...\". \\\n+    The argument <term> is a command option or other word related to the topic. \\\n+    Use \"-help all\" to show all of the help entries.\\n\\nInformation is \\\n+    available for the following topics.\\n\n+help.cmd.noEntriesFound=No entries were found that matched your query.\n+help.cmd.proto=Usage:\\n\\t{0} options... [directory|file]...\n+help.cmd.summaryHead=Information is available for the following topics:\n+help.cmd.tail=\n+help.copyright.txt=Copyright (c) 2008, 2013 Oracle and\/or its affiliates. \\\n+    All rights reserved.\\nUse is subject to license terms.\n+\n+help.compare.name=Compare Options\n+help.compare.desc=\n+help.compare.r.desc=Include the reason string in the comparison, as well as \\\n+    the type (i.e. Passed, Failed, etc.)\n+help.compare.s.desc=Perform a \"super-diff\" looking for result sets within \\\n+    a directory hierarchy. The hierarchy must be arranged as \\\n+    follows: PATH\/PLATFORM\/YEAR\/DAY_OF_YEAR\/TEST_RESULTS, where PATH is \\\n+    given by the single directory argument, PLATFORM is the name of the \\\n+    platform on which the tests were run, YEAR and DAY_OF_YEAR are numbers \\\n+    identifying when the tests were run, and TESTSUITE_RESULTS is a fixed string \\\n+    identifying when to find the result set in the hierarchy. The default \\\n+    is \"JTreport\/text\/summary.txt\", but it can be set to a different value by \\\n+    setting the system property \"jtdiff.super.testResults\". It may identify any \\\n+    source of results acceptable to a standard invocation of jtdiff. \\\n+    Set system property jtdiff.html.compact=true for a more output format, with \\\n+    symbols replacing the words \"pass\" (check mark), \"fail\" (cross), \"error\" \\\n+    (cross in a circle), and \"not run\" (horizontal bar).\n+\n+help.doc.name=Help Options\n+help.doc.desc=Options for additional help and information\n+help.doc.h.arg=[words...]\n+help.doc.h.desc=Command line help. Give words to see help info containing those \\\n+    or use \"-help all\" to see all available help.\n+help.doc.version.desc=Give information about the version of jtdiff in use.\n+\n+help.files.name=Input Files\n+help.files.desc=Input files can be any of work directories, report directories, \\\n+    or the summary.txt files in a report directory.\n+\n+help.output.name=Output Options\n+help.output.desc=Options to customize the output\n+help.output.format.arg=html|text\n+help.output.format.desc=Output format. If not specified, it is inferred from the \\\n+    extension of the output file.\n+help.output.o.arg=<file>\n+help.output.o.desc=File to which to write the results\n+help.output.title.arg=<string>\n+help.output.title.desc=Title to use for the results\n+\n+help.version.txt={0}, version {1} {2} {3}\\nInstalled in {4}\\nRunning on platform version {5} from {6}.\\nBuilt with {7} on {8}.\n+help.version.unknown=(unknown)\n+\n+html.diffs.count={0} differences\n+html.diffs.none=No differences\n+html.generatedAt=Generated at {0}\n+html.error=error\n+html.fail=fail\n+html.notRun=not run\n+html.pass=pass\n+html.error.compact=&otimes;\n+html.fail.compact=&times;\n+html.notRun.compact=&mdash;\n+html.pass.compact=&radic;\n+\n+html.head.differences=Differences\n+html.head.notitle=jtdiff results\n+html.head.sets=Test Result Sets\n+html.head.title=jtdiff results: {0}\n+\n+html.th.location=Location\n+html.th.set=Set\n+html.th.setN=Set {0}\n+html.th.test=Test\n+html.th.error=Errors\n+html.th.fail=Failed\n+html.th.notRun=Not Run\n+html.th.pass=Passed\n+html.th.total=Total\n+html.th.type=Type\n+\n+main.badArgs=Error: {0}\n+main.bad.super.dir=Bad directory argument for \"super\" mode\n+main.bad.super.format=Cannot specify format in \"super\" mode\n+main.cantFindFile=Cannot find file: {0}\n+main.cantOpenFile=Cannot open file {0}: {1}\n+main.cantOpenReport=Cannot open report: {0}\n+main.diffsFound=Differences found.\n+main.error=Error: {0}\n+main.interrupted=Error: Interrupted!\n+main.ioError=Error: {0}\n+main.no.output.dir=No output directory given; use -o dir\n+main.unexpectedException=Error: Unexpected exception occured!\n+main.unrecognizedFile=File not recognized: {0}\n+\n+report.reportDir=Report Drectory\n+report.reportFile=Report File\n+\n+simple.diffs.count={0} differences\n+simple.diffs.none=No differences\n+simple.set={0}: {1}\n+simple.test=Test\n+simple.error=error\n+simple.fail=fail\n+simple.notRun=---\n+simple.pass=pass\n+\n+simple.counts=\\\n+    {0,choice,0#|0<pass: {0,number}}{1,choice,0#|1#; }\\\n+    {2,choice,0#|0<fail: {2,number}}{3,choice,0#|1#; }\\\n+    {4,choice,0#|0<error: {4,number}}{5,choice,0#|1#; }\\\n+    {6,choice,0#|0<not run: {6,number}}\n+\n+wd.name=Work Directory\n+\n+super.history=Comparison of recent results by platform\n+super.platforms=Comparison across platforms by date\n+super.th.date=Date\n+super.th.platform=Platform\n","filename":"src\/share\/classes\/com\/sun\/javatest\/diff\/i18n.properties","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+#\n+# Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#----------------------------------------------------------------------\n+\n+$(BUILDTESTDIR)\/T6783039.ok: \\\n+\t$(JTREG_IMAGEDIR)\/lib\/javatest.jar \\\n+\t$(JTREG_IMAGEDIR)\/lib\/jtreg.jar\n+\t$(RM) $(BUILDTESTDIR)\/6783039\/\n+\tfor p in p1 p2 ; do for y in 2007 2008 ; do for d in 1 2 3 ; do \\\n+\t    mkdir -p $(BUILDTESTDIR)\/6783039\/$$p\/$$y\/$$d\/JTreport\/text\/ ; touch $(BUILDTESTDIR)\/6783039\/$$p\/$$y\/$$d\/JTreport\/text\/summary.txt ; \\\n+\tdone ; done ; done\n+\t$(JDKJAVA) -cp $(JTREG_IMAGEDIR)\/lib\/jtreg.jar com.sun.javatest.diff.Main \\\n+\t\t$(BUILDTESTDIR)\/6783039\/*\/*\/*\/JTreport\/text\/summary.txt > $(BUILDTESTDIR)\/6783039\/stdout\n+\t$(JDKJAVA) -cp $(JTREG_IMAGEDIR)\/lib\/jtreg.jar com.sun.javatest.diff.Main \\\n+\t\t-o $(BUILDTESTDIR)\/6783039\/out.txt $(BUILDTESTDIR)\/6783039\/*\/*\/*\/JTreport\/text\/summary.txt\n+\tdiff $(BUILDTESTDIR)\/6783039\/stdout $(BUILDTESTDIR)\/6783039\/out.txt\n+\tmkdir $(BUILDTESTDIR)\/6783039\/super\n+\t$(JDKJAVA) -cp $(JTREG_IMAGEDIR)\/lib\/jtreg.jar com.sun.javatest.diff.Main \\\n+\t\t-o $(BUILDTESTDIR)\/6783039\/super -super $(BUILDTESTDIR)\/6783039\/\n+\tif [ `find $(BUILDTESTDIR)\/6783039\/super -name \\*.html | wc -l` != 9 ]; then \\\n+\t\techo \"super output not as expected\" ; exit 1 ; \\\n+\tfi\n+\techo $@ passed at `date` > $@\n+\n+TESTS.jtdiff += $(BUILDTESTDIR)\/T6783039.ok\n","filename":"test\/6783039\/T6783039.gmk","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+#\n+# Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#----------------------------------------------------------------------\n+\n+$(BUILDTESTDIR)\/i18n.com.sun.javatest.diff.ok: \\\n+\t\t$(JAVAFILES.com.sun.javatest.diff) \\\n+\t\t$(JAVADIR)\/com\/sun\/javatest\/diff\/i18n.properties \\\n+\t\t$(BUILDDIR)\/classes.com.sun.javatest.diff.ok \\\n+\t\t$(TESTDIR)\/i18n\/checkI18NProps.sh\n+\t$(MKDIR) -p $(@:%.ok=%)\n+\tCLASSPATH=\"$(CLASSDIR)$(PS)$(JAVADIR)$(PS)$(JAVATEST_JAR)\" \\\n+\t\t$(JDKJAVA) -Djavatest.i18n.log=com.sun.javatest.diff \\\n+\t\t\tcom.sun.javatest.diff.Main -help all \\\n+\t\t\t> $(@:%.ok=%\/i18n-log.txt) 2>&1\n+\t$(SH) $(TESTDIR)\/i18n\/checkI18NProps.sh $(@:%.ok=%) $(JAVADIR)\/com\/sun\/javatest\/diff $(@:%.ok=%\/i18n-log.txt)\n+\techo $@ passed at `date` > $@\n+\n+TESTS.jtdiff += $(BUILDTESTDIR)\/i18n.com.sun.javatest.diff.ok\n","filename":"test\/i18n\/i18n.com.sun.javatest.diff.gmk","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"}]}