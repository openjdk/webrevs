{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import org.junit.platform.engine.DiscoverySelector;\n@@ -49,0 +50,1 @@\n+import java.util.List;\n@@ -54,0 +56,1 @@\n+import java.util.stream.Collectors;\n@@ -64,0 +67,2 @@\n+    private static final String JUNIT_SELECT_PREFIX = \"junit-select:\";\n+\n@@ -130,2 +135,15 @@\n-            \/\/ if test.query is set, treat it as a method name to be executed\n-            String testQuery = System.getProperty(\"test.query\");\n+            String testQueryStr = System.getProperty(\"test.query\");\n+            DiscoverySelector selector;\n+            if (testQueryStr != null && !testQueryStr.isEmpty()) {\n+                if (testQueryStr.startsWith(JUNIT_SELECT_PREFIX)) {\n+                    \/\/ https:\/\/junit.org\/junit5\/docs\/current\/user-guide\/#running-tests-discovery-selectors\n+                    String selectorStr = testQueryStr.substring(JUNIT_SELECT_PREFIX.length());\n+                    selector = DiscoverySelectors.parse(selectorStr)\n+                            .orElseThrow(() -> new IllegalArgumentException(\"Selector can not be parsed: \" + selectorStr));\n+                } else {\n+                    \/\/ legacy, assume method name\n+                    selector = DiscoverySelectors.selectMethod(mainClass, testQueryStr);\n+                }\n+            } else {\n+                selector = DiscoverySelectors.selectClass(mainClass);\n+            }\n@@ -133,4 +151,2 @@\n-                .selectors(testQuery == null\n-                        ? DiscoverySelectors.selectClass(mainClass)\n-                        : DiscoverySelectors.selectMethod(mainClass, testQuery))\n-                .build();\n+                    .selectors(selector)\n+                    .build();\n","filename":"src\/share\/classes\/com\/sun\/javatest\/regtest\/agent\/JUnitRunner.java","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -446,3 +446,6 @@\n-executed. For any tests executed by JUnit Platform, the string is interpreted\n-as the name of a single method in the test to be executed.  If you give\n-conflicting values for the string, including not setting any value, the last\n+executed. For any tests executed by JUnit Platform, the string is by default interpreted\n+as the name of a single method in the test to be executed. However, it is also\n+possible to use other JUnit selectors by prefixing the query string with `junit-select:`.\n+The rest of the string can then be any selector identifier as listed in the left-most\n+column of the table found here: https:\/\/junit.org\/junit5\/docs\/current\/user-guide\/#running-tests-discovery-selectors \n+If you give conflicting values for the string, including not setting any value, the last\n@@ -494,1 +497,1 @@\n-### How do I run a single test method in a JUnit test?\n+### How do I run a single test method or class in a JUnit test?\n@@ -500,0 +503,15 @@\n+This will run a method called `method-name`, having no parameters, in the top-level test class.\n+\n+To run a parameterized test method, the extended selector syntax has to be used. For example:\n+\n+    path-to-test?junit-select:method:class-name#method-name(param-type, ...param-type)\n+\n+Note that in this case, the `class-name` and `param-type` elements must be binary names, as returned\n+by `Class::getName`. For some examples, see: https:\/\/junit.org\/junit5\/docs\/current\/api\/org.junit.platform.engine\/org\/junit\/platform\/engine\/discovery\/DiscoverySelectors.html#selectMethod(java.lang.String)\n+\n+To run a specific nested test class, annotated with the `@Nested` annotation, the following can be used:\n+\n+    path-to-test?junit-select:class:class-name\n+\n+Note that again, the `class-name` has to be the binary name of the class.\n+\n","filename":"src\/share\/doc\/javatest\/regtest\/faq.md","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-\tif [ \"$$OUT\" != \"Test1.m11 Test1.m12 Test1.m13 Test2.m21 Test2.m22 Test2.m23\" ]; then \\\n+\tif [ \"$$OUT\" != \"Test1.parameterized Test1.m11 Test1.m12 Test1.m13 Test1.nested Test2.m21 Test2.m22 Test2.m23\" ]; then \\\n@@ -46,1 +46,1 @@\n-\t$(GREP) \"a\/b\/c\/ .* tests: 6, skipped: 0, started: 6, succeeded: 6, failed: 0, aborted: 0\" $(@:%.ok=%)\/report\/text\/junit.txt\n+\t$(GREP) \"a\/b\/c\/ .* tests: 8, skipped: 0, started: 8, succeeded: 8, failed: 0, aborted: 0\" $(@:%.ok=%)\/report\/text\/junit.txt\n@@ -177,1 +177,1 @@\n-\tif [ \"$$OUT\" != \"Test1.m11 Test1.m12 Test1.m13\" ]; then \\\n+\tif [ \"$$OUT\" != \"Test1.parameterized Test1.m11 Test1.m12 Test1.m13 Test1.nested\" ]; then \\\n@@ -180,1 +180,1 @@\n-\t$(GREP) \"a\/b\/c\/ .* tests: 3, skipped: 0, started: 3, succeeded: 3, failed: 0, aborted: 0\" $(@:%.ok=%)\/report\/text\/junit.txt\n+\t$(GREP) \"a\/b\/c\/ .* tests: 5, skipped: 0, started: 5, succeeded: 5, failed: 0, aborted: 0\" $(@:%.ok=%)\/report\/text\/junit.txt\n@@ -212,0 +212,50 @@\n+#----------------------------------------------------------------------\n+#\n+# parameterizedTest\n+\n+$(BUILDTESTDIR)\/JUnitQueryTest.parameterized.ok: $(JTREG_IMAGEDIR)\/lib\/javatest.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/lib\/jtreg.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/bin\/jtreg\n+\t$(RM) $(@:%.ok=%)\n+\t$(MKDIR) $(@:%.ok=%)\n+\tJT_JAVA=$(JDKHOME) JTHOME=$(JTREG_IMAGEDIR) \\\n+\t    $(JTREG_IMAGEDIR)\/bin\/jtreg $(JTREG_OPTS) \\\n+\t\t-w:$(@:%.ok=%)\/work -r:$(@:%.ok=%)\/report \\\n+\t\t-jdk:$(JDKHOME) \\\n+\t\t-va \\\n+\t\t\"$(TESTDIR)\/junitQueryTest\/a\/b\/c\/Test1.java?junit-select:method:Test1#parameterized(java.lang.String,Test1\\$$NestedClass,boolean,byte,char,short,int,long,float,double,[Ljava.lang.String;,[Z,[B,[C,[S,[I,[J,[F,[D)\" \\\n+\t\t > $(@:%.ok=%)\/jt.log 2>&1\n+\tOUT=$$( $(ECHO) $$( $(AWK) '\/STDOUT:\/,\/STDERR:\/{ print $0; } { }' $(@:%.ok=%)\/jt.log | $(GREP) -v STD ) ) ; \\\n+\tif [ \"$$OUT\" != \"Test1.parameterized\" ]; then \\\n+\t    echo \"unexpected set of tests run: $$OUT\"; exit 1 ; \\\n+\tfi\n+\t$(GREP) \"a\/b\/c\/ .* tests: 1, skipped: 0, started: 1, succeeded: 1, failed: 0, aborted: 0\" $(@:%.ok=%)\/report\/text\/junit.txt\n+\techo $@ passed at `date` > $@\n+\n+TESTS.jtreg += $(BUILDTESTDIR)\/JUnitQueryTest.parameterized.ok\n+\n+#----------------------------------------------------------------------\n+#\n+# nested class\n+\n+$(BUILDTESTDIR)\/JUnitQueryTest.nested.class.ok: $(JTREG_IMAGEDIR)\/lib\/javatest.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/lib\/jtreg.jar \\\n+\t\t$(JTREG_IMAGEDIR)\/bin\/jtreg\n+\t$(RM) $(@:%.ok=%)\n+\t$(MKDIR) $(@:%.ok=%)\n+\tJT_JAVA=$(JDKHOME) JTHOME=$(JTREG_IMAGEDIR) \\\n+\t    $(JTREG_IMAGEDIR)\/bin\/jtreg $(JTREG_OPTS) \\\n+\t\t-w:$(@:%.ok=%)\/work -r:$(@:%.ok=%)\/report \\\n+\t\t-jdk:$(JDKHOME) \\\n+\t\t-va \\\n+\t\t\"$(TESTDIR)\/junitQueryTest\/a\/b\/c\/Test1.java?junit-select:class:Test1\\$$NestedTests\" \\\n+\t\t > $(@:%.ok=%)\/jt.log 2>&1\n+\tOUT=$$( $(ECHO) $$( $(AWK) '\/STDOUT:\/,\/STDERR:\/{ print $0; } { }' $(@:%.ok=%)\/jt.log | $(GREP) -v STD ) ) ; \\\n+\tif [ \"$$OUT\" != \"Test1.nested\" ]; then \\\n+\t    echo \"unexpected set of tests run: $$OUT\"; exit 1 ; \\\n+\tfi\n+\t$(GREP) \"a\/b\/c\/ .* tests: 1, skipped: 0, started: 1, succeeded: 1, failed: 0, aborted: 0\" $(@:%.ok=%)\/report\/text\/junit.txt\n+\techo $@ passed at `date` > $@\n+\n+TESTS.jtreg += $(BUILDTESTDIR)\/JUnitQueryTest.nested.class.ok\n+\n@@ -270,0 +320,2 @@\n+    $(BUILDTESTDIR)\/JUnitQueryTest.parameterized.ok \\\n+    $(BUILDTESTDIR)\/JUnitQueryTest.nested.class.ok \\\n","filename":"test\/junitQueryTest\/JUnitQueryTest.gmk","additions":56,"deletions":4,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import org.junit.jupiter.api.Nested;\n@@ -25,0 +26,7 @@\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.params.provider.Arguments.arguments;\n@@ -45,0 +53,32 @@\n+\n+    @ParameterizedTest\n+    @MethodSource(\"params\")\n+    public void parameterized(String str,\n+                              NestedClass nested,\n+                              boolean z, byte b, char c, short s, int i, long l, float f, double d,\n+                              String[] stra,\n+                              boolean[] za, byte[] ba, char[] ca, short[] sa, int[] ia, long[] la, float[] fa, double[] da) {\n+        System.out.println(\"Test1.parameterized\");\n+    }\n+\n+    static Stream<Arguments> params() {\n+        return Stream.of(\n+            arguments(\n+                    \"a\",\n+                    new NestedClass(),\n+                    true, (byte) 42, 'x', (short) 42, 42, 42L, 42.0F, 42.0D,\n+                    new String[0],\n+                    new boolean[0], new byte[0], new char[0], new short[0], new int[0], new long[0], new float[0], new double[0]\n+            )\n+        );\n+    }\n+\n+    static class NestedClass {}\n+\n+    @Nested\n+    class NestedTests {\n+        @Test\n+        public void nested() {\n+            System.out.println(\"Test1.nested\");\n+        }\n+    }\n","filename":"test\/junitQueryTest\/a\/b\/c\/Test1.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"}]}