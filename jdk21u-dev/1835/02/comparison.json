{"files":[{"patch":"@@ -400,1 +400,1 @@\n-objArrayOop ClassListParser::get_specified_interfaces(TRAPS) {\n+GrowableArray<InstanceKlass *> ClassListParser::get_specified_interfaces() {\n@@ -402,8 +402,3 @@\n-  if (n == 0) {\n-    return nullptr;\n-  } else {\n-    objArrayOop array = oopFactory::new_objArray(vmClasses::Class_klass(), n, CHECK_NULL);\n-    for (int i = 0; i < n; i++) {\n-      array->obj_at_put(i, lookup_class_by_id(_interfaces->at(i))->java_mirror());\n-    }\n-    return array;\n+  GrowableArray<InstanceKlass *> specified_interfaces(n);\n+  for (int i = 0; i < n; i++) {\n+    specified_interfaces.append(lookup_class_by_id(_interfaces->at(i)));\n@@ -411,0 +406,1 @@\n+  return specified_interfaces;\n@@ -472,0 +468,19 @@\n+\/\/ If an unregistered class U is specified to have a registered supertype S1\n+\/\/ named SN but an unregistered class S2 also named SN has already been loaded\n+\/\/ S2 will be incorrectly used as the supertype of U instead of S1 due to\n+\/\/ limitations in the loading mechanism of unregistered classes.\n+void ClassListParser::check_supertype_obstruction(int specified_supertype_id, const InstanceKlass* specified_supertype, TRAPS) {\n+  if (specified_supertype->is_shared_unregistered_class()) {\n+    return; \/\/ Only registered supertypes can be obstructed\n+  }\n+  const InstanceKlass* obstructor = SystemDictionaryShared::get_unregistered_class(specified_supertype->name());\n+  if (obstructor == nullptr) {\n+    return; \/\/ No unregistered types with the same name have been loaded, i.e. no obstruction\n+  }\n+  \/\/ 'specified_supertype' is S1, 'obstructor' is S2 from the explanation above\n+  ResourceMark rm;\n+  THROW_MSG(vmSymbols::java_lang_UnsupportedOperationException(),\n+            err_msg(\"%s (id %d) has super-type %s (id %d) obstructed by another class with the same name\",\n+                    _class_name, _id, specified_supertype->external_name(), specified_supertype_id));\n+}\n+\n@@ -496,1 +511,0 @@\n-  char * source_path = os::strdup_check_oom(ClassLoader::uri_to_path(_source));\n@@ -498,5 +512,11 @@\n-  Handle super_class(THREAD, specified_super->java_mirror());\n-  objArrayOop r = get_specified_interfaces(CHECK_NULL);\n-  objArrayHandle interfaces(THREAD, r);\n-  InstanceKlass* k = UnregisteredClasses::load_class(class_name, source_path,\n-                                                     super_class, interfaces, CHECK_NULL);\n+  GrowableArray<InstanceKlass*> specified_interfaces = get_specified_interfaces();\n+  \/\/ Obstruction must be checked before the class loading attempt because it may\n+  \/\/ cause class loading errors (JVMS 5.3.5.3-5.3.5.4)\n+  check_supertype_obstruction(_super, specified_super, CHECK_NULL);\n+  for (int i = 0; i < _interfaces->length(); i++) {\n+    check_supertype_obstruction(_interfaces->at(i), specified_interfaces.at(i), CHECK_NULL);\n+  }\n+\n+  const char* source_path = ClassLoader::uri_to_path(_source);\n+  InstanceKlass* k = UnregisteredClasses::load_class(class_name, source_path, CHECK_NULL);\n+\n@@ -514,0 +534,9 @@\n+  for (int i = 0; i < _interfaces->length(); i++) {\n+    InstanceKlass* specified_interface = specified_interfaces.at(i);\n+    if (!k->local_interfaces()->contains(specified_interface)) {\n+      print_specified_interfaces();\n+      print_actual_interfaces(k);\n+      error(\"Specified interface %s (id %d) is not directly implemented\",\n+            specified_interface->external_name(), _interfaces->at(i));\n+      }\n+  }\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":44,"deletions":15,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -137,1 +137,2 @@\n-  objArrayOop get_specified_interfaces(TRAPS);\n+  GrowableArray<InstanceKlass*> get_specified_interfaces();\n+  void check_supertype_obstruction(int specified_supertype_id, const InstanceKlass* specified_supertype, TRAPS);\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,4 +27,0 @@\n-#include \"classfile\/classFileStream.hpp\"\n-#include \"classfile\/classLoader.inline.hpp\"\n-#include \"classfile\/classLoaderExt.hpp\"\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -34,2 +30,0 @@\n-#include \"memory\/oopFactory.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n@@ -37,0 +31,1 @@\n+#include \"oops\/oopHandle.hpp\"\n@@ -38,0 +33,1 @@\n+#include \"runtime\/handles.hpp\"\n@@ -42,1 +38,3 @@\n-InstanceKlass* UnregisteredClasses::_UnregisteredClassLoader_klass = nullptr;\n+static InstanceKlass* _UnregisteredClassLoader_klass;\n+static InstanceKlass* _UnregisteredClassLoader_Source_klass;\n+static OopHandle _unregistered_class_loader;\n@@ -45,5 +43,2 @@\n-  if (_UnregisteredClassLoader_klass == nullptr) {\n-    \/\/ no need for synchronization as this function is called single-threaded.\n-    Symbol* klass_name = SymbolTable::new_symbol(\"jdk\/internal\/misc\/CDS$UnregisteredClassLoader\");\n-    Klass* k = SystemDictionary::resolve_or_fail(klass_name, true, CHECK);\n-    _UnregisteredClassLoader_klass = InstanceKlass::cast(k);\n+  if (_UnregisteredClassLoader_klass != nullptr) {\n+    return;\n@@ -51,0 +46,18 @@\n+\n+  Symbol* klass_name;\n+  Klass* k;\n+\n+  \/\/ no need for synchronization as this function is called single-threaded.\n+  klass_name = SymbolTable::new_symbol(\"jdk\/internal\/misc\/CDS$UnregisteredClassLoader\");\n+  k = SystemDictionary::resolve_or_fail(klass_name, true, CHECK);\n+  _UnregisteredClassLoader_klass = InstanceKlass::cast(k);\n+\n+  klass_name = SymbolTable::new_symbol(\"jdk\/internal\/misc\/CDS$UnregisteredClassLoader$Source\");\n+  k = SystemDictionary::resolve_or_fail(klass_name, true, CHECK);\n+  _UnregisteredClassLoader_Source_klass = InstanceKlass::cast(k);\n+\n+  precond(_unregistered_class_loader.is_empty());\n+  HandleMark hm(THREAD);\n+  const Handle cl = JavaCalls::construct_new_instance(_UnregisteredClassLoader_klass,\n+                                                      vmSymbols::void_method_signature(), CHECK);\n+  _unregistered_class_loader = OopHandle(Universe::vm_global(), cl());\n@@ -56,2 +69,1 @@\n-InstanceKlass* UnregisteredClasses::load_class(Symbol* name, const char* path,\n-                                               Handle super_class, objArrayHandle interfaces, TRAPS) {\n+InstanceKlass* UnregisteredClasses::load_class(Symbol* name, const char* path, TRAPS) {\n@@ -65,1 +77,4 @@\n-  \/\/ Call CDS$UnregisteredClassLoader::load(String name, Class<?> superClass, Class<?>[] interfaces)\n+  assert(!_unregistered_class_loader.is_empty(), \"not initialized\");\n+  Handle classloader(THREAD, _unregistered_class_loader.resolve());\n+\n+  \/\/ Call CDS$UnregisteredClassLoader::load(String name, String source)\n@@ -67,3 +82,1 @@\n-  Symbol* methodSignature = SymbolTable::new_symbol(\"(Ljava\/lang\/String;Ljava\/lang\/Class;[Ljava\/lang\/Class;)Ljava\/lang\/Class;\");\n-  Symbol* path_symbol = SymbolTable::new_symbol(path);\n-  Handle classloader = get_classloader(path_symbol, CHECK_NULL);\n+  Symbol* methodSignature = SymbolTable::new_symbol(\"(Ljava\/lang\/String;Ljava\/lang\/String;)Ljava\/lang\/Class;\");\n@@ -71,0 +84,1 @@\n+  Handle path_string = java_lang_String::create_from_str(path, CHECK_NULL);\n@@ -73,5 +87,0 @@\n-  JavaCallArguments args(3);\n-  args.set_receiver(classloader);\n-  args.push_oop(ext_class_name);\n-  args.push_oop(super_class);\n-  args.push_oop(interfaces);\n@@ -79,1 +88,2 @@\n-                          UnregisteredClassLoader_klass(),\n+                          classloader,\n+                          _UnregisteredClassLoader_klass,\n@@ -82,1 +92,2 @@\n-                          &args,\n+                          ext_class_name,\n+                          path_string,\n@@ -85,10 +96,0 @@\n-  oop obj = result.get_oop();\n-  return InstanceKlass::cast(java_lang_Class::as_Klass(obj));\n-}\n-\n-class UnregisteredClasses::ClassLoaderTable : public ResourceHashtable<\n-  Symbol*, OopHandle,\n-  137, \/\/ prime number\n-  AnyObj::C_HEAP> {};\n-\n-static UnregisteredClasses::ClassLoaderTable* _classloader_table = nullptr;\n@@ -96,9 +97,1 @@\n-Handle UnregisteredClasses::create_classloader(Symbol* path, TRAPS) {\n-  ResourceMark rm(THREAD);\n-  JavaValue result(T_OBJECT);\n-  Handle path_string = java_lang_String::create_from_str(path->as_C_string(), CHECK_NH);\n-  Handle classloader = JavaCalls::construct_new_instance(\n-                           UnregisteredClassLoader_klass(),\n-                           vmSymbols::string_void_signature(),\n-                           path_string, CHECK_NH);\n-  return classloader;\n+  return InstanceKlass::cast(java_lang_Class::as_Klass(result.get_oop()));\n@@ -107,12 +100,3 @@\n-Handle UnregisteredClasses::get_classloader(Symbol* path, TRAPS) {\n-  if (_classloader_table == nullptr) {\n-    _classloader_table = new (mtClass)ClassLoaderTable();\n-  }\n-  OopHandle* classloader_ptr = _classloader_table->get(path);\n-  if (classloader_ptr != nullptr) {\n-    return Handle(THREAD, (*classloader_ptr).resolve());\n-  } else {\n-    Handle classloader = create_classloader(path, CHECK_NH);\n-    _classloader_table->put(path, OopHandle(Universe::vm_global(), classloader()));\n-    path->increment_refcount();\n-    return classloader;\n+bool UnregisteredClasses::check_for_exclusion(const InstanceKlass* k) {\n+  if (_UnregisteredClassLoader_klass == nullptr) {\n+    return false; \/\/ Uninitialized\n@@ -120,0 +104,2 @@\n+  return k == _UnregisteredClassLoader_klass ||\n+         k->implements_interface(_UnregisteredClassLoader_Source_klass);\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.cpp","additions":42,"deletions":56,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -36,3 +36,1 @@\n-  static InstanceKlass* load_class(Symbol* h_name, const char* path,\n-                                   Handle super_class, objArrayHandle interfaces,\n-                                   TRAPS);\n+  static InstanceKlass* load_class(Symbol* name, const char* path, TRAPS);\n@@ -40,12 +38,2 @@\n-  static InstanceKlass* UnregisteredClassLoader_klass() {\n-    return _UnregisteredClassLoader_klass;\n-  }\n-\n-  class ClassLoaderTable;\n-\n-private:\n-  \/\/ Don't put this in vmClasses as it's used only with CDS dumping.\n-  static InstanceKlass* _UnregisteredClassLoader_klass;\n-\n-  static Handle create_classloader(Symbol* path, TRAPS);\n-  static Handle get_classloader(Symbol* path, TRAPS);\n+  \/\/ Returns true if the class is loaded internally for dumping unregistered classes.\n+  static bool check_for_exclusion(const InstanceKlass* k);\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.hpp","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -317,0 +317,6 @@\n+  if (UnregisteredClasses::check_for_exclusion(k)) {\n+    ResourceMark rm;\n+    log_info(cds)(\"Skipping %s: used only when dumping CDS archive\", k->name()->as_C_string());\n+    return true;\n+  }\n+\n@@ -335,6 +341,0 @@\n-  if (k == UnregisteredClasses::UnregisteredClassLoader_klass()) {\n-    ResourceMark rm;\n-    log_info(cds)(\"Skipping %s: used only when dumping CDS archive\", k->name()->as_C_string());\n-    return true;\n-  }\n-\n@@ -459,0 +459,9 @@\n+InstanceKlass* SystemDictionaryShared::get_unregistered_class(Symbol* name) {\n+  assert(Arguments::is_dumping_archive() || ClassListWriter::is_enabled(), \"sanity\");\n+  if (_unregistered_classes_table == nullptr) {\n+    return nullptr;\n+  }\n+  InstanceKlass** k = _unregistered_classes_table->get(name);\n+  return k != nullptr ? *k : nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -290,0 +290,1 @@\n+  static InstanceKlass* get_unregistered_class(Symbol* name);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,3 +34,1 @@\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.nio.file.InvalidPathException;\n+import java.nio.file.Files;\n@@ -40,0 +38,1 @@\n+import java.util.HashMap;\n@@ -43,0 +42,1 @@\n+import java.util.jar.JarFile;\n@@ -347,4 +347,4 @@\n-    private static class UnregisteredClassLoader extends URLClassLoader {\n-        private String currentClassName;\n-        private Class<?> currentSuperClass;\n-        private Class<?>[] currentInterfaces;\n+    private static class UnregisteredClassLoader extends ClassLoader {\n+        static {\n+            registerAsParallelCapable();\n+        }\n@@ -352,12 +352,2 @@\n-        \/**\n-         * Used only by native code. Construct an UnregisteredClassLoader for loading\n-         * unregistered classes from the specified file. If the file doesn't exist,\n-         * the exception will be caughted by native code which will print a warning message and continue.\n-         *\n-         * @param fileName path of the the JAR file to load unregistered classes from.\n-         *\/\n-        private UnregisteredClassLoader(String fileName) throws InvalidPathException, IOException {\n-            super(toURLArray(fileName), \/*parent*\/null);\n-            currentClassName = null;\n-            currentSuperClass = null;\n-            currentInterfaces = null;\n+        static interface Source {\n+            public byte[] readClassFile(String className) throws IOException;\n@@ -366,3 +356,17 @@\n-        private static URL[] toURLArray(String fileName) throws InvalidPathException, IOException {\n-            if (!((new File(fileName)).exists())) {\n-                throw new IOException(\"No such file: \" + fileName);\n+        static class JarSource implements Source {\n+            private final JarFile jar;\n+\n+            JarSource(File file) throws IOException {\n+                jar = new JarFile(file);\n+            }\n+\n+            @Override\n+            public byte[] readClassFile(String className) throws IOException {\n+                final var entryName = className.replace('.', '\/').concat(\".class\");\n+                final var entry = jar.getEntry(entryName);\n+                if (entry == null) {\n+                    throw new IOException(\"No such entry: \" + entryName + \" in \" + jar.getName());\n+                }\n+                try (final var in = jar.getInputStream(entry)) {\n+                    return in.readAllBytes();\n+                }\n@@ -370,6 +374,0 @@\n-            return new URL[] {\n-                \/\/ Use an intermediate File object to construct a URI\/URL without\n-                \/\/ authority component as URLClassPath can't handle URLs with a UNC\n-                \/\/ server name in the authority component.\n-                Path.of(fileName).toRealPath().toFile().toURI().toURL()\n-            };\n@@ -378,0 +376,2 @@\n+        static class DirSource implements Source {\n+            private final String basePath;\n@@ -379,30 +379,10 @@\n-        \/**\n-         * Load the class of the given <code>\/name<code> from the JAR file that was given to\n-         * the constructor of the current UnregisteredClassLoader instance. This class must be\n-         * a direct subclass of <code>superClass<\/code>. This class must be declared to implement\n-         * the specified <code>interfaces<\/code>.\n-         * <p>\n-         * This method must be called in a single threaded context. It will never be recursed (thus\n-         * the asserts)\n-         *\n-         * @param name the name of the class to be loaded.\n-         * @param superClass must not be null. The named class must have a super class.\n-         * @param interfaces could be null if the named class does not implement any interfaces.\n-         *\/\n-        private Class<?> load(String name, Class<?> superClass, Class<?>[] interfaces)\n-            throws ClassNotFoundException\n-        {\n-            assert currentClassName == null;\n-            assert currentSuperClass == null;\n-            assert currentInterfaces == null;\n-\n-            try {\n-                currentClassName = name;\n-                currentSuperClass = superClass;\n-                currentInterfaces = interfaces;\n-\n-                return findClass(name);\n-            } finally {\n-                currentClassName = null;\n-                currentSuperClass = null;\n-                currentInterfaces = null;\n+            DirSource(File dir) {\n+                assert dir.isDirectory();\n+                basePath = dir.toString();\n+            }\n+\n+            @Override\n+            public byte[] readClassFile(String className) throws IOException {\n+                final var subPath = className.replace('.', File.separatorChar).concat(\".class\");\n+                final var fullPath = Path.of(basePath, subPath);\n+                return Files.readAllBytes(fullPath);\n@@ -412,21 +392,6 @@\n-        \/**\n-         * This method must be called from inside the <code>load()<\/code> method. The <code>\/name<code>\n-         * can be only:\n-         * <ul>\n-         * <li> the <code>name<\/code> parameter for <code>load()<\/code>\n-         * <li> the name of the <code>superClass<\/code> parameter for <code>load()<\/code>\n-         * <li> the name of one of the interfaces in <code>interfaces<\/code> parameter for <code>load()<\/code>\n-         * <ul>\n-         *\n-         * For all other cases, a <code>ClassNotFoundException<\/code> will be thrown.\n-         *\/\n-        protected Class<?> findClass(final String name)\n-            throws ClassNotFoundException\n-        {\n-            Objects.requireNonNull(currentClassName);\n-            Objects.requireNonNull(currentSuperClass);\n-\n-            if (name.equals(currentClassName)) {\n-                \/\/ Note: the following call will call back to <code>this.findClass(name)<\/code> to\n-                \/\/ resolve the super types of the named class.\n-                return super.findClass(name);\n+        private final HashMap<String, Source> sources = new HashMap<>();\n+\n+        private Source resolveSource(String path) throws IOException {\n+            Source source = sources.get(path);\n+            if (source != null) {\n+                return source;\n@@ -434,2 +399,4 @@\n-            if (name.equals(currentSuperClass.getName())) {\n-                return currentSuperClass;\n+\n+            final var file = new File(path);\n+            if (!file.exists()) {\n+                throw new IOException(\"No such file: \" + path);\n@@ -437,6 +404,6 @@\n-            if (currentInterfaces != null) {\n-                for (Class<?> c : currentInterfaces) {\n-                    if (name.equals(c.getName())) {\n-                        return c;\n-                    }\n-                }\n+            if (file.isFile()) {\n+                source = new JarSource(file);\n+            } else if (file.isDirectory()) {\n+                source = new DirSource(file);\n+            } else {\n+                throw new IOException(\"Not a normal file: \" + path);\n@@ -444,0 +411,1 @@\n+            sources.put(path, source);\n@@ -445,1 +413,39 @@\n-            throw new ClassNotFoundException(name);\n+            return source;\n+        }\n+\n+        \/**\n+         * Load the class of the given <code>name<\/code> from the given <code>source<\/code>.\n+         * <p>\n+         * All super classes and interfaces of the named class must have already been loaded:\n+         * either defined by this class loader (unregistered ones) or loaded, possibly indirectly,\n+         * by the system class loader (registered ones).\n+         * <p>\n+         * If the named class has a registered super class or interface named N there should be no\n+         * unregistered class or interface named N loaded yet.\n+         *\n+         * @param name the name of the class to be loaded.\n+         * @param source path to a directory or a JAR file from which the named class should be\n+         *               loaded.\n+         *\/\n+        private Class<?> load(String name, String source) throws IOException {\n+            final Source resolvedSource = resolveSource(source);\n+            final byte[] bytes = resolvedSource.readClassFile(name);\n+            \/\/ 'defineClass()' may cause loading of supertypes of this unregistered class by VM\n+            \/\/ calling 'this.loadClass()'.\n+            \/\/\n+            \/\/ For any supertype S named SN specified in the classlist the following is ensured by\n+            \/\/ the CDS implementation:\n+            \/\/ - if S is an unregistered class it must have already been defined by this class\n+            \/\/   loader and thus will be found by 'this.findLoadedClass(SN)',\n+            \/\/ - if S is not an unregistered class there should be no unregistered class named SN\n+            \/\/   loaded yet so either S has previously been (indirectly) loaded by this class loader\n+            \/\/   and thus it will be found when calling 'this.findLoadedClass(SN)' or it will be\n+            \/\/   found when delegating to the system class loader, which must have already loaded S,\n+            \/\/   by calling 'this.getParent().loadClass(SN, false)'.\n+            \/\/ See the implementation of 'ClassLoader.loadClass()' for details.\n+            \/\/\n+            \/\/ Therefore, we should resolve all supertypes to the expected ones as specified by the\n+            \/\/ \"super:\" and \"interfaces:\" attributes in the classlist. This invariant is validated\n+            \/\/ by the C++ function 'ClassListParser::load_class_from_source()'.\n+            assert getParent() == getSystemClassLoader();\n+            return defineClass(name, bytes, 0, bytes.length);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":94,"deletions":88,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test\n+ * @bug 8315130\n+ * @summary Tests archiving a hierarchy of package-private classes loaded from\n+ * different sources.\n+ *\n+ * @requires vm.cds\n+ * @requires vm.cds.custom.loaders\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile test-classes\/DifferentSourcesApp.java test-classes\/CustomLoadee5.java test-classes\/CustomLoadee5Child.java\n+ * @run main DifferentSourcesTest\n+ *\/\n+public class DifferentSourcesTest {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Setup:\n+        \/\/ - CustomLoadee5 is package-private\n+        \/\/ - CustomLoadee5Child extends CustomLoadee5\n+        \/\/\n+        \/\/ This setup requires CustomLoadee5 and CustomLoadee5Child to be in the\n+        \/\/ same run-time package. Since their package name is the same (empty)\n+        \/\/ this boils down to \"be loaded by the same class loader\".\n+        \/\/\n+        \/\/ DifferentSourcesApp adheres to this requirement.\n+        \/\/\n+        \/\/ This test checks that CDS adheres to this requirement too when\n+        \/\/ creating a static app archive, even if CustomLoadee5 and\n+        \/\/ CustomLoadee5Child are in different sources.\n+\n+        OutputAnalyzer output;\n+\n+        \/\/ The main check: the archive is created without IllegalAccessError\n+        JarBuilder.build(\"base\", \"CustomLoadee5\");\n+        JarBuilder.build(\"sub\", \"CustomLoadee5Child\");\n+        final String classlist[] = new String[] {\n+            \"java\/lang\/Object id: 0\",\n+            \"CustomLoadee5 id: 1 super: 0 source: base.jar\",\n+            \"CustomLoadee5Child id: 2 super: 1 source: sub.jar\",\n+        };\n+        output = TestCommon.testDump(null, classlist);\n+        output.shouldNotContain(\"java.lang.IllegalAccessError: class CustomLoadee5Child cannot access its superclass CustomLoadee5\");\n+        output.shouldNotContain(\"Cannot find CustomLoadee5Child\");\n+\n+        \/\/ Sanity check: the archive is used as expected\n+        output = TestCommon.execCommon(\"-Xlog:class+load\", \"DifferentSourcesApp\");\n+        TestCommon.checkExec(\n+            output,\n+            \"CustomLoadee5 source: shared objects file\",\n+            \"CustomLoadee5Child source: shared objects file\"\n+        );\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/DifferentSourcesTest.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test id=unreg\n+ * @summary Tests that if a super class is listed as unregistered it is archived\n+ * as such even if a class with the same name has also been loaded from the\n+ * classpath.\n+ *\n+ * @requires vm.cds\n+ * @requires vm.cds.custom.loaders\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile test-classes\/RegUnregSuperApp.java test-classes\/CustomLoadee3.java test-classes\/CustomLoadee3Child.java\n+ * @run main RegUnregSuperTest unreg\n+ *\/\n+\n+\/**\n+ * @test id=reg\n+ * @summary If an unregistered class U is specified to have a registered\n+ * supertype S1 named SN but an unregistered class S2 also named SN has already\n+ * been loaded S2 will be incorrectly used as the supertype of U instead of S1\n+ * due to limitations in the loading mechanism of unregistered classes. For this\n+ * reason U should not be loaded at all and an appropriate warning should be\n+ * printed.\n+ *\n+ * @requires vm.cds\n+ * @requires vm.cds.custom.loaders\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile test-classes\/RegUnregSuperApp.java test-classes\/CustomLoadee3.java test-classes\/CustomLoadee3Child.java\n+ * @run main RegUnregSuperTest reg\n+ *\/\n+\n+public class RegUnregSuperTest {\n+    public static void main(String[] args) throws Exception {\n+        final String variant = args[0];\n+\n+        final String appJar = JarBuilder.build(\n+            \"app\", \"RegUnregSuperApp\", \"DirectClassLoader\", \"CustomLoadee3\", \"CustomLoadee3Child\"\n+        );\n+        OutputAnalyzer out;\n+\n+        final String classlist[] = new String[] {\n+            \"java\/lang\/Object id: 0\",\n+            \"CustomLoadee3 id: 1\",\n+            \"CustomLoadee3 id: 2 super: 0 source: \" + appJar,\n+            \"CustomLoadee3Child id: 3 super: \" + (\"reg\".equals(variant) ? \"1\" : \"2\") + \" source: \" + appJar\n+        };\n+        out = TestCommon.testDump(appJar, classlist, \"-Xlog:cds+class=debug\");\n+        out.shouldContain(\"app   CustomLoadee3\"); \/\/ Not using \\n as below because it'll be \"app   CustomLoadee3 aot-linked\" with AOTClassLinking\n+        out.shouldNotContain(\"app   CustomLoadee3Child\");\n+        out.shouldContain(\"unreg CustomLoadee3\\n\"); \/\/ Accepts \"unreg CustomLoadee3\" but not \"unreg CustomLoadee3Child\"\n+        if (\"reg\".equals(variant)) {\n+            out.shouldNotContain(\"unreg CustomLoadee3Child\");\n+            out.shouldContain(\"CustomLoadee3Child (id 3) has super-type CustomLoadee3 (id 1) obstructed by another class with the same name\");\n+        } else {\n+            out.shouldContain(\"unreg CustomLoadee3Child\");\n+            out.shouldNotContain(\"[warning]\");\n+        }\n+\n+        out = TestCommon.exec(appJar, \"-Xlog:class+load\", \"RegUnregSuperApp\", variant);\n+        TestCommon.checkExec(\n+            out,\n+            \"CustomLoadee3Child source: \" + (\"reg\".equals(variant) ? \"file:\" : \"shared objects file\")\n+        );\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/RegUnregSuperTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class CustomLoadee5 {\n+    public String toString() {\n+        return \"this is CustomLoadee5\";\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\/CustomLoadee5.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class CustomLoadee5Child extends CustomLoadee5 {\n+    public String toString() {\n+        return \"this is CustomLoadee5Child\";\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\/CustomLoadee5Child.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.nio.file.FileSystems;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+\n+\/**\n+ * See ..\/DifferentSourcesTest.java for details.\n+ *\/\n+public class DifferentSourcesApp {\n+    public static void main(String args[]) throws Exception {\n+        Path base = FileSystems.getDefault().getPath(\"base.jar\");\n+        Path sub = FileSystems.getDefault().getPath(\"sub.jar\");\n+        URL[] urls = new URL[] { base.toUri().toURL(), sub.toUri().toURL() };\n+        URLClassLoader cl = new URLClassLoader(urls, \/* parent = *\/ null);\n+        Class<?> cls = cl.loadClass(\"CustomLoadee5Child\");\n+        System.out.println(cls.getName());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\/DifferentSourcesApp.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.FileSystems;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.Set;\n+\n+class DirectClassLoader extends URLClassLoader {\n+    private final Set<String> directlyLoadedNames;\n+\n+    public DirectClassLoader(URL url, String... directlyLoadedNames) {\n+        super(new URL[] { url });\n+        this.directlyLoadedNames = Set.of(directlyLoadedNames);\n+    }\n+\n+    @Override\n+    public Class<?> loadClass(String name) throws ClassNotFoundException {\n+        synchronized (getClassLoadingLock(name)) {\n+            Class<?> c = findLoadedClass(name);\n+            if (c == null) {\n+                if (directlyLoadedNames.contains(name)) {\n+                    c = findClass(name);\n+                } else {\n+                    c = super.loadClass(name);\n+                }\n+            }\n+            return c;\n+        }\n+    }\n+}\n+\n+\/**\n+ * See ..\/RegUnregSuperTest.java for details.\n+ *\/\n+public class RegUnregSuperApp {\n+    private static final URL APP_JAR;\n+    static {\n+        final URL appJar;\n+        try {\n+            appJar = FileSystems.getDefault().getPath(\"app.jar\").toUri().toURL();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+        APP_JAR = appJar;\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        switch (args[0]) {\n+            case \"reg\" -> loadWithRegisteredSuper();\n+            case \"unreg\" -> loadWithUnregisteredSuper();\n+            default -> throw new IllegalArgumentException(\"Unknown variant: \" + args[0]);\n+        }\n+    }\n+\n+    private static void loadWithRegisteredSuper() throws Exception {\n+        \/\/ Load unregistered super\n+        final var unregisteredBaseCl = new DirectClassLoader(APP_JAR, \"CustomLoadee3\");\n+        Class<?> unregisteredBase = unregisteredBaseCl.loadClass(\"CustomLoadee3\");\n+        checkClassLoader(unregisteredBase, unregisteredBaseCl);\n+\n+        \/\/ Load unregistered child with REGISTERED super\n+        final var registeredBaseCl = new DirectClassLoader(APP_JAR, \"CustomLoadee3Child\");\n+        Class<?> unregisteredChild = registeredBaseCl.loadClass(\"CustomLoadee3Child\");\n+        checkClassLoader(unregisteredChild, registeredBaseCl);\n+        checkClassLoader(unregisteredChild.getSuperclass(), ClassLoader.getSystemClassLoader());\n+    }\n+\n+    private static void loadWithUnregisteredSuper() throws Exception {\n+        \/\/ Load registered super\n+        final var systemCl = ClassLoader.getSystemClassLoader();\n+        Class<?> registeredBase = systemCl.loadClass(\"CustomLoadee3\");\n+        checkClassLoader(registeredBase, systemCl);\n+\n+        \/\/ Load unregistered child with UNREGISTERED super\n+        final var unregisteredBaseCl = new DirectClassLoader(APP_JAR, \"CustomLoadee3\", \"CustomLoadee3Child\");\n+        Class<?> unregisteredChild = unregisteredBaseCl.loadClass(\"CustomLoadee3Child\");\n+        checkClassLoader(unregisteredChild, unregisteredBaseCl);\n+        checkClassLoader(unregisteredChild.getSuperclass(), unregisteredBaseCl);\n+    }\n+\n+    private static void checkClassLoader(Class<?> c, ClassLoader cl) {\n+        ClassLoader realCl = c.getClassLoader();\n+        if (realCl != cl) {\n+           throw new RuntimeException(c + \" has wrong loader: expected \" + cl + \", got \" + realCl);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\/RegUnregSuperApp.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"}]}