{"files":[{"patch":"@@ -45,0 +45,1 @@\n+#include \"memory\/oopFactory.hpp\"\n@@ -100,0 +101,6 @@\n+int ClassListParser::parse_classlist(const char* classlist_path, ParseMode parse_mode, TRAPS) {\n+  UnregisteredClasses::initialize(CHECK_0);\n+  ClassListParser parser(classlist_path, parse_mode);\n+  return parser.parse(THREAD); \/\/ returns the number of classes loaded.\n+}\n+\n@@ -393,0 +400,9 @@\n+GrowableArray<InstanceKlass *> ClassListParser::get_specified_interfaces() {\n+  const int n = _interfaces->length();\n+  GrowableArray<InstanceKlass *> specified_interfaces(n);\n+  for (int i = 0; i < n; i++) {\n+    specified_interfaces.append(lookup_class_by_id(_interfaces->at(i)));\n+  }\n+  return specified_interfaces;\n+}\n+\n@@ -452,0 +468,19 @@\n+\/\/ If an unregistered class U is specified to have a registered supertype S1\n+\/\/ named SN but an unregistered class S2 also named SN has already been loaded\n+\/\/ S2 will be incorrectly used as the supertype of U instead of S1 due to\n+\/\/ limitations in the loading mechanism of unregistered classes.\n+void ClassListParser::check_supertype_obstruction(int specified_supertype_id, const InstanceKlass* specified_supertype, TRAPS) {\n+  if (specified_supertype->is_shared_unregistered_class()) {\n+    return; \/\/ Only registered supertypes can be obstructed\n+  }\n+  const InstanceKlass* obstructor = SystemDictionaryShared::get_unregistered_class(specified_supertype->name());\n+  if (obstructor == nullptr) {\n+    return; \/\/ No unregistered types with the same name have been loaded, i.e. no obstruction\n+  }\n+  \/\/ 'specified_supertype' is S1, 'obstructor' is S2 from the explanation above\n+  ResourceMark rm;\n+  THROW_MSG(vmSymbols::java_lang_UnsupportedOperationException(),\n+            err_msg(\"%s (id %d) has super-type %s (id %d) obstructed by another class with the same name\",\n+                    _class_name, _id, specified_supertype->external_name(), specified_supertype_id));\n+}\n+\n@@ -475,1 +510,18 @@\n-  InstanceKlass* k = UnregisteredClasses::load_class(class_name, _source, CHECK_NULL);\n+  ResourceMark rm;\n+  InstanceKlass* specified_super = lookup_class_by_id(_super);\n+  GrowableArray<InstanceKlass*> specified_interfaces = get_specified_interfaces();\n+  \/\/ Obstruction must be checked before the class loading attempt because it may\n+  \/\/ cause class loading errors (JVMS 5.3.5.3-5.3.5.4)\n+  check_supertype_obstruction(_super, specified_super, CHECK_NULL);\n+  for (int i = 0; i < _interfaces->length(); i++) {\n+    check_supertype_obstruction(_interfaces->at(i), specified_interfaces.at(i), CHECK_NULL);\n+  }\n+\n+  const char* source_path = ClassLoader::uri_to_path(_source);\n+  InstanceKlass* k = UnregisteredClasses::load_class(class_name, source_path, CHECK_NULL);\n+\n+  if (k->java_super() != specified_super) {\n+    error(\"The specified super class %s (id %d) does not match actual super class %s\",\n+          specified_super->external_name(), _super,\n+          k->java_super()->external_name());\n+  }\n@@ -482,0 +534,9 @@\n+  for (int i = 0; i < _interfaces->length(); i++) {\n+    InstanceKlass* specified_interface = specified_interfaces.at(i);\n+    if (!k->local_interfaces()->contains(specified_interface)) {\n+      print_specified_interfaces();\n+      print_actual_interfaces(k);\n+      error(\"Specified interface %s (id %d) is not directly implemented\",\n+            specified_interface->external_name(), _interfaces->at(i));\n+      }\n+  }\n@@ -683,43 +744,0 @@\n-\n-\n-InstanceKlass* ClassListParser::lookup_super_for_current_class(Symbol* super_name) {\n-  if (!is_loading_from_source()) {\n-    return nullptr;\n-  }\n-\n-  InstanceKlass* k = lookup_class_by_id(super());\n-  if (super_name != k->name()) {\n-    error(\"The specified super class %s (id %d) does not match actual super class %s\",\n-          k->name()->as_klass_external_name(), super(),\n-          super_name->as_klass_external_name());\n-  }\n-  return k;\n-}\n-\n-InstanceKlass* ClassListParser::lookup_interface_for_current_class(Symbol* interface_name) {\n-  if (!is_loading_from_source()) {\n-    return nullptr;\n-  }\n-\n-  const int n = _interfaces->length();\n-  if (n == 0) {\n-    error(\"Class %s implements the interface %s, but no interface has been specified in the input line\",\n-          _class_name, interface_name->as_klass_external_name());\n-    ShouldNotReachHere();\n-  }\n-\n-  int i;\n-  for (i=0; i<n; i++) {\n-    InstanceKlass* k = lookup_class_by_id(_interfaces->at(i));\n-    if (interface_name == k->name()) {\n-      return k;\n-    }\n-  }\n-\n-  \/\/ interface_name is not specified by the \"interfaces:\" keyword.\n-  print_specified_interfaces();\n-  error(\"The interface %s implemented by class %s does not match any of the specified interface IDs\",\n-        interface_name->as_klass_external_name(), _class_name);\n-  ShouldNotReachHere();\n-  return nullptr;\n-}\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":62,"deletions":44,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,0 +137,2 @@\n+  GrowableArray<InstanceKlass*> get_specified_interfaces();\n+  void check_supertype_obstruction(int specified_supertype_id, const InstanceKlass* specified_supertype, TRAPS);\n@@ -139,4 +141,1 @@\n-  static int parse_classlist(const char* classlist_path, ParseMode parse_mode, TRAPS) {\n-    ClassListParser parser(classlist_path, parse_mode);\n-    return parser.parse(THREAD); \/\/ returns the number of classes loaded.\n-  }\n+  static int parse_classlist(const char* classlist_path, ParseMode parse_mode, TRAPS);\n@@ -195,5 +194,0 @@\n-  \/\/ Look up the super or interface of the current class being loaded\n-  \/\/ (in this->load_current_class()).\n-  InstanceKlass* lookup_super_for_current_class(Symbol* super_name);\n-  InstanceKlass* lookup_interface_for_current_class(Symbol* interface_name);\n-\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -174,0 +174,2 @@\n+    \/\/ NB: the string following \"source: \" is not really a proper file name, but rather\n+    \/\/ a truncated URI referring to a file. It must be decoded after reading.\n","filename":"src\/hotspot\/share\/cds\/classListWriter.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -589,1 +589,1 @@\n-  const char* file = ClassLoader::skip_uri_protocol(location->as_C_string());\n+  const char* file = ClassLoader::uri_to_path(location->as_C_string());\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,4 +27,0 @@\n-#include \"classfile\/classFileStream.hpp\"\n-#include \"classfile\/classLoader.inline.hpp\"\n-#include \"classfile\/classLoaderExt.hpp\"\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -32,1 +28,1 @@\n-#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -34,2 +30,0 @@\n-#include \"memory\/oopFactory.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n@@ -37,0 +31,1 @@\n+#include \"oops\/oopHandle.hpp\"\n@@ -38,0 +33,1 @@\n+#include \"runtime\/handles.hpp\"\n@@ -42,0 +38,28 @@\n+static InstanceKlass* _UnregisteredClassLoader_klass;\n+static InstanceKlass* _UnregisteredClassLoader_Source_klass;\n+static OopHandle _unregistered_class_loader;\n+\n+void UnregisteredClasses::initialize(TRAPS) {\n+  if (_UnregisteredClassLoader_klass != nullptr) {\n+    return;\n+  }\n+\n+  Symbol* klass_name;\n+  Klass* k;\n+\n+  \/\/ no need for synchronization as this function is called single-threaded.\n+  klass_name = SymbolTable::new_symbol(\"jdk\/internal\/misc\/CDS$UnregisteredClassLoader\");\n+  k = SystemDictionary::resolve_or_fail(klass_name, true, CHECK);\n+  _UnregisteredClassLoader_klass = InstanceKlass::cast(k);\n+\n+  klass_name = SymbolTable::new_symbol(\"jdk\/internal\/misc\/CDS$UnregisteredClassLoader$Source\");\n+  k = SystemDictionary::resolve_or_fail(klass_name, true, CHECK);\n+  _UnregisteredClassLoader_Source_klass = InstanceKlass::cast(k);\n+\n+  precond(_unregistered_class_loader.is_empty());\n+  HandleMark hm(THREAD);\n+  const Handle cl = JavaCalls::construct_new_instance(_UnregisteredClassLoader_klass,\n+                                                      vmSymbols::void_method_signature(), CHECK);\n+  _unregistered_class_loader = OopHandle(Universe::vm_global(), cl());\n+}\n+\n@@ -53,2 +77,6 @@\n-  Symbol* path_symbol = SymbolTable::new_symbol(path);\n-  Handle url_classloader = get_url_classloader(path_symbol, CHECK_NULL);\n+  assert(!_unregistered_class_loader.is_empty(), \"not initialized\");\n+  Handle classloader(THREAD, _unregistered_class_loader.resolve());\n+\n+  \/\/ Call CDS$UnregisteredClassLoader::load(String name, String source)\n+  Symbol* methodName = SymbolTable::new_symbol(\"load\");\n+  Symbol* methodSignature = SymbolTable::new_symbol(\"(Ljava\/lang\/String;Ljava\/lang\/String;)Ljava\/lang\/Class;\");\n@@ -56,0 +84,1 @@\n+  Handle path_string = java_lang_String::create_from_str(path, CHECK_NULL);\n@@ -58,4 +87,0 @@\n-  JavaCallArguments args(2);\n-  args.set_receiver(url_classloader);\n-  args.push_oop(ext_class_name);\n-  args.push_int(JNI_FALSE);\n@@ -63,4 +88,6 @@\n-                          vmClasses::URLClassLoader_klass(),\n-                          vmSymbols::loadClass_name(),\n-                          vmSymbols::string_boolean_class_signature(),\n-                          &args,\n+                          classloader,\n+                          _UnregisteredClassLoader_klass,\n+                          methodName,\n+                          methodSignature,\n+                          ext_class_name,\n+                          path_string,\n@@ -69,24 +96,0 @@\n-  oop obj = result.get_oop();\n-  return InstanceKlass::cast(java_lang_Class::as_Klass(obj));\n-}\n-\n-class URLClassLoaderTable : public ResourceHashtable<\n-  Symbol*, OopHandle,\n-  137, \/\/ prime number\n-  AnyObj::C_HEAP> {};\n-\n-static URLClassLoaderTable* _url_classloader_table = nullptr;\n-\n-Handle UnregisteredClasses::create_url_classloader(Symbol* path, TRAPS) {\n-  ResourceMark rm(THREAD);\n-  JavaValue result(T_OBJECT);\n-  Handle path_string = java_lang_String::create_from_str(path->as_C_string(), CHECK_NH);\n-  JavaCalls::call_static(&result,\n-                         vmClasses::jdk_internal_loader_ClassLoaders_klass(),\n-                         vmSymbols::toFileURL_name(),\n-                         vmSymbols::toFileURL_signature(),\n-                         path_string, CHECK_NH);\n-  assert(result.get_type() == T_OBJECT, \"just checking\");\n-  oop url_h = result.get_oop();\n-  objArrayHandle urls = oopFactory::new_objArray_handle(vmClasses::URL_klass(), 1, CHECK_NH);\n-  urls->obj_at_put(0, url_h);\n@@ -94,5 +97,1 @@\n-  Handle url_classloader = JavaCalls::construct_new_instance(\n-                             vmClasses::URLClassLoader_klass(),\n-                             vmSymbols::url_array_classloader_void_signature(),\n-                             urls, Handle(), CHECK_NH);\n-  return url_classloader;\n+  return InstanceKlass::cast(java_lang_Class::as_Klass(result.get_oop()));\n@@ -101,12 +100,3 @@\n-Handle UnregisteredClasses::get_url_classloader(Symbol* path, TRAPS) {\n-  if (_url_classloader_table == nullptr) {\n-    _url_classloader_table = new (mtClass)URLClassLoaderTable();\n-  }\n-  OopHandle* url_classloader_ptr = _url_classloader_table->get(path);\n-  if (url_classloader_ptr != nullptr) {\n-    return Handle(THREAD, (*url_classloader_ptr).resolve());\n-  } else {\n-    Handle url_classloader = create_url_classloader(path, CHECK_NH);\n-    _url_classloader_table->put(path, OopHandle(Universe::vm_global(), url_classloader()));\n-    path->increment_refcount();\n-    return url_classloader;\n+bool UnregisteredClasses::check_for_exclusion(const InstanceKlass* k) {\n+  if (_UnregisteredClassLoader_klass == nullptr) {\n+    return false; \/\/ Uninitialized\n@@ -114,0 +104,2 @@\n+  return k == _UnregisteredClassLoader_klass ||\n+         k->implements_interface(_UnregisteredClassLoader_Source_klass);\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.cpp","additions":50,"deletions":58,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"memory\/allStatic.hpp\"\n@@ -30,0 +31,3 @@\n+class InstanceKlass;\n+class Symbol;\n+\n@@ -32,5 +36,4 @@\n-  static InstanceKlass* load_class(Symbol* h_name, const char* path, TRAPS);\n-\n-private:\n-  static Handle create_url_classloader(Symbol* path, TRAPS);\n-  static Handle get_url_classloader(Symbol* path, TRAPS);\n+  static InstanceKlass* load_class(Symbol* name, const char* path, TRAPS);\n+  static void initialize(TRAPS);\n+  \/\/ Returns true if the class is loaded internally for dumping unregistered classes.\n+  static bool check_for_exclusion(const InstanceKlass* k);\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -81,0 +81,3 @@\n+#include <stdlib.h>\n+#include <ctype.h>\n+\n@@ -1227,1 +1230,1 @@\n-char* ClassLoader::skip_uri_protocol(char* source) {\n+static const char* skip_uri_protocol(const char* source) {\n@@ -1246,0 +1249,41 @@\n+static char decode_percent_encoded(const char *str, size_t& index) {\n+  if (str[index] == '%'\n+      && isxdigit(str[index + 1])\n+      && isxdigit(str[index + 2])) {\n+    char hex[3];\n+    hex[0] = str[index + 1];\n+    hex[1] = str[index + 2];\n+    hex[2] = '\\0';\n+    index += 2;\n+    return (char) strtol(hex, NULL, 16);\n+  }\n+  return str[index];\n+}\n+\n+char* ClassLoader::uri_to_path(const char* uri) {\n+  const size_t len = strlen(uri) + 1;\n+  char* path = NEW_RESOURCE_ARRAY(char, len);\n+\n+  uri = skip_uri_protocol(uri);\n+\n+  if (strncmp(uri, \"\/\/\", 2) == 0) {\n+    \/\/ Skip the empty \"authority\" part\n+    uri += 2;\n+  }\n+\n+#ifdef _WINDOWS\n+  if (uri[0] == '\/') {\n+    \/\/ Absolute path name on Windows does not begin with a slash\n+    uri += 1;\n+  }\n+#endif\n+\n+  size_t path_index = 0;\n+  for (size_t i = 0; i < strlen(uri); ++i) {\n+    char decoded = decode_percent_encoded(uri, i);\n+    path[path_index++] = decoded;\n+  }\n+  path[path_index] = '\\0';\n+  return path;\n+}\n+\n@@ -1279,1 +1323,1 @@\n-    char* path = skip_uri_protocol(src);\n+    const char* path = ClassLoader::uri_to_path(src);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":46,"deletions":2,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -373,1 +373,1 @@\n-  static char* skip_uri_protocol(char* source);\n+  static char* uri_to_path(const char* uri);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,6 +101,4 @@\n-      char* path = m->location()->as_C_string();\n-      if (strncmp(path, \"file:\", 5) == 0) {\n-        path = ClassLoader::skip_uri_protocol(path);\n-        char* path_copy = NEW_RESOURCE_ARRAY(char, strlen(path) + 1);\n-        strcpy(path_copy, path);\n-        _module_paths->append(path_copy);\n+      char* uri = m->location()->as_C_string();\n+      if (strncmp(uri, \"file:\", 5) == 0) {\n+        char* path = ClassLoader::uri_to_path(uri);\n+        _module_paths->append(path);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -415,10 +415,0 @@\n-#if INCLUDE_CDS\n-  if (DumpSharedSpaces) {\n-    \/\/ Special processing for handling UNREGISTERED shared classes.\n-    InstanceKlass* k = SystemDictionaryShared::lookup_super_for_unregistered_class(class_name,\n-                           super_name, is_superclass);\n-    if (k) {\n-      return k;\n-    }\n-  }\n-#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"cds\/unregisteredClasses.hpp\"\n@@ -316,0 +317,6 @@\n+  if (UnregisteredClasses::check_for_exclusion(k)) {\n+    ResourceMark rm;\n+    log_info(cds)(\"Skipping %s: used only when dumping CDS archive\", k->name()->as_C_string());\n+    return true;\n+  }\n+\n@@ -452,35 +459,3 @@\n-\/\/ This function is called to lookup the super\/interfaces of shared classes for\n-\/\/ unregistered loaders. E.g., SharedClass in the below example\n-\/\/ where \"super:\" (and optionally \"interface:\") have been specified.\n-\/\/\n-\/\/ java\/lang\/Object id: 0\n-\/\/ Interface    id: 2 super: 0 source: cust.jar\n-\/\/ SharedClass  id: 4 super: 0 interfaces: 2 source: cust.jar\n-InstanceKlass* SystemDictionaryShared::lookup_super_for_unregistered_class(\n-    Symbol* class_name, Symbol* super_name, bool is_superclass) {\n-\n-  assert(DumpSharedSpaces, \"only when static dumping\");\n-\n-  if (!ClassListParser::is_parsing_thread()) {\n-    \/\/ Unregistered classes can be created only by ClassListParser::_parsing_thread.\n-\n-    return nullptr;\n-  }\n-\n-  ClassListParser* parser = ClassListParser::instance();\n-  if (parser == nullptr) {\n-    \/\/ We're still loading the well-known classes, before the ClassListParser is created.\n-    return nullptr;\n-  }\n-  if (class_name->equals(parser->current_class_name())) {\n-    \/\/ When this function is called, all the numbered super and interface types\n-    \/\/ must have already been loaded. Hence this function is never recursively called.\n-    if (is_superclass) {\n-      return parser->lookup_super_for_current_class(super_name);\n-    } else {\n-      return parser->lookup_interface_for_current_class(super_name);\n-    }\n-  } else {\n-    \/\/ The VM is not trying to resolve a super type of parser->current_class_name().\n-    \/\/ Instead, it's resolving an error class (because parser->current_class_name() has\n-    \/\/ failed parsing or verification). Don't do anything here.\n+InstanceKlass* SystemDictionaryShared::get_unregistered_class(Symbol* name) {\n+  assert(Arguments::is_dumping_archive() || ClassListWriter::is_enabled(), \"sanity\");\n+  if (_unregistered_classes_table == nullptr) {\n@@ -489,0 +464,2 @@\n+  InstanceKlass** k = _unregistered_classes_table->get(name);\n+  return k != nullptr ? *k : nullptr;\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":12,"deletions":35,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -290,0 +290,1 @@\n+  static InstanceKlass* get_unregistered_class(Symbol* name);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,1 +147,0 @@\n-  do_klass(URLClassLoader_klass,                        java_net_URLClassLoader                               ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -130,1 +130,0 @@\n-  template(java_net_URLClassLoader,                   \"java\/net\/URLClassLoader\")                  \\\n@@ -791,1 +790,0 @@\n-  template(url_array_classloader_void_signature,            \"([Ljava\/net\/URL;Ljava\/lang\/ClassLoader;)V\")          \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -36,0 +38,1 @@\n+import java.util.HashMap;\n@@ -39,0 +42,1 @@\n+import java.util.jar.JarFile;\n@@ -336,0 +340,114 @@\n+\n+    \/**\n+     * This class is used only by native JVM code at CDS dump time for loading\n+     * \"unregistered classes\", which are archived classes that are intended to\n+     * be loaded by custom class loaders during runtime.\n+     * See src\/hotspot\/share\/cds\/unregisteredClasses.cpp.\n+     *\/\n+    private static class UnregisteredClassLoader extends ClassLoader {\n+        static {\n+            registerAsParallelCapable();\n+        }\n+\n+        static interface Source {\n+            public byte[] readClassFile(String className) throws IOException;\n+        }\n+\n+        static class JarSource implements Source {\n+            private final JarFile jar;\n+\n+            JarSource(File file) throws IOException {\n+                jar = new JarFile(file);\n+            }\n+\n+            @Override\n+            public byte[] readClassFile(String className) throws IOException {\n+                final var entryName = className.replace('.', '\/').concat(\".class\");\n+                final var entry = jar.getEntry(entryName);\n+                if (entry == null) {\n+                    throw new IOException(\"No such entry: \" + entryName + \" in \" + jar.getName());\n+                }\n+                try (final var in = jar.getInputStream(entry)) {\n+                    return in.readAllBytes();\n+                }\n+            }\n+        }\n+\n+        static class DirSource implements Source {\n+            private final String basePath;\n+\n+            DirSource(File dir) {\n+                assert dir.isDirectory();\n+                basePath = dir.toString();\n+            }\n+\n+            @Override\n+            public byte[] readClassFile(String className) throws IOException {\n+                final var subPath = className.replace('.', File.separatorChar).concat(\".class\");\n+                final var fullPath = Path.of(basePath, subPath);\n+                return Files.readAllBytes(fullPath);\n+            }\n+        }\n+\n+        private final HashMap<String, Source> sources = new HashMap<>();\n+\n+        private Source resolveSource(String path) throws IOException {\n+            Source source = sources.get(path);\n+            if (source != null) {\n+                return source;\n+            }\n+\n+            final var file = new File(path);\n+            if (!file.exists()) {\n+                throw new IOException(\"No such file: \" + path);\n+            }\n+            if (file.isFile()) {\n+                source = new JarSource(file);\n+            } else if (file.isDirectory()) {\n+                source = new DirSource(file);\n+            } else {\n+                throw new IOException(\"Not a normal file: \" + path);\n+            }\n+            sources.put(path, source);\n+\n+            return source;\n+        }\n+\n+        \/**\n+         * Load the class of the given <code>name<\/code> from the given <code>source<\/code>.\n+         * <p>\n+         * All super classes and interfaces of the named class must have already been loaded:\n+         * either defined by this class loader (unregistered ones) or loaded, possibly indirectly,\n+         * by the system class loader (registered ones).\n+         * <p>\n+         * If the named class has a registered super class or interface named N there should be no\n+         * unregistered class or interface named N loaded yet.\n+         *\n+         * @param name the name of the class to be loaded.\n+         * @param source path to a directory or a JAR file from which the named class should be\n+         *               loaded.\n+         *\/\n+        private Class<?> load(String name, String source) throws IOException {\n+            final Source resolvedSource = resolveSource(source);\n+            final byte[] bytes = resolvedSource.readClassFile(name);\n+            \/\/ 'defineClass()' may cause loading of supertypes of this unregistered class by VM\n+            \/\/ calling 'this.loadClass()'.\n+            \/\/\n+            \/\/ For any supertype S named SN specified in the classlist the following is ensured by\n+            \/\/ the CDS implementation:\n+            \/\/ - if S is an unregistered class it must have already been defined by this class\n+            \/\/   loader and thus will be found by 'this.findLoadedClass(SN)',\n+            \/\/ - if S is not an unregistered class there should be no unregistered class named SN\n+            \/\/   loaded yet so either S has previously been (indirectly) loaded by this class loader\n+            \/\/   and thus it will be found when calling 'this.findLoadedClass(SN)' or it will be\n+            \/\/   found when delegating to the system class loader, which must have already loaded S,\n+            \/\/   by calling 'this.getParent().loadClass(SN, false)'.\n+            \/\/ See the implementation of 'ClassLoader.loadClass()' for details.\n+            \/\/\n+            \/\/ Therefore, we should resolve all supertypes to the expected ones as specified by the\n+            \/\/ \"super:\" and \"interfaces:\" attributes in the classlist. This invariant is validated\n+            \/\/ by the C++ function 'ClassListParser::load_class_from_source()'.\n+            assert getParent() == getSystemClassLoader();\n+            return defineClass(name, bytes, 0, bytes.length);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":119,"deletions":1,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -442,0 +442,1 @@\n+ -runtime\/cds\/appcds\/complexURI \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,167 @@\n+\/* Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verifies that CDS works with jar located in directories\n+ *          with names that need escaping\n+ * @bug 8339460\n+ * @requires vm.cds\n+ * @requires vm.cds.custom.loaders\n+ * @requires vm.flagless\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile mypackage\/Main.java mypackage\/Another.java\n+ * @run main\/othervm ComplexURITest\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.Platform;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class ComplexURITest {\n+    final static String moduleName = \"mymodule\";\n+\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"test.noclasspath\", \"true\");\n+        String jarFile = JarBuilder.build(moduleName, \"mypackage\/Main\", \"mypackage\/Another\");\n+\n+        Path subDir = Path.of(\".\", \"dir with space\");\n+        Files.createDirectory(subDir);\n+        Path newJarFilePath = subDir.resolve(moduleName + \".jar\");\n+        Files.move(Path.of(jarFile), newJarFilePath);\n+        jarFile = newJarFilePath.toString();\n+\n+        final String listFileName = \"test-classlist.txt\";\n+        final String staticArchiveName = \"test-static.jsa\";\n+        final String dynamicArchiveName = \"test-dynamic.jsa\";\n+\n+        \/\/ Verify static archive creation and use\n+        File fileList = new File(listFileName);\n+        delete(fileList.toPath());\n+        File staticArchive = new File(staticArchiveName);\n+        delete(staticArchive.toPath());\n+\n+        createClassList(jarFile, listFileName);\n+        if (!fileList.exists()) {\n+            throw new RuntimeException(\"No class list created at \" + fileList);\n+        }\n+\n+        createArchive(jarFile, listFileName, staticArchiveName);\n+        if (!staticArchive.exists()) {\n+            throw new RuntimeException(\"No shared classes archive created at \" + staticArchive);\n+        }\n+\n+        useArchive(jarFile, staticArchiveName);\n+\n+        \/\/ Verify dynamic archive creation and use\n+        File dynamicArchive = new File(dynamicArchiveName);\n+        delete(dynamicArchive.toPath());\n+\n+        createDynamicArchive(jarFile, dynamicArchiveName);\n+        if (!dynamicArchive.exists()) {\n+            throw new RuntimeException(\"No dynamic archive created at \" + dynamicArchive);\n+        }\n+\n+        testDynamicArchive(jarFile, dynamicArchiveName);\n+    }\n+\n+    private static void delete(Path path) throws Exception {\n+        if (Files.exists(path)) {\n+            if (Platform.isWindows()) {\n+                Files.setAttribute(path, \"dos:readonly\", false);\n+            }\n+            Files.delete(path);\n+        }\n+    }\n+\n+    private static void createClassList(String jarFile, String list) throws Exception {\n+        String[] launchArgs  = {\n+                \"-XX:DumpLoadedClassList=\" + list,\n+                \"--module-path\",\n+                jarFile,\n+                \"--module\",\n+                moduleName + \"\/mypackage.Main\"};\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(launchArgs);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"create-list\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    private static void createArchive(String jarFile, String list, String archive) throws Exception {\n+        String[] launchArgs  = {\n+                \"-Xshare:dump\",\n+                \"-XX:SharedClassListFile=\" + list,\n+                \"-XX:SharedArchiveFile=\" + archive,\n+                \"--module-path\",\n+                jarFile,\n+                \"--module\",\n+                moduleName + \"\/mypackage.Main\"};\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(launchArgs);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dump-archive\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    private static void useArchive(String jarFile, String archive) throws Exception {\n+        String[] launchArgs  = {\n+                \"-Xshare:on\",\n+                \"-XX:SharedArchiveFile=\" + archive,\n+                \"--module-path\",\n+                jarFile,\n+                \"--module\",\n+                moduleName + \"\/mypackage.Main\"};\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(launchArgs);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"use-archive\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    private static void createDynamicArchive(String jarFile, String archive) throws Exception {\n+        String[] launchArgs  = {\n+                \"-XX:ArchiveClassesAtExit=\" + archive,\n+                \"--module-path\",\n+                jarFile,\n+                \"--module\",\n+                moduleName + \"\/mypackage.Main\"};\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(launchArgs);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dynamic-archive\");\n+        output.shouldHaveExitValue(0);\n+    }\n+\n+    private static void testDynamicArchive(String jarFile, String archive) throws Exception {\n+        String[] launchArgs  = {\n+                \"-XX:SharedArchiveFile=\" + archive,\n+                \"-XX:+PrintSharedArchiveAndExit\",\n+                \"--module-path\",\n+                jarFile,\n+                \"--module\",\n+                moduleName + \"\/mypackage.Main\"};\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(launchArgs);\n+        OutputAnalyzer output = TestCommon.executeAndLog(pb, \"dynamic-archive\");\n+        output.shouldHaveExitValue(0);\n+        output.shouldContain(\"archive is valid\");\n+        output.shouldContain(\": mypackage.Main app_loader\");\n+        output.shouldContain(\": mypackage.Another unregistered_loader\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/complexURI\/ComplexURITest.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/* Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package mypackage;\n+\n+public class Another {\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/complexURI\/mypackage\/Another.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/* Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package mypackage;\n+\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+\n+public class Main {\n+    public static void main(String[] args) throws Exception {\n+        URL url1 = Main.class.getProtectionDomain().getCodeSource().getLocation();\n+        System.out.println(\"Will load Another from \" + url1);\n+        ClassLoader cl = URLClassLoader.newInstance(new URL[] { url1 }, null);\n+        var anotherClass = cl.loadClass(\"mypackage.Another\");\n+        System.out.println(\"Class \" + anotherClass + \" loaded successfully\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/complexURI\/mypackage\/Main.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-        dumpShouldFail(\n+        dumpShouldPass(\n@@ -59,1 +59,2 @@\n-            \"Class CustomLoadee2 implements the interface CustomInterface2_ia, but no interface has been specified in the input line\");\n+            \"java.lang.NoClassDefFoundError: CustomInterface2_ia\",\n+            \"Cannot find CustomLoadee2\");\n@@ -70,1 +71,1 @@\n-            \"The interface CustomInterface2_ib implemented by class CustomLoadee2 does not match any of the specified interface IDs\");\n+            \"The number of interfaces (1) specified in class list does not match the class file (2)\");\n@@ -104,0 +105,10 @@\n+\n+        dumpShouldPass(\n+            \"TESTCASE E6: JAR file doesn't exist\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"java\/lang\/Object id: 1\",\n+                \"NoSuchClass id: 2 super: 1 source: no_such_file.jar\"\n+            ),\n+            \"Cannot find NoSuchClass\",\n+            \"java.io.IOException: No such file: no_such_file.jar\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/ClassListFormatE.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test\n+ * @bug 8315130\n+ * @summary Tests archiving a hierarchy of package-private classes loaded from\n+ * different sources.\n+ *\n+ * @requires vm.cds\n+ * @requires vm.cds.custom.loaders\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile test-classes\/DifferentSourcesApp.java test-classes\/CustomLoadee5.java test-classes\/CustomLoadee5Child.java\n+ * @run main DifferentSourcesTest\n+ *\/\n+public class DifferentSourcesTest {\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Setup:\n+        \/\/ - CustomLoadee5 is package-private\n+        \/\/ - CustomLoadee5Child extends CustomLoadee5\n+        \/\/\n+        \/\/ This setup requires CustomLoadee5 and CustomLoadee5Child to be in the\n+        \/\/ same run-time package. Since their package name is the same (empty)\n+        \/\/ this boils down to \"be loaded by the same class loader\".\n+        \/\/\n+        \/\/ DifferentSourcesApp adheres to this requirement.\n+        \/\/\n+        \/\/ This test checks that CDS adheres to this requirement too when\n+        \/\/ creating a static app archive, even if CustomLoadee5 and\n+        \/\/ CustomLoadee5Child are in different sources.\n+\n+        OutputAnalyzer output;\n+\n+        \/\/ The main check: the archive is created without IllegalAccessError\n+        JarBuilder.build(\"base\", \"CustomLoadee5\");\n+        JarBuilder.build(\"sub\", \"CustomLoadee5Child\");\n+        final String classlist[] = new String[] {\n+            \"java\/lang\/Object id: 0\",\n+            \"CustomLoadee5 id: 1 super: 0 source: base.jar\",\n+            \"CustomLoadee5Child id: 2 super: 1 source: sub.jar\",\n+        };\n+        output = TestCommon.testDump(null, classlist);\n+        output.shouldNotContain(\"java.lang.IllegalAccessError: class CustomLoadee5Child cannot access its superclass CustomLoadee5\");\n+        output.shouldNotContain(\"Cannot find CustomLoadee5Child\");\n+\n+        \/\/ Sanity check: the archive is used as expected\n+        output = TestCommon.execCommon(\"-Xlog:class+load\", \"DifferentSourcesApp\");\n+        TestCommon.checkExec(\n+            output,\n+            \"CustomLoadee5 source: shared objects file\",\n+            \"CustomLoadee5Child source: shared objects file\"\n+        );\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/DifferentSourcesTest.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/**\n+ * @test id=unreg\n+ * @summary Tests that if a super class is listed as unregistered it is archived\n+ * as such even if a class with the same name has also been loaded from the\n+ * classpath.\n+ *\n+ * @requires vm.cds\n+ * @requires vm.cds.custom.loaders\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile test-classes\/RegUnregSuperApp.java test-classes\/CustomLoadee3.java test-classes\/CustomLoadee3Child.java\n+ * @run main RegUnregSuperTest unreg\n+ *\/\n+\n+\/**\n+ * @test id=reg\n+ * @summary If an unregistered class U is specified to have a registered\n+ * supertype S1 named SN but an unregistered class S2 also named SN has already\n+ * been loaded S2 will be incorrectly used as the supertype of U instead of S1\n+ * due to limitations in the loading mechanism of unregistered classes. For this\n+ * reason U should not be loaded at all and an appropriate warning should be\n+ * printed.\n+ *\n+ * @requires vm.cds\n+ * @requires vm.cds.custom.loaders\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile test-classes\/RegUnregSuperApp.java test-classes\/CustomLoadee3.java test-classes\/CustomLoadee3Child.java\n+ * @run main RegUnregSuperTest reg\n+ *\/\n+\n+public class RegUnregSuperTest {\n+    public static void main(String[] args) throws Exception {\n+        final String variant = args[0];\n+\n+        final String appJar = JarBuilder.build(\n+            \"app\", \"RegUnregSuperApp\", \"DirectClassLoader\", \"CustomLoadee3\", \"CustomLoadee3Child\"\n+        );\n+        OutputAnalyzer out;\n+\n+        final String classlist[] = new String[] {\n+            \"java\/lang\/Object id: 0\",\n+            \"CustomLoadee3 id: 1\",\n+            \"CustomLoadee3 id: 2 super: 0 source: \" + appJar,\n+            \"CustomLoadee3Child id: 3 super: \" + (\"reg\".equals(variant) ? \"1\" : \"2\") + \" source: \" + appJar\n+        };\n+        out = TestCommon.testDump(appJar, classlist, \"-Xlog:cds+class=debug\");\n+        out.shouldContain(\"app   CustomLoadee3\"); \/\/ Not using \\n as below because it'll be \"app   CustomLoadee3 aot-linked\" with AOTClassLinking\n+        out.shouldNotContain(\"app   CustomLoadee3Child\");\n+        out.shouldContain(\"unreg CustomLoadee3\\n\"); \/\/ Accepts \"unreg CustomLoadee3\" but not \"unreg CustomLoadee3Child\"\n+        if (\"reg\".equals(variant)) {\n+            out.shouldNotContain(\"unreg CustomLoadee3Child\");\n+            out.shouldContain(\"CustomLoadee3Child (id 3) has super-type CustomLoadee3 (id 1) obstructed by another class with the same name\");\n+        } else {\n+            out.shouldContain(\"unreg CustomLoadee3Child\");\n+            out.shouldNotContain(\"[warning]\");\n+        }\n+\n+        out = TestCommon.exec(appJar, \"-Xlog:class+load\", \"RegUnregSuperApp\", variant);\n+        TestCommon.checkExec(\n+            out,\n+            \"CustomLoadee3Child source: \" + (\"reg\".equals(variant) ? \"file:\" : \"shared objects file\")\n+        );\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/RegUnregSuperTest.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class CustomLoadee5 {\n+    public String toString() {\n+        return \"this is CustomLoadee5\";\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\/CustomLoadee5.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class CustomLoadee5Child extends CustomLoadee5 {\n+    public String toString() {\n+        return \"this is CustomLoadee5Child\";\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\/CustomLoadee5Child.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.nio.file.FileSystems;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+\n+\/**\n+ * See ..\/DifferentSourcesTest.java for details.\n+ *\/\n+public class DifferentSourcesApp {\n+    public static void main(String args[]) throws Exception {\n+        Path base = FileSystems.getDefault().getPath(\"base.jar\");\n+        Path sub = FileSystems.getDefault().getPath(\"sub.jar\");\n+        URL[] urls = new URL[] { base.toUri().toURL(), sub.toUri().toURL() };\n+        URLClassLoader cl = new URLClassLoader(urls, \/* parent = *\/ null);\n+        Class<?> cls = cl.loadClass(\"CustomLoadee5Child\");\n+        System.out.println(cls.getName());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\/DifferentSourcesApp.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.FileSystems;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.Set;\n+\n+class DirectClassLoader extends URLClassLoader {\n+    private final Set<String> directlyLoadedNames;\n+\n+    public DirectClassLoader(URL url, String... directlyLoadedNames) {\n+        super(new URL[] { url });\n+        this.directlyLoadedNames = Set.of(directlyLoadedNames);\n+    }\n+\n+    @Override\n+    public Class<?> loadClass(String name) throws ClassNotFoundException {\n+        synchronized (getClassLoadingLock(name)) {\n+            Class<?> c = findLoadedClass(name);\n+            if (c == null) {\n+                if (directlyLoadedNames.contains(name)) {\n+                    c = findClass(name);\n+                } else {\n+                    c = super.loadClass(name);\n+                }\n+            }\n+            return c;\n+        }\n+    }\n+}\n+\n+\/**\n+ * See ..\/RegUnregSuperTest.java for details.\n+ *\/\n+public class RegUnregSuperApp {\n+    private static final URL APP_JAR;\n+    static {\n+        final URL appJar;\n+        try {\n+            appJar = FileSystems.getDefault().getPath(\"app.jar\").toUri().toURL();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+        APP_JAR = appJar;\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        switch (args[0]) {\n+            case \"reg\" -> loadWithRegisteredSuper();\n+            case \"unreg\" -> loadWithUnregisteredSuper();\n+            default -> throw new IllegalArgumentException(\"Unknown variant: \" + args[0]);\n+        }\n+    }\n+\n+    private static void loadWithRegisteredSuper() throws Exception {\n+        \/\/ Load unregistered super\n+        final var unregisteredBaseCl = new DirectClassLoader(APP_JAR, \"CustomLoadee3\");\n+        Class<?> unregisteredBase = unregisteredBaseCl.loadClass(\"CustomLoadee3\");\n+        checkClassLoader(unregisteredBase, unregisteredBaseCl);\n+\n+        \/\/ Load unregistered child with REGISTERED super\n+        final var registeredBaseCl = new DirectClassLoader(APP_JAR, \"CustomLoadee3Child\");\n+        Class<?> unregisteredChild = registeredBaseCl.loadClass(\"CustomLoadee3Child\");\n+        checkClassLoader(unregisteredChild, registeredBaseCl);\n+        checkClassLoader(unregisteredChild.getSuperclass(), ClassLoader.getSystemClassLoader());\n+    }\n+\n+    private static void loadWithUnregisteredSuper() throws Exception {\n+        \/\/ Load registered super\n+        final var systemCl = ClassLoader.getSystemClassLoader();\n+        Class<?> registeredBase = systemCl.loadClass(\"CustomLoadee3\");\n+        checkClassLoader(registeredBase, systemCl);\n+\n+        \/\/ Load unregistered child with UNREGISTERED super\n+        final var unregisteredBaseCl = new DirectClassLoader(APP_JAR, \"CustomLoadee3\", \"CustomLoadee3Child\");\n+        Class<?> unregisteredChild = unregisteredBaseCl.loadClass(\"CustomLoadee3Child\");\n+        checkClassLoader(unregisteredChild, unregisteredBaseCl);\n+        checkClassLoader(unregisteredChild.getSuperclass(), unregisteredBaseCl);\n+    }\n+\n+    private static void checkClassLoader(Class<?> c, ClassLoader cl) {\n+        ClassLoader realCl = c.getClassLoader();\n+        if (realCl != cl) {\n+           throw new RuntimeException(c + \" has wrong loader: expected \" + cl + \", got \" + realCl);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\/RegUnregSuperApp.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"}]}