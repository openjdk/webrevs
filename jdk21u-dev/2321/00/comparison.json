{"files":[{"patch":"@@ -263,0 +263,4 @@\n+java\/awt\/Clipboard\/ClipboardSecurity.java 8054809 macosx-all\n+java\/awt\/Clipboard\/GetAltContentsTest\/SystemClipboardTest.java 8234140 macosx-all\n+java\/awt\/Clipboard\/ImageTransferTest.java 8030710 generic-all\n+java\/awt\/Clipboard\/NoDataConversionFailureTest.java 8234140 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4274061\n+ * @summary Tests that Transferable.getTransferData() and\n+ *          SelectionOwner.lostOwnership is not called on Toolkit thread.\n+ * @key headful\n+ * @library \/test\/lib\n+ * @run main ClipboardSecurity\n+ *\/\n+\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.ClipboardOwner;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class ClipboardSecurity {\n+    static Clipboard clip = null;\n+    public static final CountDownLatch latch = new CountDownLatch(1);\n+    public static volatile boolean hasError = false;\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            ClipboardSecurity clipboardSecurity = new ClipboardSecurity();\n+            clipboardSecurity.start();\n+            return;\n+        }\n+\n+        try {\n+            clip = Toolkit.getDefaultToolkit().getSystemClipboard();\n+            if ( clip == null ) {\n+                throw (new RuntimeException(\"Clipboard is null\"));\n+            }\n+            Transferable data = clip.getContents(null);\n+            if ( data == null ) {\n+                throw (new RuntimeException(\"Data is null\"));\n+            }\n+            System.out.println(\"Clipboard contents: \" + data);\n+            \/\/ First check - getTransferData\n+            try {\n+                String contData =\n+                        (String) data.getTransferData(DataFlavor.stringFlavor);\n+            } catch (UnsupportedFlavorException | IOException exc) {\n+                throw(new RuntimeException(\"Couldn't get transfer data - \"\n+                        + exc.getMessage()));\n+            }\n+            \/\/ Second check - lostOwnership\n+            MyClass clipData = new MyClass(\"clipbard test data\");\n+            clip.setContents(clipData, clipData);\n+            System.out.println(\"exit 0\");\n+            System.exit(0);\n+        } catch (RuntimeException exc) {\n+            System.err.println(exc.getMessage());\n+            System.out.println(\"exit 2\");\n+            System.exit(2);\n+        }\n+    }\n+\n+    public void start() throws Exception {\n+        clip = Toolkit.getDefaultToolkit().getSystemClipboard();\n+        if (clip == null) {\n+            throw (new RuntimeException(\"Clipboard is null\"));\n+        }\n+        MyClass clipData = new MyClass(\"clipboard test data\");\n+        clip.setContents(clipData, clipData);\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                ClipboardSecurity.class.getName(),\n+                \"child\"\n+        );\n+\n+        Process process = ProcessTools.startProcess(\"Child\", pb);\n+        OutputAnalyzer outputAnalyzer = new OutputAnalyzer(process);\n+\n+        if (!process.waitFor(15, TimeUnit.SECONDS)) {\n+            process.destroyForcibly();\n+            throw new TimeoutException(\"Timed out waiting for Child\");\n+        }\n+        System.out.println(\"WAIT COMPLETE\");\n+\n+        outputAnalyzer.shouldHaveExitValue(0);\n+\n+        if (!latch.await(10, TimeUnit.SECONDS)) {\n+            throw new RuntimeException(\"timed out\");\n+        }\n+\n+        if (hasError) {\n+            throw new RuntimeException(\"Detected call on Toolkit thread\");\n+        }\n+\n+        System.out.println(\"Passed.\");\n+    }\n+}\n+\n+class MyClass extends StringSelection implements ClipboardOwner {\n+    MyClass(String title) {\n+        super(title);\n+    }\n+\n+    private void checkIsCorrectThread(String reason) {\n+        System.out.println(\"Checking \" + reason + \" for thread \"\n+                + Thread.currentThread().getName());\n+        String name = Thread.currentThread().getName();\n+        if (name.equals(\"AWT-Windows\") || name.equals(\"AWT-Motif\")) {\n+            ClipboardSecurity.hasError = true;\n+            System.err.println(reason + \" is called on Toolkit thread!\");\n+        }\n+    }\n+\n+    public void lostOwnership(Clipboard clip, Transferable cont) {\n+        checkIsCorrectThread(\"lostOwnership\");\n+        ClipboardSecurity.latch.countDown();\n+        System.out.println(\"lost ownership on \"\n+                + Thread.currentThread().getName() + \" thread\");\n+    }\n+\n+    public Object getTransferData(DataFlavor flav)\n+            throws UnsupportedFlavorException, IOException {\n+        System.out.println(\"getTransferData on \"\n+                + Thread.currentThread().getName() + \" thread\");\n+        checkIsCorrectThread(\"getTransferData\");\n+        return super.getTransferData(flav);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Clipboard\/ClipboardSecurity.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4287795 4790833\n+ * @summary tests new Clipboard methods: getAvailableDataFlavors,\n+ *          isDataFlavorAvailable, getData\n+ * @key headful\n+ * @library \/test\/lib\n+ * @run main SystemClipboardTest\n+ *\/\n+\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.ClipboardOwner;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\n+public class SystemClipboardTest {\n+\n+    private static final Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n+\n+    private static final String contentsText = \"contents text\";\n+\n+    public void start() throws Exception {\n+        Util.setClipboardContents(clipboard, new StringSelection(contentsText), new ClipboardOwner() {\n+                public void lostOwnership(Clipboard clpbrd, Transferable cntnts) {\n+                    check(); \/\/ clipboard data retrieved from the system clipboard\n+                    Util.setClipboardContents(clipboard, new StringSelection(contentsText), null);\n+                }\n+            });\n+\n+        check(); \/\/ JVM-local clipboard data\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                SystemClipboardTest.class.getName(),\n+                \"child\"\n+        );\n+\n+        Process process = ProcessTools.startProcess(\"Child\", pb);\n+        OutputAnalyzer outputAnalyzer = new OutputAnalyzer(process);\n+\n+        if (!process.waitFor(15, TimeUnit.SECONDS)) {\n+            process.destroyForcibly();\n+            throw new TimeoutException(\"Timed out waiting for Child\");\n+        }\n+\n+        outputAnalyzer.shouldHaveExitValue(0);\n+    }\n+\n+    private void check() {\n+        boolean failed = false;\n+\n+        Transferable contents = Util.getClipboardContents(clipboard, null);\n+        Set<DataFlavor> flavorsT = new HashSet<>(Arrays.asList(contents.getTransferDataFlavors()));\n+        Set<DataFlavor> flavorsA = new HashSet<>(Arrays.asList(Util.getClipboardAvailableDataFlavors(clipboard)));\n+        System.err.println(\"getAvailableDataFlavors(): \" + flavorsA);\n+        if (!flavorsA.equals(flavorsT)) {\n+            failed = true;\n+            System.err.println(\"FAILURE: getAvailableDataFlavors() returns incorrect \" +\n+                    \"DataFlavors: \" + flavorsA + \"\\nwhile getContents().\" +\n+                    \"getTransferDataFlavors() return: \" + flavorsT);\n+        }\n+\n+        if (!Util.isClipboardDataFlavorAvailable(clipboard, DataFlavor.stringFlavor)) {\n+            failed = true;\n+            System.err.println(\"FAILURE: isDataFlavorAvailable(DataFlavor.stringFlavor) \" +\n+                               \"returns false\");\n+        }\n+\n+        Object data = null;\n+        try {\n+            data = Util.getClipboardData(clipboard, DataFlavor.stringFlavor);\n+        } catch (UnsupportedFlavorException exc) {\n+            failed = true;\n+            exc.printStackTrace();\n+        } catch (IOException exc) {\n+            failed = true;\n+            exc.printStackTrace();\n+        }\n+        System.err.println(\"getData(): \" + data);\n+        if (!contentsText.equals(data)) {\n+            failed = true;\n+            System.err.println(\"FAILURE: getData() returns: \" + data +\n+                               \", that is not equal to: \\\"\" + contentsText + \"\\\"\");\n+\n+        }\n+\n+        if (failed) {\n+            throw new RuntimeException(\"test failed, for details see output above\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            SystemClipboardTest systemClipboardTest = new SystemClipboardTest();\n+            systemClipboardTest.start();\n+            return;\n+        }\n+\n+        System.err.println(\"child VM: setting clipboard contents\");\n+\n+        CountDownLatch latch = new CountDownLatch(1);\n+        Util.setClipboardContents(clipboard, new StringSelection(contentsText),\n+                (clpbrd, cntnts) -> {\n+                    System.err.println(\"child VM: success\");\n+                    latch.countDown();\n+                });\n+\n+        if (!latch.await(15, TimeUnit.SECONDS)) {\n+            throw new RuntimeException(\"child VM failed\");\n+        }\n+    }\n+}\n+\n+class Util {\n+    public static void setClipboardContents(Clipboard cb,\n+                                            Transferable contents,\n+                                            ClipboardOwner owner) {\n+        while (true) {\n+            try {\n+                cb.setContents(contents, owner);\n+                return;\n+            } catch (IllegalStateException ise) {\n+                ise.printStackTrace();\n+                try {\n+                    Thread.sleep(100);\n+                } catch (InterruptedException ie) {\n+                    ie.printStackTrace();\n+                }\n+            }\n+        }\n+    }\n+\n+    public static Transferable getClipboardContents(Clipboard cb,\n+                                                    Object requestor) {\n+        while (true) {\n+            try {\n+                return cb.getContents(requestor);\n+            } catch (IllegalStateException ise) {\n+                try {\n+                    Thread.sleep(100);\n+                } catch (InterruptedException ie) {\n+                    ie.printStackTrace();\n+                }\n+            }\n+        }\n+    }\n+\n+    public static Object getClipboardData(Clipboard cb, DataFlavor flavor)\n+            throws IOException, UnsupportedFlavorException {\n+        while (true) {\n+            try {\n+                return cb.getData(flavor);\n+            } catch (IllegalStateException ise) {\n+                try {\n+                    Thread.sleep(100);\n+                } catch (InterruptedException ie) {\n+                    ie.printStackTrace();\n+                }\n+            }\n+        }\n+    }\n+\n+    public static DataFlavor[] getClipboardAvailableDataFlavors(Clipboard cb) {\n+        while (true) {\n+            try {\n+                return cb.getAvailableDataFlavors();\n+            } catch (IllegalStateException ise) {\n+                try {\n+                    Thread.sleep(100);\n+                } catch (InterruptedException ie) {\n+                    ie.printStackTrace();\n+                }\n+            }\n+        }\n+    }\n+\n+    public static boolean isClipboardDataFlavorAvailable(Clipboard cb,\n+                                                         DataFlavor flavor) {\n+        while (true) {\n+            try {\n+                return cb.isDataFlavorAvailable(flavor);\n+            } catch (IllegalStateException ise) {\n+                try {\n+                    Thread.sleep(100);\n+                } catch (InterruptedException ie) {\n+                    ie.printStackTrace();\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Clipboard\/GetAltContentsTest\/SystemClipboardTest.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -0,0 +1,519 @@\n+\/*\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4397404 4720930\n+ * @summary tests that images of all supported native image formats\n+ *          are transferred properly\n+ * @key headful\n+ * @library \/test\/lib\n+ * @run main ImageTransferTest\n+ *\/\n+\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.ClipboardOwner;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.SystemFlavorMap;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.MemoryImageSource;\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class ImageTransferTest {\n+    public static final int CODE_NOT_RETURNED = 100;\n+    public static final int CODE_CONSUMER_TEST_FAILED = 101;\n+    public static final int CODE_FAILURE = 102;\n+\n+    private TImageProducer imPr;\n+    private int returnCode = CODE_NOT_RETURNED;\n+\n+    public static void main(String[] args) throws Exception {\n+        ImageTransferTest imageTransferTest = new ImageTransferTest();\n+        imageTransferTest.init();\n+        imageTransferTest.start();\n+    }\n+\n+    public void init() {\n+        imPr = new TImageProducer();\n+        imPr.begin();\n+    }\n+\n+    public void start() throws Exception {\n+        String formats = \"\";\n+\n+        String iniMsg = \"Testing all native image formats from \\n\" +\n+            \"SystemFlavorMap.getNativesForFlavor(DataFlavor.imageFlavor) \\n\";\n+\n+        for (int i = 0; i < imPr.formats.length; i++) {\n+            formats += (imPr.formats[i] + \" \");\n+        }\n+        System.out.println(iniMsg + formats);\n+\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                TImageConsumer.class.getName(), formats\n+        );\n+\n+        Process process = ProcessTools.startProcess(\"Child\", pb);\n+        OutputAnalyzer outputAnalyzer = new OutputAnalyzer(process);\n+\n+        if (!process.waitFor(15, TimeUnit.SECONDS)) {\n+            process.destroyForcibly();\n+            returnCode = CODE_NOT_RETURNED;\n+        } else {\n+            returnCode = outputAnalyzer.getExitValue();\n+        }\n+\n+        switch (returnCode) {\n+            case CODE_NOT_RETURNED:\n+                throw new RuntimeException(\"Child VM: failed to start\");\n+            case CODE_FAILURE:\n+                throw new RuntimeException(\"Child VM: abnormal termination\");\n+            case CODE_CONSUMER_TEST_FAILED:\n+                throw new RuntimeException(\"test failed: images in some \" +\n+                    \"native formats are not transferred properly: \" +\n+                    \"see output of child VM\");\n+            default:\n+                boolean failed = false;\n+                String passedFormats = \"\";\n+                String failedFormats = \"\";\n+\n+                for (int i = 0; i < imPr.passedArray.length; i++) {\n+                   if (imPr.passedArray[i]) passedFormats += imPr.formats[i] + \" \";\n+                   else {\n+                       failed = true;\n+                       failedFormats += imPr.formats[i] + \" \";\n+                   }\n+                }\n+                if (failed) {\n+                    throw new RuntimeException(\"test failed: images in following \" +\n+                        \"native formats are not transferred properly: \" +\n+                        failedFormats);\n+                } else {\n+                    System.err.println(\"images in following native formats are \" +\n+                        \"transferred properly: \" + passedFormats);\n+                }\n+        }\n+    }\n+}\n+\n+abstract class ImageTransferer implements ClipboardOwner {\n+\n+    static final String S_PASSED = \"Y\";\n+    static final String S_FAILED = \"N\";\n+    static final String S_BEGIN = \"B\";\n+    static final String S_BEGIN_ANSWER = \"BA\";\n+    static final String S_END = \"E\";\n+\n+    Image image;\n+\n+    Clipboard clipboard;\n+\n+    String[] formats;\n+    int fi; \/\/ next format index\n+\n+\n+    ImageTransferer() {\n+        clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();\n+        image = createImage();\n+    }\n+\n+    abstract void notifyTransferSuccess(boolean status);\n+\n+    private static Image createImage() {\n+        int w = 100;\n+        int h = 100;\n+        int[] pix = new int[w * h];\n+\n+        int index = 0;\n+        for (int y = 0; y < h; y++) {\n+            for (int x = 0; x < w; x++) {\n+                int red = 127;\n+                int green = 127;\n+                int blue = y > h \/ 2 ? 127 : 0;\n+                int alpha = 255;\n+                if (x < w \/ 4 && y < h \/ 4) {\n+                    alpha = 0;\n+                    red = 0;\n+                }\n+                pix[index++] = (alpha << 24) | (red << 16) | (green << 8) | blue;\n+            }\n+        }\n+\n+        return Toolkit.getDefaultToolkit().\n+                   createImage(new MemoryImageSource(w, h, pix, 0, w));\n+    }\n+\n+    static String[] retrieveFormatsToTest() {\n+        SystemFlavorMap sfm = (SystemFlavorMap)SystemFlavorMap.getDefaultFlavorMap();\n+        java.util.List ln = sfm.getNativesForFlavor(DataFlavor.imageFlavor);\n+\n+        String osName = System.getProperty(\"os.name\").toLowerCase();\n+        String sMETAFILEPICT = \"METAFILEPICT\";\n+        if (osName.indexOf(\"win\") >= 0 && !ln.contains(sMETAFILEPICT)) {\n+            \/\/ for test failing on JDK without this fix\n+            ln.add(sMETAFILEPICT);\n+        }\n+        return (String[])ln.toArray(new String[ln.size()]);\n+    }\n+\n+    static void leaveFormat(String format) {\n+        SystemFlavorMap sfm = (SystemFlavorMap)SystemFlavorMap.getDefaultFlavorMap();\n+        sfm.setFlavorsForNative(format,\n+                                new DataFlavor[] { DataFlavor.imageFlavor });\n+        sfm.setNativesForFlavor(DataFlavor.imageFlavor,\n+                                new String[] { format });\n+    }\n+\n+    boolean areImagesIdentical(Image im1, Image im2) {\n+        if (formats[fi].equals(\"JFIF\") || formats[fi].equals(\"image\/jpeg\") ||\n+                formats[fi].equals(\"GIF\") || formats[fi].equals(\"image\/gif\")) {\n+            \/\/ JFIF and GIF are lossy formats\n+            return true;\n+        }\n+        int[] ib1 = getImageData(im1);\n+        int[] ib2 = getImageData(im2);\n+\n+        if (ib1.length != ib2.length) {\n+            return false;\n+        }\n+\n+        if (formats[fi].equals(\"PNG\") ||\n+            formats[fi].equals(\"image\/png\") ||\n+            formats[fi].equals(\"image\/x-png\")) {\n+            \/\/ check alpha as well\n+            for (int i = 0; i < ib1.length; i++) {\n+               if (ib1[i] != ib2[i]) {\n+                   System.err.println(\"different pixels: \" +\n+                       Integer.toHexString(ib1[i]) + \" \" +\n+                       Integer.toHexString(ib2[i]));\n+                   return false;\n+               }\n+            }\n+        } else {\n+            for (int i = 0; i < ib1.length; i++) {\n+               if ((ib1[i] & 0x00FFFFFF) != (ib2[i] & 0x00FFFFFF)) {\n+                   System.err.println(\"different pixels: \" +\n+                       Integer.toHexString(ib1[i]) + \" \" +\n+                       Integer.toHexString(ib2[i]));\n+                   return false;\n+               }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private static int[] getImageData(Image image) {\n+        int width = image.getWidth(null);\n+        int height = image.getHeight(null);\n+        BufferedImage bimage = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n+        Graphics2D g2d = bimage.createGraphics();\n+        try {\n+            g2d.drawImage(image, 0, 0, width, height, null);\n+        } finally {\n+            g2d.dispose();\n+        }\n+        return bimage.getRGB(0, 0, width, height, null, 0, width);\n+    }\n+\n+    static void setClipboardContents(Clipboard cb,\n+                                     Transferable contents,\n+                                     ClipboardOwner owner) {\n+        synchronized (cb) {\n+            boolean set = false;\n+            while (!set) {\n+                try {\n+                    cb.setContents(contents, owner);\n+                    set = true;\n+                } catch (IllegalStateException ise) {\n+                    try { Thread.sleep(100); }\n+                    catch (InterruptedException e) { e.printStackTrace(); }\n+                }\n+            }\n+        }\n+    }\n+\n+    static Transferable getClipboardContents(Clipboard cb,\n+                                             Object requestor) {\n+        synchronized (cb) {\n+            while (true) {\n+                try {\n+                    Transferable t = cb.getContents(requestor);\n+                    return t;\n+                } catch (IllegalStateException ise) {\n+                    try { Thread.sleep(100); }\n+                    catch (InterruptedException e) { e.printStackTrace(); }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+class TImageProducer extends ImageTransferer {\n+\n+    boolean[] passedArray;\n+\n+    private boolean isFirstCallOfLostOwnership = true;\n+\n+    TImageProducer() {\n+        formats = retrieveFormatsToTest();\n+        passedArray = new boolean[formats.length];\n+    }\n+\n+    void begin() {\n+        setClipboardContents(clipboard, new StringSelection(S_BEGIN), this);\n+    }\n+\n+    public void lostOwnership(Clipboard cb, Transferable contents) {\n+        System.err.println(\"PRODUCER: lost clipboard ownership\");\n+\n+        Transferable t = getClipboardContents(cb, null);\n+\n+        if (t.isDataFlavorSupported(DataFlavor.stringFlavor)) {\n+            String msg = null;\n+            \/\/ for test going on if t.getTransferData() will throw an exception\n+            if (isFirstCallOfLostOwnership) {\n+                isFirstCallOfLostOwnership = false;\n+                msg = S_BEGIN_ANSWER;\n+            } else {\n+                msg = S_PASSED;\n+            }\n+\n+            try {\n+                msg = (String)t.getTransferData(DataFlavor.stringFlavor);\n+                System.err.println(\"received message: \" + msg);\n+            } catch (Exception e) {\n+                System.err.println(\"Can't getTransferData-message: \" + e);\n+            }\n+\n+            if (msg.equals(S_PASSED)) {\n+                notifyTransferSuccess(true);\n+            } else if (msg.equals(S_FAILED)) {\n+                notifyTransferSuccess(false);\n+            } else if (!msg.equals(S_BEGIN_ANSWER)) {\n+                throw new RuntimeException(\"wrong message in \" +\n+                    \"TImageProducer.lostOwnership(): \" + msg +\n+                    \"  (possibly due to bug 4683804)\");\n+            }\n+        } else {\n+            throw new RuntimeException(\"DataFlavor.stringFlavor is not \" +\n+                \"supported by transferable in \" +\n+                \"TImageProducer.lostOwnership()\");\n+        }\n+\n+        if (fi < formats.length) {\n+            System.err.println(\"testing native image format \" + formats[fi] +\n+                               \"...\");\n+            leaveFormat(formats[fi]);\n+            setClipboardContents(cb, new ImageSelection(image), this);\n+        } else {\n+            setClipboardContents(cb, new StringSelection(S_END), null);\n+        }\n+    }\n+\n+    void notifyTransferSuccess(boolean status) {\n+        passedArray[fi] = status;\n+        fi++;\n+    }\n+}\n+\n+class TImageConsumer extends ImageTransferer {\n+\n+    private static final Object LOCK = new Object();\n+\n+    private static boolean failed;\n+\n+    public void lostOwnership(Clipboard cb, Transferable contents) {\n+        System.err.println(\"CONSUMER: lost clipboard ownership\");\n+\n+        Transferable t = getClipboardContents(cb, null);\n+\n+        if (t.isDataFlavorSupported(DataFlavor.imageFlavor)) {\n+            Image im = null; \/\/? image;\n+            try {\n+                im = (Image) t.getTransferData(DataFlavor.imageFlavor);\n+            } catch (Exception e) {\n+                System.err.println(\"Can't getTransferData-image: \" + e);\n+                notifyTransferSuccess(false);\n+            }\n+\n+            if (im == null) {\n+                System.err.println(\"getTransferData returned null\");\n+                notifyTransferSuccess(false);\n+            } else if (areImagesIdentical(image, im)) {\n+                notifyTransferSuccess(true);\n+            } else {\n+                System.err.println(\"transferred image is different from \" +\n+                                   \"initial image\");\n+                notifyTransferSuccess(false);\n+            }\n+        } else if (t.isDataFlavorSupported(DataFlavor.stringFlavor)) {\n+            \/\/ all image formats have been processed\n+            try {\n+                String msg = (String) t.getTransferData(DataFlavor.stringFlavor);\n+                System.err.println(\"received message: \" + msg);\n+            } catch (Exception e) {\n+                System.err.println(\"Can't getTransferData-message: \" + e);\n+            }\n+            synchronized (LOCK) {\n+                LOCK.notifyAll();\n+            }\n+        } else {\n+            System.err.println(\"imageFlavor is not supported by transferable\");\n+            notifyTransferSuccess(false);\n+        }\n+    }\n+\n+    void notifyTransferSuccess(boolean status) {\n+        if (status) {\n+            System.err.println(\"format passed: \" + formats[fi]);\n+            setClipboardContents(clipboard, new StringSelection(S_PASSED), this);\n+        } else {\n+            failed = true;\n+            System.err.println(\"format failed: \" + formats[fi]);\n+            setClipboardContents(clipboard, new StringSelection(S_FAILED), this);\n+        }\n+\n+        if (fi < formats.length - 1) {\n+            leaveFormat(formats[++fi]);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        try {\n+            TImageConsumer ic = new TImageConsumer();\n+\n+            ic.formats = args;\n+\n+            leaveFormat(ic.formats[0]);\n+            synchronized (LOCK) {\n+                ic.setClipboardContents(ic.clipboard,\n+                    new StringSelection(S_BEGIN_ANSWER), ic);\n+                LOCK.wait();\n+            }\n+            if (failed) System.exit(ImageTransferTest.CODE_CONSUMER_TEST_FAILED);\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+            System.exit(ImageTransferTest.CODE_FAILURE);\n+        }\n+    }\n+}\n+\n+\/**\n+ * A <code>Transferable<\/code> which implements the capability required\n+ * to transfer an <code>Image<\/code>.\n+ *\n+ * This <code>Transferable<\/code> properly supports\n+ * <code>DataFlavor.imageFlavor<\/code>.\n+ * and all equivalent flavors.\n+ * No other <code>DataFlavor<\/code>s are supported.\n+ *\n+ * @see java.awt.datatransfer.DataFlavor.imageFlavor\n+ *\/\n+class ImageSelection implements Transferable {\n+\n+    private static final int IMAGE = 0;\n+\n+    private static final DataFlavor[] flavors = { DataFlavor.imageFlavor };\n+\n+    private Image data;\n+\n+    \/**\n+     * Creates a <code>Transferable<\/code> capable of transferring\n+     * the specified <code>String<\/code>.\n+     *\/\n+    public ImageSelection(Image data) {\n+        this.data = data;\n+    }\n+\n+    \/**\n+     * Returns an array of flavors in which this <code>Transferable<\/code>\n+     * can provide the data. <code>DataFlavor.stringFlavor<\/code>\n+     * is properly supported.\n+     * Support for <code>DataFlavor.plainTextFlavor<\/code> is\n+     * <b>deprecated<\/b>.\n+     *\n+     * @return an array of length one, whose element is <code>DataFlavor.\n+     *         imageFlavor<\/code>\n+     *\/\n+    public DataFlavor[] getTransferDataFlavors() {\n+        \/\/ returning flavors itself would allow client code to modify\n+        \/\/ our internal behavior\n+        return (DataFlavor[])flavors.clone();\n+    }\n+\n+    \/**\n+     * Returns whether the requested flavor is supported by this\n+     * <code>Transferable<\/code>.\n+     *\n+     * @param flavor the requested flavor for the data\n+     * @return true if <code>flavor<\/code> is equal to\n+     *   <code>DataFlavor.imageFlavor<\/code>;\n+     *   false if <code>flavor<\/code>\n+     *   is not one of the above flavors\n+     * @throws NullPointerException if flavor is <code>null<\/code>\n+     *\/\n+    public boolean isDataFlavorSupported(DataFlavor flavor) {\n+        for (int i = 0; i < flavors.length; i++) {\n+            if (flavor.equals(flavors[i])) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Returns the <code>Transferable<\/code>'s data in the requested\n+     * <code>DataFlavor<\/code> if possible. If the desired flavor is\n+     * <code>DataFlavor.imageFlavor<\/code>, or an equivalent flavor,\n+     * the <code>Image<\/code> representing the selection is\n+     * returned.\n+     *\n+     * @param flavor the requested flavor for the data\n+     * @return the data in the requested flavor, as outlined above\n+     * @throws UnsupportedFlavorException if the requested data flavor is\n+     *         not equivalent to <code>DataFlavor.imageFlavor<\/code>\n+     * @throws IOException if an IOException occurs while retrieving the data.\n+     *         By default, <code>ImageSelection<\/code> never throws\n+     *         this exception, but a subclass may.\n+     * @throws NullPointerException if flavor is <code>null<\/code>\n+     *\/\n+    public Object getTransferData(DataFlavor flavor)\n+        throws UnsupportedFlavorException, java.io.IOException\n+    {\n+        if (flavor.equals(flavors[IMAGE])) {\n+            return (Object)data;\n+        } else {\n+            throw new UnsupportedFlavorException(flavor);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Clipboard\/ImageTransferTest.java","additions":519,"deletions":0,"binary":false,"changes":519,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2002, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4558797\n+ * @summary Tests that there is no data conversion failure when two applications\n+ *          exchange data via system clipboard\n+ * @key headful\n+ * @library \/test\/lib\n+ * @run main NoDataConversionFailureTest\n+ *\/\n+\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.Clipboard;\n+import java.awt.datatransfer.ClipboardOwner;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.StringSelection;\n+import java.awt.datatransfer.Transferable;\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class NoDataConversionFailureTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        SystemClipboardOwner.run();\n+\n+        if (SystemClipboardOwner.failed) {\n+            throw new RuntimeException(\"test failed: can not get transfer data\");\n+        } else {\n+            System.err.println(\"test passed\");\n+        }\n+    }\n+}\n+\n+class SystemClipboardOwner implements ClipboardOwner {\n+    static volatile boolean failed;\n+\n+    private static final Object LOCK = new Object();\n+\n+    private static final int CHAIN_LENGTH = 15;\n+    private final static Clipboard clipboard =\n+            Toolkit.getDefaultToolkit().getSystemClipboard();\n+\n+    private int m;\n+    private final int id;\n+\n+    public SystemClipboardOwner(int m) { this.m = m; id = m; }\n+\n+    public void lostOwnership(Clipboard cb, Transferable contents) {\n+        System.err.println(id + \" lost clipboard ownership\");\n+\n+        Transferable t = getClipboardContents(cb, null);\n+        \/\/ for test passing if t.getTransferData() will throw an exception\n+        String msg = String.valueOf(m + 1);\n+        try {\n+            msg = (String) t.getTransferData(DataFlavor.stringFlavor);\n+        } catch (IOException e) {\n+            failed = true;\n+            System.err.println(id + \" can't getTransferData: \" + e);\n+        } catch (Exception e) {\n+            System.err.println(id + \" can't getTransferData: \" + e);\n+        }\n+\n+        System.err.println(id + \" Clipboard.getContents(): \" + msg);\n+        if (!msg.equals(String.valueOf(m + 1))) {\n+            System.err.println(\"Clipboard.getContents() returned incorrect contents!\");\n+        }\n+\n+        m += 2;\n+        if (m <= CHAIN_LENGTH) {\n+            System.err.println(id + \" Clipboard.setContents(): \" + m);\n+            setClipboardContents(cb, new StringSelection(m + \"\"), this);\n+        }\n+        if (m >= CHAIN_LENGTH) {\n+            synchronized (LOCK) {\n+                LOCK.notifyAll();\n+            }\n+        }\n+    }\n+\n+    public static void run() throws Exception {\n+        SystemClipboardOwner cbo1 = new SystemClipboardOwner(0);\n+        System.err.println(cbo1.m + \" Clipboard.setContents(): \" + cbo1.m);\n+        setClipboardContents(clipboard, new StringSelection(cbo1.m + \"\"),\n+                cbo1);\n+\n+        ProcessBuilder pb = ProcessTools\n+                .createTestJavaProcessBuilder(SystemClipboardOwner.class.getName());\n+\n+        Process process = ProcessTools.startProcess(\"Child\", pb);\n+        OutputAnalyzer outputAnalyzer = new OutputAnalyzer(process);\n+\n+        if (!process.waitFor(15, TimeUnit.SECONDS)) {\n+            process.destroyForcibly();\n+            throw new TimeoutException(\"Timed out waiting for Child\");\n+        }\n+\n+        if (cbo1.m < CHAIN_LENGTH) {\n+            System.err.println(\"chain of calls of lostOwnership() broken!\");\n+        }\n+\n+        outputAnalyzer.shouldHaveExitValue(0);\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException {\n+        SystemClipboardOwner cbo2 = new SystemClipboardOwner(1);\n+        System.err.println(cbo2.m + \" Clipboard.setContents(): \" + cbo2.m);\n+\n+        synchronized (LOCK) {\n+            setClipboardContents(clipboard, new StringSelection(cbo2.m + \"\"),\n+                cbo2);\n+            LOCK.wait();\n+        }\n+    }\n+\n+\n+    private static void setClipboardContents(Clipboard cb,\n+                                             Transferable contents,\n+                                             ClipboardOwner owner) {\n+        synchronized (cb) {\n+            boolean set = false;\n+            while (!set) {\n+                try {\n+                    cb.setContents(contents, owner);\n+                    set = true;\n+                } catch (IllegalStateException ise) {\n+                    try { Thread.sleep(100); }\n+                    catch (InterruptedException e) { e.printStackTrace(); }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static Transferable getClipboardContents(Clipboard cb,\n+                                                     Object requestor) {\n+        synchronized (cb) {\n+            while (true) {\n+                try {\n+                    Transferable t = cb.getContents(requestor);\n+                    return t;\n+                } catch (IllegalStateException ise) {\n+                    try { Thread.sleep(100); }\n+                    catch (InterruptedException e) { e.printStackTrace(); }\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Clipboard\/NoDataConversionFailureTest.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"}]}