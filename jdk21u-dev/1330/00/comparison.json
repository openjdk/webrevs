{"files":[{"patch":"@@ -25,0 +25,1 @@\n+JVM_IsContainerized\n","filename":"make\/data\/hotspot-symbols\/symbols-linux","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -44,1 +45,1 @@\n-  CgroupV1Controller* cpu = nullptr;\n+  CgroupV1CpuController* cpu = nullptr;\n@@ -64,3 +65,9 @@\n-    \/\/ Note: any index in cg_infos will do as the path is the same for\n-    \/\/       all controllers.\n-    CgroupController* unified = new CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path, cg_infos[MEMORY_IDX]._cgroup_path);\n+    \/\/ Note: We use the memory for non-cpu non-memory controller look-ups.\n+    \/\/       Perhaps we ought to have separate controllers for all.\n+    CgroupV2Controller mem_other = CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path,\n+                                                      cg_infos[MEMORY_IDX]._cgroup_path,\n+                                                      cg_infos[MEMORY_IDX]._read_only);\n+    CgroupV2MemoryController* memory = new CgroupV2MemoryController(mem_other);\n+    CgroupV2CpuController* cpu = new CgroupV2CpuController(CgroupV2Controller(cg_infos[CPU_IDX]._mount_path,\n+                                                                              cg_infos[CPU_IDX]._cgroup_path,\n+                                                                              cg_infos[CPU_IDX]._read_only));\n@@ -69,1 +76,1 @@\n-    return new CgroupV2Subsystem(unified);\n+    return new CgroupV2Subsystem(memory, cpu, mem_other);\n@@ -103,1 +110,1 @@\n-        memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path);\n+        memory = new CgroupV1MemoryController(CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only));\n@@ -106,1 +113,1 @@\n-        cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only);\n@@ -109,1 +116,1 @@\n-        cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpu = new CgroupV1CpuController(CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only));\n@@ -112,1 +119,1 @@\n-        cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only);\n@@ -115,1 +122,1 @@\n-        pids = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        pids = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only);\n@@ -130,1 +137,2 @@\n-                                                  char* root_path) {\n+                                                  char* root_path,\n+                                                  bool read_only) {\n@@ -142,0 +150,1 @@\n+      cg_infos[controller]._read_only = read_only;\n@@ -149,0 +158,1 @@\n+    cg_infos[controller]._read_only = read_only;\n@@ -152,0 +162,56 @@\n+\/*\n+ * Determine whether or not the mount options, which are comma separated,\n+ * contain the 'ro' string.\n+ *\/\n+static bool find_ro_opt(char* mount_opts) {\n+  char* token;\n+  char* mo_ptr = mount_opts;\n+  \/\/ mount options are comma-separated (man proc).\n+  while ((token = strsep(&mo_ptr, \",\")) != NULL) {\n+    if (strcmp(token, \"ro\") == 0) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\/*\n+ * Read values of a \/proc\/self\/mountinfo line into variables. For cgroups v1\n+ * super options are needed. On cgroups v2 super options are not used.\n+ *\n+ * The scanning of a single mountinfo line entry is as follows:\n+ *\n+ * 36  35  98:0      \/mnt1 \/mnt2 rw,noatime master:1 - ext3 \/dev\/root rw,errors=continue\n+ * (1) (2) (3):(4)   (5)   (6)      (7)      (8)   (9) (10)   (11)         (12)\n+ *\n+ * The numbers in parentheses are labels for the descriptions below:\n+ *\n+ *  (1)   mount ID:        matched with '%*d' and discarded\n+ *  (2)   parent ID:       matched with '%*d' and discarded\n+ *  (3)   major:           ---,---> major, minor separated by ':'. matched with '%*d:%*d' and discarded\n+ *  (4)   minor:           ---'\n+ *  (5)   root:            matched with '%s' and captured in 'tmproot'. Must be non-empty.\n+ *  (6)   mount point:     matched with '%s' and captured in 'tmpmount'. Must be non-empty.\n+ *  (7)   mount options:   matched with '%s' and captured in 'mount_opts'. Must be non-empty.\n+ *  (8)   optional fields: ---,---> matched with '%*[^-]-'. Anything not a hyphen, followed by a hyphen\n+ *  (9)   separator:       ---'     and discarded. Note: The discarded match is space characters if there\n+ *                                  are no optionals. Otherwise it includes the optional fields as well.\n+ * (10)   filesystem type: matched with '%s' and captured in 'tmp_fs_type'\n+ * (11)   mount source:    matched with '%*s' and discarded\n+ * (12)   super options:   matched with '%s' and captured in 'tmpcgroups'\n+ *\/\n+static inline bool match_mount_info_line(char* line,\n+                                         char* tmproot,\n+                                         char* tmpmount,\n+                                         char* mount_opts,\n+                                         char* tmp_fs_type,\n+                                         char* tmpcgroups) {\n+ return sscanf(line,\n+               \"%*d %*d %*d:%*d %s %s %s%*[^-]- %s %*s %s\",\n+               tmproot,\n+               tmpmount,\n+               mount_opts,\n+               tmp_fs_type,\n+               tmpcgroups) == 5;\n+}\n+\n@@ -321,0 +387,1 @@\n+    char mount_opts[MAXPATHLEN+1];\n@@ -324,4 +391,13 @@\n-    \/\/ Cgroup v2 relevant info. We only look for the _mount_path iff is_cgroupsV2 so\n-    \/\/ as to avoid memory stomping of the _mount_path pointer later on in the cgroup v1\n-    \/\/ block in the hybrid case.\n-    if (is_cgroupsV2 && sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- %s %*s %*s\", tmproot, tmpmount, tmp_fs_type) == 3) {\n+    \/* Cgroup v2 relevant info. We only look for the _mount_path iff is_cgroupsV2 so\n+     * as to avoid memory stomping of the _mount_path pointer later on in the cgroup v1\n+     * block in the hybrid case.\n+     *\n+     * We collect the read only mount option in the cgroup infos so as to have that\n+     * info ready when determining is_containerized().\n+     *\/\n+    if (is_cgroupsV2 && match_mount_info_line(p,\n+                                              tmproot,\n+                                              tmpmount,\n+                                              mount_opts,\n+                                              tmp_fs_type,\n+                                              tmpcgroups \/* unused *\/)) {\n@@ -332,0 +408,3 @@\n+        \/\/ For unified we only have a single line with cgroup2 fs type.\n+        \/\/ Therefore use that option for all CG info structs.\n+        bool ro_option = find_ro_opt(mount_opts);\n@@ -333,1 +412,1 @@\n-          set_controller_paths(cg_infos, i, \"(cg2, unified)\", tmpmount, tmproot);\n+          set_controller_paths(cg_infos, i, \"(cg2, unified)\", tmpmount, tmproot, ro_option);\n@@ -340,1 +419,2 @@\n-     * Find the cgroup mount point for memory, cpuset, cpu, cpuacct, pids\n+     * Find the cgroup mount point for memory, cpuset, cpu, cpuacct, pids. For each controller\n+     * determine whether or not they show up as mounted read only or not.\n@@ -349,0 +429,1 @@\n+     *\n@@ -350,1 +431,1 @@\n-    if (sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- %s %*s %s\", tmproot, tmpmount, tmp_fs_type, tmpcgroups) == 4) {\n+    if (match_mount_info_line(p, tmproot, tmpmount, mount_opts, tmp_fs_type, tmpcgroups)) {\n@@ -358,1 +439,2 @@\n-          set_controller_paths(cg_infos, MEMORY_IDX, token, tmpmount, tmproot);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, MEMORY_IDX, token, tmpmount, tmproot, ro_option);\n@@ -362,1 +444,2 @@\n-          set_controller_paths(cg_infos, CPUSET_IDX, token, tmpmount, tmproot);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, CPUSET_IDX, token, tmpmount, tmproot, ro_option);\n@@ -366,1 +449,2 @@\n-          set_controller_paths(cg_infos, CPU_IDX, token, tmpmount, tmproot);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, CPU_IDX, token, tmpmount, tmproot, ro_option);\n@@ -370,1 +454,2 @@\n-          set_controller_paths(cg_infos, CPUACCT_IDX, token, tmpmount, tmproot);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, CPUACCT_IDX, token, tmpmount, tmproot, ro_option);\n@@ -374,1 +459,2 @@\n-          set_controller_paths(cg_infos, PIDS_IDX, token, tmpmount, tmproot);\n+          bool ro_option = find_ro_opt(mount_opts);\n+          set_controller_paths(cg_infos, PIDS_IDX, token, tmpmount, tmproot, ro_option);\n@@ -478,1 +564,1 @@\n-  int cpu_count, limit_count;\n+  int cpu_count;\n@@ -484,1 +570,1 @@\n-  CachingCgroupController* contrl = cpu_controller();\n+  CachingCgroupController<CgroupCpuController>* contrl = cpu_controller();\n@@ -492,17 +578,2 @@\n-  cpu_count = limit_count = os::Linux::active_processor_count();\n-  int quota  = cpu_quota();\n-  int period = cpu_period();\n-\n-  if (quota > -1 && period > 0) {\n-    quota_count = ceilf((float)quota \/ (float)period);\n-    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n-  }\n-\n-  \/\/ Use quotas\n-  if (quota_count != 0) {\n-    limit_count = quota_count;\n-  }\n-\n-  result = MIN2(cpu_count, limit_count);\n-  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n-\n+  cpu_count = os::Linux::active_processor_count();\n+  result = CgroupUtil::processor_count(contrl->controller(), cpu_count);\n@@ -525,1 +596,1 @@\n-  CachingCgroupController* contrl = memory_controller();\n+  CachingCgroupController<CgroupMemoryController>* contrl = memory_controller();\n@@ -532,22 +603,1 @@\n-  jlong mem_limit = read_memory_limit_in_bytes();\n-\n-  if (mem_limit <= 0 || mem_limit >= phys_mem) {\n-    jlong read_mem_limit = mem_limit;\n-    const char *reason;\n-    if (mem_limit >= phys_mem) {\n-      \/\/ Exceeding physical memory is treated as unlimited. Cg v1's implementation\n-      \/\/ of read_memory_limit_in_bytes() caps this at phys_mem since Cg v1 has no\n-      \/\/ value to represent 'max'. Cg v2 may return a value >= phys_mem if e.g. the\n-      \/\/ container engine was started with a memory flag exceeding it.\n-      reason = \"ignored\";\n-      mem_limit = -1;\n-    } else if (OSCONTAINER_ERROR == mem_limit) {\n-      reason = \"failed\";\n-    } else {\n-      assert(mem_limit == -1, \"Expected unlimited\");\n-      reason = \"unlimited\";\n-    }\n-    log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n-                             reason, read_mem_limit, phys_mem);\n-  }\n-\n+  jlong mem_limit = contrl->controller()->read_memory_limit_in_bytes(phys_mem);\n@@ -559,1 +609,145 @@\n-jlong CgroupSubsystem::limit_from_str(char* limit_str) {\n+bool CgroupController::read_string(const char* filename, char* buf, size_t buf_size) {\n+  assert(buf != nullptr, \"buffer must not be null\");\n+  assert(filename != nullptr, \"filename must be given\");\n+  const char* s_path = subsystem_path();\n+  if (s_path == nullptr) {\n+    log_debug(os, container)(\"read_string: subsystem path is null\");\n+    return false;\n+  }\n+\n+  stringStream file_path;\n+  file_path.print_raw(s_path);\n+  file_path.print_raw(filename);\n+\n+  if (file_path.size() > MAXPATHLEN) {\n+    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n+    return false;\n+  }\n+  const char* absolute_path = file_path.freeze();\n+  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n+\n+  FILE* fp = os::fopen(absolute_path, \"r\");\n+  if (fp == nullptr) {\n+    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n+    return false;\n+  }\n+\n+  \/\/ Read a single line into the provided buffer.\n+  \/\/ At most buf_size - 1 characters.\n+  char* line = fgets(buf, buf_size, fp);\n+  fclose(fp);\n+  if (line == nullptr) {\n+    log_debug(os, container)(\"Empty file %s\", absolute_path);\n+    return false;\n+  }\n+  size_t len = strlen(line);\n+  assert(len <= buf_size - 1, \"At most buf_size - 1 bytes can be read\");\n+  if (line[len - 1] == '\\n') {\n+    line[len - 1] = '\\0'; \/\/ trim trailing new line\n+  }\n+  return true;\n+}\n+\n+bool CgroupController::read_number(const char* filename, julong* result) {\n+  char buf[1024];\n+  bool is_ok = read_string(filename, buf, 1024);\n+  if (!is_ok) {\n+    return false;\n+  }\n+  int matched = sscanf(buf, JULONG_FORMAT, result);\n+  if (matched == 1) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool CgroupController::read_number_handle_max(const char* filename, jlong* result) {\n+  char buf[1024];\n+  bool is_ok = read_string(filename, buf, 1024);\n+  if (!is_ok) {\n+    return false;\n+  }\n+  jlong val = limit_from_str(buf);\n+  if (val == OSCONTAINER_ERROR) {\n+    return false;\n+  }\n+  *result = val;\n+  return true;\n+}\n+\n+bool CgroupController::read_numerical_key_value(const char* filename, const char* key, julong* result) {\n+  assert(key != nullptr, \"key must be given\");\n+  assert(result != nullptr, \"result pointer must not be null\");\n+  assert(filename != nullptr, \"file to search in must be given\");\n+  const char* s_path = subsystem_path();\n+  if (s_path == nullptr) {\n+    log_debug(os, container)(\"read_numerical_key_value: subsystem path is null\");\n+    return false;\n+  }\n+\n+  stringStream file_path;\n+  file_path.print_raw(s_path);\n+  file_path.print_raw(filename);\n+\n+  if (file_path.size() > MAXPATHLEN) {\n+    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n+    return false;\n+  }\n+  const char* absolute_path = file_path.freeze();\n+  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n+  FILE* fp = os::fopen(absolute_path, \"r\");\n+  if (fp == nullptr) {\n+    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n+    return false;\n+  }\n+\n+  const int buf_len = MAXPATHLEN+1;\n+  char buf[buf_len];\n+  char* line = fgets(buf, buf_len, fp);\n+  bool found_match = false;\n+  \/\/ File consists of multiple lines in a \"key value\"\n+  \/\/ fashion, we have to find the key.\n+  const size_t key_len = strlen(key);\n+  for (; line != nullptr; line = fgets(buf, buf_len, fp)) {\n+    char after_key = line[key_len];\n+    if (strncmp(line, key, key_len) == 0\n+          && isspace(after_key) != 0\n+          && after_key != '\\n') {\n+      \/\/ Skip key, skip space\n+      const char* value_substr = line + key_len + 1;\n+      int matched = sscanf(value_substr, JULONG_FORMAT, result);\n+      found_match = matched == 1;\n+      if (found_match) {\n+        break;\n+      }\n+    }\n+  }\n+  fclose(fp);\n+  if (found_match) {\n+    return true;\n+  }\n+  log_debug(os, container)(\"Type %s (key == %s) not found in file %s\", JULONG_FORMAT,\n+                           key, absolute_path);\n+  return false;\n+}\n+\n+bool CgroupController::read_numerical_tuple_value(const char* filename, bool use_first, jlong* result) {\n+  char buf[1024];\n+  bool is_ok = read_string(filename, buf, 1024);\n+  if (!is_ok) {\n+    return false;\n+  }\n+  char token[1024];\n+  const int matched = sscanf(buf, (use_first ? \"%1023s %*s\" : \"%*s %1023s\"), token);\n+  if (matched != 1) {\n+    return false;\n+  }\n+  jlong val = limit_from_str(token);\n+  if (val == OSCONTAINER_ERROR) {\n+    return false;\n+  }\n+  *result = val;\n+  return true;\n+}\n+\n+jlong CgroupController::limit_from_str(char* limit_str) {\n@@ -566,1 +760,0 @@\n-    os::free(limit_str);\n@@ -571,1 +764,0 @@\n-    os::free(limit_str);\n@@ -574,1 +766,0 @@\n-  os::free(limit_str);\n@@ -577,0 +768,52 @@\n+\n+\/\/ CgroupSubsystem implementations\n+\n+jlong CgroupSubsystem::memory_and_swap_limit_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  julong host_swap = os::Linux::host_swap();\n+  return memory_controller()->controller()->memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n+}\n+\n+jlong CgroupSubsystem::memory_and_swap_usage_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  julong host_swap = os::Linux::host_swap();\n+  return memory_controller()->controller()->memory_and_swap_usage_in_bytes(phys_mem, host_swap);\n+}\n+\n+jlong CgroupSubsystem::memory_soft_limit_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  return memory_controller()->controller()->memory_soft_limit_in_bytes(phys_mem);\n+}\n+\n+jlong CgroupSubsystem::memory_usage_in_bytes() {\n+  return memory_controller()->controller()->memory_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::memory_max_usage_in_bytes() {\n+  return memory_controller()->controller()->memory_max_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::rss_usage_in_bytes() {\n+  return memory_controller()->controller()->rss_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::cache_usage_in_bytes() {\n+  return memory_controller()->controller()->cache_usage_in_bytes();\n+}\n+\n+int CgroupSubsystem::cpu_quota() {\n+  return cpu_controller()->controller()->cpu_quota();\n+}\n+\n+int CgroupSubsystem::cpu_period() {\n+  return cpu_controller()->controller()->cpu_period();\n+}\n+\n+int CgroupSubsystem::cpu_shares() {\n+  return cpu_controller()->controller()->cpu_shares();\n+}\n+\n+void CgroupSubsystem::print_version_specific_info(outputStream* st) {\n+  julong phys_mem = os::Linux::physical_memory();\n+  memory_controller()->controller()->print_version_specific_info(st, phys_mem);\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":312,"deletions":69,"binary":false,"changes":381,"status":"modified"},{"patch":"@@ -72,108 +72,9 @@\n-typedef char * cptr;\n-\n-class CgroupController: public CHeapObj<mtInternal> {\n-  public:\n-    virtual char *subsystem_path() = 0;\n-};\n-\n-PRAGMA_DIAG_PUSH\n-PRAGMA_FORMAT_NONLITERAL_IGNORED\n-\/\/ Parses a subsystem's file, looking for a matching line.\n-\/\/ If key is null, then the first line will be matched with scan_fmt.\n-\/\/ If key isn't null, then each line will be matched, looking for something that matches \"$key $scan_fmt\".\n-\/\/ The matching value will be assigned to returnval.\n-\/\/ scan_fmt uses scanf() syntax.\n-\/\/ Return value: 0 on match, OSCONTAINER_ERROR on error.\n-template <typename T> int subsystem_file_line_contents(CgroupController* c,\n-                                              const char *filename,\n-                                              const char *key,\n-                                              const char *scan_fmt,\n-                                              T returnval) {\n-  if (c == nullptr) {\n-    log_debug(os, container)(\"subsystem_file_line_contents: CgroupController* is null\");\n-    return OSCONTAINER_ERROR;\n-  }\n-  if (c->subsystem_path() == nullptr) {\n-    log_debug(os, container)(\"subsystem_file_line_contents: subsystem path is null\");\n-    return OSCONTAINER_ERROR;\n-  }\n-\n-  stringStream file_path;\n-  file_path.print_raw(c->subsystem_path());\n-  file_path.print_raw(filename);\n-\n-  if (file_path.size() > (MAXPATHLEN-1)) {\n-    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n-    return OSCONTAINER_ERROR;\n-  }\n-  const char* absolute_path = file_path.freeze();\n-  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n-\n-  FILE* fp = os::fopen(absolute_path, \"r\");\n-  if (fp == nullptr) {\n-    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n-    return OSCONTAINER_ERROR;\n-  }\n-\n-  const int buf_len = MAXPATHLEN+1;\n-  char buf[buf_len];\n-  char* line = fgets(buf, buf_len, fp);\n-  if (line == nullptr) {\n-    log_debug(os, container)(\"Empty file %s\", absolute_path);\n-    fclose(fp);\n-    return OSCONTAINER_ERROR;\n-  }\n-\n-  bool found_match = false;\n-  if (key == nullptr) {\n-    \/\/ File consists of a single line according to caller, with only a value\n-    int matched = sscanf(line, scan_fmt, returnval);\n-    found_match = matched == 1;\n-  } else {\n-    \/\/ File consists of multiple lines in a \"key value\"\n-    \/\/ fashion, we have to find the key.\n-    const int key_len = (int)strlen(key);\n-    for (; line != nullptr; line = fgets(buf, buf_len, fp)) {\n-      char* key_substr = strstr(line, key);\n-      char after_key = line[key_len];\n-      if (key_substr == line\n-          && isspace(after_key) != 0\n-          && after_key != '\\n') {\n-        \/\/ Skip key, skip space\n-        const char* value_substr = line + key_len + 1;\n-        int matched = sscanf(value_substr, scan_fmt, returnval);\n-        found_match = matched == 1;\n-        if (found_match) {\n-          break;\n-        }\n-      }\n-    }\n-  }\n-  fclose(fp);\n-  if (found_match) {\n-    return 0;\n-  }\n-  log_debug(os, container)(\"Type %s (key == %s) not found in file %s\", scan_fmt,\n-                           (key == nullptr ? \"null\" : key), absolute_path);\n-  return OSCONTAINER_ERROR;\n-}\n-PRAGMA_DIAG_POP\n-\n-\/\/ log_fmt can be different than scan_fmt. For example\n-\/\/ cpu_period() for cgv2 uses log_fmt='%d' and scan_fmt='%*s %d'\n-#define GET_CONTAINER_INFO(return_type, subsystem, filename,              \\\n-                           logstring, log_fmt, scan_fmt, variable)        \\\n-  return_type variable;                                                   \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                     filename,                            \\\n-                                     nullptr,                             \\\n-                                     scan_fmt,                            \\\n-                                     &variable);                          \\\n-  if (err != 0) {                                                         \\\n-    log_trace(os, container)(logstring \"%d\", OSCONTAINER_ERROR);          \\\n-    return (return_type) OSCONTAINER_ERROR;                               \\\n-  }                                                                       \\\n-                                                                          \\\n-  log_trace(os, container)(logstring log_fmt, variable);                  \\\n+#define CONTAINER_READ_NUMBER_CHECKED(controller, filename, log_string, retval)       \\\n+{                                                                                     \\\n+  bool is_ok;                                                                         \\\n+  is_ok = controller->read_number(filename, &retval);                                 \\\n+  if (!is_ok) {                                                                       \\\n+    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);            \\\n+    return OSCONTAINER_ERROR;                                                         \\\n+  }                                                                                   \\\n+  log_trace(os, container)(log_string \" is: \" JULONG_FORMAT, retval);                 \\\n@@ -182,14 +83,9 @@\n-#define GET_CONTAINER_INFO_CPTR(return_type, subsystem, filename,         \\\n-                               logstring, scan_fmt, variable, bufsize)    \\\n-  char variable[bufsize];                                                 \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                     filename,                            \\\n-                                     nullptr,                             \\\n-                                     scan_fmt,                            \\\n-                                     variable);                           \\\n-  if (err != 0)                                                           \\\n-    return (return_type) nullptr;                                         \\\n-                                                                          \\\n-  log_trace(os, container)(logstring, variable);                          \\\n+#define CONTAINER_READ_NUMBER_CHECKED_MAX(controller, filename, log_string, retval)   \\\n+{                                                                                     \\\n+  bool is_ok;                                                                         \\\n+  is_ok = controller->read_number_handle_max(filename, &retval);                      \\\n+  if (!is_ok) {                                                                       \\\n+    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);            \\\n+    return OSCONTAINER_ERROR;                                                         \\\n+  }                                                                                   \\\n+  log_trace(os, container)(log_string \" is: \" JLONG_FORMAT, retval);                  \\\n@@ -198,14 +94,9 @@\n-#define GET_CONTAINER_INFO_LINE(return_type, controller, filename,        \\\n-                           matchline, logstring, scan_fmt, variable)      \\\n-  return_type variable;                                                   \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(controller,                          \\\n-                                filename,                                 \\\n-                                matchline,                                \\\n-                                scan_fmt,                                 \\\n-                                &variable);                               \\\n-  if (err != 0)                                                           \\\n-    return (return_type) OSCONTAINER_ERROR;                               \\\n-                                                                          \\\n-  log_trace(os, container)(logstring, variable);                          \\\n+#define CONTAINER_READ_STRING_CHECKED(controller, filename, log_string, retval, buf_size) \\\n+{                                                                                         \\\n+  bool is_ok;                                                                             \\\n+  is_ok = controller->read_string(filename, retval, buf_size);                            \\\n+  if (!is_ok) {                                                                           \\\n+    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);                \\\n+    return nullptr;                                                                       \\\n+  }                                                                                       \\\n+  log_trace(os, container)(log_string \" is: %s\", retval);                                 \\\n@@ -214,0 +105,59 @@\n+class CgroupController: public CHeapObj<mtInternal> {\n+  protected:\n+    char* _cgroup_path;\n+    char* _mount_point;\n+  public:\n+    virtual const char* subsystem_path() = 0;\n+    virtual bool is_read_only() = 0;\n+    const char* cgroup_path() { return _cgroup_path; }\n+    const char* mount_point() { return _mount_point; }\n+    virtual bool needs_hierarchy_adjustment() { return false; }\n+\n+    \/* Read a numerical value as unsigned long\n+     *\n+     * returns: false if any error occurred. true otherwise and\n+     * the parsed value is set in the provided julong pointer.\n+     *\/\n+    bool read_number(const char* filename, julong* result);\n+\n+    \/* Convenience method to deal with numbers as well as the string 'max'\n+     * in interface files. Otherwise same as read_number().\n+     *\n+     * returns: false if any error occurred. true otherwise and\n+     * the parsed value (which might be negative) is being set in\n+     * the provided jlong pointer.\n+     *\/\n+    bool read_number_handle_max(const char* filename, jlong* result);\n+\n+    \/* Read a string of at most buf_size - 1 characters from the interface file.\n+     * The provided buffer must be at least buf_size in size so as to account\n+     * for the null terminating character. Callers must ensure that the buffer\n+     * is appropriately in-scope and of sufficient size.\n+     *\n+     * returns: false if any error occured. true otherwise and the passed\n+     * in buffer will contain the first buf_size - 1 characters of the string\n+     * or up to the first new line character ('\\n') whichever comes first.\n+     *\/\n+    bool read_string(const char* filename, char* buf, size_t buf_size);\n+\n+    \/* Read a tuple value as a number. Tuple is: '<first> <second>'.\n+     * Handles 'max' (for unlimited) for any tuple value. This is handy for\n+     * parsing interface files like cpu.max which contain such tuples.\n+     *\n+     * returns: false if any error occurred. true otherwise and the parsed\n+     * value of the appropriate tuple entry set in the provided jlong pointer.\n+     *\/\n+    bool read_numerical_tuple_value(const char* filename, bool use_first, jlong* result);\n+\n+    \/* Read a numerical value from a multi-line interface file. The matched line is\n+     * determined by the provided 'key'. The associated numerical value is being set\n+     * via the passed in julong pointer. Example interface file 'memory.stat'\n+     *\n+     * returns: false if any error occurred. true otherwise and the parsed value is\n+     * being set in the provided julong pointer.\n+     *\/\n+    bool read_numerical_key_value(const char* filename, const char* key, julong* result);\n+\n+  private:\n+    static jlong limit_from_str(char* limit_str);\n+};\n@@ -239,0 +189,1 @@\n+template <class T>\n@@ -241,1 +192,1 @@\n-    CgroupController* _controller;\n+    T* _controller;\n@@ -245,1 +196,1 @@\n-    CachingCgroupController(CgroupController* cont) {\n+    CachingCgroupController(T* cont) {\n@@ -251,1 +202,35 @@\n-    CgroupController* controller() { return _controller; }\n+    T* controller() { return _controller; }\n+};\n+\n+\/\/ Pure virtual class representing version agnostic CPU controllers\n+class CgroupCpuController: public CHeapObj<mtInternal> {\n+  public:\n+    virtual int cpu_quota() = 0;\n+    virtual int cpu_period() = 0;\n+    virtual int cpu_shares() = 0;\n+    virtual bool needs_hierarchy_adjustment() = 0;\n+    virtual bool is_read_only() = 0;\n+    virtual const char* subsystem_path() = 0;\n+    virtual void set_subsystem_path(const char* cgroup_path) = 0;\n+    virtual const char* mount_point() = 0;\n+    virtual const char* cgroup_path() = 0;\n+};\n+\n+\/\/ Pure virtual class representing version agnostic memory controllers\n+class CgroupMemoryController: public CHeapObj<mtInternal> {\n+  public:\n+    virtual jlong read_memory_limit_in_bytes(julong upper_bound) = 0;\n+    virtual jlong memory_usage_in_bytes() = 0;\n+    virtual jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) = 0;\n+    virtual jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) = 0;\n+    virtual jlong memory_soft_limit_in_bytes(julong upper_bound) = 0;\n+    virtual jlong memory_max_usage_in_bytes() = 0;\n+    virtual jlong rss_usage_in_bytes() = 0;\n+    virtual jlong cache_usage_in_bytes() = 0;\n+    virtual void print_version_specific_info(outputStream* st, julong host_mem) = 0;\n+    virtual bool needs_hierarchy_adjustment() = 0;\n+    virtual bool is_read_only() = 0;\n+    virtual const char* subsystem_path() = 0;\n+    virtual void set_subsystem_path(const char* cgroup_path) = 0;\n+    virtual const char* mount_point() = 0;\n+    virtual const char* cgroup_path() = 0;\n@@ -258,1 +243,0 @@\n-    jlong limit_from_str(char* limit_str);\n@@ -260,3 +244,0 @@\n-    virtual int cpu_quota() = 0;\n-    virtual int cpu_period() = 0;\n-    virtual int cpu_shares() = 0;\n@@ -265,4 +246,1 @@\n-    virtual jlong memory_usage_in_bytes() = 0;\n-    virtual jlong memory_and_swap_limit_in_bytes() = 0;\n-    virtual jlong memory_soft_limit_in_bytes() = 0;\n-    virtual jlong memory_max_usage_in_bytes() = 0;\n+    virtual bool is_containerized() = 0;\n@@ -272,1 +250,0 @@\n-    virtual jlong read_memory_limit_in_bytes() = 0;\n@@ -274,4 +251,15 @@\n-    virtual CachingCgroupController* memory_controller() = 0;\n-    virtual CachingCgroupController* cpu_controller() = 0;\n-\n-    virtual void print_version_specific_info(outputStream* st) = 0;\n+    virtual CachingCgroupController<CgroupMemoryController>* memory_controller() = 0;\n+    virtual CachingCgroupController<CgroupCpuController>* cpu_controller() = 0;\n+\n+    int cpu_quota();\n+    int cpu_period();\n+    int cpu_shares();\n+\n+    jlong memory_usage_in_bytes();\n+    jlong memory_and_swap_limit_in_bytes();\n+    jlong memory_and_swap_usage_in_bytes();\n+    jlong memory_soft_limit_in_bytes();\n+    jlong memory_max_usage_in_bytes();\n+    jlong rss_usage_in_bytes();\n+    jlong cache_usage_in_bytes();\n+    void print_version_specific_info(outputStream* st);\n@@ -291,0 +279,1 @@\n+    bool _read_only;            \/\/ whether or not the mount path is mounted read-only\n@@ -301,0 +290,1 @@\n+      _read_only = false;\n@@ -332,1 +322,2 @@\n-                                     char* root_path);\n+                                     char* root_path,\n+                                     bool read_only);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":144,"deletions":153,"binary":false,"changes":297,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"os_linux.hpp\"\n+#include \"cgroupUtil_linux.hpp\"\n+\n+int CgroupUtil::processor_count(CgroupCpuController* cpu_ctrl, int host_cpus) {\n+  assert(host_cpus > 0, \"physical host cpus must be positive\");\n+  int limit_count = host_cpus;\n+  int quota  = cpu_ctrl->cpu_quota();\n+  int period = cpu_ctrl->cpu_period();\n+  int quota_count = 0;\n+  int result = 0;\n+\n+  if (quota > -1 && period > 0) {\n+    quota_count = ceilf((float)quota \/ (float)period);\n+    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n+  }\n+\n+  \/\/ Use quotas\n+  if (quota_count != 0) {\n+    limit_count = quota_count;\n+  }\n+\n+  result = MIN2(host_cpus, limit_count);\n+  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n+  return result;\n+}\n+\n+void CgroupUtil::adjust_controller(CgroupMemoryController* mem) {\n+  if (!mem->needs_hierarchy_adjustment()) {\n+    \/\/ nothing to do\n+    return;\n+  }\n+  log_trace(os, container)(\"Adjusting controller path for memory: %s\", mem->subsystem_path());\n+  assert(mem->cgroup_path() != nullptr, \"invariant\");\n+  char* orig = os::strdup(mem->cgroup_path());\n+  char* cg_path = os::strdup(orig);\n+  char* last_slash;\n+  assert(cg_path[0] == '\/', \"cgroup path must start with '\/'\");\n+  julong phys_mem = os::Linux::physical_memory();\n+  char* limit_cg_path = nullptr;\n+  jlong limit = mem->read_memory_limit_in_bytes(phys_mem);\n+  jlong lowest_limit = phys_mem;\n+  while ((last_slash = strrchr(cg_path, '\/')) != cg_path) {\n+    *last_slash = '\\0'; \/\/ strip path\n+    \/\/ update to shortened path and try again\n+    mem->set_subsystem_path(cg_path);\n+    limit = mem->read_memory_limit_in_bytes(phys_mem);\n+    if (limit >= 0 && limit < lowest_limit) {\n+      lowest_limit = limit;\n+      os::free(limit_cg_path); \/\/ handles nullptr\n+      limit_cg_path = os::strdup(cg_path);\n+    }\n+  }\n+  \/\/ need to check limit at mount point\n+  mem->set_subsystem_path(\"\/\");\n+  limit = mem->read_memory_limit_in_bytes(phys_mem);\n+  if (limit >= 0 && limit < lowest_limit) {\n+    lowest_limit = limit;\n+    os::free(limit_cg_path); \/\/ handles nullptr\n+    limit_cg_path = os::strdup(\"\/\");\n+  }\n+  assert(lowest_limit >= 0, \"limit must be positive\");\n+  if ((julong)lowest_limit != phys_mem) {\n+    \/\/ we've found a lower limit anywhere in the hierarchy,\n+    \/\/ set the path to the limit path\n+    assert(limit_cg_path != nullptr, \"limit path must be set\");\n+    mem->set_subsystem_path(limit_cg_path);\n+    log_trace(os, container)(\"Adjusted controller path for memory to: %s. \"\n+                             \"Lowest limit was: \" JLONG_FORMAT,\n+                             mem->subsystem_path(),\n+                             lowest_limit);\n+  } else {\n+    log_trace(os, container)(\"No lower limit found for memory in hierarchy %s, \"\n+                             \"adjusting to original path %s\",\n+                              mem->mount_point(), orig);\n+    mem->set_subsystem_path(orig);\n+  }\n+  os::free(cg_path);\n+  os::free(orig);\n+  os::free(limit_cg_path);\n+}\n+\n+void CgroupUtil::adjust_controller(CgroupCpuController* cpu) {\n+  if (!cpu->needs_hierarchy_adjustment()) {\n+    \/\/ nothing to do\n+    return;\n+  }\n+  log_trace(os, container)(\"Adjusting controller path for cpu: %s\", cpu->subsystem_path());\n+  assert(cpu->cgroup_path() != nullptr, \"invariant\");\n+  char* orig = os::strdup(cpu->cgroup_path());\n+  char* cg_path = os::strdup(orig);\n+  char* last_slash;\n+  assert(cg_path[0] == '\/', \"cgroup path must start with '\/'\");\n+  int host_cpus = os::Linux::active_processor_count();\n+  int cpus = CgroupUtil::processor_count(cpu, host_cpus);\n+  int lowest_limit = host_cpus;\n+  char* limit_cg_path = nullptr;\n+  while ((last_slash = strrchr(cg_path, '\/')) != cg_path) {\n+    *last_slash = '\\0'; \/\/ strip path\n+    \/\/ update to shortened path and try again\n+    cpu->set_subsystem_path(cg_path);\n+    cpus = CgroupUtil::processor_count(cpu, host_cpus);\n+    if (cpus != host_cpus && cpus < lowest_limit) {\n+      lowest_limit = cpus;\n+      os::free(limit_cg_path); \/\/ handles nullptr\n+      limit_cg_path = os::strdup(cg_path);\n+    }\n+  }\n+  \/\/ need to check limit at mount point\n+  cpu->set_subsystem_path(\"\/\");\n+  cpus = CgroupUtil::processor_count(cpu, host_cpus);\n+  if (cpus != host_cpus && cpus < lowest_limit) {\n+    lowest_limit = cpus;\n+    os::free(limit_cg_path); \/\/ handles nullptr\n+    limit_cg_path = os::strdup(cg_path);\n+  }\n+  assert(lowest_limit >= 0, \"limit must be positive\");\n+  if (lowest_limit != host_cpus) {\n+    \/\/ we've found a lower limit anywhere in the hierarchy,\n+    \/\/ set the path to the limit path\n+    assert(limit_cg_path != nullptr, \"limit path must be set\");\n+    cpu->set_subsystem_path(limit_cg_path);\n+    log_trace(os, container)(\"Adjusted controller path for cpu to: %s. \"\n+                             \"Lowest limit was: %d\",\n+                             cpu->subsystem_path(),\n+                             lowest_limit);\n+  } else {\n+    log_trace(os, container)(\"No lower limit found for cpu in hierarchy %s, \"\n+                             \"adjusting to original path %s\",\n+                              cpu->mount_point(), orig);\n+    cpu->set_subsystem_path(orig);\n+  }\n+  os::free(cg_path);\n+  os::free(orig);\n+  os::free(limit_cg_path);\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CGROUP_UTIL_LINUX_HPP\n+#define CGROUP_UTIL_LINUX_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+\n+class CgroupUtil: AllStatic {\n+\n+  public:\n+    static int processor_count(CgroupCpuController* cpu, int host_cpus);\n+    \/\/ Given a memory controller, adjust its path to a point in the hierarchy\n+    \/\/ that represents the closest memory limit.\n+    static void adjust_controller(CgroupMemoryController* m);\n+    \/\/ Given a cpu controller, adjust its path to a point in the hierarchy\n+    \/\/ that represents the closest cpu limit.\n+    static void adjust_controller(CgroupCpuController* c);\n+};\n+\n+#endif \/\/ CGROUP_UTIL_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.hpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -40,1 +41,9 @@\n-void CgroupV1Controller::set_subsystem_path(char *cgroup_path) {\n+void CgroupV1Controller::set_subsystem_path(const char* cgroup_path) {\n+  if (_cgroup_path != nullptr) {\n+    os::free(_cgroup_path);\n+  }\n+  if (_path != nullptr) {\n+    os::free(_path);\n+    _path = nullptr;\n+  }\n+  _cgroup_path = os::strdup(cgroup_path);\n@@ -54,1 +63,1 @@\n-        char *p = strstr(cgroup_path, _root);\n+        char *p = strstr((char*)cgroup_path, _root);\n@@ -68,8 +77,5 @@\n-\/* uses_mem_hierarchy\n- *\n- * Return whether or not hierarchical cgroup accounting is being\n- * done.\n- *\n- * return:\n- *    A number > 0 if true, or\n- *    OSCONTAINER_ERROR for not supported\n+\/*\n+ * The common case, containers, we have _root == _cgroup_path, and thus set the\n+ * controller path to the _mount_point. This is where the limits are exposed in\n+ * the cgroup pseudo filesystem (at the leaf) and adjustment of the path won't\n+ * be needed for that reason.\n@@ -77,12 +83,3 @@\n-jlong CgroupV1MemoryController::uses_mem_hierarchy() {\n-  GET_CONTAINER_INFO(jlong, this, \"\/memory.use_hierarchy\",\n-                    \"Use Hierarchy is: \", JLONG_FORMAT, JLONG_FORMAT, use_hierarchy);\n-  return use_hierarchy;\n-}\n-\n-void CgroupV1MemoryController::set_subsystem_path(char *cgroup_path) {\n-  CgroupV1Controller::set_subsystem_path(cgroup_path);\n-  jlong hierarchy = uses_mem_hierarchy();\n-  if (hierarchy > 0) {\n-    set_hierarchical(true);\n-  }\n+bool CgroupV1Controller::needs_hierarchy_adjustment() {\n+  assert(_cgroup_path != nullptr, \"sanity\");\n+  return strcmp(_root, _cgroup_path) != 0;\n@@ -91,12 +88,10 @@\n-jlong CgroupV1Subsystem::read_memory_limit_in_bytes() {\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.limit_in_bytes\",\n-                     \"Memory Limit is: \", JULONG_FORMAT, JULONG_FORMAT, memlimit);\n-\n-  if (memlimit >= os::Linux::physical_memory()) {\n-    log_trace(os, container)(\"Non-Hierarchical Memory Limit is: Unlimited\");\n-    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n-    if (mem_controller->is_hierarchical()) {\n-      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", \"hierarchical_memory_limit\",\n-                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, hier_memlimit)\n-      if (hier_memlimit >= os::Linux::physical_memory()) {\n-        log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n+static inline\n+void verbose_log(julong read_mem_limit, julong host_mem) {\n+  if (log_is_enabled(Debug, os, container)) {\n+    jlong mem_limit = (jlong)read_mem_limit; \/\/ account for negative values\n+    if (mem_limit < 0 || read_mem_limit >= host_mem) {\n+      const char *reason;\n+      if (mem_limit == OSCONTAINER_ERROR) {\n+        reason = \"failed\";\n+      } else if (mem_limit == -1) {\n+        reason = \"unlimited\";\n@@ -104,1 +99,4 @@\n-        return (jlong)hier_memlimit;\n+        assert(read_mem_limit >= host_mem, \"Expected read value exceeding host_mem\");\n+        \/\/ Exceeding physical memory is treated as unlimited. This implementation\n+        \/\/ caps it at host_mem since Cg v1 has no value to represent 'max'.\n+        reason = \"ignored\";\n@@ -106,0 +104,2 @@\n+      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n+                               reason, mem_limit, host_mem);\n@@ -107,1 +107,0 @@\n-    return (jlong)-1;\n@@ -109,1 +108,10 @@\n-  else {\n+}\n+\n+jlong CgroupV1MemoryController::read_memory_limit_in_bytes(julong phys_mem) {\n+  julong memlimit;\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.limit_in_bytes\", \"Memory Limit\", memlimit);\n+  if (memlimit >= phys_mem) {\n+    verbose_log(memlimit, phys_mem);\n+    return (jlong)-1;\n+  } else {\n+    verbose_log(memlimit, phys_mem);\n@@ -126,5 +134,3 @@\n-jlong CgroupV1Subsystem::read_mem_swap() {\n-  julong host_total_memsw;\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.memsw.limit_in_bytes\",\n-                     \"Memory and Swap Limit is: \", JULONG_FORMAT, JULONG_FORMAT, memswlimit);\n-  host_total_memsw = os::Linux::host_swap() + os::Linux::physical_memory();\n+jlong CgroupV1MemoryController::read_mem_swap(julong host_total_memsw) {\n+  julong memswlimit;\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", memswlimit);\n@@ -132,12 +138,1 @@\n-    log_trace(os, container)(\"Non-Hierarchical Memory and Swap Limit is: Unlimited\");\n-    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n-    if (mem_controller->is_hierarchical()) {\n-      const char* matchline = \"hierarchical_memsw_limit\";\n-      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", matchline,\n-                             \"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, JULONG_FORMAT, hier_memswlimit)\n-      if (hier_memswlimit >= host_total_memsw) {\n-        log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: Unlimited\");\n-      } else {\n-        return (jlong)hier_memswlimit;\n-      }\n-    }\n+    log_trace(os, container)(\"Memory and Swap Limit is: Unlimited\");\n@@ -150,2 +145,2 @@\n-jlong CgroupV1Subsystem::memory_and_swap_limit_in_bytes() {\n-  jlong memory_swap = read_mem_swap();\n+jlong CgroupV1MemoryController::memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) {\n+  jlong memory_swap = read_mem_swap(host_mem + host_swap);\n@@ -160,1 +155,1 @@\n-    jlong memlimit = read_memory_limit_in_bytes();\n+    jlong memlimit = read_memory_limit_in_bytes(host_mem);\n@@ -171,4 +166,5 @@\n-jlong CgroupV1Subsystem::read_mem_swappiness() {\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.swappiness\",\n-                     \"Swappiness is: \", JULONG_FORMAT, JULONG_FORMAT, swappiness);\n-  return swappiness;\n+static inline\n+jlong memory_swap_usage_impl(CgroupController* ctrl) {\n+  julong memory_swap_usage;\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.memsw.usage_in_bytes\", \"mem swap usage\", memory_swap_usage);\n+  return (jlong)memory_swap_usage;\n@@ -177,4 +173,22 @@\n-jlong CgroupV1Subsystem::memory_soft_limit_in_bytes() {\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.soft_limit_in_bytes\",\n-                     \"Memory Soft Limit is: \", JULONG_FORMAT, JULONG_FORMAT, memsoftlimit);\n-  if (memsoftlimit >= os::Linux::physical_memory()) {\n+jlong CgroupV1MemoryController::memory_and_swap_usage_in_bytes(julong phys_mem, julong host_swap) {\n+  jlong memory_sw_limit = memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n+  jlong memory_limit = read_memory_limit_in_bytes(phys_mem);\n+  if (memory_sw_limit > 0 && memory_limit > 0) {\n+    jlong delta_swap = memory_sw_limit - memory_limit;\n+    if (delta_swap > 0) {\n+      return memory_swap_usage_impl(reader());\n+    }\n+  }\n+  return memory_usage_in_bytes();\n+}\n+\n+jlong CgroupV1MemoryController::read_mem_swappiness() {\n+  julong swappiness;\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.swappiness\", \"Swappiness\", swappiness);\n+  return (jlong)swappiness;\n+}\n+\n+jlong CgroupV1MemoryController::memory_soft_limit_in_bytes(julong phys_mem) {\n+  julong memsoftlimit;\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", memsoftlimit);\n+  if (memsoftlimit >= phys_mem) {\n@@ -188,0 +202,26 @@\n+\/\/ Constructor\n+CgroupV1Subsystem::CgroupV1Subsystem(CgroupV1Controller* cpuset,\n+                      CgroupV1CpuController* cpu,\n+                      CgroupV1Controller* cpuacct,\n+                      CgroupV1Controller* pids,\n+                      CgroupV1MemoryController* memory) :\n+    _cpuset(cpuset),\n+    _cpuacct(cpuacct),\n+    _pids(pids) {\n+  CgroupUtil::adjust_controller(memory);\n+  CgroupUtil::adjust_controller(cpu);\n+  _memory = new CachingCgroupController<CgroupMemoryController>(memory);\n+  _cpu = new CachingCgroupController<CgroupCpuController>(cpu);\n+}\n+\n+bool CgroupV1Subsystem::is_containerized() {\n+  \/\/ containerized iff all required controllers are mounted\n+  \/\/ read-only. See OSContainer::is_containerized() for\n+  \/\/ the full logic.\n+  \/\/\n+  return _memory->controller()->is_read_only() &&\n+         _cpu->controller()->is_read_only() &&\n+         _cpuacct->is_read_only() &&\n+         _cpuset->is_read_only();\n+}\n+\n@@ -197,4 +237,4 @@\n-jlong CgroupV1Subsystem::memory_usage_in_bytes() {\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.usage_in_bytes\",\n-                     \"Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, memusage);\n-  return memusage;\n+jlong CgroupV1MemoryController::memory_usage_in_bytes() {\n+  julong memusage;\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.usage_in_bytes\", \"Memory Usage\", memusage);\n+  return (jlong)memusage;\n@@ -211,4 +251,4 @@\n-jlong CgroupV1Subsystem::memory_max_usage_in_bytes() {\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.max_usage_in_bytes\",\n-                     \"Maximum Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, memmaxusage);\n-  return memmaxusage;\n+jlong CgroupV1MemoryController::memory_max_usage_in_bytes() {\n+  julong memmaxusage;\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", memmaxusage);\n+  return (jlong)memmaxusage;\n@@ -217,0 +257,19 @@\n+jlong CgroupV1MemoryController::rss_usage_in_bytes() {\n+  julong rss;\n+  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"rss\", &rss);\n+  if (!is_ok) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"RSS usage is: \" JULONG_FORMAT, rss);\n+  return (jlong)rss;\n+}\n+\n+jlong CgroupV1MemoryController::cache_usage_in_bytes() {\n+  julong cache;\n+  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"cache\", &cache);\n+  if (!is_ok) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Cache usage is: \" JULONG_FORMAT, cache);\n+  return cache;\n+}\n@@ -218,4 +277,4 @@\n-jlong CgroupV1Subsystem::kernel_memory_usage_in_bytes() {\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.kmem.usage_in_bytes\",\n-                     \"Kernel Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, kmem_usage);\n-  return kmem_usage;\n+jlong CgroupV1MemoryController::kernel_memory_usage_in_bytes() {\n+  julong kmem_usage;\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", kmem_usage);\n+  return (jlong)kmem_usage;\n@@ -224,4 +283,4 @@\n-jlong CgroupV1Subsystem::kernel_memory_limit_in_bytes() {\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.kmem.limit_in_bytes\",\n-                     \"Kernel Memory Limit is: \", JULONG_FORMAT, JULONG_FORMAT, kmem_limit);\n-  if (kmem_limit >= os::Linux::physical_memory()) {\n+jlong CgroupV1MemoryController::kernel_memory_limit_in_bytes(julong phys_mem) {\n+  julong kmem_limit;\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", kmem_limit);\n+  if (kmem_limit >= phys_mem) {\n@@ -233,4 +292,4 @@\n-jlong CgroupV1Subsystem::kernel_memory_max_usage_in_bytes() {\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.kmem.max_usage_in_bytes\",\n-                     \"Maximum Kernel Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, kmem_max_usage);\n-  return kmem_max_usage;\n+jlong CgroupV1MemoryController::kernel_memory_max_usage_in_bytes() {\n+  julong kmem_max_usage;\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", kmem_max_usage);\n+  return (jlong)kmem_max_usage;\n@@ -239,1 +298,1 @@\n-void CgroupV1Subsystem::print_version_specific_info(outputStream* st) {\n+void CgroupV1MemoryController::print_version_specific_info(outputStream* st, julong phys_mem) {\n@@ -241,1 +300,1 @@\n-  jlong kmem_limit = kernel_memory_limit_in_bytes();\n+  jlong kmem_limit = kernel_memory_limit_in_bytes(phys_mem);\n@@ -249,3 +308,3 @@\n-char * CgroupV1Subsystem::cpu_cpuset_cpus() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.cpus\",\n-                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n+char* CgroupV1Subsystem::cpu_cpuset_cpus() {\n+  char cpus[1024];\n+  CONTAINER_READ_STRING_CHECKED(_cpuset, \"\/cpuset.cpus\", \"cpuset.cpus\", cpus, 1024);\n@@ -255,3 +314,3 @@\n-char * CgroupV1Subsystem::cpu_cpuset_memory_nodes() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.mems\",\n-                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n+char* CgroupV1Subsystem::cpu_cpuset_memory_nodes() {\n+  char mems[1024];\n+  CONTAINER_READ_STRING_CHECKED(_cpuset, \"\/cpuset.mems\", \"cpuset.mems\", mems, 1024);\n@@ -271,4 +330,12 @@\n-int CgroupV1Subsystem::cpu_quota() {\n-  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.cfs_quota_us\",\n-                     \"CPU Quota is: \", \"%d\", \"%d\", quota);\n-  return quota;\n+int CgroupV1CpuController::cpu_quota() {\n+  julong quota;\n+  bool is_ok = reader()->read_number(\"\/cpu.cfs_quota_us\", &quota);\n+  if (!is_ok) {\n+    log_trace(os, container)(\"CPU Quota failed: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  \/\/ cast to int since the read value might be negative\n+  \/\/ and we want to avoid logging -1 as a large unsigned value.\n+  int quota_int = (int)quota;\n+  log_trace(os, container)(\"CPU Quota is: %d\", quota_int);\n+  return quota_int;\n@@ -277,4 +344,4 @@\n-int CgroupV1Subsystem::cpu_period() {\n-  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.cfs_period_us\",\n-                     \"CPU Period is: \", \"%d\", \"%d\", period);\n-  return period;\n+int CgroupV1CpuController::cpu_period() {\n+  julong period;\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.cfs_period_us\", \"CPU Period\", period);\n+  return (int)period;\n@@ -293,3 +360,4 @@\n-int CgroupV1Subsystem::cpu_shares() {\n-  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.shares\",\n-                     \"CPU Shares is: \", \"%d\", \"%d\", shares);\n+int CgroupV1CpuController::cpu_shares() {\n+  julong shares;\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.shares\", \"CPU Shares\", shares);\n+  int shares_int = (int)shares;\n@@ -297,5 +365,1 @@\n-  if (shares == 1024) return -1;\n-\n-  return shares;\n-}\n-\n+  if (shares_int == 1024) return -1;\n@@ -303,4 +367,1 @@\n-char* CgroupV1Subsystem::pids_max_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _pids, \"\/pids.max\",\n-                     \"Maximum number of tasks is: %s\", \"%1023s\", pidsmax, 1024);\n-  return os::strdup(pidsmax);\n+  return shares_int;\n@@ -320,2 +381,3 @@\n-  char * pidsmax_str = pids_max_val();\n-  return limit_from_str(pidsmax_str);\n+  jlong pids_max;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(_pids, \"\/pids.max\", \"Maximum number of tasks\", pids_max);\n+  return pids_max;\n@@ -334,3 +396,3 @@\n-  GET_CONTAINER_INFO(jlong, _pids, \"\/pids.current\",\n-                     \"Current number of tasks is: \", JLONG_FORMAT, JLONG_FORMAT, pids_current);\n-  return pids_current;\n+  julong pids_current;\n+  CONTAINER_READ_NUMBER_CHECKED(_pids, \"\/pids.current\", \"Current number of tasks\", pids_current);\n+  return (jlong)pids_current;\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":181,"deletions":119,"binary":false,"changes":300,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -37,2 +38,2 @@\n-    char *_root;\n-    char *_mount_point;\n+    char* _root;\n+    bool _read_only;\n@@ -41,1 +42,1 @@\n-    char *_path;\n+    char* _path;\n@@ -44,2 +45,6 @@\n-    CgroupV1Controller(char *root, char *mountpoint) {\n-      _root = os::strdup(root);\n+    CgroupV1Controller(char *root,\n+                       char *mountpoint,\n+                       bool ro) : _root(os::strdup(root)),\n+                                  _read_only(ro),\n+                                  _path(nullptr) {\n+      _cgroup_path = nullptr;\n@@ -47,1 +52,11 @@\n-      _path = nullptr;\n+    }\n+    \/\/ Shallow copy constructor\n+    CgroupV1Controller(const CgroupV1Controller& o) : _root(o._root),\n+                                                      _read_only(o._read_only),\n+                                                      _path(o._path) {\n+      _cgroup_path = o._cgroup_path;\n+      _mount_point = o._mount_point;\n+    }\n+    ~CgroupV1Controller() {\n+      \/\/ At least one subsystem controller exists with paths to malloc'd path\n+      \/\/ names\n@@ -50,2 +65,4 @@\n-    virtual void set_subsystem_path(char *cgroup_path);\n-    char *subsystem_path() { return _path; }\n+    void set_subsystem_path(const char *cgroup_path);\n+    const char* subsystem_path() override { return _path; }\n+    bool is_read_only() override { return _read_only; }\n+    bool needs_hierarchy_adjustment() override;\n@@ -54,1 +71,1 @@\n-class CgroupV1MemoryController: public CgroupV1Controller {\n+class CgroupV1MemoryController final : public CgroupMemoryController {\n@@ -56,0 +73,3 @@\n+  private:\n+    CgroupV1Controller _reader;\n+    CgroupV1Controller* reader() { return &_reader; }\n@@ -57,2 +77,24 @@\n-    bool is_hierarchical() { return _uses_mem_hierarchy; }\n-    void set_subsystem_path(char *cgroup_path);\n+    void set_subsystem_path(const char *cgroup_path) override {\n+      reader()->set_subsystem_path(cgroup_path);\n+    }\n+    jlong read_memory_limit_in_bytes(julong upper_bound) override;\n+    jlong memory_usage_in_bytes() override;\n+    jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) override;\n+    jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) override;\n+    jlong memory_soft_limit_in_bytes(julong upper_bound) override;\n+    jlong memory_max_usage_in_bytes() override;\n+    jlong rss_usage_in_bytes() override;\n+    jlong cache_usage_in_bytes() override;\n+    jlong kernel_memory_usage_in_bytes();\n+    jlong kernel_memory_limit_in_bytes(julong host_mem);\n+    jlong kernel_memory_max_usage_in_bytes();\n+    void print_version_specific_info(outputStream* st, julong host_mem) override;\n+    bool needs_hierarchy_adjustment() override {\n+      return reader()->needs_hierarchy_adjustment();\n+    }\n+    bool is_read_only() override {\n+      return reader()->is_read_only();\n+    }\n+    const char* subsystem_path() override { return reader()->subsystem_path(); }\n+    const char* mount_point() override { return reader()->mount_point(); }\n+    const char* cgroup_path() override { return reader()->cgroup_path(); }\n@@ -60,6 +102,2 @@\n-    \/* Some container runtimes set limits via cgroup\n-     * hierarchy. If set to true consider also memory.stat\n-     * file if everything else seems unlimited *\/\n-    bool _uses_mem_hierarchy;\n-    jlong uses_mem_hierarchy();\n-    void set_hierarchical(bool value) { _uses_mem_hierarchy = value; }\n+    jlong read_mem_swappiness();\n+    jlong read_mem_swap(julong host_total_memsw);\n@@ -68,2 +106,23 @@\n-    CgroupV1MemoryController(char *root, char *mountpoint) : CgroupV1Controller(root, mountpoint) {\n-      _uses_mem_hierarchy = false;\n+    CgroupV1MemoryController(const CgroupV1Controller& reader)\n+      : _reader(reader) {\n+    }\n+\n+};\n+\n+class CgroupV1CpuController final : public CgroupCpuController {\n+\n+  private:\n+    CgroupV1Controller _reader;\n+    CgroupV1Controller* reader() { return &_reader; }\n+  public:\n+    int cpu_quota() override;\n+    int cpu_period() override;\n+    int cpu_shares() override;\n+    void set_subsystem_path(const char *cgroup_path) override {\n+      reader()->set_subsystem_path(cgroup_path);\n+    }\n+    bool is_read_only() override {\n+      return reader()->is_read_only();\n+    }\n+    const char* subsystem_path() override {\n+      return reader()->subsystem_path();\n@@ -71,0 +130,7 @@\n+    const char* mount_point() override {\n+      return reader()->mount_point();\n+    }\n+    bool needs_hierarchy_adjustment() override {\n+      return reader()->needs_hierarchy_adjustment();\n+    }\n+    const char* cgroup_path() override { return reader()->cgroup_path(); }\n@@ -72,0 +138,3 @@\n+  public:\n+    CgroupV1CpuController(const CgroupV1Controller& reader) : _reader(reader) {\n+    }\n@@ -77,5 +146,5 @@\n-    jlong read_memory_limit_in_bytes();\n-    jlong memory_and_swap_limit_in_bytes();\n-    jlong memory_soft_limit_in_bytes();\n-    jlong memory_usage_in_bytes();\n-    jlong memory_max_usage_in_bytes();\n+    CgroupV1Subsystem(CgroupV1Controller* cpuset,\n+                      CgroupV1CpuController* cpu,\n+                      CgroupV1Controller* cpuacct,\n+                      CgroupV1Controller* pids,\n+                      CgroupV1MemoryController* memory);\n@@ -90,5 +159,0 @@\n-    int cpu_quota();\n-    int cpu_period();\n-\n-    int cpu_shares();\n-\n@@ -97,2 +161,1 @@\n-\n-    void print_version_specific_info(outputStream* st);\n+    bool is_containerized();\n@@ -103,2 +166,2 @@\n-    CachingCgroupController * memory_controller() { return _memory; }\n-    CachingCgroupController * cpu_controller() { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController>* memory_controller() { return _memory; }\n+    CachingCgroupController<CgroupCpuController>* cpu_controller() { return _cpu; }\n@@ -108,1 +171,1 @@\n-    CachingCgroupController* _memory = nullptr;\n+    CachingCgroupController<CgroupMemoryController>* _memory = nullptr;\n@@ -110,1 +173,1 @@\n-    CachingCgroupController* _cpu = nullptr;\n+    CachingCgroupController<CgroupCpuController>* _cpu = nullptr;\n@@ -114,17 +177,0 @@\n-    char * pids_max_val();\n-\n-    jlong read_mem_swappiness();\n-    jlong read_mem_swap();\n-\n-  public:\n-    CgroupV1Subsystem(CgroupV1Controller* cpuset,\n-                      CgroupV1Controller* cpu,\n-                      CgroupV1Controller* cpuacct,\n-                      CgroupV1Controller* pids,\n-                      CgroupV1MemoryController* memory) {\n-      _cpuset = cpuset;\n-      _cpu = new CachingCgroupController(cpu);\n-      _cpuacct = cpuacct;\n-      _pids = pids;\n-      _memory = new CachingCgroupController(memory);\n-    }\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":99,"deletions":53,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -26,0 +26,17 @@\n+#include \"cgroupUtil_linux.hpp\"\n+\n+\/\/ Constructor\n+CgroupV2Controller::CgroupV2Controller(char* mount_path,\n+                                       char *cgroup_path,\n+                                       bool ro) :  _read_only(ro),\n+                                                   _path(construct_path(mount_path, cgroup_path)) {\n+  _cgroup_path = os::strdup(cgroup_path);\n+  _mount_point = os::strdup(mount_path);\n+}\n+\/\/ Shallow copy constructor\n+CgroupV2Controller::CgroupV2Controller(const CgroupV2Controller& o) :\n+                                            _read_only(o._read_only),\n+                                            _path(o._path) {\n+  _cgroup_path = o._cgroup_path;\n+  _mount_point = o._mount_point;\n+}\n@@ -37,3 +54,4 @@\n-int CgroupV2Subsystem::cpu_shares() {\n-  GET_CONTAINER_INFO(int, _unified, \"\/cpu.weight\",\n-                     \"Raw value for CPU Shares is: \", \"%d\", \"%d\", shares);\n+int CgroupV2CpuController::cpu_shares() {\n+  julong shares;\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.weight\", \"Raw value for CPU Shares\", shares);\n+  int shares_int = (int)shares;\n@@ -41,1 +59,1 @@\n-  if (shares == 100) {\n+  if (shares_int == 100) {\n@@ -53,1 +71,1 @@\n-  int x = 262142 * shares - 1;\n+  int x = 262142 * shares_int - 1;\n@@ -85,3 +103,7 @@\n-int CgroupV2Subsystem::cpu_quota() {\n-  char * cpu_quota_str = cpu_quota_val();\n-  int limit = (int)limit_from_str(cpu_quota_str);\n+int CgroupV2CpuController::cpu_quota() {\n+  jlong quota_val;\n+  bool is_ok = reader()->read_numerical_tuple_value(\"\/cpu.max\", true \/* use_first *\/, &quota_val);\n+  if (!is_ok) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  int limit = (int)quota_val;\n@@ -92,4 +114,15 @@\n-char * CgroupV2Subsystem::cpu_cpuset_cpus() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.cpus\",\n-                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n-  return os::strdup(cpus);\n+\/\/ Constructor\n+CgroupV2Subsystem::CgroupV2Subsystem(CgroupV2MemoryController * memory,\n+                                     CgroupV2CpuController* cpu,\n+                                     CgroupV2Controller unified) :\n+                                     _unified(unified) {\n+  CgroupUtil::adjust_controller(memory);\n+  CgroupUtil::adjust_controller(cpu);\n+  _memory = new CachingCgroupController<CgroupMemoryController>(memory);\n+  _cpu = new CachingCgroupController<CgroupCpuController>(cpu);\n+}\n+\n+bool CgroupV2Subsystem::is_containerized() {\n+  return _unified.is_read_only() &&\n+         _memory->controller()->is_read_only() &&\n+         _cpu->controller()->is_read_only();\n@@ -98,4 +131,4 @@\n-char* CgroupV2Subsystem::cpu_quota_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpu.max\",\n-                     \"Raw value for CPU quota is: %s\", \"%1023s %*d\", quota, 1024);\n-  return os::strdup(quota);\n+char* CgroupV2Subsystem::cpu_cpuset_cpus() {\n+  char cpus[1024];\n+  CONTAINER_READ_STRING_CHECKED(unified(), \"\/cpuset.cpus\", \"cpuset.cpus\", cpus, 1024);\n+  return os::strdup(cpus);\n@@ -104,3 +137,3 @@\n-char * CgroupV2Subsystem::cpu_cpuset_memory_nodes() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.mems\",\n-                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n+char* CgroupV2Subsystem::cpu_cpuset_memory_nodes() {\n+  char mems[1024];\n+  CONTAINER_READ_STRING_CHECKED(unified(), \"\/cpuset.mems\", \"cpuset.mems\", mems, 1024);\n@@ -110,3 +143,9 @@\n-int CgroupV2Subsystem::cpu_period() {\n-  GET_CONTAINER_INFO(int, _unified, \"\/cpu.max\",\n-                     \"CPU Period is: \", \"%d\", \"%*s %d\", period);\n+int CgroupV2CpuController::cpu_period() {\n+  jlong period_val;\n+  bool is_ok = reader()->read_numerical_tuple_value(\"\/cpu.max\", false \/* use_first *\/, &period_val);\n+  if (!is_ok) {\n+    log_trace(os, container)(\"CPU Period failed: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  int period = (int)period_val;\n+  log_trace(os, container)(\"CPU Period is: %d\", period);\n@@ -125,4 +164,4 @@\n-jlong CgroupV2Subsystem::memory_usage_in_bytes() {\n-  GET_CONTAINER_INFO(jlong, _unified, \"\/memory.current\",\n-                     \"Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, memusage);\n-  return memusage;\n+jlong CgroupV2MemoryController::memory_usage_in_bytes() {\n+  julong memusage;\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.current\", \"Memory Usage\", memusage);\n+  return (jlong)memusage;\n@@ -131,3 +170,4 @@\n-jlong CgroupV2Subsystem::memory_soft_limit_in_bytes() {\n-  char* mem_soft_limit_str = mem_soft_limit_val();\n-  return limit_from_str(mem_soft_limit_str);\n+jlong CgroupV2MemoryController::memory_soft_limit_in_bytes(julong phys_mem) {\n+  jlong mem_soft_limit;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(reader(), \"\/memory.low\", \"Memory Soft Limit\", mem_soft_limit);\n+  return mem_soft_limit;\n@@ -136,1 +176,1 @@\n-jlong CgroupV2Subsystem::memory_max_usage_in_bytes() {\n+jlong CgroupV2MemoryController::memory_max_usage_in_bytes() {\n@@ -142,4 +182,18 @@\n-char* CgroupV2Subsystem::mem_soft_limit_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.low\",\n-                         \"Memory Soft Limit is: %s\", \"%1023s\", mem_soft_limit_str, 1024);\n-  return os::strdup(mem_soft_limit_str);\n+jlong CgroupV2MemoryController::rss_usage_in_bytes() {\n+  julong rss;\n+  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"anon\", &rss);\n+  if (!is_ok) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"RSS usage is: \" JULONG_FORMAT, rss);\n+  return (jlong)rss;\n+}\n+\n+jlong CgroupV2MemoryController::cache_usage_in_bytes() {\n+  julong cache;\n+  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"file\", &cache);\n+  if (!is_ok) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  log_trace(os, container)(\"Cache usage is: \" JULONG_FORMAT, cache);\n+  return (jlong)cache;\n@@ -153,3 +207,5 @@\n-jlong CgroupV2Subsystem::memory_and_swap_limit_in_bytes() {\n-  char* mem_swp_limit_str = mem_swp_limit_val();\n-  if (mem_swp_limit_str == nullptr) {\n+jlong CgroupV2MemoryController::memory_and_swap_limit_in_bytes(julong phys_mem,\n+                                                               julong host_swap \/* unused in cg v2 *\/) {\n+  jlong swap_limit;\n+  bool is_ok = reader()->read_number_handle_max(\"\/memory.swap.max\", &swap_limit);\n+  if (!is_ok) {\n@@ -157,1 +213,1 @@\n-    log_trace(os, container)(\"Memory and Swap Limit is: %d\", OSCONTAINER_ERROR);\n+    log_trace(os, container)(\"Swap Limit failed: %d\", OSCONTAINER_ERROR);\n@@ -159,1 +215,1 @@\n-    return read_memory_limit_in_bytes();\n+    return read_memory_limit_in_bytes(phys_mem);\n@@ -161,1 +217,1 @@\n-  jlong swap_limit = limit_from_str(mem_swp_limit_str);\n+  log_trace(os, container)(\"Swap Limit is: \" JLONG_FORMAT, swap_limit);\n@@ -163,1 +219,1 @@\n-    jlong memory_limit = read_memory_limit_in_bytes();\n+    jlong memory_limit = read_memory_limit_in_bytes(phys_mem);\n@@ -171,4 +227,6 @@\n-char* CgroupV2Subsystem::mem_swp_limit_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.swap.max\",\n-                         \"Memory and Swap Limit is: %s\", \"%1023s\", mem_swp_limit_str, 1024);\n-  return os::strdup(mem_swp_limit_str);\n+\/\/ memory.swap.current : total amount of swap currently used by the cgroup and its descendants\n+static\n+jlong memory_swap_current_value(CgroupV2Controller* ctrl) {\n+  julong swap_current;\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.swap.current\", \"Swap currently used\", swap_current);\n+  return (jlong)swap_current;\n@@ -177,5 +235,14 @@\n-\/\/ memory.swap.current : total amount of swap currently used by the cgroup and its descendants\n-char* CgroupV2Subsystem::mem_swp_current_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.swap.current\",\n-                         \"Swap currently used is: %s\", \"%1023s\", mem_swp_current_str, 1024);\n-  return os::strdup(mem_swp_current_str);\n+jlong CgroupV2MemoryController::memory_and_swap_usage_in_bytes(julong host_mem, julong host_swap) {\n+  jlong memory_usage = memory_usage_in_bytes();\n+  if (memory_usage >= 0) {\n+      jlong swap_current = memory_swap_current_value(reader());\n+      return memory_usage + (swap_current >= 0 ? swap_current : 0);\n+  }\n+  return memory_usage; \/\/ not supported or unlimited case\n+}\n+\n+static\n+jlong memory_limit_value(CgroupV2Controller* ctrl) {\n+  jlong memory_limit;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.max\", \"Memory Limit\", memory_limit);\n+  return memory_limit;\n@@ -184,1 +251,1 @@\n-\/* memory_limit_in_bytes\n+\/* read_memory_limit_in_bytes\n@@ -192,3 +259,2 @@\n-jlong CgroupV2Subsystem::read_memory_limit_in_bytes() {\n-  char * mem_limit_str = mem_limit_val();\n-  jlong limit = limit_from_str(mem_limit_str);\n+jlong CgroupV2MemoryController::read_memory_limit_in_bytes(julong phys_mem) {\n+  jlong limit = memory_limit_value(reader());\n@@ -202,0 +268,16 @@\n+  if (log_is_enabled(Debug, os, container)) {\n+    julong read_limit = (julong)limit; \/\/ avoid signed\/unsigned compare\n+    if (limit < 0 || read_limit >= phys_mem) {\n+      const char* reason;\n+      if (limit == -1) {\n+        reason = \"unlimited\";\n+      } else if (limit == OSCONTAINER_ERROR) {\n+        reason = \"failed\";\n+      } else {\n+        assert(read_limit >= phys_mem, \"Expected mem limit to exceed host memory\");\n+        reason = \"ignored\";\n+      }\n+      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n+                               reason, limit, phys_mem);\n+    }\n+  }\n@@ -205,4 +287,5 @@\n-char* CgroupV2Subsystem::mem_limit_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.max\",\n-                         \"Raw value for memory limit is: %s\", \"%1023s\", mem_limit_str, 1024);\n-  return os::strdup(mem_limit_str);\n+static\n+jlong memory_swap_limit_value(CgroupV2Controller* ctrl) {\n+  jlong swap_limit;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.swap.max\", \"Swap Limit\", swap_limit);\n+  return swap_limit;\n@@ -211,3 +294,11 @@\n-void CgroupV2Subsystem::print_version_specific_info(outputStream* st) {\n-  char* mem_swp_current_str = mem_swp_current_val();\n-  jlong swap_current = limit_from_str(mem_swp_current_str);\n+void CgroupV2Controller::set_subsystem_path(const char* cgroup_path) {\n+  if (_path != nullptr) {\n+    os::free(_path);\n+  }\n+  _path = construct_path(_mount_point, cgroup_path);\n+}\n+\n+\/\/ For cgv2 we only need hierarchy walk if the cgroup path isn't '\/' (root)\n+bool CgroupV2Controller::needs_hierarchy_adjustment() {\n+  return strcmp(_cgroup_path, \"\/\") != 0;\n+}\n@@ -215,2 +306,3 @@\n-  char* mem_swp_limit_str = mem_swp_limit_val();\n-  jlong swap_limit = limit_from_str(mem_swp_limit_str);\n+void CgroupV2MemoryController::print_version_specific_info(outputStream* st, julong phys_mem) {\n+  jlong swap_current = memory_swap_current_value(reader());\n+  jlong swap_limit = memory_swap_limit_value(reader());\n@@ -222,1 +314,1 @@\n-char* CgroupV2Controller::construct_path(char* mount_path, char *cgroup_path) {\n+char* CgroupV2Controller::construct_path(char* mount_path, const char* cgroup_path) {\n@@ -231,6 +323,0 @@\n-char* CgroupV2Subsystem::pids_max_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/pids.max\",\n-                     \"Maximum number of tasks is: %s\", \"%1023s\", pidsmax, 1024);\n-  return os::strdup(pidsmax);\n-}\n-\n@@ -247,2 +333,3 @@\n-  char * pidsmax_str = pids_max_val();\n-  return limit_from_str(pidsmax_str);\n+  jlong pids_max;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(unified(), \"\/pids.max\", \"Maximum number of tasks\", pids_max);\n+  return pids_max;\n@@ -260,2 +347,2 @@\n-  GET_CONTAINER_INFO(jlong, _unified, \"\/pids.current\",\n-                     \"Current number of tasks is: \", JLONG_FORMAT, JLONG_FORMAT, pids_current);\n+  julong pids_current;\n+  CONTAINER_READ_NUMBER_CHECKED(unified(), \"\/pids.current\", \"Current number of tasks\", pids_current);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":161,"deletions":74,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Red Hat Inc.\n+ * Copyright (c) 2020, 2024, Red Hat Inc.\n@@ -29,0 +29,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -32,4 +33,1 @@\n-    \/* the mount path of the cgroup v2 hierarchy *\/\n-    char *_mount_path;\n-    \/* The cgroup path for the controller *\/\n-    char *_cgroup_path;\n+    bool _read_only;\n@@ -39,1 +37,1 @@\n-    static char* construct_path(char* mount_path, char *cgroup_path);\n+    static char* construct_path(char* mount_path, const char *cgroup_path);\n@@ -42,4 +40,5 @@\n-    CgroupV2Controller(char * mount_path, char *cgroup_path) {\n-      _mount_path = mount_path;\n-      _cgroup_path = os::strdup(cgroup_path);\n-      _path = construct_path(mount_path, cgroup_path);\n+    CgroupV2Controller(char* mount_path, char *cgroup_path, bool ro);\n+    \/\/ Shallow copy constructor\n+    CgroupV2Controller(const CgroupV2Controller& o);\n+    ~CgroupV2Controller() {\n+      \/\/ At least one controller exists with references to the paths\n@@ -48,1 +47,64 @@\n-    char *subsystem_path() { return _path; }\n+    const char* subsystem_path() override { return _path; }\n+    bool needs_hierarchy_adjustment() override;\n+    \/\/ Allow for optional updates of the subsystem path\n+    void set_subsystem_path(const char* cgroup_path);\n+    bool is_read_only() override { return _read_only; }\n+};\n+\n+class CgroupV2CpuController: public CgroupCpuController {\n+  private:\n+    CgroupV2Controller _reader;\n+    CgroupV2Controller* reader() { return &_reader; }\n+  public:\n+    CgroupV2CpuController(const CgroupV2Controller& reader) : _reader(reader) {\n+    }\n+    int cpu_quota() override;\n+    int cpu_period() override;\n+    int cpu_shares() override;\n+    bool is_read_only() override {\n+      return reader()->is_read_only();\n+    }\n+    const char* subsystem_path() {\n+      return reader()->subsystem_path();\n+    }\n+    bool needs_hierarchy_adjustment() override {\n+      return reader()->needs_hierarchy_adjustment();\n+    }\n+    void set_subsystem_path(const char* cgroup_path) {\n+      reader()->set_subsystem_path(cgroup_path);\n+    }\n+    const char* mount_point() { return reader()->mount_point(); }\n+    const char* cgroup_path() override { return reader()->cgroup_path(); }\n+};\n+\n+class CgroupV2MemoryController final: public CgroupMemoryController {\n+  private:\n+    CgroupV2Controller _reader;\n+    CgroupV2Controller* reader() { return &_reader; }\n+  public:\n+    CgroupV2MemoryController(const CgroupV2Controller& reader) : _reader(reader) {\n+    }\n+\n+    jlong read_memory_limit_in_bytes(julong upper_bound) override;\n+    jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swp) override;\n+    jlong memory_and_swap_usage_in_bytes(julong host_mem, julong host_swp) override;\n+    jlong memory_soft_limit_in_bytes(julong upper_bound) override;\n+    jlong memory_usage_in_bytes() override;\n+    jlong memory_max_usage_in_bytes() override;\n+    jlong rss_usage_in_bytes() override;\n+    jlong cache_usage_in_bytes() override;\n+    void print_version_specific_info(outputStream* st, julong host_mem) override;\n+    bool is_read_only() override {\n+      return reader()->is_read_only();\n+    }\n+    const char* subsystem_path() {\n+      return reader()->subsystem_path();\n+    }\n+    bool needs_hierarchy_adjustment() override {\n+      return reader()->needs_hierarchy_adjustment();\n+    }\n+    void set_subsystem_path(const char* cgroup_path) {\n+      reader()->set_subsystem_path(cgroup_path);\n+    }\n+    const char* mount_point() { return reader()->mount_point(); }\n+    const char* cgroup_path() override { return reader()->cgroup_path(); }\n@@ -54,1 +116,1 @@\n-    CgroupController* _unified = nullptr;\n+    CgroupV2Controller _unified;\n@@ -56,2 +118,2 @@\n-    CachingCgroupController* _memory = nullptr;\n-    CachingCgroupController* _cpu = nullptr;\n+    CachingCgroupController<CgroupMemoryController>* _memory = nullptr;\n+    CachingCgroupController<CgroupCpuController>* _cpu = nullptr;\n@@ -59,6 +121,1 @@\n-    char *mem_limit_val();\n-    char *mem_swp_limit_val();\n-    char *mem_swp_current_val();\n-    char *mem_soft_limit_val();\n-    char *cpu_quota_val();\n-    char *pids_max_val();\n+    CgroupV2Controller* unified() { return &_unified; }\n@@ -67,14 +124,3 @@\n-    CgroupV2Subsystem(CgroupController * unified) {\n-      _unified = unified;\n-      _memory = new CachingCgroupController(unified);\n-      _cpu = new CachingCgroupController(unified);\n-    }\n-\n-    jlong read_memory_limit_in_bytes();\n-    int cpu_quota();\n-    int cpu_period();\n-    int cpu_shares();\n-    jlong memory_and_swap_limit_in_bytes();\n-    jlong memory_soft_limit_in_bytes();\n-    jlong memory_usage_in_bytes();\n-    jlong memory_max_usage_in_bytes();\n+    CgroupV2Subsystem(CgroupV2MemoryController * memory,\n+                      CgroupV2CpuController* cpu,\n+                      CgroupV2Controller unified);\n@@ -82,4 +128,4 @@\n-    char * cpu_cpuset_cpus();\n-    char * cpu_cpuset_memory_nodes();\n-    jlong pids_max();\n-    jlong pids_current();\n+    char * cpu_cpuset_cpus() override;\n+    char * cpu_cpuset_memory_nodes() override;\n+    jlong pids_max() override;\n+    jlong pids_current() override;\n@@ -87,1 +133,1 @@\n-    void print_version_specific_info(outputStream* st);\n+    bool is_containerized() override;\n@@ -89,1 +135,1 @@\n-    const char * container_type() {\n+    const char * container_type() override {\n@@ -92,2 +138,2 @@\n-    CachingCgroupController * memory_controller() { return _memory; }\n-    CachingCgroupController * cpu_controller() { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController>* memory_controller() override { return _memory; }\n+    CachingCgroupController<CgroupCpuController>* cpu_controller() override { return _cpu; }\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":88,"deletions":42,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -61,2 +61,37 @@\n-\n-  _is_containerized = true;\n+  \/*\n+   * In order to avoid a false positive on is_containerized() on\n+   * Linux systems outside a container *and* to ensure compatibility\n+   * with in-container usage, we detemine is_containerized() by two\n+   * steps:\n+   * 1.) Determine if all the cgroup controllers are mounted read only.\n+   *     If yes, is_containerized() == true. Otherwise, do the fallback\n+   *     in 2.)\n+   * 2.) Query for memory and cpu limits. If any limit is set, we set\n+   *     is_containerized() == true.\n+   *\n+   * Step 1.) covers the basic in container use-cases. Step 2.) ensures\n+   * that limits enforced by other means (e.g. systemd slice) are properly\n+   * detected.\n+   *\/\n+  const char *reason;\n+  bool any_mem_cpu_limit_present = false;\n+  bool controllers_read_only = cgroup_subsystem->is_containerized();\n+  if (controllers_read_only) {\n+    \/\/ in-container case\n+    reason = \" because all controllers are mounted read-only (container case)\";\n+  } else {\n+    \/\/ We can be in one of two cases:\n+    \/\/  1.) On a physical Linux system without any limit\n+    \/\/  2.) On a physical Linux system with a limit enforced by other means (like systemd slice)\n+    any_mem_cpu_limit_present = cgroup_subsystem->memory_limit_in_bytes() > 0 ||\n+                                     os::Linux::active_processor_count() != cgroup_subsystem->active_processor_count();\n+    if (any_mem_cpu_limit_present) {\n+      reason = \" because either a cpu or a memory limit is present\";\n+    } else {\n+      reason = \" because no cpu or memory limit is present\";\n+    }\n+  }\n+  _is_containerized = controllers_read_only || any_mem_cpu_limit_present;\n+  log_debug(os, container)(\"OSContainer::init: is_containerized() = %s%s\",\n+                                                            _is_containerized ? \"true\" : \"false\",\n+                                                            reason);\n@@ -80,0 +115,5 @@\n+jlong OSContainer::memory_and_swap_usage_in_bytes() {\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_and_swap_usage_in_bytes();\n+}\n+\n@@ -95,0 +135,10 @@\n+jlong OSContainer::rss_usage_in_bytes() {\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->rss_usage_in_bytes();\n+}\n+\n+jlong OSContainer::cache_usage_in_bytes() {\n+  assert(cgroup_subsystem != nullptr, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cache_usage_in_bytes();\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.cpp","additions":52,"deletions":2,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+  static jlong memory_and_swap_usage_in_bytes();\n@@ -58,0 +59,2 @@\n+  static jlong rss_usage_in_bytes();\n+  static jlong cache_usage_in_bytes();\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -289,0 +289,54 @@\n+jlong os::total_swap_space() {\n+  if (OSContainer::is_containerized()) {\n+    if (OSContainer::memory_limit_in_bytes() > 0) {\n+      return (jlong)(OSContainer::memory_and_swap_limit_in_bytes() - OSContainer::memory_limit_in_bytes());\n+    }\n+  }\n+  struct sysinfo si;\n+  int ret = sysinfo(&si);\n+  if (ret != 0) {\n+    return -1;\n+  }\n+  return  (jlong)(si.totalswap * si.mem_unit);\n+}\n+\n+static jlong host_free_swap() {\n+  struct sysinfo si;\n+  int ret = sysinfo(&si);\n+  if (ret != 0) {\n+    return -1;\n+  }\n+  return (jlong)(si.freeswap * si.mem_unit);\n+}\n+\n+jlong os::free_swap_space() {\n+  \/\/ os::total_swap_space() might return the containerized limit which might be\n+  \/\/ less than host_free_swap(). The upper bound of free swap needs to be the lower of the two.\n+  jlong host_free_swap_val = MIN2(os::total_swap_space(), host_free_swap());\n+  assert(host_free_swap_val >= 0, \"sysinfo failed?\");\n+  if (OSContainer::is_containerized()) {\n+    jlong mem_swap_limit = OSContainer::memory_and_swap_limit_in_bytes();\n+    jlong mem_limit = OSContainer::memory_limit_in_bytes();\n+    if (mem_swap_limit >= 0 && mem_limit >= 0) {\n+      jlong delta_limit = mem_swap_limit - mem_limit;\n+      if (delta_limit <= 0) {\n+        return 0;\n+      }\n+      jlong mem_swap_usage = OSContainer::memory_and_swap_usage_in_bytes();\n+      jlong mem_usage = OSContainer::memory_usage_in_bytes();\n+      if (mem_swap_usage > 0 && mem_usage > 0) {\n+        jlong delta_usage = mem_swap_usage - mem_usage;\n+        if (delta_usage >= 0) {\n+          jlong free_swap = delta_limit - delta_usage;\n+          return free_swap >= 0 ? free_swap : 0;\n+        }\n+      }\n+    }\n+    \/\/ unlimited or not supported. Fall through to return host value\n+    log_trace(os,container)(\"os::free_swap_space: container_swap_limit=\" JLONG_FORMAT\n+                            \" container_mem_limit=\" JLONG_FORMAT \" returning host value: \" JLONG_FORMAT,\n+                            mem_swap_limit, mem_limit, host_free_swap_val);\n+  }\n+  return host_free_swap_val;\n+}\n+\n@@ -2385,0 +2439,2 @@\n+  OSContainer::print_container_helper(st, OSContainer::rss_usage_in_bytes(), \"rss_usage_in_bytes\");\n+  OSContainer::print_container_helper(st, OSContainer::cache_usage_in_bytes(), \"cache_usage_in_bytes\");\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":56,"deletions":0,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-  friend class CgroupSubsystem;\n@@ -35,1 +34,0 @@\n-  friend class OSContainer;\n@@ -62,1 +60,0 @@\n-  static int active_processor_count();\n@@ -112,0 +109,1 @@\n+  static int active_processor_count();\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -153,0 +153,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsContainerized(void);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -113,0 +113,3 @@\n+#ifdef LINUX\n+#include \"osContainer_linux.hpp\"\n+#endif\n@@ -496,0 +499,9 @@\n+JVM_LEAF(jboolean, JVM_IsContainerized(void))\n+#ifdef LINUX\n+  if (OSContainer::is_containerized()) {\n+    return JNI_TRUE;\n+  }\n+#endif\n+  return JNI_FALSE;\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -326,0 +326,3 @@\n+  static jlong total_swap_space();\n+  static jlong free_swap_space();\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+    @Override\n+    public boolean isContainerized() {\n+        return isContainerized0();\n+    }\n+\n@@ -197,0 +202,1 @@\n+    private static native boolean isContainerized0();\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupMetrics.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,0 +34,5 @@\n+\n+    default boolean isContainerized() {\n+        return false; \/\/ This default impl is never used\n+    }\n+\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystem.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,6 @@\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_platform_CgroupMetrics_isContainerized0(JNIEnv *env, jclass ignored)\n+{\n+    return JVM_IsContainerized();\n+}\n+\n","filename":"src\/java.base\/linux\/native\/libjava\/CgroupMetrics.c","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -74,0 +74,17 @@\n+    \/**\n+     * Determines whether or not the underlying system\n+     * has useful metrics (a.k.a. is containerized).\n+     *\n+     * @implNote\n+     * Note that Metrics on some systems aren't useful.\n+     * For example on a regular Linux system with cgroups\n+     * present, with no limits enforced and not running in\n+     * a container, Metric aren't useful. This can be used\n+     * in order to determine if the system is containerized.\n+     *\n+     * @return true when the JVM runs in containerized mode.\n+     *         false otherwise.\n+     *\n+     *\/\n+    public boolean isContainerized();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/platform\/Metrics.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -350,0 +350,4 @@\n+        if (!c.isContainerized()) {\n+            ostream.println(INDENT + \"System not containerized.\");\n+            return;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,195 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#ifdef LINUX\n-\n-#include \"runtime\/os.hpp\"\n-#include \"cgroupSubsystem_linux.hpp\"\n-#include \"unittest.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-#include <stdio.h>\n-\n-\n-\/\/ Utilities\n-bool file_exists(const char* filename) {\n-  struct stat st;\n-  return os::stat(filename, &st) == 0;\n-}\n-\n-char* temp_file(const char* prefix) {\n-  const testing::TestInfo* test_info = ::testing::UnitTest::GetInstance()->current_test_info();\n-  stringStream path;\n-  path.print_raw(os::get_temp_directory());\n-  path.print_raw(os::file_separator());\n-  path.print(\"%s-test-jdk.pid%d.%s.%s\", prefix, os::current_process_id(),\n-             test_info->test_case_name(), test_info->name());\n-  return path.as_string(true);\n-}\n-\n-void delete_file(const char* filename) {\n-  if (!file_exists(filename)) {\n-    return;\n-  }\n-  int ret = remove(filename);\n-  EXPECT_TRUE(ret == 0 || errno == ENOENT) << \"failed to remove file '\" << filename << \"': \"\n-      << os::strerror(errno) << \" (\" << errno << \")\";\n-}\n-\n-class TestController : public CgroupController {\n-public:\n-  char* subsystem_path() override {\n-    \/\/ The real subsystem is in \/tmp\/, generaed by temp_file()\n-    return (char*)\"\/\";\n-  };\n-};\n-\n-void fill_file(const char* path, const char* content) {\n-  delete_file(path);\n-  FILE* fp = os::fopen(path, \"w\");\n-  if (fp == nullptr) {\n-    return;\n-  }\n-  if (content != nullptr) {\n-    fprintf(fp, \"%s\", content);\n-  }\n-  fclose(fp);\n-}\n-\n-TEST(cgroupTest, SubSystemFileLineContentsMultipleLinesErrorCases) {\n-  TestController my_controller{};\n-  const char* test_file = temp_file(\"cgroups\");\n-  int x = 0;\n-  char s[1024];\n-  int err = 0;\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo \");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_NE(err, 0) << \"Value must not be missing in key\/value case\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"faulty_start foo bar\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_NE(err, 0) << \"Key must be at start\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foof bar\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_NE(err, 0) << \"Key must be exact match\";\n-}\n-\n-TEST(cgroupTest, SubSystemFileLineContentsMultipleLinesSuccessCases) {\n-  TestController my_controller{};\n-  const char* test_file = temp_file(\"cgroups\");\n-  int x = 0;\n-  char s[1024];\n-  int err = 0;\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo bar\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"bar\") << \"Incorrect!\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo\\tbar\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"bar\") << \"Incorrect!\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foof bar\\nfoo car\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"car\");\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo\\ttest\\nfoot car\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"test\");\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo 1\\nfoo car\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"1\");\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"max 10000\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s %*d\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"max\");\n-\n-  x = -3;\n-  fill_file(test_file, \"max 10001\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%*s %d\", &x);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(x, 10001);\n-}\n-\n-TEST(cgroupTest, SubSystemFileLineContentsSingleLine) {\n-  TestController my_controller{};\n-  const char* test_file = temp_file(\"cgroups\");\n-  int x = 0;\n-  char s[1024];\n-  int err = 0;\n-\n-  fill_file(test_file, \"foo\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"foo\");\n-\n-  fill_file(test_file, \"1337\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%d\", &x);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(x, 1337) << \"Wrong value for x\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"1337\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"1337\");\n-\n-  x = -1;\n-  fill_file(test_file, nullptr);\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%d\", &x);\n-  EXPECT_NE(err, 0) << \"Empty file should've failed\";\n-  EXPECT_EQ(x, -1) << \"x was altered\";\n-\n-  jlong y;\n-  fill_file(test_file, \"1337\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, JLONG_FORMAT, &y);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(y, 1337) << \"Wrong value for y\";\n-  julong z;\n-  fill_file(test_file, \"1337\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, JULONG_FORMAT, &z);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(z, (julong)1337) << \"Wrong value for z\";\n-}\n-\n-#endif \/\/ LINUX\n","filename":"test\/hotspot\/gtest\/os\/linux\/test_cgroupSubsystem_linux.cpp","additions":0,"deletions":195,"binary":false,"changes":195,"status":"deleted"},{"patch":"@@ -0,0 +1,557 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef LINUX\n+\n+#include \"runtime\/os.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+#include \"cgroupV1Subsystem_linux.hpp\"\n+#include \"cgroupV2Subsystem_linux.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include <stdio.h>\n+\n+\/\/ for basename\n+#include <libgen.h>\n+\n+typedef struct {\n+  const char* mount_path;\n+  const char* root_path;\n+  const char* cgroup_path;\n+  const char* expected_path;\n+} TestCase;\n+\n+\/\/ Utilities\n+static bool file_exists(const char* filename) {\n+  struct stat st;\n+  return os::stat(filename, &st) == 0;\n+}\n+\n+\/\/ we rely on temp_file returning modifiable memory in resource area.\n+static char* temp_file(const char* prefix) {\n+  const testing::TestInfo* test_info = ::testing::UnitTest::GetInstance()->current_test_info();\n+  stringStream path;\n+  path.print_raw(os::get_temp_directory());\n+  path.print_raw(os::file_separator());\n+  path.print(\"%s-test-jdk.pid%d.%s.%s\", prefix, os::current_process_id(),\n+             test_info->test_case_name(), test_info->name());\n+  return path.as_string(true);\n+}\n+\n+static void delete_file(const char* filename) {\n+  if (!file_exists(filename)) {\n+    return;\n+  }\n+  int ret = remove(filename);\n+  EXPECT_TRUE(ret == 0 || errno == ENOENT) << \"failed to remove file '\" << filename << \"': \"\n+      << os::strerror(errno) << \" (\" << errno << \")\";\n+}\n+\n+class TestController : public CgroupController {\n+private:\n+  char* _path;\n+public:\n+  TestController(char* p): _path(p) {}\n+  const char* subsystem_path() override {\n+    return _path;\n+  };\n+  bool is_read_only() override {\n+    return true; \/\/ doesn't matter\n+  }\n+};\n+\n+static void fill_file(const char* path, const char* content) {\n+  delete_file(path);\n+  FILE* fp = os::fopen(path, \"w\");\n+  if (fp == nullptr) {\n+    return;\n+  }\n+  if (content != nullptr) {\n+    fprintf(fp, \"%s\", content);\n+  }\n+  fclose(fp);\n+}\n+\n+TEST(cgroupTest, read_numerical_key_value_failure_cases) {\n+  char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  constexpr julong bad = 0xBAD;\n+  julong x = bad;\n+\n+  fill_file(test_file, \"foo \");\n+  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"Value is missing in key\/value case, expecting false\";\n+  EXPECT_EQ(bad, x) << \"x must be unchanged\";\n+\n+  x = bad;\n+  fill_file(test_file, \"faulty_start foo 101\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"key must be at the start\";\n+  EXPECT_EQ(bad, x) << \"x must be unchanged\";\n+\n+  x = bad;\n+  fill_file(test_file, nullptr);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"key not in empty file\";\n+  EXPECT_EQ(bad, x) << \"x must be unchanged\";\n+\n+  x = bad;\n+  fill_file(test_file, \"foo\\n\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"key must have a value\";\n+  EXPECT_EQ(bad, x) << \"x must be unchanged\";\n+\n+  x = bad;\n+  fill_file(test_file, \"foof 1002\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"key must be exact match\";\n+  EXPECT_EQ(bad, x) << \"x must be unchanged\";\n+\n+  \/\/ Cleanup\n+  delete_file(test_file);\n+}\n+\n+TEST(cgroupTest, read_numerical_key_value_success_cases) {\n+  char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  constexpr julong bad = 0xBAD;\n+  julong x = bad;\n+\n+  fill_file(test_file, \"foo 100\");\n+  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)100, x);\n+\n+  x = bad;\n+  fill_file(test_file, \"foo\\t111\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)111, x);\n+\n+  x = bad;\n+  fill_file(test_file, \"foo\\nbar 333\\nfoo\\t111\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)111, x);\n+\n+  x = bad;\n+  fill_file(test_file, \"foof 100\\nfoo 133\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)133, x);\n+\n+  x = bad;\n+  fill_file(test_file, \"foo\\t333\\nfoot 999\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)333, x);\n+\n+  x = bad;\n+  fill_file(test_file, \"foo 1\\nfoo car\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)1, x);\n+\n+  \/\/ Cleanup\n+  delete_file(test_file);\n+}\n+\n+TEST(cgroupTest, read_number_null) {\n+  TestController* null_path_controller = new TestController((char*)nullptr);\n+  const char* test_file_path = \"\/not-used\";\n+  constexpr julong bad = 0xBAD;\n+  julong a = bad;\n+  \/\/ null subsystem_path() case\n+  bool is_ok = null_path_controller->read_number(test_file_path, &a);\n+  EXPECT_FALSE(is_ok) << \"Null subsystem path should be an error\";\n+  EXPECT_EQ(bad, a) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, read_string_beyond_max_path) {\n+  char larger_than_max[MAXPATHLEN + 1];\n+  for (int i = 0; i < (MAXPATHLEN); i++) {\n+    larger_than_max[i] = 'A' + (i % 26);\n+  }\n+  larger_than_max[MAXPATHLEN] = '\\0';\n+  TestController* too_large_path_controller = new TestController(larger_than_max);\n+  const char* test_file_path = \"\/file-not-found\";\n+  char foo[1024];\n+  foo[0] = '\\0';\n+  bool is_ok = too_large_path_controller->read_string(test_file_path, foo, 1024);\n+  EXPECT_FALSE(is_ok) << \"Too long path should be an error\";\n+  EXPECT_STREQ(\"\", foo) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, read_number_file_not_exist) {\n+  TestController* unknown_path_ctrl = new TestController((char*)\"\/do\/not\/exist\");\n+  const char* test_file_path = \"\/file-not-found\";\n+  constexpr julong bad = 0xBAD;\n+  julong result = bad;\n+  bool is_ok = unknown_path_ctrl->read_number(test_file_path, &result);\n+  EXPECT_FALSE(is_ok) << \"File not found should be an error\";\n+  EXPECT_EQ(bad, result) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, read_numerical_key_value_null) {\n+  TestController* null_path_controller = new TestController((char*)nullptr);\n+  const char* test_file_path = \"\/not-used\";\n+  const char* key = \"something\";\n+  constexpr julong bad = 0xBAD;\n+  julong a = bad;\n+  \/\/ null subsystem_path() case\n+  bool is_ok = null_path_controller->read_numerical_key_value(test_file_path, key, &a);\n+  EXPECT_FALSE(is_ok) << \"Null subsystem path should be an error\";\n+  EXPECT_EQ(bad, a) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, read_number_tests) {\n+  char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  constexpr julong bad = 0xBAD;\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+  fill_file(test_file, \"8888\");\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  julong foo = bad;\n+  bool ok = controller->read_number(base_with_slash, &foo);\n+  EXPECT_TRUE(ok) << \"Number parsing should have been successful\";\n+  EXPECT_EQ((julong)8888, foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n+\n+  \/\/ Some interface files might have negative values, ensure we can read\n+  \/\/ them and manually cast them as needed.\n+  fill_file(test_file, \"-1\");\n+  foo = bad;\n+  ok = controller->read_number(base_with_slash, &foo);\n+  EXPECT_TRUE(ok) << \"Number parsing should have been successful\";\n+  EXPECT_EQ((jlong)-1, (jlong)foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n+\n+  foo = bad;\n+  fill_file(test_file, nullptr);\n+  ok = controller->read_number(base_with_slash, &foo);\n+  EXPECT_FALSE(ok) << \"Empty file should have failed\";\n+  EXPECT_EQ(bad, foo) << \"foo was altered\";\n+\n+  \/\/ Some interface files have numbers as well as the string\n+  \/\/ 'max', which means unlimited.\n+  jlong result = -10;\n+  fill_file(test_file, \"max\\n\");\n+  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  EXPECT_TRUE(ok) << \"Number parsing for 'max' string should have been successful\";\n+  EXPECT_EQ((jlong)-1, result) << \"'max' means unlimited (-1)\";\n+\n+  result = -10;\n+  fill_file(test_file, \"11114\\n\");\n+  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  EXPECT_TRUE(ok) << \"Number parsing for should have been successful\";\n+  EXPECT_EQ((jlong)11114, result) << \"Incorrect result\";\n+\n+  result = -10;\n+  fill_file(test_file, \"-51114\\n\");\n+  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  EXPECT_TRUE(ok) << \"Number parsing for should have been successful\";\n+  EXPECT_EQ((jlong)-51114, result) << \"Incorrect result\";\n+\n+  delete_file(test_file);\n+}\n+\n+TEST(cgroupTest, read_string_tests) {\n+  char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+  fill_file(test_file, \"foo-bar\");\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  char result[1024];\n+  bool ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_STREQ(\"foo-bar\", result);\n+\n+  result[0] = '\\0';\n+  fill_file(test_file, \"1234\");\n+  ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_STREQ(\"1234\", result);\n+\n+  \/\/ values with a space\n+  result[0] = '\\0';\n+  fill_file(test_file, \"abc def\");\n+  ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_STREQ(\"abc def\", result);\n+\n+  result[0] = '\\0';\n+  fill_file(test_file, \"  \\na\");\n+  ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_STREQ(\"  \", result);\n+\n+  \/\/ only the first line are being returned\n+  result[0] = '\\0';\n+  fill_file(test_file, \"test\\nabc\");\n+  ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_STREQ(\"test\", result);\n+\n+  result[0] = '\\0';\n+  fill_file(test_file, nullptr);\n+  ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_FALSE(ok) << \"Empty file should have failed\";\n+  EXPECT_STREQ(\"\", result) << \"Expected untouched result\";\n+  delete_file(test_file);\n+\n+  \/\/ File contents larger than 1K\n+  \/\/ We only read in the first 1K - 1 bytes\n+  const size_t large_len = 2 * 1024;\n+  char too_large[large_len];\n+  for (size_t i = 0; i < large_len; i++) {\n+    too_large[i] = 'A' + (i % 26);\n+  }\n+  too_large[large_len - 1] = '\\0';\n+  result[0] = '\\0';\n+  fill_file(test_file, too_large);\n+  ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_TRUE(1023 == strlen(result)) << \"Expected only the first 1023 chars to be read in\";\n+  EXPECT_EQ(0, strncmp(too_large, result, 1023));\n+  EXPECT_EQ(result[1023], '\\0') << \"The last character must be the null character\";\n+}\n+\n+TEST(cgroupTest, read_number_tuple_test) {\n+  char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+  fill_file(test_file, \"max 10000\");\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  jlong result = -10;\n+  bool ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, &result);\n+  EXPECT_TRUE(ok) << \"Should be OK to read value\";\n+  EXPECT_EQ((jlong)-1, result) << \"max should be unlimited (-1)\";\n+\n+  result = -10;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, false \/* use_first *\/, &result);\n+  EXPECT_TRUE(ok) << \"Should be OK to read the value\";\n+  EXPECT_EQ((jlong)10000, result);\n+\n+  \/\/ non-max strings\n+  fill_file(test_file, \"abc 10000\");\n+  result = -10;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, &result);\n+  EXPECT_FALSE(ok) << \"abc should not be parsable\";\n+  EXPECT_EQ((jlong)-10, result) << \"result value should be unchanged\";\n+\n+  fill_file(test_file, nullptr);\n+  result = -10;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, &result);\n+  EXPECT_FALSE(ok) << \"Empty file should be an error\";\n+  EXPECT_EQ((jlong)-10, result) << \"result value should be unchanged\";\n+}\n+\n+TEST(cgroupTest, read_numerical_key_beyond_max_path) {\n+  char larger_than_max[MAXPATHLEN + 1];\n+  for (int i = 0; i < (MAXPATHLEN); i++) {\n+    larger_than_max[i] = 'A' + (i % 26);\n+  }\n+  larger_than_max[MAXPATHLEN] = '\\0';\n+  TestController* too_large_path_controller = new TestController(larger_than_max);\n+  const char* test_file_path = \"\/file-not-found\";\n+  const char* key = \"something\";\n+  julong a = 0xBAD;\n+  bool is_ok = too_large_path_controller->read_numerical_key_value(test_file_path, key, &a);\n+  EXPECT_FALSE(is_ok) << \"Too long path should be an error\";\n+  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, read_numerical_key_file_not_exist) {\n+  TestController* unknown_path_ctrl = new TestController((char*)\"\/do\/not\/exist\");\n+  const char* test_file_path = \"\/file-not-found\";\n+  const char* key = \"something\";\n+  julong a = 0xBAD;\n+  bool is_ok = unknown_path_ctrl->read_numerical_key_value(test_file_path, key, &a);\n+  EXPECT_FALSE(is_ok) << \"File not found should be an error\";\n+  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, set_cgroupv1_subsystem_path) {\n+  TestCase host = {\n+    \"\/sys\/fs\/cgroup\/memory\",                                             \/\/ mount_path\n+    \"\/\",                                                                 \/\/ root_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\",                     \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/memory\/user.slice\/user-1000.slice\/user@1000.service\" \/\/ expected_path\n+  };\n+  TestCase container_engine = {\n+    \"\/sys\/fs\/cgroup\/mem\",                            \/\/ mount_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ root_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/mem\"                             \/\/ expected_path\n+  };\n+  int length = 2;\n+  TestCase* testCases[] = { &host,\n+                            &container_engine };\n+  for (int i = 0; i < length; i++) {\n+    CgroupV1Controller* ctrl = new CgroupV1Controller( (char*)testCases[i]->root_path,\n+                                                       (char*)testCases[i]->mount_path,\n+                                                       true \/* read-only mount *\/);\n+    ctrl->set_subsystem_path((char*)testCases[i]->cgroup_path);\n+    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n+  }\n+}\n+\n+TEST(cgroupTest, set_cgroupv2_subsystem_path) {\n+  TestCase at_mount_root = {\n+    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n+    nullptr,                \/\/ root_path, ignored\n+    \"\/\",                    \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\"        \/\/ expected_path\n+  };\n+  TestCase sub_path = {\n+    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n+    nullptr,                \/\/ root_path, ignored\n+    \"\/foobar\",              \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/foobar\" \/\/ expected_path\n+  };\n+  int length = 2;\n+  TestCase* testCases[] = { &at_mount_root,\n+                            &sub_path };\n+  for (int i = 0; i < length; i++) {\n+    CgroupV2Controller* ctrl = new CgroupV2Controller( (char*)testCases[i]->mount_path,\n+                                                       (char*)testCases[i]->cgroup_path,\n+                                                       true \/* read-only mount *\/);\n+    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n+  }\n+}\n+\n+TEST(cgroupTest, cgroupv2_is_hierarchy_walk_needed) {\n+  bool controller_read_only = false; \/\/ value irrelevant;\n+  CgroupV2Controller* test = new CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                    (char*)\"\/\" \/* cgroup_path *\/,\n+                                                    controller_read_only);\n+  EXPECT_FALSE(test->needs_hierarchy_adjustment());\n+  test = new CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                (char*)\"\/bar\" \/* cgroup_path *\/,\n+                                controller_read_only);\n+  EXPECT_TRUE(test->needs_hierarchy_adjustment());\n+  test = new CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\/b\",\n+                                (char*)\"\/a\/b\" \/* cgroup_path *\/,\n+                                controller_read_only);\n+  EXPECT_TRUE(test->needs_hierarchy_adjustment());\n+\n+  CgroupCpuController* test2 = new CgroupV2CpuController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                                            (char*)\"\/\" \/* cgroup_path *\/,\n+                                                                            controller_read_only));\n+  EXPECT_FALSE(test2->needs_hierarchy_adjustment());\n+  test2 = new CgroupV2CpuController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                       (char*)\"\/bar\" \/* cgroup_path *\/,\n+                                                       controller_read_only));\n+  EXPECT_TRUE(test2->needs_hierarchy_adjustment());\n+  test2 = new CgroupV2CpuController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\/b\",\n+                                                       (char*)\"\/a\/b\" \/* cgroup_path *\/,\n+                                                       controller_read_only));\n+  EXPECT_TRUE(test2->needs_hierarchy_adjustment());\n+\n+  CgroupMemoryController* test3 = new CgroupV2MemoryController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                                                  (char*)\"\/\" \/* cgroup_path *\/,\n+                                                                                  controller_read_only));\n+  EXPECT_FALSE(test3->needs_hierarchy_adjustment());\n+  test3 = new CgroupV2MemoryController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                          (char*)\"\/bar\" \/* cgroup_path *\/,\n+                                                          controller_read_only));\n+  EXPECT_TRUE(test3->needs_hierarchy_adjustment());\n+  test3 = new CgroupV2MemoryController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\/b\",\n+                                                          (char*)\"\/a\/b\" \/* cgroup_path *\/,\n+                                                          controller_read_only));\n+  EXPECT_TRUE(test3->needs_hierarchy_adjustment());\n+}\n+\n+TEST(cgroupTest, cgroupv1_is_hierarchy_walk_needed) {\n+  bool controller_read_only = true; \/\/ shouldn't matter;\n+  CgroupV1Controller* test = new CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                    (char*)\"\/sys\/fs\/cgroup\/memory\" \/* mount_path *\/,\n+                                                    controller_read_only);\n+  test->set_subsystem_path((char*)\"\/a\/b\/c\");\n+  EXPECT_FALSE(test->needs_hierarchy_adjustment());\n+  test->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test->needs_hierarchy_adjustment());\n+  test = new CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                (char*)\"\/\"\/* mount_path *\/,\n+                                controller_read_only);\n+  test->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test->needs_hierarchy_adjustment());\n+\n+  CgroupCpuController* test2 = new CgroupV1CpuController(CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                                            (char*)\"\/sys\/fs\/cgroup\/memory\" \/* mount_path *\/,\n+                                                                            controller_read_only));\n+  static_cast<CgroupV1CpuController*>(test2)->set_subsystem_path((char*)\"\/a\/b\/c\");\n+  EXPECT_FALSE(test2->needs_hierarchy_adjustment());\n+  static_cast<CgroupV1CpuController*>(test2)->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test2->needs_hierarchy_adjustment());\n+  test2 = new CgroupV1CpuController(CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                       (char*)\"\/\"\/* mount_path *\/,\n+                                                       controller_read_only));\n+  static_cast<CgroupV1CpuController*>(test2)->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test2->needs_hierarchy_adjustment());\n+\n+  CgroupMemoryController* test3 = new CgroupV1MemoryController(CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                                                  (char*)\"\/sys\/fs\/cgroup\/memory\" \/* mount_path *\/,\n+                                                                                  controller_read_only));\n+  static_cast<CgroupV1MemoryController*>(test3)->set_subsystem_path((char*)\"\/a\/b\/c\");\n+  EXPECT_FALSE(test3->needs_hierarchy_adjustment());\n+  static_cast<CgroupV1MemoryController*>(test3)->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test3->needs_hierarchy_adjustment());\n+  test3 = new CgroupV1MemoryController(CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                          (char*)\"\/\"\/* mount_path *\/,\n+                                                          controller_read_only));\n+  static_cast<CgroupV1MemoryController*>(test3)->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test3->needs_hierarchy_adjustment());\n+}\n+\n+#endif \/\/ LINUX\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":557,"deletions":0,"binary":false,"changes":557,"status":"added"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#ifdef LINUX\n-\n-#include \"cgroupV1Subsystem_linux.hpp\"\n-#include \"cgroupV2Subsystem_linux.hpp\"\n-#include \"unittest.hpp\"\n-\n-typedef struct {\n-  const char* mount_path;\n-  const char* root_path;\n-  const char* cgroup_path;\n-  const char* expected_path;\n-} TestCase;\n-\n-TEST(cgroupTest, set_cgroupv1_subsystem_path) {\n-  TestCase host = {\n-    \"\/sys\/fs\/cgroup\/memory\",                                             \/\/ mount_path\n-    \"\/\",                                                                 \/\/ root_path\n-    \"\/user.slice\/user-1000.slice\/user@1000.service\",                     \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\/memory\/user.slice\/user-1000.slice\/user@1000.service\" \/\/ expected_path\n-  };\n-  TestCase container_engine = {\n-    \"\/sys\/fs\/cgroup\/mem\",                            \/\/ mount_path\n-    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ root_path\n-    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\/mem\"                             \/\/ expected_path\n-  };\n-  int length = 2;\n-  TestCase* testCases[] = { &host,\n-                            &container_engine };\n-  for (int i = 0; i < length; i++) {\n-    CgroupV1Controller* ctrl = new CgroupV1Controller( (char*)testCases[i]->root_path,\n-                                                       (char*)testCases[i]->mount_path);\n-    ctrl->set_subsystem_path((char*)testCases[i]->cgroup_path);\n-    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n-  }\n-}\n-\n-TEST(cgroupTest, set_cgroupv2_subsystem_path) {\n-  TestCase at_mount_root = {\n-    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n-    NULL,                   \/\/ root_path, ignored\n-    \"\/\",                    \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\"        \/\/ expected_path\n-  };\n-  TestCase sub_path = {\n-    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n-    NULL,                   \/\/ root_path, ignored\n-    \"\/foobar\",              \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\/foobar\" \/\/ expected_path\n-  };\n-  int length = 2;\n-  TestCase* testCases[] = { &at_mount_root,\n-                            &sub_path };\n-  for (int i = 0; i < length; i++) {\n-    CgroupV2Controller* ctrl = new CgroupV2Controller( (char*)testCases[i]->mount_path,\n-                                                       (char*)testCases[i]->cgroup_path);\n-    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n-  }\n-}\n-\n-#endif\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux_cgroups.cpp","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -1,78 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test PlainRead\n- * @key cgroups\n- * @requires os.family == \"linux\"\n- * @requires vm.flagless\n- * @library \/testlibrary \/test\/lib\n- * @build jdk.test.whitebox.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI PlainRead\n- *\/\n-\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.Platform;\n-import jdk.test.whitebox.WhiteBox;\n-\n-public class PlainRead {\n-\n-    static public void match(OutputAnalyzer oa, String what, String value) {\n-       oa.shouldMatch(\"^.*\" + what + \" *\" + value + \".*$\");\n-    }\n-\n-    static public void noMatch(OutputAnalyzer oa, String what, String value) {\n-       oa.shouldNotMatch(\"^.*\" + what + \" *\" + value + \".*$\");\n-    }\n-\n-    static final String good_value = \"(\\\\d+|-1|-2|Unlimited)\";\n-    static final String bad_value = \"(failed)\";\n-\n-    static final String[] variables = {\"Memory Limit is:\", \"CPU Quota is:\", \"CPU Period is:\", \"active_processor_count:\"};\n-\n-    static public void isContainer(OutputAnalyzer oa) {\n-        for (String v: variables) {\n-            match(oa, v, good_value);\n-        }\n-        for (String v: variables) {\n-            noMatch(oa, v, bad_value);\n-        }\n-    }\n-\n-    static public void isNotContainer(OutputAnalyzer oa) {\n-       oa.shouldMatch(\"^.*Can't open \/proc\/self\/mountinfo.*$\");\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        WhiteBox wb = WhiteBox.getWhiteBox();\n-        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-Xlog:os+container=trace\", \"-version\");\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-\n-        if (wb.isContainerized()) {\n-            System.out.println(\"Inside a cgroup, testing...\");\n-            isContainer(output);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/PlainRead.java","additions":0,"deletions":78,"binary":false,"changes":78,"status":"deleted"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8261242\n+ * @key cgroups\n+ * @requires os.family == \"linux\"\n+ * @requires vm.flagless\n+ * @library \/testlibrary \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI TestContainerized\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestContainerized {\n+\n+    public static void main(String[] args) throws Exception {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        if (wb.isContainerized()) {\n+            throw new RuntimeException(\"Test failed! Expected not containerized on plain Linux.\");\n+        }\n+        System.out.println(\"Plain linux, no limits. Passed!\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/TestContainerized.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,4 @@\n+            \/\/ see https:\/\/docs.docker.com\/config\/containers\/resource_constraints\/\n+            testSwapMemory(\"200m\", \"200m\", \"\" + 0*MB, \"\" + 0*MB);\n+            testSwapMemory(\"200m\", \"300m\", \"\" + 100*MB, \"\" + 100*MB);\n+\n@@ -213,0 +217,31 @@\n+    private static void testSwapMemory(String memValueToSet, String swapValueToSet, String expectedTotalValue, String expectedFreeValue) throws Exception {\n+        Common.logNewTestCase(\"Memory: --memory = \" + memValueToSet + \" --memory-swap = \" + swapValueToSet);\n+         OutputAnalyzer out = DockerTestUtils.dockerRunJava(\n+                                      commonDockerOpts()\n+                                      .addDockerOpts(\"--memory=\" + memValueToSet)\n+                                      .addDockerOpts(\"--memory-swap=\" + swapValueToSet)\n+                                      .addClassOptions(\"jdk.SwapSpace\"));\n+         out.shouldHaveExitValue(0)\n+            .shouldContain(\"totalSize = \" + expectedTotalValue)\n+            .shouldContain(\"freeSize = \");\n+         List<String> ls = out.asLinesWithoutVMWarnings();\n+         for (String cur : ls) {\n+             int idx = cur.indexOf(\"freeSize = \");\n+             if (idx != -1) {\n+                 int startNbr = idx+11;\n+                 int endNbr = cur.indexOf(' ', startNbr);\n+                 if (endNbr == -1) endNbr = cur.length();\n+                 String freeSizeStr = cur.substring(startNbr, endNbr);\n+                 long freeval = Long.parseLong(freeSizeStr);\n+                 long totalval = Long.parseLong(expectedTotalValue);\n+                 if (0 <= freeval && freeval <= totalval) {\n+                     System.out.println(\"Found freeSize value \" + freeval + \" is fine\");\n+                 } else {\n+                     System.out.println(\"Found freeSize value \" + freeval + \" is bad\");\n+                     throw new Exception(\"Found free size value is bad\");\n+                 }\n+             }\n+         }\n+    }\n+\n+\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestJFREvents.java","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -203,2 +203,2 @@\n-            .shouldMatch(\"Memory and Swap Limit is:.*(\" + expectedTraceValue + \"|-2|0)\")\n-            .shouldNotMatch(\"Memory and Swap Limit is:.*\" + neg2InUnsignedLong);\n+            .shouldMatch(\"(Memory and )?Swap Limit is:.*(\" + expectedTraceValue + \"|-2|0)\")\n+            .shouldNotMatch(\"(Memory and )?Swap Limit is:.*\" + neg2InUnsignedLong);\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMemoryAwareness.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -120,1 +120,3 @@\n-            \"current number of tasks\"\n+            \"current number of tasks\",\n+            \"rss_usage_in_bytes\",\n+            \"cache_usage_in_bytes\"\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMisc.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key cgroups\n+ * @requires os.family == \"linux\"\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @build TestSystemSettings\n+ * @run main\/othervm TestSystemSettings\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestSystemSettings {\n+\n+    public static void main(String[] args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"-XshowSettings:system\", \"-version\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        output.shouldContain(\"System not containerized.\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestSystemSettings.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -72,0 +72,10 @@\n+        testContainerized(m, inContainer);\n+    }\n+\n+    private void testContainerized(Metrics m, boolean inContainer) {\n+        if (m.isContainerized() != inContainer) {\n+            throw new RuntimeException(\"containerized test failed. \" +\n+                                       \"Expected isContainerized()==\" + inContainer +\n+                                       \" but got '\" + m.isContainerized() + \"'\");\n+        }\n+        System.out.println(\"testContainerized() PASSED!\");\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTester.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}