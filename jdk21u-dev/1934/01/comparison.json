{"files":[{"patch":"@@ -614,1 +614,1 @@\n-  char* s_path = subsystem_path();\n+  const char* s_path = subsystem_path();\n@@ -684,1 +684,1 @@\n-  char* s_path = subsystem_path();\n+  const char* s_path = subsystem_path();\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -106,0 +106,3 @@\n+  protected:\n+    char* _cgroup_path;\n+    char* _mount_point;\n@@ -107,1 +110,1 @@\n-    virtual char* subsystem_path() = 0;\n+    virtual const char* subsystem_path() = 0;\n@@ -109,0 +112,3 @@\n+    const char* cgroup_path() { return _cgroup_path; }\n+    const char* mount_point() { return _mount_point; }\n+    virtual bool needs_hierarchy_adjustment() { return false; }\n@@ -205,0 +211,1 @@\n+    virtual bool needs_hierarchy_adjustment() = 0;\n@@ -206,0 +213,4 @@\n+    virtual const char* subsystem_path() = 0;\n+    virtual void set_subsystem_path(const char* cgroup_path) = 0;\n+    virtual const char* mount_point() = 0;\n+    virtual const char* cgroup_path() = 0;\n@@ -219,0 +230,1 @@\n+    virtual bool needs_hierarchy_adjustment() = 0;\n@@ -220,0 +232,4 @@\n+    virtual const char* subsystem_path() = 0;\n+    virtual void set_subsystem_path(const char* cgroup_path) = 0;\n+    virtual const char* mount_point() = 0;\n+    virtual const char* cgroup_path() = 0;\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"os_linux.hpp\"\n@@ -49,0 +50,110 @@\n+\n+void CgroupUtil::adjust_controller(CgroupMemoryController* mem) {\n+  if (!mem->needs_hierarchy_adjustment()) {\n+    \/\/ nothing to do\n+    return;\n+  }\n+  log_trace(os, container)(\"Adjusting controller path for memory: %s\", mem->subsystem_path());\n+  assert(mem->cgroup_path() != nullptr, \"invariant\");\n+  char* orig = os::strdup(mem->cgroup_path());\n+  char* cg_path = os::strdup(orig);\n+  char* last_slash;\n+  assert(cg_path[0] == '\/', \"cgroup path must start with '\/'\");\n+  julong phys_mem = os::Linux::physical_memory();\n+  char* limit_cg_path = nullptr;\n+  jlong limit = mem->read_memory_limit_in_bytes(phys_mem);\n+  jlong lowest_limit = phys_mem;\n+  while ((last_slash = strrchr(cg_path, '\/')) != cg_path) {\n+    *last_slash = '\\0'; \/\/ strip path\n+    \/\/ update to shortened path and try again\n+    mem->set_subsystem_path(cg_path);\n+    limit = mem->read_memory_limit_in_bytes(phys_mem);\n+    if (limit >= 0 && limit < lowest_limit) {\n+      lowest_limit = limit;\n+      os::free(limit_cg_path); \/\/ handles nullptr\n+      limit_cg_path = os::strdup(cg_path);\n+    }\n+  }\n+  \/\/ need to check limit at mount point\n+  mem->set_subsystem_path(\"\/\");\n+  limit = mem->read_memory_limit_in_bytes(phys_mem);\n+  if (limit >= 0 && limit < lowest_limit) {\n+    lowest_limit = limit;\n+    os::free(limit_cg_path); \/\/ handles nullptr\n+    limit_cg_path = os::strdup(\"\/\");\n+  }\n+  assert(lowest_limit >= 0, \"limit must be positive\");\n+  if ((julong)lowest_limit != phys_mem) {\n+    \/\/ we've found a lower limit anywhere in the hierarchy,\n+    \/\/ set the path to the limit path\n+    assert(limit_cg_path != nullptr, \"limit path must be set\");\n+    mem->set_subsystem_path(limit_cg_path);\n+    log_trace(os, container)(\"Adjusted controller path for memory to: %s. \"\n+                             \"Lowest limit was: \" JLONG_FORMAT,\n+                             mem->subsystem_path(),\n+                             lowest_limit);\n+  } else {\n+    log_trace(os, container)(\"No lower limit found for memory in hierarchy %s, \"\n+                             \"adjusting to original path %s\",\n+                              mem->mount_point(), orig);\n+    mem->set_subsystem_path(orig);\n+  }\n+  os::free(cg_path);\n+  os::free(orig);\n+  os::free(limit_cg_path);\n+}\n+\n+void CgroupUtil::adjust_controller(CgroupCpuController* cpu) {\n+  if (!cpu->needs_hierarchy_adjustment()) {\n+    \/\/ nothing to do\n+    return;\n+  }\n+  log_trace(os, container)(\"Adjusting controller path for cpu: %s\", cpu->subsystem_path());\n+  assert(cpu->cgroup_path() != nullptr, \"invariant\");\n+  char* orig = os::strdup(cpu->cgroup_path());\n+  char* cg_path = os::strdup(orig);\n+  char* last_slash;\n+  assert(cg_path[0] == '\/', \"cgroup path must start with '\/'\");\n+  int host_cpus = os::Linux::active_processor_count();\n+  int cpus = CgroupUtil::processor_count(cpu, host_cpus);\n+  int lowest_limit = host_cpus;\n+  char* limit_cg_path = nullptr;\n+  while ((last_slash = strrchr(cg_path, '\/')) != cg_path) {\n+    *last_slash = '\\0'; \/\/ strip path\n+    \/\/ update to shortened path and try again\n+    cpu->set_subsystem_path(cg_path);\n+    cpus = CgroupUtil::processor_count(cpu, host_cpus);\n+    if (cpus != host_cpus && cpus < lowest_limit) {\n+      lowest_limit = cpus;\n+      os::free(limit_cg_path); \/\/ handles nullptr\n+      limit_cg_path = os::strdup(cg_path);\n+    }\n+  }\n+  \/\/ need to check limit at mount point\n+  cpu->set_subsystem_path(\"\/\");\n+  cpus = CgroupUtil::processor_count(cpu, host_cpus);\n+  if (cpus != host_cpus && cpus < lowest_limit) {\n+    lowest_limit = cpus;\n+    os::free(limit_cg_path); \/\/ handles nullptr\n+    limit_cg_path = os::strdup(cg_path);\n+  }\n+  assert(lowest_limit >= 0, \"limit must be positive\");\n+  if (lowest_limit != host_cpus) {\n+    \/\/ we've found a lower limit anywhere in the hierarchy,\n+    \/\/ set the path to the limit path\n+    assert(limit_cg_path != nullptr, \"limit path must be set\");\n+    cpu->set_subsystem_path(limit_cg_path);\n+    log_trace(os, container)(\"Adjusted controller path for cpu to: %s. \"\n+                             \"Lowest limit was: %d\",\n+                             cpu->subsystem_path(),\n+                             lowest_limit);\n+  } else {\n+    log_trace(os, container)(\"No lower limit found for cpu in hierarchy %s, \"\n+                             \"adjusting to original path %s\",\n+                              cpu->mount_point(), orig);\n+    cpu->set_subsystem_path(orig);\n+  }\n+  os::free(cg_path);\n+  os::free(orig);\n+  os::free(limit_cg_path);\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":111,"deletions":0,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -35,0 +35,6 @@\n+    \/\/ Given a memory controller, adjust its path to a point in the hierarchy\n+    \/\/ that represents the closest memory limit.\n+    static void adjust_controller(CgroupMemoryController* m);\n+    \/\/ Given a cpu controller, adjust its path to a point in the hierarchy\n+    \/\/ that represents the closest cpu limit.\n+    static void adjust_controller(CgroupCpuController* c);\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,9 @@\n-void CgroupV1Controller::set_subsystem_path(char *cgroup_path) {\n+void CgroupV1Controller::set_subsystem_path(const char* cgroup_path) {\n+  if (_cgroup_path != nullptr) {\n+    os::free(_cgroup_path);\n+  }\n+  if (_path != nullptr) {\n+    os::free(_path);\n+    _path = nullptr;\n+  }\n+  _cgroup_path = os::strdup(cgroup_path);\n@@ -55,1 +63,1 @@\n-        char *p = strstr(cgroup_path, _root);\n+        char *p = strstr((char*)cgroup_path, _root);\n@@ -69,8 +77,5 @@\n-\/* uses_mem_hierarchy\n- *\n- * Return whether or not hierarchical cgroup accounting is being\n- * done.\n- *\n- * return:\n- *    A number > 0 if true, or\n- *    OSCONTAINER_ERROR for not supported\n+\/*\n+ * The common case, containers, we have _root == _cgroup_path, and thus set the\n+ * controller path to the _mount_point. This is where the limits are exposed in\n+ * the cgroup pseudo filesystem (at the leaf) and adjustment of the path won't\n+ * be needed for that reason.\n@@ -78,12 +83,3 @@\n-jlong CgroupV1MemoryController::uses_mem_hierarchy() {\n-  julong use_hierarchy;\n-  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.use_hierarchy\", \"Use Hierarchy\", use_hierarchy);\n-  return (jlong)use_hierarchy;\n-}\n-\n-void CgroupV1MemoryController::set_subsystem_path(char *cgroup_path) {\n-  reader()->set_subsystem_path(cgroup_path);\n-  jlong hierarchy = uses_mem_hierarchy();\n-  if (hierarchy > 0) {\n-    set_hierarchical(true);\n-  }\n+bool CgroupV1Controller::needs_hierarchy_adjustment() {\n+  assert(_cgroup_path != nullptr, \"sanity\");\n+  return strcmp(_root, _cgroup_path) != 0;\n@@ -118,14 +114,0 @@\n-    log_trace(os, container)(\"Non-Hierarchical Memory Limit is: Unlimited\");\n-    if (is_hierarchical()) {\n-      julong hier_memlimit;\n-      bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"hierarchical_memory_limit\", &hier_memlimit);\n-      if (!is_ok) {\n-        return OSCONTAINER_ERROR;\n-      }\n-      log_trace(os, container)(\"Hierarchical Memory Limit is: \" JULONG_FORMAT, hier_memlimit);\n-      if (hier_memlimit < phys_mem) {\n-        verbose_log(hier_memlimit, phys_mem);\n-        return (jlong)hier_memlimit;\n-      }\n-      log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n-    }\n@@ -153,1 +135,0 @@\n-  julong hier_memswlimit;\n@@ -157,16 +138,1 @@\n-    log_trace(os, container)(\"Non-Hierarchical Memory and Swap Limit is: Unlimited\");\n-    if (is_hierarchical()) {\n-      const char* matchline = \"hierarchical_memsw_limit\";\n-      bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\",\n-                                                           matchline,\n-                                                           &hier_memswlimit);\n-      if (!is_ok) {\n-        return OSCONTAINER_ERROR;\n-      }\n-      log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: \" JULONG_FORMAT, hier_memswlimit);\n-      if (hier_memswlimit >= host_total_memsw) {\n-        log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: Unlimited\");\n-      } else {\n-        return (jlong)hier_memswlimit;\n-      }\n-    }\n+    log_trace(os, container)(\"Memory and Swap Limit is: Unlimited\");\n@@ -224,0 +190,15 @@\n+\/\/ Constructor\n+CgroupV1Subsystem::CgroupV1Subsystem(CgroupV1Controller* cpuset,\n+                      CgroupV1CpuController* cpu,\n+                      CgroupV1Controller* cpuacct,\n+                      CgroupV1Controller* pids,\n+                      CgroupV1MemoryController* memory) :\n+    _cpuset(cpuset),\n+    _cpuacct(cpuacct),\n+    _pids(pids) {\n+  CgroupUtil::adjust_controller(memory);\n+  CgroupUtil::adjust_controller(cpu);\n+  _memory = new CachingCgroupController<CgroupMemoryController>(memory);\n+  _cpu = new CachingCgroupController<CgroupCpuController>(cpu);\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":34,"deletions":53,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -38,1 +39,0 @@\n-    char* _mount_point;\n@@ -48,1 +48,0 @@\n-                                  _mount_point(os::strdup(mountpoint)),\n@@ -51,0 +50,2 @@\n+      _cgroup_path = nullptr;\n+      _mount_point = os::strdup(mountpoint);\n@@ -54,1 +55,0 @@\n-                                                      _mount_point(o._mount_point),\n@@ -57,0 +57,2 @@\n+      _cgroup_path = o._cgroup_path;\n+      _mount_point = o._mount_point;\n@@ -63,2 +65,2 @@\n-    void set_subsystem_path(char *cgroup_path);\n-    char *subsystem_path() override { return _path; }\n+    void set_subsystem_path(const char *cgroup_path);\n+    const char* subsystem_path() override { return _path; }\n@@ -66,0 +68,1 @@\n+    bool needs_hierarchy_adjustment() override;\n@@ -74,2 +77,3 @@\n-    bool is_hierarchical() { return _uses_mem_hierarchy; }\n-    void set_subsystem_path(char *cgroup_path);\n+    void set_subsystem_path(const char *cgroup_path) override {\n+      reader()->set_subsystem_path(cgroup_path);\n+    }\n@@ -87,0 +91,3 @@\n+    bool needs_hierarchy_adjustment() override {\n+      return reader()->needs_hierarchy_adjustment();\n+    }\n@@ -90,0 +97,3 @@\n+    const char* subsystem_path() override { return reader()->subsystem_path(); }\n+    const char* mount_point() override { return reader()->mount_point(); }\n+    const char* cgroup_path() override { return reader()->cgroup_path(); }\n@@ -91,6 +101,0 @@\n-    \/* Some container runtimes set limits via cgroup\n-     * hierarchy. If set to true consider also memory.stat\n-     * file if everything else seems unlimited *\/\n-    bool _uses_mem_hierarchy;\n-    jlong uses_mem_hierarchy();\n-    void set_hierarchical(bool value) { _uses_mem_hierarchy = value; }\n@@ -102,2 +106,1 @@\n-      : _reader(reader),\n-        _uses_mem_hierarchy(false) {\n+      : _reader(reader) {\n@@ -117,1 +120,1 @@\n-    void set_subsystem_path(char *cgroup_path) {\n+    void set_subsystem_path(const char *cgroup_path) override {\n@@ -123,0 +126,10 @@\n+    const char* subsystem_path() override {\n+      return reader()->subsystem_path();\n+    }\n+    const char* mount_point() override {\n+      return reader()->mount_point();\n+    }\n+    bool needs_hierarchy_adjustment() override {\n+      return reader()->needs_hierarchy_adjustment();\n+    }\n+    const char* cgroup_path() override { return reader()->cgroup_path(); }\n@@ -132,0 +145,6 @@\n+    CgroupV1Subsystem(CgroupV1Controller* cpuset,\n+                      CgroupV1CpuController* cpu,\n+                      CgroupV1Controller* cpuacct,\n+                      CgroupV1Controller* pids,\n+                      CgroupV1MemoryController* memory);\n+\n@@ -157,12 +176,0 @@\n-  public:\n-    CgroupV1Subsystem(CgroupV1Controller* cpuset,\n-                      CgroupV1CpuController* cpu,\n-                      CgroupV1Controller* cpuacct,\n-                      CgroupV1Controller* pids,\n-                      CgroupV1MemoryController* memory) :\n-      _memory(new CachingCgroupController<CgroupMemoryController>(memory)),\n-      _cpuset(cpuset),\n-      _cpu(new CachingCgroupController<CgroupCpuController>(cpu)),\n-      _cpuacct(cpuacct),\n-      _pids(pids) {\n-    }\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":35,"deletions":28,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -28,0 +28,16 @@\n+\/\/ Constructor\n+CgroupV2Controller::CgroupV2Controller(char* mount_path,\n+                                       char *cgroup_path,\n+                                       bool ro) :  _read_only(ro),\n+                                                   _path(construct_path(mount_path, cgroup_path)) {\n+  _cgroup_path = os::strdup(cgroup_path);\n+  _mount_point = os::strdup(mount_path);\n+}\n+\/\/ Shallow copy constructor\n+CgroupV2Controller::CgroupV2Controller(const CgroupV2Controller& o) :\n+                                            _read_only(o._read_only),\n+                                            _path(o._path) {\n+  _cgroup_path = o._cgroup_path;\n+  _mount_point = o._mount_point;\n+}\n+\n@@ -98,0 +114,11 @@\n+\/\/ Constructor\n+CgroupV2Subsystem::CgroupV2Subsystem(CgroupV2MemoryController * memory,\n+                                     CgroupV2CpuController* cpu,\n+                                     CgroupV2Controller unified) :\n+                                     _unified(unified) {\n+  CgroupUtil::adjust_controller(memory);\n+  CgroupUtil::adjust_controller(cpu);\n+  _memory = new CachingCgroupController<CgroupMemoryController>(memory);\n+  _cpu = new CachingCgroupController<CgroupCpuController>(cpu);\n+}\n+\n@@ -258,0 +285,12 @@\n+void CgroupV2Controller::set_subsystem_path(const char* cgroup_path) {\n+  if (_path != nullptr) {\n+    os::free(_path);\n+  }\n+  _path = construct_path(_mount_point, cgroup_path);\n+}\n+\n+\/\/ For cgv2 we only need hierarchy walk if the cgroup path isn't '\/' (root)\n+bool CgroupV2Controller::needs_hierarchy_adjustment() {\n+  return strcmp(_cgroup_path, \"\/\") != 0;\n+}\n+\n@@ -266,1 +305,1 @@\n-char* CgroupV2Controller::construct_path(char* mount_path, char *cgroup_path) {\n+char* CgroupV2Controller::construct_path(char* mount_path, const char* cgroup_path) {\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -32,4 +33,0 @@\n-    \/* the mount path of the cgroup v2 hierarchy *\/\n-    char *_mount_path;\n-    \/* The cgroup path for the controller *\/\n-    char *_cgroup_path;\n@@ -40,1 +37,1 @@\n-    static char* construct_path(char* mount_path, char *cgroup_path);\n+    static char* construct_path(char* mount_path, const char *cgroup_path);\n@@ -43,7 +40,1 @@\n-    CgroupV2Controller(char* mount_path,\n-                       char *cgroup_path,\n-                       bool ro) :  _mount_path(os::strdup(mount_path)),\n-                                   _cgroup_path(os::strdup(cgroup_path)),\n-                                   _read_only(ro),\n-                                   _path(construct_path(mount_path, cgroup_path)) {\n-    }\n+    CgroupV2Controller(char* mount_path, char *cgroup_path, bool ro);\n@@ -51,6 +42,1 @@\n-    CgroupV2Controller(const CgroupV2Controller& o) :\n-                                            _mount_path(o._mount_path),\n-                                            _cgroup_path(o._cgroup_path),\n-                                            _read_only(o._read_only),\n-                                            _path(o._path) {\n-    }\n+    CgroupV2Controller(const CgroupV2Controller& o);\n@@ -61,1 +47,4 @@\n-    char *subsystem_path() override { return _path; }\n+    const char* subsystem_path() override { return _path; }\n+    bool needs_hierarchy_adjustment() override;\n+    \/\/ Allow for optional updates of the subsystem path\n+    void set_subsystem_path(const char* cgroup_path);\n@@ -78,0 +67,11 @@\n+    const char* subsystem_path() override {\n+      return reader()->subsystem_path();\n+    }\n+    bool needs_hierarchy_adjustment() override {\n+      return reader()->needs_hierarchy_adjustment();\n+    }\n+    void set_subsystem_path(const char* cgroup_path) override {\n+      reader()->set_subsystem_path(cgroup_path);\n+    }\n+    const char* mount_point() override { return reader()->mount_point(); }\n+    const char* cgroup_path() override { return reader()->cgroup_path(); }\n@@ -99,0 +99,11 @@\n+    const char* subsystem_path() override {\n+      return reader()->subsystem_path();\n+    }\n+    bool needs_hierarchy_adjustment() override {\n+      return reader()->needs_hierarchy_adjustment();\n+    }\n+    void set_subsystem_path(const char* cgroup_path) override {\n+      reader()->set_subsystem_path(cgroup_path);\n+    }\n+    const char* mount_point() override { return reader()->mount_point(); }\n+    const char* cgroup_path() override { return reader()->cgroup_path(); }\n@@ -112,1 +123,1 @@\n-    CgroupV2Subsystem(CgroupV2MemoryController* memory,\n+    CgroupV2Subsystem(CgroupV2MemoryController * memory,\n@@ -114,5 +125,1 @@\n-                      CgroupV2Controller unified) :\n-        _unified(unified),\n-        _memory(new CachingCgroupController<CgroupMemoryController>(memory)),\n-        _cpu(new CachingCgroupController<CgroupCpuController>(cpu)) {\n-    }\n+                      CgroupV2Controller unified);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":32,"deletions":25,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-  char* subsystem_path() override {\n+  const char* subsystem_path() override {\n@@ -473,0 +473,84 @@\n+TEST(cgroupTest, cgroupv2_is_hierarchy_walk_needed) {\n+  bool controller_read_only = false; \/\/ value irrelevant;\n+  CgroupV2Controller* test = new CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                    (char*)\"\/\" \/* cgroup_path *\/,\n+                                                    controller_read_only);\n+  EXPECT_FALSE(test->needs_hierarchy_adjustment());\n+  test = new CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                (char*)\"\/bar\" \/* cgroup_path *\/,\n+                                controller_read_only);\n+  EXPECT_TRUE(test->needs_hierarchy_adjustment());\n+  test = new CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\/b\",\n+                                (char*)\"\/a\/b\" \/* cgroup_path *\/,\n+                                controller_read_only);\n+  EXPECT_TRUE(test->needs_hierarchy_adjustment());\n+\n+  CgroupCpuController* test2 = new CgroupV2CpuController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                                            (char*)\"\/\" \/* cgroup_path *\/,\n+                                                                            controller_read_only));\n+  EXPECT_FALSE(test2->needs_hierarchy_adjustment());\n+  test2 = new CgroupV2CpuController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                       (char*)\"\/bar\" \/* cgroup_path *\/,\n+                                                       controller_read_only));\n+  EXPECT_TRUE(test2->needs_hierarchy_adjustment());\n+  test2 = new CgroupV2CpuController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\/b\",\n+                                                       (char*)\"\/a\/b\" \/* cgroup_path *\/,\n+                                                       controller_read_only));\n+  EXPECT_TRUE(test2->needs_hierarchy_adjustment());\n+\n+  CgroupMemoryController* test3 = new CgroupV2MemoryController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                                                  (char*)\"\/\" \/* cgroup_path *\/,\n+                                                                                  controller_read_only));\n+  EXPECT_FALSE(test3->needs_hierarchy_adjustment());\n+  test3 = new CgroupV2MemoryController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\",\n+                                                          (char*)\"\/bar\" \/* cgroup_path *\/,\n+                                                          controller_read_only));\n+  EXPECT_TRUE(test3->needs_hierarchy_adjustment());\n+  test3 = new CgroupV2MemoryController(CgroupV2Controller((char*)\"\/sys\/fs\/cgroup\/b\",\n+                                                          (char*)\"\/a\/b\" \/* cgroup_path *\/,\n+                                                          controller_read_only));\n+  EXPECT_TRUE(test3->needs_hierarchy_adjustment());\n+}\n+\n+TEST(cgroupTest, cgroupv1_is_hierarchy_walk_needed) {\n+  bool controller_read_only = true; \/\/ shouldn't matter;\n+  CgroupV1Controller* test = new CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                    (char*)\"\/sys\/fs\/cgroup\/memory\" \/* mount_path *\/,\n+                                                    controller_read_only);\n+  test->set_subsystem_path((char*)\"\/a\/b\/c\");\n+  EXPECT_FALSE(test->needs_hierarchy_adjustment());\n+  test->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test->needs_hierarchy_adjustment());\n+  test = new CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                (char*)\"\/\"\/* mount_path *\/,\n+                                controller_read_only);\n+  test->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test->needs_hierarchy_adjustment());\n+\n+  CgroupCpuController* test2 = new CgroupV1CpuController(CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                                            (char*)\"\/sys\/fs\/cgroup\/memory\" \/* mount_path *\/,\n+                                                                            controller_read_only));\n+  static_cast<CgroupV1CpuController*>(test2)->set_subsystem_path((char*)\"\/a\/b\/c\");\n+  EXPECT_FALSE(test2->needs_hierarchy_adjustment());\n+  static_cast<CgroupV1CpuController*>(test2)->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test2->needs_hierarchy_adjustment());\n+  test2 = new CgroupV1CpuController(CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                       (char*)\"\/\"\/* mount_path *\/,\n+                                                       controller_read_only));\n+  static_cast<CgroupV1CpuController*>(test2)->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test2->needs_hierarchy_adjustment());\n+\n+  CgroupMemoryController* test3 = new CgroupV1MemoryController(CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                                                  (char*)\"\/sys\/fs\/cgroup\/memory\" \/* mount_path *\/,\n+                                                                                  controller_read_only));\n+  static_cast<CgroupV1MemoryController*>(test3)->set_subsystem_path((char*)\"\/a\/b\/c\");\n+  EXPECT_FALSE(test3->needs_hierarchy_adjustment());\n+  static_cast<CgroupV1MemoryController*>(test3)->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test3->needs_hierarchy_adjustment());\n+  test3 = new CgroupV1MemoryController(CgroupV1Controller((char*)\"\/a\/b\/c\" \/* root *\/,\n+                                                          (char*)\"\/\"\/* mount_path *\/,\n+                                                          controller_read_only));\n+  static_cast<CgroupV1MemoryController*>(test3)->set_subsystem_path((char*)\"\/\");\n+  EXPECT_TRUE(test3->needs_hierarchy_adjustment());\n+}\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":85,"deletions":1,"binary":false,"changes":86,"status":"modified"}]}