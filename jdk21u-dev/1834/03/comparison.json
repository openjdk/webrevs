{"files":[{"patch":"@@ -45,0 +45,1 @@\n+#include \"memory\/oopFactory.hpp\"\n@@ -100,0 +101,6 @@\n+int ClassListParser::parse_classlist(const char* classlist_path, ParseMode parse_mode, TRAPS) {\n+  UnregisteredClasses::initialize(CHECK_0);\n+  ClassListParser parser(classlist_path, parse_mode);\n+  return parser.parse(THREAD); \/\/ returns the number of classes loaded.\n+}\n+\n@@ -393,0 +400,13 @@\n+objArrayOop ClassListParser::get_specified_interfaces(TRAPS) {\n+  const int n = _interfaces->length();\n+  if (n == 0) {\n+    return nullptr;\n+  } else {\n+    objArrayOop array = oopFactory::new_objArray(vmClasses::Class_klass(), n, CHECK_NULL);\n+    for (int i = 0; i < n; i++) {\n+      array->obj_at_put(i, lookup_class_by_id(_interfaces->at(i))->java_mirror());\n+    }\n+    return array;\n+  }\n+}\n+\n@@ -477,1 +497,11 @@\n-  InstanceKlass* k = UnregisteredClasses::load_class(class_name, source_path, CHECK_NULL);\n+  InstanceKlass* specified_super = lookup_class_by_id(_super);\n+  Handle super_class(THREAD, specified_super->java_mirror());\n+  objArrayOop r = get_specified_interfaces(CHECK_NULL);\n+  objArrayHandle interfaces(THREAD, r);\n+  InstanceKlass* k = UnregisteredClasses::load_class(class_name, source_path,\n+                                                     super_class, interfaces, CHECK_NULL);\n+  if (k->java_super() != specified_super) {\n+    error(\"The specified super class %s (id %d) does not match actual super class %s\",\n+          specified_super->external_name(), _super,\n+          k->java_super()->external_name());\n+  }\n@@ -685,43 +715,0 @@\n-\n-\n-InstanceKlass* ClassListParser::lookup_super_for_current_class(Symbol* super_name) {\n-  if (!is_loading_from_source()) {\n-    return nullptr;\n-  }\n-\n-  InstanceKlass* k = lookup_class_by_id(super());\n-  if (super_name != k->name()) {\n-    error(\"The specified super class %s (id %d) does not match actual super class %s\",\n-          k->name()->as_klass_external_name(), super(),\n-          super_name->as_klass_external_name());\n-  }\n-  return k;\n-}\n-\n-InstanceKlass* ClassListParser::lookup_interface_for_current_class(Symbol* interface_name) {\n-  if (!is_loading_from_source()) {\n-    return nullptr;\n-  }\n-\n-  const int n = _interfaces->length();\n-  if (n == 0) {\n-    error(\"Class %s implements the interface %s, but no interface has been specified in the input line\",\n-          _class_name, interface_name->as_klass_external_name());\n-    ShouldNotReachHere();\n-  }\n-\n-  int i;\n-  for (i=0; i<n; i++) {\n-    InstanceKlass* k = lookup_class_by_id(_interfaces->at(i));\n-    if (interface_name == k->name()) {\n-      return k;\n-    }\n-  }\n-\n-  \/\/ interface_name is not specified by the \"interfaces:\" keyword.\n-  print_specified_interfaces();\n-  error(\"The interface %s implemented by class %s does not match any of the specified interface IDs\",\n-        interface_name->as_klass_external_name(), _class_name);\n-  ShouldNotReachHere();\n-  return nullptr;\n-}\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":31,"deletions":44,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,0 +137,1 @@\n+  objArrayOop get_specified_interfaces(TRAPS);\n@@ -139,4 +140,1 @@\n-  static int parse_classlist(const char* classlist_path, ParseMode parse_mode, TRAPS) {\n-    ClassListParser parser(classlist_path, parse_mode);\n-    return parser.parse(THREAD); \/\/ returns the number of classes loaded.\n-  }\n+  static int parse_classlist(const char* classlist_path, ParseMode parse_mode, TRAPS);\n@@ -195,5 +193,0 @@\n-  \/\/ Look up the super or interface of the current class being loaded\n-  \/\/ (in this->load_current_class()).\n-  InstanceKlass* lookup_super_for_current_class(Symbol* super_name);\n-  InstanceKlass* lookup_interface_for_current_class(Symbol* interface_name);\n-\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -42,0 +42,11 @@\n+InstanceKlass* UnregisteredClasses::_UnregisteredClassLoader_klass = nullptr;\n+\n+void UnregisteredClasses::initialize(TRAPS) {\n+  if (_UnregisteredClassLoader_klass == nullptr) {\n+    \/\/ no need for synchronization as this function is called single-threaded.\n+    Symbol* klass_name = SymbolTable::new_symbol(\"jdk\/internal\/misc\/CDS$UnregisteredClassLoader\");\n+    Klass* k = SystemDictionary::resolve_or_fail(klass_name, true, CHECK);\n+    _UnregisteredClassLoader_klass = InstanceKlass::cast(k);\n+  }\n+}\n+\n@@ -45,1 +56,2 @@\n-InstanceKlass* UnregisteredClasses::load_class(Symbol* name, const char* path, TRAPS) {\n+InstanceKlass* UnregisteredClasses::load_class(Symbol* name, const char* path,\n+                                               Handle super_class, objArrayHandle interfaces, TRAPS) {\n@@ -53,0 +65,3 @@\n+  \/\/ Call CDS$UnregisteredClassLoader::load(String name, Class<?> superClass, Class<?>[] interfaces)\n+  Symbol* methodName = SymbolTable::new_symbol(\"load\");\n+  Symbol* methodSignature = SymbolTable::new_symbol(\"(Ljava\/lang\/String;Ljava\/lang\/Class;[Ljava\/lang\/Class;)Ljava\/lang\/Class;\");\n@@ -54,1 +69,1 @@\n-  Handle url_classloader = get_url_classloader(path_symbol, CHECK_NULL);\n+  Handle classloader = get_classloader(path_symbol, CHECK_NULL);\n@@ -58,2 +73,2 @@\n-  JavaCallArguments args(2);\n-  args.set_receiver(url_classloader);\n+  JavaCallArguments args(3);\n+  args.set_receiver(classloader);\n@@ -61,1 +76,2 @@\n-  args.push_int(JNI_FALSE);\n+  args.push_oop(super_class);\n+  args.push_oop(interfaces);\n@@ -63,3 +79,3 @@\n-                          vmClasses::URLClassLoader_klass(),\n-                          vmSymbols::loadClass_name(),\n-                          vmSymbols::string_boolean_class_signature(),\n+                          UnregisteredClassLoader_klass(),\n+                          methodName,\n+                          methodSignature,\n@@ -73,1 +89,1 @@\n-class URLClassLoaderTable : public ResourceHashtable<\n+class UnregisteredClasses::ClassLoaderTable : public ResourceHashtable<\n@@ -78,1 +94,1 @@\n-static URLClassLoaderTable* _url_classloader_table = nullptr;\n+static UnregisteredClasses::ClassLoaderTable* _classloader_table = nullptr;\n@@ -80,1 +96,1 @@\n-Handle UnregisteredClasses::create_url_classloader(Symbol* path, TRAPS) {\n+Handle UnregisteredClasses::create_classloader(Symbol* path, TRAPS) {\n@@ -84,15 +100,5 @@\n-  JavaCalls::call_static(&result,\n-                         vmClasses::jdk_internal_loader_ClassLoaders_klass(),\n-                         vmSymbols::toFileURL_name(),\n-                         vmSymbols::toFileURL_signature(),\n-                         path_string, CHECK_NH);\n-  assert(result.get_type() == T_OBJECT, \"just checking\");\n-  oop url_h = result.get_oop();\n-  objArrayHandle urls = oopFactory::new_objArray_handle(vmClasses::URL_klass(), 1, CHECK_NH);\n-  urls->obj_at_put(0, url_h);\n-\n-  Handle url_classloader = JavaCalls::construct_new_instance(\n-                             vmClasses::URLClassLoader_klass(),\n-                             vmSymbols::url_array_classloader_void_signature(),\n-                             urls, Handle(), CHECK_NH);\n-  return url_classloader;\n+  Handle classloader = JavaCalls::construct_new_instance(\n+                           UnregisteredClassLoader_klass(),\n+                           vmSymbols::string_void_signature(),\n+                           path_string, CHECK_NH);\n+  return classloader;\n@@ -101,3 +107,3 @@\n-Handle UnregisteredClasses::get_url_classloader(Symbol* path, TRAPS) {\n-  if (_url_classloader_table == nullptr) {\n-    _url_classloader_table = new (mtClass)URLClassLoaderTable();\n+Handle UnregisteredClasses::get_classloader(Symbol* path, TRAPS) {\n+  if (_classloader_table == nullptr) {\n+    _classloader_table = new (mtClass)ClassLoaderTable();\n@@ -105,3 +111,3 @@\n-  OopHandle* url_classloader_ptr = _url_classloader_table->get(path);\n-  if (url_classloader_ptr != nullptr) {\n-    return Handle(THREAD, (*url_classloader_ptr).resolve());\n+  OopHandle* classloader_ptr = _classloader_table->get(path);\n+  if (classloader_ptr != nullptr) {\n+    return Handle(THREAD, (*classloader_ptr).resolve());\n@@ -109,2 +115,2 @@\n-    Handle url_classloader = create_url_classloader(path, CHECK_NH);\n-    _url_classloader_table->put(path, OopHandle(Universe::vm_global(), url_classloader()));\n+    Handle classloader = create_classloader(path, CHECK_NH);\n+    _classloader_table->put(path, OopHandle(Universe::vm_global(), classloader()));\n@@ -112,1 +118,1 @@\n-    return url_classloader;\n+    return classloader;\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.cpp","additions":42,"deletions":36,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"memory\/allStatic.hpp\"\n@@ -30,0 +31,3 @@\n+class InstanceKlass;\n+class Symbol;\n+\n@@ -32,1 +36,9 @@\n-  static InstanceKlass* load_class(Symbol* h_name, const char* path, TRAPS);\n+  static InstanceKlass* load_class(Symbol* h_name, const char* path,\n+                                   Handle super_class, objArrayHandle interfaces,\n+                                   TRAPS);\n+  static void initialize(TRAPS);\n+  static InstanceKlass* UnregisteredClassLoader_klass() {\n+    return _UnregisteredClassLoader_klass;\n+  }\n+\n+  class ClassLoaderTable;\n@@ -35,2 +47,5 @@\n-  static Handle create_url_classloader(Symbol* path, TRAPS);\n-  static Handle get_url_classloader(Symbol* path, TRAPS);\n+  \/\/ Don't put this in vmClasses as it's used only with CDS dumping.\n+  static InstanceKlass* _UnregisteredClassLoader_klass;\n+\n+  static Handle create_classloader(Symbol* path, TRAPS);\n+  static Handle get_classloader(Symbol* path, TRAPS);\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.hpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -415,10 +415,0 @@\n-#if INCLUDE_CDS\n-  if (DumpSharedSpaces) {\n-    \/\/ Special processing for handling UNREGISTERED shared classes.\n-    InstanceKlass* k = SystemDictionaryShared::lookup_super_for_unregistered_class(class_name,\n-                           super_name, is_superclass);\n-    if (k) {\n-      return k;\n-    }\n-  }\n-#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"cds\/unregisteredClasses.hpp\"\n@@ -334,0 +335,6 @@\n+  if (k == UnregisteredClasses::UnregisteredClassLoader_klass()) {\n+    ResourceMark rm;\n+    log_info(cds)(\"Skipping %s: used only when dumping CDS archive\", k->name()->as_C_string());\n+    return true;\n+  }\n+\n@@ -452,39 +459,0 @@\n-\/\/ This function is called to lookup the super\/interfaces of shared classes for\n-\/\/ unregistered loaders. E.g., SharedClass in the below example\n-\/\/ where \"super:\" (and optionally \"interface:\") have been specified.\n-\/\/\n-\/\/ java\/lang\/Object id: 0\n-\/\/ Interface    id: 2 super: 0 source: cust.jar\n-\/\/ SharedClass  id: 4 super: 0 interfaces: 2 source: cust.jar\n-InstanceKlass* SystemDictionaryShared::lookup_super_for_unregistered_class(\n-    Symbol* class_name, Symbol* super_name, bool is_superclass) {\n-\n-  assert(DumpSharedSpaces, \"only when static dumping\");\n-\n-  if (!ClassListParser::is_parsing_thread()) {\n-    \/\/ Unregistered classes can be created only by ClassListParser::_parsing_thread.\n-\n-    return nullptr;\n-  }\n-\n-  ClassListParser* parser = ClassListParser::instance();\n-  if (parser == nullptr) {\n-    \/\/ We're still loading the well-known classes, before the ClassListParser is created.\n-    return nullptr;\n-  }\n-  if (class_name->equals(parser->current_class_name())) {\n-    \/\/ When this function is called, all the numbered super and interface types\n-    \/\/ must have already been loaded. Hence this function is never recursively called.\n-    if (is_superclass) {\n-      return parser->lookup_super_for_current_class(super_name);\n-    } else {\n-      return parser->lookup_interface_for_current_class(super_name);\n-    }\n-  } else {\n-    \/\/ The VM is not trying to resolve a super type of parser->current_class_name().\n-    \/\/ Instead, it's resolving an error class (because parser->current_class_name() has\n-    \/\/ failed parsing or verification). Don't do anything here.\n-    return nullptr;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":7,"deletions":39,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,1 +146,0 @@\n-  do_klass(URLClassLoader_klass,                        java_net_URLClassLoader                               ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -130,1 +130,0 @@\n-  template(java_net_URLClassLoader,                   \"java\/net\/URLClassLoader\")                  \\\n@@ -789,1 +788,0 @@\n-  template(url_array_classloader_void_signature,            \"([Ljava\/net\/URL;Ljava\/lang\/ClassLoader;)V\")          \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,4 @@\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n@@ -336,0 +340,108 @@\n+\n+    \/**\n+     * This class is used only by native JVM code at CDS dump time for loading\n+     * \"unregistered classes\", which are archived classes that are intended to\n+     * be loaded by custom class loaders during runtime.\n+     * See src\/hotspot\/share\/cds\/unregisteredClasses.cpp.\n+     *\/\n+    private static class UnregisteredClassLoader extends URLClassLoader {\n+        private String currentClassName;\n+        private Class<?> currentSuperClass;\n+        private Class<?>[] currentInterfaces;\n+\n+        \/**\n+         * Used only by native code. Construct an UnregisteredClassLoader for loading\n+         * unregistered classes from the specified file. If the file doesn't exist,\n+         * the exception will be caughted by native code which will print a warning message and continue.\n+         *\n+         * @param fileName path of the the JAR file to load unregistered classes from.\n+         *\/\n+        private UnregisteredClassLoader(String fileName) throws InvalidPathException, IOException {\n+            super(toURLArray(fileName), \/*parent*\/null);\n+            currentClassName = null;\n+            currentSuperClass = null;\n+            currentInterfaces = null;\n+        }\n+\n+        private static URL[] toURLArray(String fileName) throws InvalidPathException, IOException {\n+            if (!((new File(fileName)).exists())) {\n+                throw new IOException(\"No such file: \" + fileName);\n+            }\n+            return new URL[] {\n+                \/\/ Use an intermediate File object to construct a URI\/URL without\n+                \/\/ authority component as URLClassPath can't handle URLs with a UNC\n+                \/\/ server name in the authority component.\n+                Path.of(fileName).toRealPath().toFile().toURI().toURL()\n+            };\n+        }\n+\n+\n+        \/**\n+         * Load the class of the given <code>\/name<code> from the JAR file that was given to\n+         * the constructor of the current UnregisteredClassLoader instance. This class must be\n+         * a direct subclass of <code>superClass<\/code>. This class must be declared to implement\n+         * the specified <code>interfaces<\/code>.\n+         * <p>\n+         * This method must be called in a single threaded context. It will never be recursed (thus\n+         * the asserts)\n+         *\n+         * @param name the name of the class to be loaded.\n+         * @param superClass must not be null. The named class must have a super class.\n+         * @param interfaces could be null if the named class does not implement any interfaces.\n+         *\/\n+        private Class<?> load(String name, Class<?> superClass, Class<?>[] interfaces)\n+            throws ClassNotFoundException\n+        {\n+            assert currentClassName == null;\n+            assert currentSuperClass == null;\n+            assert currentInterfaces == null;\n+\n+            try {\n+                currentClassName = name;\n+                currentSuperClass = superClass;\n+                currentInterfaces = interfaces;\n+\n+                return findClass(name);\n+            } finally {\n+                currentClassName = null;\n+                currentSuperClass = null;\n+                currentInterfaces = null;\n+            }\n+        }\n+\n+        \/**\n+         * This method must be called from inside the <code>load()<\/code> method. The <code>\/name<code>\n+         * can be only:\n+         * <ul>\n+         * <li> the <code>name<\/code> parameter for <code>load()<\/code>\n+         * <li> the name of the <code>superClass<\/code> parameter for <code>load()<\/code>\n+         * <li> the name of one of the interfaces in <code>interfaces<\/code> parameter for <code>load()<\/code>\n+         * <ul>\n+         *\n+         * For all other cases, a <code>ClassNotFoundException<\/code> will be thrown.\n+         *\/\n+        protected Class<?> findClass(final String name)\n+            throws ClassNotFoundException\n+        {\n+            Objects.requireNonNull(currentClassName);\n+            Objects.requireNonNull(currentSuperClass);\n+\n+            if (name.equals(currentClassName)) {\n+                \/\/ Note: the following call will call back to <code>this.findClass(name)<\/code> to\n+                \/\/ resolve the super types of the named class.\n+                return super.findClass(name);\n+            }\n+            if (name.equals(currentSuperClass.getName())) {\n+                return currentSuperClass;\n+            }\n+            if (currentInterfaces != null) {\n+                for (Class<?> c : currentInterfaces) {\n+                    if (name.equals(c.getName())) {\n+                        return c;\n+                    }\n+                }\n+            }\n+\n+            throw new ClassNotFoundException(name);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":113,"deletions":1,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-        dumpShouldFail(\n+        dumpShouldPass(\n@@ -59,1 +59,2 @@\n-            \"Class CustomLoadee2 implements the interface CustomInterface2_ia, but no interface has been specified in the input line\");\n+            \"java.lang.NoClassDefFoundError: CustomInterface2_ia\",\n+            \"Cannot find CustomLoadee2\");\n@@ -70,1 +71,1 @@\n-            \"The interface CustomInterface2_ib implemented by class CustomLoadee2 does not match any of the specified interface IDs\");\n+            \"The number of interfaces (1) specified in class list does not match the class file (2)\");\n@@ -104,0 +105,10 @@\n+\n+        dumpShouldPass(\n+            \"TESTCASE E6: JAR file doesn't exist\",\n+            appJar, classlist(\n+                \"Hello\",\n+                \"java\/lang\/Object id: 1\",\n+                \"NoSuchClass id: 2 super: 1 source: no_such_file.jar\"\n+            ),\n+            \"Cannot find NoSuchClass\",\n+            \"java.io.IOException: No such file: no_such_file.jar\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/ClassListFormatE.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"}]}