{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,7 +26,0 @@\n-import jdk.test.lib.util.Pair;\n-import jdk.test.lib.jittester.factories.IRNodeBuilder;\n-import jdk.test.lib.jittester.types.TypeKlass;\n-import jdk.test.lib.jittester.utils.FixedTrees;\n-import jdk.test.lib.jittester.utils.OptionResolver;\n-import jdk.test.lib.jittester.utils.OptionResolver.Option;\n-import jdk.test.lib.jittester.utils.PseudoRandom;\n@@ -42,51 +35,0 @@\n-    private static Pair<IRNode, IRNode> generateIRTree(String name) {\n-        ProductionLimiter.resetTimer();\n-        SymbolTable.removeAll();\n-        TypeList.removeAll();\n-\n-        IRNodeBuilder builder = new IRNodeBuilder()\n-                .setPrefix(name)\n-                .setName(name)\n-                .setLevel(0);\n-\n-        Long complexityLimit = ProductionParams.complexityLimit.value();\n-        IRNode privateClasses = null;\n-        if (!ProductionParams.disableClasses.value()) {\n-            long privateClassComlexity = (long) (complexityLimit * PseudoRandom.random());\n-            try {\n-                privateClasses = builder.setComplexityLimit(privateClassComlexity)\n-                        .getClassDefinitionBlockFactory()\n-                        .produce();\n-            } catch (ProductionFailedException ex) {\n-                ex.printStackTrace(System.out);\n-            }\n-        }\n-        long mainClassComplexity = (long) (complexityLimit * PseudoRandom.random());\n-        IRNode mainClass = null;\n-        try {\n-            mainClass = builder.setComplexityLimit(mainClassComplexity)\n-                    .getMainKlassFactory()\n-                    .produce();\n-            TypeKlass aClass = new TypeKlass(name);\n-            mainClass.getChild(1).addChild(FixedTrees.generateMainOrExecuteMethod(aClass, true));\n-            mainClass.getChild(1).addChild(FixedTrees.generateMainOrExecuteMethod(aClass, false));\n-        } catch (ProductionFailedException ex) {\n-            ex.printStackTrace(System.out);\n-        }\n-        return new Pair<>(mainClass, privateClasses);\n-    }\n-\n-    private static void initializeTestGenerator(String[] params) {\n-        OptionResolver parser = new OptionResolver();\n-        Option<String> propertyFileOpt = parser.addStringOption('p', \"property-file\",\n-                \"conf\/default.properties\", \"File to read properties from\");\n-        ProductionParams.register(parser);\n-        parser.parse(params, propertyFileOpt);\n-        PseudoRandom.reset(ProductionParams.seed.value());\n-        TypesParser.parseTypesAndMethods(ProductionParams.classesFile.value(),\n-                ProductionParams.excludeMethodsFile.value());\n-        if (ProductionParams.specificSeed.isSet()) {\n-            PseudoRandom.setCurrentSeed(ProductionParams.specificSeed.value());\n-        }\n-    }\n-\n@@ -112,1 +54,3 @@\n-        initializeTestGenerator(args);\n+        ProductionParams.initializeFromCmdline(args);\n+        IRTreeGenerator.initializeWithProductionParams();\n+\n@@ -124,1 +68,1 @@\n-                Pair<IRNode, IRNode> irTree = generateIRTree(name);\n+                var test = IRTreeGenerator.generateIRTree(name);\n@@ -132,1 +76,1 @@\n-                        generator.accept(irTree.first, irTree.second);\n+                        generator.accept(test);\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/Automatic.java","additions":6,"deletions":62,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,3 +50,4 @@\n-    public void accept(IRNode mainClass, IRNode privateClasses) {\n-        generateClassFiles(mainClass, privateClasses);\n-        generateSeparateJtregHeader(mainClass);\n+    public void accept(IRTreeGenerator.Test test) {\n+        IRNode mainClass = test.mainClass();\n+        generateClassFiles(mainClass, test.privateClasses());\n+        generateSeparateJtregHeader(test.seed(), mainClass);\n@@ -57,1 +58,1 @@\n-    private void generateSeparateJtregHeader(IRNode mainClass) {\n+    private void generateSeparateJtregHeader(long seed, IRNode mainClass) {\n@@ -59,1 +60,1 @@\n-        writeFile(generatorDir, mainClassName + \".java\", getJtregHeader(mainClassName));\n+        writeFile(generatorDir, mainClassName + \".java\", getJtregHeader(mainClassName, seed));\n@@ -97,0 +98,13 @@\n+\n+    public static void main(String[] args) throws Exception {\n+        ProductionParams.initializeFromCmdline(args);\n+        IRTreeGenerator.initializeWithProductionParams();\n+\n+        ByteCodeGenerator generator = new ByteCodeGenerator();\n+\n+        for (String mainClass : ProductionParams.mainClassNames.value()) {\n+            var test = IRTreeGenerator.generateIRTree(mainClass);\n+            generator.generateClassFiles(test.mainClass(), test.privateClasses());\n+            generator.generateSeparateJtregHeader(test.seed(), test.mainClass());\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/ByteCodeGenerator.java","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.jittester;\n+\n+import jdk.test.lib.jittester.factories.IRNodeBuilder;\n+import jdk.test.lib.jittester.types.TypeKlass;\n+import jdk.test.lib.jittester.utils.FixedTrees;\n+import jdk.test.lib.jittester.utils.PseudoRandom;\n+\n+\/**\n+ * Generates IR trees for fuzzy test classes.\n+ *\/\n+public class IRTreeGenerator {\n+\n+    \/**\n+     * Generated Test - main and private classes trees along with random seed used for generation.\n+     *\/\n+    public record Test (long seed, IRNode mainClass, IRNode privateClasses) {};\n+\n+    \/**\n+     * Generates IR trees for main and private classes.\n+     *\n+     * @param name main class name\n+     * @return a pair (main class; private classes)\n+     *\/\n+    public static Test generateIRTree(String name) {\n+        long seed = PseudoRandom.getCurrentSeed();\n+        ProductionLimiter.resetTimer();\n+        \/\/NB: SymbolTable is a widely-used singleton, hence all the locking.\n+        SymbolTable.removeAll();\n+        TypeList.removeAll();\n+\n+        IRNodeBuilder builder = new IRNodeBuilder()\n+                .setPrefix(name)\n+                .setName(name)\n+                .setLevel(0);\n+\n+        Long complexityLimit = ProductionParams.complexityLimit.value();\n+        IRNode privateClasses = null;\n+        if (!ProductionParams.disableClasses.value()) {\n+            long privateClassComlexity = (long) (complexityLimit * PseudoRandom.random());\n+            try {\n+                privateClasses = builder.setComplexityLimit(privateClassComlexity)\n+                        .getClassDefinitionBlockFactory()\n+                        .produce();\n+            } catch (ProductionFailedException ex) {\n+                ex.printStackTrace(System.out);\n+            }\n+        }\n+        long mainClassComplexity = (long) (complexityLimit * PseudoRandom.random());\n+        IRNode mainClass = null;\n+        try {\n+            mainClass = builder.setComplexityLimit(mainClassComplexity)\n+                    .getMainKlassFactory()\n+                    .produce();\n+            TypeKlass aClass = new TypeKlass(name);\n+            mainClass.getChild(1).addChild(FixedTrees.generateMainOrExecuteMethod(aClass, true));\n+            mainClass.getChild(1).addChild(FixedTrees.generateMainOrExecuteMethod(aClass, false));\n+        } catch (ProductionFailedException ex) {\n+            ex.printStackTrace(System.out);\n+        }\n+        return new Test(seed, mainClass, privateClasses);\n+    }\n+\n+    \/**\n+     * Initializes the generator from ProductionParams static class.\n+     *\/\n+    public static void initializeWithProductionParams() {\n+        TypesParser.parseTypesAndMethods(ProductionParams.classesFile.value(),\n+                ProductionParams.excludeMethodsFile.value());\n+        if (ProductionParams.specificSeed.isSet()) {\n+            PseudoRandom.setCurrentSeed(ProductionParams.specificSeed.value());\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/IRTreeGenerator.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -45,1 +45,2 @@\n-    public void accept(IRNode mainClass, IRNode privateClasses) {\n+    public void accept(IRTreeGenerator.Test test) {\n+        IRNode mainClass = test.mainClass();\n@@ -47,1 +48,1 @@\n-        generateSources(mainClass, privateClasses);\n+        generateSources(test.seed(), mainClass, test.privateClasses());\n@@ -53,1 +54,1 @@\n-    private void generateSources(IRNode mainClass, IRNode privateClasses) {\n+    private void generateSources(long seed, IRNode mainClass, IRNode privateClasses) {\n@@ -57,1 +58,1 @@\n-        code.append(getJtregHeader(mainClassName));\n+        code.append(getJtregHeader(mainClassName, seed));\n@@ -82,1 +83,1 @@\n-    private static String[] generatePrerunAction(String mainClassName) {\n+    protected static String[] generatePrerunAction(String mainClassName) {\n@@ -85,0 +86,12 @@\n+\n+    public static void main(String[] args) throws Exception {\n+        ProductionParams.initializeFromCmdline(args);\n+        IRTreeGenerator.initializeWithProductionParams();\n+\n+        JavaCodeGenerator generator = new JavaCodeGenerator();\n+\n+        for (String mainClass : ProductionParams.mainClassNames.value()) {\n+            var test = IRTreeGenerator.generateIRTree(mainClass);\n+            generator.generateSources(test.seed(), test.mainClass(), test.privateClasses());\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/JavaCodeGenerator.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import java.util.List;\n+\n@@ -28,0 +30,1 @@\n+import jdk.test.lib.jittester.utils.PseudoRandom;\n@@ -31,0 +34,1 @@\n+    public static Option<List<String>> mainClassNames = null;\n@@ -75,0 +79,1 @@\n+    public static Option<String> tempDir = null;\n@@ -84,0 +89,1 @@\n+        mainClassNames = optionResolver.addRepeatingOption('k', \"main-class\", \"\", \"Main class name\");\n@@ -127,0 +133,1 @@\n+        tempDir = optionResolver.addStringOption(\"temp-dir\", \".\", \"Temp dir path\");\n@@ -135,0 +142,14 @@\n+\n+    \/**\n+     * Initializes from the given command-line args\n+     *\n+     * @param args command-line arguments to use for initialization\n+     *\/\n+    public static void initializeFromCmdline(String[] args) {\n+        OptionResolver parser = new OptionResolver();\n+        Option<String> propertyFileOpt = parser.addStringOption('p', \"property-file\",\n+                \"conf\/default.properties\", \"File to read properties from\");\n+        ProductionParams.register(parser);\n+        parser.parse(args, propertyFileOpt);\n+        PseudoRandom.reset(ProductionParams.seed.value());\n+    }\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/ProductionParams.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n@@ -37,1 +37,0 @@\n-import jdk.test.lib.jittester.utils.PseudoRandom;\n@@ -39,1 +38,1 @@\n-public abstract class TestsGenerator implements BiConsumer<IRNode, IRNode> {\n+public abstract class TestsGenerator implements Consumer<IRTreeGenerator.Test> {\n@@ -124,1 +123,1 @@\n-    protected String getJtregHeader(String mainClassName) {\n+    protected String getJtregHeader(String mainClassName, long seed) {\n@@ -126,1 +125,1 @@\n-                + \", specificSeed = '\" + PseudoRandom.getCurrentSeed() + \"'\";\n+                + \", specificSeed = '\" + seed + \"'\";\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/TestsGenerator.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,0 +159,6 @@\n+    public Option<List<String>> addRepeatingOption(Character key, String name, String defaultValue, String description) {\n+        final Option<List<String>> option = new RepeatingOption(key, name, defaultValue, description);\n+        register(option);\n+        return option;\n+    }\n+\n@@ -267,0 +273,14 @@\n+    private class RepeatingOption extends Option<List<String>> {\n+        List<String> accumulated = new ArrayList<String>();\n+\n+        RepeatingOption(Character s, String l, String v, String d) {\n+            super(s, l, List.of(v), d);\n+        }\n+\n+        @Override\n+        public List<String> parseFromString(String arg) {\n+            accumulated.add(arg);\n+            return accumulated;\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/utils\/OptionResolver.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"}]}