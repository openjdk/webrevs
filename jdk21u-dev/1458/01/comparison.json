{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/bufferNode.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/bufferNode.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"gc\/shared\/ptrQueue.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTableEntryClosure.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shared\/bufferNode.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/bufferNode.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/bufferNode.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RedirtyCardsQueue.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/bufferNode.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RedirtyCardsQueue.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"gc\/shared\/bufferNode.hpp\"\n@@ -48,1 +49,0 @@\n-#include \"gc\/shared\/ptrQueue.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/bufferNode.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SATBMarkQueueSet.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/shared\/bufferNode.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/bufferNode.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/bufferNode.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+\n+#include <new>\n+\n+BufferNode::AllocatorConfig::AllocatorConfig(size_t size) : _buffer_size(size) {}\n+\n+void* BufferNode::AllocatorConfig::allocate() {\n+  size_t byte_size = _buffer_size * sizeof(void*);\n+  return NEW_C_HEAP_ARRAY(char, buffer_offset() + byte_size, mtGC);\n+}\n+\n+void BufferNode::AllocatorConfig::deallocate(void* node) {\n+  assert(node != nullptr, \"precondition\");\n+  FREE_C_HEAP_ARRAY(char, node);\n+}\n+\n+BufferNode::Allocator::Allocator(const char* name, size_t buffer_size) :\n+  _config(buffer_size),\n+  _free_list(name, &_config)\n+{}\n+\n+size_t BufferNode::Allocator::free_count() const {\n+  return _free_list.free_count();\n+}\n+\n+BufferNode* BufferNode::Allocator::allocate() {\n+  return ::new (_free_list.allocate()) BufferNode();\n+}\n+\n+void BufferNode::Allocator::release(BufferNode* node) {\n+  assert(node != nullptr, \"precondition\");\n+  assert(node->next() == nullptr, \"precondition\");\n+  node->~BufferNode();\n+  _free_list.release(node);\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/bufferNode.cpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_BUFFERNODE_HPP\n+#define SHARE_GC_SHARED_BUFFERNODE_HPP\n+\n+#include \"gc\/shared\/freeListAllocator.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/lockFreeStack.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class BufferNode {\n+  size_t _index;\n+  BufferNode* volatile _next;\n+  void* _buffer[1];             \/\/ Pseudo flexible array member.\n+\n+  BufferNode() : _index(0), _next(nullptr) { }\n+  ~BufferNode() { }\n+\n+  NONCOPYABLE(BufferNode);\n+\n+  static size_t buffer_offset() {\n+    return offset_of(BufferNode, _buffer);\n+  }\n+\n+public:\n+  static BufferNode* volatile* next_ptr(BufferNode& bn) { return &bn._next; }\n+  typedef LockFreeStack<BufferNode, &next_ptr> Stack;\n+\n+  BufferNode* next() const     { return _next;  }\n+  void set_next(BufferNode* n) { _next = n;     }\n+  size_t index() const         { return _index; }\n+  void set_index(size_t i)     { _index = i; }\n+\n+  \/\/ Return the BufferNode containing the buffer, after setting its index.\n+  static BufferNode* make_node_from_buffer(void** buffer, size_t index) {\n+    BufferNode* node =\n+      reinterpret_cast<BufferNode*>(\n+        reinterpret_cast<char*>(buffer) - buffer_offset());\n+    node->set_index(index);\n+    return node;\n+  }\n+\n+  \/\/ Return the buffer for node.\n+  static void** make_buffer_from_node(BufferNode *node) {\n+    \/\/ &_buffer[0] might lead to index out of bounds warnings.\n+    return reinterpret_cast<void**>(\n+      reinterpret_cast<char*>(node) + buffer_offset());\n+  }\n+\n+  class AllocatorConfig;\n+  class Allocator;              \/\/ Free-list based allocator.\n+  class TestSupport;            \/\/ Unit test support.\n+};\n+\n+\/\/ We use BufferNode::AllocatorConfig to set the allocation options for the\n+\/\/ FreeListAllocator.\n+class BufferNode::AllocatorConfig : public FreeListConfig {\n+  const size_t _buffer_size;\n+public:\n+  explicit AllocatorConfig(size_t size);\n+\n+  ~AllocatorConfig() = default;\n+\n+  void* allocate() override;\n+\n+  void deallocate(void* node) override;\n+\n+  size_t buffer_size() const { return _buffer_size; }\n+};\n+\n+class BufferNode::Allocator {\n+  friend class TestSupport;\n+\n+  AllocatorConfig _config;\n+  FreeListAllocator _free_list;\n+\n+  NONCOPYABLE(Allocator);\n+\n+public:\n+  Allocator(const char* name, size_t buffer_size);\n+  ~Allocator() = default;\n+\n+  size_t buffer_size() const { return _config.buffer_size(); }\n+  size_t free_count() const;\n+  BufferNode* allocate();\n+  void release(BufferNode* node);\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_BUFFERNODE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/bufferNode.hpp","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shared\/bufferNode.hpp\"\n@@ -27,3 +28,0 @@\n-#include \"memory\/allocation.inline.hpp\"\n-\n-#include <new>\n@@ -41,6 +39,0 @@\n-BufferNode::AllocatorConfig::AllocatorConfig(size_t size) : _buffer_size(size) {}\n-\n-void* BufferNode::AllocatorConfig::allocate() {\n-  size_t byte_size = _buffer_size * sizeof(void*);\n-  return NEW_C_HEAP_ARRAY(char, buffer_offset() + byte_size, mtGC);\n-}\n@@ -48,26 +40,0 @@\n-void BufferNode::AllocatorConfig::deallocate(void* node) {\n-  assert(node != nullptr, \"precondition\");\n-  FREE_C_HEAP_ARRAY(char, node);\n-}\n-\n-BufferNode::Allocator::Allocator(const char* name, size_t buffer_size) :\n-  _config(buffer_size),\n-  _free_list(name, &_config)\n-{\n-\n-}\n-\n-size_t BufferNode::Allocator::free_count() const {\n-  return _free_list.free_count();\n-}\n-\n-BufferNode* BufferNode::Allocator::allocate() {\n-  return ::new (_free_list.allocate()) BufferNode();\n-}\n-\n-void BufferNode::Allocator::release(BufferNode* node) {\n-  assert(node != nullptr, \"precondition\");\n-  assert(node->next() == nullptr, \"precondition\");\n-  node->~BufferNode();\n-  _free_list.release(node);\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/ptrQueue.cpp","additions":1,"deletions":35,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-#include \"gc\/shared\/freeListAllocator.hpp\"\n-#include \"memory\/padded.hpp\"\n+#include \"gc\/shared\/bufferNode.hpp\"\n@@ -33,1 +32,0 @@\n-#include \"utilities\/lockFreeStack.hpp\"\n@@ -41,1 +39,0 @@\n-class BufferNode;\n@@ -121,78 +118,0 @@\n-class BufferNode {\n-  size_t _index;\n-  BufferNode* volatile _next;\n-  void* _buffer[1];             \/\/ Pseudo flexible array member.\n-\n-  BufferNode() : _index(0), _next(nullptr) { }\n-  ~BufferNode() { }\n-\n-  NONCOPYABLE(BufferNode);\n-\n-  static size_t buffer_offset() {\n-    return offset_of(BufferNode, _buffer);\n-  }\n-\n-public:\n-  static BufferNode* volatile* next_ptr(BufferNode& bn) { return &bn._next; }\n-  typedef LockFreeStack<BufferNode, &next_ptr> Stack;\n-\n-  BufferNode* next() const     { return _next;  }\n-  void set_next(BufferNode* n) { _next = n;     }\n-  size_t index() const         { return _index; }\n-  void set_index(size_t i)     { _index = i; }\n-\n-  \/\/ Return the BufferNode containing the buffer, after setting its index.\n-  static BufferNode* make_node_from_buffer(void** buffer, size_t index) {\n-    BufferNode* node =\n-      reinterpret_cast<BufferNode*>(\n-        reinterpret_cast<char*>(buffer) - buffer_offset());\n-    node->set_index(index);\n-    return node;\n-  }\n-\n-  \/\/ Return the buffer for node.\n-  static void** make_buffer_from_node(BufferNode *node) {\n-    \/\/ &_buffer[0] might lead to index out of bounds warnings.\n-    return reinterpret_cast<void**>(\n-      reinterpret_cast<char*>(node) + buffer_offset());\n-  }\n-\n-  class AllocatorConfig;\n-  class Allocator;              \/\/ Free-list based allocator.\n-  class TestSupport;            \/\/ Unit test support.\n-};\n-\n-\/\/ We use BufferNode::AllocatorConfig to set the allocation options for the\n-\/\/ FreeListAllocator.\n-class BufferNode::AllocatorConfig : public FreeListConfig {\n-  const size_t _buffer_size;\n-public:\n-  explicit AllocatorConfig(size_t size);\n-\n-  ~AllocatorConfig() = default;\n-\n-  void* allocate() override;\n-\n-  void deallocate(void* node) override;\n-\n-  size_t buffer_size() const { return _buffer_size; }\n-};\n-\n-class BufferNode::Allocator {\n-  friend class TestSupport;\n-\n-  AllocatorConfig _config;\n-  FreeListAllocator _free_list;\n-\n-  NONCOPYABLE(Allocator);\n-\n-public:\n-  Allocator(const char* name, size_t buffer_size);\n-  ~Allocator() = default;\n-\n-  size_t buffer_size() const { return _config.buffer_size(); }\n-  size_t free_count() const;\n-  BufferNode* allocate();\n-  void release(BufferNode* node);\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/ptrQueue.hpp","additions":1,"deletions":82,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/bufferNode.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/bufferNode.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSATBMarkQueueSet.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#include \"gc\/shared\/ptrQueue.hpp\"\n+#include \"gc\/shared\/bufferNode.hpp\"\n@@ -54,1 +54,1 @@\n-TEST_VM(PtrQueueBufferAllocatorTest, test) {\n+TEST_VM(BufferNodeAllocatorTest, test) {\n@@ -238,1 +238,1 @@\n-TEST_VM(PtrQueueBufferAllocatorTest, stress_free_list_allocator) {\n+TEST_VM(BufferNodeAllocatorTest, stress_free_list_allocator) {\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_bufferNodeAllocator.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/hotspot\/gtest\/gc\/shared\/test_ptrQueueBufferAllocator.cpp","status":"renamed"}]}