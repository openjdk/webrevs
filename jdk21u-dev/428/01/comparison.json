{"files":[{"patch":"@@ -73,14 +73,11 @@\n-    if (b->count() > 0) {\n-      if (nm->is_marked_for_deoptimization()) {\n-        deopt_scope->dependent(nm);\n-      } else if (nm->check_dependency_on(changes)) {\n-        LogTarget(Info, dependencies) lt;\n-        if (lt.is_enabled()) {\n-          ResourceMark rm;\n-          LogStream ls(&lt);\n-          ls.print_cr(\"Marked for deoptimization\");\n-          changes.print_on(&ls);\n-          nm->print_on(&ls);\n-          nm->print_dependencies_on(&ls);\n-        }\n-        deopt_scope->mark(nm, !changes.is_call_site_change());\n+    if (nm->is_marked_for_deoptimization()) {\n+      deopt_scope->dependent(nm);\n+    } else if (nm->check_dependency_on(changes)) {\n+      LogTarget(Info, dependencies) lt;\n+      if (lt.is_enabled()) {\n+        ResourceMark rm;\n+        LogStream ls(&lt);\n+        ls.print_cr(\"Marked for deoptimization\");\n+        changes.print_on(&ls);\n+        nm->print_on(&ls);\n+        nm->print_dependencies_on(&ls);\n@@ -88,0 +85,1 @@\n+      deopt_scope->mark(nm, !changes.is_call_site_change());\n@@ -94,3 +92,0 @@\n-\/\/ It's possible that an nmethod has multiple dependencies on a klass\n-\/\/ so a count is kept for each bucket to guarantee that creation and\n-\/\/ deletion of dependencies is consistent.\n@@ -102,1 +97,0 @@\n-      b->increment();\n@@ -197,5 +191,3 @@\n-    if (b->count() > 0) {\n-      \/\/ Also count already (concurrently) marked nmethods to make sure\n-      \/\/ deoptimization is triggered before execution in this thread continues.\n-      deopt_scope->mark(nm);\n-    }\n+    \/\/ Also count already (concurrently) marked nmethods to make sure\n+    \/\/ deoptimization is triggered before execution in this thread continues.\n+    deopt_scope->mark(nm);\n@@ -211,1 +203,1 @@\n-    tty->print(\"[%d] count=%d { \", idx++, b->count());\n+    tty->print(\"[%d] { \", idx++);\n@@ -227,4 +219,0 @@\n-#ifdef ASSERT\n-      int count = b->count();\n-      assert(count >= 0, \"count shouldn't be negative: %d\", count);\n-#endif\n@@ -237,4 +225,0 @@\n-int nmethodBucket::decrement() {\n-  return Atomic::sub(&_count, 1);\n-}\n-\n","filename":"src\/hotspot\/share\/code\/dependencyContext.cpp","additions":16,"deletions":32,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -42,5 +42,1 @@\n-\/\/ finding nmethods which might need to be deoptimized.  Instead of\n-\/\/ recording the method, a count of how many times a particular nmethod\n-\/\/ was recorded is kept.  This ensures that any recording errors are\n-\/\/ noticed since an nmethod should be removed as many times are it's\n-\/\/ added.\n+\/\/ finding nmethods which might need to be deoptimized.\n@@ -52,1 +48,0 @@\n-  volatile int   _count;\n@@ -58,1 +53,1 @@\n-    _nmethod(nmethod), _count(1), _next(next), _purge_list_next(nullptr) {}\n+    _nmethod(nmethod), _next(next), _purge_list_next(nullptr) {}\n@@ -60,3 +55,0 @@\n-  int count()                                { return _count; }\n-  int increment()                            { _count += 1; return _count; }\n-  int decrement();\n","filename":"src\/hotspot\/share\/code\/dependencyContext.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"}]}