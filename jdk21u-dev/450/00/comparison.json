{"files":[{"patch":"@@ -2705,1 +2705,12 @@\n-    switch (C->static_subtype_check(superk, subk)) {\n+    \/\/\n+    \/\/ Do not skip the static sub type check with StressReflectiveCode during\n+    \/\/ parsing (i.e. with ExpandSubTypeCheckAtParseTime) because the\n+    \/\/ associated CheckCastNodePP could already be folded when the type\n+    \/\/ system can prove it's an impossible type. Therefore, we should also\n+    \/\/ do the static sub type check here to ensure control is folded as well.\n+    \/\/ Otherwise, the graph is left in a broken state.\n+    \/\/ At macro expansion, we would have already folded the SubTypeCheckNode\n+    \/\/ being expanded here because we always perform the static sub type\n+    \/\/ check in SubTypeCheckNode::sub() regardless of whether\n+    \/\/ StressReflectiveCode is set or not.\n+    switch (C->static_subtype_check(superk, subk, !ExpandSubTypeCheckAtParseTime)) {\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -6461,3 +6461,1 @@\n-  int dummy;\n-  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n-  if (!this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n+  if (!this_one->is_loaded() || !other->is_loaded()) {\n@@ -6469,0 +6467,7 @@\n+\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+  if (this_top_or_bottom) {\n+    return true;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=Xcomp\n+ * @bug 8328702\n+ * @summary Check that SubTypeCheckNode is properly folded when having an array with bottom type elements checked\n+ *          against an interface.\n+ *\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.types.TestSubTypeCheckWithBottomArray::test*\n+ *                   -XX:CompileCommand=inline,compiler.types.TestSubTypeCheckWithBottomArray::check*\n+ *                   compiler.types.TestSubTypeCheckWithBottomArray\n+ *\/\n+\n+\/*\n+ * @test id=Xbatch\n+ * @bug 8328702\n+ * @summary Check that SubTypeCheckNode is properly folded when having an array with bottom type elements checked\n+ *          against an interface.\n+ *\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=compileonly,compiler.types.TestSubTypeCheckWithBottomArray::test*\n+ *                   -XX:CompileCommand=inline,compiler.types.TestSubTypeCheckWithBottomArray::check*\n+ *                   compiler.types.TestSubTypeCheckWithBottomArray\n+ *\/\n+\n+\/*\n+ * @test id=stress\n+ * @bug 8328702\n+ * @summary Check that PartialSubtypeCheckNode is properly folded when having an array with bottom type elements checked\n+ *          either against an interface or an unrelated non-sub-class.\n+ *\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.types.TestSubTypeCheckWithBottomArray::test*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+ExpandSubTypeCheckAtParseTime\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+StressReflectiveCode\n+ *                   -XX:CompileCommand=inline,compiler.types.TestSubTypeCheckWithBottomArray::check*\n+ *                   compiler.types.TestSubTypeCheckWithBottomArray\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=compileonly,compiler.types.TestSubTypeCheckWithBottomArray::test*\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+ExpandSubTypeCheckAtParseTime\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+StressReflectiveCode\n+ *                   -XX:CompileCommand=inline,compiler.types.TestSubTypeCheckWithBottomArray::check*\n+ *                   compiler.types.TestSubTypeCheckWithBottomArray\n+ *\/\n+\n+package compiler.types;\n+\n+public class TestSubTypeCheckWithBottomArray {\n+    static byte[] bArr = new byte[10];\n+    static Object[] oArr = new Object[10];\n+    static boolean flag;\n+\n+    public static void main(String[] args) {\n+        A a = new A();\n+        B b = new B();\n+        Y y = new Y();\n+        Z z = new Z();\n+        for (int i = 0; i < 10000; i++) {\n+            \/\/ With -Xcomp: Immediatly crashes because of no profiling -> don't know anything.\n+            checkInterface(a); \/\/ Make sure that checkInterface() sometimes passes instanceof.\n+            checkInterface(b); \/\/ Use two sub classes such that checkcast is required.\n+            testInterface();\n+\n+            checkClass(y); \/\/ Make sure that checkClass() sometimes passes instanceof.\n+            checkClass(z); \/\/ Use two sub classes such that checkcast is required.\n+            testClass();\n+            flag = !flag;\n+        }\n+    }\n+\n+    static void testInterface() {\n+        checkInterface(flag ? bArr : oArr); \/\/ Inlined, never passes instanceof\n+    }\n+\n+    static void checkInterface(Object o) {\n+        if (o instanceof I i) {\n+            \/\/ Use of i: Needs CheckCastPP which is replaced by top because [bottom <: I cannot be true.\n+            \/\/ But: SubTypeCheckNode is not folded away -> broken graph (data dies, control not)\n+            i.getClass();\n+        }\n+    }\n+\n+    static void testClass() {\n+        checkClass(flag ? bArr : oArr); \/\/ Inlined, never passes instanceof\n+    }\n+\n+    static void checkClass(Object o) {\n+        if (o instanceof X x) {\n+            \/\/ Use of i: Needs CheckCastPP which is replaced by top because [bottom <: I cannot be true.\n+            \/\/ But: SubTypeCheckNode is not folded away -> broken graph (data dies, control not)\n+            x.getClass();\n+        }\n+    }\n+\n+}\n+\n+interface I {}\n+class A implements I {}\n+class B implements I {}\n+\n+class X {}\n+class Y extends X {}\n+class Z extends X {}\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestSubTypeCheckWithBottomArray.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"}]}