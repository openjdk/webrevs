{"files":[{"patch":"@@ -120,0 +120,1 @@\n+    static Debugee             debuggee      = null;\n@@ -140,2 +141,0 @@\n-        Debugee debuggee;\n-\n@@ -339,1 +338,0 @@\n-\n@@ -344,0 +342,10 @@\n+\n+                \/\/ don't do vm.suspend() until mainThread is waiting\n+                line = pipe.readln();\n+                if (line.equals(\"waiting\")) {\n+                    log2(\"     : returned string is 'waiting'\");\n+                } else {\n+                    log3(\"ERROR: returned string is not 'waiting': \" + line);\n+                    expresult = returnCode4;\n+                    break label1;\n+                }\n@@ -346,0 +354,1 @@\n+\n@@ -364,2 +373,1 @@\n-\n-                log2(\"      resuming the thread2\");\n+                log2(\"       resuming the thread2\");\n@@ -368,0 +376,7 @@\n+                log2(\"       undo the vm.suspend() with vm.resume()\");\n+                vm.resume();\n+            }\n+            \/\/ These are only needed if we break out of the loop due to an error\n+            if (expresult != returnCode0) {\n+                vm.resume();\n+                vm.resume();  \/\/ for case error when both VirtualMachine and the thread2 were suspended\n@@ -369,2 +384,0 @@\n-            vm.resume();\n-            vm.resume();  \/\/ for case error when both VirtualMachine and the thread2 were suspended\n@@ -490,1 +503,2 @@\n-                        log3(\"ERROR:  timeout for waiting for a BreakpintEvent\");\n+                        log3(\"ERROR:  timeout for waiting for a BreakpointEvent\");\n+                        debuggee.printThreadsInfo(vm);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/resume\/resume001.java","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,1 +84,7 @@\n-            log1(\"waiting for an instruction from the debugger ...\");\n+            log1(\"waiting for an instruction from the debugger: iteration \" + i);\n+            if (i == 1) {\n+                \/\/ Let the debugger know we finished the first iteration and are now\n+                \/\/ waiting for next command. This is needed so we don't suspend the\n+                \/\/ main thread while it is doing a log(), which can hold a needed lock.\n+                pipe.println(\"waiting\");\n+            }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/resume\/resume001a.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -624,1 +624,1 @@\n-    protected void printThreadsInfo(VirtualMachine vm)  {\n+    public void printThreadsInfo(VirtualMachine vm) {\n@@ -626,1 +626,1 @@\n-            log.display(\"------------ Try to print debuggee threads before killing process ------------\");\n+            log.display(\"------------ Print debuggee threads ------------\");\n@@ -660,1 +660,1 @@\n-            log.display(\"----------------------------------------------------------------------\");\n+            log.display(\"------------------------------------------------\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/Debugee.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}