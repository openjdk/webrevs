{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Red Hat, Inc.\n+ * Copyright (c) 2024, 2025, Red Hat, Inc.\n@@ -52,0 +52,7 @@\n+  assert(mem->cgroup_path() != nullptr, \"invariant\");\n+  if (strstr(mem->cgroup_path(), \"..\/\") != nullptr) {\n+    log_warning(os, container)(\"Cgroup memory controller path at '%s' seems to have moved to '%s', detected limits won't be accurate\",\n+      mem->mount_point(), mem->cgroup_path());\n+    mem->set_subsystem_path(\"\/\");\n+    return;\n+  }\n@@ -57,1 +64,0 @@\n-  assert(mem->cgroup_path() != nullptr, \"invariant\");\n@@ -65,1 +71,2 @@\n-  jlong lowest_limit = phys_mem;\n+  jlong lowest_limit = limit < 0 ? phys_mem : limit;\n+  julong orig_limit = ((julong)lowest_limit) != phys_mem ? lowest_limit : phys_mem;\n@@ -86,1 +93,1 @@\n-  if ((julong)lowest_limit != phys_mem) {\n+  if ((julong)lowest_limit != orig_limit) {\n@@ -96,0 +103,1 @@\n+    log_trace(os, container)(\"Lowest limit was: \" JLONG_FORMAT, lowest_limit);\n@@ -107,0 +115,7 @@\n+  assert(cpu->cgroup_path() != nullptr, \"invariant\");\n+  if (strstr(cpu->cgroup_path(), \"..\/\") != nullptr) {\n+    log_warning(os, container)(\"Cgroup cpu controller path at '%s' seems to have moved to '%s', detected limits won't be accurate\",\n+      cpu->mount_point(), cpu->cgroup_path());\n+    cpu->set_subsystem_path(\"\/\");\n+    return;\n+  }\n@@ -112,1 +127,0 @@\n-  assert(cpu->cgroup_path() != nullptr, \"invariant\");\n@@ -119,1 +133,2 @@\n-  int lowest_limit = host_cpus;\n+  int lowest_limit = cpus < host_cpus ? cpus: host_cpus;\n+  int orig_limit = lowest_limit != host_cpus ? lowest_limit : host_cpus;\n@@ -141,1 +156,1 @@\n-  if (lowest_limit != host_cpus) {\n+  if (lowest_limit != orig_limit) {\n@@ -151,0 +166,1 @@\n+    log_trace(os, container)(\"Lowest limit was: %d\", lowest_limit);\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":23,"deletions":7,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,41 @@\n+ *\n+ * The method determines whether it runs in\n+ * - host mode\n+ * - container mode\n+ *\n+ * In the host mode, _root is equal to \"\/\" and\n+ * the subsystem path is equal to the _mount_point path\n+ * joined with cgroup_path.\n+ *\n+ * In the container mode, it can be two possibilities:\n+ * - private namespace (cgroupns=private)\n+ * - host namespace (cgroupns=host, default mode in cgroup V1 hosts)\n+ *\n+ * Private namespace is equivalent to the host mode, i.e.\n+ * the subsystem path is set by concatenating\n+ * _mount_point and cgroup_path.\n+ *\n+ * In the host namespace, _root is equal to host's cgroup path\n+ * of the control group to which the containerized process\n+ * belongs to at the moment of creation. The mountinfo and\n+ * cgroup files are mirrored from the host, while the subsystem\n+ * specific files are mapped directly at _mount_point, i.e.\n+ * at \/sys\/fs\/cgroup\/<controller>\/, the subsystem path is\n+ * then set equal to _mount_point.\n+ *\n+ * A special case of the subsystem path is when a cgroup path\n+ * includes a subgroup, when a containerized process was associated\n+ * with an existing cgroup, that is different from cgroup\n+ * in which the process has been created.\n+ * Here, the _root is equal to the host's initial cgroup path,\n+ * cgroup_path will be equal to host's new cgroup path.\n+ * As host cgroup hierarchies are not accessible in the container,\n+ * it needs to be determined which part of cgroup path\n+ * is accessible inside container, i.e. mapped under\n+ * \/sys\/fs\/cgroup\/<controller>\/<subgroup>.\n+ * In Docker default setup, host's cgroup path can be\n+ * of the form: \/docker\/<CONTAINER_ID>\/<subgroup>,\n+ * from which only <subgroup> is mapped.\n+ * The method trims cgroup path from left, until the subgroup\n+ * component is found. The subsystem path will be set to\n+ * the _mount_point joined with the subgroup path.\n@@ -52,0 +93,1 @@\n+    ss.print_raw(_mount_point);\n@@ -53,1 +95,1 @@\n-      ss.print_raw(_mount_point);\n+      \/\/ host processes and containers with cgroupns=private\n@@ -57,1 +99,0 @@\n-      _path = os::strdup(ss.base());\n@@ -59,11 +100,18 @@\n-      if (strcmp(_root, cgroup_path) == 0) {\n-        ss.print_raw(_mount_point);\n-        _path = os::strdup(ss.base());\n-      } else {\n-        char *p = strstr((char*)cgroup_path, _root);\n-        if (p != nullptr && p == _root) {\n-          if (strlen(cgroup_path) > strlen(_root)) {\n-            ss.print_raw(_mount_point);\n-            const char* cg_path_sub = cgroup_path + strlen(_root);\n-            ss.print_raw(cg_path_sub);\n-            _path = os::strdup(ss.base());\n+      \/\/ containers with cgroupns=host, default setting is _root==cgroup_path\n+      if (strcmp(_root, cgroup_path) != 0) {\n+        if (*cgroup_path != '\\0' && strcmp(cgroup_path, \"\/\") != 0) {\n+          \/\/ When moved to a subgroup, between subgroups, the path suffix will change.\n+          const char *suffix = cgroup_path;\n+          while (suffix != nullptr) {\n+            stringStream pp;\n+            pp.print_raw(_mount_point);\n+            pp.print_raw(suffix);\n+            if (os::file_exists(pp.base())) {\n+              ss.print_raw(suffix);\n+              if (suffix != cgroup_path) {\n+                log_trace(os, container)(\"set_subsystem_path: cgroup v1 path reduced to: %s.\", suffix);\n+              }\n+              break;\n+            }\n+            log_trace(os, container)(\"set_subsystem_path: skipped non-existent directory: %s.\", suffix);\n+            suffix = strchr(suffix + 1, '\/');\n@@ -74,0 +122,1 @@\n+    _path = os::strdup(ss.base());\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":63,"deletions":14,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Red Hat Inc.\n+ * Copyright (c) 2020, 2025, Red Hat Inc.\n@@ -286,0 +286,4 @@\n+  if (_cgroup_path != nullptr) {\n+    os::free(_cgroup_path);\n+  }\n+  _cgroup_path = os::strdup(cgroup_path);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.lang.System.Logger.Level;\n+import java.nio.file.Path;\n+import java.nio.file.Files;\n@@ -47,0 +50,1 @@\n+            String path = mountPoint;\n@@ -48,0 +52,1 @@\n+                \/\/ host processes and containers with cgroupns=private\n@@ -49,1 +54,1 @@\n-                    path = mountPoint + cgroupPath;\n+                    path += cgroupPath;\n@@ -51,13 +56,19 @@\n-                else {\n-                    path = mountPoint;\n-                }\n-            }\n-            else {\n-                if (root.equals(cgroupPath)) {\n-                    path = mountPoint;\n-                }\n-                else {\n-                    if (cgroupPath.startsWith(root)) {\n-                        if (cgroupPath.length() > root.length()) {\n-                            String cgroupSubstr = cgroupPath.substring(root.length());\n-                            path = mountPoint + cgroupSubstr;\n+            } else {\n+                \/\/ containers with cgroupns=host, default setting is _root==cgroup_path\n+                if (!cgroupPath.equals(root)) {\n+                    if (!cgroupPath.equals(\"\") && !cgroupPath.equals(\"\/\")) {\n+                        \/\/ When moved to a subgroup, between subgroups, the path suffix will change.\n+                        Path cgp = Path.of(cgroupPath);\n+                        int nameCount = cgp.getNameCount();\n+                        for (int i=0; i < nameCount; i++) {\n+                            Path dir = Path.of(mountPoint, cgp.toString());\n+                            if (Files.isDirectory(dir)) {\n+                                path = dir.toString();\n+                                if (i > 0) {\n+                                    System.getLogger(\"jdk.internal.platform\").log(Level.DEBUG, String.format(\n+                                            \"Cgroup v1 path reduced to: %s.\", cgp));\n+                                }\n+                                break;\n+                            }\n+                            int currentNameCount = cgp.getNameCount();\n+                            cgp = (currentNameCount > 1) ? cgp.subpath(1, currentNameCount) : Path.of(\"\");\n@@ -68,0 +79,1 @@\n+            this.path = path;\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1SubsystemController.java","additions":27,"deletions":15,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -440,1 +441,7 @@\n-  int length = 2;\n+  TestCase container_moving_cgroup = {\n+    \"\/sys\/fs\/cgroup\/cpu,cpuacct\",                                            \/\/ mount_path\n+    \"\/system.slice\/garden.service\/garden\/good\/2f57368b-0eda-4e52-64d8-af5c\", \/\/ root_path\n+    \"\/system.slice\/garden.service\/garden\/bad\/2f57368b-0eda-4e52-64d8-af5c\",  \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/cpu,cpuacct\"                                             \/\/ expected_path\n+  };\n+  int length = 3;\n@@ -442,1 +449,2 @@\n-                            &container_engine };\n+                            &container_engine,\n+                            &container_moving_cgroup };\n@@ -452,0 +460,66 @@\n+TEST(cgroupTest, set_cgroupv1_subsystem_path_adjusted) {\n+  TestCase memory = {\n+    \"\/sys\/fs\/cgroup\/memory\", \/\/ mount_path\n+    \"\/\",                     \/\/ root_path\n+    \"..\/test1\",              \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/memory\"  \/\/ expected_path\n+  };\n+  TestCase cpu = {\n+    \"\/sys\/fs\/cgroup\/cpu\", \/\/ mount_path\n+    \"\/\",                  \/\/ root_path\n+    \"..\/..\/test2\",        \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/cpu\"  \/\/ expected_path\n+  };\n+  CgroupCpuController* ccc = new CgroupV1CpuController(CgroupV1Controller((char*)cpu.root_path,\n+                                                                          (char*)cpu.mount_path,\n+                                                                          true \/* read-only mount *\/));\n+  ccc->set_subsystem_path((char*)cpu.cgroup_path);\n+  EXPECT_TRUE(ccc->needs_hierarchy_adjustment());\n+\n+  CgroupUtil::adjust_controller(ccc);\n+  ASSERT_STREQ(cpu.expected_path, ccc->subsystem_path());\n+  EXPECT_FALSE(ccc->needs_hierarchy_adjustment());\n+\n+  CgroupMemoryController* cmc = new CgroupV1MemoryController(CgroupV1Controller((char*)memory.root_path,\n+                                                                                (char*)memory.mount_path,\n+                                                                                true \/* read-only mount *\/));\n+  cmc->set_subsystem_path((char*)memory.cgroup_path);\n+  EXPECT_TRUE(cmc->needs_hierarchy_adjustment());\n+\n+  CgroupUtil::adjust_controller(cmc);\n+  ASSERT_STREQ(memory.expected_path, cmc->subsystem_path());\n+  EXPECT_FALSE(cmc->needs_hierarchy_adjustment());\n+}\n+\n+TEST(cgroupTest, set_cgroupv2_subsystem_path_adjusted) {\n+  TestCase memory = {\n+    \"\/sys\/fs\/cgroup\", \/\/ mount_path\n+    \"\/\",              \/\/ root_path\n+    \"..\/test1\",       \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\"  \/\/ expected_path\n+  };\n+  TestCase cpu = {\n+    \"\/sys\/fs\/cgroup\", \/\/ mount_path\n+    \"\/\",              \/\/ root_path\n+    \"..\/..\/test2\",    \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\"  \/\/ expected_path\n+  };\n+  CgroupCpuController* ccc = new CgroupV2CpuController(CgroupV2Controller((char*)cpu.mount_path,\n+                                                                          (char*)cpu.cgroup_path,\n+                                                                          true \/* read-only mount *\/));\n+  EXPECT_TRUE(ccc->needs_hierarchy_adjustment());\n+\n+  CgroupUtil::adjust_controller(ccc);\n+  ASSERT_STREQ(cpu.expected_path, ccc->subsystem_path());\n+  EXPECT_FALSE(ccc->needs_hierarchy_adjustment());\n+\n+  CgroupMemoryController* cmc = new CgroupV2MemoryController(CgroupV2Controller((char*)memory.mount_path,\n+                                                                                (char*)memory.cgroup_path,\n+                                                                                true \/* read-only mount *\/));\n+  EXPECT_TRUE(cmc->needs_hierarchy_adjustment());\n+\n+  CgroupUtil::adjust_controller(cmc);\n+  ASSERT_STREQ(memory.expected_path, cmc->subsystem_path());\n+  EXPECT_FALSE(cmc->needs_hierarchy_adjustment());\n+}\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":76,"deletions":2,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (C) 2025, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Container;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.containers.docker.ContainerRuntimeVersionTestUtils;\n+import jdk.test.lib.containers.docker.DockerRunOptions;\n+import jdk.internal.platform.Metrics;\n+\n+import java.util.ArrayList;\n+\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @bug 8343191\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.platform\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar whitebox.jar jdk.test.whitebox.WhiteBox\n+ * @run main TestMemoryWithSubgroups\n+ *\/\n+public class TestMemoryWithSubgroups {\n+    private static final String imageName = Common.imageName(\"subgroup\");\n+\n+    static String getEngineInfo(String format) throws Exception {\n+        return DockerTestUtils.execute(Container.ENGINE_COMMAND, \"info\", \"-f\", format)\n+            .getStdout();\n+    }\n+\n+    static boolean isRootless() throws Exception {\n+        \/\/ Docker and Podman have different INFO structures.\n+        \/\/ The node path for Podman is .Host.Security.Rootless, that also holds for\n+        \/\/ Podman emulating Docker CLI. The node path for Docker is .SecurityOptions.\n+        return (getEngineInfo(\"{{.Host.Security.Rootless}}\").contains(\"true\") ||\n+                getEngineInfo(\"{{.SecurityOptions}}\").contains(\"name=rootless\"));\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Metrics metrics = Metrics.systemMetrics();\n+        if (metrics == null) {\n+            System.out.println(\"Cgroup not configured.\");\n+            return;\n+        }\n+        if (!DockerTestUtils.canTestDocker()) {\n+            System.out.println(\"Unable to run docker tests.\");\n+            return;\n+        }\n+\n+        ContainerRuntimeVersionTestUtils.checkContainerVersionSupported();\n+\n+        if (isRootless()) {\n+            throw new SkippedException(\"Test skipped in rootless mode\");\n+        }\n+        Common.prepareWhiteBox();\n+        DockerTestUtils.buildJdkContainerImage(imageName);\n+\n+        if (\"cgroupv1\".equals(metrics.getProvider())) {\n+            try {\n+                testMemoryLimitSubgroupV1(\"200m\", \"100m\", \"104857600\", false);\n+                testMemoryLimitSubgroupV1(\"1g\", \"500m\", \"524288000\", false);\n+                testMemoryLimitSubgroupV1(\"200m\", \"100m\", \"104857600\", true);\n+                testMemoryLimitSubgroupV1(\"1g\", \"500m\", \"524288000\", true);\n+            } finally {\n+                DockerTestUtils.removeDockerImage(imageName);\n+            }\n+        } else if (\"cgroupv2\".equals(metrics.getProvider())) {\n+            try {\n+                testMemoryLimitSubgroupV2(\"200m\", \"100m\", \"104857600\", false);\n+                testMemoryLimitSubgroupV2(\"1g\", \"500m\", \"524288000\", false);\n+                testMemoryLimitSubgroupV2(\"200m\", \"100m\", \"104857600\", true);\n+                testMemoryLimitSubgroupV2(\"1g\", \"500m\", \"524288000\", true);\n+            } finally {\n+                DockerTestUtils.removeDockerImage(imageName);\n+            }\n+        } else {\n+            throw new SkippedException(\"Metrics are from neither cgroup v1 nor v2, skipped for now.\");\n+        }\n+    }\n+\n+    private static void testMemoryLimitSubgroupV1(String containerMemorySize, String valueToSet, String expectedValue, boolean privateNamespace)\n+            throws Exception {\n+\n+        Common.logNewTestCase(\"Cgroup V1 subgroup memory limit: \" + valueToSet);\n+\n+        DockerRunOptions opts = new DockerRunOptions(imageName, \"sh\", \"-c\");\n+        opts.javaOpts = new ArrayList<>();\n+        opts.appendTestJavaOptions = false;\n+        opts.addDockerOpts(\"--privileged\")\n+            .addDockerOpts(\"--cgroupns=\" + (privateNamespace ? \"private\" : \"host\"))\n+            .addDockerOpts(\"--memory\", containerMemorySize);\n+        opts.addClassOptions(\"mkdir -p \/sys\/fs\/cgroup\/memory\/test ; \" +\n+            \"echo \" + valueToSet + \" > \/sys\/fs\/cgroup\/memory\/test\/memory.limit_in_bytes ; \" +\n+            \"echo $$ > \/sys\/fs\/cgroup\/memory\/test\/cgroup.procs ; \" +\n+            \"\/jdk\/bin\/java -Xlog:os+container=trace -version\");\n+\n+        Common.run(opts)\n+            .shouldMatch(\"Lowest limit was:.*\" + expectedValue);\n+    }\n+\n+    private static void testMemoryLimitSubgroupV2(String containerMemorySize, String valueToSet, String expectedValue, boolean privateNamespace)\n+            throws Exception {\n+\n+        Common.logNewTestCase(\"Cgroup V2 subgroup memory limit: \" + valueToSet);\n+\n+        DockerRunOptions opts = new DockerRunOptions(imageName, \"sh\", \"-c\");\n+        opts.javaOpts = new ArrayList<>();\n+        opts.appendTestJavaOptions = false;\n+        opts.addDockerOpts(\"--privileged\")\n+            .addDockerOpts(\"--cgroupns=\" + (privateNamespace ? \"private\" : \"host\"))\n+            .addDockerOpts(\"--memory\", containerMemorySize);\n+        opts.addClassOptions(\"mkdir -p \/sys\/fs\/cgroup\/memory\/test ; \" +\n+            \"echo $$ > \/sys\/fs\/cgroup\/memory\/test\/cgroup.procs ; \" +\n+            \"echo '+memory' > \/sys\/fs\/cgroup\/cgroup.subtree_control ; \" +\n+            \"echo '+memory' > \/sys\/fs\/cgroup\/memory\/cgroup.subtree_control ; \" +\n+            \"echo \" + valueToSet + \" > \/sys\/fs\/cgroup\/memory\/test\/memory.max ; \" +\n+            \"\/jdk\/bin\/java -Xlog:os+container=trace -version\");\n+\n+        Common.run(opts)\n+            .shouldMatch(\"Lowest limit was:.*\" + expectedValue);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMemoryWithSubgroups.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Red Hat, Inc.\n+ * Copyright (c) 2022, 2025, Red Hat, Inc.\n@@ -67,0 +67,3 @@\n+    \/*\n+     * Less common cases: Containers\n+     *\/\n@@ -74,1 +77,1 @@\n-        String expectedPath = mountPoint + \"\/some\";\n+        String expectedPath = mountPoint;\n@@ -78,0 +81,10 @@\n+    @Test\n+    public void testCgPathToMovedPath() {\n+        String root = \"\/system.slice\/garden.service\/garden\/good\/2f57368b-0eda-4e52-64d8-af5c\";\n+        String mountPoint = \"\/sys\/fs\/cgroup\/cpu,cpuacct\";\n+        CgroupV1SubsystemController ctrl = new CgroupV1SubsystemController(root, mountPoint);\n+        String cgroupPath = \"\/system.slice\/garden.service\/garden\/bad\/2f57368b-0eda-4e52-64d8-af5c\";\n+        ctrl.setPath(cgroupPath);\n+        String expectedPath = mountPoint;\n+        assertEquals(expectedPath, ctrl.path());\n+    }\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/CgroupV1SubsystemControllerTest.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Red Hat Inc.\n+ * Copyright (c) 2020, 2025, Red Hat Inc.\n@@ -47,0 +47,1 @@\n+import jdk.internal.platform.cgroupv1.CgroupV1SubsystemController;\n@@ -78,0 +79,1 @@\n+    private Path cgroupv1MntInfoNonTrivialRoot;\n@@ -80,0 +82,1 @@\n+    private Path cgroupv1SelfNonTrivialRoot;\n@@ -178,0 +181,1 @@\n+    private String mntInfoNonTrivialRoot = \"2207 2196 0:43 \/system.slice\/garden.service\/garden\/good\/2f57368b-0eda-4e52-64d8-af5c \/sys\/fs\/cgroup\/cpu,cpuacct ro,nosuid,nodev,noexec,relatime master:25 - cgroup cgroup rw,cpu,cpuacct\\n\";\n@@ -233,0 +237,1 @@\n+    private String cgroupv1SelfNTRoot = \"11:cpu,cpuacct:\/system.slice\/garden.service\/garden\/bad\/2f57368b-0eda-4e52-64d8-af5c\\n\";\n@@ -297,0 +302,3 @@\n+            cgroupv1MntInfoNonTrivialRoot = Paths.get(existingDirectory.toString(), \"mountinfo_nt_root\");\n+            Files.writeString(cgroupv1MntInfoNonTrivialRoot, mntInfoNonTrivialRoot);\n+\n@@ -303,0 +311,3 @@\n+            cgroupv1SelfNonTrivialRoot = Paths.get(existingDirectory.toString(), \"self_nt_root_cgv1\");\n+            Files.writeString(cgroupv1SelfNonTrivialRoot, cgroupv1SelfNTRoot);\n+\n@@ -452,0 +463,21 @@\n+    @Test\n+    public void testMountPrefixCgroupsV1() throws IOException {\n+        String cgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String mountInfo = cgroupv1MntInfoNonTrivialRoot.toString();\n+        String selfCgroup = cgroupv1SelfNonTrivialRoot.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+        CgroupInfo cpuInfo = res.getInfos().get(\"cpu\");\n+        assertEquals(cpuInfo.getCgroupPath(), \"\/system.slice\/garden.service\/garden\/bad\/2f57368b-0eda-4e52-64d8-af5c\");\n+        String expectedMountPoint = \"\/sys\/fs\/cgroup\/cpu,cpuacct\";\n+        assertEquals(expectedMountPoint, cpuInfo.getMountPoint());\n+        CgroupV1SubsystemController cgroupv1MemoryController = new CgroupV1SubsystemController(cpuInfo.getMountRoot(), cpuInfo.getMountPoint());\n+        cgroupv1MemoryController.setPath(cpuInfo.getCgroupPath());\n+        String actualPath = cgroupv1MemoryController.path();\n+        assertNotNull(actualPath);\n+        String expectedPath = expectedMountPoint;\n+        assertEquals(\"Should be equal to the mount point path\", expectedPath, actualPath);\n+    }\n+\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemFactory.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2025, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.platform.Metrics;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerfileConfig;\n+import jdk.test.lib.containers.docker.DockerRunOptions;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.containers.docker.ContainerRuntimeVersionTestUtils;\n+\n+import java.util.ArrayList;\n+\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @bug 8343191\n+ * @key cgroups\n+ * @summary Cgroup v1 subsystem fails to set subsystem path\n+ * @requires container.support\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.platform\n+ * @build MetricsMemoryTester\n+ * @run main TestDockerMemoryMetricsSubgroup\n+ *\/\n+\n+public class TestDockerMemoryMetricsSubgroup {\n+    private static final String imageName =\n+            DockerfileConfig.getBaseImageName() + \":\" +\n+            DockerfileConfig.getBaseImageVersion();\n+\n+    public static void main(String[] args) throws Exception {\n+        Metrics metrics = Metrics.systemMetrics();\n+        if (metrics == null) {\n+            System.out.println(\"Cgroup not configured.\");\n+            return;\n+        }\n+        if (!DockerTestUtils.canTestDocker()) {\n+            System.out.println(\"Unable to run docker tests.\");\n+            return;\n+        }\n+\n+        ContainerRuntimeVersionTestUtils.checkContainerVersionSupported();\n+\n+        if (\"cgroupv1\".equals(metrics.getProvider())) {\n+            testMemoryLimitSubgroupV1(\"200m\", \"400m\", false);\n+            testMemoryLimitSubgroupV1(\"500m\", \"1G\", false);\n+            testMemoryLimitSubgroupV1(\"200m\", \"400m\", true);\n+            testMemoryLimitSubgroupV1(\"500m\", \"1G\", true);\n+        } else if (\"cgroupv2\".equals(metrics.getProvider())) {\n+            testMemoryLimitSubgroupV2(\"200m\", \"400m\", false);\n+            testMemoryLimitSubgroupV2(\"500m\", \"1G\", false);\n+            testMemoryLimitSubgroupV2(\"200m\", \"400m\", true);\n+            testMemoryLimitSubgroupV2(\"500m\", \"1G\", true);\n+        } else {\n+            throw new SkippedException(\"Metrics are from neither cgroup v1 nor v2, skipped for now.\");\n+        }\n+    }\n+\n+    private static void testMemoryLimitSubgroupV1(String innerSize, String outerGroupMemorySize, boolean privateNamespace) throws Exception {\n+        Common.logNewTestCase(\"testMemoryLimitSubgroup, innerSize = \" + innerSize);\n+        DockerRunOptions opts =\n+            new DockerRunOptions(imageName, \"sh\", \"-c\");\n+        opts.javaOpts = new ArrayList<>();\n+        opts.appendTestJavaOptions = false;\n+        opts.addDockerOpts(\"--volume\", Utils.TEST_CLASSES + \":\/test-classes\/\")\n+            .addDockerOpts(\"--volume\", Utils.TEST_JDK + \":\/jdk\")\n+            .addDockerOpts(\"--privileged\")\n+            .addDockerOpts(\"--cgroupns=\" + (privateNamespace ? \"private\" : \"host\"))\n+            .addDockerOpts(\"--memory\", outerGroupMemorySize);\n+        opts.addClassOptions(\"mkdir -p \/sys\/fs\/cgroup\/memory\/test ; \" +\n+            \"echo \" + innerSize + \" > \/sys\/fs\/cgroup\/memory\/test\/memory.limit_in_bytes ; \" +\n+            \"echo $$ > \/sys\/fs\/cgroup\/memory\/test\/cgroup.procs ; \" +\n+            \"\/jdk\/bin\/java -cp \/test-classes\/ \" +\n+            \"--add-exports java.base\/jdk.internal.platform=ALL-UNNAMED \" +\n+            \"MetricsMemoryTester memory \" + innerSize);\n+\n+        DockerTestUtils.dockerRunJava(opts).shouldHaveExitValue(0).shouldContain(\"TEST PASSED!!!\");\n+    }\n+\n+    private static void testMemoryLimitSubgroupV2(String innerSize, String outerGroupMemorySize, boolean privateNamespace) throws Exception {\n+        Common.logNewTestCase(\"testMemoryLimitSubgroup, innerSize = \" + innerSize);\n+        DockerRunOptions opts =\n+            new DockerRunOptions(imageName, \"sh\", \"-c\");\n+        opts.javaOpts = new ArrayList<>();\n+        opts.appendTestJavaOptions = false;\n+        opts.addDockerOpts(\"--volume\", Utils.TEST_CLASSES + \":\/test-classes\/\")\n+            .addDockerOpts(\"--volume\", Utils.TEST_JDK + \":\/jdk\")\n+            .addDockerOpts(\"--privileged\")\n+            .addDockerOpts(\"--cgroupns=\" + (privateNamespace ? \"private\" : \"host\"))\n+            .addDockerOpts(\"--memory\", outerGroupMemorySize);\n+        opts.addClassOptions(\"mkdir -p \/sys\/fs\/cgroup\/memory\/test ; \" +\n+            \"echo $$ > \/sys\/fs\/cgroup\/memory\/test\/cgroup.procs ; \" +\n+            \"echo '+memory' > \/sys\/fs\/cgroup\/cgroup.subtree_control ; \" +\n+            \"echo '+memory' > \/sys\/fs\/cgroup\/memory\/cgroup.subtree_control ; \" +\n+            \"echo \" + innerSize + \" > \/sys\/fs\/cgroup\/memory\/test\/memory.max ; \" +\n+            \"\/jdk\/bin\/java -cp \/test-classes\/ \" +\n+            \"--add-exports java.base\/jdk.internal.platform=ALL-UNNAMED \" +\n+            \"MetricsMemoryTester memory \" + innerSize);\n+\n+        DockerTestUtils.dockerRunJava(opts).shouldHaveExitValue(0).shouldContain(\"TEST PASSED!!!\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestDockerMemoryMetricsSubgroup.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * Methods and definitions related to container runtime version to test container in this directory\n+ *\/\n+\n+package jdk.test.lib.containers.docker;\n+\n+import jdk.test.lib.Container;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jtreg.SkippedException;\n+\n+public class ContainerRuntimeVersionTestUtils implements Comparable<ContainerRuntimeVersionTestUtils> {\n+    private final int major;\n+    private final int minor;\n+    private final int micro;\n+    private static final boolean IS_DOCKER = Container.ENGINE_COMMAND.contains(\"docker\");\n+    private static final boolean IS_PODMAN = Container.ENGINE_COMMAND.contains(\"podman\");\n+    public static final ContainerRuntimeVersionTestUtils DOCKER_MINIMAL_SUPPORTED_VERSION_CGROUPNS = new ContainerRuntimeVersionTestUtils(20, 10, 0);\n+    public static final ContainerRuntimeVersionTestUtils PODMAN_MINIMAL_SUPPORTED_VERSION_CGROUPNS = new ContainerRuntimeVersionTestUtils(1, 5, 0);\n+\n+    private ContainerRuntimeVersionTestUtils(int major, int minor, int micro) {\n+        this.major = major;\n+        this.minor = minor;\n+        this.micro = micro;\n+    }\n+\n+    public static void checkContainerVersionSupported() {\n+        if (IS_DOCKER && ContainerRuntimeVersionTestUtils.DOCKER_MINIMAL_SUPPORTED_VERSION_CGROUPNS.compareTo(ContainerRuntimeVersionTestUtils.getContainerRuntimeVersion()) > 0) {\n+            throw new SkippedException(\"Docker version too old for this test. Expected >= 20.10.0\");\n+        }\n+        if (IS_PODMAN && ContainerRuntimeVersionTestUtils.PODMAN_MINIMAL_SUPPORTED_VERSION_CGROUPNS.compareTo(ContainerRuntimeVersionTestUtils.getContainerRuntimeVersion()) > 0) {\n+            throw new SkippedException(\"Podman version too old for this test. Expected >= 1.5.0\");\n+        }\n+    }\n+\n+    @Override\n+    public int compareTo(ContainerRuntimeVersionTestUtils other) {\n+        if (this.major > other.major) {\n+            return 1;\n+        } else if (this.major < other.major) {\n+            return -1;\n+        } else if (this.minor > other.minor) {\n+            return 1;\n+        } else if (this.minor < other.minor) {\n+            return -1;\n+        } else if (this.micro > other.micro) {\n+            return 1;\n+        } else if (this.micro < other.micro) {\n+            return -1;\n+        } else {\n+            \/\/ equal majors, minors, micro\n+            return 0;\n+        }\n+    }\n+\n+    public static ContainerRuntimeVersionTestUtils fromVersionString(String version) {\n+        try {\n+            \/\/ Example 'docker version 20.10.0 or podman version 4.9.4-rhel'\n+            String versNums = version.split(\"\\\\s+\", 3)[2];\n+            \/\/ On some docker implementations e.g. RHEL8 ppc64le we have the following version output:\n+            \/\/    Docker version v25.0.3, build 4debf41\n+            \/\/ Trim potentially leading 'v' and trailing ','\n+            if (versNums.startsWith(\"v\")) {\n+                versNums = versNums.substring(1);\n+            }\n+            int cidx = versNums.indexOf(',');\n+            versNums = (cidx != -1) ? versNums.substring(0, cidx) : versNums;\n+\n+            String[] numbers = versNums.split(\"-\")[0].split(\"\\\\.\", 3);\n+            return new ContainerRuntimeVersionTestUtils(Integer.parseInt(numbers[0]),\n+                    Integer.parseInt(numbers[1]),\n+                    Integer.parseInt(numbers[2]));\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Failed to parse container runtime version: \" + version, e);\n+        }\n+    }\n+\n+    public static String getContainerRuntimeVersionStr() {\n+        try {\n+            ProcessBuilder pb = new ProcessBuilder(Container.ENGINE_COMMAND, \"--version\");\n+            OutputAnalyzer out = new OutputAnalyzer(pb.start())\n+                    .shouldHaveExitValue(0);\n+            String result = out.asLines().get(0);\n+            System.out.println(Container.ENGINE_COMMAND + \" --version returning: \" + result);\n+            return result;\n+        } catch (Exception e) {\n+            throw new RuntimeException(Container.ENGINE_COMMAND + \" --version command failed.\");\n+        }\n+    }\n+\n+    public static ContainerRuntimeVersionTestUtils getContainerRuntimeVersion() {\n+        return ContainerRuntimeVersionTestUtils.fromVersionString(getContainerRuntimeVersionStr());\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/ContainerRuntimeVersionTestUtils.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"}]}