{"files":[{"patch":"@@ -790,0 +790,1 @@\n+int java_lang_Class::_init_lock_offset;\n@@ -915,0 +916,6 @@\n+  \/\/ Allocate a simple java object for a lock.\n+  \/\/ This needs to be a java object because during class initialization\n+  \/\/ it can be held across a java call.\n+  typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);\n+  set_init_lock(mirror(), r);\n+\n@@ -1136,0 +1143,4 @@\n+    \/\/ create the init_lock\n+    typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK_(false));\n+    set_init_lock(mirror(), r);\n+\n@@ -1200,0 +1211,9 @@\n+oop java_lang_Class::init_lock(oop java_class) {\n+  assert(_init_lock_offset != 0, \"must be set\");\n+  return java_class->obj_field(_init_lock_offset);\n+}\n+void java_lang_Class::set_init_lock(oop java_class, oop init_lock) {\n+  assert(_init_lock_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_init_lock_offset, init_lock);\n+}\n+\n@@ -1419,0 +1439,5 @@\n+  \/\/ Init lock is a C union with component_mirror.  Only instanceKlass mirrors have\n+  \/\/ init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops\n+  \/\/ GC treats them the same.\n+  _init_lock_offset = _component_mirror_offset;\n+\n@@ -1425,0 +1450,1 @@\n+  f->do_u4((u4*)&_init_lock_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -227,0 +227,1 @@\n+  static int _init_lock_offset;\n@@ -241,0 +242,1 @@\n+  static void set_init_lock(oop java_class, oop init_lock);\n@@ -293,0 +295,4 @@\n+  static oop  init_lock(oop java_class);\n+  static void clear_init_lock(oop java_class) {\n+    set_init_lock(java_class, nullptr);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1798,1 +1798,1 @@\n-  \/\/ a lock to do the final serialization of updates\n+  \/\/ an ObjectLocker to do the final serialization of updates\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -254,1 +255,1 @@\n-             method->method_holder()->is_init_thread(JavaThread::current()),\n+             method->method_holder()->is_reentrant_initialization(JavaThread::current()),\n@@ -357,0 +358,1 @@\n+\n@@ -358,1 +360,10 @@\n-  MutexLocker ml(cpool->pool_holder()->init_monitor());\n+  JavaThread* current = JavaThread::current();\n+  objArrayHandle resolved_references(current, cpool->resolved_references());\n+  \/\/ Use the resolved_references() lock for this cpCache entry.\n+  \/\/ resolved_references are created for all classes with Invokedynamic, MethodHandle\n+  \/\/ or MethodType constant pool cache entries.\n+  assert(resolved_references() != nullptr,\n+         \"a resolved_references array should have been created for this class\");\n+  ObjectLocker ol(resolved_references, current);\n+  \/\/ TODO remove - not in 21\n+  \/\/ResolvedMethodEntry* method_entry = resolved_method_entry_at(method_index);\n@@ -841,1 +852,8 @@\n-  MutexLocker ml(THREAD, cpool->pool_holder()->init_monitor());\n+  \/\/ Use the resolved_references() lock for this cpCache entry.\n+  \/\/ resolved_references are created for all classes with Invokedynamic, MethodHandle\n+  \/\/ or MethodType constant pool cache entries.\n+  JavaThread* current = THREAD;\n+  objArrayHandle resolved_references(current, cpool->resolved_references());\n+  assert(resolved_references() != nullptr,\n+         \"a resolved_references array should have been created for this class\");\n+  ObjectLocker ol(resolved_references, current);\n@@ -865,1 +883,11 @@\n-  MutexLocker ml(constant_pool()->pool_holder()->init_monitor());\n+\n+  \/\/ Use the resolved_references() lock for this cpCache entry.\n+  \/\/ resolved_references are created for all classes with Invokedynamic, MethodHandle\n+  \/\/ or MethodType constant pool cache entries.\n+  JavaThread* current = JavaThread::current();\n+  constantPoolHandle cp(current, constant_pool());\n+\n+  objArrayHandle resolved_references(current, cp->resolved_references());\n+  assert(resolved_references() != nullptr,\n+         \"a resolved_references array should have been created for this class\");\n+  ObjectLocker ol(resolved_references, current);\n@@ -869,1 +897,1 @@\n-    return constant_pool()->resolved_reference_from_indy(index);\n+    return cp->resolved_reference_from_indy(index);\n@@ -878,3 +906,1 @@\n-    JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n-    constantPoolHandle cp(THREAD, constant_pool());\n-    ConstantPool::throw_resolution_error(cp, encoded_index, THREAD);\n+    ConstantPool::throw_resolution_error(cp, encoded_index, current);\n@@ -904,1 +930,0 @@\n-    objArrayOop resolved_references = constant_pool()->resolved_references();\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":34,"deletions":9,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -497,4 +498,0 @@\n-static Monitor* create_init_monitor(const char* name) {\n-  return new Monitor(Mutex::safepoint, name);\n-}\n-\n@@ -513,1 +510,0 @@\n-  _init_monitor(create_init_monitor(\"InstanceKlassInitMonitor_lock\")),\n@@ -741,0 +737,22 @@\n+oop InstanceKlass::init_lock() const {\n+  \/\/ return the init lock from the mirror\n+  oop lock = java_lang_Class::init_lock(java_mirror());\n+  \/\/ Prevent reordering with any access of initialization state\n+  OrderAccess::loadload();\n+  assert(lock != nullptr || !is_not_initialized(), \/\/ initialized or in_error state\n+         \"only fully initialized state can have a null lock\");\n+  return lock;\n+}\n+\n+\/\/ Set the initialization lock to null so the object can be GC'ed.  Any racing\n+\/\/ threads to get this lock will see a null lock and will not lock.\n+\/\/ That's okay because they all check for initialized state after getting\n+\/\/ the lock and return.\n+void InstanceKlass::fence_and_clear_init_lock() {\n+  \/\/ make sure previous stores are all done, notably the init_state.\n+  OrderAccess::storestore();\n+  java_lang_Class::clear_init_lock(java_mirror());\n+  assert(!is_not_initialized(), \"class must be initialized now\");\n+}\n+\n+\n@@ -768,43 +786,0 @@\n-void InstanceKlass::check_link_state_and_wait(JavaThread* current) {\n-  MonitorLocker ml(current, _init_monitor);\n-\n-  bool debug_logging_enabled = log_is_enabled(Debug, class, init);\n-\n-  \/\/ Another thread is linking this class, wait.\n-  while (is_being_linked() && !is_init_thread(current)) {\n-    if (debug_logging_enabled) {\n-      ResourceMark rm(current);\n-      log_debug(class, init)(\"Thread \\\"%s\\\" waiting for linking of %s by thread \\\"%s\\\"\",\n-                             current->name(), external_name(), init_thread_name());\n-    }\n-    ml.wait();\n-  }\n-\n-  \/\/ This thread is recursively linking this class, continue\n-  if (is_being_linked() && is_init_thread(current)) {\n-    if (debug_logging_enabled) {\n-      ResourceMark rm(current);\n-      log_debug(class, init)(\"Thread \\\"%s\\\" recursively linking %s\",\n-                             current->name(), external_name());\n-    }\n-    return;\n-  }\n-\n-  \/\/ If this class wasn't linked already, set state to being_linked\n-  if (!is_linked()) {\n-    if (debug_logging_enabled) {\n-      ResourceMark rm(current);\n-      log_debug(class, init)(\"Thread \\\"%s\\\" linking %s\",\n-                             current->name(), external_name());\n-    }\n-    set_init_state(being_linked);\n-    set_init_thread(current);\n-  } else {\n-    if (debug_logging_enabled) {\n-      ResourceMark rm(current);\n-      log_debug(class, init)(\"Thread \\\"%s\\\" found %s already linked\",\n-                             current->name(), external_name());\n-      }\n-  }\n-}\n-\n@@ -889,2 +864,3 @@\n-    LockLinkState init_lock(this, jt);\n-\n+    HandleMark hm(THREAD);\n+    Handle h_init_lock(THREAD, init_lock());\n+    ObjectLocker ol(h_init_lock, jt);\n@@ -948,1 +924,15 @@\n-      set_initialization_state_and_notify(linked, THREAD);\n+      if (UseVtableBasedCHA && Universe::is_fully_initialized()) {\n+        DeoptimizationScope deopt_scope;\n+        {\n+          \/\/ Now mark all code that assumes the class is not linked.\n+          \/\/ Set state under the Compile_lock also.\n+          MutexLocker ml(THREAD, Compile_lock);\n+\n+          set_init_state(linked);\n+          CodeCache::mark_dependents_on(&deopt_scope, this);\n+        }\n+        \/\/ Perform the deopt handshake outside Compile_lock.\n+        deopt_scope.deoptimize_marked();\n+      } else {\n+        set_init_state(linked);\n+      }\n@@ -1069,1 +1059,0 @@\n-  bool throw_error = false;\n@@ -1078,1 +1067,2 @@\n-    MonitorLocker ml(jt, _init_monitor);\n+    Handle h_init_lock(THREAD, init_lock());\n+    ObjectLocker ol(h_init_lock, jt);\n@@ -1081,1 +1071,4 @@\n-    while (is_being_initialized() && !is_init_thread(jt)) {\n+    \/\/ If we were to use wait() instead of waitInterruptibly() then\n+    \/\/ we might end up throwing IE from link\/symbol resolution sites\n+    \/\/ that aren't expected to throw.  This would wreak havoc.  See 6320309.\n+    while (is_being_initialized() && !is_reentrant_initialization(jt)) {\n@@ -1090,1 +1083,1 @@\n-      ml.wait();\n+      ol.wait_uninterruptibly(jt);\n@@ -1095,1 +1088,1 @@\n-    if (is_being_initialized() && is_init_thread(jt)) {\n+    if (is_being_initialized() && is_reentrant_initialization(jt)) {\n@@ -1123,1 +1116,13 @@\n-      throw_error = true;\n+\n+      DTRACE_CLASSINIT_PROBE_WAIT(erroneous, -1, wait);\n+      ResourceMark rm(THREAD);\n+      Handle cause(THREAD, get_initialization_error(THREAD));\n+\n+      stringStream ss;\n+      ss.print(\"Could not initialize class %s\", external_name());\n+      if (cause.is_null()) {\n+        THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), ss.as_string());\n+      } else {\n+        THROW_MSG_CAUSE(vmSymbols::java_lang_NoClassDefFoundError(),\n+                        ss.as_string(), cause);\n+      }\n@@ -1137,16 +1142,0 @@\n-  \/\/ Throw error outside lock\n-  if (throw_error) {\n-    DTRACE_CLASSINIT_PROBE_WAIT(erroneous, -1, wait);\n-    ResourceMark rm(THREAD);\n-    Handle cause(THREAD, get_initialization_error(THREAD));\n-\n-    stringStream ss;\n-    ss.print(\"Could not initialize class %s\", external_name());\n-    if (cause.is_null()) {\n-      THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), ss.as_string());\n-    } else {\n-      THROW_MSG_CAUSE(vmSymbols::java_lang_NoClassDefFoundError(),\n-                      ss.as_string(), cause);\n-    }\n-  }\n-\n@@ -1210,1 +1199,1 @@\n-    set_initialization_state_and_notify(fully_initialized, THREAD);\n+    set_initialization_state_and_notify(fully_initialized, CHECK);\n@@ -1243,17 +1232,8 @@\n-void InstanceKlass::set_initialization_state_and_notify(ClassState state, JavaThread* current) {\n-  MonitorLocker ml(current, _init_monitor);\n-\n-  if (state == linked && UseVtableBasedCHA && Universe::is_fully_initialized()) {\n-    DeoptimizationScope deopt_scope;\n-    {\n-      \/\/ Now mark all code that assumes the class is not linked.\n-      \/\/ Set state under the Compile_lock also.\n-      MutexLocker ml(current, Compile_lock);\n-\n-      set_init_thread(nullptr); \/\/ reset _init_thread before changing _init_state\n-      set_init_state(state);\n-\n-      CodeCache::mark_dependents_on(&deopt_scope, this);\n-    }\n-    \/\/ Perform the deopt handshake outside Compile_lock.\n-    deopt_scope.deoptimize_marked();\n+void InstanceKlass::set_initialization_state_and_notify(ClassState state, TRAPS) {\n+  Handle h_init_lock(THREAD, init_lock());\n+  if (h_init_lock() != nullptr) {\n+    ObjectLocker ol(h_init_lock, THREAD);\n+    set_init_thread(nullptr); \/\/ reset _init_thread before changing _init_state\n+    set_init_state(state);\n+    fence_and_clear_init_lock();\n+    ol.notify_all(CHECK);\n@@ -1261,0 +1241,1 @@\n+    assert(h_init_lock() != nullptr, \"The initialization state should never be set twice\");\n@@ -1264,1 +1245,0 @@\n-  ml.notify_all();\n@@ -1269,1 +1249,1 @@\n-void InstanceKlass::add_to_hierarchy(JavaThread* current) {\n+void InstanceKlass::add_to_hierarchy_impl(JavaThread* current) {\n@@ -1272,8 +1252,0 @@\n-  \/\/ In case we are not using CHA based vtables we need to make sure the loaded\n-  \/\/ deopt is completed before anyone links this class.\n-  \/\/ Linking is done with _init_monitor held, by loading and deopting with it\n-  \/\/ held we make sure the deopt is completed before linking.\n-  if (!UseVtableBasedCHA) {\n-    init_monitor()->lock();\n-  }\n-\n@@ -1301,0 +1273,1 @@\n+}\n@@ -1302,2 +1275,14 @@\n-  if (!UseVtableBasedCHA) {\n-    init_monitor()->unlock();\n+void InstanceKlass::add_to_hierarchy(JavaThread* current) {\n+\n+  if (UseVtableBasedCHA || !Universe::is_fully_initialized()) {\n+    add_to_hierarchy_impl(current);\n+  } else {\n+    \/\/ In case we are not using CHA based vtables we need to make sure the loaded\n+    \/\/ deopt is completed before anyone links this class.\n+    \/\/ Linking is done with init_lock held, by loading and deopting with it\n+    \/\/ held we make sure the deopt is completed before linking.\n+    Handle h_init_lock(current, init_lock());\n+    ObjectLocker ol(h_init_lock, current);\n+    add_to_hierarchy_impl(current);\n+\n+    \/\/ This doesn't need a notify because the wait is only on the class initialization path.\n@@ -1307,0 +1292,1 @@\n+\n@@ -2658,1 +2644,0 @@\n-  _init_monitor = nullptr;\n@@ -2760,3 +2745,0 @@\n-\n-  \/\/ restore the monitor\n-  _init_monitor = create_init_monitor(\"InstanceKlassInitMonitorRestored_lock\");\n@@ -2858,3 +2840,0 @@\n-  \/\/ Destroy the init_monitor\n-  delete _init_monitor;\n-\n@@ -3526,1 +3505,1 @@\n-  \"allocated\", \"loaded\", \"being_linked\", \"linked\", \"being_initialized\", \"fully_initialized\", \"initialization_error\"\n+  \"allocated\", \"loaded\", \"linked\", \"being_initialized\", \"fully_initialized\", \"initialization_error\"\n@@ -4083,3 +4062,0 @@\n-  if (state > loaded) {\n-    assert_lock_strong(_init_monitor);\n-  }\n@@ -4089,2 +4065,1 @@\n-  bool link_failed = _init_state == being_linked && state == loaded;\n-  assert(good_state || state == allocated || link_failed, \"illegal state transition\");\n+  assert(good_state || state == allocated, \"illegal state transition\");\n@@ -4093,1 +4068,1 @@\n-  Atomic::store(&_init_state, state);\n+  _init_state = state;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":92,"deletions":117,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -152,1 +152,0 @@\n-    being_linked,                       \/\/ currently running verifier and rewriter\n@@ -226,0 +225,7 @@\n+  \/\/ _is_marked_dependent can be set concurrently, thus cannot be part of the\n+  \/\/ _misc_flags.\n+  bool            _is_marked_dependent;     \/\/ used for marking during flushing and deoptimization\n+\n+  \/\/ Class states are defined as ClassState (see above).\n+  \/\/ Place the _init_state here to utilize the unused 2-byte after\n+  \/\/ _idnum_allocated_count.\n@@ -228,1 +234,1 @@\n-  u1              _reference_type;          \/\/ reference type\n+  u1              _reference_type;                \/\/ reference type\n@@ -233,1 +239,0 @@\n-  Monitor*             _init_monitor;       \/\/ mutual exclusion to _init_state and _init_thread.\n@@ -496,1 +501,0 @@\n-  \/\/ We can safely access the name as long as we hold the _init_monitor.\n@@ -498,1 +502,0 @@\n-    assert(_init_monitor->owned_by_self(), \"Must hold _init_monitor here\");\n@@ -504,9 +507,8 @@\n-  bool is_loaded() const                   { return init_state() >= loaded; }\n-  bool is_linked() const                   { return init_state() >= linked; }\n-  bool is_being_linked() const             { return init_state() == being_linked; }\n-  bool is_initialized() const              { return init_state() == fully_initialized; }\n-  bool is_not_initialized() const          { return init_state() <  being_initialized; }\n-  bool is_being_initialized() const        { return init_state() == being_initialized; }\n-  bool is_in_error_state() const           { return init_state() == initialization_error; }\n-  bool is_init_thread(JavaThread *thread)  { return thread == init_thread(); }\n-  ClassState  init_state() const           { return Atomic::load(&_init_state); }\n+  bool is_loaded() const                   { return _init_state >= loaded; }\n+  bool is_linked() const                   { return _init_state >= linked; }\n+  bool is_initialized() const              { return _init_state == fully_initialized; }\n+  bool is_not_initialized() const          { return _init_state <  being_initialized; }\n+  bool is_being_initialized() const        { return _init_state == being_initialized; }\n+  bool is_in_error_state() const           { return _init_state == initialization_error; }\n+  bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }\n+  ClassState  init_state() const           { return _init_state; }\n@@ -516,15 +518,0 @@\n-  class LockLinkState : public StackObj {\n-    InstanceKlass* _ik;\n-    JavaThread*    _current;\n-   public:\n-    LockLinkState(InstanceKlass* ik, JavaThread* current) : _ik(ik), _current(current) {\n-      ik->check_link_state_and_wait(current);\n-    }\n-    ~LockLinkState() {\n-      if (!_ik->is_linked()) {\n-        \/\/ Reset to loaded if linking failed.\n-        _ik->set_initialization_state_and_notify(loaded, _current);\n-      }\n-    }\n-  };\n-\n@@ -842,1 +829,1 @@\n-  void set_initialization_state_and_notify(ClassState state, JavaThread* current);\n+  void set_initialization_state_and_notify(ClassState state, TRAPS);\n@@ -854,0 +841,4 @@\n+ private:\n+  void add_to_hierarchy_impl(JavaThread* current);\n+\n+ public:\n@@ -1071,1 +1062,1 @@\n- private:\n+private:\n@@ -1093,0 +1084,6 @@\n+  \/\/ Lock for (1) initialization; (2) access to the ConstantPool of this class.\n+  \/\/ Must be one per class and it has to be a VM internal object so java code\n+  \/\/ cannot lock it (like the mirror).\n+  \/\/ It has to be an object not a Mutex because it's held through java calls.\n+  oop init_lock() const;\n+\n@@ -1102,2 +1099,0 @@\n-\n-  Monitor* init_monitor() const { return _init_monitor; }\n@@ -1105,1 +1100,2 @@\n-  void check_link_state_and_wait(JavaThread* current);\n+  void fence_and_clear_init_lock();\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":30,"deletions":34,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1440,1 +1440,1 @@\n-           callee_method->method_holder()->is_init_thread(current),\n+           callee_method->method_holder()->is_reentrant_initialization(current),\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -727,0 +727,10 @@\n+void ObjectSynchronizer::waitUninterruptibly(Handle obj, jlong millis, TRAPS) {\n+  if (millis < 0) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), \"timeout value is negative\");\n+  }\n+  ObjectSynchronizer::inflate(THREAD,\n+                              obj(),\n+                              inflate_cause_wait)->wait(millis, false, THREAD);\n+}\n+\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -109,0 +109,5 @@\n+  \/\/ Special internal-use-only method for use by JVM infrastructure\n+  \/\/ that needs to wait() on a java-level object but that can't risk\n+  \/\/ throwing unexpected InterruptedExecutionExceptions.\n+  static void waitUninterruptibly(Handle obj, jlong Millis, TRAPS);\n+\n@@ -210,0 +215,1 @@\n+  void wait_uninterruptibly(TRAPS)  { ObjectSynchronizer::waitUninterruptibly(_obj, 0, CHECK); } \/\/ wait forever\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -208,2 +208,3 @@\n-    else if (thread()->osthread()->get_state() == CONDVAR_WAIT) {\n-      \/\/ We are waiting on the native class initialization monitor.\n+    else if (thread()->osthread()->get_state() == OBJECT_WAIT) {\n+      \/\/ We are waiting on an Object monitor but Object.wait() isn't the\n+      \/\/ top-frame, so we should be waiting on a Class initialization monitor.\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -242,0 +242,1 @@\n+  nonstatic_field(InstanceKlass,               _is_marked_dependent,                          bool)                                  \\\n@@ -2236,1 +2237,0 @@\n-  declare_constant(InstanceKlass::being_linked)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1249,0 +1249,8 @@\n+  \/\/ Also provide a pointer to the init_lock if present, so there aren't unreferenced int[0]\n+  \/\/ arrays.\n+  oop init_lock = ik->init_lock();\n+  if (init_lock != nullptr) {\n+    field_count++;\n+    size += sizeof(address);\n+  }\n+\n@@ -1286,0 +1294,8 @@\n+\n+  \/\/ Add init lock to the end if the class is not yet initialized\n+  oop init_lock = ik->init_lock();\n+  if (init_lock != nullptr) {\n+    writer->write_symbolID(vmSymbols::init_lock_name());         \/\/ name\n+    writer->write_u1(sig2tag(vmSymbols::int_array_signature())); \/\/ type\n+    writer->write_objectID(init_lock);\n+  }\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-  private static int CLASS_STATE_BEING_LINKED;\n@@ -101,1 +100,0 @@\n-    CLASS_STATE_BEING_LINKED = db.lookupIntConstant(\"InstanceKlass::being_linked\").intValue();\n@@ -155,1 +153,0 @@\n-     public static final ClassState BEING_LINKED = new ClassState(\"beingLinked\");\n@@ -179,2 +176,0 @@\n-     } else if (state == CLASS_STATE_BEING_LINKED) {\n-        return ClassState.BEING_LINKED;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,2 +63,1 @@\n-    \/\/ final static String IN_OBJECT_WAIT = \"in Object.wait()\";\n-    final static String IN_CONVAR_WAIT = \"waiting on condition\";\n+    final static String IN_OBJECT_WAIT = \"in Object.wait()\";\n@@ -143,1 +142,1 @@\n-                    if (!line.contains(IN_CONVAR_WAIT)) {\n+                    if (!line.contains(IN_OBJECT_WAIT)) {\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestThreadDumpClassInitMonitor.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8333542\n+ * @summary Missed breakpoint due to JVM not blocking other threads while\n+ *          delivering a ClassPrepareEvent.\n+ *\n+ * @run build TestScaffold VMConnection TargetListener TargetAdapter\n+ * @run compile -g BreakpointOnClassPrepare.java\n+ * @run driver BreakpointOnClassPrepare SUSPEND_NONE\n+ * @run driver BreakpointOnClassPrepare SUSPEND_EVENT_THREAD\n+ * @run driver BreakpointOnClassPrepare SUSPEND_ALL\n+ *\/\n+\n+import com.sun.jdi.*;\n+import com.sun.jdi.event.*;\n+import com.sun.jdi.request.*;\n+\n+import java.util.*;\n+\n+\/\/ The debuggee spawns 50 threads that call LoadedClass.foo(). The debugger enables\n+\/\/ ClassPrepareEvent for LoadedClass, and sets a breakpoint on LoadedClass.foo() when\n+\/\/ the ClassPrepareEvent arrives. The debugger expects 50 breakpoints to be hit.\n+\/\/ This verifies that the thread that causes the generation of the ClassPrepareEvent\n+\/\/ has properly blocked all other threads from executing LoadedClass.foo() until the\n+\/\/ ClassPrepareEvent has been delivered.\n+\n+class LoadedClass {\n+    static void foo(int k) {\n+        System.out.println(\"HIT = \" + k); \/\/ set breakpoint here\n+    }\n+}\n+\n+class BreakpointOnClassPrepareTarg {\n+    public static void main(String[] args) throws InterruptedException {\n+        System.out.println(\"Start\");\n+        Thread threads[] = new Thread[BreakpointOnClassPrepare.NUM_BREAKPOINTS];\n+        for (int i = 0; i < BreakpointOnClassPrepare.NUM_BREAKPOINTS; i++) {\n+            int k = i;\n+            Thread t = DebuggeeWrapper.newThread(() -> {\n+                System.out.println(\"k = \" + k);\n+                LoadedClass.foo(k);\n+            });\n+            threads[i] = t;\n+            t.setDaemon(true);\n+            t.setName(\"MyThread-\" + k);\n+            t.start();\n+        }\n+\n+        for (int i = 0; i < BreakpointOnClassPrepare.NUM_BREAKPOINTS; i++) {\n+            try {\n+                Thread t = threads[i];\n+                t.join();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        System.out.println(\"Finish\");\n+    }\n+}\n+\n+    \/********** test program **********\/\n+\n+public class BreakpointOnClassPrepare extends TestScaffold {\n+    ClassType targetClass;\n+    ThreadReference mainThread;\n+\n+    BreakpointOnClassPrepare(String args[]) {\n+        super(args);\n+    }\n+\n+    public static void main(String[] args)      throws Exception {\n+        new BreakpointOnClassPrepare(args).startTests();\n+    }\n+\n+    \/********** event handlers **********\/\n+\n+    static final int NUM_BREAKPOINTS = 50;\n+    int bkptCount;\n+    BreakpointRequest bkptRequest;\n+\n+    public void breakpointReached(BreakpointEvent event) {\n+        bkptCount++;\n+        System.out.println(\"Got BreakpointEvent: \" + bkptCount + \" for thread \" + event.thread());\n+    }\n+\n+    public void vmDisconnected(VMDisconnectEvent event) {\n+        println(\"Got VMDisconnectEvent\");\n+    }\n+\n+    \/********** test core **********\/\n+\n+    protected void runTests() throws Exception {\n+        \/* Determine which suspend policy to use. *\/\n+        int policy;\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Invalid number of args: \" + args.length);\n+        }\n+        String policyString = args[0];\n+        if (policyString.equals(\"SUSPEND_NONE\")) {\n+            policy = EventRequest.SUSPEND_NONE;\n+        } else if (policyString.equals(\"SUSPEND_ALL\")) {\n+            policy = EventRequest.SUSPEND_ALL;\n+        } else if (policyString.equals(\"SUSPEND_EVENT_THREAD\")) {\n+            policy = EventRequest.SUSPEND_EVENT_THREAD;\n+        } else {\n+            throw new RuntimeException(\"Invalid suspend policy: \" + policyString);\n+        }\n+\n+        \/* Stop when the target is loaded. *\/\n+        BreakpointEvent bpe = startToMain(\"BreakpointOnClassPrepareTarg\");\n+\n+        \/* Stop when \"LoadedClass\" is loaded. *\/\n+        EventRequestManager erm = vm().eventRequestManager();\n+        ClassPrepareEvent cpe = resumeToPrepareOf(\"LoadedClass\");\n+        println(\"Got ClassPrepareEvent: \" + cpe);\n+\n+        \/* Set a breakpoint for each time LoadedClass.foo() is called. *\/\n+        ClassType loadedClass = (ClassType)cpe.referenceType() ;\n+        Location loc1 = findMethodLocation(loadedClass,  \"foo\", \"(I)V\", 1);\n+        bkptRequest = erm.createBreakpointRequest(loc1);\n+        bkptRequest.setSuspendPolicy(policy);\n+        bkptRequest.enable();\n+\n+        listenUntilVMDisconnect();\n+\n+        if (!testFailed && bkptCount == NUM_BREAKPOINTS) {\n+            println(\"BreakpointOnClassPrepare: passed\");\n+        } else {\n+            throw new Exception(\"BreakpointOnClassPrepare: failed. bkptCount == \" + bkptCount);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/BreakpointOnClassPrepare.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"}]}