{"files":[{"patch":"@@ -795,1 +795,1 @@\n-      DISABLED_WARNINGS_gcc_png.c := maybe-uninitialized, \\\n+      DISABLED_WARNINGS_gcc_png.c := maybe-uninitialized unused-function, \\\n@@ -803,0 +803,1 @@\n+      DISABLED_WARNINGS_clang_png.c := unused-function, \\\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## libpng v1.6.43\n+## libpng v1.6.47\n@@ -12,2 +12,2 @@\n-Copyright (C) 1995-2024 The PNG Reference Library Authors.\n-Copyright (C) 2018-2024 Cosmin Truta\n+Copyright (c) 1995-2025 The PNG Reference Library Authors.\n+Copyright (C) 2018-2025 Cosmin Truta\n@@ -173,0 +173,1 @@\n+ * Lucas Chollet\n","filename":"src\/java.desktop\/share\/legal\/libpng.md","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -6199,0 +6199,55 @@\n+Version 1.6.44 [September 12, 2024]\n+  Hardened calculations in chroma handling to prevent overflows, and\n+    relaxed a constraint in cHRM validation to accomodate the standard\n+    ACES AP1 set of color primaries.\n+    (Contributed by John Bowler)\n+  Removed the ASM implementation of ARM Neon optimizations and updated\n+    the build accordingly. Only the remaining C implementation shall be\n+    used from now on, thus ensuring the support of the PAC\/BTI security\n+    features on ARM64.\n+    (Contributed by Ross Burton and John Bowler)\n+  Fixed the pickup of the PNG_HARDWARE_OPTIMIZATIONS option in the\n+    CMake build on FreeBSD\/amd64. This is an important performance fix\n+    on this platform.\n+  Applied various fixes and improvements to the CMake build.\n+    (Contributed by Eric Riff, Benjamin Buch and Erik Scholz)\n+  Added fuzzing targets for the simplified read API.\n+    (Contributed by Mikhail Khachayants)\n+  Fixed a build error involving pngtest.c under a custom config.\n+    This was a regression introduced in a code cleanup in libpng-1.6.43.\n+    (Contributed by Ben Wagner)\n+  Fixed and improved the config files for AppVeyor CI and Travis CI.\n+\n+Version 1.6.45 [January 7, 2025]\n+  Added support for the cICP chunk.\n+    (Contributed by Lucas Chollet and John Bowler)\n+  Adjusted and improved various checks in colorspace calculations.\n+    (Contributed by John Bowler)\n+  Rearranged the write order of colorspace chunks for better conformance\n+    with the PNG v3 draft specification.\n+    (Contributed by John Bowler)\n+  Raised the minimum required CMake version from 3.6 to 3.14.\n+  Forked off a development branch for libpng version 1.8.\n+\n+Version 1.6.46 [January 23, 2025]\n+  Added support for the mDCV and cLLI chunks.\n+    (Contributed by John Bowler)\n+  Fixed a build issue affecting C89 compilers.\n+    This was a regression introduced in libpng-1.6.45.\n+    (Contributed by John Bowler)\n+  Added makefile.c89, specifically for testing C89 compilers.\n+  Cleaned up contrib\/pngminus: corrected an old typo, removed an old\n+    workaround, and updated the CMake file.\n+\n+Version 1.6.47 [February 18, 2025]\n+  Modified the behaviour of colorspace chunks in order to adhere\n+    to the new precedence rules formulated in the latest draft of\n+    the PNG Specification.\n+    (Contributed by John Bowler)\n+  Fixed a latent bug in `png_write_iCCP`.\n+    This would have been a read-beyond-end-of-malloc vulnerability,\n+    introduced early in the libpng-1.6.0 development, yet (fortunately!)\n+    it was inaccessible before the above-mentioned modification of the\n+    colorspace precedence rules, due to pre-existing colorspace checks.\n+    (Reported by Bob Friesenhahn; fixed by John Bowler)\n+\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/CHANGES","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -7,2 +7,2 @@\n- * Copyright (c) 1995-2024 The PNG Reference Library Authors.\n- * Copyright (c) 2018-2024 Cosmin Truta.\n+ * Copyright (c) 1995-2025 The PNG Reference Library Authors.\n+ * Copyright (c) 2018-2025 Cosmin Truta.\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/LICENSE","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-README for libpng version 1.6.43\n+README for libpng version 1.6.47\n@@ -160,2 +160,0 @@\n-        oss-fuzz\/     =>  Files used by the OSS-Fuzz project for fuzz-testing\n-                          libpng\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/README","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018-2024 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -45,1 +45,28 @@\n-typedef png_libpng_version_1_6_43 Your_png_h_is_not_version_1_6_43;\n+typedef png_libpng_version_1_6_47 Your_png_h_is_not_version_1_6_47;\n+\n+\/* Sanity check the chunks definitions - PNG_KNOWN_CHUNKS from pngpriv.h and the\n+ * corresponding macro definitions.  This causes a compile time failure if\n+ * something is wrong but generates no code.\n+ *\n+ * (1) The first check is that the PNG_CHUNK(cHNK, index) 'index' values must\n+ * increment from 0 to the last value.\n+ *\/\n+#define PNG_CHUNK(cHNK, index) != (index) || ((index)+1)\n+\n+#if 0 PNG_KNOWN_CHUNKS < 0\n+#  error PNG_KNOWN_CHUNKS chunk definitions are not in order\n+#endif\n+\n+#undef PNG_CHUNK\n+\n+\/* (2) The chunk name macros, png_cHNK, must all be valid and defined.  Since\n+ * this is a preprocessor test undefined pp-tokens come out as zero and will\n+ * fail this test.\n+ *\/\n+#define PNG_CHUNK(cHNK, index) !PNG_CHUNK_NAME_VALID(png_ ## cHNK) ||\n+\n+#if PNG_KNOWN_CHUNKS 0\n+#  error png_cHNK not defined for some known cHNK\n+#endif\n+\n+#undef PNG_CHUNK\n@@ -273,1 +300,0 @@\n-   \/* Added at libpng-1.2.6 *\/\n@@ -279,1 +305,0 @@\n-      \/* Added at libpng-1.2.43 and 1.4.0 *\/\n@@ -283,4 +308,1 @@\n-#     ifdef PNG_USER_CHUNK_MALLOC_MAX\n-      \/* Added at libpng-1.2.43 and 1.4.1, required only for read but exists\n-       * in png_struct regardless.\n-       *\/\n+#     if PNG_USER_CHUNK_MALLOC_MAX > 0 \/* default to compile-time limit *\/\n@@ -288,0 +310,7 @@\n+\n+      \/* No compile-time limit, so initialize to the system limit: *\/\n+#     elif defined PNG_MAX_MALLOC_64K \/* legacy system limit *\/\n+      create_struct.user_chunk_malloc_max = 65536U;\n+\n+#     else \/* modern system limit SIZE_MAX (C99) *\/\n+      create_struct.user_chunk_malloc_max = PNG_SIZE_MAX;\n@@ -629,7 +658,0 @@\n-# ifdef PNG_READ_eXIf_SUPPORTED\n-      if (info_ptr->eXIf_buf)\n-      {\n-         png_free(png_ptr, info_ptr->eXIf_buf);\n-         info_ptr->eXIf_buf = NULL;\n-      }\n-# endif\n@@ -825,2 +847,2 @@\n-      \"libpng version 1.6.43\" PNG_STRING_NEWLINE \\\n-      \"Copyright (c) 2018-2024 Cosmin Truta\" PNG_STRING_NEWLINE \\\n+      \"libpng version 1.6.47\" PNG_STRING_NEWLINE \\\n+      \"Copyright (c) 2018-2025 Cosmin Truta\" PNG_STRING_NEWLINE \\\n@@ -1070,18 +1092,3 @@\n-\/* png_convert_size: a PNGAPI but no longer in png.h, so deleted\n- * at libpng 1.5.5!\n- *\/\n-\n-\/* Added at libpng version 1.2.34 and 1.4.0 (moved from pngset.c) *\/\n-#ifdef PNG_GAMMA_SUPPORTED \/* always set if COLORSPACE *\/\n-static int\n-png_colorspace_check_gamma(png_const_structrp png_ptr,\n-    png_colorspacerp colorspace, png_fixed_point gAMA, int from)\n-   \/* This is called to check a new gamma value against an existing one.  The\n-    * routine returns false if the new gamma value should not be written.\n-    *\n-    * 'from' says where the new gamma value comes from:\n-    *\n-    *    0: the new gamma value is the libpng estimate for an ICC profile\n-    *    1: the new gamma value comes from a gAMA chunk\n-    *    2: the new gamma value comes from an sRGB chunk\n-    *\/\n+#ifdef PNG_COLORSPACE_SUPPORTED\n+static png_int_32\n+png_fp_add(png_int_32 addend0, png_int_32 addend1, int *error)\n@@ -1089,5 +1096,7 @@\n-   png_fixed_point gtest;\n-\n-   if ((colorspace->flags & PNG_COLORSPACE_HAVE_GAMMA) != 0 &&\n-       (png_muldiv(&gtest, colorspace->gamma, PNG_FP_1, gAMA) == 0  ||\n-      png_gamma_significant(gtest) != 0))\n+   \/* Safely add two fixed point values setting an error flag and returning 0.5\n+    * on overflow.\n+    * IMPLEMENTATION NOTE: ANSI requires signed overflow not to occur, therefore\n+    * relying on addition of two positive values producing a negative one is not\n+    * safe.\n+    *\/\n+   if (addend0 > 0)\n@@ -1095,20 +1104,2 @@\n-      \/* Either this is an sRGB image, in which case the calculated gamma\n-       * approximation should match, or this is an image with a profile and the\n-       * value libpng calculates for the gamma of the profile does not match the\n-       * value recorded in the file.  The former, sRGB, case is an error, the\n-       * latter is just a warning.\n-       *\/\n-      if ((colorspace->flags & PNG_COLORSPACE_FROM_sRGB) != 0 || from == 2)\n-      {\n-         png_chunk_report(png_ptr, \"gamma value does not match sRGB\",\n-             PNG_CHUNK_ERROR);\n-         \/* Do not overwrite an sRGB value *\/\n-         return from == 2;\n-      }\n-\n-      else \/* sRGB tag not involved *\/\n-      {\n-         png_chunk_report(png_ptr, \"gamma value does not match libpng estimate\",\n-             PNG_CHUNK_WARNING);\n-         return from == 1;\n-      }\n+      if (0x7fffffff - addend0 >= addend1)\n+         return addend0+addend1;\n@@ -1116,36 +1107,1 @@\n-\n-   return 1;\n-}\n-\n-void \/* PRIVATE *\/\n-png_colorspace_set_gamma(png_const_structrp png_ptr,\n-    png_colorspacerp colorspace, png_fixed_point gAMA)\n-{\n-   \/* Changed in libpng-1.5.4 to limit the values to ensure overflow can't\n-    * occur.  Since the fixed point representation is asymmetrical it is\n-    * possible for 1\/gamma to overflow the limit of 21474 and this means the\n-    * gamma value must be at least 5\/100000 and hence at most 20000.0.  For\n-    * safety the limits here are a little narrower.  The values are 0.00016 to\n-    * 6250.0, which are truly ridiculous gamma values (and will produce\n-    * displays that are all black or all white.)\n-    *\n-    * In 1.6.0 this test replaces the ones in pngrutil.c, in the gAMA chunk\n-    * handling code, which only required the value to be >0.\n-    *\/\n-   png_const_charp errmsg;\n-\n-   if (gAMA < 16 || gAMA > 625000000)\n-      errmsg = \"gamma value out of range\";\n-\n-#  ifdef PNG_READ_gAMA_SUPPORTED\n-   \/* Allow the application to set the gamma value more than once *\/\n-   else if ((png_ptr->mode & PNG_IS_READ_STRUCT) != 0 &&\n-      (colorspace->flags & PNG_COLORSPACE_FROM_gAMA) != 0)\n-      errmsg = \"duplicate\";\n-#  endif\n-\n-   \/* Do nothing if the colorspace is already invalid *\/\n-   else if ((colorspace->flags & PNG_COLORSPACE_INVALID) != 0)\n-      return;\n-\n-   else\n+   else if (addend0 < 0)\n@@ -1153,15 +1109,2 @@\n-      if (png_colorspace_check_gamma(png_ptr, colorspace, gAMA,\n-          1\/*from gAMA*\/) != 0)\n-      {\n-         \/* Store this gamma value. *\/\n-         colorspace->gamma = gAMA;\n-         colorspace->flags |=\n-            (PNG_COLORSPACE_HAVE_GAMMA | PNG_COLORSPACE_FROM_gAMA);\n-      }\n-\n-      \/* At present if the check_gamma test fails the gamma of the colorspace is\n-       * not updated however the colorspace is not invalidated.  This\n-       * corresponds to the case where the existing gamma comes from an sRGB\n-       * chunk or profile.  An error message has already been output.\n-       *\/\n-      return;\n+      if (-0x7fffffff - addend0 <= addend1)\n+         return addend0+addend1;\n@@ -1169,0 +1112,2 @@\n+   else\n+      return addend1;\n@@ -1170,3 +1115,2 @@\n-   \/* Error exit - errmsg has been set. *\/\n-   colorspace->flags |= PNG_COLORSPACE_INVALID;\n-   png_chunk_report(png_ptr, errmsg, PNG_CHUNK_WRITE_ERROR);\n+   *error = 1;\n+   return PNG_FP_1\/2;\n@@ -1175,2 +1119,2 @@\n-void \/* PRIVATE *\/\n-png_colorspace_sync_info(png_const_structrp png_ptr, png_inforp info_ptr)\n+static png_int_32\n+png_fp_sub(png_int_32 addend0, png_int_32 addend1, int *error)\n@@ -1178,1 +1122,2 @@\n-   if ((info_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) != 0)\n+   \/* As above but calculate addend0-addend1. *\/\n+   if (addend1 > 0)\n@@ -1180,10 +1125,2 @@\n-      \/* Everything is invalid *\/\n-      info_ptr->valid &= ~(PNG_INFO_gAMA|PNG_INFO_cHRM|PNG_INFO_sRGB|\n-         PNG_INFO_iCCP);\n-\n-#     ifdef PNG_COLORSPACE_SUPPORTED\n-      \/* Clean up the iCCP profile now if it won't be used. *\/\n-      png_free_data(png_ptr, info_ptr, PNG_FREE_ICCP, -1\/*not used*\/);\n-#     else\n-      PNG_UNUSED(png_ptr)\n-#     endif\n+      if (-0x7fffffff + addend1 <= addend0)\n+         return addend0-addend1;\n@@ -1191,2 +1128,1 @@\n-\n-   else\n+   else if (addend1 < 0)\n@@ -1194,23 +1130,2 @@\n-#     ifdef PNG_COLORSPACE_SUPPORTED\n-      \/* Leave the INFO_iCCP flag set if the pngset.c code has already set\n-       * it; this allows a PNG to contain a profile which matches sRGB and\n-       * yet still have that profile retrievable by the application.\n-       *\/\n-      if ((info_ptr->colorspace.flags & PNG_COLORSPACE_MATCHES_sRGB) != 0)\n-         info_ptr->valid |= PNG_INFO_sRGB;\n-\n-      else\n-         info_ptr->valid &= ~PNG_INFO_sRGB;\n-\n-      if ((info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)\n-         info_ptr->valid |= PNG_INFO_cHRM;\n-\n-      else\n-         info_ptr->valid &= ~PNG_INFO_cHRM;\n-#     endif\n-\n-      if ((info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_GAMMA) != 0)\n-         info_ptr->valid |= PNG_INFO_gAMA;\n-\n-      else\n-         info_ptr->valid &= ~PNG_INFO_gAMA;\n+      if (0x7fffffff + addend1 >= addend0)\n+         return addend0-addend1;\n@@ -1218,0 +1133,5 @@\n+   else\n+      return addend0;\n+\n+   *error = 1;\n+   return PNG_FP_1\/2;\n@@ -1220,3 +1140,3 @@\n-#ifdef PNG_READ_SUPPORTED\n-void \/* PRIVATE *\/\n-png_colorspace_sync(png_const_structrp png_ptr, png_inforp info_ptr)\n+static int\n+png_safe_add(png_int_32 *addend0_and_result, png_int_32 addend1,\n+      png_int_32 addend2)\n@@ -1224,5 +1144,9 @@\n-   if (info_ptr == NULL) \/* reduce code size; check here not in the caller *\/\n-      return;\n-\n-   info_ptr->colorspace = png_ptr->colorspace;\n-   png_colorspace_sync_info(png_ptr, info_ptr);\n+   \/* Safely add three integers.  Returns 0 on success, 1 on overflow.  Does not\n+    * set the result on overflow.\n+    *\/\n+   int error = 0;\n+   int result = png_fp_add(*addend0_and_result,\n+                           png_fp_add(addend1, addend2, &error),\n+                           &error);\n+   if (!error) *addend0_and_result = result;\n+   return error;\n@@ -1230,2 +1154,0 @@\n-#endif\n-#endif \/* GAMMA *\/\n@@ -1233,1 +1155,0 @@\n-#ifdef PNG_COLORSPACE_SUPPORTED\n@@ -1239,1 +1160,1 @@\n-static int\n+int \/* PRIVATE *\/\n@@ -1242,1 +1163,2 @@\n-   png_int_32 d, dwhite, whiteX, whiteY;\n+   \/* NOTE: returns 0 on success, 1 means error. *\/\n+   png_int_32 d, dred, dgreen, dblue, dwhite, whiteX, whiteY;\n@@ -1244,2 +1166,5 @@\n-   d = XYZ->red_X + XYZ->red_Y + XYZ->red_Z;\n-   if (png_muldiv(&xy->redx, XYZ->red_X, PNG_FP_1, d) == 0)\n+   \/* 'd' in each of the blocks below is just X+Y+Z for each component,\n+    * x, y and z are X,Y,Z\/(X+Y+Z).\n+    *\/\n+   d = XYZ->red_X;\n+   if (png_safe_add(&d, XYZ->red_Y, XYZ->red_Z))\n@@ -1247,1 +1172,4 @@\n-   if (png_muldiv(&xy->redy, XYZ->red_Y, PNG_FP_1, d) == 0)\n+   dred = d;\n+   if (png_muldiv(&xy->redx, XYZ->red_X, PNG_FP_1, dred) == 0)\n+      return 1;\n+   if (png_muldiv(&xy->redy, XYZ->red_Y, PNG_FP_1, dred) == 0)\n@@ -1249,3 +1177,0 @@\n-   dwhite = d;\n-   whiteX = XYZ->red_X;\n-   whiteY = XYZ->red_Y;\n@@ -1253,2 +1178,2 @@\n-   d = XYZ->green_X + XYZ->green_Y + XYZ->green_Z;\n-   if (png_muldiv(&xy->greenx, XYZ->green_X, PNG_FP_1, d) == 0)\n+   d = XYZ->green_X;\n+   if (png_safe_add(&d, XYZ->green_Y, XYZ->green_Z))\n@@ -1256,1 +1181,4 @@\n-   if (png_muldiv(&xy->greeny, XYZ->green_Y, PNG_FP_1, d) == 0)\n+   dgreen = d;\n+   if (png_muldiv(&xy->greenx, XYZ->green_X, PNG_FP_1, dgreen) == 0)\n+      return 1;\n+   if (png_muldiv(&xy->greeny, XYZ->green_Y, PNG_FP_1, dgreen) == 0)\n@@ -1258,3 +1186,0 @@\n-   dwhite += d;\n-   whiteX += XYZ->green_X;\n-   whiteY += XYZ->green_Y;\n@@ -1262,2 +1187,5 @@\n-   d = XYZ->blue_X + XYZ->blue_Y + XYZ->blue_Z;\n-   if (png_muldiv(&xy->bluex, XYZ->blue_X, PNG_FP_1, d) == 0)\n+   d = XYZ->blue_X;\n+   if (png_safe_add(&d, XYZ->blue_Y, XYZ->blue_Z))\n+      return 1;\n+   dblue = d;\n+   if (png_muldiv(&xy->bluex, XYZ->blue_X, PNG_FP_1, dblue) == 0)\n@@ -1265,1 +1193,1 @@\n-   if (png_muldiv(&xy->bluey, XYZ->blue_Y, PNG_FP_1, d) == 0)\n+   if (png_muldiv(&xy->bluey, XYZ->blue_Y, PNG_FP_1, dblue) == 0)\n@@ -1267,3 +1195,0 @@\n-   dwhite += d;\n-   whiteX += XYZ->blue_X;\n-   whiteY += XYZ->blue_Y;\n@@ -1271,2 +1196,3 @@\n-   \/* The reference white is simply the sum of the end-point (X,Y,Z) vectors,\n-    * thus:\n+   \/* The reference white is simply the sum of the end-point (X,Y,Z) vectors so\n+    * the fillowing calculates (X+Y+Z) of the reference white (media white,\n+    * encoding white) itself:\n@@ -1274,0 +1200,18 @@\n+   d = dblue;\n+   if (png_safe_add(&d, dred, dgreen))\n+      return 1;\n+   dwhite = d;\n+\n+   \/* Find the white X,Y values from the sum of the red, green and blue X,Y\n+    * values.\n+    *\/\n+   d = XYZ->red_X;\n+   if (png_safe_add(&d, XYZ->green_X, XYZ->blue_X))\n+      return 1;\n+   whiteX = d;\n+\n+   d = XYZ->red_Y;\n+   if (png_safe_add(&d, XYZ->green_Y, XYZ->blue_Y))\n+      return 1;\n+   whiteY = d;\n+\n@@ -1282,1 +1226,1 @@\n-static int\n+int \/* PRIVATE *\/\n@@ -1285,0 +1229,1 @@\n+   \/* NOTE: returns 0 on success, 1 means error. *\/\n@@ -1292,0 +1237,8 @@\n+    *\n+    * The limits here will *not* accept ACES AP0, where bluey is -7700\n+    * (-0.0770) because the PNG spec itself requires the xy values to be\n+    * unsigned.  whitey is also required to be 5 or more to avoid overflow.\n+    *\n+    * Instead the upper limits have been relaxed to accomodate ACES AP1 where\n+    * redz ends up as -600 (-0.006).  ProPhotoRGB was already \"in range.\"\n+    * The new limit accomodates the AP0 and AP1 ranges for z but not AP0 redy.\n@@ -1293,8 +1246,9 @@\n-   if (xy->redx   < 0 || xy->redx > PNG_FP_1) return 1;\n-   if (xy->redy   < 0 || xy->redy > PNG_FP_1-xy->redx) return 1;\n-   if (xy->greenx < 0 || xy->greenx > PNG_FP_1) return 1;\n-   if (xy->greeny < 0 || xy->greeny > PNG_FP_1-xy->greenx) return 1;\n-   if (xy->bluex  < 0 || xy->bluex > PNG_FP_1) return 1;\n-   if (xy->bluey  < 0 || xy->bluey > PNG_FP_1-xy->bluex) return 1;\n-   if (xy->whitex < 0 || xy->whitex > PNG_FP_1) return 1;\n-   if (xy->whitey < 5 || xy->whitey > PNG_FP_1-xy->whitex) return 1;\n+   const png_fixed_point fpLimit = PNG_FP_1+(PNG_FP_1\/10);\n+   if (xy->redx   < 0 || xy->redx > fpLimit) return 1;\n+   if (xy->redy   < 0 || xy->redy > fpLimit-xy->redx) return 1;\n+   if (xy->greenx < 0 || xy->greenx > fpLimit) return 1;\n+   if (xy->greeny < 0 || xy->greeny > fpLimit-xy->greenx) return 1;\n+   if (xy->bluex  < 0 || xy->bluex > fpLimit) return 1;\n+   if (xy->bluey  < 0 || xy->bluey > fpLimit-xy->bluex) return 1;\n+   if (xy->whitex < 0 || xy->whitex > fpLimit) return 1;\n+   if (xy->whitey < 5 || xy->whitey > fpLimit-xy->whitex) return 1;\n@@ -1445,5 +1399,10 @@\n-    * The input values have 5 decimal digits of accuracy.  The values are all in\n-    * the range 0 < value < 1, so simple products are in the same range but may\n-    * need up to 10 decimal digits to preserve the original precision and avoid\n-    * underflow.  Because we are using a 32-bit signed representation we cannot\n-    * match this; the best is a little over 9 decimal digits, less than 10.\n+    * The input values have 5 decimal digits of accuracy.\n+    *\n+    * In the previous implementation the values were all in the range 0 < value\n+    * < 1, so simple products are in the same range but may need up to 10\n+    * decimal digits to preserve the original precision and avoid underflow.\n+    * Because we are using a 32-bit signed representation we cannot match this;\n+    * the best is a little over 9 decimal digits, less than 10.\n+    *\n+    * This range has now been extended to allow values up to 1.1, or 110,000 in\n+    * fixed point.\n@@ -1453,4 +1412,4 @@\n-    * difference between two products of values that must be in the range -1..+1\n-    * it is sufficient to divide the product by 7; ceil(100,000\/32767*2).  The\n-    * factor is irrelevant in the calculation because it is applied to both\n-    * numerator and denominator.\n+    * difference between two products of values that must be in the range\n+    * -1.1..+1.1 it is sufficient to divide the product by 8;\n+    * ceil(121,000\/32767*2).  The factor is irrelevant in the calculation\n+    * because it is applied to both numerator and denominator.\n@@ -1478,23 +1437,2 @@\n-   \/* By the argument, above overflow should be impossible here. The return\n-    * value of 2 indicates an internal error to the caller.\n-    *\/\n-   if (png_muldiv(&left, xy->greenx-xy->bluex, xy->redy - xy->bluey, 7) == 0)\n-      return 2;\n-   if (png_muldiv(&right, xy->greeny-xy->bluey, xy->redx - xy->bluex, 7) == 0)\n-      return 2;\n-   denominator = left - right;\n-\n-   \/* Now find the red numerator. *\/\n-   if (png_muldiv(&left, xy->greenx-xy->bluex, xy->whitey-xy->bluey, 7) == 0)\n-      return 2;\n-   if (png_muldiv(&right, xy->greeny-xy->bluey, xy->whitex-xy->bluex, 7) == 0)\n-      return 2;\n-\n-   \/* Overflow is possible here and it indicates an extreme set of PNG cHRM\n-    * chunk values.  This calculation actually returns the reciprocal of the\n-    * scale value because this allows us to delay the multiplication of white-y\n-    * into the denominator, which tends to produce a small number.\n-    *\/\n-   if (png_muldiv(&red_inverse, xy->whitey, denominator, left-right) == 0 ||\n-       red_inverse <= xy->whitey \/* r+g+b scales = white scale *\/)\n-      return 1;\n+   {\n+      int error = 0;\n@@ -1502,8 +1440,13 @@\n-   \/* Similarly for green_inverse: *\/\n-   if (png_muldiv(&left, xy->redy-xy->bluey, xy->whitex-xy->bluex, 7) == 0)\n-      return 2;\n-   if (png_muldiv(&right, xy->redx-xy->bluex, xy->whitey-xy->bluey, 7) == 0)\n-      return 2;\n-   if (png_muldiv(&green_inverse, xy->whitey, denominator, left-right) == 0 ||\n-       green_inverse <= xy->whitey)\n-      return 1;\n+      \/* By the argument above overflow should be impossible here, however the\n+       * code now simply returns a failure code.  The xy subtracts in the\n+       * arguments to png_muldiv are *not* checked for overflow because the\n+       * checks at the start guarantee they are in the range 0..110000 and\n+       * png_fixed_point is a 32-bit signed number.\n+       *\/\n+      if (png_muldiv(&left, xy->greenx-xy->bluex, xy->redy - xy->bluey, 8) == 0)\n+         return 1;\n+      if (png_muldiv(&right, xy->greeny-xy->bluey, xy->redx - xy->bluex, 8) ==\n+            0)\n+         return 1;\n+      denominator = png_fp_sub(left, right, &error);\n+      if (error) return 1;\n@@ -1511,7 +1454,6 @@\n-   \/* And the blue scale, the checks above guarantee this can't overflow but it\n-    * can still produce 0 for extreme cHRM values.\n-    *\/\n-   blue_scale = png_reciprocal(xy->whitey) - png_reciprocal(red_inverse) -\n-       png_reciprocal(green_inverse);\n-   if (blue_scale <= 0)\n-      return 1;\n+      \/* Now find the red numerator. *\/\n+      if (png_muldiv(&left, xy->greenx-xy->bluex, xy->whitey-xy->bluey, 8) == 0)\n+         return 1;\n+      if (png_muldiv(&right, xy->greeny-xy->bluey, xy->whitex-xy->bluex, 8) ==\n+            0)\n+         return 1;\n@@ -1519,0 +1461,9 @@\n+      \/* Overflow is possible here and it indicates an extreme set of PNG cHRM\n+       * chunk values.  This calculation actually returns the reciprocal of the\n+       * scale value because this allows us to delay the multiplication of\n+       * white-y into the denominator, which tends to produce a small number.\n+       *\/\n+      if (png_muldiv(&red_inverse, xy->whitey, denominator,\n+                     png_fp_sub(left, right, &error)) == 0 || error ||\n+          red_inverse <= xy->whitey \/* r+g+b scales = white scale *\/)\n+         return 1;\n@@ -1520,1 +1471,24 @@\n-   \/* And fill in the png_XYZ: *\/\n+      \/* Similarly for green_inverse: *\/\n+      if (png_muldiv(&left, xy->redy-xy->bluey, xy->whitex-xy->bluex, 8) == 0)\n+         return 1;\n+      if (png_muldiv(&right, xy->redx-xy->bluex, xy->whitey-xy->bluey, 8) == 0)\n+         return 1;\n+      if (png_muldiv(&green_inverse, xy->whitey, denominator,\n+                     png_fp_sub(left, right, &error)) == 0 || error ||\n+          green_inverse <= xy->whitey)\n+         return 1;\n+\n+      \/* And the blue scale, the checks above guarantee this can't overflow but\n+       * it can still produce 0 for extreme cHRM values.\n+       *\/\n+      blue_scale = png_fp_sub(png_fp_sub(png_reciprocal(xy->whitey),\n+                                         png_reciprocal(red_inverse), &error),\n+                              png_reciprocal(green_inverse), &error);\n+      if (error || blue_scale <= 0)\n+         return 1;\n+   }\n+\n+   \/* And fill in the png_XYZ.  Again the subtracts are safe because of the\n+    * checks on the xy values at the start (the subtracts just calculate the\n+    * corresponding z values.)\n+    *\/\n@@ -1547,0 +1521,1 @@\n+#endif \/* COLORSPACE *\/\n@@ -1548,243 +1523,1 @@\n-static int\n-png_XYZ_normalize(png_XYZ *XYZ)\n-{\n-   png_int_32 Y;\n-\n-   if (XYZ->red_Y < 0 || XYZ->green_Y < 0 || XYZ->blue_Y < 0 ||\n-      XYZ->red_X < 0 || XYZ->green_X < 0 || XYZ->blue_X < 0 ||\n-      XYZ->red_Z < 0 || XYZ->green_Z < 0 || XYZ->blue_Z < 0)\n-      return 1;\n-\n-   \/* Normalize by scaling so the sum of the end-point Y values is PNG_FP_1.\n-    * IMPLEMENTATION NOTE: ANSI requires signed overflow not to occur, therefore\n-    * relying on addition of two positive values producing a negative one is not\n-    * safe.\n-    *\/\n-   Y = XYZ->red_Y;\n-   if (0x7fffffff - Y < XYZ->green_X)\n-      return 1;\n-   Y += XYZ->green_Y;\n-   if (0x7fffffff - Y < XYZ->blue_X)\n-      return 1;\n-   Y += XYZ->blue_Y;\n-\n-   if (Y != PNG_FP_1)\n-   {\n-      if (png_muldiv(&XYZ->red_X, XYZ->red_X, PNG_FP_1, Y) == 0)\n-         return 1;\n-      if (png_muldiv(&XYZ->red_Y, XYZ->red_Y, PNG_FP_1, Y) == 0)\n-         return 1;\n-      if (png_muldiv(&XYZ->red_Z, XYZ->red_Z, PNG_FP_1, Y) == 0)\n-         return 1;\n-\n-      if (png_muldiv(&XYZ->green_X, XYZ->green_X, PNG_FP_1, Y) == 0)\n-         return 1;\n-      if (png_muldiv(&XYZ->green_Y, XYZ->green_Y, PNG_FP_1, Y) == 0)\n-         return 1;\n-      if (png_muldiv(&XYZ->green_Z, XYZ->green_Z, PNG_FP_1, Y) == 0)\n-         return 1;\n-\n-      if (png_muldiv(&XYZ->blue_X, XYZ->blue_X, PNG_FP_1, Y) == 0)\n-         return 1;\n-      if (png_muldiv(&XYZ->blue_Y, XYZ->blue_Y, PNG_FP_1, Y) == 0)\n-         return 1;\n-      if (png_muldiv(&XYZ->blue_Z, XYZ->blue_Z, PNG_FP_1, Y) == 0)\n-         return 1;\n-   }\n-\n-   return 0;\n-}\n-\n-static int\n-png_colorspace_endpoints_match(const png_xy *xy1, const png_xy *xy2, int delta)\n-{\n-   \/* Allow an error of +\/-0.01 (absolute value) on each chromaticity *\/\n-   if (PNG_OUT_OF_RANGE(xy1->whitex, xy2->whitex,delta) ||\n-       PNG_OUT_OF_RANGE(xy1->whitey, xy2->whitey,delta) ||\n-       PNG_OUT_OF_RANGE(xy1->redx,   xy2->redx,  delta) ||\n-       PNG_OUT_OF_RANGE(xy1->redy,   xy2->redy,  delta) ||\n-       PNG_OUT_OF_RANGE(xy1->greenx, xy2->greenx,delta) ||\n-       PNG_OUT_OF_RANGE(xy1->greeny, xy2->greeny,delta) ||\n-       PNG_OUT_OF_RANGE(xy1->bluex,  xy2->bluex, delta) ||\n-       PNG_OUT_OF_RANGE(xy1->bluey,  xy2->bluey, delta))\n-      return 0;\n-   return 1;\n-}\n-\n-\/* Added in libpng-1.6.0, a different check for the validity of a set of cHRM\n- * chunk chromaticities.  Earlier checks used to simply look for the overflow\n- * condition (where the determinant of the matrix to solve for XYZ ends up zero\n- * because the chromaticity values are not all distinct.)  Despite this it is\n- * theoretically possible to produce chromaticities that are apparently valid\n- * but that rapidly degrade to invalid, potentially crashing, sets because of\n- * arithmetic inaccuracies when calculations are performed on them.  The new\n- * check is to round-trip xy -> XYZ -> xy and then check that the result is\n- * within a small percentage of the original.\n- *\/\n-static int\n-png_colorspace_check_xy(png_XYZ *XYZ, const png_xy *xy)\n-{\n-   int result;\n-   png_xy xy_test;\n-\n-   \/* As a side-effect this routine also returns the XYZ endpoints. *\/\n-   result = png_XYZ_from_xy(XYZ, xy);\n-   if (result != 0)\n-      return result;\n-\n-   result = png_xy_from_XYZ(&xy_test, XYZ);\n-   if (result != 0)\n-      return result;\n-\n-   if (png_colorspace_endpoints_match(xy, &xy_test,\n-       5\/*actually, the math is pretty accurate*\/) != 0)\n-      return 0;\n-\n-   \/* Too much slip *\/\n-   return 1;\n-}\n-\n-\/* This is the check going the other way.  The XYZ is modified to normalize it\n- * (another side-effect) and the xy chromaticities are returned.\n- *\/\n-static int\n-png_colorspace_check_XYZ(png_xy *xy, png_XYZ *XYZ)\n-{\n-   int result;\n-   png_XYZ XYZtemp;\n-\n-   result = png_XYZ_normalize(XYZ);\n-   if (result != 0)\n-      return result;\n-\n-   result = png_xy_from_XYZ(xy, XYZ);\n-   if (result != 0)\n-      return result;\n-\n-   XYZtemp = *XYZ;\n-   return png_colorspace_check_xy(&XYZtemp, xy);\n-}\n-\n-\/* Used to check for an endpoint match against sRGB *\/\n-static const png_xy sRGB_xy = \/* From ITU-R BT.709-3 *\/\n-{\n-   \/* color      x       y *\/\n-   \/* red   *\/ 64000, 33000,\n-   \/* green *\/ 30000, 60000,\n-   \/* blue  *\/ 15000,  6000,\n-   \/* white *\/ 31270, 32900\n-};\n-\n-static int\n-png_colorspace_set_xy_and_XYZ(png_const_structrp png_ptr,\n-    png_colorspacerp colorspace, const png_xy *xy, const png_XYZ *XYZ,\n-    int preferred)\n-{\n-   if ((colorspace->flags & PNG_COLORSPACE_INVALID) != 0)\n-      return 0;\n-\n-   \/* The consistency check is performed on the chromaticities; this factors out\n-    * variations because of the normalization (or not) of the end point Y\n-    * values.\n-    *\/\n-   if (preferred < 2 &&\n-       (colorspace->flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)\n-   {\n-      \/* The end points must be reasonably close to any we already have.  The\n-       * following allows an error of up to +\/-.001\n-       *\/\n-      if (png_colorspace_endpoints_match(xy, &colorspace->end_points_xy,\n-          100) == 0)\n-      {\n-         colorspace->flags |= PNG_COLORSPACE_INVALID;\n-         png_benign_error(png_ptr, \"inconsistent chromaticities\");\n-         return 0; \/* failed *\/\n-      }\n-\n-      \/* Only overwrite with preferred values *\/\n-      if (preferred == 0)\n-         return 1; \/* ok, but no change *\/\n-   }\n-\n-   colorspace->end_points_xy = *xy;\n-   colorspace->end_points_XYZ = *XYZ;\n-   colorspace->flags |= PNG_COLORSPACE_HAVE_ENDPOINTS;\n-\n-   \/* The end points are normally quoted to two decimal digits, so allow +\/-0.01\n-    * on this test.\n-    *\/\n-   if (png_colorspace_endpoints_match(xy, &sRGB_xy, 1000) != 0)\n-      colorspace->flags |= PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB;\n-\n-   else\n-      colorspace->flags &= PNG_COLORSPACE_CANCEL(\n-         PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB);\n-\n-   return 2; \/* ok and changed *\/\n-}\n-\n-int \/* PRIVATE *\/\n-png_colorspace_set_chromaticities(png_const_structrp png_ptr,\n-    png_colorspacerp colorspace, const png_xy *xy, int preferred)\n-{\n-   \/* We must check the end points to ensure they are reasonable - in the past\n-    * color management systems have crashed as a result of getting bogus\n-    * colorant values, while this isn't the fault of libpng it is the\n-    * responsibility of libpng because PNG carries the bomb and libpng is in a\n-    * position to protect against it.\n-    *\/\n-   png_XYZ XYZ;\n-\n-   switch (png_colorspace_check_xy(&XYZ, xy))\n-   {\n-      case 0: \/* success *\/\n-         return png_colorspace_set_xy_and_XYZ(png_ptr, colorspace, xy, &XYZ,\n-             preferred);\n-\n-      case 1:\n-         \/* We can't invert the chromaticities so we can't produce value XYZ\n-          * values.  Likely as not a color management system will fail too.\n-          *\/\n-         colorspace->flags |= PNG_COLORSPACE_INVALID;\n-         png_benign_error(png_ptr, \"invalid chromaticities\");\n-         break;\n-\n-      default:\n-         \/* libpng is broken; this should be a warning but if it happens we\n-          * want error reports so for the moment it is an error.\n-          *\/\n-         colorspace->flags |= PNG_COLORSPACE_INVALID;\n-         png_error(png_ptr, \"internal error checking chromaticities\");\n-   }\n-\n-   return 0; \/* failed *\/\n-}\n-\n-int \/* PRIVATE *\/\n-png_colorspace_set_endpoints(png_const_structrp png_ptr,\n-    png_colorspacerp colorspace, const png_XYZ *XYZ_in, int preferred)\n-{\n-   png_XYZ XYZ = *XYZ_in;\n-   png_xy xy;\n-\n-   switch (png_colorspace_check_XYZ(&xy, &XYZ))\n-   {\n-      case 0:\n-         return png_colorspace_set_xy_and_XYZ(png_ptr, colorspace, &xy, &XYZ,\n-             preferred);\n-\n-      case 1:\n-         \/* End points are invalid. *\/\n-         colorspace->flags |= PNG_COLORSPACE_INVALID;\n-         png_benign_error(png_ptr, \"invalid end points\");\n-         break;\n-\n-      default:\n-         colorspace->flags |= PNG_COLORSPACE_INVALID;\n-         png_error(png_ptr, \"internal error checking chromaticities\");\n-   }\n-\n-   return 0; \/* failed *\/\n-}\n-\n-#if defined(PNG_sRGB_SUPPORTED) || defined(PNG_iCCP_SUPPORTED)\n+#ifdef PNG_iCCP_SUPPORTED\n@@ -1830,2 +1563,2 @@\n-png_icc_profile_error(png_const_structrp png_ptr, png_colorspacerp colorspace,\n-    png_const_charp name, png_alloc_size_t value, png_const_charp reason)\n+png_icc_profile_error(png_const_structrp png_ptr, png_const_charp name,\n+   png_alloc_size_t value, png_const_charp reason)\n@@ -1836,3 +1569,0 @@\n-   if (colorspace != NULL)\n-      colorspace->flags |= PNG_COLORSPACE_INVALID;\n-\n@@ -1865,7 +1595,1 @@\n-   \/* This is recoverable, but make it unconditionally an app_error on write to\n-    * avoid writing invalid ICC profiles into PNG files (i.e., we handle them\n-    * on read, with a warning, but on write unless the app turns off\n-    * application errors the PNG won't be written.)\n-    *\/\n-   png_chunk_report(png_ptr, message,\n-       (colorspace != NULL) ? PNG_CHUNK_ERROR : PNG_CHUNK_WRITE_ERROR);\n+   png_chunk_benign_error(png_ptr, message);\n@@ -1875,91 +1599,1 @@\n-#endif \/* sRGB || iCCP *\/\n-\n-#ifdef PNG_sRGB_SUPPORTED\n-int \/* PRIVATE *\/\n-png_colorspace_set_sRGB(png_const_structrp png_ptr, png_colorspacerp colorspace,\n-    int intent)\n-{\n-   \/* sRGB sets known gamma, end points and (from the chunk) intent. *\/\n-   \/* IMPORTANT: these are not necessarily the values found in an ICC profile\n-    * because ICC profiles store values adapted to a D50 environment; it is\n-    * expected that the ICC profile mediaWhitePointTag will be D50; see the\n-    * checks and code elsewhere to understand this better.\n-    *\n-    * These XYZ values, which are accurate to 5dp, produce rgb to gray\n-    * coefficients of (6968,23435,2366), which are reduced (because they add up\n-    * to 32769 not 32768) to (6968,23434,2366).  These are the values that\n-    * libpng has traditionally used (and are the best values given the 15bit\n-    * algorithm used by the rgb to gray code.)\n-    *\/\n-   static const png_XYZ sRGB_XYZ = \/* D65 XYZ (*not* the D50 adapted values!) *\/\n-   {\n-      \/* color      X      Y      Z *\/\n-      \/* red   *\/ 41239, 21264,  1933,\n-      \/* green *\/ 35758, 71517, 11919,\n-      \/* blue  *\/ 18048,  7219, 95053\n-   };\n-\n-   \/* Do nothing if the colorspace is already invalidated. *\/\n-   if ((colorspace->flags & PNG_COLORSPACE_INVALID) != 0)\n-      return 0;\n-\n-   \/* Check the intent, then check for existing settings.  It is valid for the\n-    * PNG file to have cHRM or gAMA chunks along with sRGB, but the values must\n-    * be consistent with the correct values.  If, however, this function is\n-    * called below because an iCCP chunk matches sRGB then it is quite\n-    * conceivable that an older app recorded incorrect gAMA and cHRM because of\n-    * an incorrect calculation based on the values in the profile - this does\n-    * *not* invalidate the profile (though it still produces an error, which can\n-    * be ignored.)\n-    *\/\n-   if (intent < 0 || intent >= PNG_sRGB_INTENT_LAST)\n-      return png_icc_profile_error(png_ptr, colorspace, \"sRGB\",\n-          (png_alloc_size_t)intent, \"invalid sRGB rendering intent\");\n-\n-   if ((colorspace->flags & PNG_COLORSPACE_HAVE_INTENT) != 0 &&\n-       colorspace->rendering_intent != intent)\n-      return png_icc_profile_error(png_ptr, colorspace, \"sRGB\",\n-         (png_alloc_size_t)intent, \"inconsistent rendering intents\");\n-\n-   if ((colorspace->flags & PNG_COLORSPACE_FROM_sRGB) != 0)\n-   {\n-      png_benign_error(png_ptr, \"duplicate sRGB information ignored\");\n-      return 0;\n-   }\n-\n-   \/* If the standard sRGB cHRM chunk does not match the one from the PNG file\n-    * warn but overwrite the value with the correct one.\n-    *\/\n-   if ((colorspace->flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0 &&\n-       !png_colorspace_endpoints_match(&sRGB_xy, &colorspace->end_points_xy,\n-       100))\n-      png_chunk_report(png_ptr, \"cHRM chunk does not match sRGB\",\n-         PNG_CHUNK_ERROR);\n-\n-   \/* This check is just done for the error reporting - the routine always\n-    * returns true when the 'from' argument corresponds to sRGB (2).\n-    *\/\n-   (void)png_colorspace_check_gamma(png_ptr, colorspace, PNG_GAMMA_sRGB_INVERSE,\n-       2\/*from sRGB*\/);\n-\n-   \/* intent: bugs in GCC force 'int' to be used as the parameter type. *\/\n-   colorspace->rendering_intent = (png_uint_16)intent;\n-   colorspace->flags |= PNG_COLORSPACE_HAVE_INTENT;\n-\n-   \/* endpoints *\/\n-   colorspace->end_points_xy = sRGB_xy;\n-   colorspace->end_points_XYZ = sRGB_XYZ;\n-   colorspace->flags |=\n-      (PNG_COLORSPACE_HAVE_ENDPOINTS|PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB);\n-\n-   \/* gamma *\/\n-   colorspace->gamma = PNG_GAMMA_sRGB_INVERSE;\n-   colorspace->flags |= PNG_COLORSPACE_HAVE_GAMMA;\n-\n-   \/* Finally record that we have an sRGB profile *\/\n-   colorspace->flags |=\n-      (PNG_COLORSPACE_MATCHES_sRGB|PNG_COLORSPACE_FROM_sRGB);\n-\n-   return 1; \/* set *\/\n-}\n-#endif \/* sRGB *\/\n+#endif \/* iCCP *\/\n@@ -1967,1 +1601,1 @@\n-#ifdef PNG_iCCP_SUPPORTED\n+#ifdef PNG_READ_iCCP_SUPPORTED\n@@ -1977,2 +1611,2 @@\n-icc_check_length(png_const_structrp png_ptr, png_colorspacerp colorspace,\n-    png_const_charp name, png_uint_32 profile_length)\n+icc_check_length(png_const_structrp png_ptr, png_const_charp name,\n+   png_uint_32 profile_length)\n@@ -1981,2 +1615,1 @@\n-      return png_icc_profile_error(png_ptr, colorspace, name, profile_length,\n-          \"too short\");\n+      return png_icc_profile_error(png_ptr, name, profile_length, \"too short\");\n@@ -1986,1 +1619,0 @@\n-#ifdef PNG_READ_iCCP_SUPPORTED\n@@ -1988,2 +1620,2 @@\n-png_icc_check_length(png_const_structrp png_ptr, png_colorspacerp colorspace,\n-    png_const_charp name, png_uint_32 profile_length)\n+png_icc_check_length(png_const_structrp png_ptr, png_const_charp name,\n+   png_uint_32 profile_length)\n@@ -1991,1 +1623,1 @@\n-   if (!icc_check_length(png_ptr, colorspace, name, profile_length))\n+   if (!icc_check_length(png_ptr, name, profile_length))\n@@ -2000,15 +1632,3 @@\n-#  ifdef PNG_SET_USER_LIMITS_SUPPORTED\n-      else if (png_ptr->user_chunk_malloc_max > 0 &&\n-               png_ptr->user_chunk_malloc_max < profile_length)\n-         return png_icc_profile_error(png_ptr, colorspace, name, profile_length,\n-             \"exceeds application limits\");\n-#  elif PNG_USER_CHUNK_MALLOC_MAX > 0\n-      else if (PNG_USER_CHUNK_MALLOC_MAX < profile_length)\n-         return png_icc_profile_error(png_ptr, colorspace, name, profile_length,\n-             \"exceeds libpng limits\");\n-#  else \/* !SET_USER_LIMITS *\/\n-      \/* This will get compiled out on all 32-bit and better systems. *\/\n-      else if (PNG_SIZE_MAX < profile_length)\n-         return png_icc_profile_error(png_ptr, colorspace, name, profile_length,\n-             \"exceeds system limits\");\n-#  endif \/* !SET_USER_LIMITS *\/\n+   if (profile_length > png_chunk_max(png_ptr))\n+      return png_icc_profile_error(png_ptr, name, profile_length,\n+            \"profile too long\");\n@@ -2018,1 +1638,0 @@\n-#endif \/* READ_iCCP *\/\n@@ -2021,3 +1640,3 @@\n-png_icc_check_header(png_const_structrp png_ptr, png_colorspacerp colorspace,\n-    png_const_charp name, png_uint_32 profile_length,\n-    png_const_bytep profile\/* first 132 bytes only *\/, int color_type)\n+png_icc_check_header(png_const_structrp png_ptr, png_const_charp name,\n+   png_uint_32 profile_length,\n+   png_const_bytep profile\/* first 132 bytes only *\/, int color_type)\n@@ -2034,1 +1653,1 @@\n-      return png_icc_profile_error(png_ptr, colorspace, name, temp,\n+      return png_icc_profile_error(png_ptr, name, temp,\n@@ -2039,1 +1658,1 @@\n-      return png_icc_profile_error(png_ptr, colorspace, name, profile_length,\n+      return png_icc_profile_error(png_ptr, name, profile_length,\n@@ -2045,1 +1664,1 @@\n-      return png_icc_profile_error(png_ptr, colorspace, name, temp,\n+      return png_icc_profile_error(png_ptr, name, temp,\n@@ -2053,1 +1672,1 @@\n-      return png_icc_profile_error(png_ptr, colorspace, name, temp,\n+      return png_icc_profile_error(png_ptr, name, temp,\n@@ -2060,1 +1679,1 @@\n-      (void)png_icc_profile_error(png_ptr, NULL, name, temp,\n+      (void)png_icc_profile_error(png_ptr, name, temp,\n@@ -2077,1 +1696,1 @@\n-      return png_icc_profile_error(png_ptr, colorspace, name, temp,\n+      return png_icc_profile_error(png_ptr, name, temp,\n@@ -2088,1 +1707,1 @@\n-      (void)png_icc_profile_error(png_ptr, NULL, name, 0\/*no tag value*\/,\n+      (void)png_icc_profile_error(png_ptr, name, 0\/*no tag value*\/,\n@@ -2116,1 +1735,1 @@\n-            return png_icc_profile_error(png_ptr, colorspace, name, temp,\n+            return png_icc_profile_error(png_ptr, name, temp,\n@@ -2122,1 +1741,1 @@\n-            return png_icc_profile_error(png_ptr, colorspace, name, temp,\n+            return png_icc_profile_error(png_ptr, name, temp,\n@@ -2127,1 +1746,1 @@\n-         return png_icc_profile_error(png_ptr, colorspace, name, temp,\n+         return png_icc_profile_error(png_ptr, name, temp,\n@@ -2152,1 +1771,1 @@\n-         return png_icc_profile_error(png_ptr, colorspace, name, temp,\n+         return png_icc_profile_error(png_ptr, name, temp,\n@@ -2162,1 +1781,1 @@\n-         return png_icc_profile_error(png_ptr, colorspace, name, temp,\n+         return png_icc_profile_error(png_ptr, name, temp,\n@@ -2170,1 +1789,1 @@\n-         (void)png_icc_profile_error(png_ptr, NULL, name, temp,\n+         (void)png_icc_profile_error(png_ptr, name, temp,\n@@ -2180,1 +1799,1 @@\n-         (void)png_icc_profile_error(png_ptr, NULL, name, temp,\n+         (void)png_icc_profile_error(png_ptr, name, temp,\n@@ -2196,1 +1815,1 @@\n-         return png_icc_profile_error(png_ptr, colorspace, name, temp,\n+         return png_icc_profile_error(png_ptr, name, temp,\n@@ -2204,3 +1823,3 @@\n-png_icc_check_tag_table(png_const_structrp png_ptr, png_colorspacerp colorspace,\n-    png_const_charp name, png_uint_32 profile_length,\n-    png_const_bytep profile \/* header plus whole tag table *\/)\n+png_icc_check_tag_table(png_const_structrp png_ptr, png_const_charp name,\n+   png_uint_32 profile_length,\n+   png_const_bytep profile \/* header plus whole tag table *\/)\n@@ -2232,1 +1851,1 @@\n-         return png_icc_profile_error(png_ptr, colorspace, name, tag_id,\n+         return png_icc_profile_error(png_ptr, name, tag_id,\n@@ -2241,1 +1860,1 @@\n-         (void)png_icc_profile_error(png_ptr, NULL, name, tag_id,\n+         (void)png_icc_profile_error(png_ptr, name, tag_id,\n@@ -2248,0 +1867,1 @@\n+#endif \/* READ_iCCP *\/\n@@ -2249,64 +1869,2 @@\n-#ifdef PNG_sRGB_SUPPORTED\n-#if PNG_sRGB_PROFILE_CHECKS >= 0\n-\/* Information about the known ICC sRGB profiles *\/\n-static const struct\n-{\n-   png_uint_32 adler, crc, length;\n-   png_uint_32 md5[4];\n-   png_byte    have_md5;\n-   png_byte    is_broken;\n-   png_uint_16 intent;\n-\n-#  define PNG_MD5(a,b,c,d) { a, b, c, d }, (a!=0)||(b!=0)||(c!=0)||(d!=0)\n-#  define PNG_ICC_CHECKSUM(adler, crc, md5, intent, broke, date, length, fname)\\\n-      { adler, crc, length, md5, broke, intent },\n-\n-} png_sRGB_checks[] =\n-{\n-   \/* This data comes from contrib\/tools\/checksum-icc run on downloads of\n-    * all four ICC sRGB profiles from www.color.org.\n-    *\/\n-   \/* adler32, crc32, MD5[4], intent, date, length, file-name *\/\n-   PNG_ICC_CHECKSUM(0x0a3fd9f6, 0x3b8772b9,\n-       PNG_MD5(0x29f83dde, 0xaff255ae, 0x7842fae4, 0xca83390d), 0, 0,\n-       \"2009\/03\/27 21:36:31\", 3048, \"sRGB_IEC61966-2-1_black_scaled.icc\")\n-\n-   \/* ICC sRGB v2 perceptual no black-compensation: *\/\n-   PNG_ICC_CHECKSUM(0x4909e5e1, 0x427ebb21,\n-       PNG_MD5(0xc95bd637, 0xe95d8a3b, 0x0df38f99, 0xc1320389), 1, 0,\n-       \"2009\/03\/27 21:37:45\", 3052, \"sRGB_IEC61966-2-1_no_black_scaling.icc\")\n-\n-   PNG_ICC_CHECKSUM(0xfd2144a1, 0x306fd8ae,\n-       PNG_MD5(0xfc663378, 0x37e2886b, 0xfd72e983, 0x8228f1b8), 0, 0,\n-       \"2009\/08\/10 17:28:01\", 60988, \"sRGB_v4_ICC_preference_displayclass.icc\")\n-\n-   \/* ICC sRGB v4 perceptual *\/\n-   PNG_ICC_CHECKSUM(0x209c35d2, 0xbbef7812,\n-       PNG_MD5(0x34562abf, 0x994ccd06, 0x6d2c5721, 0xd0d68c5d), 0, 0,\n-       \"2007\/07\/25 00:05:37\", 60960, \"sRGB_v4_ICC_preference.icc\")\n-\n-   \/* The following profiles have no known MD5 checksum. If there is a match\n-    * on the (empty) MD5 the other fields are used to attempt a match and\n-    * a warning is produced.  The first two of these profiles have a 'cprt' tag\n-    * which suggests that they were also made by Hewlett Packard.\n-    *\/\n-   PNG_ICC_CHECKSUM(0xa054d762, 0x5d5129ce,\n-       PNG_MD5(0x00000000, 0x00000000, 0x00000000, 0x00000000), 1, 0,\n-       \"2004\/07\/21 18:57:42\", 3024, \"sRGB_IEC61966-2-1_noBPC.icc\")\n-\n-   \/* This is a 'mntr' (display) profile with a mediaWhitePointTag that does not\n-    * match the D50 PCS illuminant in the header (it is in fact the D65 values,\n-    * so the white point is recorded as the un-adapted value.)  The profiles\n-    * below only differ in one byte - the intent - and are basically the same as\n-    * the previous profile except for the mediaWhitePointTag error and a missing\n-    * chromaticAdaptationTag.\n-    *\/\n-   PNG_ICC_CHECKSUM(0xf784f3fb, 0x182ea552,\n-       PNG_MD5(0x00000000, 0x00000000, 0x00000000, 0x00000000), 0, 1\/*broken*\/,\n-       \"1998\/02\/09 06:49:00\", 3144, \"HP-Microsoft sRGB v2 perceptual\")\n-\n-   PNG_ICC_CHECKSUM(0x0398f3fc, 0xf29e526d,\n-       PNG_MD5(0x00000000, 0x00000000, 0x00000000, 0x00000000), 1, 1\/*broken*\/,\n-       \"1998\/02\/09 06:49:00\", 3144, \"HP-Microsoft sRGB v2 media-relative\")\n-};\n-\n+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n+#if (defined PNG_READ_mDCV_SUPPORTED) || (defined PNG_READ_cHRM_SUPPORTED)\n@@ -2314,2 +1872,1 @@\n-png_compare_ICC_profile_with_sRGB(png_const_structrp png_ptr,\n-    png_const_bytep profile, uLong adler)\n+have_chromaticities(png_const_structrp png_ptr)\n@@ -2317,6 +1874,15 @@\n-   \/* The quick check is to verify just the MD5 signature and trust the\n-    * rest of the data.  Because the profile has already been verified for\n-    * correctness this is safe.  png_colorspace_set_sRGB will check the 'intent'\n-    * field too, so if the profile has been edited with an intent not defined\n-    * by sRGB (but maybe defined by a later ICC specification) the read of\n-    * the profile will fail at that point.\n+   \/* Handle new PNGv3 chunks and the precedence rules to determine whether\n+    * png_struct::chromaticities must be processed.  Only required for RGB to\n+    * gray.\n+    *\n+    * mDCV: this is the mastering colour space and it is independent of the\n+    *       encoding so it needs to be used regardless of the encoded space.\n+    *\n+    * cICP: first in priority but not yet implemented - the chromaticities come\n+    *       from the 'primaries'.\n+    *\n+    * iCCP: not supported by libpng (so ignored)\n+    *\n+    * sRGB: the defaults match sRGB\n+    *\n+    * cHRM: calculate the coefficients\n@@ -2324,0 +1890,5 @@\n+#  ifdef PNG_READ_mDCV_SUPPORTED\n+      if (png_has_chunk(png_ptr, mDCV))\n+         return 1;\n+#     define check_chromaticities 1\n+#  endif \/*mDCV*\/\n@@ -2325,87 +1896,4 @@\n-   png_uint_32 length = 0;\n-   png_uint_32 intent = 0x10000; \/* invalid *\/\n-#if PNG_sRGB_PROFILE_CHECKS > 1\n-   uLong crc = 0; \/* the value for 0 length data *\/\n-#endif\n-   unsigned int i;\n-\n-#ifdef PNG_SET_OPTION_SUPPORTED\n-   \/* First see if PNG_SKIP_sRGB_CHECK_PROFILE has been set to \"on\" *\/\n-   if (((png_ptr->options >> PNG_SKIP_sRGB_CHECK_PROFILE) & 3) ==\n-               PNG_OPTION_ON)\n-      return 0;\n-#endif\n-\n-   for (i=0; i < (sizeof png_sRGB_checks) \/ (sizeof png_sRGB_checks[0]); ++i)\n-   {\n-      if (png_get_uint_32(profile+84) == png_sRGB_checks[i].md5[0] &&\n-         png_get_uint_32(profile+88) == png_sRGB_checks[i].md5[1] &&\n-         png_get_uint_32(profile+92) == png_sRGB_checks[i].md5[2] &&\n-         png_get_uint_32(profile+96) == png_sRGB_checks[i].md5[3])\n-      {\n-         \/* This may be one of the old HP profiles without an MD5, in that\n-          * case we can only use the length and Adler32 (note that these\n-          * are not used by default if there is an MD5!)\n-          *\/\n-#        if PNG_sRGB_PROFILE_CHECKS == 0\n-            if (png_sRGB_checks[i].have_md5 != 0)\n-               return 1+png_sRGB_checks[i].is_broken;\n-#        endif\n-\n-         \/* Profile is unsigned or more checks have been configured in. *\/\n-         if (length == 0)\n-         {\n-            length = png_get_uint_32(profile);\n-            intent = png_get_uint_32(profile+64);\n-         }\n-\n-         \/* Length *and* intent must match *\/\n-         if (length == (png_uint_32) png_sRGB_checks[i].length &&\n-            intent == (png_uint_32) png_sRGB_checks[i].intent)\n-         {\n-            \/* Now calculate the adler32 if not done already. *\/\n-            if (adler == 0)\n-            {\n-               adler = adler32(0, NULL, 0);\n-               adler = adler32(adler, profile, length);\n-            }\n-\n-            if (adler == png_sRGB_checks[i].adler)\n-            {\n-               \/* These basic checks suggest that the data has not been\n-                * modified, but if the check level is more than 1 perform\n-                * our own crc32 checksum on the data.\n-                *\/\n-#              if PNG_sRGB_PROFILE_CHECKS > 1\n-                  if (crc == 0)\n-                  {\n-                     crc = crc32(0, NULL, 0);\n-                     crc = crc32(crc, profile, length);\n-                  }\n-\n-                  \/* So this check must pass for the 'return' below to happen.\n-                   *\/\n-                  if (crc == png_sRGB_checks[i].crc)\n-#              endif\n-               {\n-                  if (png_sRGB_checks[i].is_broken != 0)\n-                  {\n-                     \/* These profiles are known to have bad data that may cause\n-                      * problems if they are used, therefore attempt to\n-                      * discourage their use, skip the 'have_md5' warning below,\n-                      * which is made irrelevant by this error.\n-                      *\/\n-                     png_chunk_report(png_ptr, \"known incorrect sRGB profile\",\n-                         PNG_CHUNK_ERROR);\n-                  }\n-\n-                  \/* Warn that this being done; this isn't even an error since\n-                   * the profile is perfectly valid, but it would be nice if\n-                   * people used the up-to-date ones.\n-                   *\/\n-                  else if (png_sRGB_checks[i].have_md5 == 0)\n-                  {\n-                     png_chunk_report(png_ptr,\n-                         \"out-of-date sRGB profile with no signature\",\n-                         PNG_CHUNK_WARNING);\n-                  }\n+#  ifdef PNG_READ_sRGB_SUPPORTED\n+      if (png_has_chunk(png_ptr, sRGB))\n+         return 0;\n+#  endif \/*sRGB*\/\n@@ -2413,17 +1901,5 @@\n-                  return 1+png_sRGB_checks[i].is_broken;\n-               }\n-            }\n-\n-# if PNG_sRGB_PROFILE_CHECKS > 0\n-         \/* The signature matched, but the profile had been changed in some\n-          * way.  This probably indicates a data error or uninformed hacking.\n-          * Fall through to \"no match\".\n-          *\/\n-         png_chunk_report(png_ptr,\n-             \"Not recognizing known sRGB profile that has been edited\",\n-             PNG_CHUNK_WARNING);\n-         break;\n-# endif\n-         }\n-      }\n-   }\n+#  ifdef PNG_READ_cHRM_SUPPORTED\n+      if (png_has_chunk(png_ptr, cHRM))\n+         return 1;\n+#     define check_chromaticities 1\n+#  endif \/*cHRM*\/\n@@ -2431,1 +1907,1 @@\n-   return 0; \/* no match *\/\n+   return 0; \/* sRGB defaults *\/\n@@ -2433,0 +1909,1 @@\n+#endif \/* READ_mDCV || READ_cHRM *\/\n@@ -2435,2 +1912,1 @@\n-png_icc_set_sRGB(png_const_structrp png_ptr,\n-    png_colorspacerp colorspace, png_const_bytep profile, uLong adler)\n+png_set_rgb_coefficients(png_structrp png_ptr)\n@@ -2438,2 +1914,3 @@\n-   \/* Is this profile one of the known ICC sRGB profiles?  If it is, just set\n-    * the sRGB information.\n+   \/* Set the rgb_to_gray coefficients from the colorspace if available.  Note\n+    * that '_set' means that png_rgb_to_gray was called **and** it successfully\n+    * set up the coefficients.\n@@ -2441,20 +1918,1 @@\n-   if (png_compare_ICC_profile_with_sRGB(png_ptr, profile, adler) != 0)\n-      (void)png_colorspace_set_sRGB(png_ptr, colorspace,\n-         (int)\/*already checked*\/png_get_uint_32(profile+64));\n-}\n-#endif \/* PNG_sRGB_PROFILE_CHECKS >= 0 *\/\n-#endif \/* sRGB *\/\n-\n-int \/* PRIVATE *\/\n-png_colorspace_set_ICC(png_const_structrp png_ptr, png_colorspacerp colorspace,\n-    png_const_charp name, png_uint_32 profile_length, png_const_bytep profile,\n-    int color_type)\n-{\n-   if ((colorspace->flags & PNG_COLORSPACE_INVALID) != 0)\n-      return 0;\n-\n-   if (icc_check_length(png_ptr, colorspace, name, profile_length) != 0 &&\n-       png_icc_check_header(png_ptr, colorspace, name, profile_length, profile,\n-           color_type) != 0 &&\n-       png_icc_check_tag_table(png_ptr, colorspace, name, profile_length,\n-           profile) != 0)\n+   if (png_ptr->rgb_to_gray_coefficients_set == 0)\n@@ -2462,6 +1920,2 @@\n-#     if defined(PNG_sRGB_SUPPORTED) && PNG_sRGB_PROFILE_CHECKS >= 0\n-         \/* If no sRGB support, don't try storing sRGB information *\/\n-         png_icc_set_sRGB(png_ptr, colorspace, profile, 0);\n-#     endif\n-      return 1;\n-   }\n+#  if check_chromaticities\n+      png_XYZ xyz;\n@@ -2469,26 +1923,2 @@\n-   \/* Failure case *\/\n-   return 0;\n-}\n-#endif \/* iCCP *\/\n-\n-#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n-void \/* PRIVATE *\/\n-png_colorspace_set_rgb_coefficients(png_structrp png_ptr)\n-{\n-   \/* Set the rgb_to_gray coefficients from the colorspace. *\/\n-   if (png_ptr->rgb_to_gray_coefficients_set == 0 &&\n-      (png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)\n-   {\n-      \/* png_set_background has not been called, get the coefficients from the Y\n-       * values of the colorspace colorants.\n-       *\/\n-      png_fixed_point r = png_ptr->colorspace.end_points_XYZ.red_Y;\n-      png_fixed_point g = png_ptr->colorspace.end_points_XYZ.green_Y;\n-      png_fixed_point b = png_ptr->colorspace.end_points_XYZ.blue_Y;\n-      png_fixed_point total = r+g+b;\n-\n-      if (total > 0 &&\n-         r >= 0 && png_muldiv(&r, r, 32768, total) && r >= 0 && r <= 32768 &&\n-         g >= 0 && png_muldiv(&g, g, 32768, total) && g >= 0 && g <= 32768 &&\n-         b >= 0 && png_muldiv(&b, b, 32768, total) && b >= 0 && b <= 32768 &&\n-         r+g+b <= 32769)\n+      if (have_chromaticities(png_ptr) &&\n+          png_XYZ_from_xy(&xyz, &png_ptr->chromaticities) == 0)\n@@ -2496,4 +1926,2 @@\n-         \/* We allow 0 coefficients here.  r+g+b may be 32769 if two or\n-          * all of the coefficients were rounded up.  Handle this by\n-          * reducing the *largest* coefficient by 1; this matches the\n-          * approach used for the default coefficients in pngrtran.c\n+         \/* png_set_rgb_to_gray has not set the coefficients, get them from the\n+          * Y * values of the colorspace colorants.\n@@ -2501,1 +1929,17 @@\n-         int add = 0;\n+         png_fixed_point r = xyz.red_Y;\n+         png_fixed_point g = xyz.green_Y;\n+         png_fixed_point b = xyz.blue_Y;\n+         png_fixed_point total = r+g+b;\n+\n+         if (total > 0 &&\n+            r >= 0 && png_muldiv(&r, r, 32768, total) && r >= 0 && r <= 32768 &&\n+            g >= 0 && png_muldiv(&g, g, 32768, total) && g >= 0 && g <= 32768 &&\n+            b >= 0 && png_muldiv(&b, b, 32768, total) && b >= 0 && b <= 32768 &&\n+            r+g+b <= 32769)\n+         {\n+            \/* We allow 0 coefficients here.  r+g+b may be 32769 if two or\n+             * all of the coefficients were rounded up.  Handle this by\n+             * reducing the *largest* coefficient by 1; this matches the\n+             * approach used for the default coefficients in pngrtran.c\n+             *\/\n+            int add = 0;\n@@ -2503,4 +1947,4 @@\n-         if (r+g+b > 32768)\n-            add = -1;\n-         else if (r+g+b < 32768)\n-            add = 1;\n+            if (r+g+b > 32768)\n+               add = -1;\n+            else if (r+g+b < 32768)\n+               add = 1;\n@@ -2508,9 +1952,9 @@\n-         if (add != 0)\n-         {\n-            if (g >= r && g >= b)\n-               g += add;\n-            else if (r >= g && r >= b)\n-               r += add;\n-            else\n-               b += add;\n-         }\n+            if (add != 0)\n+            {\n+               if (g >= r && g >= b)\n+                  g += add;\n+               else if (r >= g && r >= b)\n+                  r += add;\n+               else\n+                  b += add;\n+            }\n@@ -2518,4 +1962,4 @@\n-         \/* Check for an internal error. *\/\n-         if (r+g+b != 32768)\n-            png_error(png_ptr,\n-                \"internal error handling cHRM coefficients\");\n+            \/* Check for an internal error. *\/\n+            if (r+g+b != 32768)\n+               png_error(png_ptr,\n+                   \"internal error handling cHRM coefficients\");\n@@ -2523,4 +1967,5 @@\n-         else\n-         {\n-            png_ptr->rgb_to_gray_red_coeff   = (png_uint_16)r;\n-            png_ptr->rgb_to_gray_green_coeff = (png_uint_16)g;\n+            else\n+            {\n+               png_ptr->rgb_to_gray_red_coeff   = (png_uint_16)r;\n+               png_ptr->rgb_to_gray_green_coeff = (png_uint_16)g;\n+            }\n@@ -2529,5 +1974,0 @@\n-\n-      \/* This is a png_error at present even though it could be ignored -\n-       * it should never happen, but it is important that if it does, the\n-       * bug is fixed.\n-       *\/\n@@ -2535,1 +1975,7 @@\n-         png_error(png_ptr, \"internal error handling cHRM->XYZ\");\n+#  endif \/* check_chromaticities *\/\n+      {\n+         \/* Use the historical REC 709 (etc) values: *\/\n+         png_ptr->rgb_to_gray_red_coeff   = 6968;\n+         png_ptr->rgb_to_gray_green_coeff = 23434;\n+         \/* png_ptr->rgb_to_gray_blue_coeff  = 2366; *\/\n+      }\n@@ -2540,2 +1986,0 @@\n-#endif \/* COLORSPACE *\/\n-\n@@ -3323,1 +2767,21 @@\n-#if defined(PNG_GAMMA_SUPPORTED) || defined(PNG_COLORSPACE_SUPPORTED) ||\\\n+#if defined(PNG_FLOATING_POINT_SUPPORTED) && \\\n+   !defined(PNG_FIXED_POINT_MACRO_SUPPORTED) && \\\n+   (defined(PNG_cLLI_SUPPORTED) || defined(PNG_mDCV_SUPPORTED))\n+png_uint_32\n+png_fixed_ITU(png_const_structrp png_ptr, double fp, png_const_charp text)\n+{\n+   double r = floor(10000 * fp + .5);\n+\n+   if (r > 2147483647. || r < 0)\n+      png_fixed_error(png_ptr, text);\n+\n+#  ifndef PNG_ERROR_TEXT_SUPPORTED\n+   PNG_UNUSED(text)\n+#  endif\n+\n+   return (png_uint_32)r;\n+}\n+#endif\n+\n+\n+#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_COLORSPACE_SUPPORTED) ||\\\n@@ -3331,1 +2795,1 @@\n-int\n+int \/* PRIVATE *\/\n@@ -3445,19 +2909,0 @@\n-#endif \/* READ_GAMMA || INCH_CONVERSIONS *\/\n-\n-#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_INCH_CONVERSIONS_SUPPORTED)\n-\/* The following is for when the caller doesn't much care about the\n- * result.\n- *\/\n-png_fixed_point\n-png_muldiv_warn(png_const_structrp png_ptr, png_fixed_point a, png_int_32 times,\n-    png_int_32 divisor)\n-{\n-   png_fixed_point result;\n-\n-   if (png_muldiv(&result, a, times, divisor) != 0)\n-      return result;\n-\n-   png_warning(png_ptr, \"fixed point overflow ignored\");\n-   return 0;\n-}\n-#endif\n@@ -3465,1 +2910,0 @@\n-#ifdef PNG_GAMMA_SUPPORTED \/* more fixed point functions for gamma *\/\n@@ -3484,0 +2928,1 @@\n+#endif \/* READ_GAMMA || COLORSPACE || INCH_CONVERSIONS || READ_pHYS *\/\n@@ -3485,0 +2930,1 @@\n+#ifdef PNG_READ_GAMMA_SUPPORTED\n@@ -3491,0 +2937,12 @@\n+   \/* sRGB:       1\/2.2 == 0.4545(45)\n+    * AdobeRGB:   1\/(2+51\/256) ~= 0.45471 5dp\n+    *\n+    * So the correction from AdobeRGB to sRGB (output) is:\n+    *\n+    *    2.2\/(2+51\/256) == 1.00035524\n+    *\n+    * I.e. vanishly small (<4E-4) but still detectable in 16-bit linear (+\/-\n+    * 23).  Note that the Adobe choice seems to be something intended to give an\n+    * exact number with 8 binary fractional digits - it is the closest to 2.2\n+    * that is possible a base 2 .8p representation.\n+    *\/\n@@ -3494,1 +2952,0 @@\n-#endif\n@@ -3496,2 +2953,1 @@\n-#ifdef PNG_READ_GAMMA_SUPPORTED\n-#ifdef PNG_16BIT_SUPPORTED\n+#ifndef PNG_FLOATING_ARITHMETIC_SUPPORTED\n@@ -3502,2 +2958,2 @@\n-   \/* The required result is 1\/a * 1\/b; the following preserves accuracy. *\/\n-#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED\n+   \/* The required result is a * b; the following preserves accuracy. *\/\n+#ifdef PNG_FLOATING_ARITHMETIC_SUPPORTED \/* Should now be unused *\/\n@@ -3519,1 +2975,1 @@\n-#endif \/* 16BIT *\/\n+#endif \/* FLOATING_ARITHMETIC *\/\n@@ -3521,1 +2977,0 @@\n-\/* The inverse of the above. *\/\n@@ -4174,0 +3629,3 @@\n+ *\n+ * TODO: move this to pngrtran.c and make it static.  Better yet create\n+ * pngcolor.c and put all the PNG_COLORSPACE stuff in there.\n@@ -4175,0 +3633,8 @@\n+#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \\\n+   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \\\n+   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)\n+#  define GAMMA_TRANSFORMS 1 \/* #ifdef CSE *\/\n+#else\n+#  define GAMMA_TRANSFORMS 0\n+#endif\n+\n@@ -4178,0 +3644,6 @@\n+   png_fixed_point file_gamma, screen_gamma;\n+   png_fixed_point correction;\n+#  if GAMMA_TRANSFORMS\n+      png_fixed_point file_to_linear, linear_to_screen;\n+#  endif\n+\n@@ -4192,0 +3664,25 @@\n+   \/* The following fields are set, finally, in png_init_read_transformations.\n+    * If file_gamma is 0 (unset) nothing can be done otherwise if screen_gamma\n+    * is 0 (unset) there is no gamma correction but to\/from linear is possible.\n+    *\/\n+   file_gamma = png_ptr->file_gamma;\n+   screen_gamma = png_ptr->screen_gamma;\n+#  if GAMMA_TRANSFORMS\n+      file_to_linear = png_reciprocal(file_gamma);\n+#  endif\n+\n+   if (screen_gamma > 0)\n+   {\n+#     if GAMMA_TRANSFORMS\n+         linear_to_screen = png_reciprocal(screen_gamma);\n+#     endif\n+      correction = png_reciprocal2(screen_gamma, file_gamma);\n+   }\n+   else \/* screen gamma unknown *\/\n+   {\n+#     if GAMMA_TRANSFORMS\n+         linear_to_screen = file_gamma;\n+#     endif\n+      correction = PNG_FP_1;\n+   }\n+\n@@ -4194,4 +3691,1 @@\n-      png_build_8bit_table(png_ptr, &png_ptr->gamma_table,\n-          png_ptr->screen_gamma > 0 ?\n-          png_reciprocal2(png_ptr->colorspace.gamma,\n-          png_ptr->screen_gamma) : PNG_FP_1);\n+      png_build_8bit_table(png_ptr, &png_ptr->gamma_table, correction);\n@@ -4199,3 +3693,1 @@\n-#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \\\n-   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \\\n-   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)\n+#if GAMMA_TRANSFORMS\n@@ -4204,2 +3696,1 @@\n-         png_build_8bit_table(png_ptr, &png_ptr->gamma_to_1,\n-             png_reciprocal(png_ptr->colorspace.gamma));\n+         png_build_8bit_table(png_ptr, &png_ptr->gamma_to_1, file_to_linear);\n@@ -4208,3 +3699,1 @@\n-             png_ptr->screen_gamma > 0 ?\n-             png_reciprocal(png_ptr->screen_gamma) :\n-             png_ptr->colorspace.gamma\/* Probably doing rgb_to_gray *\/);\n+            linear_to_screen);\n@@ -4212,1 +3701,1 @@\n-#endif \/* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY *\/\n+#endif \/* GAMMA_TRANSFORMS *\/\n@@ -4278,4 +3767,2 @@\n-          png_build_16to8_table(png_ptr, &png_ptr->gamma_16_table, shift,\n-          png_ptr->screen_gamma > 0 ? png_product2(png_ptr->colorspace.gamma,\n-          png_ptr->screen_gamma) : PNG_FP_1);\n-\n+         png_build_16to8_table(png_ptr, &png_ptr->gamma_16_table, shift,\n+            png_reciprocal(correction));\n@@ -4283,3 +3770,2 @@\n-          png_build_16bit_table(png_ptr, &png_ptr->gamma_16_table, shift,\n-          png_ptr->screen_gamma > 0 ? png_reciprocal2(png_ptr->colorspace.gamma,\n-          png_ptr->screen_gamma) : PNG_FP_1);\n+         png_build_16bit_table(png_ptr, &png_ptr->gamma_16_table, shift,\n+            correction);\n@@ -4287,3 +3773,1 @@\n-#if defined(PNG_READ_BACKGROUND_SUPPORTED) || \\\n-   defined(PNG_READ_ALPHA_MODE_SUPPORTED) || \\\n-   defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)\n+#  if GAMMA_TRANSFORMS\n@@ -4293,1 +3777,1 @@\n-             png_reciprocal(png_ptr->colorspace.gamma));\n+            file_to_linear);\n@@ -4300,2 +3784,1 @@\n-             png_ptr->screen_gamma > 0 ? png_reciprocal(png_ptr->screen_gamma) :\n-             png_ptr->colorspace.gamma\/* Probably doing rgb_to_gray *\/);\n+            linear_to_screen);\n@@ -4303,1 +3786,1 @@\n-#endif \/* READ_BACKGROUND || READ_ALPHA_MODE || RGB_TO_GRAY *\/\n+#endif \/* GAMMA_TRANSFORMS *\/\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/png.c","additions":442,"deletions":959,"binary":false,"changes":1401,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * libpng version 1.6.43\n+ * libpng version 1.6.47\n@@ -34,1 +34,1 @@\n- * Copyright (c) 2018-2024 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -46,1 +46,1 @@\n- *   libpng versions 1.6.36, December 2018, through 1.6.43, February 2024:\n+ *   libpng versions 1.6.36, December 2018, through 1.6.47, February 2025:\n@@ -58,2 +58,2 @@\n- *  * Copyright (c) 1995-2024 The PNG Reference Library Authors.\n- *  * Copyright (c) 2018-2024 Cosmin Truta.\n+ *  * Copyright (c) 1995-2025 The PNG Reference Library Authors.\n+ *  * Copyright (c) 2018-2025 Cosmin Truta.\n@@ -270,1 +270,1 @@\n- *    1.6.43                  16    10643  16.so.16.43[.0]\n+ *    1.6.47                  16    10647  16.so.16.47[.0]\n@@ -306,1 +306,1 @@\n-#define PNG_LIBPNG_VER_STRING \"1.6.43\"\n+#define PNG_LIBPNG_VER_STRING \"1.6.47\"\n@@ -317,1 +317,1 @@\n-#define PNG_LIBPNG_VER_RELEASE 43\n+#define PNG_LIBPNG_VER_RELEASE 47\n@@ -322,1 +322,1 @@\n-#define PNG_LIBPNG_VER_BUILD  0\n+#define PNG_LIBPNG_VER_BUILD 0\n@@ -325,4 +325,4 @@\n-#define PNG_LIBPNG_BUILD_ALPHA    1\n-#define PNG_LIBPNG_BUILD_BETA     2\n-#define PNG_LIBPNG_BUILD_RC       3\n-#define PNG_LIBPNG_BUILD_STABLE   4\n+#define PNG_LIBPNG_BUILD_ALPHA               1\n+#define PNG_LIBPNG_BUILD_BETA                2\n+#define PNG_LIBPNG_BUILD_RC                  3\n+#define PNG_LIBPNG_BUILD_STABLE              4\n@@ -348,1 +348,1 @@\n-#define PNG_LIBPNG_VER 10643 \/* 1.6.43 *\/\n+#define PNG_LIBPNG_VER 10647 \/* 1.6.47 *\/\n@@ -458,1 +458,1 @@\n-typedef char* png_libpng_version_1_6_43;\n+typedef char* png_libpng_version_1_6_47;\n@@ -776,0 +776,15 @@\n+#define PNG_INFO_cICP 0x20000U \/* PNGv3: 1.6.45 *\/\n+#define PNG_INFO_cLLI 0x40000U \/* PNGv3: 1.6.45 *\/\n+#define PNG_INFO_mDCV 0x80000U \/* PNGv3: 1.6.45 *\/\n+\/* APNG: these chunks are stored as unknown, these flags are never set\n+ * however they are provided as a convenience for implementors of APNG and\n+ * avoids any merge conflicts.\n+ *\n+ * Private chunks: these chunk names violate the chunk name recommendations\n+ * because the chunk definitions have no signature and because the private\n+ * chunks with these names have been reserved.  Private definitions should\n+ * avoid them.\n+ *\/\n+#define PNG_INFO_acTL 0x100000U \/* PNGv3: 1.6.45: unknown *\/\n+#define PNG_INFO_fcTL 0x200000U \/* PNGv3: 1.6.45: unknown *\/\n+#define PNG_INFO_fdAT 0x400000U \/* PNGv3: 1.6.45: unknown *\/\n@@ -855,1 +870,1 @@\n-PNG_FUNCTION(void, (PNGCAPI *png_longjmp_ptr), PNGARG((jmp_buf, int)), typedef);\n+PNG_FUNCTION(void, (PNGCAPI *png_longjmp_ptr), (jmp_buf, int), typedef);\n@@ -2005,0 +2020,40 @@\n+#ifdef PNG_cICP_SUPPORTED\n+PNG_EXPORT(250, png_uint_32, png_get_cICP, (png_const_structrp png_ptr,\n+    png_const_inforp info_ptr, png_bytep colour_primaries,\n+    png_bytep transfer_function, png_bytep matrix_coefficients,\n+    png_bytep video_full_range_flag));\n+#endif\n+\n+#ifdef PNG_cICP_SUPPORTED\n+PNG_EXPORT(251, void, png_set_cICP, (png_const_structrp png_ptr,\n+    png_inforp info_ptr, png_byte colour_primaries,\n+    png_byte transfer_function, png_byte matrix_coefficients,\n+    png_byte video_full_range_flag));\n+#endif\n+\n+#ifdef PNG_cLLI_SUPPORTED\n+PNG_FP_EXPORT(252, png_uint_32, png_get_cLLI, (png_const_structrp png_ptr,\n+         png_const_inforp info_ptr, double *maximum_content_light_level,\n+         double *maximum_frame_average_light_level))\n+PNG_FIXED_EXPORT(253, png_uint_32, png_get_cLLI_fixed,\n+    (png_const_structrp png_ptr, png_const_inforp info_ptr,\n+    \/* The values below are in cd\/m2 (nits) and are scaled by 10,000; not\n+     * 100,000 as in the case of png_fixed_point.\n+     *\/\n+    png_uint_32p maximum_content_light_level_scaled_by_10000,\n+    png_uint_32p maximum_frame_average_light_level_scaled_by_10000))\n+#endif\n+\n+#ifdef PNG_cLLI_SUPPORTED\n+PNG_FP_EXPORT(254, void, png_set_cLLI, (png_const_structrp png_ptr,\n+         png_inforp info_ptr, double maximum_content_light_level,\n+         double maximum_frame_average_light_level))\n+PNG_FIXED_EXPORT(255, void, png_set_cLLI_fixed, (png_const_structrp png_ptr,\n+    png_inforp info_ptr,\n+    \/* The values below are in cd\/m2 (nits) and are scaled by 10,000; not\n+     * 100,000 as in the case of png_fixed_point.\n+     *\/\n+    png_uint_32 maximum_content_light_level_scaled_by_10000,\n+    png_uint_32 maximum_frame_average_light_level_scaled_by_10000))\n+#endif\n+\n@@ -2049,0 +2104,54 @@\n+#ifdef PNG_mDCV_SUPPORTED\n+PNG_FP_EXPORT(256, png_uint_32, png_get_mDCV, (png_const_structrp png_ptr,\n+    png_const_inforp info_ptr,\n+    \/* The chromaticities of the mastering display.  As cHRM, but independent of\n+     * the encoding endpoints in cHRM, or cICP, or iCCP.  These values will\n+     * always be in the range 0 to 1.3107.\n+     *\/\n+    double *white_x, double *white_y, double *red_x, double *red_y,\n+    double *green_x, double *green_y, double *blue_x, double *blue_y,\n+    \/* Mastering display luminance in cd\/m2 (nits). *\/\n+    double *mastering_display_maximum_luminance,\n+    double *mastering_display_minimum_luminance))\n+\n+PNG_FIXED_EXPORT(257, png_uint_32, png_get_mDCV_fixed,\n+    (png_const_structrp png_ptr, png_const_inforp info_ptr,\n+    png_fixed_point *int_white_x, png_fixed_point *int_white_y,\n+    png_fixed_point *int_red_x, png_fixed_point *int_red_y,\n+    png_fixed_point *int_green_x, png_fixed_point *int_green_y,\n+    png_fixed_point *int_blue_x, png_fixed_point *int_blue_y,\n+    \/* Mastering display luminance in cd\/m2 (nits) multiplied (scaled) by\n+     * 10,000.\n+     *\/\n+    png_uint_32p mastering_display_maximum_luminance_scaled_by_10000,\n+    png_uint_32p mastering_display_minimum_luminance_scaled_by_10000))\n+#endif\n+\n+#ifdef PNG_mDCV_SUPPORTED\n+PNG_FP_EXPORT(258, void, png_set_mDCV, (png_const_structrp png_ptr,\n+    png_inforp info_ptr,\n+    \/* The chromaticities of the mastering display.  As cHRM, but independent of\n+     * the encoding endpoints in cHRM, or cICP, or iCCP.\n+     *\/\n+    double white_x, double white_y, double red_x, double red_y, double green_x,\n+    double green_y, double blue_x, double blue_y,\n+    \/* Mastering display luminance in cd\/m2 (nits). *\/\n+    double mastering_display_maximum_luminance,\n+    double mastering_display_minimum_luminance))\n+\n+PNG_FIXED_EXPORT(259, void, png_set_mDCV_fixed, (png_const_structrp png_ptr,\n+    png_inforp info_ptr,\n+    \/* The admissible range of these values is not the full range of a PNG\n+     * fixed point value.  Negative values cannot be encoded and the maximum\n+     * value is about 1.3 *\/\n+    png_fixed_point int_white_x, png_fixed_point int_white_y,\n+    png_fixed_point int_red_x, png_fixed_point int_red_y,\n+    png_fixed_point int_green_x, png_fixed_point int_green_y,\n+    png_fixed_point int_blue_x, png_fixed_point int_blue_y,\n+    \/* These are PNG unsigned 4 byte values: 31-bit unsigned values.  The MSB\n+     * must be zero.\n+     *\/\n+    png_uint_32 mastering_display_maximum_luminance_scaled_by_10000,\n+    png_uint_32 mastering_display_minimum_luminance_scaled_by_10000))\n+#endif\n+\n@@ -3269,1 +3378,1 @@\n-  PNG_EXPORT_LAST_ORDINAL(249);\n+  PNG_EXPORT_LAST_ORDINAL(259);\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/png.h","additions":126,"deletions":17,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * libpng version 1.6.43\n+ * libpng version 1.6.47\n@@ -34,1 +34,1 @@\n- * Copyright (c) 2018-2024 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -119,1 +119,1 @@\n- * prototypes.  It is not required for modern C compilers.\n+ * prototypes.  [Deprecated.]\n@@ -329,1 +329,1 @@\n-      PNG_FUNCTION(PNG_EXPORT_TYPE(type), (PNGAPI name), PNGARG(args), \\\n+      PNG_FUNCTION(PNG_EXPORT_TYPE(type), (PNGAPI name), args, \\\n@@ -347,1 +347,1 @@\n-#  define PNG_CALLBACK(type, name, args) type (PNGCBAPI name) PNGARG(args)\n+#  define PNG_CALLBACK(type, name, args) type (PNGCBAPI name) args\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngconf.h","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -51,2 +51,3 @@\n-static PNG_FUNCTION(void, png_default_error,PNGARG((png_const_structrp png_ptr,\n-    png_const_charp error_message)),PNG_NORETURN);\n+static PNG_FUNCTION(void \/* PRIVATE *\/,\n+png_default_error,(png_const_structrp png_ptr, png_const_charp error_message),\n+    PNG_NORETURN);\n@@ -56,2 +57,2 @@\n-png_default_warning PNGARG((png_const_structrp png_ptr,\n-    png_const_charp warning_message));\n+png_default_warning(png_const_structrp png_ptr,\n+    png_const_charp warning_message);\n@@ -966,1 +967,1 @@\n-   png_voidp saved_error_buf = image->opaque->error_buf;\n+   const png_voidp saved_error_buf = image->opaque->error_buf;\n@@ -968,1 +969,0 @@\n-   int result;\n@@ -973,0 +973,2 @@\n+      int result;\n+\n@@ -976,1 +978,3 @@\n-      return result;\n+\n+      if (result)\n+         return 1; \/* success *\/\n@@ -979,1 +983,5 @@\n-   \/* On png_error, return via longjmp, pop the jmpbuf, and free the image. *\/\n+   \/* The function failed either because of a caught png_error and a regular\n+    * return of false above or because of an uncaught png_error from the\n+    * function itself.  Ensure that the error_buf is always set back to the\n+    * value saved above:\n+    *\/\n@@ -981,2 +989,9 @@\n-   png_image_free(image);\n-   return 0;\n+\n+   \/* On the final false return, when about to return control to the caller, the\n+    * image is freed (png_image_free does this check but it is duplicated here\n+    * for clarity:\n+    *\/\n+   if (saved_error_buf == NULL)\n+      png_image_free(image);\n+\n+   return 0; \/* failure *\/\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngerror.c","additions":25,"deletions":10,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -412,1 +412,7 @@\n-   return png_muldiv_warn(png_ptr, microns, 500, 127);\n+   png_fixed_point result;\n+\n+   if (png_muldiv(&result, microns, 500, 127) != 0)\n+      return result;\n+\n+   png_warning(png_ptr, \"fixed point overflow ignored\");\n+   return 0;\n@@ -422,1 +428,1 @@\n-#endif\n+#endif \/* FIXED_POINT *\/\n@@ -550,2 +556,2 @@\n-    double *white_x, double *white_y, double *red_x, double *red_y,\n-    double *green_x, double *green_y, double *blue_x, double *blue_y)\n+    double *whitex, double *whitey, double *redx, double *redy,\n+    double *greenx, double *greeny, double *bluex, double *bluey)\n@@ -555,6 +561,1 @@\n-   \/* Quiet API change: this code used to only return the end points if a cHRM\n-    * chunk was present, but the end points can also come from iCCP or sRGB\n-    * chunks, so in 1.6.0 the png_get_ APIs return the end points regardless and\n-    * the png_set_ APIs merely check that set end points are mutually\n-    * consistent.\n-    *\/\n+   \/* PNGv3: this just returns the values store from the cHRM, if any. *\/\n@@ -562,1 +563,1 @@\n-      (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)\n+       (info_ptr->valid & PNG_INFO_cHRM) != 0)\n@@ -564,24 +565,16 @@\n-      if (white_x != NULL)\n-         *white_x = png_float(png_ptr,\n-             info_ptr->colorspace.end_points_xy.whitex, \"cHRM white X\");\n-      if (white_y != NULL)\n-         *white_y = png_float(png_ptr,\n-             info_ptr->colorspace.end_points_xy.whitey, \"cHRM white Y\");\n-      if (red_x != NULL)\n-         *red_x = png_float(png_ptr, info_ptr->colorspace.end_points_xy.redx,\n-             \"cHRM red X\");\n-      if (red_y != NULL)\n-         *red_y = png_float(png_ptr, info_ptr->colorspace.end_points_xy.redy,\n-             \"cHRM red Y\");\n-      if (green_x != NULL)\n-         *green_x = png_float(png_ptr,\n-             info_ptr->colorspace.end_points_xy.greenx, \"cHRM green X\");\n-      if (green_y != NULL)\n-         *green_y = png_float(png_ptr,\n-             info_ptr->colorspace.end_points_xy.greeny, \"cHRM green Y\");\n-      if (blue_x != NULL)\n-         *blue_x = png_float(png_ptr, info_ptr->colorspace.end_points_xy.bluex,\n-             \"cHRM blue X\");\n-      if (blue_y != NULL)\n-         *blue_y = png_float(png_ptr, info_ptr->colorspace.end_points_xy.bluey,\n-             \"cHRM blue Y\");\n+      if (whitex != NULL)\n+         *whitex = png_float(png_ptr, info_ptr->cHRM.whitex, \"cHRM wx\");\n+      if (whitey != NULL)\n+         *whitey = png_float(png_ptr, info_ptr->cHRM.whitey, \"cHRM wy\");\n+      if (redx   != NULL)\n+         *redx   = png_float(png_ptr, info_ptr->cHRM.redx,   \"cHRM rx\");\n+      if (redy   != NULL)\n+         *redy   = png_float(png_ptr, info_ptr->cHRM.redy,   \"cHRM ry\");\n+      if (greenx != NULL)\n+         *greenx = png_float(png_ptr, info_ptr->cHRM.greenx, \"cHRM gx\");\n+      if (greeny != NULL)\n+         *greeny = png_float(png_ptr, info_ptr->cHRM.greeny, \"cHRM gy\");\n+      if (bluex  != NULL)\n+         *bluex  = png_float(png_ptr, info_ptr->cHRM.bluex,  \"cHRM bx\");\n+      if (bluey  != NULL)\n+         *bluey  = png_float(png_ptr, info_ptr->cHRM.bluey,  \"cHRM by\");\n@@ -600,0 +593,1 @@\n+   png_XYZ XYZ;\n@@ -603,1 +597,2 @@\n-       (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)\n+       (info_ptr->valid & PNG_INFO_cHRM) != 0 &&\n+       png_XYZ_from_xy(&XYZ, &info_ptr->cHRM) == 0)\n@@ -606,2 +601,1 @@\n-         *red_X = png_float(png_ptr, info_ptr->colorspace.end_points_XYZ.red_X,\n-             \"cHRM red X\");\n+         *red_X = png_float(png_ptr, XYZ.red_X, \"cHRM red X\");\n@@ -609,2 +603,1 @@\n-         *red_Y = png_float(png_ptr, info_ptr->colorspace.end_points_XYZ.red_Y,\n-             \"cHRM red Y\");\n+         *red_Y = png_float(png_ptr, XYZ.red_Y, \"cHRM red Y\");\n@@ -612,2 +605,1 @@\n-         *red_Z = png_float(png_ptr, info_ptr->colorspace.end_points_XYZ.red_Z,\n-             \"cHRM red Z\");\n+         *red_Z = png_float(png_ptr, XYZ.red_Z, \"cHRM red Z\");\n@@ -615,2 +607,1 @@\n-         *green_X = png_float(png_ptr,\n-             info_ptr->colorspace.end_points_XYZ.green_X, \"cHRM green X\");\n+         *green_X = png_float(png_ptr, XYZ.green_X, \"cHRM green X\");\n@@ -618,2 +609,1 @@\n-         *green_Y = png_float(png_ptr,\n-             info_ptr->colorspace.end_points_XYZ.green_Y, \"cHRM green Y\");\n+         *green_Y = png_float(png_ptr, XYZ.green_Y, \"cHRM green Y\");\n@@ -621,2 +611,1 @@\n-         *green_Z = png_float(png_ptr,\n-             info_ptr->colorspace.end_points_XYZ.green_Z, \"cHRM green Z\");\n+         *green_Z = png_float(png_ptr, XYZ.green_Z, \"cHRM green Z\");\n@@ -624,2 +613,1 @@\n-         *blue_X = png_float(png_ptr,\n-             info_ptr->colorspace.end_points_XYZ.blue_X, \"cHRM blue X\");\n+         *blue_X = png_float(png_ptr, XYZ.blue_X, \"cHRM blue X\");\n@@ -627,2 +615,1 @@\n-         *blue_Y = png_float(png_ptr,\n-             info_ptr->colorspace.end_points_XYZ.blue_Y, \"cHRM blue Y\");\n+         *blue_Y = png_float(png_ptr, XYZ.blue_Y, \"cHRM blue Y\");\n@@ -630,2 +617,1 @@\n-         *blue_Z = png_float(png_ptr,\n-             info_ptr->colorspace.end_points_XYZ.blue_Z, \"cHRM blue Z\");\n+         *blue_Z = png_float(png_ptr, XYZ.blue_Z, \"cHRM blue Z\");\n@@ -648,0 +634,1 @@\n+   png_XYZ XYZ;\n@@ -651,1 +638,2 @@\n-      (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)\n+       (info_ptr->valid & PNG_INFO_cHRM) != 0U &&\n+       png_XYZ_from_xy(&XYZ, &info_ptr->cHRM) == 0)\n@@ -653,18 +641,9 @@\n-      if (int_red_X != NULL)\n-         *int_red_X = info_ptr->colorspace.end_points_XYZ.red_X;\n-      if (int_red_Y != NULL)\n-         *int_red_Y = info_ptr->colorspace.end_points_XYZ.red_Y;\n-      if (int_red_Z != NULL)\n-         *int_red_Z = info_ptr->colorspace.end_points_XYZ.red_Z;\n-      if (int_green_X != NULL)\n-         *int_green_X = info_ptr->colorspace.end_points_XYZ.green_X;\n-      if (int_green_Y != NULL)\n-         *int_green_Y = info_ptr->colorspace.end_points_XYZ.green_Y;\n-      if (int_green_Z != NULL)\n-         *int_green_Z = info_ptr->colorspace.end_points_XYZ.green_Z;\n-      if (int_blue_X != NULL)\n-         *int_blue_X = info_ptr->colorspace.end_points_XYZ.blue_X;\n-      if (int_blue_Y != NULL)\n-         *int_blue_Y = info_ptr->colorspace.end_points_XYZ.blue_Y;\n-      if (int_blue_Z != NULL)\n-         *int_blue_Z = info_ptr->colorspace.end_points_XYZ.blue_Z;\n+      if (int_red_X != NULL) *int_red_X = XYZ.red_X;\n+      if (int_red_Y != NULL) *int_red_Y = XYZ.red_Y;\n+      if (int_red_Z != NULL) *int_red_Z = XYZ.red_Z;\n+      if (int_green_X != NULL) *int_green_X = XYZ.green_X;\n+      if (int_green_Y != NULL) *int_green_Y = XYZ.green_Y;\n+      if (int_green_Z != NULL) *int_green_Z = XYZ.green_Z;\n+      if (int_blue_X != NULL) *int_blue_X = XYZ.blue_X;\n+      if (int_blue_Y != NULL) *int_blue_Y = XYZ.blue_Y;\n+      if (int_blue_Z != NULL) *int_blue_Z = XYZ.blue_Z;\n@@ -679,3 +658,3 @@\n-    png_fixed_point *white_x, png_fixed_point *white_y, png_fixed_point *red_x,\n-    png_fixed_point *red_y, png_fixed_point *green_x, png_fixed_point *green_y,\n-    png_fixed_point *blue_x, png_fixed_point *blue_y)\n+    png_fixed_point *whitex, png_fixed_point *whitey, png_fixed_point *redx,\n+    png_fixed_point *redy, png_fixed_point *greenx, png_fixed_point *greeny,\n+    png_fixed_point *bluex, png_fixed_point *bluey)\n@@ -685,0 +664,1 @@\n+   \/* PNGv3: this just returns the values store from the cHRM, if any. *\/\n@@ -686,1 +666,1 @@\n-      (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_ENDPOINTS) != 0)\n+       (info_ptr->valid & PNG_INFO_cHRM) != 0)\n@@ -688,16 +668,8 @@\n-      if (white_x != NULL)\n-         *white_x = info_ptr->colorspace.end_points_xy.whitex;\n-      if (white_y != NULL)\n-         *white_y = info_ptr->colorspace.end_points_xy.whitey;\n-      if (red_x != NULL)\n-         *red_x = info_ptr->colorspace.end_points_xy.redx;\n-      if (red_y != NULL)\n-         *red_y = info_ptr->colorspace.end_points_xy.redy;\n-      if (green_x != NULL)\n-         *green_x = info_ptr->colorspace.end_points_xy.greenx;\n-      if (green_y != NULL)\n-         *green_y = info_ptr->colorspace.end_points_xy.greeny;\n-      if (blue_x != NULL)\n-         *blue_x = info_ptr->colorspace.end_points_xy.bluex;\n-      if (blue_y != NULL)\n-         *blue_y = info_ptr->colorspace.end_points_xy.bluey;\n+      if (whitex != NULL) *whitex = info_ptr->cHRM.whitex;\n+      if (whitey != NULL) *whitey = info_ptr->cHRM.whitey;\n+      if (redx   != NULL) *redx   = info_ptr->cHRM.redx;\n+      if (redy   != NULL) *redy   = info_ptr->cHRM.redy;\n+      if (greenx != NULL) *greenx = info_ptr->cHRM.greenx;\n+      if (greeny != NULL) *greeny = info_ptr->cHRM.greeny;\n+      if (bluex  != NULL) *bluex  = info_ptr->cHRM.bluex;\n+      if (bluey  != NULL) *bluey  = info_ptr->cHRM.bluey;\n@@ -720,0 +692,1 @@\n+   \/* PNGv3 compatibility: only report gAMA if it is really present. *\/\n@@ -721,2 +694,1 @@\n-       (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_GAMMA) != 0 &&\n-       file_gamma != NULL)\n+       (info_ptr->valid & PNG_INFO_gAMA) != 0)\n@@ -724,1 +696,1 @@\n-      *file_gamma = info_ptr->colorspace.gamma;\n+      if (file_gamma != NULL) *file_gamma = info_ptr->gamma;\n@@ -739,0 +711,1 @@\n+   \/* PNGv3 compatibility: only report gAMA if it is really present. *\/\n@@ -740,2 +713,1 @@\n-      (info_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_GAMMA) != 0 &&\n-      file_gamma != NULL)\n+       (info_ptr->valid & PNG_INFO_gAMA) != 0)\n@@ -743,2 +715,3 @@\n-      *file_gamma = png_float(png_ptr, info_ptr->colorspace.gamma,\n-          \"png_get_gAMA\");\n+      if (file_gamma != NULL)\n+         *file_gamma = png_float(png_ptr, info_ptr->gamma, \"gAMA\");\n+\n@@ -761,1 +734,1 @@\n-      (info_ptr->valid & PNG_INFO_sRGB) != 0 && file_srgb_intent != NULL)\n+      (info_ptr->valid & PNG_INFO_sRGB) != 0)\n@@ -763,1 +736,2 @@\n-      *file_srgb_intent = info_ptr->colorspace.rendering_intent;\n+      if (file_srgb_intent != NULL)\n+         *file_srgb_intent = info_ptr->rendering_intent;\n@@ -816,0 +790,130 @@\n+#ifdef PNG_cICP_SUPPORTED\n+png_uint_32 PNGAPI\n+png_get_cICP(png_const_structrp png_ptr,\n+             png_const_inforp info_ptr, png_bytep colour_primaries,\n+             png_bytep transfer_function, png_bytep matrix_coefficients,\n+             png_bytep video_full_range_flag)\n+{\n+    png_debug1(1, \"in %s retrieval function\", \"cICP\");\n+\n+    if (png_ptr != NULL && info_ptr != NULL &&\n+        (info_ptr->valid & PNG_INFO_cICP) != 0 &&\n+        colour_primaries != NULL && transfer_function != NULL &&\n+        matrix_coefficients != NULL && video_full_range_flag != NULL)\n+    {\n+        *colour_primaries = info_ptr->cicp_colour_primaries;\n+        *transfer_function = info_ptr->cicp_transfer_function;\n+        *matrix_coefficients = info_ptr->cicp_matrix_coefficients;\n+        *video_full_range_flag = info_ptr->cicp_video_full_range_flag;\n+        return (PNG_INFO_cICP);\n+    }\n+\n+    return 0;\n+}\n+#endif\n+\n+#ifdef PNG_cLLI_SUPPORTED\n+#  ifdef PNG_FIXED_POINT_SUPPORTED\n+png_uint_32 PNGAPI\n+png_get_cLLI_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,\n+    png_uint_32p maxCLL,\n+    png_uint_32p maxFALL)\n+{\n+   png_debug1(1, \"in %s retrieval function\", \"cLLI\");\n+\n+   if (png_ptr != NULL && info_ptr != NULL &&\n+       (info_ptr->valid & PNG_INFO_cLLI) != 0)\n+   {\n+      if (maxCLL != NULL) *maxCLL = info_ptr->maxCLL;\n+      if (maxFALL != NULL) *maxFALL = info_ptr->maxFALL;\n+      return PNG_INFO_cLLI;\n+   }\n+\n+   return 0;\n+}\n+#  endif\n+\n+#  ifdef PNG_FLOATING_POINT_SUPPORTED\n+png_uint_32 PNGAPI\n+png_get_cLLI(png_const_structrp png_ptr, png_const_inforp info_ptr,\n+      double *maxCLL, double *maxFALL)\n+{\n+   png_debug1(1, \"in %s retrieval function\", \"cLLI(float)\");\n+\n+   if (png_ptr != NULL && info_ptr != NULL &&\n+       (info_ptr->valid & PNG_INFO_cLLI) != 0)\n+   {\n+      if (maxCLL != NULL) *maxCLL = info_ptr->maxCLL * .0001;\n+      if (maxFALL != NULL) *maxFALL = info_ptr->maxFALL * .0001;\n+      return PNG_INFO_cLLI;\n+   }\n+\n+   return 0;\n+}\n+#  endif\n+#endif \/* cLLI *\/\n+\n+#ifdef PNG_mDCV_SUPPORTED\n+#  ifdef PNG_FIXED_POINT_SUPPORTED\n+png_uint_32 PNGAPI\n+png_get_mDCV_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,\n+    png_fixed_point *white_x, png_fixed_point *white_y,\n+    png_fixed_point *red_x, png_fixed_point *red_y,\n+    png_fixed_point *green_x, png_fixed_point *green_y,\n+    png_fixed_point *blue_x, png_fixed_point *blue_y,\n+    png_uint_32p mastering_maxDL, png_uint_32p mastering_minDL)\n+{\n+   png_debug1(1, \"in %s retrieval function\", \"mDCV\");\n+\n+   if (png_ptr != NULL && info_ptr != NULL &&\n+       (info_ptr->valid & PNG_INFO_mDCV) != 0)\n+   {\n+      if (white_x != NULL) *white_x = info_ptr->mastering_white_x * 2;\n+      if (white_y != NULL) *white_y = info_ptr->mastering_white_y * 2;\n+      if (red_x != NULL) *red_x = info_ptr->mastering_red_x * 2;\n+      if (red_y != NULL) *red_y = info_ptr->mastering_red_y * 2;\n+      if (green_x != NULL) *green_x = info_ptr->mastering_green_x * 2;\n+      if (green_y != NULL) *green_y = info_ptr->mastering_green_y * 2;\n+      if (blue_x != NULL) *blue_x = info_ptr->mastering_blue_x * 2;\n+      if (blue_y != NULL) *blue_y = info_ptr->mastering_blue_y * 2;\n+      if (mastering_maxDL != NULL) *mastering_maxDL = info_ptr->mastering_maxDL;\n+      if (mastering_minDL != NULL) *mastering_minDL = info_ptr->mastering_minDL;\n+      return PNG_INFO_mDCV;\n+   }\n+\n+   return 0;\n+}\n+#  endif\n+\n+#  ifdef PNG_FLOATING_POINT_SUPPORTED\n+png_uint_32 PNGAPI\n+png_get_mDCV(png_const_structrp png_ptr, png_const_inforp info_ptr,\n+    double *white_x, double *white_y, double *red_x, double *red_y,\n+    double *green_x, double *green_y, double *blue_x, double *blue_y,\n+    double *mastering_maxDL, double *mastering_minDL)\n+{\n+   png_debug1(1, \"in %s retrieval function\", \"mDCV(float)\");\n+\n+   if (png_ptr != NULL && info_ptr != NULL &&\n+       (info_ptr->valid & PNG_INFO_mDCV) != 0)\n+   {\n+      if (white_x != NULL) *white_x = info_ptr->mastering_white_x * .00002;\n+      if (white_y != NULL) *white_y = info_ptr->mastering_white_y * .00002;\n+      if (red_x != NULL) *red_x = info_ptr->mastering_red_x * .00002;\n+      if (red_y != NULL) *red_y = info_ptr->mastering_red_y * .00002;\n+      if (green_x != NULL) *green_x = info_ptr->mastering_green_x * .00002;\n+      if (green_y != NULL) *green_y = info_ptr->mastering_green_y * .00002;\n+      if (blue_x != NULL) *blue_x = info_ptr->mastering_blue_x * .00002;\n+      if (blue_y != NULL) *blue_y = info_ptr->mastering_blue_y * .00002;\n+      if (mastering_maxDL != NULL)\n+         *mastering_maxDL = info_ptr->mastering_maxDL * .0001;\n+      if (mastering_minDL != NULL)\n+         *mastering_minDL = info_ptr->mastering_minDL * .0001;\n+      return PNG_INFO_mDCV;\n+   }\n+\n+   return 0;\n+}\n+#  endif \/* FLOATING_POINT *\/\n+#endif \/* mDCV *\/\n+\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngget.c","additions":206,"deletions":102,"binary":false,"changes":308,"status":"modified"},{"patch":"@@ -118,12 +118,6 @@\n-#if defined(PNG_COLORSPACE_SUPPORTED) || defined(PNG_GAMMA_SUPPORTED)\n-   \/* png_colorspace only contains 'flags' if neither GAMMA or COLORSPACE are\n-    * defined.  When COLORSPACE is switched on all the colorspace-defining\n-    * chunks should be enabled, when GAMMA is switched on all the gamma-defining\n-    * chunks should be enabled.  If this is not done it becomes possible to read\n-    * inconsistent PNG files and assign a probably incorrect interpretation to\n-    * the information.  (In other words, by carefully choosing which chunks to\n-    * recognize the system configuration can select an interpretation for PNG\n-    * files containing ambiguous data and this will result in inconsistent\n-    * behavior between different libpng builds!)\n-    *\/\n-   png_colorspace colorspace;\n+#ifdef PNG_cICP_SUPPORTED\n+   \/* cICP chunk data *\/\n+   png_byte cicp_colour_primaries;\n+   png_byte cicp_transfer_function;\n+   png_byte cicp_matrix_coefficients;\n+   png_byte cicp_video_full_range_flag;\n@@ -139,0 +133,18 @@\n+#ifdef PNG_cLLI_SUPPORTED\n+   png_uint_32 maxCLL;  \/* cd\/m2 (nits) * 10,000 *\/\n+   png_uint_32 maxFALL;\n+#endif\n+\n+#ifdef PNG_mDCV_SUPPORTED\n+   png_uint_16 mastering_red_x;  \/* CIE (xy) x * 50,000 *\/\n+   png_uint_16 mastering_red_y;\n+   png_uint_16 mastering_green_x;\n+   png_uint_16 mastering_green_y;\n+   png_uint_16 mastering_blue_x;\n+   png_uint_16 mastering_blue_y;\n+   png_uint_16 mastering_white_x;\n+   png_uint_16 mastering_white_y;\n+   png_uint_32 mastering_maxDL; \/* cd\/m2 (nits) * 10,000 *\/\n+   png_uint_32 mastering_minDL;\n+#endif\n+\n@@ -217,1 +229,1 @@\n-   int num_exif;  \/* Added at libpng-1.6.31 *\/\n+   png_uint_32 num_exif;  \/* Added at libpng-1.6.31 *\/\n@@ -219,3 +231,0 @@\n-# ifdef PNG_READ_eXIf_SUPPORTED\n-   png_bytep eXIf_buf;  \/* Added at libpng-1.6.32 *\/\n-# endif\n@@ -294,0 +303,11 @@\n+#ifdef PNG_cHRM_SUPPORTED\n+   png_xy cHRM;\n+#endif\n+\n+#ifdef PNG_gAMA_SUPPORTED\n+   png_fixed_point gamma;\n+#endif\n+\n+#ifdef PNG_sRGB_SUPPORTED\n+   int rendering_intent;\n+#endif\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pnginfo.h","additions":36,"deletions":16,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-\/* libpng version 1.6.43 *\/\n+\/* libpng version 1.6.47 *\/\n@@ -36,1 +36,1 @@\n-\/* Copyright (c) 2018-2023 Cosmin Truta *\/\n+\/* Copyright (c) 2018-2025 Cosmin Truta *\/\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pnglibconf.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -104,3 +104,9 @@\n-#ifndef PNG_USER_MEM_SUPPORTED\n-   PNG_UNUSED(png_ptr)\n-#endif\n+#  ifdef PNG_MAX_MALLOC_64K\n+      \/* This is support for legacy systems which had segmented addressing\n+       * limiting the maximum allocation size to 65536.  It takes precedence\n+       * over PNG_SIZE_MAX which is set to 65535 on true 16-bit systems.\n+       *\n+       * TODO: libpng-1.8: finally remove both cases.\n+       *\/\n+      if (size > 65536U) return NULL;\n+#  endif\n@@ -108,2 +114,1 @@\n-   \/* Some compilers complain that this is always true.  However, it\n-    * can be false when integer overflow happens.\n+   \/* This is checked too because the system malloc call below takes a (size_t).\n@@ -111,7 +116,3 @@\n-   if (size > 0 && size <= PNG_SIZE_MAX\n-#     ifdef PNG_MAX_MALLOC_64K\n-         && size <= 65536U\n-#     endif\n-      )\n-   {\n-#ifdef PNG_USER_MEM_SUPPORTED\n+   if (size > PNG_SIZE_MAX) return NULL;\n+\n+#  ifdef PNG_USER_MEM_SUPPORTED\n@@ -120,0 +121,3 @@\n+#  else\n+      PNG_UNUSED(png_ptr)\n+#  endif\n@@ -121,7 +125,2 @@\n-      else\n-#endif\n-         return malloc((size_t)size); \/* checked for truncation above *\/\n-   }\n-\n-   else\n-      return NULL;\n+   \/* Use the system malloc *\/\n+   return malloc((size_t)\/*SAFE*\/size); \/* checked for truncation above *\/\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngmem.c","additions":18,"deletions":19,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -63,0 +63,15 @@\n+#ifdef PNG_READ_INTERLACING_SUPPORTED\n+\/* Arrays to facilitate interlacing - use pass (0 - 6) as index. *\/\n+\n+\/* Start of interlace block *\/\n+static const png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};\n+\/* Offset to next interlace block *\/\n+static const png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n+\/* Start of interlace block in the y direction *\/\n+static const png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};\n+\/* Offset to next interlace block in the y direction *\/\n+static const png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};\n+\n+\/* TODO: Move these arrays to a common utility module to avoid duplication. *\/\n+#endif\n+\n@@ -210,3 +225,0 @@\n-      png_byte chunk_length[4];\n-      png_byte chunk_tag[4];\n-\n@@ -214,7 +226,1 @@\n-      png_push_fill_buffer(png_ptr, chunk_length, 4);\n-      png_ptr->push_length = png_get_uint_31(png_ptr, chunk_length);\n-      png_reset_crc(png_ptr);\n-      png_crc_read(png_ptr, chunk_tag, 4);\n-      png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(chunk_tag);\n-      png_check_chunk_name(png_ptr, png_ptr->chunk_name);\n-      png_check_chunk_length(png_ptr, png_ptr->push_length);\n+      png_ptr->push_length = png_read_chunk_header(png_ptr);\n@@ -261,1 +267,1 @@\n-      png_handle_IHDR(png_ptr, info_ptr, png_ptr->push_length);\n+      png_handle_chunk(png_ptr, info_ptr, png_ptr->push_length);\n@@ -267,1 +273,1 @@\n-      png_handle_IEND(png_ptr, info_ptr, png_ptr->push_length);\n+      png_handle_chunk(png_ptr, info_ptr, png_ptr->push_length);\n@@ -284,6 +290,0 @@\n-   else if (chunk_name == png_PLTE)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_PLTE(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n@@ -302,144 +302,0 @@\n-#ifdef PNG_READ_gAMA_SUPPORTED\n-   else if (png_ptr->chunk_name == png_gAMA)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_gAMA(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_sBIT_SUPPORTED\n-   else if (png_ptr->chunk_name == png_sBIT)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_sBIT(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_cHRM_SUPPORTED\n-   else if (png_ptr->chunk_name == png_cHRM)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_cHRM(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_eXIf_SUPPORTED\n-   else if (png_ptr->chunk_name == png_eXIf)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_eXIf(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_sRGB_SUPPORTED\n-   else if (chunk_name == png_sRGB)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_sRGB(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_iCCP_SUPPORTED\n-   else if (png_ptr->chunk_name == png_iCCP)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_iCCP(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_sPLT_SUPPORTED\n-   else if (chunk_name == png_sPLT)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_sPLT(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_tRNS_SUPPORTED\n-   else if (chunk_name == png_tRNS)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_tRNS(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_bKGD_SUPPORTED\n-   else if (chunk_name == png_bKGD)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_bKGD(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_hIST_SUPPORTED\n-   else if (chunk_name == png_hIST)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_hIST(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_pHYs_SUPPORTED\n-   else if (chunk_name == png_pHYs)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_pHYs(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_oFFs_SUPPORTED\n-   else if (chunk_name == png_oFFs)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_oFFs(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-#endif\n-\n-#ifdef PNG_READ_pCAL_SUPPORTED\n-   else if (chunk_name == png_pCAL)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_pCAL(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_sCAL_SUPPORTED\n-   else if (chunk_name == png_sCAL)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_sCAL(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_tIME_SUPPORTED\n-   else if (chunk_name == png_tIME)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_tIME(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_tEXt_SUPPORTED\n-   else if (chunk_name == png_tEXt)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_tEXt(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_zTXt_SUPPORTED\n-   else if (chunk_name == png_zTXt)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_zTXt(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-\n-#endif\n-#ifdef PNG_READ_iTXt_SUPPORTED\n-   else if (chunk_name == png_iTXt)\n-   {\n-      PNG_PUSH_SAVE_BUFFER_IF_FULL\n-      png_handle_iTXt(png_ptr, info_ptr, png_ptr->push_length);\n-   }\n-#endif\n-\n@@ -449,2 +305,1 @@\n-      png_handle_unknown(png_ptr, info_ptr, png_ptr->push_length,\n-          PNG_HANDLE_CHUNK_AS_DEFAULT);\n+      png_handle_chunk(png_ptr, info_ptr, png_ptr->push_length);\n@@ -1007,21 +862,0 @@\n-#ifdef PNG_READ_INTERLACING_SUPPORTED\n-   \/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index *\/\n-\n-   \/* Start of interlace block *\/\n-   static const png_byte png_pass_start[] = {0, 4, 0, 2, 0, 1, 0};\n-\n-   \/* Offset to next interlace block *\/\n-   static const png_byte png_pass_inc[] = {8, 8, 4, 4, 2, 2, 1};\n-\n-   \/* Start of interlace block in the y direction *\/\n-   static const png_byte png_pass_ystart[] = {0, 0, 4, 0, 2, 0, 1};\n-\n-   \/* Offset to next interlace block in the y direction *\/\n-   static const png_byte png_pass_yinc[] = {8, 8, 8, 4, 4, 2, 2};\n-\n-   \/* Height of interlace block.  This is not currently used - if you need\n-    * it, uncomment it here and in png.h\n-   static const png_byte png_pass_height[] = {8, 8, 4, 4, 2, 2, 1};\n-   *\/\n-#endif\n-\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngpread.c","additions":19,"deletions":185,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -171,41 +171,0 @@\n-\n-   \/* By default the 'intrinsics' code in arm\/filter_neon_intrinsics.c is used\n-    * if possible - if __ARM_NEON__ is set and the compiler version is not known\n-    * to be broken.  This is controlled by PNG_ARM_NEON_IMPLEMENTATION which can\n-    * be:\n-    *\n-    *    1  The intrinsics code (the default with __ARM_NEON__)\n-    *    2  The hand coded assembler (the default without __ARM_NEON__)\n-    *\n-    * It is possible to set PNG_ARM_NEON_IMPLEMENTATION in CPPFLAGS, however\n-    * this is *NOT* supported and may cease to work even after a minor revision\n-    * to libpng.  It *is* valid to do this for testing purposes, e.g. speed\n-    * testing or a new compiler, but the results should be communicated to the\n-    * libpng implementation list for incorporation in the next minor release.\n-    *\/\n-#  ifndef PNG_ARM_NEON_IMPLEMENTATION\n-#     if defined(__ARM_NEON__) || defined(__ARM_NEON)\n-#        if defined(__clang__)\n-            \/* At present it is unknown by the libpng developers which versions\n-             * of clang support the intrinsics, however some or perhaps all\n-             * versions do not work with the assembler so this may be\n-             * irrelevant, so just use the default (do nothing here.)\n-             *\/\n-#        elif defined(__GNUC__)\n-            \/* GCC 4.5.4 NEON support is known to be broken.  4.6.3 is known to\n-             * work, so if this *is* GCC, or G++, look for a version >4.5\n-             *\/\n-#           if __GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 6)\n-#              define PNG_ARM_NEON_IMPLEMENTATION 2\n-#           endif \/* no GNUC support *\/\n-#        endif \/* __GNUC__ *\/\n-#     else \/* !defined __ARM_NEON__ *\/\n-         \/* The 'intrinsics' code simply won't compile without this -mfpu=neon:\n-          *\/\n-#        if !defined(__aarch64__) && !defined(_M_ARM64)\n-            \/* The assembler code currently does not work on ARM64 *\/\n-#          define PNG_ARM_NEON_IMPLEMENTATION 2\n-#        endif \/* __aarch64__ *\/\n-#     endif \/* __ARM_NEON__ *\/\n-#  endif \/* !PNG_ARM_NEON_IMPLEMENTATION *\/\n-\n@@ -744,1 +703,1 @@\n-#define PNG_FLAG_ASSUME_sRGB              0x1000U \/* Added to libpng-1.5.4 *\/\n+\/*      PNG_FLAG_ASSUME_sRGB unused       0x1000U  * Added to libpng-1.5.4 *\/\n@@ -855,0 +814,2 @@\n+#define png_fixed_ITU(png_ptr, fp, s) ((fp) <= 214748 && (fp) >= 0 ?\\\n+    ((png_uint_32)(10000 * (fp))) : (png_fixed_error(png_ptr, s),0))\n@@ -873,0 +834,4 @@\n+ *\n+ * 1.6.47: PNG_32b was made into a preprocessor evaluable macro by replacing the\n+ * static_cast with a promoting binary operation using a guaranteed 32-bit\n+ * (minimum) unsigned value.\n@@ -874,1 +839,1 @@\n-#define PNG_32b(b,s) ((png_uint_32)(b) << (s))\n+#define PNG_32b(b,s) (((0xFFFFFFFFU)&(b)) << (s))\n@@ -878,0 +843,16 @@\n+\/* Chunk name validation.  When using these macros all the arguments should be\n+ * constants, otherwise code bloat may well occur.  The macros are provided\n+ * primarily for use in #if checks.\n+ *\n+ * PNG_32to8 produces a byte value with the right shift; used to extract the\n+ * byte value from a chunk name.\n+ *\/\n+#define PNG_32to8(cn,s) (((cn) >> (s)) & 0xffU)\n+#define PNG_CN_VALID_UPPER(b) ((b) >= 65 && (b) <= 90) \/* upper-case ASCII *\/\n+#define PNG_CN_VALID_ASCII(b) PNG_CN_VALID_UPPER((b) & ~32U)\n+#define PNG_CHUNK_NAME_VALID(cn) (\\\n+   PNG_CN_VALID_ASCII(PNG_32to8(cn,24)) && \/* critical, !ancillary *\/\\\n+   PNG_CN_VALID_ASCII(PNG_32to8(cn,16)) && \/* public, !privately defined *\/\\\n+   PNG_CN_VALID_UPPER(PNG_32to8(cn, 8)) && \/* VALID, !reserved *\/\\\n+   PNG_CN_VALID_ASCII(PNG_32to8(cn, 0))   \/* data-dependent, !copy ok *\/)\n+\n@@ -905,0 +886,1 @@\n+#define png_acTL PNG_U32( 97,  99,  84,  76) \/* PNGv3: APNG *\/\n@@ -907,0 +889,2 @@\n+#define png_cICP PNG_U32( 99,  73,  67,  80) \/* PNGv3 *\/\n+#define png_cLLI PNG_U32( 99,  76,  76,  73) \/* PNGv3 *\/\n@@ -908,0 +892,2 @@\n+#define png_fcTL PNG_U32(102,  99,  84,  76) \/* PNGv3: APNG *\/\n+#define png_fdAT PNG_U32(102, 100,  65,  84) \/* PNGv3: APNG *\/\n@@ -916,0 +902,1 @@\n+#define png_mDCV PNG_U32(109,  68,  67,  86) \/* PNGv3 *\/\n@@ -956,0 +943,50 @@\n+\/* Known chunks.  All supported chunks must be listed here.  The macro PNG_CHUNK\n+ * contains the four character ASCII name by which the chunk is identified.  The\n+ * macro is implemented as required to build tables or switch statements which\n+ * require entries for every known chunk.  The macro also contains an index\n+ * value which should be in order (this is checked in png.c).\n+ *\n+ * Notice that \"known\" does not require \"SUPPORTED\"; tables should be built in\n+ * such a way that chunks unsupported in a build require no more than the table\n+ * entry (which should be small.)  In particular function pointers for\n+ * unsupported chunks should be NULL.\n+ *\n+ * At present these index values are not exported (not part of the public API)\n+ * so can be changed at will.  For convenience the names are in lexical sort\n+ * order but with the critical chunks at the start in the order of occurence in\n+ * a PNG.\n+ *\n+ * PNG_INFO_ values do not exist for every one of these chunk handles; for\n+ * example PNG_INFO_{IDAT,IEND,tEXt,iTXt,zTXt} and possibly other chunks in the\n+ * future.\n+ *\/\n+#define PNG_KNOWN_CHUNKS\\\n+   PNG_CHUNK(IHDR,  0)\\\n+   PNG_CHUNK(PLTE,  1)\\\n+   PNG_CHUNK(IDAT,  2)\\\n+   PNG_CHUNK(IEND,  3)\\\n+   PNG_CHUNK(acTL,  4)\\\n+   PNG_CHUNK(bKGD,  5)\\\n+   PNG_CHUNK(cHRM,  6)\\\n+   PNG_CHUNK(cICP,  7)\\\n+   PNG_CHUNK(cLLI,  8)\\\n+   PNG_CHUNK(eXIf,  9)\\\n+   PNG_CHUNK(fcTL, 10)\\\n+   PNG_CHUNK(fdAT, 11)\\\n+   PNG_CHUNK(gAMA, 12)\\\n+   PNG_CHUNK(hIST, 13)\\\n+   PNG_CHUNK(iCCP, 14)\\\n+   PNG_CHUNK(iTXt, 15)\\\n+   PNG_CHUNK(mDCV, 16)\\\n+   PNG_CHUNK(oFFs, 17)\\\n+   PNG_CHUNK(pCAL, 18)\\\n+   PNG_CHUNK(pHYs, 19)\\\n+   PNG_CHUNK(sBIT, 20)\\\n+   PNG_CHUNK(sCAL, 21)\\\n+   PNG_CHUNK(sPLT, 22)\\\n+   PNG_CHUNK(sRGB, 23)\\\n+   PNG_CHUNK(tEXt, 24)\\\n+   PNG_CHUNK(tIME, 25)\\\n+   PNG_CHUNK(tRNS, 26)\\\n+   PNG_CHUNK(zTXt, 27)\n+\n@@ -961,0 +998,13 @@\n+\/* gamma sanity check.  libpng cannot implement gamma transforms outside a\n+ * certain limit because of its use of 16-bit fixed point intermediate values.\n+ * Gamma values that are too large or too small will zap the 16-bit values all\n+ * to 0 or 65535 resulting in an obvious 'bad' image.\n+ *\n+ * In libpng 1.6.0 the limits were changed from 0.07..3 to 0.01..100 to\n+ * accommodate the optimal 16-bit gamma of 36 and its reciprocal.\n+ *\n+ * These are png_fixed_point integral values:\n+ *\/\n+#define PNG_LIB_GAMMA_MIN 1000\n+#define PNG_LIB_GAMMA_MAX 10000000\n+\n@@ -1024,1 +1074,0 @@\n-\n@@ -1043,0 +1092,1 @@\n+   defined(PNG_mDCV_SUPPORTED) || \\\n@@ -1050,0 +1100,7 @@\n+#if defined(PNG_FLOATING_POINT_SUPPORTED) && \\\n+   !defined(PNG_FIXED_POINT_MACRO_SUPPORTED) && \\\n+   (defined(PNG_cLLI_SUPPORTED) || defined(PNG_mDCV_SUPPORTED))\n+PNG_INTERNAL_FUNCTION(png_uint_32,png_fixed_ITU,(png_const_structrp png_ptr,\n+   double fp, png_const_charp text),PNG_EMPTY);\n+#endif\n+\n@@ -1056,0 +1113,19 @@\n+#ifdef PNG_READ_SUPPORTED \/* should only be used on read *\/\n+\/* Security: read limits on the largest allocations while reading a PNG.  This\n+ * avoids very large allocations caused by PNG files with damaged or altered\n+ * chunk 'length' fields.\n+ *\/\n+#ifdef PNG_SET_USER_LIMITS_SUPPORTED \/* run-time limit *\/\n+#  define png_chunk_max(png_ptr) ((png_ptr)->user_chunk_malloc_max)\n+\n+#elif PNG_USER_CHUNK_MALLOC_MAX > 0 \/* compile-time limit *\/\n+#  define png_chunk_max(png_ptr) ((void)png_ptr, PNG_USER_CHUNK_MALLOC_MAX)\n+\n+#elif (defined PNG_MAX_MALLOC_64K)  \/* legacy system limit *\/\n+#  define png_chunk_max(png_ptr) ((void)png_ptr, 65536U)\n+\n+#else                               \/* modern system limit SIZE_MAX (C99) *\/\n+#  define png_chunk_max(png_ptr) ((void)png_ptr, PNG_SIZE_MAX)\n+#endif\n+#endif \/* READ *\/\n+\n@@ -1155,3 +1231,0 @@\n-\/* Read the CRC from the file and compare it to the libpng calculated CRC *\/\n-PNG_INTERNAL_FUNCTION(int,png_crc_error,(png_structrp png_ptr),PNG_EMPTY);\n-\n@@ -1203,0 +1276,20 @@\n+#ifdef PNG_WRITE_cICP_SUPPORTED\n+PNG_INTERNAL_FUNCTION(void,png_write_cICP,(png_structrp png_ptr,\n+    png_byte colour_primaries, png_byte transfer_function,\n+    png_byte matrix_coefficients, png_byte video_full_range_flag), PNG_EMPTY);\n+#endif\n+\n+#ifdef PNG_WRITE_cLLI_SUPPORTED\n+PNG_INTERNAL_FUNCTION(void,png_write_cLLI_fixed,(png_structrp png_ptr,\n+   png_uint_32 maxCLL, png_uint_32 maxFALL), PNG_EMPTY);\n+#endif\n+\n+#ifdef PNG_WRITE_mDCV_SUPPORTED\n+PNG_INTERNAL_FUNCTION(void,png_write_mDCV_fixed,(png_structrp png_ptr,\n+   png_uint_16 red_x, png_uint_16 red_y,\n+   png_uint_16 green_x, png_uint_16 green_y,\n+   png_uint_16 blue_x, png_uint_16 blue_y,\n+   png_uint_16 white_x, png_uint_16 white_y,\n+   png_uint_32 maxDL, png_uint_32 minDL), PNG_EMPTY);\n+#endif\n+\n@@ -1215,4 +1308,4 @@\n-   png_const_charp name, png_const_bytep profile), PNG_EMPTY);\n-   \/* The profile must have been previously validated for correctness, the\n-    * length comes from the first four bytes.  Only the base, deflate,\n-    * compression is supported.\n+   png_const_charp name, png_const_bytep profile, png_uint_32 proflen),\n+   PNG_EMPTY);\n+   \/* Writes a previously 'set' profile.  The profile argument is **not**\n+    * compressed.\n@@ -1527,107 +1620,18 @@\n-\n-\/* Decode the IHDR chunk *\/\n-PNG_INTERNAL_FUNCTION(void,png_handle_IHDR,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-PNG_INTERNAL_FUNCTION(void,png_handle_PLTE,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-PNG_INTERNAL_FUNCTION(void,png_handle_IEND,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-\n-#ifdef PNG_READ_bKGD_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_bKGD,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_cHRM_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_cHRM,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_eXIf_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_eXIf,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_gAMA_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_gAMA,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_hIST_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_hIST,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_iCCP_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_iCCP,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif \/* READ_iCCP *\/\n-\n-#ifdef PNG_READ_iTXt_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_iTXt,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_oFFs_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_oFFs,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_pCAL_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_pCAL,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_pHYs_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_pHYs,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_sBIT_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_sBIT,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_sCAL_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_sCAL,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_sPLT_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_sPLT,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif \/* READ_sPLT *\/\n-\n-#ifdef PNG_READ_sRGB_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_sRGB,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_tEXt_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_tEXt,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_tIME_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_tIME,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_tRNS_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_tRNS,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-#ifdef PNG_READ_zTXt_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_handle_zTXt,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-#endif\n-\n-PNG_INTERNAL_FUNCTION(void,png_check_chunk_name,(png_const_structrp png_ptr,\n-    png_uint_32 chunk_name),PNG_EMPTY);\n-\n-PNG_INTERNAL_FUNCTION(void,png_check_chunk_length,(png_const_structrp png_ptr,\n-    png_uint_32 chunk_length),PNG_EMPTY);\n-\n-PNG_INTERNAL_FUNCTION(void,png_handle_unknown,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length, int keep),PNG_EMPTY);\n+typedef enum\n+{\n+   \/* Result of a call to png_handle_chunk made to handle the current chunk\n+    * png_struct::chunk_name on read.  Always informational, either the stream\n+    * is read for the next chunk or the routine will call png_error.\n+    *\n+    * NOTE: order is important internally.  handled_saved and above are regarded\n+    * as handling the chunk.\n+    *\/\n+   handled_error = 0,  \/* bad crc or known and bad format or too long *\/\n+   handled_discarded,  \/* not saved in the unknown chunk list *\/\n+   handled_saved,      \/* saved in the unknown chunk list *\/\n+   handled_ok          \/* known, supported and handled without error *\/\n+} png_handle_result_code;\n+\n+PNG_INTERNAL_FUNCTION(png_handle_result_code,png_handle_unknown,\n+    (png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length, int keep),\n+    PNG_EMPTY);\n@@ -1640,0 +1644,6 @@\n+PNG_INTERNAL_FUNCTION(png_handle_result_code,png_handle_chunk,\n+    (png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n+   \/* This handles the current chunk png_ptr->chunk_name with unread\n+    * data[length] and returns one of the above result codes.\n+    *\/\n+\n@@ -1679,2 +1689,0 @@\n-PNG_INTERNAL_FUNCTION(void,png_push_handle_unknown,(png_structrp png_ptr,\n-   png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n@@ -1693,19 +1701,0 @@\n-#  ifdef PNG_READ_tEXt_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_push_handle_tEXt,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-PNG_INTERNAL_FUNCTION(void,png_push_read_tEXt,(png_structrp png_ptr,\n-    png_inforp info_ptr),PNG_EMPTY);\n-#  endif\n-#  ifdef PNG_READ_zTXt_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_push_handle_zTXt,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-PNG_INTERNAL_FUNCTION(void,png_push_read_zTXt,(png_structrp png_ptr,\n-    png_inforp info_ptr),PNG_EMPTY);\n-#  endif\n-#  ifdef PNG_READ_iTXt_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_push_handle_iTXt,(png_structrp png_ptr,\n-    png_inforp info_ptr, png_uint_32 length),PNG_EMPTY);\n-PNG_INTERNAL_FUNCTION(void,png_push_read_iTXt,(png_structrp png_ptr,\n-    png_inforp info_ptr),PNG_EMPTY);\n-#  endif\n-\n@@ -1714,43 +1703,0 @@\n-\/* Added at libpng version 1.6.0 *\/\n-#ifdef PNG_GAMMA_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_colorspace_set_gamma,(png_const_structrp png_ptr,\n-    png_colorspacerp colorspace, png_fixed_point gAMA), PNG_EMPTY);\n-   \/* Set the colorspace gamma with a value provided by the application or by\n-    * the gAMA chunk on read.  The value will override anything set by an ICC\n-    * profile.\n-    *\/\n-\n-PNG_INTERNAL_FUNCTION(void,png_colorspace_sync_info,(png_const_structrp png_ptr,\n-    png_inforp info_ptr), PNG_EMPTY);\n-   \/* Synchronize the info 'valid' flags with the colorspace *\/\n-\n-PNG_INTERNAL_FUNCTION(void,png_colorspace_sync,(png_const_structrp png_ptr,\n-    png_inforp info_ptr), PNG_EMPTY);\n-   \/* Copy the png_struct colorspace to the info_struct and call the above to\n-    * synchronize the flags.  Checks for NULL info_ptr and does nothing.\n-    *\/\n-#endif\n-\n-\/* Added at libpng version 1.4.0 *\/\n-#ifdef PNG_COLORSPACE_SUPPORTED\n-\/* These internal functions are for maintaining the colorspace structure within\n- * a png_info or png_struct (or, indeed, both).\n- *\/\n-PNG_INTERNAL_FUNCTION(int,png_colorspace_set_chromaticities,\n-   (png_const_structrp png_ptr, png_colorspacerp colorspace, const png_xy *xy,\n-    int preferred), PNG_EMPTY);\n-\n-PNG_INTERNAL_FUNCTION(int,png_colorspace_set_endpoints,\n-   (png_const_structrp png_ptr, png_colorspacerp colorspace, const png_XYZ *XYZ,\n-    int preferred), PNG_EMPTY);\n-\n-#ifdef PNG_sRGB_SUPPORTED\n-PNG_INTERNAL_FUNCTION(int,png_colorspace_set_sRGB,(png_const_structrp png_ptr,\n-   png_colorspacerp colorspace, int intent), PNG_EMPTY);\n-   \/* This does set the colorspace gAMA and cHRM values too, but doesn't set the\n-    * flags to write them, if it returns false there was a problem and an error\n-    * message has already been output (but the colorspace may still need to be\n-    * synced to record the invalid flag).\n-    *\/\n-#endif \/* sRGB *\/\n-\n@@ -1758,6 +1704,0 @@\n-PNG_INTERNAL_FUNCTION(int,png_colorspace_set_ICC,(png_const_structrp png_ptr,\n-   png_colorspacerp colorspace, png_const_charp name,\n-   png_uint_32 profile_length, png_const_bytep profile, int color_type),\n-   PNG_EMPTY);\n-   \/* The 'name' is used for information only *\/\n-\n@@ -1767,2 +1707,1 @@\n-   png_colorspacerp colorspace, png_const_charp name,\n-   png_uint_32 profile_length), PNG_EMPTY);\n+   png_const_charp name, png_uint_32 profile_length), PNG_EMPTY);\n@@ -1771,2 +1710,1 @@\n-   png_colorspacerp colorspace, png_const_charp name,\n-   png_uint_32 profile_length,\n+   png_const_charp name, png_uint_32 profile_length,\n@@ -1776,2 +1714,1 @@\n-   png_colorspacerp colorspace, png_const_charp name,\n-   png_uint_32 profile_length,\n+   png_const_charp name, png_uint_32 profile_length,\n@@ -1779,9 +1716,0 @@\n-#ifdef PNG_sRGB_SUPPORTED\n-PNG_INTERNAL_FUNCTION(void,png_icc_set_sRGB,(\n-   png_const_structrp png_ptr, png_colorspacerp colorspace,\n-   png_const_bytep profile, uLong adler), PNG_EMPTY);\n-   \/* 'adler' is the Adler32 checksum of the uncompressed profile data. It may\n-    * be zero to indicate that it is not available.  It is used, if provided,\n-    * as a fast check on the profile when checking to see if it is sRGB.\n-    *\/\n-#endif\n@@ -1791,3 +1719,3 @@\n-PNG_INTERNAL_FUNCTION(void,png_colorspace_set_rgb_coefficients,\n-   (png_structrp png_ptr), PNG_EMPTY);\n-   \/* Set the rgb_to_gray coefficients from the colorspace Y values *\/\n+PNG_INTERNAL_FUNCTION(void,png_set_rgb_coefficients, (png_structrp png_ptr),\n+   PNG_EMPTY);\n+   \/* Set the rgb_to_gray coefficients from the cHRM Y values (if unset) *\/\n@@ -1795,1 +1723,0 @@\n-#endif \/* COLORSPACE *\/\n@@ -2057,2 +1984,4 @@\n-#if defined(PNG_GAMMA_SUPPORTED) ||\\\n-    defined(PNG_INCH_CONVERSIONS_SUPPORTED) || defined(PNG_READ_pHYs_SUPPORTED)\n+#if defined(PNG_READ_GAMMA_SUPPORTED) ||\\\n+    defined(PNG_COLORSPACE_SUPPORTED) ||\\\n+    defined(PNG_INCH_CONVERSIONS_SUPPORTED) ||\\\n+    defined(PNG_READ_pHYs_SUPPORTED)\n@@ -2067,8 +1996,0 @@\n-#endif\n-\n-#if defined(PNG_READ_GAMMA_SUPPORTED) || defined(PNG_INCH_CONVERSIONS_SUPPORTED)\n-\/* Same deal, but issue a warning on overflow and return 0. *\/\n-PNG_INTERNAL_FUNCTION(png_fixed_point,png_muldiv_warn,\n-   (png_const_structrp png_ptr, png_fixed_point a, png_int_32 multiplied_by,\n-   png_int_32 divided_by),PNG_EMPTY);\n-#endif\n@@ -2076,1 +1997,0 @@\n-#ifdef PNG_GAMMA_SUPPORTED\n@@ -2083,0 +2003,1 @@\n+#endif\n@@ -2091,1 +2012,0 @@\n-#endif\n@@ -2096,1 +2016,0 @@\n-#endif\n@@ -2098,1 +2017,11 @@\n-#ifdef PNG_READ_GAMMA_SUPPORTED\n+\/* PNGv3: 'resolve' the file gamma according to the new PNGv3 rules for colour\n+ * space information.\n+ *\n+ * NOTE: this uses precisely those chunks that libpng supports.  For example it\n+ * doesn't use iCCP and it can only use cICP for known and manageable\n+ * transforms.  For this reason a gamma specified by png_set_gamma always takes\n+ * precedence.\n+ *\/\n+PNG_INTERNAL_FUNCTION(png_fixed_point,png_resolve_file_gamma,\n+   (png_const_structrp png_ptr),PNG_EMPTY);\n+\n@@ -2116,0 +2045,16 @@\n+#endif \/* READ_GAMMA *\/\n+\n+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n+\/* Set the RGB coefficients if not already set by png_set_rgb_to_gray *\/\n+PNG_INTERNAL_FUNCTION(void,png_set_rgb_coefficients,(png_structrp png_ptr),\n+   PNG_EMPTY);\n+#endif\n+\n+#if defined(PNG_cHRM_SUPPORTED) || defined(PNG_READ_RGB_TO_GRAY_SUPPORTED)\n+PNG_INTERNAL_FUNCTION(int,png_XYZ_from_xy,(png_XYZ *XYZ, const png_xy *xy),\n+   PNG_EMPTY);\n+#endif \/* cHRM || READ_RGB_TO_GRAY *\/\n+\n+#ifdef PNG_COLORSPACE_SUPPORTED\n+PNG_INTERNAL_FUNCTION(int,png_xy_from_XYZ,(png_xy *xy, const png_XYZ *XYZ),\n+   PNG_EMPTY);\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngpriv.h","additions":206,"deletions":261,"binary":false,"changes":467,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018-2024 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -163,3 +163,0 @@\n-      \/* This should be a binary subdivision search or a hash for\n-       * matching the chunk name rather than a linear search.\n-       *\/\n@@ -167,1 +164,1 @@\n-         png_handle_IHDR(png_ptr, info_ptr, length);\n+         png_handle_chunk(png_ptr, info_ptr, length);\n@@ -170,1 +167,1 @@\n-         png_handle_IEND(png_ptr, info_ptr, length);\n+         png_handle_chunk(png_ptr, info_ptr, length);\n@@ -187,2 +184,0 @@\n-      else if (chunk_name == png_PLTE)\n-         png_handle_PLTE(png_ptr, info_ptr, length);\n@@ -196,90 +191,0 @@\n-#ifdef PNG_READ_bKGD_SUPPORTED\n-      else if (chunk_name == png_bKGD)\n-         png_handle_bKGD(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_cHRM_SUPPORTED\n-      else if (chunk_name == png_cHRM)\n-         png_handle_cHRM(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_eXIf_SUPPORTED\n-      else if (chunk_name == png_eXIf)\n-         png_handle_eXIf(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_gAMA_SUPPORTED\n-      else if (chunk_name == png_gAMA)\n-         png_handle_gAMA(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_hIST_SUPPORTED\n-      else if (chunk_name == png_hIST)\n-         png_handle_hIST(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_oFFs_SUPPORTED\n-      else if (chunk_name == png_oFFs)\n-         png_handle_oFFs(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_pCAL_SUPPORTED\n-      else if (chunk_name == png_pCAL)\n-         png_handle_pCAL(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_sCAL_SUPPORTED\n-      else if (chunk_name == png_sCAL)\n-         png_handle_sCAL(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_pHYs_SUPPORTED\n-      else if (chunk_name == png_pHYs)\n-         png_handle_pHYs(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_sBIT_SUPPORTED\n-      else if (chunk_name == png_sBIT)\n-         png_handle_sBIT(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_sRGB_SUPPORTED\n-      else if (chunk_name == png_sRGB)\n-         png_handle_sRGB(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_iCCP_SUPPORTED\n-      else if (chunk_name == png_iCCP)\n-         png_handle_iCCP(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_sPLT_SUPPORTED\n-      else if (chunk_name == png_sPLT)\n-         png_handle_sPLT(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_tEXt_SUPPORTED\n-      else if (chunk_name == png_tEXt)\n-         png_handle_tEXt(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_tIME_SUPPORTED\n-      else if (chunk_name == png_tIME)\n-         png_handle_tIME(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_tRNS_SUPPORTED\n-      else if (chunk_name == png_tRNS)\n-         png_handle_tRNS(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_zTXt_SUPPORTED\n-      else if (chunk_name == png_zTXt)\n-         png_handle_zTXt(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_iTXt_SUPPORTED\n-      else if (chunk_name == png_iTXt)\n-         png_handle_iTXt(png_ptr, info_ptr, length);\n-#endif\n-\n@@ -287,2 +192,1 @@\n-         png_handle_unknown(png_ptr, info_ptr, length,\n-             PNG_HANDLE_CHUNK_AS_DEFAULT);\n+         png_handle_chunk(png_ptr, info_ptr, length);\n@@ -833,1 +737,1 @@\n-         png_handle_IEND(png_ptr, info_ptr, length);\n+         png_handle_chunk(png_ptr, info_ptr, length);\n@@ -836,1 +740,1 @@\n-         png_handle_IHDR(png_ptr, info_ptr, length);\n+         png_handle_chunk(png_ptr, info_ptr, length);\n@@ -870,92 +774,0 @@\n-      else if (chunk_name == png_PLTE)\n-         png_handle_PLTE(png_ptr, info_ptr, length);\n-\n-#ifdef PNG_READ_bKGD_SUPPORTED\n-      else if (chunk_name == png_bKGD)\n-         png_handle_bKGD(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_cHRM_SUPPORTED\n-      else if (chunk_name == png_cHRM)\n-         png_handle_cHRM(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_eXIf_SUPPORTED\n-      else if (chunk_name == png_eXIf)\n-         png_handle_eXIf(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_gAMA_SUPPORTED\n-      else if (chunk_name == png_gAMA)\n-         png_handle_gAMA(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_hIST_SUPPORTED\n-      else if (chunk_name == png_hIST)\n-         png_handle_hIST(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_oFFs_SUPPORTED\n-      else if (chunk_name == png_oFFs)\n-         png_handle_oFFs(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_pCAL_SUPPORTED\n-      else if (chunk_name == png_pCAL)\n-         png_handle_pCAL(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_sCAL_SUPPORTED\n-      else if (chunk_name == png_sCAL)\n-         png_handle_sCAL(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_pHYs_SUPPORTED\n-      else if (chunk_name == png_pHYs)\n-         png_handle_pHYs(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_sBIT_SUPPORTED\n-      else if (chunk_name == png_sBIT)\n-         png_handle_sBIT(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_sRGB_SUPPORTED\n-      else if (chunk_name == png_sRGB)\n-         png_handle_sRGB(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_iCCP_SUPPORTED\n-      else if (chunk_name == png_iCCP)\n-         png_handle_iCCP(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_sPLT_SUPPORTED\n-      else if (chunk_name == png_sPLT)\n-         png_handle_sPLT(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_tEXt_SUPPORTED\n-      else if (chunk_name == png_tEXt)\n-         png_handle_tEXt(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_tIME_SUPPORTED\n-      else if (chunk_name == png_tIME)\n-         png_handle_tIME(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_tRNS_SUPPORTED\n-      else if (chunk_name == png_tRNS)\n-         png_handle_tRNS(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_zTXt_SUPPORTED\n-      else if (chunk_name == png_zTXt)\n-         png_handle_zTXt(png_ptr, info_ptr, length);\n-#endif\n-\n-#ifdef PNG_READ_iTXt_SUPPORTED\n-      else if (chunk_name == png_iTXt)\n-         png_handle_iTXt(png_ptr, info_ptr, length);\n-#endif\n@@ -964,2 +776,1 @@\n-         png_handle_unknown(png_ptr, info_ptr, length,\n-             PNG_HANDLE_CHUNK_AS_DEFAULT);\n+         png_handle_chunk(png_ptr, info_ptr, length);\n@@ -1416,0 +1227,25 @@\n+static int\n+chromaticities_match_sRGB(const png_xy *xy)\n+{\n+#  define sRGB_TOLERANCE 1000\n+   static const png_xy sRGB_xy = \/* From ITU-R BT.709-3 *\/\n+   {\n+      \/* color      x       y *\/\n+      \/* red   *\/ 64000, 33000,\n+      \/* green *\/ 30000, 60000,\n+      \/* blue  *\/ 15000,  6000,\n+      \/* white *\/ 31270, 32900\n+   };\n+\n+   if (PNG_OUT_OF_RANGE(xy->whitex, sRGB_xy.whitex,sRGB_TOLERANCE) ||\n+       PNG_OUT_OF_RANGE(xy->whitey, sRGB_xy.whitey,sRGB_TOLERANCE) ||\n+       PNG_OUT_OF_RANGE(xy->redx,   sRGB_xy.redx,  sRGB_TOLERANCE) ||\n+       PNG_OUT_OF_RANGE(xy->redy,   sRGB_xy.redy,  sRGB_TOLERANCE) ||\n+       PNG_OUT_OF_RANGE(xy->greenx, sRGB_xy.greenx,sRGB_TOLERANCE) ||\n+       PNG_OUT_OF_RANGE(xy->greeny, sRGB_xy.greeny,sRGB_TOLERANCE) ||\n+       PNG_OUT_OF_RANGE(xy->bluex,  sRGB_xy.bluex, sRGB_TOLERANCE) ||\n+       PNG_OUT_OF_RANGE(xy->bluey,  sRGB_xy.bluey, sRGB_TOLERANCE))\n+      return 0;\n+   return 1;\n+}\n+\n@@ -1424,8 +1260,3 @@\n-   if (g < PNG_FP_1)\n-   {\n-      \/* An uninitialized gamma is assumed to be sRGB for the simplified API. *\/\n-      if (g == 0)\n-         return 0;\n-\n-      return png_gamma_significant((g * 11 + 2)\/5 \/* i.e. *2.2, rounded *\/);\n-   }\n+   \/* 1.6.47: use the same sanity checks as used in pngrtran.c *\/\n+   if (g < PNG_LIB_GAMMA_MIN || g > PNG_LIB_GAMMA_MAX)\n+      return 0; \/* Includes the uninitialized value 0 *\/\n@@ -1433,1 +1264,1 @@\n-   return 1;\n+   return png_gamma_significant((g * 11 + 2)\/5 \/* i.e. *2.2, rounded *\/);\n@@ -1440,0 +1271,27 @@\n+static int\n+png_image_is_not_sRGB(png_const_structrp png_ptr)\n+{\n+   \/* Does the colorspace **not** match sRGB?  The flag is only set if the\n+    * answer can be determined reliably.\n+    *\n+    * png_struct::chromaticities always exists since the simplified API\n+    * requires rgb-to-gray.  The mDCV, cICP and cHRM chunks may all set it to\n+    * a non-sRGB value, so it needs to be checked but **only** if one of\n+    * those chunks occured in the file.\n+    *\/\n+   \/* Highest priority: check to be safe. *\/\n+   if (png_has_chunk(png_ptr, cICP) || png_has_chunk(png_ptr, mDCV))\n+      return !chromaticities_match_sRGB(&png_ptr->chromaticities);\n+\n+   \/* If the image is marked as sRGB then it is... *\/\n+   if (png_has_chunk(png_ptr, sRGB))\n+      return 0;\n+\n+   \/* Last stop: cHRM, must check: *\/\n+   if (png_has_chunk(png_ptr, cHRM))\n+      return !chromaticities_match_sRGB(&png_ptr->chromaticities);\n+\n+   \/* Else default to sRGB *\/\n+   return 0;\n+}\n+\n@@ -1461,5 +1319,3 @@\n-#ifdef PNG_COLORSPACE_SUPPORTED\n-      \/* Does the colorspace match sRGB?  If there is no color endpoint\n-       * (colorant) information assume yes, otherwise require the\n-       * 'ENDPOINTS_MATCHP_sRGB' colorspace flag to have been set.  If the\n-       * colorspace has been determined to be invalid ignore it.\n+      \/* Greyscale images don't (typically) have colour space information and\n+       * using it is pretty much impossible, so use sRGB for grayscale (it\n+       * doesn't matter r==g==b so the transform is irrelevant.)\n@@ -1467,3 +1323,2 @@\n-      if ((format & PNG_FORMAT_FLAG_COLOR) != 0 && ((png_ptr->colorspace.flags\n-         & (PNG_COLORSPACE_HAVE_ENDPOINTS|PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB|\n-            PNG_COLORSPACE_INVALID)) == PNG_COLORSPACE_HAVE_ENDPOINTS))\n+      if ((format & PNG_FORMAT_FLAG_COLOR) != 0 &&\n+          png_image_is_not_sRGB(png_ptr))\n@@ -1471,1 +1326,0 @@\n-#endif\n@@ -1659,3 +1513,1 @@\n-    * too.  This allows the simplified API to be compiled without iCCP support,\n-    * however if the support is there the chunk is still checked to detect\n-    * errors (which are unfortunately quite common.)\n+    * too.  This allows the simplified API to be compiled without iCCP support.\n@@ -1667,0 +1519,1 @@\n+            99,  73,  67,  80, '\\0',  \/* cICP *\/\n@@ -1668,3 +1521,1 @@\n-#        ifdef PNG_READ_iCCP_SUPPORTED\n-           105,  67,  67,  80, '\\0',  \/* iCCP *\/\n-#        endif\n+           109,  68,  67,  86, '\\0',  \/* mDCV *\/\n@@ -1673,1 +1524,1 @@\n-           };\n+         };\n@@ -1702,1 +1553,9 @@\n-   png_fixed_point g = display->image->opaque->png_ptr->colorspace.gamma;\n+   png_structrp png_ptr = display->image->opaque->png_ptr;\n+   png_fixed_point g = png_resolve_file_gamma(png_ptr);\n+\n+   \/* PNGv3: the result may be 0 however the 'default_gamma' should have been\n+    * set before this is called so zero is an error:\n+    *\/\n+   if (g == 0)\n+      png_error(png_ptr, \"internal: default gamma not set\");\n+\n@@ -2190,1 +2049,5 @@\n-    * format.\n+    * format.  The 'default' gamma value is also set by png_set_alpha_mode, but\n+    * this is happening before any such call, so:\n+    *\n+    * TODO: should be an internal API and all this code should be copied into a\n+    * single common gamma+colorspace file.\n@@ -2192,13 +2055,3 @@\n-   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_GAMMA) == 0)\n-   {\n-      \/* Do this directly, not using the png_colorspace functions, to ensure\n-       * that it happens even if the colorspace is invalid (though probably if\n-       * it is the setting will be ignored)  Note that the same thing can be\n-       * achieved at the application interface with png_set_gAMA.\n-       *\/\n-      if (png_ptr->bit_depth == 16 &&\n-         (image->flags & PNG_IMAGE_FLAG_16BIT_sRGB) == 0)\n-         png_ptr->colorspace.gamma = PNG_GAMMA_LINEAR;\n-\n-      else\n-         png_ptr->colorspace.gamma = PNG_GAMMA_sRGB_INVERSE;\n+   if (png_ptr->bit_depth == 16 &&\n+      (image->flags & PNG_IMAGE_FLAG_16BIT_sRGB) == 0)\n+      png_ptr->default_gamma = PNG_GAMMA_LINEAR;\n@@ -2206,2 +2059,2 @@\n-      png_ptr->colorspace.flags |= PNG_COLORSPACE_HAVE_GAMMA;\n-   }\n+   else\n+      png_ptr->default_gamma = PNG_GAMMA_sRGB_INVERSE;\n@@ -2585,0 +2438,2 @@\n+               const png_fixed_point gamma = png_resolve_file_gamma(png_ptr);\n+\n@@ -2599,0 +2454,3 @@\n+                *\n+                * NOTE: PNGv3: check the resolved result of all the potentially\n+                * different colour space chunks.\n@@ -2602,1 +2460,1 @@\n-                  png_gamma_not_sRGB(png_ptr->colorspace.gamma) != 0)\n+                  png_gamma_not_sRGB(gamma) != 0)\n@@ -2634,2 +2492,2 @@\n-                     gray = PNG_DIV257(png_gamma_16bit_correct(gray,\n-                         png_ptr->colorspace.gamma)); \/* now P_FILE *\/\n+                     gray = PNG_DIV257(png_gamma_16bit_correct(gray, gamma));\n+                        \/* now P_FILE *\/\n@@ -3766,0 +3624,6 @@\n+         \/* This is safe but should no longer be necessary as\n+          * png_ptr->default_gamma should have been set after the\n+          * info-before-IDAT was read in png_image_read_header.\n+          *\n+          * TODO: 1.8: remove this and see what happens.\n+          *\/\n@@ -3821,2 +3685,3 @@\n-         if (png_muldiv(&gtest, output_gamma, png_ptr->colorspace.gamma,\n-             PNG_FP_1) != 0 && png_gamma_significant(gtest) == 0)\n+         if (png_muldiv(&gtest, output_gamma,\n+                  png_resolve_file_gamma(png_ptr), PNG_FP_1) != 0 &&\n+             png_gamma_significant(gtest) == 0)\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngread.c","additions":108,"deletions":243,"binary":false,"changes":351,"status":"modified"},{"patch":"@@ -250,0 +250,51 @@\n+\/* PNGv3 conformance: this private API exists to resolve the now mandatory error\n+ * resolution when multiple conflicting sources of gamma or colour space\n+ * information are available.\n+ *\n+ * Terminology (assuming power law, \"gamma\", encodings):\n+ *    \"screen\" gamma: a power law imposed by the output device when digital\n+ *    samples are converted to visible light output.  The EOTF - volage to\n+ *    luminance on output.\n+ *\n+ *    \"file\" gamma: a power law used to encode luminance levels from the input\n+ *    data (the scene or the mastering display system) into digital voltages.\n+ *    The OETF - luminance to voltage on input.\n+ *\n+ *    gamma \"correction\": a power law matching the **inverse** of the overall\n+ *    transfer function from input luminance levels to output levels.  The\n+ *    **inverse** of the OOTF; the correction \"corrects\" for the OOTF by aiming\n+ *    to make the overall OOTF (including the correction) linear.\n+ *\n+ * It is important to understand this terminology because the defined terms are\n+ * scattered throughout the libpng code and it is very easy to end up with the\n+ * inverse of the power law required.\n+ *\n+ * Variable and struct::member names:\n+ *    file_gamma        OETF  how the PNG data was encoded\n+ *\n+ *    screen_gamma      EOTF  how the screen will decode digital levels\n+ *\n+ *    -- not used --    OOTF  the net effect OETF x EOTF\n+ *    gamma_correction        the inverse of OOTF to make the result linear\n+ *\n+ * All versions of libpng require a call to \"png_set_gamma\" to establish the\n+ * \"screen\" gamma, the power law representing the EOTF.  png_set_gamma may also\n+ * set or default the \"file\" gamma; the OETF.  gamma_correction is calculated\n+ * internally.\n+ *\n+ * The earliest libpng versions required file_gamma to be supplied to set_gamma.\n+ * Later versions started allowing png_set_gamma and, later, png_set_alpha_mode,\n+ * to cause defaulting from the file data.\n+ *\n+ * PNGv3 mandated a particular form for this defaulting, one that is compatible\n+ * with what libpng did except that if libpng detected inconsistencies it marked\n+ * all the chunks as \"invalid\".  PNGv3 effectively invalidates this prior code.\n+ *\n+ * Behaviour implemented below:\n+ *    translate_gamma_flags(gamma, is_screen)\n+ *       The libpng-1.6 API for the gamma parameters to libpng APIs\n+ *       (png_set_gamma and png_set_alpha_mode at present).  This allows the\n+ *       'gamma' value to be passed as a png_fixed_point number or as one of a\n+ *       set of integral values for specific \"well known\" examples of transfer\n+ *       functions.  This is compatible with PNGv3.\n+ *\/\n@@ -251,2 +302,1 @@\n-translate_gamma_flags(png_structrp png_ptr, png_fixed_point output_gamma,\n-    int is_screen)\n+translate_gamma_flags(png_fixed_point output_gamma, int is_screen)\n@@ -262,8 +312,0 @@\n-      \/* If there is no sRGB support this just sets the gamma to the standard\n-       * sRGB value.  (This is a side effect of using this function!)\n-       *\/\n-#     ifdef PNG_READ_sRGB_SUPPORTED\n-         png_ptr->flags |= PNG_FLAG_ASSUME_sRGB;\n-#     else\n-         PNG_UNUSED(png_ptr)\n-#     endif\n@@ -311,0 +353,27 @@\n+\n+static int\n+unsupported_gamma(png_structrp png_ptr, png_fixed_point gamma, int warn)\n+{\n+   \/* Validate a gamma value to ensure it is in a reasonable range.  The value\n+    * is expected to be 1 or greater, but this range test allows for some\n+    * viewing correction values.  The intent is to weed out the API users\n+    * who might use the inverse of the gamma value accidentally!\n+    *\n+    * 1.6.47: apply the test in png_set_gamma as well but only warn and return\n+    * false if it fires.\n+    *\n+    * TODO: 1.8: make this an app_error in png_set_gamma as well.\n+    *\/\n+   if (gamma < PNG_LIB_GAMMA_MIN || gamma > PNG_LIB_GAMMA_MAX)\n+   {\n+#     define msg \"gamma out of supported range\"\n+      if (warn)\n+         png_app_warning(png_ptr, msg);\n+      else\n+         png_app_error(png_ptr, msg);\n+      return 1;\n+#     undef msg\n+   }\n+\n+   return 0;\n+}\n@@ -318,1 +387,0 @@\n-   int compose = 0;\n@@ -320,0 +388,1 @@\n+   int compose = 0;\n@@ -326,12 +395,3 @@\n-   output_gamma = translate_gamma_flags(png_ptr, output_gamma, 1\/*screen*\/);\n-\n-   \/* Validate the value to ensure it is in a reasonable range.  The value\n-    * is expected to be 1 or greater, but this range test allows for some\n-    * viewing correction values.  The intent is to weed out the API users\n-    * who might use the inverse of the gamma value accidentally!\n-    *\n-    * In libpng 1.6.0, we changed from 0.07..3 to 0.01..100, to accommodate\n-    * the optimal 16-bit gamma of 36 and its reciprocal.\n-    *\/\n-   if (output_gamma < 1000 || output_gamma > 10000000)\n-      png_error(png_ptr, \"output gamma out of expected range\");\n+   output_gamma = translate_gamma_flags(output_gamma, 1\/*screen*\/);\n+   if (unsupported_gamma(png_ptr, output_gamma, 0\/*error*\/))\n+      return;\n@@ -340,1 +400,3 @@\n-    * gamma may be changed below so get the file value first:\n+    * gamma may be changed below so get the file value first.  The default_gamma\n+    * is set here and from the simplified API (which uses a different algorithm)\n+    * so don't overwrite a set value:\n@@ -342,1 +404,6 @@\n-   file_gamma = png_reciprocal(output_gamma);\n+   file_gamma = png_ptr->default_gamma;\n+   if (file_gamma == 0)\n+   {\n+      file_gamma = png_reciprocal(output_gamma);\n+      png_ptr->default_gamma = file_gamma;\n+   }\n@@ -393,11 +460,1 @@\n-   \/* Only set the default gamma if the file gamma has not been set (this has\n-    * the side effect that the gamma in a second call to png_set_alpha_mode will\n-    * be ignored.)\n-    *\/\n-   if (png_ptr->colorspace.gamma == 0)\n-   {\n-      png_ptr->colorspace.gamma = file_gamma;\n-      png_ptr->colorspace.flags |= PNG_COLORSPACE_HAVE_GAMMA;\n-   }\n-\n-   \/* But always set the output gamma: *\/\n+   \/* Set the screen gamma values: *\/\n@@ -413,1 +470,1 @@\n-      png_ptr->background_gamma = png_ptr->colorspace.gamma; \/* just in case *\/\n+      png_ptr->background_gamma = file_gamma; \/* just in case *\/\n@@ -851,2 +908,2 @@\n-   scrn_gamma = translate_gamma_flags(png_ptr, scrn_gamma, 1\/*screen*\/);\n-   file_gamma = translate_gamma_flags(png_ptr, file_gamma, 0\/*file*\/);\n+   scrn_gamma = translate_gamma_flags(scrn_gamma, 1\/*screen*\/);\n+   file_gamma = translate_gamma_flags(file_gamma, 0\/*file*\/);\n@@ -866,2 +923,1 @@\n-      png_error(png_ptr, \"invalid file gamma in png_set_gamma\");\n-\n+      png_app_error(png_ptr, \"invalid file gamma in png_set_gamma\");\n@@ -869,1 +925,5 @@\n-      png_error(png_ptr, \"invalid screen gamma in png_set_gamma\");\n+      png_app_error(png_ptr, \"invalid screen gamma in png_set_gamma\");\n+\n+   if (unsupported_gamma(png_ptr, file_gamma, 1\/*warn*\/) ||\n+       unsupported_gamma(png_ptr, scrn_gamma, 1\/*warn*\/))\n+      return;\n@@ -871,3 +931,3 @@\n-   \/* Set the gamma values unconditionally - this overrides the value in the PNG\n-    * file if a gAMA chunk was present.  png_set_alpha_mode provides a\n-    * different, easier, way to default the file gamma.\n+   \/* 1.6.47: png_struct::file_gamma and png_struct::screen_gamma are now only\n+    * written by this API.  This removes dependencies on the order of API calls\n+    * and allows the complex gamma checks to be delayed until needed.\n@@ -875,2 +935,1 @@\n-   png_ptr->colorspace.gamma = file_gamma;\n-   png_ptr->colorspace.flags |= PNG_COLORSPACE_HAVE_GAMMA;\n+   png_ptr->file_gamma = file_gamma;\n@@ -1054,20 +1113,3 @@\n-      else\n-      {\n-         if (red >= 0 && green >= 0)\n-            png_app_warning(png_ptr,\n-                \"ignoring out of range rgb_to_gray coefficients\");\n-\n-         \/* Use the defaults, from the cHRM chunk if set, else the historical\n-          * values which are close to the sRGB\/HDTV\/ITU-Rec 709 values.  See\n-          * png_do_rgb_to_gray for more discussion of the values.  In this case\n-          * the coefficients are not marked as 'set' and are not overwritten if\n-          * something has already provided a default.\n-          *\/\n-         if (png_ptr->rgb_to_gray_red_coeff == 0 &&\n-             png_ptr->rgb_to_gray_green_coeff == 0)\n-         {\n-            png_ptr->rgb_to_gray_red_coeff   = 6968;\n-            png_ptr->rgb_to_gray_green_coeff = 23434;\n-            \/* png_ptr->rgb_to_gray_blue_coeff  = 2366; *\/\n-         }\n-      }\n+      else if (red >= 0 && green >= 0)\n+         png_app_warning(png_ptr,\n+               \"ignoring out of range rgb_to_gray coefficients\");\n@@ -1314,0 +1356,74 @@\n+#ifdef PNG_READ_GAMMA_SUPPORTED\n+png_fixed_point \/* PRIVATE *\/\n+png_resolve_file_gamma(png_const_structrp png_ptr)\n+{\n+   png_fixed_point file_gamma;\n+\n+   \/* The file gamma is determined by these precedence rules, in this order\n+    * (i.e. use the first value found):\n+    *\n+    *    png_set_gamma; png_struct::file_gammma if not zero, then:\n+    *    png_struct::chunk_gamma if not 0 (determined the PNGv3 rules), then:\n+    *    png_set_gamma; 1\/png_struct::screen_gamma if not zero\n+    *\n+    *    0 (i.e. do no gamma handling)\n+    *\/\n+   file_gamma = png_ptr->file_gamma;\n+   if (file_gamma != 0)\n+      return file_gamma;\n+\n+   file_gamma = png_ptr->chunk_gamma;\n+   if (file_gamma != 0)\n+      return file_gamma;\n+\n+   file_gamma = png_ptr->default_gamma;\n+   if (file_gamma != 0)\n+      return file_gamma;\n+\n+   \/* If png_reciprocal oveflows it returns 0 which indicates to the caller that\n+    * there is no usable file gamma.  (The checks added to png_set_gamma and\n+    * png_set_alpha_mode should prevent a screen_gamma which would overflow.)\n+    *\/\n+   if (png_ptr->screen_gamma != 0)\n+      file_gamma = png_reciprocal(png_ptr->screen_gamma);\n+\n+   return file_gamma;\n+}\n+\n+static int\n+png_init_gamma_values(png_structrp png_ptr)\n+{\n+   \/* The following temporary indicates if overall gamma correction is\n+    * required.\n+    *\/\n+   int gamma_correction = 0;\n+   png_fixed_point file_gamma, screen_gamma;\n+\n+   \/* Resolve the file_gamma.  See above: if png_ptr::screen_gamma is set\n+    * file_gamma will always be set here:\n+    *\/\n+   file_gamma = png_resolve_file_gamma(png_ptr);\n+   screen_gamma = png_ptr->screen_gamma;\n+\n+   if (file_gamma > 0) \/* file has been set *\/\n+   {\n+      if (screen_gamma > 0) \/* screen set too *\/\n+         gamma_correction = png_gamma_threshold(file_gamma, screen_gamma);\n+\n+      else\n+         \/* Assume the output matches the input; a long time default behavior\n+          * of libpng, although the standard has nothing to say about this.\n+          *\/\n+         screen_gamma = png_reciprocal(file_gamma);\n+   }\n+\n+   else \/* both unset, prevent corrections: *\/\n+      file_gamma = screen_gamma = PNG_FP_1;\n+\n+   png_ptr->file_gamma = file_gamma;\n+   png_ptr->screen_gamma = screen_gamma;\n+   return gamma_correction;\n+\n+}\n+#endif \/* READ_GAMMA *\/\n+\n@@ -1333,0 +1449,10 @@\n+    *\n+    * PNGv3: the new mandatory precedence\/priority rules for colour space chunks\n+    * are handled here (by calling the above function).\n+    *\n+    * Turn the gamma transformation on or off as appropriate.  Notice that\n+    * PNG_GAMMA just refers to the file->screen correction.  Alpha composition\n+    * may independently cause gamma correction because it needs linear data\n+    * (e.g. if the file has a gAMA chunk but the screen gamma hasn't been\n+    * specified.)  In any case this flag may get turned off in the code\n+    * immediately below if the transform can be handled outside the row loop.\n@@ -1334,5 +1460,2 @@\n-   {\n-      \/* The following temporary indicates if overall gamma correction is\n-       * required.\n-       *\/\n-      int gamma_correction = 0;\n+   if (png_init_gamma_values(png_ptr) != 0)\n+      png_ptr->transformations |= PNG_GAMMA;\n@@ -1340,46 +1463,2 @@\n-      if (png_ptr->colorspace.gamma != 0) \/* has been set *\/\n-      {\n-         if (png_ptr->screen_gamma != 0) \/* screen set too *\/\n-            gamma_correction = png_gamma_threshold(png_ptr->colorspace.gamma,\n-                png_ptr->screen_gamma);\n-\n-         else\n-            \/* Assume the output matches the input; a long time default behavior\n-             * of libpng, although the standard has nothing to say about this.\n-             *\/\n-            png_ptr->screen_gamma = png_reciprocal(png_ptr->colorspace.gamma);\n-      }\n-\n-      else if (png_ptr->screen_gamma != 0)\n-         \/* The converse - assume the file matches the screen, note that this\n-          * perhaps undesirable default can (from 1.5.4) be changed by calling\n-          * png_set_alpha_mode (even if the alpha handling mode isn't required\n-          * or isn't changed from the default.)\n-          *\/\n-         png_ptr->colorspace.gamma = png_reciprocal(png_ptr->screen_gamma);\n-\n-      else \/* neither are set *\/\n-         \/* Just in case the following prevents any processing - file and screen\n-          * are both assumed to be linear and there is no way to introduce a\n-          * third gamma value other than png_set_background with 'UNIQUE', and,\n-          * prior to 1.5.4\n-          *\/\n-         png_ptr->screen_gamma = png_ptr->colorspace.gamma = PNG_FP_1;\n-\n-      \/* We have a gamma value now. *\/\n-      png_ptr->colorspace.flags |= PNG_COLORSPACE_HAVE_GAMMA;\n-\n-      \/* Now turn the gamma transformation on or off as appropriate.  Notice\n-       * that PNG_GAMMA just refers to the file->screen correction.  Alpha\n-       * composition may independently cause gamma correction because it needs\n-       * linear data (e.g. if the file has a gAMA chunk but the screen gamma\n-       * hasn't been specified.)  In any case this flag may get turned off in\n-       * the code immediately below if the transform can be handled outside the\n-       * row loop.\n-       *\/\n-      if (gamma_correction != 0)\n-         png_ptr->transformations |= PNG_GAMMA;\n-\n-      else\n-         png_ptr->transformations &= ~PNG_GAMMA;\n-   }\n+   else\n+      png_ptr->transformations &= ~PNG_GAMMA;\n@@ -1457,1 +1536,1 @@\n-      png_colorspace_set_rgb_coefficients(png_ptr);\n+      png_set_rgb_coefficients(png_ptr);\n@@ -1600,1 +1679,1 @@\n-        (png_gamma_significant(png_ptr->colorspace.gamma) != 0 ||\n+        (png_gamma_significant(png_ptr->file_gamma) != 0 ||\n@@ -1603,1 +1682,1 @@\n-         (png_gamma_significant(png_ptr->colorspace.gamma) != 0 ||\n+         (png_gamma_significant(png_ptr->file_gamma) != 0 ||\n@@ -1659,2 +1738,2 @@\n-                     g = png_reciprocal(png_ptr->colorspace.gamma);\n-                     gs = png_reciprocal2(png_ptr->colorspace.gamma,\n+                     g = png_reciprocal(png_ptr->file_gamma);\n+                     gs = png_reciprocal2(png_ptr->file_gamma,\n@@ -1768,2 +1847,2 @@\n-                  g = png_reciprocal(png_ptr->colorspace.gamma);\n-                  gs = png_reciprocal2(png_ptr->colorspace.gamma,\n+                  g = png_reciprocal(png_ptr->file_gamma);\n+                  gs = png_reciprocal2(png_ptr->file_gamma,\n@@ -2019,3 +2098,3 @@\n-    * TODO: this looks wrong; the info_ptr should end up with a gamma equal to\n-    * the screen_gamma value.  The following probably results in weirdness if\n-    * the info_ptr is used by the app after the rows have been read.\n+    * TODO: this is confusing.  It only changes the result of png_get_gAMA and,\n+    * yes, it does return the value that the transformed data effectively has\n+    * but does any app really understand this?\n@@ -2023,1 +2102,1 @@\n-   info_ptr->colorspace.gamma = png_ptr->colorspace.gamma;\n+   info_ptr->gamma = png_ptr->file_gamma;\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngrtran.c","additions":208,"deletions":129,"binary":false,"changes":337,"status":"modified"},{"patch":"@@ -49,0 +49,20 @@\n+\/* The minimum 'zlib' stream is assumed to be just the 2 byte header, 5 bytes\n+ * minimum 'deflate' stream, and the 4 byte checksum.\n+ *\/\n+#define LZ77Min  (2U+5U+4U)\n+\n+#ifdef PNG_READ_INTERLACING_SUPPORTED\n+\/* Arrays to facilitate interlacing - use pass (0 - 6) as index. *\/\n+\n+\/* Start of interlace block *\/\n+static const png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};\n+\/* Offset to next interlace block *\/\n+static const png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n+\/* Start of interlace block in the y direction *\/\n+static const png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};\n+\/* Offset to next interlace block in the y direction *\/\n+static const png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};\n+\n+\/* TODO: Move these arrays to a common utility module to avoid duplication. *\/\n+#endif\n+\n@@ -60,24 +80,0 @@\n-#if defined(PNG_READ_gAMA_SUPPORTED) || defined(PNG_READ_cHRM_SUPPORTED)\n-\/* The following is a variation on the above for use with the fixed\n- * point values used for gAMA and cHRM.  Instead of png_error it\n- * issues a warning and returns (-1) - an invalid value because both\n- * gAMA and cHRM use *unsigned* integers for fixed point values.\n- *\/\n-#define PNG_FIXED_ERROR (-1)\n-\n-static png_fixed_point \/* PRIVATE *\/\n-png_get_fixed_point(png_structrp png_ptr, png_const_bytep buf)\n-{\n-   png_uint_32 uval = png_get_uint_32(buf);\n-\n-   if (uval <= PNG_UINT_31_MAX)\n-      return (png_fixed_point)uval; \/* known to be in range *\/\n-\n-   \/* The caller can turn off the warning by passing NULL. *\/\n-   if (png_ptr != NULL)\n-      png_warning(png_ptr, \"PNG fixed point integer out of range\");\n-\n-   return PNG_FIXED_ERROR;\n-}\n-#endif\n-\n@@ -180,0 +176,32 @@\n+\/* This function is called to verify that a chunk name is valid.\n+ * Do this using the bit-whacking approach from contrib\/tools\/pngfix.c\n+ *\n+ * Copied from libpng 1.7.\n+ *\/\n+static int\n+check_chunk_name(png_uint_32 name)\n+{\n+   png_uint_32 t;\n+\n+   \/* Remove bit 5 from all but the reserved byte; this means\n+    * every 8-bit unit must be in the range 65-90 to be valid.\n+    * So bit 5 must be zero, bit 6 must be set and bit 7 zero.\n+    *\/\n+   name &= ~PNG_U32(32,32,0,32);\n+   t = (name & ~0x1f1f1f1fU) ^ 0x40404040U;\n+\n+   \/* Subtract 65 for each 8-bit quantity, this must not\n+    * overflow and each byte must then be in the range 0-25.\n+    *\/\n+   name -= PNG_U32(65,65,65,65);\n+   t |= name;\n+\n+   \/* Subtract 26, handling the overflow which should set the\n+    * top three bits of each byte.\n+    *\/\n+   name -= PNG_U32(25,25,25,26);\n+   t |= ~name;\n+\n+   return (t & 0xe0e0e0e0U) == 0U;\n+}\n+\n@@ -187,1 +215,1 @@\n-   png_uint_32 length;\n+   png_uint_32 chunk_name, length;\n@@ -193,2 +221,3 @@\n-   \/* Read the length and the chunk name.\n-    * This must be performed in a single I\/O call.\n+   \/* Read the length and the chunk name.  png_struct::chunk_name is immediately\n+    * updated even if they are detectably wrong.  This aids error message\n+    * handling by allowing png_chunk_error to be used.\n@@ -198,0 +227,1 @@\n+   png_ptr->chunk_name = chunk_name = PNG_CHUNK_FROM_STRING(buf+4);\n@@ -199,2 +229,3 @@\n-   \/* Put the chunk name into png_ptr->chunk_name. *\/\n-   png_ptr->chunk_name = PNG_CHUNK_FROM_STRING(buf+4);\n+   \/* Reset the crc and run it over the chunk name. *\/\n+   png_reset_crc(png_ptr);\n+   png_calculate_crc(png_ptr, buf + 4, 4);\n@@ -205,3 +236,5 @@\n-   \/* Reset the crc and run it over the chunk name. *\/\n-   png_reset_crc(png_ptr);\n-   png_calculate_crc(png_ptr, buf + 4, 4);\n+   \/* Sanity check the length (first by <= 0x80) and the chunk name.  An error\n+    * here indicates a broken stream and libpng has no recovery from this.\n+    *\/\n+   if (buf[0] >= 0x80U)\n+      png_chunk_error(png_ptr, \"bad header (invalid length)\");\n@@ -210,4 +243,2 @@\n-   png_check_chunk_name(png_ptr, png_ptr->chunk_name);\n-\n-   \/* Check for too-large chunk length *\/\n-   png_check_chunk_length(png_ptr, length);\n+   if (!check_chunk_name(chunk_name))\n+      png_chunk_error(png_ptr, \"bad header (invalid type)\");\n@@ -233,0 +264,66 @@\n+\/* Compare the CRC stored in the PNG file with that calculated by libpng from\n+ * the data it has read thus far.\n+ *\/\n+static int\n+png_crc_error(png_structrp png_ptr, int handle_as_ancillary)\n+{\n+   png_byte crc_bytes[4];\n+   png_uint_32 crc;\n+   int need_crc = 1;\n+\n+   \/* There are four flags two for ancillary and two for critical chunks.  The\n+    * default setting of these flags is all zero.\n+    *\n+    * PNG_FLAG_CRC_ANCILLARY_USE\n+    * PNG_FLAG_CRC_ANCILLARY_NOWARN\n+    *  USE+NOWARN: no CRC calculation (implemented here), else;\n+    *  NOWARN:     png_chunk_error on error (implemented in png_crc_finish)\n+    *  else:       png_chunk_warning on error (implemented in png_crc_finish)\n+    *              This is the default.\n+    *\n+    *    I.e. NOWARN without USE produces png_chunk_error.  The default setting\n+    *    where neither are set does the same thing.\n+    *\n+    * PNG_FLAG_CRC_CRITICAL_USE\n+    * PNG_FLAG_CRC_CRITICAL_IGNORE\n+    *  IGNORE: no CRC calculation (implemented here), else;\n+    *  USE:    png_chunk_warning on error (implemented in png_crc_finish)\n+    *  else:   png_chunk_error on error (implemented in png_crc_finish)\n+    *          This is the default.\n+    *\n+    * This arose because of original mis-implementation and has persisted for\n+    * compatibility reasons.\n+    *\n+    * TODO: the flag names are internal so maybe this can be changed to\n+    * something comprehensible.\n+    *\/\n+   if (handle_as_ancillary || PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0)\n+   {\n+      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==\n+          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))\n+         need_crc = 0;\n+   }\n+\n+   else \/* critical *\/\n+   {\n+      if ((png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE) != 0)\n+         need_crc = 0;\n+   }\n+\n+#ifdef PNG_IO_STATE_SUPPORTED\n+   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_CRC;\n+#endif\n+\n+   \/* The chunk CRC must be serialized in a single I\/O call. *\/\n+   png_read_data(png_ptr, crc_bytes, 4);\n+\n+   if (need_crc != 0)\n+   {\n+      crc = png_get_uint_32(crc_bytes);\n+      return crc != png_ptr->crc;\n+   }\n+\n+   else\n+      return 0;\n+}\n+\n@@ -237,0 +334,5 @@\n+ *\n+ * There is one public version which is used in most places and another which\n+ * takes the value for the 'critical' flag to check.  This allows PLTE and IEND\n+ * handling code to ignore the CRC error and removes some confusing code\n+ * duplication.\n@@ -238,2 +340,3 @@\n-int \/* PRIVATE *\/\n-png_crc_finish(png_structrp png_ptr, png_uint_32 skip)\n+static int\n+png_crc_finish_critical(png_structrp png_ptr, png_uint_32 skip,\n+      int handle_as_ancillary)\n@@ -257,1 +360,12 @@\n-   if (png_crc_error(png_ptr) != 0)\n+   \/* If 'handle_as_ancillary' has been requested and this is a critical chunk\n+    * but PNG_FLAG_CRC_CRITICAL_IGNORE was set then png_read_crc did not, in\n+    * fact, calculate the CRC so the ANCILLARY settings should not be used\n+    * instead.\n+    *\/\n+   if (handle_as_ancillary &&\n+       (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE) != 0)\n+      handle_as_ancillary = 0;\n+\n+   \/* TODO: this might be more comprehensible if png_crc_error was inlined here.\n+    *\/\n+   if (png_crc_error(png_ptr, handle_as_ancillary) != 0)\n@@ -259,1 +373,2 @@\n-      if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0 ?\n+      \/* See above for the explanation of how the flags work. *\/\n+      if (handle_as_ancillary || PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0 ?\n@@ -262,1 +377,0 @@\n-      {\n@@ -264,1 +378,0 @@\n-      }\n@@ -275,3 +388,0 @@\n-\/* Compare the CRC stored in the PNG file with that calculated by libpng from\n- * the data it has read thus far.\n- *\/\n@@ -279,1 +389,1 @@\n-png_crc_error(png_structrp png_ptr)\n+png_crc_finish(png_structrp png_ptr, png_uint_32 skip)\n@@ -281,32 +391,1 @@\n-   png_byte crc_bytes[4];\n-   png_uint_32 crc;\n-   int need_crc = 1;\n-\n-   if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0)\n-   {\n-      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==\n-          (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))\n-         need_crc = 0;\n-   }\n-\n-   else \/* critical *\/\n-   {\n-      if ((png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE) != 0)\n-         need_crc = 0;\n-   }\n-\n-#ifdef PNG_IO_STATE_SUPPORTED\n-   png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_CRC;\n-#endif\n-\n-   \/* The chunk CRC must be serialized in a single I\/O call. *\/\n-   png_read_data(png_ptr, crc_bytes, 4);\n-\n-   if (need_crc != 0)\n-   {\n-      crc = png_get_uint_32(crc_bytes);\n-      return crc != png_ptr->crc;\n-   }\n-\n-   else\n-      return 0;\n+   return png_crc_finish_critical(png_ptr, skip, 0\/*critical handling*\/);\n@@ -318,1 +397,2 @@\n-    defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_SEQUENTIAL_READ_SUPPORTED)\n+    defined(PNG_READ_zTXt_SUPPORTED) || defined(PNG_READ_eXIf_SUPPORTED) ||\\\n+    defined(PNG_SEQUENTIAL_READ_SUPPORTED)\n@@ -322,2 +402,1 @@\n- * it will call png_error (via png_malloc) on failure.  (warn == 2 means\n- * 'silent').\n+ * it will call png_error on failure.\n@@ -326,1 +405,1 @@\n-png_read_buffer(png_structrp png_ptr, png_alloc_size_t new_size, int warn)\n+png_read_buffer(png_structrp png_ptr, png_alloc_size_t new_size)\n@@ -330,0 +409,2 @@\n+   if (new_size > png_chunk_max(png_ptr)) return NULL;\n+\n@@ -344,1 +425,3 @@\n-         memset(buffer, 0, new_size); \/* just in case *\/\n+#        ifndef PNG_NO_MEMZERO \/* for detecting UIM bugs **only** *\/\n+            memset(buffer, 0, new_size); \/* just in case *\/\n+#        endif\n@@ -348,9 +431,0 @@\n-\n-      else if (warn < 2) \/* else silent *\/\n-      {\n-         if (warn != 0)\n-             png_chunk_warning(png_ptr, \"insufficient memory to read chunk\");\n-\n-         else\n-             png_chunk_error(png_ptr, \"insufficient memory to read chunk\");\n-      }\n@@ -361,1 +435,1 @@\n-#endif \/* READ_iCCP|iTXt|pCAL|sCAL|sPLT|tEXt|zTXt|SEQUENTIAL_READ *\/\n+#endif \/* READ_iCCP|iTXt|pCAL|sCAL|sPLT|tEXt|zTXt|eXIf|SEQUENTIAL_READ *\/\n@@ -648,10 +722,1 @@\n-   png_alloc_size_t limit = PNG_SIZE_MAX;\n-\n-# ifdef PNG_SET_USER_LIMITS_SUPPORTED\n-   if (png_ptr->user_chunk_malloc_max > 0 &&\n-       png_ptr->user_chunk_malloc_max < limit)\n-      limit = png_ptr->user_chunk_malloc_max;\n-# elif PNG_USER_CHUNK_MALLOC_MAX > 0\n-   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n-      limit = PNG_USER_CHUNK_MALLOC_MAX;\n-# endif\n+   png_alloc_size_t limit = png_chunk_max(png_ptr);\n@@ -862,0 +927,1 @@\n+\/* CHUNK HANDLING *\/\n@@ -863,2 +929,1 @@\n-\n-void \/* PRIVATE *\/\n+static png_handle_result_code\n@@ -874,6 +939,1 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) != 0)\n-      png_chunk_error(png_ptr, \"out of place\");\n-\n-   \/* Check the length *\/\n-   if (length != 13)\n-      png_chunk_error(png_ptr, \"invalid\");\n+   \/* Length and position are checked by the caller. *\/\n@@ -933,0 +993,4 @@\n+\n+   \/* Rely on png_set_IHDR to completely validate the data and call png_error if\n+    * it's wrong.\n+    *\/\n@@ -935,0 +999,3 @@\n+\n+   return handled_ok;\n+   PNG_UNUSED(length)\n@@ -938,1 +1005,5 @@\n-void \/* PRIVATE *\/\n+\/* TODO: there are several obvious errors in this code when handling\n+ * out-of-place chunks and there is much over-complexity caused by trying to\n+ * patch up the problems.\n+ *\/\n+static png_handle_result_code\n@@ -941,5 +1012,1 @@\n-   png_color palette[PNG_MAX_PALETTE_LENGTH];\n-   int max_palette_length, num, i;\n-#ifdef PNG_POINTER_INDEXING_SUPPORTED\n-   png_colorp pal_ptr;\n-#endif\n+   png_const_charp errmsg = NULL;\n@@ -949,7 +1016,4 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   \/* Moved to before the 'after IDAT' check below because otherwise duplicate\n-    * PLTE chunks are potentially ignored (the spec says there shall not be more\n-    * than one PLTE, the error is not treated as benign, so this check trumps\n-    * the requirement that PLTE appears before IDAT.)\n+   \/* 1.6.47: consistency.  This used to be especially treated as a critical\n+    * error even in an image which is not colour mapped, there isn't a good\n+    * justification for treating some errors here one way and others another so\n+    * everything uses the same logic.\n@@ -957,2 +1021,2 @@\n-   else if ((png_ptr->mode & PNG_HAVE_PLTE) != 0)\n-      png_chunk_error(png_ptr, \"duplicate\");\n+   if ((png_ptr->mode & PNG_HAVE_PLTE) != 0)\n+      errmsg = \"duplicate\";\n@@ -961,8 +1025,1 @@\n-   {\n-      \/* This is benign because the non-benign error happened before, when an\n-       * IDAT was encountered in a color-mapped image with no PLTE.\n-       *\/\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n+      errmsg = \"out of place\";\n@@ -970,1 +1027,2 @@\n-   png_ptr->mode |= PNG_HAVE_PLTE;\n+   else if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0)\n+      errmsg = \"ignored in grayscale PNG\";\n@@ -972,6 +1030,2 @@\n-   if ((png_ptr->color_type & PNG_COLOR_MASK_COLOR) == 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"ignored in grayscale PNG\");\n-      return;\n-   }\n+   else if (length > 3*PNG_MAX_PALETTE_LENGTH || (length % 3) != 0)\n+      errmsg = \"invalid\";\n@@ -979,7 +1033,14 @@\n-#ifndef PNG_READ_OPT_PLTE_SUPPORTED\n-   if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      return;\n-   }\n-#endif\n+   \/* This drops PLTE in favour of tRNS or bKGD because both of those chunks\n+    * can have an effect on the rendering of the image whereas PLTE only matters\n+    * in the case of an 8-bit display with a decoder which controls the palette.\n+    *\n+    * The alternative here is to ignore the error and store the palette anyway;\n+    * destroying the tRNS will definately cause problems.\n+    *\n+    * NOTE: the case of PNG_COLOR_TYPE_PALETTE need not be considered because\n+    * the png_handle_ routines for the three 'after PLTE' chunks tRNS, bKGD and\n+    * hIST all check for a preceding PLTE in these cases.\n+    *\/\n+   else if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE &&\n+            (png_has_chunk(png_ptr, tRNS) || png_has_chunk(png_ptr, bKGD)))\n+      errmsg = \"out of place\";\n@@ -987,1 +1048,1 @@\n-   if (length > 3*PNG_MAX_PALETTE_LENGTH || length % 3)\n+   else\n@@ -989,10 +1050,8 @@\n-      png_crc_finish(png_ptr, length);\n-\n-      if (png_ptr->color_type != PNG_COLOR_TYPE_PALETTE)\n-         png_chunk_benign_error(png_ptr, \"invalid\");\n-\n-      else\n-         png_chunk_error(png_ptr, \"invalid\");\n-\n-      return;\n-   }\n+      \/* If the palette has 256 or fewer entries but is too large for the bit\n+       * depth we don't issue an error to preserve the behavior of previous\n+       * libpng versions. We silently truncate the unused extra palette entries\n+       * here.\n+       *\/\n+      const unsigned max_palette_length =\n+         (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE) ?\n+            1U << png_ptr->bit_depth : PNG_MAX_PALETTE_LENGTH;\n@@ -1000,2 +1059,5 @@\n-   \/* The cast is safe because 'length' is less than 3*PNG_MAX_PALETTE_LENGTH *\/\n-   num = (int)length \/ 3;\n+      \/* The cast is safe because 'length' is less than\n+       * 3*PNG_MAX_PALETTE_LENGTH\n+       *\/\n+      const unsigned num = (length > 3U*max_palette_length) ?\n+         max_palette_length : (unsigned)length \/ 3U;\n@@ -1003,9 +1065,3 @@\n-   \/* If the palette has 256 or fewer entries but is too large for the bit\n-    * depth, we don't issue an error, to preserve the behavior of previous\n-    * libpng versions. We silently truncate the unused extra palette entries\n-    * here.\n-    *\/\n-   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n-      max_palette_length = (1 << png_ptr->bit_depth);\n-   else\n-      max_palette_length = PNG_MAX_PALETTE_LENGTH;\n+      unsigned i, j;\n+      png_byte buf[3*PNG_MAX_PALETTE_LENGTH];\n+      png_color palette[PNG_MAX_PALETTE_LENGTH];\n@@ -1013,2 +1069,5 @@\n-   if (num > max_palette_length)\n-      num = max_palette_length;\n+      \/* Read the chunk into the buffer then read to the end of the chunk. *\/\n+      png_crc_read(png_ptr, buf, num*3U);\n+      png_crc_finish_critical(png_ptr, length - 3U*num,\n+            \/* Handle as ancillary if PLTE is optional: *\/\n+            png_ptr->color_type != PNG_COLOR_TYPE_PALETTE);\n@@ -1016,4 +1075,6 @@\n-#ifdef PNG_POINTER_INDEXING_SUPPORTED\n-   for (i = 0, pal_ptr = palette; i < num; i++, pal_ptr++)\n-   {\n-      png_byte buf[3];\n+      for (i = 0U, j = 0U; i < num; i++)\n+      {\n+         palette[i].red = buf[j++];\n+         palette[i].green = buf[j++];\n+         palette[i].blue = buf[j++];\n+      }\n@@ -1021,9 +1082,2 @@\n-      png_crc_read(png_ptr, buf, 3);\n-      pal_ptr->red = buf[0];\n-      pal_ptr->green = buf[1];\n-      pal_ptr->blue = buf[2];\n-   }\n-#else\n-   for (i = 0; i < num; i++)\n-   {\n-      png_byte buf[3];\n+      \/* A valid PLTE chunk has been read *\/\n+      png_ptr->mode |= PNG_HAVE_PLTE;\n@@ -1031,5 +1085,15 @@\n-      png_crc_read(png_ptr, buf, 3);\n-      \/* Don't depend upon png_color being any order *\/\n-      palette[i].red = buf[0];\n-      palette[i].green = buf[1];\n-      palette[i].blue = buf[2];\n+      \/* TODO: png_set_PLTE has the side effect of setting png_ptr->palette to\n+       * its own copy of the palette.  This has the side effect that when\n+       * png_start_row is called (this happens after any call to\n+       * png_read_update_info) the info_ptr palette gets changed.  This is\n+       * extremely unexpected and confusing.\n+       *\n+       * REVIEW: there have been consistent bugs in the past about gamma and\n+       * similar transforms to colour mapped images being useless because the\n+       * modified palette cannot be accessed because of the above.\n+       *\n+       * CONSIDER: Fix this by not sharing the palette in this way.  But does\n+       * this completely fix the problem?\n+       *\/\n+      png_set_PLTE(png_ptr, info_ptr, palette, num);\n+      return handled_ok;\n@@ -1037,1 +1101,0 @@\n-#endif\n@@ -1039,6 +1102,1 @@\n-   \/* If we actually need the PLTE chunk (ie for a paletted image), we do\n-    * whatever the normal CRC configuration tells us.  However, if we\n-    * have an RGB image, the PLTE can be considered ancillary, so\n-    * we will act as though it is.\n-    *\/\n-#ifndef PNG_READ_OPT_PLTE_SUPPORTED\n+   \/* Here on error: errmsg is non NULL. *\/\n@@ -1046,1 +1104,0 @@\n-#endif\n@@ -1048,1 +1105,2 @@\n-      png_crc_finish(png_ptr, (png_uint_32) (length - (unsigned int)num * 3));\n+      png_crc_finish(png_ptr, length);\n+      png_chunk_error(png_ptr, errmsg);\n@@ -1051,2 +1109,1 @@\n-#ifndef PNG_READ_OPT_PLTE_SUPPORTED\n-   else if (png_crc_error(png_ptr) != 0)  \/* Only if we have a CRC error *\/\n+   else \/* not critical to this image *\/\n@@ -1054,21 +1111,2 @@\n-      \/* If we don't want to use the data from an ancillary chunk,\n-       * we have two options: an error abort, or a warning and we\n-       * ignore the data in this chunk (which should be OK, since\n-       * it's considered ancillary for a RGB or RGBA image).\n-       *\n-       * IMPLEMENTATION NOTE: this is only here because png_crc_finish uses the\n-       * chunk type to determine whether to check the ancillary or the critical\n-       * flags.\n-       *\/\n-      if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_USE) == 0)\n-      {\n-         if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) != 0)\n-            return;\n-\n-         else\n-            png_chunk_error(png_ptr, \"CRC error\");\n-      }\n-\n-      \/* Otherwise, we (optionally) emit a warning and use the chunk. *\/\n-      else if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) == 0)\n-         png_chunk_warning(png_ptr, \"CRC error\");\n+      png_crc_finish_critical(png_ptr, length, 1\/*handle as ancillary*\/);\n+      png_chunk_benign_error(png_ptr, errmsg);\n@@ -1076,1 +1114,0 @@\n-#endif\n@@ -1078,18 +1115,2 @@\n-   \/* TODO: png_set_PLTE has the side effect of setting png_ptr->palette to its\n-    * own copy of the palette.  This has the side effect that when png_start_row\n-    * is called (this happens after any call to png_read_update_info) the\n-    * info_ptr palette gets changed.  This is extremely unexpected and\n-    * confusing.\n-    *\n-    * Fix this by not sharing the palette in this way.\n-    *\/\n-   png_set_PLTE(png_ptr, info_ptr, palette, num);\n-\n-   \/* The three chunks, bKGD, hIST and tRNS *must* appear after PLTE and before\n-    * IDAT.  Prior to 1.6.0 this was not checked; instead the code merely\n-    * checked the apparent validity of a tRNS chunk inserted before PLTE on a\n-    * palette PNG.  1.6.0 attempts to rigorously follow the standard and\n-    * therefore does a benign error if the erroneous condition is detected *and*\n-    * cancels the tRNS if the benign error returns.  The alternative is to\n-    * amend the standard since it would be rather hypocritical of the standards\n-    * maintainers to ignore it.\n+   \/* Because PNG_UNUSED(errmsg) does not work if all the uses are compiled out\n+    * (this does happen).\n@@ -1097,26 +1118,1 @@\n-#ifdef PNG_READ_tRNS_SUPPORTED\n-   if (png_ptr->num_trans > 0 ||\n-       (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS) != 0))\n-   {\n-      \/* Cancel this because otherwise it would be used if the transforms\n-       * require it.  Don't cancel the 'valid' flag because this would prevent\n-       * detection of duplicate chunks.\n-       *\/\n-      png_ptr->num_trans = 0;\n-\n-      if (info_ptr != NULL)\n-         info_ptr->num_trans = 0;\n-\n-      png_chunk_benign_error(png_ptr, \"tRNS must be after\");\n-   }\n-#endif\n-\n-#ifdef PNG_READ_hIST_SUPPORTED\n-   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST) != 0)\n-      png_chunk_benign_error(png_ptr, \"hIST must be after\");\n-#endif\n-\n-#ifdef PNG_READ_bKGD_SUPPORTED\n-   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD) != 0)\n-      png_chunk_benign_error(png_ptr, \"bKGD must be after\");\n-#endif\n+   return errmsg != NULL ? handled_error : handled_error;\n@@ -1125,1 +1121,6 @@\n-void \/* PRIVATE *\/\n+\/* On read the IDAT chunk is always handled specially, even if marked for\n+ * unknown handling (this is allowed), so:\n+ *\/\n+#define png_handle_IDAT NULL\n+\n+static png_handle_result_code\n@@ -1130,4 +1131,0 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0 ||\n-       (png_ptr->mode & PNG_HAVE_IDAT) == 0)\n-      png_chunk_error(png_ptr, \"out of place\");\n-\n@@ -1136,2 +1133,0 @@\n-   png_crc_finish(png_ptr, length);\n-\n@@ -1141,0 +1136,3 @@\n+   png_crc_finish_critical(png_ptr, length, 1\/*handle as ancillary*\/);\n+\n+   return handled_ok;\n@@ -1145,1 +1143,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code\n@@ -1148,1 +1146,1 @@\n-   png_fixed_point igamma;\n+   png_uint_32 ugamma;\n@@ -1153,2 +1151,1 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n+   png_crc_read(png_ptr, buf, 4);\n@@ -1156,6 +1153,2 @@\n-   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n+   if (png_crc_finish(png_ptr, 0) != 0)\n+      return handled_error;\n@@ -1163,1 +1156,3 @@\n-   if (length != 4)\n+   ugamma = png_get_uint_32(buf);\n+\n+   if (ugamma > PNG_UINT_31_MAX)\n@@ -1165,1 +1160,0 @@\n-      png_crc_finish(png_ptr, length);\n@@ -1167,1 +1161,1 @@\n-      return;\n+      return handled_error;\n@@ -1170,4 +1164,1 @@\n-   png_crc_read(png_ptr, buf, 4);\n-\n-   if (png_crc_finish(png_ptr, 0) != 0)\n-      return;\n+   png_set_gAMA_fixed(png_ptr, info_ptr, (png_fixed_point)\/*SAFE*\/ugamma);\n@@ -1175,1 +1166,7 @@\n-   igamma = png_get_fixed_point(NULL, buf);\n+#ifdef PNG_READ_GAMMA_SUPPORTED\n+      \/* PNGv3: chunk precedence for gamma is cICP, [iCCP], sRGB, gAMA.  gAMA is\n+       * at the end of the chain so simply check for an unset value.\n+       *\/\n+      if (png_ptr->chunk_gamma == 0)\n+         png_ptr->chunk_gamma = (png_fixed_point)\/*SAFE*\/ugamma;\n+#endif \/*READ_GAMMA*\/\n@@ -1177,2 +1174,2 @@\n-   png_colorspace_set_gamma(png_ptr, &png_ptr->colorspace, igamma);\n-   png_colorspace_sync(png_ptr, info_ptr);\n+   return handled_ok;\n+   PNG_UNUSED(length)\n@@ -1180,0 +1177,2 @@\n+#else\n+#  define png_handle_gAMA NULL\n@@ -1183,1 +1182,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -1192,17 +1191,0 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-   if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sBIT) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n-\n@@ -1221,1 +1203,1 @@\n-   if (length != truelen || length > 4)\n+   if (length != truelen)\n@@ -1223,1 +1205,0 @@\n-      png_chunk_benign_error(png_ptr, \"invalid\");\n@@ -1225,1 +1206,2 @@\n-      return;\n+      png_chunk_benign_error(png_ptr, \"bad length\");\n+      return handled_error;\n@@ -1232,1 +1214,1 @@\n-      return;\n+      return handled_error;\n@@ -1239,1 +1221,1 @@\n-         return;\n+         return handled_error;\n@@ -1251,1 +1233,1 @@\n-   else\n+   else \/* grayscale *\/\n@@ -1261,0 +1243,1 @@\n+   return handled_ok;\n@@ -1262,0 +1245,2 @@\n+#else\n+#  define png_handle_sBIT NULL\n@@ -1265,2 +1250,2 @@\n-void \/* PRIVATE *\/\n-png_handle_cHRM(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n+static png_int_32\n+png_get_int_32_checked(png_const_bytep buf, int *error)\n@@ -1268,2 +1253,3 @@\n-   png_byte buf[32];\n-   png_xy xy;\n+   png_uint_32 uval = png_get_uint_32(buf);\n+   if ((uval & 0x80000000) == 0) \/* non-negative *\/\n+      return (png_int_32)uval;\n@@ -1271,1 +1257,3 @@\n-   png_debug(1, \"in png_handle_cHRM\");\n+   uval = (uval ^ 0xffffffff) + 1;  \/* 2's complement: -x = ~x+1 *\/\n+   if ((uval & 0x80000000) == 0) \/* no overflow *\/\n+      return -(png_int_32)uval;\n@@ -1273,2 +1261,6 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n+   \/* This version of png_get_int_32 has a way of returning the error to the\n+    * caller, so:\n+    *\/\n+   *error = 1;\n+   return 0; \/* Safe *\/\n+}\n@@ -1276,6 +1268,6 @@\n-   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n+static png_handle_result_code \/* PRIVATE *\/\n+png_handle_cHRM(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n+{\n+   int error = 0;\n+   png_xy xy;\n+   png_byte buf[32];\n@@ -1283,6 +1275,1 @@\n-   if (length != 32)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"invalid\");\n-      return;\n-   }\n+   png_debug(1, \"in png_handle_cHRM\");\n@@ -1293,1 +1280,1 @@\n-      return;\n+      return handled_error;\n@@ -1295,17 +1282,10 @@\n-   xy.whitex = png_get_fixed_point(NULL, buf);\n-   xy.whitey = png_get_fixed_point(NULL, buf + 4);\n-   xy.redx   = png_get_fixed_point(NULL, buf + 8);\n-   xy.redy   = png_get_fixed_point(NULL, buf + 12);\n-   xy.greenx = png_get_fixed_point(NULL, buf + 16);\n-   xy.greeny = png_get_fixed_point(NULL, buf + 20);\n-   xy.bluex  = png_get_fixed_point(NULL, buf + 24);\n-   xy.bluey  = png_get_fixed_point(NULL, buf + 28);\n-\n-   if (xy.whitex == PNG_FIXED_ERROR ||\n-       xy.whitey == PNG_FIXED_ERROR ||\n-       xy.redx   == PNG_FIXED_ERROR ||\n-       xy.redy   == PNG_FIXED_ERROR ||\n-       xy.greenx == PNG_FIXED_ERROR ||\n-       xy.greeny == PNG_FIXED_ERROR ||\n-       xy.bluex  == PNG_FIXED_ERROR ||\n-       xy.bluey  == PNG_FIXED_ERROR)\n+   xy.whitex = png_get_int_32_checked(buf +  0, &error);\n+   xy.whitey = png_get_int_32_checked(buf +  4, &error);\n+   xy.redx   = png_get_int_32_checked(buf +  8, &error);\n+   xy.redy   = png_get_int_32_checked(buf + 12, &error);\n+   xy.greenx = png_get_int_32_checked(buf + 16, &error);\n+   xy.greeny = png_get_int_32_checked(buf + 20, &error);\n+   xy.bluex  = png_get_int_32_checked(buf + 24, &error);\n+   xy.bluey  = png_get_int_32_checked(buf + 28, &error);\n+\n+   if (error)\n@@ -1313,2 +1293,2 @@\n-      png_chunk_benign_error(png_ptr, \"invalid values\");\n-      return;\n+      png_chunk_benign_error(png_ptr, \"invalid\");\n+      return handled_error;\n@@ -1317,3 +1297,6 @@\n-   \/* If a colorspace error has already been output skip this chunk *\/\n-   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) != 0)\n-      return;\n+   \/* png_set_cHRM may complain about some of the values but this doesn't matter\n+    * because it was a cHRM and it did have vaguely (if, perhaps, ridiculous)\n+    * values.  Ridiculousity will be checked if the values are used later.\n+    *\/\n+   png_set_cHRM_fixed(png_ptr, info_ptr, xy.whitex, xy.whitey, xy.redx, xy.redy,\n+         xy.greenx, xy.greeny, xy.bluex, xy.bluey);\n@@ -1321,7 +1304,10 @@\n-   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_FROM_cHRM) != 0)\n-   {\n-      png_ptr->colorspace.flags |= PNG_COLORSPACE_INVALID;\n-      png_colorspace_sync(png_ptr, info_ptr);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n+   \/* We only use 'chromaticities' for RGB to gray *\/\n+#  ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n+      \/* There is no need to check sRGB here, cICP is NYI and iCCP is not\n+       * supported so just check mDCV.\n+       *\/\n+      if (!png_has_chunk(png_ptr, mDCV))\n+      {\n+         png_ptr->chromaticities = xy;\n+      }\n+#  endif \/* READ_RGB_TO_GRAY *\/\n@@ -1329,4 +1315,2 @@\n-   png_ptr->colorspace.flags |= PNG_COLORSPACE_FROM_cHRM;\n-   (void)png_colorspace_set_chromaticities(png_ptr, &png_ptr->colorspace, &xy,\n-       1\/*prefer cHRM values*\/);\n-   png_colorspace_sync(png_ptr, info_ptr);\n+   return handled_ok;\n+   PNG_UNUSED(length)\n@@ -1334,0 +1318,2 @@\n+#else\n+#  define png_handle_cHRM NULL\n@@ -1337,1 +1323,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -1344,17 +1330,0 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-   if (length != 1)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"invalid\");\n-      return;\n-   }\n-\n@@ -1364,5 +1333,1 @@\n-      return;\n-\n-   \/* If a colorspace error has already been output skip this chunk *\/\n-   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) != 0)\n-      return;\n+      return handled_error;\n@@ -1370,2 +1335,4 @@\n-   \/* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect\n-    * this.\n+   \/* This checks the range of the \"rendering intent\" because it is specified in\n+    * the PNG spec itself; the \"reserved\" values will result in the chunk not\n+    * being accepted, just as they do with the various \"reserved\" values in\n+    * IHDR.\n@@ -1373,1 +1340,1 @@\n-   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_INTENT) != 0)\n+   if (intent > 3\/*PNGv3 spec*\/)\n@@ -1375,4 +1342,2 @@\n-      png_ptr->colorspace.flags |= PNG_COLORSPACE_INVALID;\n-      png_colorspace_sync(png_ptr, info_ptr);\n-      png_chunk_benign_error(png_ptr, \"too many profiles\");\n-      return;\n+      png_chunk_benign_error(png_ptr, \"invalid\");\n+      return handled_error;\n@@ -1381,2 +1346,16 @@\n-   (void)png_colorspace_set_sRGB(png_ptr, &png_ptr->colorspace, intent);\n-   png_colorspace_sync(png_ptr, info_ptr);\n+   png_set_sRGB(png_ptr, info_ptr, intent);\n+   \/* NOTE: png_struct::chromaticities is not set here because the RGB to gray\n+    * coefficients are known without a need for the chromaticities.\n+    *\/\n+\n+#ifdef PNG_READ_GAMMA_SUPPORTED\n+      \/* PNGv3: chunk precedence for gamma is cICP, [iCCP], sRGB, gAMA.  iCCP is\n+       * not supported by libpng so the only requirement is to check for cICP\n+       * setting the gamma (this is NYI, but this check is safe.)\n+       *\/\n+      if (!png_has_chunk(png_ptr, cICP) || png_ptr->chunk_gamma == 0)\n+         png_ptr->chunk_gamma = PNG_GAMMA_sRGB_INVERSE;\n+#endif \/*READ_GAMMA*\/\n+\n+   return handled_ok;\n+   PNG_UNUSED(length)\n@@ -1384,0 +1363,2 @@\n+#else\n+#  define png_handle_sRGB NULL\n@@ -1387,1 +1368,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -1396,19 +1377,3 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & (PNG_HAVE_IDAT|PNG_HAVE_PLTE)) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-   \/* Consistent with all the above colorspace handling an obviously *invalid*\n-    * chunk is just ignored, so does not invalidate the color space.  An\n-    * alternative is to set the 'invalid' flags at the start of this routine\n-    * and only clear them in they were not set before and all the tests pass.\n-    *\/\n-\n-   \/* The keyword must be at least one character and there is a\n-    * terminator (0) byte and the compression method byte, and the\n-    * 'zlib' datastream is at least 11 bytes.\n+   \/* PNGv3: allow PNG files with both sRGB and iCCP because the PNG spec only\n+    * ever said that there \"should\" be only one, not \"shall\" and the PNGv3\n+    * colour chunk precedence rules give a handling for this case anyway.\n@@ -1416,18 +1381,0 @@\n-   if (length < 14)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"too short\");\n-      return;\n-   }\n-\n-   \/* If a colorspace error has already been output skip this chunk *\/\n-   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_INVALID) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      return;\n-   }\n-\n-   \/* Only one sRGB or iCCP chunk is allowed, use the HAVE_INTENT flag to detect\n-    * this.\n-    *\/\n-   if ((png_ptr->colorspace.flags & PNG_COLORSPACE_HAVE_INTENT) == 0)\n@@ -1443,1 +1390,1 @@\n-         read_length = (uInt)length;\n+         read_length = (uInt)\/*SAFE*\/length;\n@@ -1448,4 +1395,1 @@\n-      \/* The minimum 'zlib' stream is assumed to be just the 2 byte header,\n-       * 5 bytes minimum 'deflate' stream, and the 4 byte checksum.\n-       *\/\n-      if (length < 11)\n+      if (length < LZ77Min)\n@@ -1455,1 +1399,1 @@\n-         return;\n+         return handled_error;\n@@ -1492,2 +1436,2 @@\n-                  if (png_icc_check_length(png_ptr, &png_ptr->colorspace,\n-                      keyword, profile_length) != 0)\n+                  if (png_icc_check_length(png_ptr, keyword, profile_length) !=\n+                      0)\n@@ -1498,3 +1442,2 @@\n-                     if (png_icc_check_header(png_ptr, &png_ptr->colorspace,\n-                         keyword, profile_length, profile_header,\n-                         png_ptr->color_type) != 0)\n+                     if (png_icc_check_header(png_ptr, keyword, profile_length,\n+                              profile_header, png_ptr->color_type) != 0)\n@@ -1510,1 +1453,1 @@\n-                            profile_length, 2\/*silent*\/);\n+                              profile_length);\n@@ -1529,2 +1472,1 @@\n-                                  &png_ptr->colorspace, keyword, profile_length,\n-                                  profile) != 0)\n+                                       keyword, profile_length, profile) != 0)\n@@ -1562,7 +1504,0 @@\n-# if defined(PNG_sRGB_SUPPORTED) && PNG_sRGB_PROFILE_CHECKS >= 0\n-                                    \/* Check for a match against sRGB *\/\n-                                    png_icc_set_sRGB(png_ptr,\n-                                        &png_ptr->colorspace, profile,\n-                                        png_ptr->zstream.adler);\n-# endif\n-\n@@ -1591,3 +1526,0 @@\n-                                       {\n-                                          png_ptr->colorspace.flags |=\n-                                             PNG_COLORSPACE_INVALID;\n@@ -1595,1 +1527,0 @@\n-                                       }\n@@ -1603,3 +1534,0 @@\n-                                    if (info_ptr != NULL)\n-                                       png_colorspace_sync(png_ptr, info_ptr);\n-\n@@ -1609,1 +1537,1 @@\n-                                       return;\n+                                       return handled_ok;\n@@ -1650,3 +1578,0 @@\n-   else\n-      errmsg = \"too many profiles\";\n-\n@@ -1657,2 +1582,0 @@\n-   png_ptr->colorspace.flags |= PNG_COLORSPACE_INVALID;\n-   png_colorspace_sync(png_ptr, info_ptr);\n@@ -1661,0 +1584,2 @@\n+\n+   return handled_error;\n@@ -1662,0 +1587,2 @@\n+#else\n+#  define png_handle_iCCP NULL\n@@ -1665,1 +1592,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -1686,1 +1613,1 @@\n-         return;\n+         return handled_error;\n@@ -1693,1 +1620,1 @@\n-         return;\n+         return handled_error;\n@@ -1698,20 +1625,1 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-#ifdef PNG_MAX_MALLOC_64K\n-   if (length > 65535U)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"too large to fit in memory\");\n-      return;\n-   }\n-#endif\n-\n-   buffer = png_read_buffer(png_ptr, length+1, 2\/*silent*\/);\n+   buffer = png_read_buffer(png_ptr, length+1);\n@@ -1722,1 +1630,1 @@\n-      return;\n+      return handled_error;\n@@ -1733,1 +1641,1 @@\n-      return;\n+      return handled_error;\n@@ -1746,1 +1654,1 @@\n-      return;\n+      return handled_error;\n@@ -1760,1 +1668,1 @@\n-      return;\n+      return handled_error;\n@@ -1769,1 +1677,1 @@\n-      return;\n+      return handled_error;\n@@ -1780,1 +1688,1 @@\n-      return;\n+      return handled_error;\n@@ -1783,1 +1691,0 @@\n-#ifdef PNG_POINTER_INDEXING_SUPPORTED\n@@ -1806,25 +1713,0 @@\n-#else\n-   pp = new_palette.entries;\n-\n-   for (i = 0; i < new_palette.nentries; i++)\n-   {\n-\n-      if (new_palette.depth == 8)\n-      {\n-         pp[i].red   = *entry_start++;\n-         pp[i].green = *entry_start++;\n-         pp[i].blue  = *entry_start++;\n-         pp[i].alpha = *entry_start++;\n-      }\n-\n-      else\n-      {\n-         pp[i].red   = png_get_uint_16(entry_start); entry_start += 2;\n-         pp[i].green = png_get_uint_16(entry_start); entry_start += 2;\n-         pp[i].blue  = png_get_uint_16(entry_start); entry_start += 2;\n-         pp[i].alpha = png_get_uint_16(entry_start); entry_start += 2;\n-      }\n-\n-      pp[i].frequency = png_get_uint_16(entry_start); entry_start += 2;\n-   }\n-#endif\n@@ -1838,0 +1720,1 @@\n+   return handled_ok;\n@@ -1839,0 +1722,2 @@\n+#else\n+#  define png_handle_sPLT NULL\n@@ -1842,1 +1727,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -1849,17 +1734,0 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tRNS) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n-\n@@ -1874,1 +1742,1 @@\n-         return;\n+         return handled_error;\n@@ -1890,1 +1758,1 @@\n-         return;\n+         return handled_error;\n@@ -1904,1 +1772,0 @@\n-         \/* TODO: is this actually an error in the ISO spec? *\/\n@@ -1907,1 +1774,1 @@\n-         return;\n+         return handled_error;\n@@ -1916,1 +1783,1 @@\n-         return;\n+         return handled_error;\n@@ -1927,1 +1794,1 @@\n-      return;\n+      return handled_error;\n@@ -1933,1 +1800,1 @@\n-      return;\n+      return handled_error;\n@@ -1942,0 +1809,1 @@\n+   return handled_ok;\n@@ -1943,0 +1811,2 @@\n+#else\n+#  define png_handle_tRNS NULL\n@@ -1946,1 +1816,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -1955,13 +1825,1 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0 ||\n-       (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE &&\n-       (png_ptr->mode & PNG_HAVE_PLTE) == 0))\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_bKGD) != 0)\n+   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n@@ -1969,4 +1827,6 @@\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n+      if ((png_ptr->mode & PNG_HAVE_PLTE) == 0)\n+      {\n+         png_crc_finish(png_ptr, length);\n+         png_chunk_benign_error(png_ptr, \"out of place\");\n+         return handled_error;\n+      }\n@@ -1974,1 +1834,0 @@\n-   if (png_ptr->color_type == PNG_COLOR_TYPE_PALETTE)\n@@ -1976,0 +1835,1 @@\n+   }\n@@ -1987,1 +1847,1 @@\n-      return;\n+      return handled_error;\n@@ -1993,1 +1853,1 @@\n-      return;\n+      return handled_error;\n@@ -2009,1 +1869,1 @@\n-            return;\n+            return handled_error;\n@@ -2030,1 +1890,1 @@\n-            return;\n+            return handled_error;\n@@ -2048,1 +1908,1 @@\n-            return;\n+            return handled_error;\n@@ -2060,0 +1920,1 @@\n+   return handled_ok;\n@@ -2061,0 +1922,2 @@\n+#else\n+#  define png_handle_bKGD NULL\n@@ -2063,3 +1926,3 @@\n-#ifdef PNG_READ_eXIf_SUPPORTED\n-void \/* PRIVATE *\/\n-png_handle_eXIf(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n+#ifdef PNG_READ_cICP_SUPPORTED\n+static png_handle_result_code \/* PRIVATE *\/\n+png_handle_cICP(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n@@ -2067,1 +1930,1 @@\n-   unsigned int i;\n+   png_byte buf[4];\n@@ -2069,1 +1932,1 @@\n-   png_debug(1, \"in png_handle_eXIf\");\n+   png_debug(1, \"in png_handle_cICP\");\n@@ -2071,2 +1934,1 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n+   png_crc_read(png_ptr, buf, 4);\n@@ -2074,6 +1936,2 @@\n-   if (length < 2)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"too short\");\n-      return;\n-   }\n+   if (png_crc_finish(png_ptr, 0) != 0)\n+      return handled_error;\n@@ -2081,6 +1939,1 @@\n-   else if (info_ptr == NULL || (info_ptr->valid & PNG_INFO_eXIf) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n+   png_set_cICP(png_ptr, info_ptr, buf[0], buf[1],  buf[2], buf[3]);\n@@ -2088,1 +1941,7 @@\n-   info_ptr->free_me |= PNG_FREE_EXIF;\n+   \/* We only use 'chromaticities' for RGB to gray *\/\n+#  ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n+      if (!png_has_chunk(png_ptr, mDCV))\n+      {\n+         \/* TODO: png_ptr->chromaticities = chromaticities; *\/\n+      }\n+#  endif \/* READ_RGB_TO_GRAY *\/\n@@ -2090,2 +1949,8 @@\n-   info_ptr->eXIf_buf = png_voidcast(png_bytep,\n-             png_malloc_warn(png_ptr, length));\n+#ifdef PNG_READ_GAMMA_SUPPORTED\n+      \/* PNGv3: chunk precedence for gamma is cICP, [iCCP], sRGB, gAMA.  cICP is\n+       * at the head so simply set the gamma if it can be determined.  If not\n+       * chunk_gamma remains unchanged; sRGB and gAMA handling check it for\n+       * being zero.\n+       *\/\n+      \/* TODO: set png_struct::chunk_gamma when possible *\/\n+#endif \/*READ_GAMMA*\/\n@@ -2093,1 +1958,95 @@\n-   if (info_ptr->eXIf_buf == NULL)\n+   return handled_ok;\n+   PNG_UNUSED(length)\n+}\n+#else\n+#  define png_handle_cICP NULL\n+#endif\n+\n+#ifdef PNG_READ_cLLI_SUPPORTED\n+static png_handle_result_code \/* PRIVATE *\/\n+png_handle_cLLI(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n+{\n+   png_byte buf[8];\n+\n+   png_debug(1, \"in png_handle_cLLI\");\n+\n+   png_crc_read(png_ptr, buf, 8);\n+\n+   if (png_crc_finish(png_ptr, 0) != 0)\n+      return handled_error;\n+\n+   \/* The error checking happens here, this puts it in just one place: *\/\n+   png_set_cLLI_fixed(png_ptr, info_ptr, png_get_uint_32(buf),\n+         png_get_uint_32(buf+4));\n+   return handled_ok;\n+   PNG_UNUSED(length)\n+}\n+#else\n+#  define png_handle_cLLI NULL\n+#endif\n+\n+#ifdef PNG_READ_mDCV_SUPPORTED\n+static png_handle_result_code \/* PRIVATE *\/\n+png_handle_mDCV(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n+{\n+   png_xy chromaticities;\n+   png_byte buf[24];\n+\n+   png_debug(1, \"in png_handle_mDCV\");\n+\n+   png_crc_read(png_ptr, buf, 24);\n+\n+   if (png_crc_finish(png_ptr, 0) != 0)\n+      return handled_error;\n+\n+   \/* The error checking happens here, this puts it in just one place.  The\n+    * odd \/50000 scaling factor makes it more difficult but the (x.y) values are\n+    * only two bytes so a <<1 is safe.\n+    *\n+    * WARNING: the PNG specification defines the cHRM chunk to **start** with\n+    * the white point (x,y).  The W3C PNG v3 specification puts the white point\n+    * **after* R,G,B.  The x,y values in mDCV are also scaled by 50,000 and\n+    * stored in just two bytes, whereas those in cHRM are scaled by 100,000 and\n+    * stored in four bytes.  This is very, very confusing.  These APIs remove\n+    * the confusion by copying the existing, well established, API.\n+    *\/\n+   chromaticities.redx   = png_get_uint_16(buf+ 0U) << 1; \/* red x *\/\n+   chromaticities.redy   = png_get_uint_16(buf+ 2U) << 1; \/* red y *\/\n+   chromaticities.greenx = png_get_uint_16(buf+ 4U) << 1; \/* green x *\/\n+   chromaticities.greeny = png_get_uint_16(buf+ 6U) << 1; \/* green y *\/\n+   chromaticities.bluex  = png_get_uint_16(buf+ 8U) << 1; \/* blue x *\/\n+   chromaticities.bluey  = png_get_uint_16(buf+10U) << 1; \/* blue y *\/\n+   chromaticities.whitex = png_get_uint_16(buf+12U) << 1; \/* white x *\/\n+   chromaticities.whitey = png_get_uint_16(buf+14U) << 1; \/* white y *\/\n+\n+   png_set_mDCV_fixed(png_ptr, info_ptr,\n+         chromaticities.whitex, chromaticities.whitey,\n+         chromaticities.redx, chromaticities.redy,\n+         chromaticities.greenx, chromaticities.greeny,\n+         chromaticities.bluex, chromaticities.bluey,\n+         png_get_uint_32(buf+16U), \/* peak luminance *\/\n+         png_get_uint_32(buf+20U));\/* minimum perceivable luminance *\/\n+\n+   \/* We only use 'chromaticities' for RGB to gray *\/\n+#  ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n+      png_ptr->chromaticities = chromaticities;\n+#  endif \/* READ_RGB_TO_GRAY *\/\n+\n+   return handled_ok;\n+   PNG_UNUSED(length)\n+}\n+#else\n+#  define png_handle_mDCV NULL\n+#endif\n+\n+#ifdef PNG_READ_eXIf_SUPPORTED\n+static png_handle_result_code \/* PRIVATE *\/\n+png_handle_eXIf(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n+{\n+   png_bytep buffer = NULL;\n+\n+   png_debug(1, \"in png_handle_eXIf\");\n+\n+   buffer = png_read_buffer(png_ptr, length);\n+\n+   if (buffer == NULL)\n@@ -2097,1 +2056,1 @@\n-      return;\n+      return handled_error;\n@@ -2100,1 +2059,9 @@\n-   for (i = 0; i < length; i++)\n+   png_crc_read(png_ptr, buffer, length);\n+\n+   if (png_crc_finish(png_ptr, 0) != 0)\n+      return handled_error;\n+\n+   \/* PNGv3: the code used to check the byte order mark at the start for MM or\n+    * II, however PNGv3 states that the the first 4 bytes should be checked.\n+    * The caller ensures that there are four bytes available.\n+    *\/\n@@ -2102,4 +2069,4 @@\n-      png_byte buf[1];\n-      png_crc_read(png_ptr, buf, 1);\n-      info_ptr->eXIf_buf[i] = buf[0];\n-      if (i == 1)\n+      png_uint_32 header = png_get_uint_32(buffer);\n+\n+      \/* These numbers are copied from the PNGv3 spec: *\/\n+      if (header != 0x49492A00 && header != 0x4D4D002A)\n@@ -2107,9 +2074,2 @@\n-         if ((buf[0] != 'M' && buf[0] != 'I') ||\n-             (info_ptr->eXIf_buf[0] != buf[0]))\n-         {\n-            png_crc_finish(png_ptr, length - 2);\n-            png_chunk_benign_error(png_ptr, \"incorrect byte-order specifier\");\n-            png_free(png_ptr, info_ptr->eXIf_buf);\n-            info_ptr->eXIf_buf = NULL;\n-            return;\n-         }\n+         png_chunk_benign_error(png_ptr, \"invalid\");\n+         return handled_error;\n@@ -2119,5 +2079,2 @@\n-   if (png_crc_finish(png_ptr, 0) == 0)\n-      png_set_eXIf_1(png_ptr, info_ptr, length, info_ptr->eXIf_buf);\n-\n-   png_free(png_ptr, info_ptr->eXIf_buf);\n-   info_ptr->eXIf_buf = NULL;\n+   png_set_eXIf_1(png_ptr, info_ptr, length, buffer);\n+   return handled_ok;\n@@ -2125,0 +2082,2 @@\n+#else\n+#  define png_handle_eXIf NULL\n@@ -2128,1 +2087,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -2136,19 +2095,7 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0 ||\n-       (png_ptr->mode & PNG_HAVE_PLTE) == 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n-\n-   num = length \/ 2 ;\n+   \/* This cast is safe because the chunk definition limits the length to a\n+    * maximum of 1024 bytes.\n+    *\n+    * TODO: maybe use png_uint_32 anyway, not unsigned int, to reduce the\n+    * casts.\n+    *\/\n+   num = (unsigned int)length \/ 2 ;\n@@ -2162,1 +2109,1 @@\n-      return;\n+      return handled_error;\n@@ -2174,1 +2121,1 @@\n-      return;\n+      return handled_error;\n@@ -2177,0 +2124,1 @@\n+   return handled_ok;\n@@ -2178,0 +2126,2 @@\n+#else\n+#  define png_handle_hIST NULL\n@@ -2181,1 +2131,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -2190,24 +2140,0 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pHYs) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n-\n-   if (length != 9)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"invalid\");\n-      return;\n-   }\n-\n@@ -2217,1 +2143,1 @@\n-      return;\n+      return handled_error;\n@@ -2223,0 +2149,2 @@\n+   return handled_ok;\n+   PNG_UNUSED(length)\n@@ -2224,0 +2152,2 @@\n+#else\n+#  define png_handle_pHYs NULL\n@@ -2227,1 +2157,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -2236,24 +2166,0 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_oFFs) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n-\n-   if (length != 9)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"invalid\");\n-      return;\n-   }\n-\n@@ -2263,1 +2169,1 @@\n-      return;\n+      return handled_error;\n@@ -2269,0 +2175,2 @@\n+   return handled_ok;\n+   PNG_UNUSED(length)\n@@ -2270,0 +2178,2 @@\n+#else\n+#  define png_handle_oFFs NULL\n@@ -2274,1 +2184,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -2284,18 +2194,0 @@\n-\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_pCAL) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n-\n@@ -2305,1 +2197,1 @@\n-   buffer = png_read_buffer(png_ptr, length+1, 2\/*silent*\/);\n+   buffer = png_read_buffer(png_ptr, length+1);\n@@ -2311,1 +2203,1 @@\n-      return;\n+      return handled_error;\n@@ -2317,1 +2209,1 @@\n-      return;\n+      return handled_error;\n@@ -2333,1 +2225,1 @@\n-      return;\n+      return handled_error;\n@@ -2353,1 +2245,1 @@\n-      return;\n+      return handled_error;\n@@ -2372,1 +2264,1 @@\n-      return;\n+      return handled_error;\n@@ -2390,1 +2282,1 @@\n-         return;\n+         return handled_error;\n@@ -2397,0 +2289,6 @@\n+   \/* TODO: BUG: png_set_pCAL calls png_chunk_report which, in this case, calls\n+    * png_benign_error and that can error out.\n+    *\n+    * png_read_buffer needs to be allocated with space for both nparams and the\n+    * parameter strings.  Not hard to do.\n+    *\/\n@@ -2398,0 +2296,1 @@\n+   return handled_ok;\n@@ -2399,0 +2298,2 @@\n+#else\n+#  define png_handle_pCAL NULL\n@@ -2403,1 +2304,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -2411,26 +2312,0 @@\n-\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"out of place\");\n-      return;\n-   }\n-\n-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_sCAL) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n-\n-   \/* Need unit type, width, \\0, height: minimum 4 bytes *\/\n-   else if (length < 4)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"invalid\");\n-      return;\n-   }\n-\n@@ -2440,1 +2315,1 @@\n-   buffer = png_read_buffer(png_ptr, length+1, 2\/*silent*\/);\n+   buffer = png_read_buffer(png_ptr, length+1);\n@@ -2444,1 +2319,0 @@\n-      png_chunk_benign_error(png_ptr, \"out of memory\");\n@@ -2446,1 +2320,2 @@\n-      return;\n+      png_chunk_benign_error(png_ptr, \"out of memory\");\n+      return handled_error;\n@@ -2453,1 +2328,1 @@\n-      return;\n+      return handled_error;\n@@ -2459,1 +2334,1 @@\n-      return;\n+      return handled_error;\n@@ -2488,0 +2363,1 @@\n+      {\n@@ -2491,0 +2367,2 @@\n+         return handled_ok;\n+      }\n@@ -2492,0 +2370,2 @@\n+\n+   return handled_error;\n@@ -2493,0 +2373,2 @@\n+#else\n+#  define png_handle_sCAL NULL\n@@ -2496,1 +2378,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -2504,10 +2386,4 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n-   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_tIME) != 0)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"duplicate\");\n-      return;\n-   }\n-\n+   \/* TODO: what is this doing here?  It should be happened in pngread.c and\n+    * pngpread.c, although it could be moved to png_handle_chunk below and\n+    * thereby avoid some code duplication.\n+    *\/\n@@ -2517,7 +2393,0 @@\n-   if (length != 7)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"invalid\");\n-      return;\n-   }\n-\n@@ -2527,1 +2396,1 @@\n-      return;\n+      return handled_error;\n@@ -2537,0 +2406,2 @@\n+   return handled_ok;\n+   PNG_UNUSED(length)\n@@ -2538,0 +2409,2 @@\n+#else\n+#  define png_handle_tIME NULL\n@@ -2542,1 +2415,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -2559,1 +2432,1 @@\n-         return;\n+         return handled_error;\n@@ -2566,1 +2439,1 @@\n-         return;\n+         return handled_error;\n@@ -2571,3 +2444,1 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n+   \/* TODO: this doesn't work and shouldn't be necessary. *\/\n@@ -2577,10 +2448,1 @@\n-#ifdef PNG_MAX_MALLOC_64K\n-   if (length > 65535U)\n-   {\n-      png_crc_finish(png_ptr, length);\n-      png_chunk_benign_error(png_ptr, \"too large to fit in memory\");\n-      return;\n-   }\n-#endif\n-\n-   buffer = png_read_buffer(png_ptr, length+1, 1\/*warn*\/);\n+   buffer = png_read_buffer(png_ptr, length+1);\n@@ -2590,0 +2452,1 @@\n+      png_crc_finish(png_ptr, length);\n@@ -2591,1 +2454,1 @@\n-      return;\n+      return handled_error;\n@@ -2597,1 +2460,1 @@\n-      return;\n+      return handled_error;\n@@ -2616,2 +2479,5 @@\n-   if (png_set_text_2(png_ptr, info_ptr, &text_info, 1) != 0)\n-      png_warning(png_ptr, \"Insufficient memory to process text chunk\");\n+   if (png_set_text_2(png_ptr, info_ptr, &text_info, 1) == 0)\n+      return handled_ok;\n+\n+   png_chunk_benign_error(png_ptr, \"out of memory\");\n+   return handled_error;\n@@ -2619,0 +2485,2 @@\n+#else\n+#  define png_handle_tEXt NULL\n@@ -2623,1 +2491,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -2638,1 +2506,1 @@\n-         return;\n+         return handled_error;\n@@ -2645,1 +2513,1 @@\n-         return;\n+         return handled_error;\n@@ -2650,3 +2518,1 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n+   \/* TODO: should not be necessary. *\/\n@@ -2657,1 +2523,2 @@\n-    * a null terminator later.\n+    * a null terminator later.  The limit check in png_handle_chunk should be\n+    * sufficient.\n@@ -2659,1 +2526,1 @@\n-   buffer = png_read_buffer(png_ptr, length, 2\/*silent*\/);\n+   buffer = png_read_buffer(png_ptr, length);\n@@ -2665,1 +2532,1 @@\n-      return;\n+      return handled_error;\n@@ -2671,1 +2538,1 @@\n-      return;\n+      return handled_error;\n@@ -2724,2 +2591,4 @@\n-            if (png_set_text_2(png_ptr, info_ptr, &text, 1) != 0)\n-               errmsg = \"insufficient memory\";\n+            if (png_set_text_2(png_ptr, info_ptr, &text, 1) == 0)\n+               return handled_ok;\n+\n+            errmsg = \"out of memory\";\n@@ -2733,2 +2602,2 @@\n-   if (errmsg != NULL)\n-      png_chunk_benign_error(png_ptr, errmsg);\n+   png_chunk_benign_error(png_ptr, errmsg);\n+   return handled_error;\n@@ -2736,0 +2605,2 @@\n+#else\n+#  define png_handle_zTXt NULL\n@@ -2740,1 +2611,1 @@\n-void \/* PRIVATE *\/\n+static png_handle_result_code \/* PRIVATE *\/\n@@ -2755,1 +2626,1 @@\n-         return;\n+         return handled_error;\n@@ -2762,1 +2633,1 @@\n-         return;\n+         return handled_error;\n@@ -2767,3 +2638,1 @@\n-   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n-      png_chunk_error(png_ptr, \"missing IHDR\");\n-\n+   \/* TODO: should not be necessary. *\/\n@@ -2773,1 +2642,1 @@\n-   buffer = png_read_buffer(png_ptr, length+1, 1\/*warn*\/);\n+   buffer = png_read_buffer(png_ptr, length+1);\n@@ -2779,1 +2648,1 @@\n-      return;\n+      return handled_error;\n@@ -2785,1 +2654,1 @@\n-      return;\n+      return handled_error;\n@@ -2875,2 +2744,4 @@\n-         if (png_set_text_2(png_ptr, info_ptr, &text, 1) != 0)\n-            errmsg = \"insufficient memory\";\n+         if (png_set_text_2(png_ptr, info_ptr, &text, 1) == 0)\n+            return handled_ok;\n+\n+         errmsg = \"out of memory\";\n@@ -2885,0 +2756,1 @@\n+   return handled_error;\n@@ -2886,0 +2758,2 @@\n+#else\n+#  define png_handle_iTXt NULL\n@@ -2893,1 +2767,1 @@\n-   png_alloc_size_t limit = PNG_SIZE_MAX;\n+   const png_alloc_size_t limit = png_chunk_max(png_ptr);\n@@ -2901,10 +2775,0 @@\n-#  ifdef PNG_SET_USER_LIMITS_SUPPORTED\n-   if (png_ptr->user_chunk_malloc_max > 0 &&\n-       png_ptr->user_chunk_malloc_max < limit)\n-      limit = png_ptr->user_chunk_malloc_max;\n-\n-#  elif PNG_USER_CHUNK_MALLOC_MAX > 0\n-   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n-      limit = PNG_USER_CHUNK_MALLOC_MAX;\n-#  endif\n-\n@@ -2949,1 +2813,1 @@\n-void \/* PRIVATE *\/\n+png_handle_result_code \/*PRIVATE*\/\n@@ -2953,1 +2817,1 @@\n-   int handled = 0; \/* the chunk was handled *\/\n+   png_handle_result_code handled = handled_discarded; \/* the default *\/\n@@ -3000,1 +2864,1 @@\n-         if (ret < 0)\n+         if (ret < 0) \/* handled_error *\/\n@@ -3034,1 +2898,1 @@\n-            handled = 1;\n+            handled = handled_ok;\n@@ -3119,1 +2983,1 @@\n-            handled = 1;\n+            handled = handled_saved;\n@@ -3145,1 +3009,1 @@\n-   if (handled == 0 && PNG_CHUNK_CRITICAL(png_ptr->chunk_name))\n+   if (handled < handled_saved && PNG_CHUNK_CRITICAL(png_ptr->chunk_name))\n@@ -3147,0 +3011,2 @@\n+\n+   return handled;\n@@ -3149,5 +3015,8 @@\n-\/* This function is called to verify that a chunk name is valid.\n- * This function can't have the \"critical chunk check\" incorporated\n- * into it, since in the future we will need to be able to call user\n- * functions to handle unknown critical chunks after we check that\n- * the chunk name itself is valid.\n+\/* APNG handling: the minimal implementation of APNG handling in libpng 1.6\n+ * requires that those significant applications which already handle APNG not\n+ * get hosed.  To do this ensure the code here will have to ensure than APNG\n+ * data by default (at least in 1.6) gets stored in the unknown chunk list.\n+ * Maybe this can be relaxed in a few years but at present it's just the only\n+ * safe way.\n+ *\n+ * ATM just cause unknown handling for all three chunks:\n@@ -3155,0 +3024,3 @@\n+#define png_handle_acTL NULL\n+#define png_handle_fcTL NULL\n+#define png_handle_fdAT NULL\n@@ -3156,1 +3028,2 @@\n-\/* Bit hacking: the test for an invalid byte in the 4 byte chunk name is:\n+\/*\n+ * 1.6.47: This is the new table driven interface to all the chunk handling.\n@@ -3158,1 +3031,7 @@\n- * ((c) < 65 || (c) > 122 || ((c) > 90 && (c) < 97))\n+ * The table describes the PNG standard rules for **reading** known chunks -\n+ * every chunk which has an entry in PNG_KNOWN_CHUNKS.  The table contains an\n+ * entry for each PNG_INDEX_cHNK describing the rules.\n+ *\n+ * In this initial version the only information in the entry is the\n+ * png_handle_cHNK function for the chunk in question.  When chunk support is\n+ * compiled out the entry will be NULL.\n@@ -3160,3 +3039,1 @@\n-\n-void \/* PRIVATE *\/\n-png_check_chunk_name(png_const_structrp png_ptr, png_uint_32 chunk_name)\n+static const struct\n@@ -3164,4 +3041,5 @@\n-   int i;\n-   png_uint_32 cn=chunk_name;\n-\n-   png_debug(1, \"in png_check_chunk_name\");\n+   png_handle_result_code (*handler)(\n+         png_structrp, png_inforp, png_uint_32 length);\n+      \/* A chunk-specific 'handler', NULL if the chunk is not supported in this\n+       * build.\n+       *\/\n@@ -3169,1 +3047,100 @@\n-   for (i=1; i<=4; ++i)\n+   \/* Crushing these values helps on modern 32-bit architectures because the\n+    * pointer and the following bit fields both end up requiring 32 bits.\n+    * Typically this will halve the table size.  On 64-bit architectures the\n+    * table entries will typically be 8 bytes.\n+    *\/\n+   png_uint_32 max_length :12; \/* Length min, max in bytes *\/\n+   png_uint_32 min_length :8;\n+      \/* Length errors on critical chunks have special handling to preserve the\n+       * existing behaviour in libpng 1.6.  Anciallary chunks are checked below\n+       * and produce a 'benign' error.\n+       *\/\n+   png_uint_32 pos_before :4; \/* PNG_HAVE_ values chunk must precede *\/\n+   png_uint_32 pos_after  :4; \/* PNG_HAVE_ values chunk must follow *\/\n+      \/* NOTE: PLTE, tRNS and bKGD require special handling which depends on\n+       * the colour type of the base image.\n+       *\/\n+   png_uint_32 multiple   :1; \/* Multiple occurences permitted *\/\n+      \/* This is enabled for PLTE because PLTE may, in practice, be optional *\/\n+}\n+read_chunks[PNG_INDEX_unknown] =\n+{\n+   \/* Definitions as above but done indirectly by #define so that\n+    * PNG_KNOWN_CHUNKS can be used safely to build the table in order.\n+    *\n+    * Each CDcHNK definition lists the values for the parameters **after**\n+    * the first, 'handler', function.  'handler' is NULL when the chunk has no\n+    * compiled in support.\n+    *\/\n+#  define NoCheck 0x801U      \/* Do not check the maximum length *\/\n+#  define Limit   0x802U      \/* Limit to png_chunk_max bytes *\/\n+#  define LKMin   3U+LZ77Min  \/* Minimum length of keyword+LZ77 *\/\n+\n+#define hIHDR PNG_HAVE_IHDR\n+#define hPLTE PNG_HAVE_PLTE\n+#define hIDAT PNG_HAVE_IDAT\n+   \/* For the two chunks, tRNS and bKGD which can occur in PNGs without a PLTE\n+    * but must occur after the PLTE use this and put the check in the handler\n+    * routine for colour mapped images were PLTE is required.  Also put a check\n+    * in PLTE for other image types to drop the PLTE if tRNS or bKGD have been\n+    * seen.\n+    *\/\n+#define hCOL  (PNG_HAVE_PLTE|PNG_HAVE_IDAT)\n+   \/* Used for the decoding chunks which must be before PLTE. *\/\n+#define aIDAT PNG_AFTER_IDAT\n+\n+   \/* Chunks from W3C PNG v3: *\/\n+   \/*       cHNK  max_len,   min, before, after, multiple *\/\n+#  define CDIHDR      13U,   13U,  hIHDR,     0,        0\n+#  define CDPLTE  NoCheck,    0U,      0, hIHDR,        1\n+      \/* PLTE errors are only critical for colour-map images, consequently the\n+       * hander does all the checks.\n+       *\/\n+#  define CDIDAT  NoCheck,    0U,  aIDAT, hIHDR,        1\n+#  define CDIEND  NoCheck,    0U,      0, aIDAT,        0\n+      \/* Historically data was allowed in IEND *\/\n+#  define CDtRNS     256U,    0U,  hIDAT, hIHDR,        0\n+#  define CDcHRM      32U,   32U,   hCOL, hIHDR,        0\n+#  define CDgAMA       4U,    4U,   hCOL, hIHDR,        0\n+#  define CDiCCP  NoCheck, LKMin,   hCOL, hIHDR,        0\n+#  define CDsBIT       4U,    1U,   hCOL, hIHDR,        0\n+#  define CDsRGB       1U,    1U,   hCOL, hIHDR,        0\n+#  define CDcICP       4U,    4U,   hCOL, hIHDR,        0\n+#  define CDmDCV      24U,   24U,   hCOL, hIHDR,        0\n+#  define CDeXIf    Limit,    4U,      0, hIHDR,        0\n+#  define CDcLLI       8U,    8U,   hCOL, hIHDR,        0\n+#  define CDtEXt  NoCheck,    2U,      0, hIHDR,        1\n+      \/* Allocates 'length+1'; checked in the handler *\/\n+#  define CDzTXt    Limit, LKMin,      0, hIHDR,        1\n+#  define CDiTXt  NoCheck,    6U,      0, hIHDR,        1\n+      \/* Allocates 'length+1'; checked in the handler *\/\n+#  define CDbKGD       6U,    1U,  hIDAT, hIHDR,        0\n+#  define CDhIST    1024U,    0U,  hPLTE, hIHDR,        0\n+#  define CDpHYs       9U,    9U,  hIDAT, hIHDR,        0\n+#  define CDsPLT  NoCheck,    3U,  hIDAT, hIHDR,        1\n+      \/* Allocates 'length+1'; checked in the handler *\/\n+#  define CDtIME       7U,    7U,      0, hIHDR,        0\n+#  define CDacTL       8U,    8U,  hIDAT, hIHDR,        0\n+#  define CDfcTL      25U,   26U,      0, hIHDR,        1\n+#  define CDfdAT    Limit,    4U,  hIDAT, hIHDR,        1\n+   \/* Supported chunks from PNG extensions 1.5.0, NYI so limit *\/\n+#  define CDoFFs       9U,    9U,  hIDAT, hIHDR,        0\n+#  define CDpCAL  NoCheck,   14U,  hIDAT, hIHDR,        0\n+      \/* Allocates 'length+1'; checked in the handler *\/\n+#  define CDsCAL    Limit,    4U,  hIDAT, hIHDR,        0\n+      \/* Allocates 'length+1'; checked in the handler *\/\n+\n+#  define PNG_CHUNK(cHNK, index) { png_handle_ ## cHNK, CD ## cHNK },\n+   PNG_KNOWN_CHUNKS\n+#  undef PNG_CHUNK\n+};\n+\n+\n+static png_index\n+png_chunk_index_from_name(png_uint_32 chunk_name)\n+{\n+   \/* For chunk png_cHNK return PNG_INDEX_cHNK.  Return PNG_INDEX_unknown if\n+    * chunk_name is not known.  Notice that in a particular build \"known\" does\n+    * not necessarily mean \"supported\", although the inverse applies.\n+    *\/\n+   switch (chunk_name)\n@@ -3171,1 +3148,4 @@\n-      int c = cn & 0xff;\n+#     define PNG_CHUNK(cHNK, index)\\\n+         case png_ ## cHNK: return PNG_INDEX_ ## cHNK; \/* == index *\/\n+\n+      PNG_KNOWN_CHUNKS\n@@ -3173,2 +3153,1 @@\n-      if (c < 65 || c > 122 || (c > 90 && c < 97))\n-         png_chunk_error(png_ptr, \"invalid chunk type\");\n+#     undef PNG_CHUNK\n@@ -3176,1 +3155,1 @@\n-      cn >>= 8;\n+      default: return PNG_INDEX_unknown;\n@@ -3180,2 +3159,2 @@\n-void \/* PRIVATE *\/\n-png_check_chunk_length(png_const_structrp png_ptr, png_uint_32 length)\n+png_handle_result_code \/*PRIVATE*\/\n+png_handle_chunk(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n@@ -3183,11 +3162,16 @@\n-   png_alloc_size_t limit = PNG_UINT_31_MAX;\n-\n-# ifdef PNG_SET_USER_LIMITS_SUPPORTED\n-   if (png_ptr->user_chunk_malloc_max > 0 &&\n-       png_ptr->user_chunk_malloc_max < limit)\n-      limit = png_ptr->user_chunk_malloc_max;\n-# elif PNG_USER_CHUNK_MALLOC_MAX > 0\n-   if (PNG_USER_CHUNK_MALLOC_MAX < limit)\n-      limit = PNG_USER_CHUNK_MALLOC_MAX;\n-# endif\n-   if (png_ptr->chunk_name == png_IDAT)\n+   \/* CSE: these things don't change, these autos are just to save typing and\n+    * make the code more clear.\n+    *\/\n+   const png_uint_32 chunk_name = png_ptr->chunk_name;\n+   const png_index chunk_index = png_chunk_index_from_name(chunk_name);\n+\n+   png_handle_result_code handled = handled_error;\n+   png_const_charp errmsg = NULL;\n+\n+   \/* Is this a known chunk?  If not there are no checks performed here;\n+    * png_handle_unknown does the correct checks.  This means that the values\n+    * for known but unsupported chunks in the above table are not used here\n+    * however the chunks_seen fields in png_struct are still set.\n+    *\/\n+   if (chunk_index == PNG_INDEX_unknown ||\n+       read_chunks[chunk_index].handler == NULL)\n@@ -3195,15 +3179,82 @@\n-      png_alloc_size_t idat_limit = PNG_UINT_31_MAX;\n-      size_t row_factor =\n-         (size_t)png_ptr->width\n-         * (size_t)png_ptr->channels\n-         * (png_ptr->bit_depth > 8? 2: 1)\n-         + 1\n-         + (png_ptr->interlaced? 6: 0);\n-      if (png_ptr->height > PNG_UINT_32_MAX\/row_factor)\n-         idat_limit = PNG_UINT_31_MAX;\n-      else\n-         idat_limit = png_ptr->height * row_factor;\n-      row_factor = row_factor > 32566? 32566 : row_factor;\n-      idat_limit += 6 + 5*(idat_limit\/row_factor+1); \/* zlib+deflate overhead *\/\n-      idat_limit=idat_limit < PNG_UINT_31_MAX? idat_limit : PNG_UINT_31_MAX;\n-      limit = limit < idat_limit? idat_limit : limit;\n+      handled = png_handle_unknown(\n+            png_ptr, info_ptr, length, PNG_HANDLE_CHUNK_AS_DEFAULT);\n+   }\n+\n+   \/* First check the position.   The first check is historical; the stream must\n+    * start with IHDR and anything else causes libpng to give up immediately.\n+    *\/\n+   else if (chunk_index != PNG_INDEX_IHDR &&\n+            (png_ptr->mode & PNG_HAVE_IHDR) == 0)\n+      png_chunk_error(png_ptr, \"missing IHDR\"); \/* NORETURN *\/\n+\n+   \/* Before all the pos_before chunks, after all the pos_after chunks. *\/\n+   else if (((png_ptr->mode & read_chunks[chunk_index].pos_before) != 0) ||\n+            ((png_ptr->mode & read_chunks[chunk_index].pos_after) !=\n+             read_chunks[chunk_index].pos_after))\n+   {\n+      errmsg = \"out of place\";\n+   }\n+\n+   \/* Now check for duplicates: duplicated critical chunks also produce a\n+    * full error.\n+    *\/\n+   else if (read_chunks[chunk_index].multiple == 0 &&\n+            png_file_has_chunk(png_ptr, chunk_index))\n+   {\n+      errmsg = \"duplicate\";\n+   }\n+\n+   else if (length < read_chunks[chunk_index].min_length)\n+      errmsg = \"too short\";\n+   else\n+   {\n+      \/* NOTE: apart from IHDR the critical chunks (PLTE, IDAT and IEND) are set\n+       * up above not to do any length checks.\n+       *\n+       * The png_chunk_max check ensures that the variable length chunks are\n+       * always checked at this point for being within the system allocation\n+       * limits.\n+       *\/\n+      unsigned max_length = read_chunks[chunk_index].max_length;\n+\n+      switch (max_length)\n+      {\n+         case Limit:\n+            \/* png_read_chunk_header has already png_error'ed chunks with a\n+             * length exceeding the 31-bit PNG limit, so just check the memory\n+             * limit:\n+             *\/\n+            if (length <= png_chunk_max(png_ptr))\n+               goto MeetsLimit;\n+\n+            errmsg = \"length exceeds libpng limit\";\n+            break;\n+\n+         default:\n+            if (length <= max_length)\n+               goto MeetsLimit;\n+\n+            errmsg = \"too long\";\n+            break;\n+\n+         case NoCheck:\n+         MeetsLimit:\n+            handled = read_chunks[chunk_index].handler(\n+                  png_ptr, info_ptr, length);\n+            break;\n+      }\n+   }\n+\n+   \/* If there was an error or the chunk was simply skipped it is not counted as\n+    * 'seen'.\n+    *\/\n+   if (errmsg != NULL)\n+   {\n+      if (PNG_CHUNK_CRITICAL(chunk_name)) \/* stop immediately *\/\n+         png_chunk_error(png_ptr, errmsg);\n+      else \/* ancillary chunk *\/\n+      {\n+         \/* The chunk data is skipped: *\/\n+         png_crc_finish(png_ptr, length);\n+         png_chunk_benign_error(png_ptr, errmsg);\n+      }\n@@ -3212,1 +3263,1 @@\n-   if (length > limit)\n+   else if (handled >= handled_saved)\n@@ -3214,3 +3265,2 @@\n-      png_debug2(0,\" length = %lu, limit = %lu\",\n-         (unsigned long)length,(unsigned long)limit);\n-      png_benign_error(png_ptr, \"chunk data is too large\");\n+      if (chunk_index != PNG_INDEX_unknown)\n+         png_file_add_chunk(png_ptr, chunk_index);\n@@ -3218,0 +3268,2 @@\n+\n+   return handled;\n@@ -3715,4 +3767,0 @@\n-   \/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index *\/\n-   \/* Offset to next interlace block *\/\n-   static const unsigned int png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n-\n@@ -4211,0 +4259,3 @@\n+         if (avail_in > png_chunk_max(png_ptr))\n+            avail_in = (uInt)\/*SAFE*\/png_chunk_max(png_ptr);\n+\n@@ -4218,0 +4269,2 @@\n+          *\n+          * An error here corresponds to the system being out of memory.\n@@ -4219,1 +4272,4 @@\n-         buffer = png_read_buffer(png_ptr, avail_in, 0\/*error*\/);\n+         buffer = png_read_buffer(png_ptr, avail_in);\n+\n+         if (buffer == NULL)\n+            png_chunk_error(png_ptr, \"out of memory\");\n@@ -4356,14 +4412,0 @@\n-   \/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index *\/\n-\n-   \/* Start of interlace block *\/\n-   static const png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};\n-\n-   \/* Offset to next interlace block *\/\n-   static const png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n-\n-   \/* Start of interlace block in the y direction *\/\n-   static const png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};\n-\n-   \/* Offset to next interlace block in the y direction *\/\n-   static const png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};\n-\n@@ -4421,14 +4463,0 @@\n-   \/* Arrays to facilitate easy interlacing - use pass (0 - 6) as index *\/\n-\n-   \/* Start of interlace block *\/\n-   static const png_byte png_pass_start[7] = {0, 4, 0, 2, 0, 1, 0};\n-\n-   \/* Offset to next interlace block *\/\n-   static const png_byte png_pass_inc[7] = {8, 8, 4, 4, 2, 2, 1};\n-\n-   \/* Start of interlace block in the y direction *\/\n-   static const png_byte png_pass_ystart[7] = {0, 0, 4, 0, 2, 0, 1};\n-\n-   \/* Offset to next interlace block in the y direction *\/\n-   static const png_byte png_pass_yinc[7] = {8, 8, 8, 4, 4, 2, 2};\n-\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngrutil.c","additions":947,"deletions":919,"binary":false,"changes":1866,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Copyright (c) 2018-2024 Cosmin Truta\n+ * Copyright (c) 2018-2025 Cosmin Truta\n@@ -73,2 +73,0 @@\n-   png_xy xy;\n-\n@@ -80,12 +78,8 @@\n-   xy.redx = red_x;\n-   xy.redy = red_y;\n-   xy.greenx = green_x;\n-   xy.greeny = green_y;\n-   xy.bluex = blue_x;\n-   xy.bluey = blue_y;\n-   xy.whitex = white_x;\n-   xy.whitey = white_y;\n-\n-   if (png_colorspace_set_chromaticities(png_ptr, &info_ptr->colorspace, &xy,\n-       2\/* override with app values*\/) != 0)\n-      info_ptr->colorspace.flags |= PNG_COLORSPACE_FROM_cHRM;\n+   info_ptr->cHRM.redx = red_x;\n+   info_ptr->cHRM.redy = red_y;\n+   info_ptr->cHRM.greenx = green_x;\n+   info_ptr->cHRM.greeny = green_y;\n+   info_ptr->cHRM.bluex = blue_x;\n+   info_ptr->cHRM.bluey = blue_y;\n+   info_ptr->cHRM.whitex = white_x;\n+   info_ptr->cHRM.whitey = white_y;\n@@ -93,1 +87,1 @@\n-   png_colorspace_sync_info(png_ptr, info_ptr);\n+   info_ptr->valid |= PNG_INFO_cHRM;\n@@ -105,0 +99,1 @@\n+   png_xy xy;\n@@ -121,3 +116,5 @@\n-   if (png_colorspace_set_endpoints(png_ptr, &info_ptr->colorspace,\n-       &XYZ, 2) != 0)\n-      info_ptr->colorspace.flags |= PNG_COLORSPACE_FROM_cHRM;\n+   if (png_xy_from_XYZ(&xy, &XYZ) == 0)\n+   {\n+      info_ptr->cHRM = xy;\n+      info_ptr->valid |= PNG_INFO_cHRM;\n+   }\n@@ -125,1 +122,2 @@\n-   png_colorspace_sync_info(png_ptr, info_ptr);\n+   else\n+      png_app_error(png_ptr, \"invalid cHRM XYZ\");\n@@ -165,0 +163,186 @@\n+#ifdef PNG_cICP_SUPPORTED\n+void PNGAPI\n+png_set_cICP(png_const_structrp png_ptr, png_inforp info_ptr,\n+             png_byte colour_primaries, png_byte transfer_function,\n+             png_byte matrix_coefficients, png_byte video_full_range_flag)\n+{\n+   png_debug1(1, \"in %s storage function\", \"cICP\");\n+\n+   if (png_ptr == NULL || info_ptr == NULL)\n+      return;\n+\n+   info_ptr->cicp_colour_primaries = colour_primaries;\n+   info_ptr->cicp_transfer_function = transfer_function;\n+   info_ptr->cicp_matrix_coefficients = matrix_coefficients;\n+   info_ptr->cicp_video_full_range_flag = video_full_range_flag;\n+\n+   if (info_ptr->cicp_matrix_coefficients != 0)\n+   {\n+      png_warning(png_ptr, \"Invalid cICP matrix coefficients\");\n+      return;\n+   }\n+\n+   info_ptr->valid |= PNG_INFO_cICP;\n+}\n+#endif \/* cICP *\/\n+\n+#ifdef PNG_cLLI_SUPPORTED\n+void PNGFAPI\n+png_set_cLLI_fixed(png_const_structrp png_ptr, png_inforp info_ptr,\n+    \/* The values below are in cd\/m2 (nits) and are scaled by 10,000; not\n+     * 100,000 as in the case of png_fixed_point.\n+     *\/\n+    png_uint_32 maxCLL, png_uint_32 maxFALL)\n+{\n+   png_debug1(1, \"in %s storage function\", \"cLLI\");\n+\n+   if (png_ptr == NULL || info_ptr == NULL)\n+      return;\n+\n+   \/* Check the light level range: *\/\n+   if (maxCLL > 0x7FFFFFFFU || maxFALL > 0x7FFFFFFFU)\n+   {\n+      \/* The limit is 200kcd\/m2; somewhat bright but not inconceivable because\n+       * human vision is said to run up to 100Mcd\/m2.  The sun is about 2Gcd\/m2.\n+       *\n+       * The reference sRGB monitor is 80cd\/m2 and the limit of PQ encoding is\n+       * 2kcd\/m2.\n+       *\/\n+      png_chunk_report(png_ptr, \"cLLI light level exceeds PNG limit\",\n+            PNG_CHUNK_WRITE_ERROR);\n+      return;\n+   }\n+\n+   info_ptr->maxCLL = maxCLL;\n+   info_ptr->maxFALL = maxFALL;\n+   info_ptr->valid |= PNG_INFO_cLLI;\n+}\n+\n+#  ifdef PNG_FLOATING_POINT_SUPPORTED\n+void PNGAPI\n+png_set_cLLI(png_const_structrp png_ptr, png_inforp info_ptr,\n+   double maxCLL, double maxFALL)\n+{\n+   png_set_cLLI_fixed(png_ptr, info_ptr,\n+       png_fixed_ITU(png_ptr, maxCLL, \"png_set_cLLI(maxCLL)\"),\n+       png_fixed_ITU(png_ptr, maxFALL, \"png_set_cLLI(maxFALL)\"));\n+}\n+#  endif \/* FLOATING_POINT *\/\n+#endif \/* cLLI *\/\n+\n+#ifdef PNG_mDCV_SUPPORTED\n+static png_uint_16\n+png_ITU_fixed_16(int *error, png_fixed_point v)\n+{\n+   \/* Return a safe uint16_t value scaled according to the ITU H273 rules for\n+    * 16-bit display chromaticities.  Functions like the corresponding\n+    * png_fixed() internal function with regard to errors: it's an error on\n+    * write, a chunk_benign_error on read: See the definition of\n+    * png_chunk_report in pngpriv.h.\n+    *\/\n+   v \/= 2; \/* rounds to 0 in C: avoids insignificant arithmetic errors *\/\n+   if (v > 65535 || v < 0)\n+   {\n+      *error = 1;\n+      return 0;\n+   }\n+\n+   return (png_uint_16)\/*SAFE*\/v;\n+}\n+\n+void PNGAPI\n+png_set_mDCV_fixed(png_const_structrp png_ptr, png_inforp info_ptr,\n+    png_fixed_point white_x, png_fixed_point white_y,\n+    png_fixed_point red_x, png_fixed_point red_y,\n+    png_fixed_point green_x, png_fixed_point green_y,\n+    png_fixed_point blue_x, png_fixed_point blue_y,\n+    png_uint_32 maxDL,\n+    png_uint_32 minDL)\n+{\n+   png_uint_16 rx, ry, gx, gy, bx, by, wx, wy;\n+   int error;\n+\n+   png_debug1(1, \"in %s storage function\", \"mDCV\");\n+\n+   if (png_ptr == NULL || info_ptr == NULL)\n+      return;\n+\n+   \/* Check the input values to ensure they are in the expected range: *\/\n+   error = 0;\n+   rx = png_ITU_fixed_16(&error, red_x);\n+   ry = png_ITU_fixed_16(&error, red_y);\n+   gx = png_ITU_fixed_16(&error, green_x);\n+   gy = png_ITU_fixed_16(&error, green_y);\n+   bx = png_ITU_fixed_16(&error, blue_x);\n+   by = png_ITU_fixed_16(&error, blue_y);\n+   wx = png_ITU_fixed_16(&error, white_x);\n+   wy = png_ITU_fixed_16(&error, white_y);\n+\n+   if (error)\n+   {\n+      png_chunk_report(png_ptr,\n+         \"mDCV chromaticities outside representable range\",\n+         PNG_CHUNK_WRITE_ERROR);\n+      return;\n+   }\n+\n+   \/* Check the light level range: *\/\n+   if (maxDL > 0x7FFFFFFFU || minDL > 0x7FFFFFFFU)\n+   {\n+      \/* The limit is 200kcd\/m2; somewhat bright but not inconceivable because\n+       * human vision is said to run up to 100Mcd\/m2.  The sun is about 2Gcd\/m2.\n+       *\n+       * The reference sRGB monitor is 80cd\/m2 and the limit of PQ encoding is\n+       * 2kcd\/m2.\n+       *\/\n+      png_chunk_report(png_ptr, \"mDCV display light level exceeds PNG limit\",\n+            PNG_CHUNK_WRITE_ERROR);\n+      return;\n+   }\n+\n+   \/* All values are safe, the settings are accepted.\n+    *\n+    * IMPLEMENTATION NOTE: in practice the values can be checked and assigned\n+    * but the result is confusing if a writing app calls png_set_mDCV more than\n+    * once, the second time with an invalid value.  This approach is more\n+    * obviously correct at the cost of typing and a very slight machine\n+    * overhead.\n+    *\/\n+   info_ptr->mastering_red_x = rx;\n+   info_ptr->mastering_red_y = ry;\n+   info_ptr->mastering_green_x = gx;\n+   info_ptr->mastering_green_y = gy;\n+   info_ptr->mastering_blue_x = bx;\n+   info_ptr->mastering_blue_y = by;\n+   info_ptr->mastering_white_x = wx;\n+   info_ptr->mastering_white_y = wy;\n+   info_ptr->mastering_maxDL = maxDL;\n+   info_ptr->mastering_minDL = minDL;\n+   info_ptr->valid |= PNG_INFO_mDCV;\n+}\n+\n+#  ifdef PNG_FLOATING_POINT_SUPPORTED\n+void PNGAPI\n+png_set_mDCV(png_const_structrp png_ptr, png_inforp info_ptr,\n+    double white_x, double white_y, double red_x, double red_y, double green_x,\n+    double green_y, double blue_x, double blue_y,\n+    double maxDL, double minDL)\n+{\n+   png_set_mDCV_fixed(png_ptr, info_ptr,\n+      \/* The ITU approach is to scale by 50,000, not 100,000 so just divide\n+       * the input values by 2 and use png_fixed:\n+       *\/\n+      png_fixed(png_ptr, white_x \/ 2, \"png_set_mDCV(white(x))\"),\n+      png_fixed(png_ptr, white_y \/ 2, \"png_set_mDCV(white(y))\"),\n+      png_fixed(png_ptr, red_x \/ 2, \"png_set_mDCV(red(x))\"),\n+      png_fixed(png_ptr, red_y \/ 2, \"png_set_mDCV(red(y))\"),\n+      png_fixed(png_ptr, green_x \/ 2, \"png_set_mDCV(green(x))\"),\n+      png_fixed(png_ptr, green_y \/ 2, \"png_set_mDCV(green(y))\"),\n+      png_fixed(png_ptr, blue_x \/ 2, \"png_set_mDCV(blue(x))\"),\n+      png_fixed(png_ptr, blue_y \/ 2, \"png_set_mDCV(blue(y))\"),\n+      png_fixed_ITU(png_ptr, maxDL, \"png_set_mDCV(maxDL)\"),\n+      png_fixed_ITU(png_ptr, minDL, \"png_set_mDCV(minDL)\"));\n+}\n+#  endif \/* FLOATING_POINT *\/\n+#endif \/* mDCV *\/\n+\n@@ -216,2 +400,2 @@\n-   png_colorspace_set_gamma(png_ptr, &info_ptr->colorspace, file_gamma);\n-   png_colorspace_sync_info(png_ptr, info_ptr);\n+   info_ptr->gamma = file_gamma;\n+   info_ptr->valid |= PNG_INFO_gAMA;\n@@ -676,2 +860,2 @@\n-   (void)png_colorspace_set_sRGB(png_ptr, &info_ptr->colorspace, srgb_intent);\n-   png_colorspace_sync_info(png_ptr, info_ptr);\n+   info_ptr->rendering_intent = srgb_intent;\n+   info_ptr->valid |= PNG_INFO_sRGB;\n@@ -689,7 +873,5 @@\n-   if (png_colorspace_set_sRGB(png_ptr, &info_ptr->colorspace,\n-       srgb_intent) != 0)\n-   {\n-      \/* This causes the gAMA and cHRM to be written too *\/\n-      info_ptr->colorspace.flags |=\n-         PNG_COLORSPACE_FROM_gAMA|PNG_COLORSPACE_FROM_cHRM;\n-   }\n+   png_set_sRGB(png_ptr, info_ptr, srgb_intent);\n+\n+#  ifdef PNG_gAMA_SUPPORTED\n+      png_set_gAMA_fixed(png_ptr, info_ptr, PNG_GAMMA_sRGB_INVERSE);\n+#  endif \/* gAMA *\/\n@@ -697,1 +879,8 @@\n-   png_colorspace_sync_info(png_ptr, info_ptr);\n+#  ifdef PNG_cHRM_SUPPORTED\n+      png_set_cHRM_fixed(png_ptr, info_ptr,\n+         \/* color      x       y *\/\n+         \/* white *\/ 31270, 32900,\n+         \/* red   *\/ 64000, 33000,\n+         \/* green *\/ 30000, 60000,\n+         \/* blue  *\/ 15000,  6000);\n+#  endif \/* cHRM *\/\n@@ -720,21 +909,0 @@\n-   \/* Set the colorspace first because this validates the profile; do not\n-    * override previously set app cHRM or gAMA here (because likely as not the\n-    * application knows better than libpng what the correct values are.)  Pass\n-    * the info_ptr color_type field to png_colorspace_set_ICC because in the\n-    * write case it has not yet been stored in png_ptr.\n-    *\/\n-   {\n-      int result = png_colorspace_set_ICC(png_ptr, &info_ptr->colorspace, name,\n-          proflen, profile, info_ptr->color_type);\n-\n-      png_colorspace_sync_info(png_ptr, info_ptr);\n-\n-      \/* Don't do any of the copying if the profile was bad, or inconsistent. *\/\n-      if (result == 0)\n-         return;\n-\n-      \/* But do write the gAMA and cHRM chunks from the profile. *\/\n-      info_ptr->colorspace.flags |=\n-         PNG_COLORSPACE_FROM_gAMA|PNG_COLORSPACE_FROM_cHRM;\n-   }\n-\n@@ -1426,0 +1594,2 @@\n+         99,  73,  67,  80, '\\0',  \/* cICP *\/\n+         99,  76,  76,  73, '\\0',  \/* cLLI *\/\n@@ -1431,0 +1601,1 @@\n+        109,  68,  67,  86, '\\0',  \/* mDCV *\/\n@@ -1692,0 +1863,5 @@\n+   \/* pngstruct::user_chunk_malloc_max is initialized to a non-zero value in\n+    * png.c.  This API supports '0' for unlimited, make sure the correct\n+    * (unlimited) value is set here to avoid a need to check for 0 everywhere\n+    * the parameter is used.\n+    *\/\n@@ -1693,1 +1869,12 @@\n-      png_ptr->user_chunk_malloc_max = user_chunk_malloc_max;\n+   {\n+      if (user_chunk_malloc_max == 0U) \/* unlimited *\/\n+      {\n+#        ifdef PNG_MAX_MALLOC_64K\n+            png_ptr->user_chunk_malloc_max = 65536U;\n+#        else\n+            png_ptr->user_chunk_malloc_max = PNG_SIZE_MAX;\n+#        endif\n+      }\n+      else\n+         png_ptr->user_chunk_malloc_max = user_chunk_malloc_max;\n+   }\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngset.c","additions":241,"deletions":54,"binary":false,"changes":295,"status":"modified"},{"patch":"@@ -101,5 +101,0 @@\n- *\n- * PNG_COLORSPACE_SUPPORTED is only required if the application will perform\n- * colorspace corrections, otherwise all the colorspace information can be\n- * skipped and the size of libpng can be reduced (significantly) by compiling\n- * out the colorspace support.\n@@ -107,1 +102,0 @@\n-#ifdef PNG_COLORSPACE_SUPPORTED\n@@ -128,1 +122,0 @@\n-#endif \/* COLORSPACE *\/\n@@ -130,9 +123,2 @@\n-#if defined(PNG_COLORSPACE_SUPPORTED) || defined(PNG_GAMMA_SUPPORTED)\n-\/* A colorspace is all the above plus, potentially, profile information;\n- * however at present libpng does not use the profile internally so it is only\n- * stored in the png_info struct (if iCCP is supported.)  The rendering intent\n- * is retained here and is checked.\n- *\n- * The file gamma encoding information is also stored here and gamma correction\n- * is done by libpng, whereas color correction must currently be done by the\n- * application.\n+\/* Chunk index values as an enum, PNG_INDEX_unknown is also a count of the\n+ * number of chunks.\n@@ -140,1 +126,2 @@\n-typedef struct png_colorspace\n+#define PNG_CHUNK(cHNK, i) PNG_INDEX_ ## cHNK = (i),\n+typedef enum\n@@ -142,3 +129,4 @@\n-#ifdef PNG_GAMMA_SUPPORTED\n-   png_fixed_point gamma;        \/* File gamma *\/\n-#endif\n+   PNG_KNOWN_CHUNKS\n+   PNG_INDEX_unknown\n+} png_index;\n+#undef PNG_CHUNK\n@@ -146,9 +134,10 @@\n-#ifdef PNG_COLORSPACE_SUPPORTED\n-   png_xy      end_points_xy;    \/* End points as chromaticities *\/\n-   png_XYZ     end_points_XYZ;   \/* End points as CIE XYZ colorant values *\/\n-   png_uint_16 rendering_intent; \/* Rendering intent of a profile *\/\n-#endif\n-\n-   \/* Flags are always defined to simplify the code. *\/\n-   png_uint_16 flags;            \/* As defined below *\/\n-} png_colorspace, * PNG_RESTRICT png_colorspacerp;\n+\/* Chunk flag values.  These are (png_uint_32 values) with exactly one bit set\n+ * and can be combined into a flag set with bitwise 'or'.\n+ *\n+ * TODO: C23: convert these macros to C23 inlines (which are static).\n+ *\/\n+#define png_chunk_flag_from_index(i) (0x80000000U >> (31 - (i)))\n+   \/* The flag coresponding to the given png_index enum value.  This is defined\n+    * for png_unknown as well (until it reaches the value 32) but this should\n+    * not be relied on.\n+    *\/\n@@ -156,1 +145,3 @@\n-typedef const png_colorspace * PNG_RESTRICT png_const_colorspacerp;\n+#define png_file_has_chunk(png_ptr, i)\\\n+   (((png_ptr)->chunks & png_chunk_flag_from_index(i)) != 0)\n+   \/* The chunk has been recorded in png_struct *\/\n@@ -158,12 +149,3 @@\n-\/* General flags for the 'flags' field *\/\n-#define PNG_COLORSPACE_HAVE_GAMMA           0x0001\n-#define PNG_COLORSPACE_HAVE_ENDPOINTS       0x0002\n-#define PNG_COLORSPACE_HAVE_INTENT          0x0004\n-#define PNG_COLORSPACE_FROM_gAMA            0x0008\n-#define PNG_COLORSPACE_FROM_cHRM            0x0010\n-#define PNG_COLORSPACE_FROM_sRGB            0x0020\n-#define PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB 0x0040\n-#define PNG_COLORSPACE_MATCHES_sRGB         0x0080 \/* exact match on profile *\/\n-#define PNG_COLORSPACE_INVALID              0x8000\n-#define PNG_COLORSPACE_CANCEL(flags)        (0xffff ^ (flags))\n-#endif \/* COLORSPACE || GAMMA *\/\n+#define png_file_add_chunk(pnt_ptr, i)\\\n+   ((void)((png_ptr)->chunks |= png_chunk_flag_from_index(i)))\n+   \/* Record the chunk in the png_struct *\/\n@@ -241,0 +223,5 @@\n+   png_uint_32 chunks; \/* PNG_CF_ for every chunk read or (NYI) written *\/\n+#  define png_has_chunk(png_ptr, cHNK)\\\n+      png_file_has_chunk(png_ptr, PNG_INDEX_ ## cHNK)\n+      \/* Convenience accessor - use this to check for a known chunk by name *\/\n+\n@@ -317,0 +304,4 @@\n+#ifdef PNG_READ_RGB_TO_GRAY_SUPPORTED\n+   png_xy          chromaticities; \/* From mDVC, cICP, [iCCP], sRGB or cHRM *\/\n+#endif\n+\n@@ -319,1 +310,4 @@\n-   png_fixed_point screen_gamma; \/* screen gamma value (display_exponent) *\/\n+   png_fixed_point screen_gamma; \/* screen gamma value (display exponent) *\/\n+   png_fixed_point file_gamma;   \/* file gamma value (encoding exponent) *\/\n+   png_fixed_point chunk_gamma;  \/* from cICP, iCCP, sRGB or gAMA *\/\n+   png_fixed_point default_gamma;\/* from png_set_alpha_mode *\/\n@@ -331,1 +325,1 @@\n-#endif\n+#endif \/* READ_GAMMA *\/\n@@ -381,2 +375,2 @@\n-#endif\n-#endif\n+#endif \/* TIME_RFC1123 *\/\n+#endif \/* LIBPNG_VER < 10700 *\/\n@@ -392,2 +386,2 @@\n-#endif\n-#endif\n+#endif \/* READ_USER_CHUNKS *\/\n+#endif \/* USER_CHUNKS *\/\n@@ -500,6 +494,0 @@\n-\n-#ifdef PNG_READ_SUPPORTED\n-#if defined(PNG_COLORSPACE_SUPPORTED) || defined(PNG_GAMMA_SUPPORTED)\n-   png_colorspace   colorspace;\n-#endif\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/libpng\/pngstruct.h","additions":42,"deletions":54,"binary":false,"changes":96,"status":"modified"}]}