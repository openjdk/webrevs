{"files":[{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,10 +28,3 @@\n- * @summary Check ability to read zip files created by python zipfile\n- * implementation, which fails to write optional (but recommended) data\n- * descriptor signatures.  Repro scenario is a Java -> Python -> Java round trip:\n- * - ZipOutputStream creates zip file with DEFLATED entries and data\n- *   descriptors with optional signature \"PK0x0708\".\n- * - Python reads those entries, preserving the 0x08 flag byte\n- * - Python outputs those entries with data descriptors lacking the\n- *   optional signature.\n- * - ZipInputStream cannot handle the missing signature\n- *\n+ * @summary Verify the ability to read zip files whose local header\n+ * data descriptor is missing the optional signature\n+ * <p>\n@@ -39,2 +33,1 @@\n- *\n- * @ignore This test has brittle dependencies on an external working python.\n+ * @run junit DataDescriptorSignatureMissing\n@@ -43,0 +36,3 @@\n+\n+import org.junit.jupiter.api.Test;\n+\n@@ -44,0 +40,3 @@\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.charset.StandardCharsets;\n@@ -46,11 +45,12 @@\n-public class DataDescriptorSignatureMissing  {\n-    void printStream(InputStream is) throws IOException {\n-        Reader r = new InputStreamReader(is);\n-        StringBuilder sb = new StringBuilder();\n-        char[] buf = new char[1024];\n-        int n;\n-        while ((n = r.read(buf)) > 0) {\n-            sb.append(buf, 0, n);\n-        }\n-        System.out.print(sb);\n-    }\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class DataDescriptorSignatureMissing {\n+\n+    \/**\n+     * Verify that ZipInputStream correctly parses a ZIP with a Data Descriptor without\n+     * the recommended but optional signature.\n+     *\/\n+    @Test\n+    public void shouldParseSignaturelessDescriptor() throws IOException {\n+        \/\/ The ZIP with a signature-less descriptor\n+        byte[] zip = makeZipWithSignaturelessDescriptor();\n@@ -58,6 +58,12 @@\n-    int entryCount(File zipFile) throws IOException {\n-        try (FileInputStream fis = new FileInputStream(zipFile);\n-             ZipInputStream zis = new ZipInputStream(fis)) {\n-            for (int count = 0;; count++)\n-                if (zis.getNextEntry() == null)\n-                    return count;\n+        \/\/ ZipInputStream should read the signature-less data descriptor\n+        try (ZipInputStream in = new ZipInputStream(\n+                new ByteArrayInputStream(zip))) {\n+            ZipEntry first = in.getNextEntry();\n+            assertNotNull(first, \"Zip file is unexpectedly missing first entry\");\n+            assertEquals(\"first\", first.getName());\n+            assertArrayEquals(\"first\".getBytes(StandardCharsets.UTF_8), in.readAllBytes());\n+\n+            ZipEntry second = in.getNextEntry();\n+            assertNotNull(second, \"Zip file is unexpectedly missing second entry\");\n+            assertEquals(\"second\", second.getName());\n+            assertArrayEquals(\"second\".getBytes(StandardCharsets.UTF_8), in.readAllBytes());\n@@ -65,0 +71,1 @@\n+\n@@ -67,18 +74,52 @@\n-    void test(String[] args) throws Throwable {\n-        if (! new File(\"\/usr\/bin\/python\").canExecute())\n-            return;\n-\n-        \/\/ Create a java zip file with DEFLATED entries and data\n-        \/\/ descriptors with signatures.\n-        final File in = new File(\"in.zip\");\n-        final File out = new File(\"out.zip\");\n-        final int count = 3;\n-        try (FileOutputStream fos = new FileOutputStream(in);\n-             ZipOutputStream zos = new ZipOutputStream(fos)) {\n-            for (int i = 0; i < count; i++) {\n-                ZipEntry ze = new ZipEntry(\"hello.python\" + i);\n-                ze.setMethod(ZipEntry.DEFLATED);\n-                zos.putNextEntry(ze);\n-                zos.write(new byte[10]);\n-                zos.closeEntry();\n-            }\n+    \/**\n+     * The 'Data descriptor' record is used to facilitate ZIP streaming. If the size of an\n+     * entry is unknown at the time the LOC header is written, bit 3 of the General Purpose Bit Flag\n+     * is set, and the File data is immediately followed by the 'Data descriptor' record. This record\n+     * then contains the compressed and uncompressed sizes of the entry and also the CRC value.\n+     *\n+     * The 'Data descriptor' record is usually preceded by the recommended, but optional\n+     * signature value 0x08074b50.\n+     *\n+     * A ZIP entry in streaming mode has the following structure:\n+     *\n+     *  ------  Local File Header  ------\n+     *  000000  signature          0x04034b50\n+     *  000004  version            20\n+     *  000006  flags              0x0808   # Notice bit 3 is set\n+     *  [..] Omitted for brevity\n+     *\n+     *  ------  File Data  ------\n+     *  000035  data               7 bytes\n+     *\n+     *  ------  Data Descriptor  ------\n+     *  000042  signature          0x08074b50\n+     *  000046  crc                0x3610a686\n+     *  000050  csize              7\n+     *  000054  size               5\n+     *\n+     * A signature-less data descriptor will look like the following:\n+     *\n+     *  ------  Data Descriptor  ------\n+     *  000042  crc                0x3610a686\n+     *  000046  csize              7\n+     *  000050  size               5\n+     *\n+     * This method produces a ZIP with two entries, where the first entry\n+     * is made signature-less.\n+     *\/\n+    private static byte[] makeZipWithSignaturelessDescriptor() throws IOException {\n+        \/\/ Offset of the signed data descriptor\n+        int sigOffset;\n+\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        try (ZipOutputStream zo = new ZipOutputStream(out)) {\n+            \/\/ Write a first entry\n+            zo.putNextEntry(new ZipEntry(\"first\"));\n+            zo.write(\"first\".getBytes(StandardCharsets.UTF_8));\n+            \/\/ Force the data descriptor to be written out\n+            zo.closeEntry();\n+            \/\/ Signed data descriptor starts 16 bytes before current offset\n+            sigOffset = out.size() - 4 * Integer.BYTES;\n+            \/\/ Add a second entry\n+            zo.putNextEntry(new ZipEntry(\"second\"));\n+            zo.write(\"second\".getBytes(StandardCharsets.UTF_8));\n@@ -87,43 +128,13 @@\n-        \/\/ Copy the zip file using python's zipfile module\n-        String[] python_program_lines = {\n-            \"import os\",\n-            \"import zipfile\",\n-            \"input_zip = zipfile.ZipFile('in.zip', mode='r')\",\n-            \"output_zip = zipfile.ZipFile('out.zip', mode='w')\",\n-            \"count08 = 0\",\n-            \"for input_info in input_zip.infolist():\",\n-            \"  output_info = input_info\",\n-            \"  if output_info.flag_bits & 0x08 == 0x08:\",\n-            \"    count08 += 1\",\n-            \"  output_zip.writestr(output_info, input_zip.read(input_info))\",\n-            \"output_zip.close()\",\n-            \"if count08 == 0:\",\n-            \"  raise ValueError('Expected to see entries with 0x08 flag_bits set')\",\n-        };\n-        StringBuilder python_program_builder = new StringBuilder();\n-        for (String line : python_program_lines)\n-            python_program_builder.append(line).append('\\n');\n-        String python_program = python_program_builder.toString();\n-        String[] cmdline = { \"\/usr\/bin\/python\", \"-c\", python_program };\n-        ProcessBuilder pb = new ProcessBuilder(cmdline);\n-        pb.redirectErrorStream(true);\n-        Process p = pb.start();\n-        printStream(p.getInputStream());\n-        p.waitFor();\n-        equal(p.exitValue(), 0);\n-\n-        File pythonZipFile = new File(\"out.zip\");\n-        check(pythonZipFile.exists());\n-\n-        equal(entryCount(in),\n-              entryCount(out));\n-\n-        \/\/ We expect out to be identical to in, except for the removal of\n-        \/\/ the optional data descriptor signatures.\n-        final int SIG_LENGTH = 4;       \/\/ length of a zip signature - PKxx\n-        equal(in.length(),\n-              out.length() + SIG_LENGTH * count);\n-\n-        in.delete();\n-        out.delete();\n-    }\n+        \/\/ The generated ZIP file with a signed data descriptor\n+        byte[] sigZip = out.toByteArray();\n+\n+        \/\/ The offset of the CRC immediately following the 4-byte signature\n+        int crcOffset = sigOffset + Integer.BYTES;\n+\n+        \/\/ Create a ZIP file with a signature-less data descriptor for the first entry\n+        ByteArrayOutputStream sigLess = new ByteArrayOutputStream();\n+        sigLess.write(sigZip, 0, sigOffset);\n+        \/\/ Skip the signature\n+        sigLess.write(sigZip, crcOffset, sigZip.length - crcOffset);\n+\n+        byte[] siglessZip = sigLess.toByteArray();\n@@ -131,16 +142,19 @@\n-    \/\/--------------------- Infrastructure ---------------------------\n-    volatile int passed = 0, failed = 0;\n-    void pass() {passed++;}\n-    void fail() {failed++; Thread.dumpStack();}\n-    void fail(String msg) {System.err.println(msg); fail();}\n-    void unexpected(Throwable t) {failed++; t.printStackTrace();}\n-    void check(boolean cond) {if (cond) pass(); else fail();}\n-    void equal(Object x, Object y) {\n-        if (x == null ? y == null : x.equals(y)) pass();\n-        else fail(x + \" not equal to \" + y);}\n-    public static void main(String[] args) throws Throwable {\n-        new DataDescriptorSignatureMissing().instanceMain(args);}\n-    public void instanceMain(String[] args) throws Throwable {\n-        try {test(args);} catch (Throwable t) {unexpected(t);}\n-        System.out.printf(\"%nPassed = %d, failed = %d%n%n\", passed, failed);\n-        if (failed > 0) throw new AssertionError(\"Some tests failed\");}\n+        \/\/ Adjust the CEN offset in the END header\n+        ByteBuffer buffer = ByteBuffer.wrap(siglessZip).order(ByteOrder.LITTLE_ENDIAN);\n+        \/\/ Reduce cenOffset by 4 bytes\n+        int cenOff = siglessZip.length - ZipFile.ENDHDR + ZipFile.ENDOFF;\n+        int realCenOff = buffer.getInt(cenOff) - Integer.BYTES;\n+        buffer.putInt(cenOff, realCenOff);\n+\n+        \/\/ Adjust the LOC offset in the second CEN header\n+        int cen = realCenOff;\n+        \/\/ Skip past the first CEN header\n+        int nlen = buffer.getShort(cen + ZipFile.CENNAM);\n+        cen += ZipFile.CENHDR + nlen;\n+\n+        \/\/ Reduce LOC offset by 4 bytes\n+        int locOff = cen + ZipFile.CENOFF;\n+        buffer.putInt(locOff, buffer.getInt(locOff) - Integer.BYTES);\n+\n+        return siglessZip;\n+    }\n","filename":"test\/jdk\/java\/util\/zip\/DataDescriptorSignatureMissing.java","additions":120,"deletions":106,"binary":false,"changes":226,"status":"modified"}]}