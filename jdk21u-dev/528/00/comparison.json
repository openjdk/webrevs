{"files":[{"patch":"@@ -280,37 +280,0 @@\n-#ifdef ASSERT\n-typedef void (*arraycopy_fn)(address src, address dst, int count);\n-\n-\/\/ simple tests of generated arraycopy functions\n-static void test_arraycopy_func(address func, int alignment) {\n-  int v = 0xcc;\n-  int v2 = 0x11;\n-  jlong lbuffer[8];\n-  jlong lbuffer2[8];\n-  address fbuffer  = (address) lbuffer;\n-  address fbuffer2 = (address) lbuffer2;\n-  unsigned int i;\n-  for (i = 0; i < sizeof(lbuffer); i++) {\n-    fbuffer[i] = v; fbuffer2[i] = v2;\n-  }\n-  \/\/ C++ does not guarantee jlong[] array alignment to 8 bytes.\n-  \/\/ Use middle of array to check that memory before it is not modified.\n-  address buffer  = align_up((address)&lbuffer[4], BytesPerLong);\n-  address buffer2 = align_up((address)&lbuffer2[4], BytesPerLong);\n-  \/\/ do an aligned copy\n-  ((arraycopy_fn)func)(buffer, buffer2, 0);\n-  for (i = 0; i < sizeof(lbuffer); i++) {\n-    assert(fbuffer[i] == v && fbuffer2[i] == v2, \"shouldn't have copied anything\");\n-  }\n-  \/\/ adjust destination alignment\n-  ((arraycopy_fn)func)(buffer, buffer2 + alignment, 0);\n-  for (i = 0; i < sizeof(lbuffer); i++) {\n-    assert(fbuffer[i] == v && fbuffer2[i] == v2, \"shouldn't have copied anything\");\n-  }\n-  \/\/ adjust source alignment\n-  ((arraycopy_fn)func)(buffer + alignment, buffer2, 0);\n-  for (i = 0; i < sizeof(lbuffer); i++) {\n-    assert(fbuffer[i] == v && fbuffer2[i] == v2, \"shouldn't have copied anything\");\n-  }\n-}\n-#endif \/\/ ASSERT\n-\n@@ -325,81 +288,0 @@\n-\n-#ifdef ASSERT\n-\n-  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));\n-\n-#define TEST_ARRAYCOPY(type)                                                    \\\n-  test_arraycopy_func(          type##_arraycopy(),          sizeof(type));     \\\n-  test_arraycopy_func(          type##_disjoint_arraycopy(), sizeof(type));     \\\n-  test_arraycopy_func(arrayof_##type##_arraycopy(),          sizeof(HeapWord)); \\\n-  test_arraycopy_func(arrayof_##type##_disjoint_arraycopy(), sizeof(HeapWord))\n-\n-  \/\/ Make sure all the arraycopy stubs properly handle zero count\n-  TEST_ARRAYCOPY(jbyte);\n-  TEST_ARRAYCOPY(jshort);\n-  TEST_ARRAYCOPY(jint);\n-  TEST_ARRAYCOPY(jlong);\n-\n-#undef TEST_ARRAYCOPY\n-\n-#define TEST_FILL(type)                                                                      \\\n-  if (_##type##_fill != nullptr) {                                                              \\\n-    union {                                                                                  \\\n-      double d;                                                                              \\\n-      type body[96];                                                                         \\\n-    } s;                                                                                     \\\n-                                                                                             \\\n-    int v = 32;                                                                              \\\n-    for (int offset = -2; offset <= 2; offset++) {                                           \\\n-      for (int i = 0; i < 96; i++) {                                                         \\\n-        s.body[i] = 1;                                                                       \\\n-      }                                                                                      \\\n-      type* start = s.body + 8 + offset;                                                     \\\n-      for (int aligned = 0; aligned < 2; aligned++) {                                        \\\n-        if (aligned) {                                                                       \\\n-          if (((intptr_t)start) % HeapWordSize == 0) {                                       \\\n-            ((void (*)(type*, int, int))StubRoutines::_arrayof_##type##_fill)(start, v, 80); \\\n-          } else {                                                                           \\\n-            continue;                                                                        \\\n-          }                                                                                  \\\n-        } else {                                                                             \\\n-          ((void (*)(type*, int, int))StubRoutines::_##type##_fill)(start, v, 80);           \\\n-        }                                                                                    \\\n-        for (int i = 0; i < 96; i++) {                                                       \\\n-          if (i < (8 + offset) || i >= (88 + offset)) {                                      \\\n-            assert(s.body[i] == 1, \"what?\");                                                 \\\n-          } else {                                                                           \\\n-            assert(s.body[i] == 32, \"what?\");                                                \\\n-          }                                                                                  \\\n-        }                                                                                    \\\n-      }                                                                                      \\\n-    }                                                                                        \\\n-  }                                                                                          \\\n-\n-  TEST_FILL(jbyte);\n-  TEST_FILL(jshort);\n-  TEST_FILL(jint);\n-\n-#undef TEST_FILL\n-\n-#define TEST_COPYRTN(type) \\\n-  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::conjoint_##type##s_atomic),  sizeof(type)); \\\n-  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::arrayof_conjoint_##type##s), (int)MAX2(sizeof(HeapWord), sizeof(type)))\n-\n-  \/\/ Make sure all the copy runtime routines properly handle zero count\n-  TEST_COPYRTN(jbyte);\n-  TEST_COPYRTN(jshort);\n-  TEST_COPYRTN(jint);\n-  TEST_COPYRTN(jlong);\n-\n-#undef TEST_COPYRTN\n-\n-  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::conjoint_words), sizeof(HeapWord));\n-  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::disjoint_words), sizeof(HeapWord));\n-  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::disjoint_words_atomic), sizeof(HeapWord));\n-  \/\/ Aligned to BytesPerLong\n-  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::aligned_conjoint_words), sizeof(jlong));\n-  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::aligned_disjoint_words), sizeof(jlong));\n-\n-  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n-\n-#endif\n@@ -408,1 +290,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":0,"deletions":119,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"utilities\/copy.hpp\"\n+#include \"unittest.hpp\"\n+\n+typedef void (*arraycopy_fn)(address src, address dst, int count);\n+\n+\/\/ simple tests of generated arraycopy functions\n+static void test_arraycopy_func(address func, int alignment) {\n+  int v = 0xcc;\n+  int v2 = 0x11;\n+  jlong lbuffer[8];\n+  jlong lbuffer2[8];\n+  address fbuffer  = (address) lbuffer;\n+  address fbuffer2 = (address) lbuffer2;\n+  unsigned int i;\n+  for (i = 0; i < sizeof(lbuffer); i++) {\n+    fbuffer[i] = v; fbuffer2[i] = v2;\n+  }\n+  \/\/ C++ does not guarantee jlong[] array alignment to 8 bytes.\n+  \/\/ Use middle of array to check that memory before it is not modified.\n+  address buffer  = align_up((address)&lbuffer[4], BytesPerLong);\n+  address buffer2 = align_up((address)&lbuffer2[4], BytesPerLong);\n+  \/\/ do an aligned copy\n+  ((arraycopy_fn)func)(buffer, buffer2, 0);\n+  for (i = 0; i < sizeof(lbuffer); i++) {\n+    ASSERT_TRUE(fbuffer[i] == v && fbuffer2[i] == v2) << \"shouldn't have copied anything\";\n+  }\n+  \/\/ adjust destination alignment\n+  ((arraycopy_fn)func)(buffer, buffer2 + alignment, 0);\n+  for (i = 0; i < sizeof(lbuffer); i++) {\n+    ASSERT_TRUE(fbuffer[i] == v && fbuffer2[i] == v2) << \"shouldn't have copied anything\";\n+  }\n+  \/\/ adjust source alignment\n+  ((arraycopy_fn)func)(buffer + alignment, buffer2, 0);\n+  for (i = 0; i < sizeof(lbuffer); i++) {\n+    ASSERT_TRUE(fbuffer[i] == v && fbuffer2[i] == v2) << \"shouldn't have copied anything\";\n+  }\n+}\n+\n+TEST_VM(StubRoutines, array_copy_routine) {\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));\n+\n+#define TEST_ARRAYCOPY(type)                                                                  \\\n+  test_arraycopy_func(          StubRoutines::type##_arraycopy(),          sizeof(type));     \\\n+  test_arraycopy_func(          StubRoutines::type##_disjoint_arraycopy(), sizeof(type));     \\\n+  test_arraycopy_func(StubRoutines::arrayof_##type##_arraycopy(),          sizeof(HeapWord)); \\\n+  test_arraycopy_func(StubRoutines::arrayof_##type##_disjoint_arraycopy(), sizeof(HeapWord))\n+\n+  \/\/ Make sure all the arraycopy stubs properly handle zero count\n+  TEST_ARRAYCOPY(jbyte);\n+  TEST_ARRAYCOPY(jshort);\n+  TEST_ARRAYCOPY(jint);\n+  TEST_ARRAYCOPY(jlong);\n+\n+#undef TEST_ARRAYCOPY\n+\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n+}\n+\n+TEST_VM(StubRoutines, copy_routine) {\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));\n+\n+#define TEST_COPYRTN(type) \\\n+  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::conjoint_##type##s_atomic),  sizeof(type)); \\\n+  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::arrayof_conjoint_##type##s), (int)MAX2(sizeof(HeapWord), sizeof(type)))\n+\n+  \/\/ Make sure all the copy runtime routines properly handle zero count\n+  TEST_COPYRTN(jbyte);\n+  TEST_COPYRTN(jshort);\n+  TEST_COPYRTN(jint);\n+  TEST_COPYRTN(jlong);\n+\n+#undef TEST_COPYRTN\n+\n+  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::conjoint_words), sizeof(HeapWord));\n+  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::disjoint_words), sizeof(HeapWord));\n+  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::disjoint_words_atomic), sizeof(HeapWord));\n+  \/\/ Aligned to BytesPerLong\n+  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::aligned_conjoint_words), sizeof(jlong));\n+  test_arraycopy_func(CAST_FROM_FN_PTR(address, Copy::aligned_disjoint_words), sizeof(jlong));\n+\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n+}\n+\n+TEST_VM(StubRoutines, array_fill_routine) {\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));\n+\n+#define TEST_FILL(type)                                                                      \\\n+  if (StubRoutines::_##type##_fill != nullptr) {                                             \\\n+    union {                                                                                  \\\n+      double d;                                                                              \\\n+      type body[96];                                                                         \\\n+    } s;                                                                                     \\\n+                                                                                             \\\n+    int v = 32;                                                                              \\\n+    for (int offset = -2; offset <= 2; offset++) {                                           \\\n+      for (int i = 0; i < 96; i++) {                                                         \\\n+        s.body[i] = 1;                                                                       \\\n+      }                                                                                      \\\n+      type* start = s.body + 8 + offset;                                                     \\\n+      for (int aligned = 0; aligned < 2; aligned++) {                                        \\\n+        if (aligned) {                                                                       \\\n+          if (((intptr_t)start) % HeapWordSize == 0) {                                       \\\n+            ((void (*)(type*, int, int))StubRoutines::_arrayof_##type##_fill)(start, v, 80); \\\n+          } else {                                                                           \\\n+            continue;                                                                        \\\n+          }                                                                                  \\\n+        } else {                                                                             \\\n+          ((void (*)(type*, int, int))StubRoutines::_##type##_fill)(start, v, 80);           \\\n+        }                                                                                    \\\n+        for (int i = 0; i < 96; i++) {                                                       \\\n+          if (i < (8 + offset) || i >= (88 + offset)) {                                      \\\n+            ASSERT_TRUE(s.body[i] == 1) << \"what?\";                                          \\\n+          } else {                                                                           \\\n+            ASSERT_TRUE(s.body[i] == 32) << \"what?\";                                         \\\n+          }                                                                                  \\\n+        }                                                                                    \\\n+      }                                                                                      \\\n+    }                                                                                        \\\n+  }                                                                                          \\\n+\n+  TEST_FILL(jbyte);\n+  TEST_FILL(jshort);\n+  TEST_FILL(jint);\n+\n+#undef TEST_FILL\n+\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_stubRoutines.cpp","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"}]}