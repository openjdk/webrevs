{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @summary Test Socket.available()\n+ * @summary Test Socket.getInputStream().available()\n@@ -51,0 +51,4 @@\n+    \/*\n+     * Verifies that the Socket.getInputStream().available() throws an IOException\n+     * if invoked after the socket has been closed.\n+     *\/\n@@ -52,24 +56,28 @@\n-        boolean error = true;\n-        InetAddress addr = InetAddress.getLocalHost();\n-        ServerSocket ss = new ServerSocket(0, 0, addr);\n-        int port = ss.getLocalPort();\n-\n-        Thread t = new Thread(new Thread(\"Close-Available-1\") {\n-            public void run() {\n-                try {\n-                    Socket s = new Socket(addr, port);\n-                    s.close();\n-                } catch (Exception e) {\n-                    e.printStackTrace();\n-                }\n-            }\n-        });\n-\n-        t.start();\n-\n-        Socket  soc = ss.accept();\n-        ss.close();\n-\n-        DataInputStream is = new DataInputStream(soc.getInputStream());\n-        is.close();\n-\n+        System.out.println(\"testClose\");\n+        final InetAddress addr = InetAddress.getLoopbackAddress();\n+        final Socket acceptedSocket;\n+        try (final ServerSocket ss = new ServerSocket(0, 0, addr)) {\n+            System.out.println(\"created server socket: \" + ss);\n+            final int port = ss.getLocalPort();\n+            \/\/ start a thread which initiates a socket connection to the server\n+            Thread.ofPlatform().name(\"Close-Available-1\")\n+                    .start(() -> {\n+                        try {\n+                            final Socket s = new Socket(addr, port);\n+                            System.out.println(\"created socket: \" + s);\n+                            s.close();\n+                            System.out.println(\"closed socket: \" + s);\n+                        } catch (Exception e) {\n+                            System.err.println(\"exception in \" + Thread.currentThread().getName()\n+                                    + \": \" + e);\n+                            e.printStackTrace();\n+                        }\n+                    });\n+            \/\/ accept the client connect\n+            acceptedSocket = ss.accept();\n+            System.out.println(ss + \" accepted connection \" + acceptedSocket);\n+        } \/\/ (intentionally) close the ServerSocket\n+\n+        final DataInputStream is = new DataInputStream(acceptedSocket.getInputStream());\n+        is.close(); \/\/ close the inputstream and thus the underlying socket\n+        System.out.println(\"closed inputstream of socket: \" + acceptedSocket);\n@@ -77,4 +85,7 @@\n-            is.available();\n-        }\n-        catch (IOException ex) {\n-            error = false;\n+            final int av = is.available();\n+            \/\/ available() was expected to fail but didn't\n+            throw new AssertionError(\"Socket.getInputStream().available() was expected to fail on \"\n+                    + acceptedSocket + \" but returned \" + av);\n+        } catch (IOException ex) {\n+            \/\/ expected IOException\n+            System.out.println(\"received the expected IOException: \" + ex);\n@@ -82,2 +93,0 @@\n-        if (error)\n-            throw new RuntimeException(\"Available() can be called after stream closed.\");\n@@ -86,2 +95,4 @@\n-    \/\/ Verifies consistency of `available` behaviour when EOF reached, both\n-    \/\/ explicitly and implicitly.\n+    \/*\n+     * Verifies consistency of Socket.getInputStream().available() behaviour when EOF reached, both\n+     * explicitly and implicitly.\n+     *\/\n@@ -90,19 +101,35 @@\n-        InetAddress addr = InetAddress.getLoopbackAddress();\n-        ServerSocket ss = new ServerSocket();\n-        ss.bind(new InetSocketAddress(addr, 0), 0);\n-        int port = ss.getLocalPort();\n-\n-        try (Socket s = new Socket(addr, port)) {\n-            s.getOutputStream().write(0x42);\n-            s.shutdownOutput();\n-\n-            try (Socket soc = ss.accept()) {\n-                ss.close();\n-\n-                InputStream is = soc.getInputStream();\n-                int b = is.read();\n-                assert b == 0x42;\n-                assert !s.isClosed();\n-                if (readUntilEOF) {\n-                    b = is.read();\n-                    assert b == -1;\n+        final InetAddress addr = InetAddress.getLoopbackAddress();\n+        try (final ServerSocket ss = new ServerSocket()) {\n+            ss.bind(new InetSocketAddress(addr, 0), 0);\n+            System.out.println(\"server socket bound: \" + ss);\n+            final int port = ss.getLocalPort();\n+            try (final Socket s = new Socket(addr, port)) {\n+                System.out.println(\"created socket: \" + s);\n+                s.getOutputStream().write(0x42);\n+                s.shutdownOutput();\n+\n+                try (final Socket soc = ss.accept()) {\n+                    System.out.println(\"accepted socket: \" + soc);\n+                    ss.close();\n+                    System.out.println(\"closed server socket: \" + ss);\n+\n+                    final InputStream is = soc.getInputStream();\n+                    int b = is.read();\n+                    assert b == 0x42 : \"unexpected byte read: \" + b;\n+                    assert !s.isClosed() : \"socket \" + s + \" is unexpectedly closed\";\n+                    if (readUntilEOF) {\n+                        b = is.read();\n+                        assert b == -1 : \"unexpected number of bytes read: \" + b;\n+                    }\n+\n+                    int a;\n+                    for (int i = 0; i < 100; i++) {\n+                        a = is.available();\n+                        System.out.print(a + \", \");\n+                        if (a != 0) {\n+                            throw new RuntimeException(\"Unexpected non-zero available: \" + a);\n+                        }\n+                    }\n+                    assert !s.isClosed() : \"socket \" + s + \" is unexpectedly closed\";\n+                    final int more = is.read();\n+                    assert more == -1 : \"unexpected byte read: \" + more;\n@@ -110,10 +137,0 @@\n-\n-                int a;\n-                for (int i = 0; i < 100; i++) {\n-                    a = is.available();\n-                    System.out.print(a + \", \");\n-                    if (a != 0)\n-                        throw new RuntimeException(\"Unexpected non-zero available: \" + a);\n-                }\n-                assert !s.isClosed();\n-                assert is.read() == -1;\n@@ -125,2 +142,4 @@\n-    \/\/ Verifies IOException thrown by `available`, on a closed input stream\n-    \/\/ that may, or may not, have reached EOF prior to closure.\n+    \/*\n+     * Verifies IOException thrown by Socket.getInputStream().available(), on a closed input stream\n+     * that may, or may not, have reached EOF prior to closure.\n+     *\/\n@@ -129,26 +148,32 @@\n-        InetAddress addr = InetAddress.getLoopbackAddress();\n-        ServerSocket ss = new ServerSocket();\n-        ss.bind(new InetSocketAddress(addr, 0), 0);\n-        int port = ss.getLocalPort();\n-\n-        try (Socket s = new Socket(addr, port)) {\n-            s.getOutputStream().write(0x43);\n-            s.shutdownOutput();\n-\n-            try (Socket soc = ss.accept()) {\n-                ss.close();\n-\n-                InputStream is = soc.getInputStream();\n-                int b = is.read();\n-                assert b == 0x43;\n-                assert !s.isClosed();\n-                if (readUntilEOF) {\n-                    b = is.read();\n-                    assert b == -1;\n-                }\n-                is.close();\n-                try {\n-                    b = is.available();\n-                    throw new RuntimeException(\"UNEXPECTED successful read: \" + b);\n-                } catch (IOException expected) {\n-                    System.out.println(\"caught expected IOException:\" + expected);\n+        final InetAddress addr = InetAddress.getLoopbackAddress();\n+        try (final ServerSocket ss = new ServerSocket()) {\n+            ss.bind(new InetSocketAddress(addr, 0), 0);\n+            System.out.println(\"server socket bound: \" + ss);\n+            final int port = ss.getLocalPort();\n+\n+            try (final Socket s = new Socket(addr, port)) {\n+                System.out.println(\"created socket: \" + s);\n+                s.getOutputStream().write(0x43);\n+                s.shutdownOutput();\n+\n+                try (final Socket soc = ss.accept()) {\n+                    System.out.println(\"accepted socket: \" + soc);\n+                    ss.close();\n+                    System.out.println(\"closed server socket: \" + ss);\n+\n+                    final InputStream is = soc.getInputStream();\n+                    int b = is.read();\n+                    assert b == 0x43 : \"unexpected byte read: \" + b;\n+                    assert !s.isClosed() : \"socket \" + s + \" is unexpectedly closed\";\n+                    if (readUntilEOF) {\n+                        b = is.read();\n+                        assert b == -1 : \"unexpected byte read: \" + b;\n+                    }\n+                    is.close();\n+                    System.out.println(\"closed inputstream of socket: \" + soc);\n+                    try {\n+                        b = is.available();\n+                        throw new RuntimeException(\"UNEXPECTED successful read: \" + b);\n+                    } catch (IOException expected) {\n+                        System.out.println(\"caught expected IOException:\" + expected);\n+                    }\n","filename":"test\/jdk\/java\/net\/Socket\/CloseAvailable.java","additions":116,"deletions":91,"binary":false,"changes":207,"status":"modified"}]}