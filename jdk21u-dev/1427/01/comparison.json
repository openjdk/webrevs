{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,4 @@\n+    \/\/ this will be set to true only when the peer explicitly states (through a GOAWAY frame or\n+    \/\/ a relevant error code in reset frame) that the corresponding stream (id) wasn't processed\n+    private volatile boolean unprocessedByPeer;\n+\n@@ -267,0 +271,9 @@\n+\n+    final boolean isUnprocessedByPeer() {\n+        return this.unprocessedByPeer;\n+    }\n+\n+    \/\/ Marks the exchange as unprocessed by the peer\n+    final void markUnprocessedByPeer() {\n+        this.unprocessedByPeer = true;\n+    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ExchangeImpl.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+\n+import static jdk.internal.net.http.frame.SettingsFrame.INITIAL_CONNECTION_WINDOW_SIZE;\n@@ -292,0 +294,4 @@\n+        \/\/ The min value is the max between the streamWindow and\n+        \/\/ the initial connection window size\n+        int minValue = Math.max(INITIAL_CONNECTION_WINDOW_SIZE, streamWindow);\n+\n@@ -294,1 +300,1 @@\n-                streamWindow, Integer.MAX_VALUE, defaultValue);\n+                minValue, Integer.MAX_VALUE, defaultValue);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2ClientImpl.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -399,0 +400,1 @@\n+    private final AtomicLong lastProcessedStreamInGoAway = new AtomicLong(-1);\n@@ -805,1 +807,3 @@\n-            if (connection.channel().isOpen()) {\n+            \/\/ we send a GOAWAY frame only if the remote side hasn't already indicated\n+            \/\/ the intention to close the connection by previously sending a GOAWAY of its own\n+            if (connection.channel().isOpen() && !isMarked(closedState, HALF_CLOSED_REMOTE)) {\n@@ -1067,0 +1071,28 @@\n+    \/\/ This method is called when a DataFrame that was added\n+    \/\/ to a Stream::inputQ is later dropped from the queue\n+    \/\/ without being consumed.\n+    \/\/\n+    \/\/ Before adding a frame to the queue, the Stream calls\n+    \/\/ connection.windowUpdater.canBufferUnprocessedBytes(), which\n+    \/\/ increases the count of unprocessed bytes in the connection.\n+    \/\/ After consuming the frame, it calls connection.windowUpdater::processed,\n+    \/\/ which decrements the count of unprocessed bytes, and possibly\n+    \/\/ sends a window update to the peer.\n+    \/\/\n+    \/\/ This method is called when connection.windowUpdater::processed\n+    \/\/ will not be called, which can happen when consuming the frame\n+    \/\/ fails, or when an empty DataFrame terminates the stream,\n+    \/\/ or when the stream is cancelled while data is still\n+    \/\/ sitting in its inputQ. In the later case, it is called for\n+    \/\/ each frame that is dropped from the queue.\n+    final void releaseUnconsumed(DataFrame df) {\n+        windowUpdater.released(df.payloadLength());\n+        dropDataFrame(df);\n+    }\n+\n+    \/\/ This method can be called directly when a DataFrame is dropped\n+    \/\/ before\/without having been added to any Stream::inputQ.\n+    \/\/ In that case, the number of unprocessed bytes hasn't been incremented\n+    \/\/ by the stream, and does not need to be decremented.\n+    \/\/ Otherwise, if the frame is dropped after having been added to the\n+    \/\/ inputQ, releaseUnconsumed above should be called.\n@@ -1357,7 +1389,40 @@\n-    private void handleGoAway(GoAwayFrame frame)\n-        throws IOException\n-    {\n-        if (markHalfClosedLRemote()) {\n-            shutdown(new IOException(\n-                    connection.channel().getLocalAddress()\n-                            + \": GOAWAY received\"));\n+    private void handleGoAway(final GoAwayFrame frame) {\n+        final long lastProcessedStream = frame.getLastStream();\n+        assert lastProcessedStream >= 0 : \"unexpected last stream id: \"\n+                + lastProcessedStream + \" in GOAWAY frame\";\n+\n+        markHalfClosedRemote();\n+        setFinalStream(); \/\/ don't allow any new streams on this connection\n+        if (debug.on()) {\n+            debug.log(\"processing incoming GOAWAY with last processed stream id:%s in frame %s\",\n+                    lastProcessedStream, frame);\n+        }\n+        \/\/ see if this connection has previously received a GOAWAY from the peer and if yes\n+        \/\/ then check if this new last processed stream id is lesser than the previous\n+        \/\/ known last processed stream id. Only update the last processed stream id if the new\n+        \/\/ one is lesser than the previous one.\n+        long prevLastProcessed = lastProcessedStreamInGoAway.get();\n+        while (prevLastProcessed == -1 || lastProcessedStream < prevLastProcessed) {\n+            if (lastProcessedStreamInGoAway.compareAndSet(prevLastProcessed,\n+                    lastProcessedStream)) {\n+                break;\n+            }\n+            prevLastProcessed = lastProcessedStreamInGoAway.get();\n+        }\n+        handlePeerUnprocessedStreams(lastProcessedStreamInGoAway.get());\n+    }\n+\n+    private void handlePeerUnprocessedStreams(final long lastProcessedStream) {\n+        final AtomicInteger numClosed = new AtomicInteger(); \/\/ atomic merely to allow usage within lambda\n+        streams.forEach((id, exchange) -> {\n+            if (id > lastProcessedStream) {\n+                \/\/ any streams with an stream id higher than the last processed stream\n+                \/\/ can be retried (on a new connection). we close the exchange as unprocessed\n+                \/\/ to facilitate the retrying.\n+                client2.client().theExecutor().ensureExecutedAsync(exchange::closeAsUnprocessed);\n+                numClosed.incrementAndGet();\n+            }\n+        });\n+        if (debug.on()) {\n+            debug.log(numClosed.get() + \" stream(s), with id greater than \" + lastProcessedStream\n+                    + \", will be closed as unprocessed\");\n@@ -1419,2 +1484,3 @@\n-        final int len = windowUpdater.initialWindowSize - DEFAULT_INITIAL_WINDOW_SIZE;\n-        if (len != 0) {\n+        final int len = windowUpdater.initialWindowSize - INITIAL_CONNECTION_WINDOW_SIZE;\n+        assert len >= 0;\n+        if (len > 0) {\n@@ -1423,1 +1489,1 @@\n-                        len, windowUpdater.initialWindowSize, DEFAULT_INITIAL_WINDOW_SIZE);\n+                        len, windowUpdater.initialWindowSize, INITIAL_CONNECTION_WINDOW_SIZE);\n@@ -1877,0 +1943,13 @@\n+\n+        @Override\n+        protected boolean windowSizeExceeded(long received) {\n+            if (connection.isOpen()) {\n+                try {\n+                    connection.protocolError(ErrorFrame.FLOW_CONTROL_ERROR,\n+                            \"connection window exceeded\");\n+                } catch (IOException io) {\n+                    connection.shutdown(io);\n+                }\n+            }\n+            return true;\n+        }\n@@ -1914,1 +1993,1 @@\n-    private boolean markHalfClosedLRemote() {\n+    private boolean markHalfClosedRemote() {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":91,"deletions":12,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-    static void registerPending(PendingRequest pending) {\n+    static <T> CompletableFuture<T> registerPending(PendingRequest pending, CompletableFuture<T> res) {\n@@ -288,1 +288,1 @@\n-        if (pending.cf.isDone()) return;\n+        if (pending.cf.isDone()) return res;\n@@ -295,1 +295,2 @@\n-        pending.ref = cf.whenComplete((r,t) -> client.pendingRequests.remove(pending));\n+        var ref = res.whenComplete((r,t) -> client.pendingRequests.remove(pending));\n+        pending.ref = ref;\n@@ -302,0 +303,1 @@\n+        return ref;\n@@ -578,0 +580,1 @@\n+                        return true;\n@@ -579,1 +582,1 @@\n-                    return true;\n+                    return false;\n@@ -933,1 +936,1 @@\n-            if (cf != null )\n+            if (cf != null) {\n@@ -935,0 +938,1 @@\n+            }\n@@ -1056,7 +1060,0 @@\n-            \/\/ makes sure that any dependent actions happen in the CF default\n-            \/\/ executor. This is only needed for sendAsync(...), when\n-            \/\/ exchangeExecutor is non-null.\n-            if (exchangeExecutor != null) {\n-                res = res.whenCompleteAsync((r, t) -> { \/* do nothing *\/}, ASYNC_POOL);\n-            }\n-\n@@ -1066,3 +1063,14 @@\n-            registerPending(pending);\n-            return res;\n-        } catch(Throwable t) {\n+            res = registerPending(pending, res);\n+\n+            if (exchangeExecutor != null) {\n+                \/\/ makes sure that any dependent actions happen in the CF default\n+                \/\/ executor. This is only needed for sendAsync(...), when\n+                \/\/ exchangeExecutor is non-null.\n+                return res.isDone() ? res\n+                        : res.whenCompleteAsync((r, t) -> { \/* do nothing *\/}, ASYNC_POOL);\n+            } else {\n+                \/\/ make a defensive copy that can be safely canceled\n+                \/\/ by the caller\n+                return res.isDone() ? res : res.copy();\n+            }\n+        } catch (Throwable t) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":23,"deletions":15,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,2 +93,2 @@\n-    volatile boolean expiredOnce;\n-    volatile HttpResponse<T> response = null;\n+    volatile boolean retriedOnce;\n+    volatile HttpResponse<T> response;\n@@ -282,0 +282,1 @@\n+        boolean firstCancel = false;\n@@ -284,1 +285,1 @@\n-                interrupted.compareAndSet(null,\n+                firstCancel = interrupted.compareAndSet(null,\n@@ -287,0 +288,7 @@\n+            if (debug.on()) {\n+                if (firstCancel) {\n+                    debug.log(\"multi exchange recording: \" + interrupted.get());\n+                } else {\n+                    debug.log(\"multi exchange recorded: \" + interrupted.get());\n+                }\n+            }\n@@ -368,0 +376,16 @@\n+    \/\/ returns a CancellationExcpetion that wraps the given cause\n+    \/\/ if cancel(boolean) was called, the given cause otherwise\n+    private Throwable wrapIfCancelled(Throwable cause) {\n+        CancellationException interrupt = interrupted.get();\n+        if (interrupt == null) return cause;\n+\n+        var cancel = new CancellationException(interrupt.getMessage());\n+        \/\/ preserve the stack trace of the original exception to\n+        \/\/ show where the call to cancel(boolean) came from\n+        cancel.setStackTrace(interrupt.getStackTrace());\n+        cancel.initCause(Utils.getCancelCause(cause));\n+        return cancel;\n+    }\n+\n+    \/\/ if the request failed because the multi exchange was cancelled,\n+    \/\/ make sure the reported exception is wrapped in CancellationException\n@@ -369,5 +393,2 @@\n-        CancellationException x = interrupted.get();\n-        if (x != null) {\n-            \/\/ make sure to fail with CancellationException if cancel(true)\n-            \/\/ was called.\n-            t = x.initCause(Utils.getCancelCause(t));\n+        var x = wrapIfCancelled(t);\n+        if (x instanceof CancellationException) {\n@@ -375,1 +396,1 @@\n-                debug.log(\"MultiExchange interrupted with: \" + t.getCause());\n+                debug.log(\"MultiExchange interrupted with: \" + x.getCause());\n@@ -378,1 +399,1 @@\n-        return MinimalFuture.failedFuture(t);\n+        return MinimalFuture.failedFuture(x);\n@@ -441,1 +462,1 @@\n-                                expiredOnce = false;\n+                                retriedOnce = false;\n@@ -454,1 +475,1 @@\n-                        CompletableFuture<Response> errorCF = getExceptionalCF(ex);\n+                        CompletableFuture<Response> errorCF = getExceptionalCF(ex, exch.exchImpl);\n@@ -526,1 +547,1 @@\n-    private CompletableFuture<Response> getExceptionalCF(Throwable t) {\n+    private CompletableFuture<Response> getExceptionalCF(Throwable t, ExchangeImpl<?> exchImpl) {\n@@ -532,0 +553,1 @@\n+        final boolean retryAsUnprocessed = exchImpl != null && exchImpl.isUnprocessedByPeer();\n@@ -536,1 +558,1 @@\n-        } else if (retryOnFailure(t)) {\n+        } else if (retryAsUnprocessed || retryOnFailure(t)) {\n@@ -543,2 +565,4 @@\n-                if (!canRetryRequest(currentreq)) {\n-                    return failedFuture(cause); \/\/ fails with original cause\n+                if (!retryAsUnprocessed && !canRetryRequest(currentreq)) {\n+                    \/\/ a (peer) processed request which cannot be retried, fail with\n+                    \/\/ the original cause\n+                    return failedFuture(cause);\n@@ -550,1 +574,1 @@\n-            if (!expiredOnce) {\n+            if (!retriedOnce) {\n@@ -552,2 +576,3 @@\n-                    debug.log(t.getClass().getSimpleName() + \" (async): retrying...\", t);\n-                expiredOnce = true;\n+                    debug.log(t.getClass().getSimpleName()\n+                            + \" (async): retrying \" + currentreq + \" due to: \", t);\n+                retriedOnce = true;\n@@ -564,1 +589,1 @@\n-                            + \" (async): already retried once.\", t);\n+                            + \" (async): already retried once \" + currentreq, t);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/MultiExchange.java","additions":46,"deletions":21,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -163,1 +163,0 @@\n-\n@@ -170,1 +169,1 @@\n-    private final WindowUpdateSender windowUpdater;\n+    private final WindowUpdateSender streamWindowUpdater;\n@@ -194,1 +193,1 @@\n-            while (!inputQ.isEmpty()) {\n+            while (!inputQ.isEmpty() && errorRef.get() == null) {\n@@ -209,1 +208,2 @@\n-                    connection.ensureWindowUpdated(df); \/\/ must update connection window\n+                    \/\/ consumed will not be called\n+                    connection.releaseUnconsumed(df); \/\/ must update connection window\n@@ -225,1 +225,5 @@\n-                        connection.dropDataFrame(df); \/\/ must update connection window\n+                        \/\/ Data frames that have been added to the inputQ\n+                        \/\/ must be released using releaseUnconsumed() to\n+                        \/\/ account for the amount of unprocessed bytes\n+                        \/\/ tracked by the connection.windowUpdater.\n+                        connection.releaseUnconsumed(df);\n@@ -277,2 +281,6 @@\n-            if (frame instanceof DataFrame) {\n-                connection.dropDataFrame((DataFrame)frame);\n+            if (frame instanceof DataFrame df) {\n+                \/\/ Data frames that have been added to the inputQ\n+                \/\/ must be released using releaseUnconsumed() to\n+                \/\/ account for the amount of unprocessed bytes\n+                \/\/ tracked by the connection.windowUpdater.\n+                connection.releaseUnconsumed(df);\n@@ -304,2 +312,1 @@\n-        connection.windowUpdater.update(len);\n-\n+        connection.windowUpdater.processed(len);\n@@ -307,0 +314,2 @@\n+            streamWindowUpdater.processed(len);\n+        } else {\n@@ -309,1 +318,1 @@\n-            windowUpdater.update(len);\n+            streamWindowUpdater.released(len);\n@@ -379,2 +388,15 @@\n-        inputQ.add(df);\n-        sched.runOrSchedule();\n+        try {\n+            int len = df.payloadLength();\n+            if (len > 0) {\n+                \/\/ we return from here if the connection is being closed.\n+                if (!connection.windowUpdater.canBufferUnprocessedBytes(len)) return;\n+                \/\/ we return from here if the stream is being closed.\n+                if (closed || !streamWindowUpdater.canBufferUnprocessedBytes(len)) {\n+                    connection.releaseUnconsumed(df);\n+                    return;\n+                }\n+            }\n+            inputQ.add(df);\n+        } finally {\n+            sched.runOrSchedule();\n+        }\n@@ -428,0 +450,4 @@\n+        \/\/ ensure that the body subscriber will be subscribed and onError() is\n+        \/\/ invoked\n+        pendingResponseSubscriber = bodySubscriber;\n+\n@@ -438,3 +464,0 @@\n-        \/\/ ensure that the body subscriber will be subscribed and onError() is\n-        \/\/ invoked\n-        pendingResponseSubscriber = bodySubscriber;\n@@ -463,1 +486,1 @@\n-        this.windowUpdater = new StreamWindowUpdateSender(connection);\n+        this.streamWindowUpdater = new StreamWindowUpdateSender(connection);\n@@ -497,0 +520,2 @@\n+                \/\/ Data frames that have not been added to the inputQ\n+                \/\/ can be released using dropDataFrame\n@@ -675,6 +700,24 @@\n-                int error = frame.getErrorCode();\n-                IOException e = new IOException(\"Received RST_STREAM: \"\n-                        + ErrorFrame.stringForCode(error));\n-                if (errorRef.compareAndSet(null, e)) {\n-                    if (subscriber != null) {\n-                        subscriber.onError(e);\n+                final int error = frame.getErrorCode();\n+                \/\/ A REFUSED_STREAM error code implies that the stream wasn't processed by the\n+                \/\/ peer and the client is free to retry the request afresh.\n+                if (error == ErrorFrame.REFUSED_STREAM) {\n+                    \/\/ Here we arrange for the request to be retried. Note that we don't call\n+                    \/\/ closeAsUnprocessed() method here because the \"closed\" state is already set\n+                    \/\/ to true a few lines above and calling close() from within\n+                    \/\/ closeAsUnprocessed() will end up being a no-op. We instead do the additional\n+                    \/\/ bookkeeping here.\n+                    markUnprocessedByPeer();\n+                    errorRef.compareAndSet(null, new IOException(\"request not processed by peer\"));\n+                    if (debug.on()) {\n+                        debug.log(\"request unprocessed by peer (REFUSED_STREAM) \" + this.request);\n+                    }\n+                } else {\n+                    final String reason = ErrorFrame.stringForCode(error);\n+                    final IOException failureCause = new IOException(\"Received RST_STREAM: \" + reason);\n+                    if (debug.on()) {\n+                        debug.log(streamid + \" received RST_STREAM with code: \" + reason);\n+                    }\n+                    if (errorRef.compareAndSet(null, failureCause)) {\n+                        if (subscriber != null) {\n+                            subscriber.onError(failureCause);\n+                        }\n@@ -683,1 +726,2 @@\n-                completeResponseExceptionally(e);\n+                final Throwable failureCause = errorRef.get();\n+                completeResponseExceptionally(failureCause);\n@@ -685,1 +729,1 @@\n-                    requestBodyCF.completeExceptionally(errorRef.get()); \/\/ we may be sending the body..\n+                    requestBodyCF.completeExceptionally(failureCause); \/\/ we may be sending the body..\n@@ -688,1 +732,1 @@\n-                    responseBodyCF.completeExceptionally(errorRef.get());\n+                    responseBodyCF.completeExceptionally(failureCause);\n@@ -1380,0 +1424,4 @@\n+        onProtocolError(cause, ResetFrame.PROTOCOL_ERROR);\n+    }\n+\n+    void onProtocolError(final IOException cause, int code) {\n@@ -1381,1 +1429,3 @@\n-            debug.log(\"cancelling exchange on stream %d due to protocol error: %s\", streamid, cause.getMessage());\n+            debug.log(\"cancelling exchange on stream %d due to protocol error [%s]: %s\",\n+                    streamid, ErrorFrame.stringForCode(code),\n+                    cause.getMessage());\n@@ -1385,1 +1435,1 @@\n-        cancelImpl(cause, ResetFrame.PROTOCOL_ERROR);\n+        cancelImpl(cause, code);\n@@ -1682,0 +1732,7 @@\n+\n+        @Override\n+        protected boolean windowSizeExceeded(long received) {\n+            onProtocolError(new ProtocolException(\"stream %s flow control window exceeded\"\n+                            .formatted(streamid)), ResetFrame.FLOW_CONTROL_ERROR);\n+            return true;\n+        }\n@@ -1701,1 +1758,29 @@\n-        return connection.dbgString() + \"\/Stream(\"+streamid+\")\";\n+        final int id = streamid;\n+        final String sid = id == 0 ? \"?\" : String.valueOf(id);\n+        return connection.dbgString() + \"\/Stream(\" + sid + \")\";\n+    }\n+\n+    \/**\n+     * An unprocessed exchange is one that hasn't been processed by a peer. The local end of the\n+     * connection would be notified about such exchanges when it receives a GOAWAY frame with\n+     * a stream id that tells which exchanges have been unprocessed.\n+     * This method is called on such unprocessed exchanges and the implementation of this method\n+     * will arrange for the request, corresponding to this exchange, to be retried afresh on a\n+     * new connection.\n+     *\/\n+    void closeAsUnprocessed() {\n+        try {\n+            \/\/ We arrange for the request to be retried on a new connection as allowed by the RFC-9113\n+            markUnprocessedByPeer();\n+            this.errorRef.compareAndSet(null, new IOException(\"request not processed by peer\"));\n+            if (debug.on()) {\n+                debug.log(\"closing \" + this.request + \" as unprocessed by peer\");\n+            }\n+            \/\/ close the exchange and complete the response CF exceptionally\n+            close();\n+            completeResponseExceptionally(this.errorRef.get());\n+        } finally {\n+            \/\/ decrementStreamsCount isn't really needed but we do it to make sure\n+            \/\/ the log messages, where these counts\/states get reported, show the accurate state.\n+            connection.decrementStreamsCount(streamid);\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":113,"deletions":28,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,6 @@\n-            \/\/ Odd stream numbers (client streams) should have been registered.\n+            \/\/ A client initiated stream might be closed (as unprocessed, due to a\n+            \/\/ GOAWAY received on the connection) even before the stream is\n+            \/\/ registered with this WindowController instance (when sending out request headers).\n+            \/\/ Thus, for client initiated streams, we don't enforce the presence of the\n+            \/\/ stream in the registered \"streams\" map.\n+\n@@ -107,3 +112,1 @@\n-            if (old == null && isClientStream) {\n-                throw new InternalError(\"Expected entry for streamid: \" + streamid);\n-            } else if (old != null && !isClientStream) {\n+            if (old != null && !isClientStream) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/WindowController.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -36,0 +37,4 @@\n+\/**\n+ * A class that tracks the amount of flow controlled\n+ * data received on an HTTP\/2 connection\n+ *\/\n@@ -41,0 +46,1 @@\n+    \/\/ The threshold at which window updates are sent in bytes\n@@ -42,0 +48,2 @@\n+    \/\/ The flow control window in bytes\n+    final int windowSize;\n@@ -43,1 +51,8 @@\n-    final AtomicInteger received = new AtomicInteger();\n+    \/\/ The amount of flow controlled data received and processed, in bytes,\n+    \/\/ since the start of the window.\n+    \/\/ The window is exhausted when received + unprocessed >= windowSize\n+    final AtomicLong received = new AtomicLong();\n+    \/\/ The amount of flow controlled data received and unprocessed, in bytes,\n+    \/\/ since the start of the window.\n+    \/\/ The window is exhausted when received + unprocessed >= windowSize\n+    final AtomicLong unprocessed = new AtomicLong();\n@@ -56,0 +71,1 @@\n+        this.windowSize = initWindowSize;\n@@ -69,0 +85,1 @@\n+    \/\/ O for the connection window, > 0 for a stream window\n@@ -71,0 +88,99 @@\n+\n+    \/**\n+     * {@return {@code true} if buffering the given amount of\n+     * flow controlled data would not exceed the flow control\n+     * window}\n+     * <p>\n+     * This method is called before buffering and processing\n+     * a DataFrame. The count of unprocessed bytes is incremented\n+     * by the given amount, and checked against the number of\n+     * available bytes in the flow control window.\n+     * <p>\n+     * This method returns {@code true} if the bytes can be buffered\n+     * without exceeding the flow control window, {@code false}\n+     * if the flow control window is exceeded and corrective\n+     * action (close\/reset) has been taken.\n+     * <p>\n+     * When this method returns true, either {@link #processed(int)}\n+     * or {@link #released(int)} must eventually be called to release\n+     * the bytes from the flow control window.\n+     *\n+     * @implSpec\n+     * an HTTP\/2 endpoint may disable its own flow control\n+     * (see <a href=\"https:\/\/www.rfc-editor.org\/rfc\/rfc9113.html#section-5.2.1\">\n+     *     RFC 9113, section 5.2.1<\/a>), in which case this\n+     * method may return true even if the flow control window would\n+     * be exceeded: that is, the flow control window is exceeded but\n+     * the endpoint decided to take no corrective action.\n+     *\n+     * @param  len a number of unprocessed bytes, which\n+     *             the caller wants to buffer.\n+     *\/\n+    boolean canBufferUnprocessedBytes(int len) {\n+        return !checkWindowSizeExceeded(unprocessed.addAndGet(len));\n+    }\n+\n+    \/\/ adds the provided amount to the amount of already\n+    \/\/ received and processed bytes and checks whether the\n+    \/\/ flow control window is exceeded. If so, take\n+    \/\/ corrective actions and return true.\n+    private boolean checkWindowSizeExceeded(long len) {\n+        \/\/ because windowSize is bound by Integer.MAX_VALUE\n+        \/\/ we will never reach the point where received.get() + len\n+        \/\/ could overflow\n+        long rcv = received.get() + len;\n+        return rcv > windowSize && windowSizeExceeded(rcv);\n+    }\n+\n+    \/**\n+     * Called after unprocessed buffered bytes have been\n+     * processed, to release part of the flow control window\n+     *\n+     * @apiNote this method is called only when releasing bytes\n+     * that where buffered after calling\n+     * {@link #canBufferUnprocessedBytes(int)}.\n+     *\n+     * @param delta the amount of processed bytes to release\n+     *\/\n+    void processed(int delta) {\n+        long rest = unprocessed.addAndGet(-delta);\n+        assert rest >= 0;\n+        update(delta);\n+    }\n+\n+    \/**\n+     * Called when it is desired to release unprocessed bytes\n+     * without processing them, or without triggering the\n+     * sending of a window update. This method can be called\n+     * instead of calling {@link #processed(int)}.\n+     * When this method is called instead of calling {@link #processed(int)},\n+     * it should generally be followed by a call to {@link #update(int)},\n+     * unless the stream or connection is being closed.\n+     *\n+     * @apiNote this method should only be called to release bytes that\n+     * have been buffered after calling {@link\n+     * #canBufferUnprocessedBytes(int)}.\n+     *\n+     * @param delta the amount of bytes to release from the window\n+     *\n+     * @return the amount of remaining unprocessed bytes\n+     *\/\n+    long released(int delta) {\n+        long rest = unprocessed.addAndGet(-delta);\n+        assert rest >= 0;\n+        return rest;\n+    }\n+\n+    \/**\n+     * This method is called to update the flow control window,\n+     * and possibly send a window update\n+     *\n+     * @apiNote this method can be called directly if a frame is\n+     * dropped before calling {@link #canBufferUnprocessedBytes(int)}.\n+     * Otherwise, either {@link #processed(int)} or {@link #released(int)}\n+     * should be called, depending on whether sending a window update\n+     * is desired or not. It is typically not desired to send an update\n+     * if the stream or connection is being closed.\n+     *\n+     * @param delta the amount of bytes released from the window.\n+     *\/\n@@ -72,1 +188,1 @@\n-        int rcv = received.addAndGet(delta);\n+        long rcv = received.addAndGet(delta);\n@@ -74,0 +190,3 @@\n+        if (rcv > windowSize && windowSizeExceeded(rcv)) {\n+            return;\n+        }\n@@ -77,2 +196,2 @@\n-                int tosend = received.get();\n-                if( tosend > limit) {\n+                int tosend = (int)Math.min(received.get(), Integer.MAX_VALUE);\n+                if (tosend > limit) {\n@@ -90,0 +209,1 @@\n+        assert delta > 0 : \"illegal window update delta: \" + delta;\n@@ -107,0 +227,12 @@\n+    \/**\n+     * Called when the flow control window size is exceeded\n+     * This method may return false if flow control is disabled\n+     * in this endpoint.\n+     *\n+     * @param received the amount of data received, which is greater\n+     *                 than {@code windowSize}\n+     * @return {@code true} if the error was reported to the peer\n+     *         and no further window update should be sent.\n+     *\/\n+    protected abstract boolean windowSizeExceeded(long received);\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/WindowUpdateSender.java","additions":137,"deletions":5,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -466,0 +466,10 @@\n+                if (id == SettingsFrame.INITIAL_WINDOW_SIZE && val < 0) {\n+                    return new MalformedFrame(ErrorFrame.FLOW_CONTROL_ERROR,\n+                            \"SettingsFrame with INITIAL_WINDOW_SIZE > 2^31 -1: \"\n+                                    + (val & 0xffffffffL));\n+                }\n+                if (id == SettingsFrame.MAX_FRAME_SIZE && (val < 16384 || val > 16777215)) {\n+                    return new MalformedFrame(ErrorFrame.PROTOCOL_ERROR,\n+                            \"SettingsFrame with MAX_FRAME_SIZE out of range: \"\n+                                    + (val & 0xffffffffL));\n+                }\n@@ -533,1 +543,6 @@\n-        return new WindowUpdateFrame(streamid, getInt() & 0x7fffffff);\n+        int update = getInt();\n+        if (update < 0) {\n+            return new MalformedFrame(ErrorFrame.FLOW_CONTROL_ERROR,\n+                    \"WindowUpdateFrame with value > 2^31 -1 \" + (update & 0xffffffffL));\n+        }\n+        return new WindowUpdateFrame(streamid, update & 0x7fffffff);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/frame\/FramesDecoder.java","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,3 @@\n-        return super.toString() + \" Debugdata: \" + new String(debugData, UTF_8);\n+        return super.toString()\n+                + \" lastStreamId=\" + lastStream\n+                + \", Debugdata: \" + new String(debugData, UTF_8);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/frame\/GoAwayFrame.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,0 +169,5 @@\n+    \/\/ Initial connection window size. This cannot be updated using the\n+    \/\/ SETTINGS frame.\n+    public static final int INITIAL_CONNECTION_WINDOW_SIZE = DEFAULT_INITIAL_WINDOW_SIZE;\n+\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/frame\/SettingsFrame.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -60,3 +60,5 @@\n- * The HTTP\/2 client connection window size in bytes. The maximum size is 2^31-1. This value\n- * cannot be smaller than the stream window size, which can be configured through the\n- * {@code jdk.httpclient.windowsize} system property.\n+ * The HTTP\/2 client connection window size in bytes. Valid values are in the range\n+ * [2^16-1, 2^31-1]. If an invalid value is provided, the default value is used.\n+ * The implementation guarantees that the actual value will be no smaller than the stream\n+ * window size, which can be configured through the {@code jdk.httpclient.windowsize}\n+ * system property.\n@@ -153,1 +155,2 @@\n- * The HTTP\/2 client stream window size in bytes.\n+ * The HTTP\/2 client stream window size in bytes. Valid values are in the range [2^14, 2^31-1].\n+ * If an invalid value is provided, the default value is used.\n","filename":"src\/java.net.http\/share\/classes\/module-info.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -477,0 +477,1 @@\n+            var tracker = TRACKER.getTracker(client);\n@@ -485,1 +486,0 @@\n-                var tracker = TRACKER.getTracker(client);\n@@ -494,0 +494,8 @@\n+            } else {\n+                System.out.println(now() + \"waiting for operation to finish: \" + tracker.getName());\n+                System.err.println(now() + \"waiting for operation to finish: \" + tracker.getName());\n+                var error = TRACKER.checkFinished(tracker, 10000);\n+                if (error != null) throw error;\n+                System.out.println(now() + \"operation finished normally: \" + tracker.getName());\n+                System.err.println(now() + \"operation finished normally: \" + tracker.getName());\n+\n@@ -803,1 +811,1 @@\n-        AssertionError fail = TRACKER.check(500);\n+        AssertionError fail = TRACKER.check(5000);\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractThrowingSubscribers.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @build jdk.test.lib.net.SimpleSSLContext jdk.httpclient.test.lib.common.HttpServerAdapters\n+ * @build jdk.test.lib.net.SimpleSSLContext jdk.httpclient.test.lib.common.HttpServerAdapters ReferenceTracker\n","filename":"test\/jdk\/java\/net\/httpclient\/GZIPInputStreamTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,391 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import jdk.internal.net.http.common.OperationTrackers.Tracker;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8316580\n+ * @library \/test\/lib\n+ * @run junit\/othervm -Djdk.tracePinnedThreads=full\n+ *                   -DuseReferenceTracker=false\n+ *                   HttpGetInCancelledFuture\n+ * @run junit\/othervm -Djdk.tracePinnedThreads=full\n+ *                   -DuseReferenceTracker=true\n+ *                   HttpGetInCancelledFuture\n+ * @summary This test verifies that cancelling a future that\n+ * does an HTTP request using the HttpClient doesn't cause\n+ * HttpClient::close to block forever.\n+ *\/\n+public class HttpGetInCancelledFuture {\n+\n+    static final boolean useTracker = Boolean.getBoolean(\"useReferenceTracker\");\n+\n+    static final class TestException extends RuntimeException {\n+        public TestException(String message, Throwable cause) {\n+            super(message, cause);\n+        }\n+    }\n+\n+    static ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+\n+    HttpClient makeClient(URI uri, Version version, Executor executor) {\n+        var builder = HttpClient.newBuilder();\n+        if (uri.getScheme().equalsIgnoreCase(\"https\")) {\n+            try {\n+                builder.sslContext(new SimpleSSLContext().get());\n+            } catch (IOException io) {\n+                throw new UncheckedIOException(io);\n+            }\n+        }\n+        return builder.connectTimeout(Duration.ofSeconds(1))\n+                .executor(executor)\n+                .version(version)\n+                .build();\n+    }\n+\n+    record TestCase(String url, int reqCount, Version version) {}\n+    \/\/ A server that doesn't accept\n+    static volatile ServerSocket NOT_ACCEPTING;\n+\n+    static List<TestCase> parameters() {\n+        ServerSocket ss = NOT_ACCEPTING;\n+        if (ss == null) {\n+            synchronized (HttpGetInCancelledFuture.class) {\n+                if ((ss = NOT_ACCEPTING) == null) {\n+                    try {\n+                        ss = new ServerSocket();\n+                        var loopback = InetAddress.getLoopbackAddress();\n+                        ss.bind(new InetSocketAddress(loopback, 0), 10);\n+                        NOT_ACCEPTING = ss;\n+                    } catch (IOException io) {\n+                        throw new UncheckedIOException(io);\n+                    }\n+                }\n+            }\n+        }\n+        URI http = URIBuilder.newBuilder()\n+                .loopback()\n+                .scheme(\"http\")\n+                .port(ss.getLocalPort())\n+                .path(\"\/not-accepting\/\")\n+                .buildUnchecked();\n+        URI https = URIBuilder.newBuilder()\n+                .loopback()\n+                .scheme(\"https\")\n+                .port(ss.getLocalPort())\n+                .path(\"\/not-accepting\/\")\n+                .buildUnchecked();\n+        \/\/ use all HTTP versions, without and with TLS\n+        return List.of(\n+                new TestCase(http.toString(), 200, Version.HTTP_2),\n+                new TestCase(http.toString(), 200, Version.HTTP_1_1),\n+                new TestCase(https.toString(), 200, Version.HTTP_2),\n+                new TestCase(https.toString(), 200, Version.HTTP_1_1)\n+                );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"parameters\")\n+    void runTest(TestCase test) {\n+        System.out.println(\"Testing with: \" + test);\n+        runTest(test.url, test.reqCount, test.version);\n+    }\n+\n+    static class TestTaskScope implements AutoCloseable {\n+        final ExecutorService pool = new ForkJoinPool();\n+        final Map<Task<?>, Future<?>> tasks = new ConcurrentHashMap<>();\n+        final AtomicReference<ExecutionException> failed = new AtomicReference<>();\n+\n+        class Task<T> implements Callable<T> {\n+            final Callable<T> task;\n+            final CompletableFuture<T> cf = new CompletableFuture<>();\n+            Task(Callable<T> task) {\n+                this.task = task;\n+            }\n+            @Override\n+            public T call() throws Exception {\n+                try {\n+                    var res = task.call();\n+                    cf.complete(res);\n+                    return res;\n+                } catch (Throwable t) {\n+                    cf.completeExceptionally(t);\n+                    throw t;\n+                }\n+            }\n+            CompletableFuture<T> cf() {\n+                return cf;\n+            }\n+        }\n+\n+\n+        static class ShutdownOnFailure extends TestTaskScope {\n+            public ShutdownOnFailure() {}\n+\n+            @Override\n+            protected <T> void completed(Task<T> task, T result, Throwable throwable) {\n+                super.completed(task, result, throwable);\n+                if (throwable != null) {\n+                    if (failed.get() == null) {\n+                        ExecutionException ex = throwable instanceof ExecutionException x\n+                                ? x : new ExecutionException(throwable);\n+                        failed.compareAndSet(null, ex);\n+                    }\n+                    tasks.entrySet().forEach(this::cancel);\n+                }\n+            }\n+\n+            void cancel(Map.Entry<Task<?>, Future<?>> entry) {\n+                entry.getValue().cancel(true);\n+                entry.getKey().cf().cancel(true);\n+                tasks.remove(entry.getKey(), entry.getValue());\n+            }\n+\n+            @Override\n+            public <T> CompletableFuture<T> fork(Callable<T> callable) {\n+                var ex = failed.get();\n+                if (ex == null) {\n+                    return super.fork(callable);\n+                } \/\/ otherwise do nothing\n+                return CompletableFuture.failedFuture(new RejectedExecutionException());\n+            }\n+        }\n+\n+        public <T> CompletableFuture<T> fork(Callable<T> callable) {\n+            var task = new Task<>(callable);\n+            var res = pool.submit(task);\n+            tasks.put(task, res);\n+            task.cf.whenComplete((r,t) -> completed(task, r, t));\n+            return task.cf;\n+        }\n+\n+        protected <T> void completed(Task<T> task, T result, Throwable throwable) {\n+            tasks.remove(task);\n+        }\n+\n+        public void join() throws InterruptedException {\n+            try {\n+                var cfs = tasks.keySet().stream()\n+                        .map(Task::cf).toArray(CompletableFuture[]::new);\n+                CompletableFuture.allOf(cfs).get();\n+            } catch (InterruptedException it) {\n+                throw it;\n+            } catch (ExecutionException ex) {\n+                failed.compareAndSet(null, ex);\n+            }\n+        }\n+\n+        public void throwIfFailed() throws ExecutionException {\n+            ExecutionException x = failed.get();\n+            if (x != null) throw x;\n+        }\n+\n+        public void close() {\n+            pool.close();\n+        }\n+    }\n+\n+    ExecutorService testExecutor() {\n+        return Executors.newCachedThreadPool();\n+    }\n+\n+    void runTest(String url, int reqCount, Version version) {\n+        final var dest = URI.create(url);\n+        try (final var executor = testExecutor()) {\n+            var httpClient = makeClient(dest, version, executor);\n+            TRACKER.track(httpClient);\n+            Tracker tracker = TRACKER.getTracker(httpClient);\n+            Throwable failed = null;\n+            try {\n+                try (final var scope = new TestTaskScope.ShutdownOnFailure()) {\n+                    launchAndProcessRequests(scope, httpClient, reqCount, dest);\n+                } finally {\n+                    System.out.printf(\"StructuredTaskScope closed: STARTED=%s, SUCCESS=%s, INTERRUPT=%s, FAILED=%s%n\",\n+                            STARTED.get(), SUCCESS.get(), INTERRUPT.get(), FAILED.get());\n+                }\n+                System.out.println(\"ERROR: Expected TestException not thrown\");\n+                throw new AssertionError(\"Expected TestException not thrown\");\n+            } catch (TestException x) {\n+                System.out.println(\"Got expected exception: \" + x);\n+            } catch (Throwable t) {\n+                System.out.println(\"ERROR: Unexpected exception: \" + t);\n+                failed = t;\n+                throw t;\n+            } finally {\n+                \/\/ we can either use the tracker or call HttpClient::close\n+                if (useTracker) {\n+                    \/\/ using the tracker depends on GC but will give us some diagnostic\n+                    \/\/ if some operations are not properly cancelled and prevent the client\n+                    \/\/ from terminating\n+                    httpClient = null;\n+                    System.gc();\n+                    System.out.println(TRACKER.diagnose(tracker));\n+                    var error = TRACKER.check(tracker, 10000);\n+                    if (error != null) {\n+                        if (failed != null) error.addSuppressed(failed);\n+                        EXCEPTIONS.forEach(x -> {\n+                            System.out.println(\"FAILED: \" + x);\n+                        });\n+                        EXCEPTIONS.forEach(x -> {\n+                            x.printStackTrace(System.out);\n+                        });\n+                        throw error;\n+                    }\n+                } else {\n+                    \/\/ if not all operations terminate, close() will block\n+                    \/\/ forever and the test will fail in jtreg timeout.\n+                    \/\/ there will be no diagnostic.\n+                    httpClient.close();\n+                }\n+                System.out.println(\"HttpClient closed\");\n+            }\n+        } finally {\n+            System.out.println(\"ThreadExecutor closed\");\n+        }\n+        \/\/ not all tasks may have been started before the scope was cancelled\n+        \/\/ due to the first connect\/timeout exception, but all tasks that started\n+        \/\/ must have either succeeded, be interrupted, or failed\n+        assertTrue(STARTED.get() > 0);\n+        assertEquals(STARTED.get(), SUCCESS.get() + INTERRUPT.get() + FAILED.get());\n+        if (SUCCESS.get() > 0) {\n+            \/\/ we don't expect any server to be listening and responding\n+            System.out.println(\"WARNING: got some unexpected successful responses from \"\n+                    + \"\\\"\" + NOT_ACCEPTING.getLocalSocketAddress() + \"\\\": \" + SUCCESS.get());\n+        }\n+    }\n+\n+    private void launchAndProcessRequests(\n+            TestTaskScope.ShutdownOnFailure scope,\n+            HttpClient httpClient,\n+            int reqCount,\n+            URI dest) {\n+        for (int counter = 0; counter < reqCount; counter++) {\n+            scope.fork(() ->\n+                    getAndCheck(httpClient, dest)\n+            );\n+        }\n+        try {\n+            scope.join();\n+        } catch (InterruptedException e) {\n+            throw new AssertionError(\"scope.join() was interrupted\", e);\n+        }\n+        try {\n+            scope.throwIfFailed();\n+        } catch (ExecutionException e) {\n+            throw new TestException(\"something threw an exception in StructuredTaskScope\", e);\n+        }\n+    }\n+\n+    final static AtomicLong ID = new AtomicLong();\n+    final AtomicLong SUCCESS = new AtomicLong();\n+    final AtomicLong INTERRUPT = new AtomicLong();\n+    final AtomicLong FAILED = new AtomicLong();\n+    final AtomicLong STARTED = new AtomicLong();\n+    final CopyOnWriteArrayList<Exception> EXCEPTIONS = new CopyOnWriteArrayList<>();\n+    private String getAndCheck(HttpClient httpClient, URI url) {\n+        STARTED.incrementAndGet();\n+        final var response = sendRequest(httpClient, url);\n+        String res = response.body();\n+        int statusCode = response.statusCode();\n+        assertEquals(200, statusCode);\n+        return res;\n+    }\n+\n+    private HttpResponse<String> sendRequest(HttpClient httpClient, URI url) {\n+        var id = ID.incrementAndGet();\n+        try {\n+            var request = HttpRequest.newBuilder(url).GET().build();\n+            var response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n+            \/\/ System.out.println(\"Got response for \" + id + \": \" + response);\n+            SUCCESS.incrementAndGet();\n+            return response;\n+        } catch (InterruptedException e) {\n+            INTERRUPT.incrementAndGet();\n+            \/\/ System.out.println(\"Got interrupted for \" + id + \": \" + e);\n+            throw new RuntimeException(e);\n+        } catch (Exception e) {\n+            FAILED.incrementAndGet();\n+            EXCEPTIONS.add(e);\n+            \/\/System.out.println(\"Got exception for \" + id + \": \" + e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @AfterAll\n+    static void tearDown() {\n+        try {\n+            System.gc();\n+            var error = TRACKER.check(5000);\n+            if (error != null) throw error;\n+        } finally {\n+            ServerSocket ss;\n+            synchronized (HttpGetInCancelledFuture.class) {\n+                ss = NOT_ACCEPTING;\n+                NOT_ACCEPTING = null;\n+            }\n+            if (ss != null) {\n+                try {\n+                    ss.close();\n+                } catch (IOException io) {\n+                    throw new UncheckedIOException(io);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpGetInCancelledFuture.java","additions":391,"deletions":0,"binary":false,"changes":391,"status":"added"},{"patch":"@@ -379,1 +379,1 @@\n-        AssertionError fail = TRACKER.check(500);\n+        AssertionError fail = TRACKER.check(1500);\n","filename":"test\/jdk\/java\/net\/httpclient\/ProxySelectorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,0 +118,8 @@\n+    public AssertionError checkFinished(Tracker tracker, long graceDelayMs) {\n+        Predicate<Tracker> hasOperations = (t) -> t.getOutstandingOperations() > 0;\n+        Predicate<Tracker> hasSubscribers = (t) -> t.getOutstandingSubscribers() > 0;\n+        return check(tracker, graceDelayMs,\n+                hasOperations.or(hasSubscribers),\n+                \"outstanding operations or unreleased resources\", false);\n+    }\n+\n@@ -249,0 +257,5 @@\n+            if (i == 0 && waited == 0) {\n+                \/\/ we found nothing and didn't wait expecting success, but then found\n+                \/\/ something. Respin to make sure we wait.\n+                return check(tracker, graceDelayMs, hasOutstanding, description, printThreads);\n+            }\n@@ -305,0 +318,5 @@\n+            if (i == 0 && waited == 0) {\n+                \/\/ we found nothing and didn't wait expecting success, but then found\n+                \/\/ something. Respin to make sure we wait.\n+                return check(graceDelayMs, hasOutstanding, description, printThreads);\n+            }\n","filename":"test\/jdk\/java\/net\/httpclient\/ReferenceTracker.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,365 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8342075\n+ * @summary checks connection flow control\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer jdk.test.lib.net.SimpleSSLContext\n+ * @run testng\/othervm  -Djdk.internal.httpclient.debug=true\n+ *                      -Djdk.httpclient.connectionWindowSize=65535\n+ *                      -Djdk.httpclient.windowsize=16384\n+ *                      ConnectionFlowControlTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.ProtocolException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandler;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.net.http.HttpResponse.BodySubscriber;\n+import java.net.http.HttpResponse.ResponseInfo;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiFunction;\n+import java.util.function.Consumer;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSession;\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.httpclient.test.lib.http2.BodyOutputStream;\n+import jdk.httpclient.test.lib.http2.Http2Handler;\n+import jdk.httpclient.test.lib.http2.Http2TestExchange;\n+import jdk.httpclient.test.lib.http2.Http2TestExchangeImpl;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import jdk.httpclient.test.lib.http2.Http2TestServerConnection;\n+import jdk.internal.net.http.common.HttpHeadersBuilder;\n+import jdk.internal.net.http.frame.ContinuationFrame;\n+import jdk.internal.net.http.frame.HeaderFrame;\n+import jdk.internal.net.http.frame.HeadersFrame;\n+import jdk.internal.net.http.frame.Http2Frame;\n+import jdk.internal.net.http.frame.SettingsFrame;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.util.List.of;\n+import static java.util.Map.entry;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class ConnectionFlowControlTest {\n+\n+    SSLContext sslContext;\n+    HttpTestServer http2TestServer;   \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;  \/\/ HTTP\/2 ( h2  )\n+    String http2URI;\n+    String https2URI;\n+    final AtomicInteger reqid = new AtomicInteger();\n+\n+\n+    @DataProvider(name = \"variants\")\n+    public Object[][] variants() {\n+        return new Object[][] {\n+                { http2URI },\n+                { https2URI },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"variants\")\n+    void test(String uri) throws Exception {\n+        System.out.printf(\"%ntesting %s%n\", uri);\n+        ConcurrentHashMap<String, CompletableFuture<String>> responseSent = new ConcurrentHashMap<>();\n+        ConcurrentHashMap<String, HttpResponse<InputStream>> responses = new ConcurrentHashMap<>();\n+        FCHttp2TestExchange.setResponseSentCB((s) -> responseSent.get(s).complete(s));\n+        int connectionWindowSize = Math.max(Integer.getInteger(\n+                \"jdk.httpclient.connectionWindowSize\", 65535), 65535);\n+        int windowSize = Math.max(Integer.getInteger(\n+                \"jdk.httpclient.windowsize\", 65535), 16384);\n+        int max = connectionWindowSize \/ windowSize + 2;\n+        System.out.printf(\"connection window: %s, stream window: %s, will make %s requests%n\",\n+                connectionWindowSize, windowSize, max);\n+\n+        try (HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build()) {\n+            String label = null;\n+\n+            Throwable t = null;\n+            try {\n+                String[] keys = new String[max];\n+                for (int i = 0; i < max; i++) {\n+                    String query = \"reqId=\" + reqid.incrementAndGet();\n+                    keys[i] = query;\n+                    URI uriWithQuery = URI.create(uri + \"?\" + query);\n+                    CompletableFuture<String> sent = new CompletableFuture<>();\n+                    responseSent.put(query, sent);\n+                    HttpRequest request = HttpRequest.newBuilder(uriWithQuery)\n+                            .POST(BodyPublishers.ofString(\"Hello there!\"))\n+                            .build();\n+                    System.out.println(\"\\nSending request:\" + uriWithQuery);\n+                    final HttpClient cc = client;\n+                    var response = cc.send(request, BodyHandlers.ofInputStream());\n+                    responses.put(query, response);\n+                    String ckey = response.headers().firstValue(\"X-Connection-Key\").get();\n+                    if (label == null) label = ckey;\n+                    try {\n+                        if (i < max - 1) {\n+                            \/\/ the connection window might be exceeded at i == max - 2, which\n+                            \/\/ means that the last request could go on a new connection.\n+                            assertEquals(ckey, label, \"Unexpected key for \" + query);\n+                        }\n+                    } catch (AssertionError ass) {\n+                        \/\/ since we won't pull all responses, the client\n+                        \/\/ will not exit unless we ask it to shutdown now.\n+                        client.shutdownNow();\n+                        throw ass;\n+                    }\n+                }\n+                try {\n+                    Thread.sleep(1000);\n+                } catch (InterruptedException ie) {\n+                    \/\/ ignore\n+                }\n+                CompletableFuture<?> allsent = CompletableFuture.allOf(responseSent.values().stream()\n+                        .toArray(CompletableFuture<?>[]::new));\n+                allsent.get();\n+                for (int i = 0; i < max; i++) {\n+                    try {\n+                        String query = keys[i];\n+                        var response = responses.get(keys[i]);\n+                        String ckey = response.headers().firstValue(\"X-Connection-Key\").get();\n+                        if (label == null) label = ckey;\n+                        assertEquals(ckey, label, \"Unexpected key for \" + query);\n+                        int wait = uri.startsWith(\"https:\/\/\") ? 500 : 250;\n+                        try (InputStream is = response.body()) {\n+                            Thread.sleep(Utils.adjustTimeout(wait));\n+                            is.readAllBytes();\n+                        }\n+                        System.out.printf(\"%s did not fail: %s%n\", query, response.statusCode());\n+                    } catch (AssertionError t1) {\n+                        \/\/ since we won't pull all responses, the client\n+                        \/\/ will not exit unless we ask it to shutdown now.\n+                        client.shutdownNow();\n+                        throw t1;\n+                    } catch (Throwable t0) {\n+                        System.out.println(\"Got EXPECTED: \" + t0);\n+                        if (t0 instanceof ExecutionException) {\n+                            t0 = t0.getCause();\n+                        }\n+                        t = t0;\n+                        try {\n+                            assertDetailMessage(t0, i);\n+                        } catch (AssertionError e) {\n+                            \/\/ since we won't pull all responses, the client\n+                            \/\/ will not exit unless we ask it to shutdown now.\n+                            client.shutdownNow();\n+                            throw e;\n+                        }\n+                    }\n+                }\n+            } catch (Throwable t0) {\n+                System.out.println(\"Got EXPECTED: \" + t0);\n+                if (t0 instanceof ExecutionException) {\n+                    t0 = t0.getCause();\n+                }\n+                t = t0;\n+            }\n+            if (t == null) {\n+                \/\/ we could fail here if we haven't waited long enough\n+                fail(\"Expected exception, got all responses, should sleep time be raised?\");\n+            } else {\n+                assertDetailMessage(t, max);\n+            }\n+            String query = \"reqId=\" + reqid.incrementAndGet();\n+            URI uriWithQuery = URI.create(uri + \"?\" + query);\n+            CompletableFuture<String> sent = new CompletableFuture<>();\n+            responseSent.put(query, sent);\n+            HttpRequest request = HttpRequest.newBuilder(uriWithQuery)\n+                    .POST(BodyPublishers.ofString(\"Hello there!\"))\n+                    .build();\n+            System.out.println(\"\\nSending last request:\" + uriWithQuery);\n+            var response = client.send(request, BodyHandlers.ofString());\n+            if (label != null) {\n+                String ckey = response.headers().firstValue(\"X-Connection-Key\").get();\n+                assertNotEquals(ckey, label);\n+                System.out.printf(\"last request %s sent on different connection as expected:\" +\n+                        \"\\n\\tlast: %s\\n\\tprevious: %s%n\", query, ckey, label);\n+            }\n+        }\n+    }\n+\n+    \/\/ Assertions based on implementation specific detail messages. Keep in\n+    \/\/ sync with implementation.\n+    static void assertDetailMessage(Throwable throwable, int iterationIndex) {\n+        try {\n+            Throwable cause = throwable;\n+            while (cause != null) {\n+                if (cause instanceof ProtocolException) {\n+                    if (cause.getMessage().contains(\"connection window exceeded\")) {\n+                       System.out.println(\"Found expected exception: \" + cause);\n+                       return;\n+                    }\n+                }\n+                cause = cause.getCause();\n+            }\n+            throw new AssertionError(\n+                    \"ProtocolException(\\\"protocol error: connection window exceeded\\\") not found\",\n+                             throwable);\n+        } catch (AssertionError e) {\n+            System.out.println(\"Exception does not match expectation: \" + throwable);\n+            throwable.printStackTrace(System.out);\n+            throw e;\n+        }\n+    }\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        var http2TestServer = new Http2TestServer(\"localhost\", false, 0);\n+        http2TestServer.addHandler(new Http2TestHandler(), \"\/http2\/\");\n+        this.http2TestServer = HttpTestServer.of(http2TestServer);\n+        http2URI = \"http:\/\/\" + this.http2TestServer.serverAuthority() + \"\/http2\/x\";\n+\n+        var https2TestServer = new Http2TestServer(\"localhost\", true, sslContext);\n+        https2TestServer.addHandler(new Http2TestHandler(), \"\/https2\/\");\n+        this.https2TestServer = HttpTestServer.of(https2TestServer);\n+        https2URI = \"https:\/\/\" + this.https2TestServer.serverAuthority() + \"\/https2\/x\";\n+\n+        \/\/ Override the default exchange supplier with a custom one to enable\n+        \/\/ particular test scenarios\n+        http2TestServer.setExchangeSupplier(FCHttp2TestExchange::new);\n+        https2TestServer.setExchangeSupplier(FCHttp2TestExchange::new);\n+\n+        this.http2TestServer.start();\n+        this.https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        http2TestServer.stop();\n+        https2TestServer.stop();\n+    }\n+\n+    static class Http2TestHandler implements Http2Handler {\n+\n+        @Override\n+        public void handle(Http2TestExchange t) throws IOException {\n+            String query = t.getRequestURI().getRawQuery();\n+\n+            try (InputStream is = t.getRequestBody();\n+                 OutputStream os = t.getResponseBody()) {\n+\n+                byte[] bytes = is.readAllBytes();\n+                System.out.println(\"Server \" + t.getLocalAddress() + \" received:\\n\"\n+                        + t.getRequestURI() + \": \" + new String(bytes, StandardCharsets.UTF_8));\n+                t.getResponseHeaders().setHeader(\"X-Connection-Key\", t.getConnectionKey());\n+\n+                if (bytes.length == 0) bytes = \"no request body!\".getBytes(StandardCharsets.UTF_8);\n+                int window = Math.max(16384, Integer.getInteger(\"jdk.httpclient.windowsize\", 2*16*1024));\n+                 final int maxChunkSize;\n+                if (t instanceof FCHttp2TestExchange fct) {\n+                    maxChunkSize = Math.min(window, fct.conn.getMaxFrameSize());\n+                } else {\n+                    maxChunkSize = Math.min(window, SettingsFrame.MAX_FRAME_SIZE);\n+                }\n+                byte[] resp = bytes.length < maxChunkSize\n+                        ? bytes\n+                        : Arrays.copyOfRange(bytes, 0, maxChunkSize);\n+                int max = (window \/ resp.length);\n+                \/\/ send in chunks\n+                t.sendResponseHeaders(200, 0);\n+                int sent = 0;\n+                for (int i=0; i<=max; i++) {\n+                    int len = Math.min(resp.length, window - sent);\n+                    if (len <= 0) break;\n+                    if (os instanceof BodyOutputStream bos) {\n+                        try {\n+                            \/\/ we don't wait for the stream window, but we want\n+                            \/\/ to wait for the connection window\n+                            bos.waitForStreamWindow(len);\n+                        } catch (InterruptedException ie) {\n+                            \/\/ ignore and continue...\n+                        }\n+                    }\n+                    ((BodyOutputStream) os).writeUncontrolled(resp, 0, len);\n+                    sent += len;\n+                }\n+                if (sent != window) fail(\"should have sent %s, sent %s\".formatted(window, sent));\n+            }\n+            if (t instanceof FCHttp2TestExchange fct) {\n+                fct.responseSent(query);\n+            } else {\n+                fail(\"Exchange is not %s but %s\"\n+                        .formatted(FCHttp2TestExchange.class.getName(), t.getClass().getName()));\n+            }\n+        }\n+    }\n+\n+    \/\/ A custom Http2TestExchangeImpl that overrides sendResponseHeaders to\n+    \/\/ allow headers to be sent with a number of CONTINUATION frames.\n+    static class FCHttp2TestExchange extends Http2TestExchangeImpl {\n+        static volatile Consumer<String> responseSentCB;\n+        static void setResponseSentCB(Consumer<String> responseSentCB) {\n+            FCHttp2TestExchange.responseSentCB = responseSentCB;\n+        }\n+\n+        final Http2TestServerConnection conn;\n+        FCHttp2TestExchange(int streamid, String method, HttpHeaders reqheaders,\n+                             HttpHeadersBuilder rspheadersBuilder, URI uri, InputStream is,\n+                             SSLSession sslSession, BodyOutputStream os,\n+                             Http2TestServerConnection conn, boolean pushAllowed) {\n+            super(streamid, method, reqheaders, rspheadersBuilder, uri, is, sslSession, os, conn, pushAllowed);\n+            this.conn = conn;\n+        }\n+        public void responseSent(String query) {\n+            System.out.println(\"Server: response sent for \" + query);\n+            responseSentCB.accept(query);\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/ConnectionFlowControlTest.java","additions":365,"deletions":0,"binary":false,"changes":365,"status":"added"},{"patch":"@@ -0,0 +1,336 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.util.ArrayList;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestExchange;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestHandler;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/*\n+ * @test\n+ * @bug 8335181\n+ * @summary verify that the HttpClient correctly handles incoming GOAWAY frames and\n+ *          retries any unprocessed requests on a new connection\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *        jdk.test.lib.net.SimpleSSLContext\n+ * @run junit H2GoAwayTest\n+ *\/\n+public class H2GoAwayTest {\n+    private static final String REQ_PATH = \"\/test\";\n+    private static HttpTestServer server;\n+    private static String REQ_URI_BASE;\n+    private static SSLContext sslCtx;\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        sslCtx = new SimpleSSLContext().get();\n+        assertNotNull(sslCtx, \"SSLContext couldn't be created\");\n+        server = HttpTestServer.create(HTTP_2, sslCtx);\n+        server.addHandler(new Handler(), REQ_PATH);\n+        server.start();\n+        System.out.println(\"Server started at \" + server.getAddress());\n+        REQ_URI_BASE = URIBuilder.newBuilder().scheme(\"https\")\n+                .loopback()\n+                .port(server.getAddress().getPort())\n+                .path(REQ_PATH)\n+                .build().toString();\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        if (server != null) {\n+            System.out.println(\"Stopping server at \" + server.getAddress());\n+            server.stop();\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that when several requests are sent using send() and the server\n+     * connection is configured to send a GOAWAY after processing only a few requests, then\n+     * the remaining requests are retried on a different connection\n+     *\/\n+    @Test\n+    public void testSequential() throws Exception {\n+        final LimitedPerConnRequestApprover reqApprover = new LimitedPerConnRequestApprover();\n+        server.setRequestApprover(reqApprover::allowNewRequest);\n+        try (final HttpClient client = HttpClient.newBuilder().version(HTTP_2)\n+                .sslContext(sslCtx).build()) {\n+            final String[] reqMethods = {\"HEAD\", \"GET\", \"POST\"};\n+            for (final String reqMethod : reqMethods) {\n+                final int numReqs = LimitedPerConnRequestApprover.MAX_REQS_PER_CONN + 3;\n+                final Set<String> connectionKeys = new LinkedHashSet<>();\n+                for (int i = 1; i <= numReqs; i++) {\n+                    final URI reqURI = new URI(REQ_URI_BASE + \"?seq&\" + reqMethod + \"=\" + i);\n+                    final HttpRequest req = HttpRequest.newBuilder()\n+                            .uri(reqURI)\n+                            .method(reqMethod, HttpRequest.BodyPublishers.noBody())\n+                            .build();\n+                    System.out.println(\"initiating request \" + req);\n+                    final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n+                    final String respBody = resp.body();\n+                    System.out.println(\"received response: \" + respBody);\n+                    assertEquals(200, resp.statusCode(),\n+                            \"unexpected status code for request \" + resp.request());\n+                    \/\/ response body is the logical key of the connection on which the\n+                    \/\/ request was handled\n+                    connectionKeys.add(respBody);\n+                }\n+                System.out.println(\"connections involved in handling the requests: \"\n+                        + connectionKeys);\n+                \/\/ all requests have finished, we now just do a basic check that\n+                \/\/ more than one connection was involved in processing these requests\n+                assertEquals(2, connectionKeys.size(),\n+                        \"unexpected number of connections \" + connectionKeys);\n+            }\n+        } finally {\n+            server.setRequestApprover(null); \/\/ reset\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that when a server responds with a GOAWAY and then never processes the new retried\n+     * requests on a new connection too, then the application code receives the request failure.\n+     * This tests the send() API of the HttpClient.\n+     *\/\n+    @Test\n+    public void testUnprocessedRaisesException() throws Exception {\n+        try (final HttpClient client = HttpClient.newBuilder().version(HTTP_2)\n+                .sslContext(sslCtx).build()) {\n+            final Random random = new Random();\n+            final String[] reqMethods = {\"HEAD\", \"GET\", \"POST\"};\n+            for (final String reqMethod : reqMethods) {\n+                final int maxAllowedReqs = 2;\n+                final int numReqs = maxAllowedReqs + 3; \/\/ 3 more requests than max allowed\n+                \/\/ configure the approver\n+                final LimitedRequestApprover reqApprover = new LimitedRequestApprover(maxAllowedReqs);\n+                server.setRequestApprover(reqApprover::allowNewRequest);\n+                try {\n+                    int numSuccess = 0;\n+                    int numFailed = 0;\n+                    for (int i = 1; i <= numReqs; i++) {\n+                        final String reqQueryPart = \"?sync&\" + reqMethod + \"=\" + i;\n+                        final URI reqURI = new URI(REQ_URI_BASE + reqQueryPart);\n+                        final HttpRequest req = HttpRequest.newBuilder()\n+                                .uri(reqURI)\n+                                .method(reqMethod, HttpRequest.BodyPublishers.noBody())\n+                                .build();\n+                        System.out.println(\"initiating request \" + req);\n+                        if (i <= maxAllowedReqs) {\n+                            \/\/ expected to successfully complete\n+                            numSuccess++;\n+                            final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n+                            final String respBody = resp.body();\n+                            System.out.println(\"received response: \" + respBody);\n+                            assertEquals(200, resp.statusCode(),\n+                                    \"unexpected status code for request \" + resp.request());\n+                        } else {\n+                            \/\/ expected to fail as unprocessed\n+                            try {\n+                                final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n+                                fail(\"Request was expected to fail as unprocessed,\"\n+                                        + \" but got response: \" + resp.body() + \", status code: \"\n+                                        + resp.statusCode());\n+                            } catch (IOException ioe) {\n+                                \/\/ verify it failed for the right reason\n+                                if (ioe.getMessage() == null\n+                                        || !ioe.getMessage().contains(\"request not processed by peer\")) {\n+                                    \/\/ propagate the original failure\n+                                    throw ioe;\n+                                }\n+                                numFailed++; \/\/ failed due to right reason\n+                                System.out.println(\"received expected failure: \" + ioe\n+                                        + \", for request \" + reqURI);\n+                            }\n+                        }\n+                    }\n+                    \/\/ verify the correct number of requests succeeded\/failed\n+                    assertEquals(maxAllowedReqs, numSuccess, \"unexpected number of requests succeeded\");\n+                    assertEquals((numReqs - maxAllowedReqs), numFailed, \"unexpected number of requests failed\");\n+                } finally {\n+                    server.setRequestApprover(null); \/\/ reset\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that when a server responds with a GOAWAY and then never processes the new retried\n+     * requests on a new connection too, then the application code receives the request failure.\n+     * This tests the sendAsync() API of the HttpClient.\n+     *\/\n+    @Test\n+    public void testUnprocessedRaisesExceptionAsync() throws Throwable {\n+        try (final HttpClient client = HttpClient.newBuilder().version(HTTP_2)\n+                .sslContext(sslCtx).build()) {\n+            final Random random = new Random();\n+            final String[] reqMethods = {\"HEAD\", \"GET\", \"POST\"};\n+            for (final String reqMethod : reqMethods) {\n+                final int maxAllowedReqs = 2;\n+                final int numReqs = maxAllowedReqs + 3; \/\/ 3 more requests than max allowed\n+                \/\/ configure the approver\n+                final LimitedRequestApprover reqApprover = new LimitedRequestApprover(maxAllowedReqs);\n+                server.setRequestApprover(reqApprover::allowNewRequest);\n+                try {\n+                    final List<Future<HttpResponse<String>>> futures = new ArrayList<>();\n+                    for (int i = 1; i <= numReqs; i++) {\n+                        final URI reqURI = new URI(REQ_URI_BASE + \"?async&\" + reqMethod + \"=\" + i);\n+                        final HttpRequest req = HttpRequest.newBuilder()\n+                                .uri(reqURI)\n+                                .method(reqMethod, HttpRequest.BodyPublishers.noBody())\n+                                .build();\n+                        System.out.println(\"initiating request \" + req);\n+                        final Future<HttpResponse<String>> f = client.sendAsync(req, BodyHandlers.ofString());\n+                        futures.add(f);\n+                    }\n+                    \/\/ wait for responses\n+                    int numFailed = 0;\n+                    int numSuccess = 0;\n+                    for (int i = 1; i <= numReqs; i++) {\n+                        final String reqQueryPart = \"?async&\" + reqMethod + \"=\" + i;\n+                        try {\n+                            System.out.println(\"waiting response of request \"\n+                                    + REQ_URI_BASE + reqQueryPart);\n+                            final HttpResponse<String> resp = futures.get(i - 1).get();\n+                            numSuccess++;\n+                            final String respBody = resp.body();\n+                            System.out.println(\"request: \" + resp.request()\n+                                    + \", received response: \" + respBody);\n+                            assertEquals(200, resp.statusCode(),\n+                                    \"unexpected status code for request \" + resp.request());\n+                        } catch (ExecutionException ee) {\n+                            final Throwable cause = ee.getCause();\n+                            if (!(cause instanceof IOException ioe)) {\n+                                throw cause;\n+                            }\n+                            \/\/ verify it failed for the right reason\n+                            if (ioe.getMessage() == null\n+                                    || !ioe.getMessage().contains(\"request not processed by peer\")) {\n+                                \/\/ propagate the original failure\n+                                throw ioe;\n+                            }\n+                            numFailed++; \/\/ failed due to the right reason\n+                            System.out.println(\"received expected failure: \" + ioe\n+                                    + \", for request \" + REQ_URI_BASE + reqQueryPart);\n+                        }\n+                    }\n+                    \/\/ verify the correct number of requests succeeded\/failed\n+                    assertEquals(maxAllowedReqs, numSuccess, \"unexpected number of requests succeeded\");\n+                    assertEquals((numReqs - maxAllowedReqs), numFailed, \"unexpected number of requests failed\");\n+                } finally {\n+                    server.setRequestApprover(null); \/\/ reset\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ only allows fixed number of requests, irrespective of which server connection handles\n+    \/\/ it. requests that are rejected will either be sent a GOAWAY on the connection\n+    \/\/ or a RST_FRAME with a REFUSED_STREAM on the stream\n+    private static final class LimitedRequestApprover {\n+        private final int maxAllowedReqs;\n+        private final AtomicInteger numApproved = new AtomicInteger();\n+\n+        private LimitedRequestApprover(final int maxAllowedReqs) {\n+            this.maxAllowedReqs = maxAllowedReqs;\n+        }\n+\n+        public boolean allowNewRequest(final String serverConnKey) {\n+            final int approved = numApproved.incrementAndGet();\n+            return approved <= maxAllowedReqs;\n+        }\n+    }\n+\n+    \/\/ allows a certain number of requests per server connection.\n+    \/\/ requests that are rejected will either be sent a GOAWAY on the connection\n+    \/\/ or a RST_FRAME with a REFUSED_STREAM on the stream\n+    private static final class LimitedPerConnRequestApprover {\n+        private static final int MAX_REQS_PER_CONN = 6;\n+        private final Map<String, AtomicInteger> numApproved =\n+                new ConcurrentHashMap<>();\n+        private final Map<String, AtomicInteger> numDisapproved =\n+                new ConcurrentHashMap<>();\n+\n+        public boolean allowNewRequest(final String serverConnKey) {\n+            final AtomicInteger approved = numApproved.computeIfAbsent(serverConnKey,\n+                    (k) -> new AtomicInteger());\n+            int curr = approved.get();\n+            while (curr < MAX_REQS_PER_CONN) {\n+                if (approved.compareAndSet(curr, curr + 1)) {\n+                    return true; \/\/ new request allowed\n+                }\n+                curr = approved.get();\n+            }\n+            final AtomicInteger disapproved = numDisapproved.computeIfAbsent(serverConnKey,\n+                    (k) -> new AtomicInteger());\n+            final int numUnprocessed = disapproved.incrementAndGet();\n+            System.out.println(approved.get() + \" processed, \"\n+                    + numUnprocessed + \" unprocessed requests on connection \" + serverConnKey);\n+            return false;\n+        }\n+    }\n+\n+    private static final class Handler implements HttpTestHandler {\n+\n+        @Override\n+        public void handle(final HttpTestExchange exchange) throws IOException {\n+            final String connectionKey = exchange.getConnectionKey();\n+            System.out.println(\"responding to request: \" + exchange.getRequestURI()\n+                    + \" on connection \" + connectionKey);\n+            final byte[] response = connectionKey.getBytes(UTF_8);\n+            exchange.sendResponseHeaders(200, response.length);\n+            try (final OutputStream os = exchange.getResponseBody()) {\n+                os.write(response);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/H2GoAwayTest.java","additions":336,"deletions":0,"binary":false,"changes":336,"status":"added"},{"patch":"@@ -0,0 +1,342 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8342075\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.http2.Http2TestServer jdk.test.lib.net.SimpleSSLContext\n+ * @run testng\/othervm  -Djdk.internal.httpclient.debug=true\n+ *                      -Djdk.httpclient.connectionWindowSize=65535\n+ *                      -Djdk.httpclient.windowsize=16384\n+ *                      StreamFlowControlTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.ProtocolException;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpRequest.BodyPublishers;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSession;\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.httpclient.test.lib.http2.BodyOutputStream;\n+import jdk.httpclient.test.lib.http2.Http2Handler;\n+import jdk.httpclient.test.lib.http2.Http2TestExchange;\n+import jdk.httpclient.test.lib.http2.Http2TestExchangeImpl;\n+import jdk.httpclient.test.lib.http2.Http2TestServer;\n+import jdk.httpclient.test.lib.http2.Http2TestServerConnection;\n+import jdk.internal.net.http.common.HttpHeadersBuilder;\n+import jdk.internal.net.http.frame.SettingsFrame;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.fail;\n+\n+public class StreamFlowControlTest {\n+\n+    SSLContext sslContext;\n+    HttpTestServer http2TestServer;   \/\/ HTTP\/2 ( h2c )\n+    HttpTestServer https2TestServer;  \/\/ HTTP\/2 ( h2  )\n+    String http2URI;\n+    String https2URI;\n+    final AtomicInteger reqid = new AtomicInteger();\n+\n+\n+    @DataProvider(name = \"variants\")\n+    public Object[][] variants() {\n+        return new Object[][] {\n+                { http2URI,  false },\n+                { https2URI, false },\n+                { http2URI,  true },\n+                { https2URI, true },\n+        };\n+    }\n+\n+\n+    @Test(dataProvider = \"variants\")\n+    void test(String uri,\n+              boolean sameClient)\n+        throws Exception\n+    {\n+        System.out.printf(\"%ntesting test(%s, %s)%n\", uri, sameClient);\n+        ConcurrentHashMap<String, CompletableFuture<String>>  responseSent = new ConcurrentHashMap<>();\n+        FCHttp2TestExchange.setResponseSentCB((s) -> responseSent.get(s).complete(s));\n+\n+        HttpClient client = null;\n+        try {\n+            int max = sameClient ? 10 : 3;\n+            String label = null;\n+            for (int i = 0; i < max; i++) {\n+                if (!sameClient || client == null)\n+                    client = HttpClient.newBuilder().sslContext(sslContext).build();\n+\n+                String query = \"reqId=\" + reqid.incrementAndGet();\n+                URI uriWithQuery = URI.create(uri + \"?\" + query);\n+                CompletableFuture<String> sent = new CompletableFuture<>();\n+                responseSent.put(query, sent);\n+                HttpRequest request = HttpRequest.newBuilder(uriWithQuery)\n+                        .POST(BodyPublishers.ofString(\"Hello there!\"))\n+                        .build();\n+                System.out.println(\"\\nSending request:\" + uriWithQuery);\n+                final HttpClient cc = client;\n+                try {\n+                    HttpResponse<InputStream> response = cc.send(request, BodyHandlers.ofInputStream());\n+                    if (sameClient) {\n+                        String key = response.headers().firstValue(\"X-Connection-Key\").get();\n+                        if (label == null) label = key;\n+                        assertEquals(key, label, \"Unexpected key for \" + query);\n+                    }\n+                    sent.join();\n+                    \/\/ we have to pull to get the exception, but slow enough\n+                    \/\/ so that DataFrames are buffered up to the point that\n+                    \/\/ the window is exceeded...\n+                    int wait = uri.startsWith(\"https:\/\/\") ? 500 : 350;\n+                    try (InputStream is = response.body()) {\n+                        Thread.sleep(Utils.adjustTimeout(wait));\n+                        is.readAllBytes();\n+                    }\n+                    \/\/ we could fail here if we haven't waited long enough\n+                    fail(\"Expected exception, got :\" + response + \", should sleep time be raised?\");\n+                } catch (IOException ioe) {\n+                    System.out.println(\"Got EXPECTED: \" + ioe);\n+                    assertDetailMessage(ioe, i);\n+                } finally {\n+                    if (!sameClient && client != null) {\n+                        client.close();\n+                        client = null;\n+                    }\n+                }\n+            }\n+        } finally {\n+            if (sameClient && client != null) client.close();\n+        }\n+\n+    }\n+\n+    @Test(dataProvider = \"variants\")\n+    void testAsync(String uri,\n+                   boolean sameClient)\n+    {\n+        System.out.printf(\"%ntesting testAsync(%s, %s)%n\", uri, sameClient);\n+        ConcurrentHashMap<String, CompletableFuture<String>> responseSent = new ConcurrentHashMap<>();\n+        FCHttp2TestExchange.setResponseSentCB((s) -> responseSent.get(s).complete(s));\n+\n+        HttpClient client = null;\n+        try {\n+            int max = sameClient ? 5 : 3;\n+            String label = null;\n+            for (int i = 0; i < max; i++) {\n+                if (!sameClient || client == null)\n+                    client = HttpClient.newBuilder().sslContext(sslContext).build();\n+\n+                String query = \"reqId=\" + reqid.incrementAndGet();\n+                URI uriWithQuery = URI.create(uri + \"?\" + query);\n+                CompletableFuture<String> sent = new CompletableFuture<>();\n+                responseSent.put(query, sent);\n+                HttpRequest request = HttpRequest.newBuilder(uriWithQuery)\n+                        .POST(BodyPublishers.ofString(\"Hello there!\"))\n+                        .build();\n+                System.out.println(\"\\nSending request:\" + uriWithQuery);\n+                final HttpClient cc = client;\n+\n+                Throwable t = null;\n+                try {\n+                    HttpResponse<InputStream> response = cc.sendAsync(request, BodyHandlers.ofInputStream()).get();\n+                    if (sameClient) {\n+                        String key = response.headers().firstValue(\"X-Connection-Key\").get();\n+                        if (label == null) label = key;\n+                        assertEquals(key, label, \"Unexpected key for \" + query);\n+                    }\n+                    sent.join();\n+                    int wait = uri.startsWith(\"https:\/\/\") ? 600 : 300;\n+                    try (InputStream is = response.body()) {\n+                        Thread.sleep(Utils.adjustTimeout(wait));\n+                        is.readAllBytes();\n+                    }\n+                    \/\/ we could fail here if we haven't waited long enough\n+                    fail(\"Expected exception, got :\" + response + \", should sleep time be raised?\");\n+                } catch (Throwable t0) {\n+                    System.out.println(\"Got EXPECTED: \" + t0);\n+                    if (t0 instanceof ExecutionException) {\n+                        t0 = t0.getCause();\n+                    }\n+                    t = t0;\n+                } finally {\n+                    if (!sameClient && client != null) {\n+                        client.close();\n+                        client = null;\n+                    }\n+                }\n+                assertDetailMessage(t, i);\n+            }\n+        } finally {\n+            if (sameClient && client != null) client.close();\n+        }\n+    }\n+\n+    \/\/ Assertions based on implementation specific detail messages. Keep in\n+    \/\/ sync with implementation.\n+    static void assertDetailMessage(Throwable throwable, int iterationIndex) {\n+        try {\n+            Throwable cause = throwable;\n+            while (cause != null) {\n+                if (cause instanceof ProtocolException) {\n+                    if (cause.getMessage().matches(\"stream [0-9]+ flow control window exceeded\")) {\n+                       System.out.println(\"Found expected exception: \" + cause);\n+                       return;\n+                    }\n+                }\n+                cause = cause.getCause();\n+            }\n+            throw new AssertionError(\n+                    \"ProtocolException(\\\"stream X flow control window exceeded\\\") not found\",\n+                             throwable);\n+        } catch (AssertionError e) {\n+            System.out.println(\"Exception does not match expectation: \" + throwable);\n+            throwable.printStackTrace(System.out);\n+            throw e;\n+        }\n+    }\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        sslContext = new SimpleSSLContext().get();\n+        if (sslContext == null)\n+            throw new AssertionError(\"Unexpected null sslContext\");\n+\n+        var http2TestServer = new Http2TestServer(\"localhost\", false, 0);\n+        http2TestServer.addHandler(new Http2TestHandler(), \"\/http2\/\");\n+        this.http2TestServer = HttpTestServer.of(http2TestServer);\n+        http2URI = \"http:\/\/\" + this.http2TestServer.serverAuthority() + \"\/http2\/x\";\n+\n+        var https2TestServer = new Http2TestServer(\"localhost\", true, sslContext);\n+        https2TestServer.addHandler(new Http2TestHandler(), \"\/https2\/\");\n+        this.https2TestServer = HttpTestServer.of(https2TestServer);\n+        https2URI = \"https:\/\/\" + this.https2TestServer.serverAuthority() + \"\/https2\/x\";\n+\n+        \/\/ Override the default exchange supplier with a custom one to enable\n+        \/\/ particular test scenarios\n+        http2TestServer.setExchangeSupplier(FCHttp2TestExchange::new);\n+        https2TestServer.setExchangeSupplier(FCHttp2TestExchange::new);\n+\n+        this.http2TestServer.start();\n+        this.https2TestServer.start();\n+    }\n+\n+    @AfterTest\n+    public void teardown() throws Exception {\n+        http2TestServer.stop();\n+        https2TestServer.stop();\n+    }\n+\n+    static class Http2TestHandler implements Http2Handler {\n+\n+        @Override\n+        public void handle(Http2TestExchange t) throws IOException {\n+            String query = t.getRequestURI().getRawQuery();\n+\n+            try (InputStream is = t.getRequestBody();\n+                 OutputStream os = t.getResponseBody()) {\n+\n+                byte[] bytes = is.readAllBytes();\n+                System.out.println(\"Server \" + t.getLocalAddress() + \" received:\\n\"\n+                        + t.getRequestURI() + \": \" + new String(bytes, StandardCharsets.UTF_8));\n+                t.getResponseHeaders().setHeader(\"X-Connection-Key\", t.getConnectionKey());\n+\n+                if (bytes.length == 0) bytes = \"no request body!\".getBytes(StandardCharsets.UTF_8);\n+                int window = Integer.getInteger(\"jdk.httpclient.windowsize\", 2 * 16 * 1024);\n+                final int maxChunkSize;\n+                if (t instanceof FCHttp2TestExchange fct) {\n+                    maxChunkSize = Math.min(window, fct.conn.getMaxFrameSize());\n+                } else {\n+                    maxChunkSize = Math.min(window, SettingsFrame.MAX_FRAME_SIZE);\n+                }\n+                byte[] resp = bytes.length <= maxChunkSize\n+                        ? bytes\n+                        : Arrays.copyOfRange(bytes, 0, maxChunkSize);\n+                int max = (window \/ resp.length) + 2;\n+                \/\/ send in chunks\n+                t.sendResponseHeaders(200, 0);\n+                for (int i = 0; i <= max; i++) {\n+                    if (t instanceof FCHttp2TestExchange fct) {\n+                        try {\n+                            \/\/ we don't wait for the stream window, but we want\n+                            \/\/ to wait for the connection window\n+                            fct.conn.obtainConnectionWindow(resp.length);\n+                        } catch (InterruptedException ie) {\n+                            \/\/ ignore and continue...\n+                        }\n+                    }\n+                    ((BodyOutputStream) os).writeUncontrolled(resp, 0, resp.length);\n+                }\n+            }\n+            if (t instanceof FCHttp2TestExchange fct) {\n+                fct.responseSent(query);\n+            } else fail(\"Exchange is not %s but %s\"\n+                    .formatted(FCHttp2TestExchange.class.getName(), t.getClass().getName()));\n+        }\n+    }\n+\n+    \/\/ A custom Http2TestExchangeImpl that overrides sendResponseHeaders to\n+    \/\/ allow headers to be sent with a number of CONTINUATION frames.\n+    static class FCHttp2TestExchange extends Http2TestExchangeImpl {\n+        static volatile Consumer<String> responseSentCB;\n+        static void setResponseSentCB(Consumer<String> responseSentCB) {\n+            FCHttp2TestExchange.responseSentCB = responseSentCB;\n+        }\n+\n+        final Http2TestServerConnection conn;\n+        FCHttp2TestExchange(int streamid, String method, HttpHeaders reqheaders,\n+                             HttpHeadersBuilder rspheadersBuilder, URI uri, InputStream is,\n+                             SSLSession sslSession, BodyOutputStream os,\n+                             Http2TestServerConnection conn, boolean pushAllowed) {\n+            super(streamid, method, reqheaders, rspheadersBuilder, uri, is, sslSession, os, conn, pushAllowed);\n+            this.conn = conn;\n+        }\n+        public void responseSent(String query) {\n+            System.out.println(\"Server: response sent for \" + query);\n+            responseSentCB.accept(query);\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/StreamFlowControlTest.java","additions":342,"deletions":0,"binary":false,"changes":342,"status":"added"},{"patch":"@@ -61,0 +61,1 @@\n+import java.util.function.Predicate;\n@@ -243,0 +244,1 @@\n+        public abstract String getConnectionKey();\n@@ -257,1 +259,1 @@\n-            return new Http2TestExchangeImpl(exchange);\n+            return new H2ExchangeImpl(exchange);\n@@ -313,0 +315,6 @@\n+\n+            @Override\n+            public String getConnectionKey() {\n+                return exchange.getLocalAddress() + \"->\" + exchange.getRemoteAddress();\n+            }\n+\n@@ -319,1 +327,1 @@\n-        private static final class Http2TestExchangeImpl extends HttpTestExchange {\n+        private static final class H2ExchangeImpl extends HttpTestExchange {\n@@ -321,1 +329,1 @@\n-            Http2TestExchangeImpl(Http2TestExchange exch) {\n+            H2ExchangeImpl(Http2TestExchange exch) {\n@@ -374,0 +382,5 @@\n+            @Override\n+            public String getConnectionKey() {\n+                return exchange.getConnectionKey();\n+            }\n+\n@@ -719,0 +732,1 @@\n+        public abstract void setRequestApprover(final Predicate<String> approver);\n@@ -867,0 +881,5 @@\n+\n+            @Override\n+            public void setRequestApprover(final Predicate<String> approver) {\n+                throw new UnsupportedOperationException(\"not supported\");\n+            }\n@@ -918,0 +937,5 @@\n+\n+            @Override\n+            public void setRequestApprover(final Predicate<String> approver) {\n+                this.impl.setRequestApprover(approver);\n+            }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/common\/HttpServerAdapters.java","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.Objects;\n@@ -68,0 +69,4 @@\n+        waitForStreamWindow(demand);\n+    }\n+\n+    public void waitForStreamWindow(int demand) throws InterruptedException {\n@@ -86,0 +91,1 @@\n+        Objects.checkFromIndexSize(offset, len, buf.length);\n@@ -107,0 +113,28 @@\n+    \/**\n+     * This method pushes frames onto the stack without checking\n+     * for flow control, allowing the sender to bypass flow\n+     * control for testing purposes\n+     * @param buf     data to send\n+     * @param offset  offset at which the data starts\n+     * @param len     length of the data to send\n+     * @throws IOException if an I\/O error occurs\n+     *\/\n+    public void writeUncontrolled(byte[] buf, int offset, int len)\n+            throws IOException {\n+        Objects.checkFromIndexSize(offset, len, buf.length);\n+        if (closed) {\n+            throw new IOException(\"closed\");\n+        }\n+\n+        if (!goodToGo) {\n+            throw new IllegalStateException(\"sendResponseHeaders must be called first\");\n+        }\n+        int max = conn.getMaxFrameSize();\n+        while (len > 0) {\n+            int n = len > max ? max : len;\n+            send(buf, offset, n, 0);\n+            offset += n;\n+            len -= n;\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/BodyOutputStream.java","additions":35,"deletions":1,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,0 +87,6 @@\n+\n+    \/**\n+     * {@return the identification of the connection on which this exchange is being\n+     * processed}\n+     *\/\n+    String getConnectionKey();\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchange.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -230,0 +230,5 @@\n+    @Override\n+    public String getConnectionKey() {\n+        return conn.connectionKey();\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchangeImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import java.util.function.Predicate;\n+\n@@ -62,0 +64,2 @@\n+    \/\/ request approver which takes the server connection key as the input\n+    private volatile Predicate<String> newRequestApprover;\n@@ -288,0 +292,8 @@\n+    public void setRequestApprover(final Predicate<String> approver) {\n+        this.newRequestApprover = approver;\n+    }\n+\n+    Predicate<String> getRequestApprover() {\n+        return this.newRequestApprover;\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServer.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+import java.util.Set;\n@@ -83,0 +84,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -86,0 +88,1 @@\n+import java.util.function.Predicate;\n@@ -89,0 +92,1 @@\n+import static jdk.internal.net.http.frame.ErrorFrame.REFUSED_STREAM;\n@@ -118,0 +122,4 @@\n+    \/\/ the max stream id of a processed H2 request. -1 implies none were processed.\n+    private final AtomicInteger maxProcessedRequestStreamId = new AtomicInteger(-1);\n+    \/\/ the stream id that was sent in a GOAWAY frame. -1 implies no GOAWAY frame was sent.\n+    private final AtomicInteger goAwayRequestStreamId = new AtomicInteger(-1);\n@@ -242,5 +250,23 @@\n-    void goAway(int error) throws IOException {\n-        int laststream = nextstream >= 3 ? nextstream - 2 : 1;\n-\n-        GoAwayFrame go = new GoAwayFrame(laststream, error);\n-        outputQ.put(go);\n+    private void sendGoAway(final int error) throws IOException {\n+        int maxProcessedStreamId = maxProcessedRequestStreamId.get();\n+        if (maxProcessedStreamId == -1) {\n+            maxProcessedStreamId = 0;\n+        }\n+        boolean send = false;\n+        int currentGoAwayReqStrmId = goAwayRequestStreamId.get();\n+        \/\/ update the last processed stream id and send a goaway frame if the new last processed\n+        \/\/ stream id is lesser than the last processed stream id sent in\n+        \/\/ a previous goaway frame (if any)\n+        while (currentGoAwayReqStrmId == -1 || maxProcessedStreamId < currentGoAwayReqStrmId) {\n+            if (goAwayRequestStreamId.compareAndSet(currentGoAwayReqStrmId, maxProcessedStreamId)) {\n+                send = true;\n+                break;\n+            }\n+            currentGoAwayReqStrmId = goAwayRequestStreamId.get();\n+        }\n+        if (!send) {\n+            return;\n+        }\n+        final GoAwayFrame frame = new GoAwayFrame(maxProcessedStreamId, error);\n+        outputQ.put(frame);\n+        System.err.println(\"Sending GOAWAY frame \" + frame + \" from server connection \" + this);\n@@ -339,2 +365,3 @@\n-            if (error != -1)\n-                goAway(error);\n+            if (error != -1) {\n+                sendGoAway(error);\n+            }\n@@ -622,0 +649,8 @@\n+        \/\/ skip processing the request if configured to do so\n+        final String connKey = connectionKey();\n+        if (!shouldProcessNewHTTPRequest(connKey)) {\n+            System.err.println(\"Rejecting primordial stream 1 and sending GOAWAY\" +\n+                    \" on server connection \" + connKey + \", for request: \" + path);\n+            sendGoAway(ErrorFrame.NO_ERROR);\n+            return;\n+        }\n@@ -630,0 +665,1 @@\n+        maxProcessedRequestStreamId.set(1);\n@@ -635,0 +671,12 @@\n+    private boolean shouldProcessNewHTTPRequest(final String serverConnKey) {\n+        final Predicate<String> approver = this.server.getRequestApprover();\n+        if (approver == null) {\n+            return true; \/\/ process the request\n+        }\n+        return approver.test(serverConnKey);\n+    }\n+\n+    final String connectionKey() {\n+        return this.server.getAddress() + \"->\" + this.socket.getRemoteSocketAddress();\n+    }\n+\n@@ -642,1 +690,1 @@\n-            throw new IOException(\"unexpected stream id\");\n+            throw new IOException(\"unexpected stream id: \" + streamid);\n@@ -673,1 +721,1 @@\n-        if (disallowedHeader.isPresent())\n+        if (disallowedHeader.isPresent()) {\n@@ -675,0 +723,1 @@\n+        }\n@@ -676,1 +725,10 @@\n-\n+        \/\/ skip processing the request if the server is configured to do so\n+        final String connKey = connectionKey();\n+        final String path = headers.firstValue(\":path\").orElse(\"\");\n+        if (!shouldProcessNewHTTPRequest(connKey)) {\n+            System.err.println(\"Rejecting stream \" + streamid\n+                    + \" and sending GOAWAY on server connection \"\n+                    + connKey + \", for request: \" + path);\n+            sendGoAway(ErrorFrame.NO_ERROR);\n+            return;\n+        }\n@@ -679,0 +737,8 @@\n+        \/\/ keep track of the largest request id that we have processed\n+        int currentLargest = maxProcessedRequestStreamId.get();\n+        while (streamid > currentLargest) {\n+            if (maxProcessedRequestStreamId.compareAndSet(currentLargest, streamid)) {\n+                break;\n+            }\n+            currentLargest = maxProcessedRequestStreamId.get();\n+        }\n@@ -781,0 +847,2 @@\n+                    System.err.println(\"EOF reached on connection \" + connectionKey()\n+                            + \", will no longer accept incoming frames\");\n@@ -804,0 +872,11 @@\n+                            final int streamId = frame.streamid();\n+                            final int finalProcessedStreamId = goAwayRequestStreamId.get();\n+                            \/\/ if we already sent a goaway, then don't create new streams with\n+                            \/\/ higher stream ids.\n+                            if (finalProcessedStreamId != -1 && streamId > finalProcessedStreamId) {\n+                                System.err.println(connectionKey() + \" resetting stream \" + streamId\n+                                        + \" as REFUSED_STREAM\");\n+                                final ResetFrame rst = new ResetFrame(streamId, REFUSED_STREAM);\n+                                outputQ.put(rst);\n+                                continue;\n+                            }\n@@ -1298,1 +1377,1 @@\n-    synchronized void obtainConnectionWindow(int amount) throws InterruptedException {\n+    public synchronized void obtainConnectionWindow(int amount) throws InterruptedException {\n@@ -1308,3 +1387,7 @@\n-    synchronized void updateConnectionWindow(int amount) {\n-        sendWindow += amount;\n-        notifyAll();\n+    void updateConnectionWindow(int amount) {\n+        System.out.printf(\"sendWindow (window=%s, amount=%s) is now: %s%n\",\n+                sendWindow, amount, sendWindow + amount);\n+        synchronized (this) {\n+            sendWindow += amount;\n+            notifyAll();\n+        }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":97,"deletions":14,"binary":false,"changes":111,"status":"modified"}]}