{"files":[{"patch":"@@ -188,0 +188,1 @@\n+    private boolean hasNonexistentEntries = false;\n@@ -734,0 +735,1 @@\n+        Map<String,Set<String>> entriesInSF = new HashMap<>();\n@@ -781,0 +783,1 @@\n+                                entriesInSF.put(alias, sf.getEntries().keySet());\n@@ -880,0 +883,3 @@\n+                        for (var signed : entriesInSF.values()) {\n+                            signed.remove(name);\n+                        }\n@@ -1077,0 +1083,7 @@\n+                        var signed = entriesInSF.get(s);\n+                        if (!signed.isEmpty()) {\n+                            if (verbose != null) {\n+                                System.out.println(rb.getString(\"history.nonexistent.entries\") + signed);\n+                            }\n+                            hasNonexistentEntries = true;\n+                        }\n@@ -1320,0 +1333,3 @@\n+        if (hasNonexistentEntries) {\n+            warnings.add(rb.getString(\"nonexistent.entries.found\"));\n+        }\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -167,0 +167,1 @@\n+        {\"history.nonexistent.entries\", \"    Warning: nonexistent signed entries: \"},\n@@ -181,0 +182,1 @@\n+        {\"nonexistent.entries.found\", \"This jar contains signed entries for files that do not exist. See the -verbose output for more details.\"},\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Resources.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8309841\n+ * @summary Jarsigner should print a warning if an entry is removed\n+ * @library \/test\/lib\n+ *\/\n+\n+import jdk.test.lib.SecurityTools;\n+import jdk.test.lib.util.JarUtils;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.jar.Attributes;\n+import java.util.jar.Manifest;\n+\n+public class RemovedFiles {\n+\n+    private static final String NONEXISTENT_ENTRIES_FOUND\n+            = \"This jar contains signed entries for files that do not exist. See the -verbose output for more details.\";\n+\n+    public static void main(String[] args) throws Exception {\n+        JarUtils.createJarFile(\n+                Path.of(\"a.jar\"),\n+                Path.of(\".\"),\n+                Files.writeString(Path.of(\"a\"), \"a\"),\n+                Files.writeString(Path.of(\"b\"), \"b\"));\n+        SecurityTools.keytool(\"-genkeypair -storepass changeit -keystore ks -alias x -dname CN=x -keyalg ed25519\");\n+        SecurityTools.jarsigner(\"-storepass changeit -keystore ks a.jar x\");\n+\n+        \/\/ All is fine at the beginning.\n+        SecurityTools.jarsigner(\"-verify a.jar\")\n+                .shouldNotContain(NONEXISTENT_ENTRIES_FOUND);\n+\n+        \/\/ Remove an entry after signing. There will be a warning.\n+        JarUtils.deleteEntries(Path.of(\"a.jar\"), \"a\");\n+        SecurityTools.jarsigner(\"-verify a.jar\")\n+                .shouldContain(NONEXISTENT_ENTRIES_FOUND);\n+        SecurityTools.jarsigner(\"-verify -verbose a.jar\")\n+                .shouldContain(NONEXISTENT_ENTRIES_FOUND)\n+                .shouldContain(\"Warning: nonexistent signed entries: [a]\");\n+\n+        \/\/ Remove one more entry.\n+        JarUtils.deleteEntries(Path.of(\"a.jar\"), \"b\");\n+        SecurityTools.jarsigner(\"-verify a.jar\")\n+                .shouldContain(NONEXISTENT_ENTRIES_FOUND);\n+        SecurityTools.jarsigner(\"-verify -verbose a.jar\")\n+                .shouldContain(NONEXISTENT_ENTRIES_FOUND)\n+                .shouldContain(\"Warning: nonexistent signed entries: [a, b]\");\n+\n+        \/\/ Re-sign will not clear the warning.\n+        SecurityTools.jarsigner(\"-storepass changeit -keystore ks a.jar x\");\n+        SecurityTools.jarsigner(\"-verify a.jar\")\n+                .shouldContain(NONEXISTENT_ENTRIES_FOUND);\n+\n+        \/\/ Unfortunately, if there is a non-file entry in manifest, there will be\n+        \/\/ a false alarm. See https:\/\/bugs.openjdk.org\/browse\/JDK-8334261.\n+        var man = new Manifest();\n+        man.getMainAttributes().putValue(\"Manifest-Version\", \"1.0\");\n+        man.getEntries().computeIfAbsent(\"Hello\", key -> new Attributes())\n+                .putValue(\"Foo\", \"Bar\");\n+        JarUtils.createJarFile(Path.of(\"b.jar\"),\n+                man,\n+                Path.of(\".\"),\n+                Path.of(\"a\"));\n+        SecurityTools.jarsigner(\"-storepass changeit -keystore ks b.jar x\");\n+        SecurityTools.jarsigner(\"-verbose -verify b.jar\")\n+                .shouldContain(\"Warning: nonexistent signed entries: [Hello]\")\n+                .shouldContain(NONEXISTENT_ENTRIES_FOUND);\n+\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/RemovedFiles.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8309841\n+ * @summary Unit Test for a common Test API in jdk.test.lib.util.JarUtils\n+ * @library \/test\/lib\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.util.JarUtils;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.stream.Collectors;\n+\n+public class JarUtilsTest {\n+    public static void main(String[] args) throws Exception {\n+        Files.createDirectory(Path.of(\"bx\"));\n+        JarUtils.createJarFile(Path.of(\"a.jar\"),\n+                Path.of(\".\"),\n+                Files.writeString(Path.of(\"a\"), \"\"),\n+                Files.writeString(Path.of(\"b1\"), \"\"),\n+                Files.writeString(Path.of(\"b2\"), \"\"),\n+                Files.writeString(Path.of(\"bx\/x\"), \"\"),\n+                Files.writeString(Path.of(\"c\"), \"\"),\n+                Files.writeString(Path.of(\"e1\"), \"\"),\n+                Files.writeString(Path.of(\"e2\"), \"\"));\n+        checkContent(\"a\", \"b1\", \"b2\", \"bx\/x\", \"c\", \"e1\", \"e2\");\n+\n+        JarUtils.deleteEntries(Path.of(\"a.jar\"), \"a\");\n+        checkContent(\"b1\", \"b2\", \"bx\/x\", \"c\", \"e1\", \"e2\");\n+\n+        \/\/ Note: b* covers everything starting with b, even bx\/x\n+        JarUtils.deleteEntries(Path.of(\"a.jar\"), \"b*\");\n+        checkContent(\"c\", \"e1\", \"e2\");\n+\n+        \/\/ d* does not match\n+        JarUtils.deleteEntries(Path.of(\"a.jar\"), \"d*\");\n+        checkContent(\"c\", \"e1\", \"e2\");\n+\n+        \/\/ multiple patterns\n+        JarUtils.deleteEntries(Path.of(\"a.jar\"), \"d*\", \"e*\");\n+        checkContent(\"c\");\n+    }\n+\n+    static void checkContent(String... expected) throws IOException {\n+        try (var jf = new JarFile(\"a.jar\")) {\n+            Asserts.assertEquals(Set.of(expected),\n+                    jf.stream().map(JarEntry::getName).collect(Collectors.toSet()));\n+        }\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/util\/JarUtilsTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -323,0 +323,51 @@\n+    \/**\n+     * Remove entries from a ZIP file.\n+     *\n+     * Each entry can be a name or a name ending with \"*\".\n+     *\n+     * @return number of removed entries\n+     * @throws IOException if there is any I\/O error\n+     *\/\n+    public static int deleteEntries(Path jarfile, String... patterns)\n+            throws IOException {\n+        Path tmpfile = Files.createTempFile(\"jar\", \"jar\");\n+        int count = 0;\n+\n+        try (OutputStream out = Files.newOutputStream(tmpfile);\n+             JarOutputStream jos = new JarOutputStream(out)) {\n+            try (JarFile jf = new JarFile(jarfile.toString())) {\n+                Enumeration<JarEntry> jentries = jf.entries();\n+                top: while (jentries.hasMoreElements()) {\n+                    JarEntry jentry = jentries.nextElement();\n+                    String name = jentry.getName();\n+                    for (String pattern : patterns) {\n+                        if (pattern.endsWith(\"*\")) {\n+                            if (name.startsWith(pattern.substring(\n+                                    0, pattern.length() - 1))) {\n+                                \/\/ Go directly to next entry. This\n+                                \/\/ one is not written into `jos` and\n+                                \/\/ therefore removed.\n+                                count++;\n+                                continue top;\n+                            }\n+                        } else {\n+                            if (name.equals(pattern)) {\n+                                \/\/ Same as above\n+                                count++;\n+                                continue top;\n+                            }\n+                        }\n+                    }\n+                    \/\/ No pattern matched, file retained\n+                    jos.putNextEntry(copyEntry(jentry));\n+                    jf.getInputStream(jentry).transferTo(jos);\n+                }\n+            }\n+        }\n+\n+        \/\/ replace the original JAR file\n+        Files.move(tmpfile, jarfile, StandardCopyOption.REPLACE_EXISTING);\n+\n+        return count;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/util\/JarUtils.java","additions":52,"deletions":1,"binary":false,"changes":53,"status":"modified"}]}