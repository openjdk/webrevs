{"files":[{"patch":"@@ -0,0 +1,331 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8309612 8310584\n+ * @summary The test verifies that JVMTI GetThreadState function reports expected state\n+ *          for mounted (pinned) virtual thread and its carrier thread\n+ * @requires vm.jvmti\n+ * @requires vm.continuations\n+ * @run main\/othervm\/native\n+ *      -agentlib:GetThreadStateMountedTest\n+ *      GetThreadStateMountedTest\n+ *\/\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.locks.LockSupport;\n+\n+\/**\n+ * The test implements different scenarios to get desired JVMTI thread states.\n+ * For each scenario the test also checks states after carrier and virtual threads suspend\/resume\n+ * and after virtual thread interrupt.\n+ * Special handling is required for WAITING state scenarios:\n+ * Spurious wakeups may cause unexpected thread state change and this causes test failure.\n+ * To avoid this, the test thread should be suspended (i.e. carrier and\/or mounted virtual thread is suspended).\n+ *\/\n+public class GetThreadStateMountedTest {\n+\n+    static final int JVMTI_THREAD_STATE_RUNNABLE                 = 0x0004;\n+    static final int JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER = 0x0400;\n+    static final int JVMTI_THREAD_STATE_WAITING                  = 0x0080;\n+    static final int JVMTI_THREAD_STATE_WAITING_INDEFINITELY     = 0x0010;\n+    static final int JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT     = 0x0020;\n+    static final int JVMTI_THREAD_STATE_IN_OBJECT_WAIT           = 0x0100;\n+    static final int JVMTI_THREAD_STATE_SLEEPING                 = 0x0040;\n+    static final int JVMTI_THREAD_STATE_PARKED                   = 0x0200;\n+    static final int JVMTI_THREAD_STATE_IN_NATIVE                = 0x400000;\n+\n+    static void runnable() throws Exception {\n+        TestStatus status = new TestStatus(\"JVMTI_THREAD_STATE_RUNNABLE\");\n+        CountDownLatch ready = new CountDownLatch(1);\n+        final boolean[] stopFlag = new boolean[1];\n+        Thread vthread = createPinnedVThread(() -> {\n+            ready.countDown();\n+            int i = 0;\n+            while (!stopFlag[0]) {\n+                if (i < 200) {\n+                    i++;\n+                } else {\n+                    i = 0;\n+                }\n+            }\n+        });\n+        vthread.start();\n+        ready.await();\n+        testThreadStates(vthread, false, true, JVMTI_THREAD_STATE_RUNNABLE);\n+        stopFlag[0] = true;\n+        status.print();\n+    }\n+\n+    static void blockedOnMonitorEnter() throws Exception {\n+        \/\/ JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER\n+        \/\/ Thread is waiting to enter a synchronized block\/method or,\n+        \/\/ after an Object.wait(), waiting to re-enter a synchronized block\/method.\n+        TestStatus status = new TestStatus(\"JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER\");\n+        CountDownLatch ready = new CountDownLatch(1);\n+        final Object syncObj = new Object();\n+        Thread vthread = createPinnedVThread(() -> {\n+            ready.countDown();\n+            synchronized (syncObj) {\n+            }\n+        });\n+        synchronized (syncObj) {\n+            vthread.start();\n+            ready.await();\n+            Thread.sleep(500); \/\/ wait some time to ensure the thread is blocked on monitor\n+            testThreadStates(vthread, false, true, JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER);\n+        }\n+        status.print();\n+    }\n+\n+    static void waiting(boolean withTimeout) throws Exception {\n+        \/\/ JVMTI_THREAD_STATE_WAITING\n+        \/\/ Thread is waiting.\n+        \/\/ JVMTI_THREAD_STATE_WAITING_INDEFINITELY\n+        \/\/ Thread is waiting without a timeout. For example, Object.wait().\n+        \/\/ JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT\n+        \/\/ Thread is waiting with a maximum time to wait specified. For example, Object.wait(long).\n+        TestStatus status = new TestStatus(withTimeout\n+                                           ? \"JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT\"\n+                                           : \"JVMTI_THREAD_STATE_WAITING_INDEFINITELY\");\n+        CountDownLatch ready = new CountDownLatch(1);\n+        \/\/ Test thread exits by InterruptedException,\n+        \/\/ stopFlag is to handle spurious wakeups.\n+        final boolean[] stopFlag = new boolean[1];\n+        final Object syncObj = new Object();\n+        Thread vthread = createPinnedVThread(() -> {\n+            synchronized (syncObj) {\n+                try {\n+                    ready.countDown();\n+                    while (!stopFlag[0]) {\n+                        if (withTimeout) {\n+                            syncObj.wait(60000);\n+                        } else {\n+                            syncObj.wait();\n+                        }\n+                    }\n+                } catch (InterruptedException ex) {\n+                    \/\/ expected after testThreadStates\n+                }\n+            }\n+        });\n+        vthread.start();\n+        ready.await();\n+\n+        \/\/ Suspend test thread in \"waiting\" state.\n+        suspendWaiting(vthread);\n+\n+        int expectedState = JVMTI_THREAD_STATE_WAITING\n+                | JVMTI_THREAD_STATE_IN_OBJECT_WAIT\n+                | (withTimeout\n+                    ? JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT\n+                    : JVMTI_THREAD_STATE_WAITING_INDEFINITELY);\n+        testThreadStates(vthread, true,  true, expectedState);\n+        \/\/ signal test thread to finish (for safety, Object.wait should throw InterruptedException)\n+        synchronized (syncObj) {\n+            stopFlag[0] = true;\n+            syncObj.notifyAll();\n+        }\n+        status.print();\n+    }\n+\n+    static void sleeping() throws Exception {\n+        \/\/ JVMTI_THREAD_STATE_SLEEPING\n+        \/\/ Thread is sleeping -- Thread.sleep.\n+        \/\/ JVMTI_THREAD_STATE_PARKED\n+        \/\/ A virtual thread that is sleeping, in Thread.sleep,\n+        \/\/ may have this state flag set instead of JVMTI_THREAD_STATE_SLEEPING.\n+        TestStatus status = new TestStatus(\"JVMTI_THREAD_STATE_SLEEPING\");\n+        CountDownLatch ready = new CountDownLatch(1);\n+        \/\/ Test thread exits by InterruptedException,\n+        \/\/ stopFlag is to handle spurious wakeups.\n+        final boolean[] stopFlag = new boolean[1];\n+        Thread vthread = createPinnedVThread(() -> {\n+            ready.countDown();\n+            try {\n+                while (!stopFlag[0]) {\n+                    Thread.sleep(60000);\n+                }\n+            } catch (InterruptedException ex) {\n+                \/\/ expected, ignore\n+            }\n+        });\n+        vthread.start();\n+        ready.await();\n+\n+        \/\/ Suspend test thread in \"waiting\" state.\n+        suspendWaiting(vthread);\n+\n+        \/\/ vthread is suspended, set stopFlag before testThreadStates\n+        stopFlag[0] = true;\n+\n+        \/\/ don't test interrupt() - it causes thread state change for parked thread\n+        \/\/ even if it's suspended\n+        testThreadStates(vthread, true, false,\n+                JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT,\n+                JVMTI_THREAD_STATE_SLEEPING | JVMTI_THREAD_STATE_PARKED);\n+        status.print();\n+    }\n+\n+    static void parked() throws Exception {\n+        \/\/ JVMTI_THREAD_STATE_PARKED\n+        \/\/ Thread is parked, for example: LockSupport.park, LockSupport.parkUtil and LockSupport.parkNanos.\n+        TestStatus status = new TestStatus(\"JVMTI_THREAD_STATE_PARKED\");\n+        CountDownLatch ready = new CountDownLatch(1);\n+        final boolean[] stopFlag = new boolean[1];\n+\n+        Thread vthread = createPinnedVThread(() -> {\n+            ready.countDown();\n+            while (!stopFlag[0]) {\n+                LockSupport.park(Thread.currentThread());\n+            }\n+        });\n+        vthread.start();\n+        ready.await();\n+\n+        \/\/ Suspend test thread in \"waiting\" state.\n+        suspendWaiting(vthread);\n+\n+        \/\/ vthread is suspended, set stopFlag before testThreadStates\n+        stopFlag[0] = true;\n+\n+        \/\/ don't test interrupt() - it causes thread state change for parked thread\n+        \/\/ even if it's suspended\n+        testThreadStates(vthread, true, false,\n+                JVMTI_THREAD_STATE_WAITING | JVMTI_THREAD_STATE_WAITING_INDEFINITELY | JVMTI_THREAD_STATE_PARKED);\n+        \/\/ allow test thread to finish\n+        LockSupport.unpark(vthread);\n+        status.print();\n+    }\n+\n+    static void inNative() throws Exception {\n+        TestStatus status = new TestStatus(\"JVMTI_THREAD_STATE_IN_NATIVE\");\n+        Thread vthread = createPinnedVThread(() -> {\n+            waitInNative();\n+        });\n+        vthread.start();\n+        while (!waitInNativeReady) {\n+            Thread.sleep(50);\n+        }\n+        testThreadStates(vthread, false, true,\n+                JVMTI_THREAD_STATE_RUNNABLE | JVMTI_THREAD_STATE_IN_NATIVE,\n+                0);\n+        endWait();\n+        status.print();\n+    }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        runnable();\n+        \/* \"waiting\" test cases fail due JDK-8310584\n+        blockedOnMonitorEnter();\n+        waiting(false);\n+        waiting(true);\n+        sleeping();\n+        parked();\n+        *\/\n+        inNative();\n+\n+        int errCount = getErrorCount();\n+        if (errCount > 0) {\n+            throw new RuntimeException(\"Test failed, \" + errCount + \" errors\");\n+        }\n+    }\n+\n+    private static Thread createPinnedVThread(Runnable runnable) {\n+        final Object syncObj = new Object();\n+        return Thread.ofVirtual().unstarted(() -> {\n+            synchronized (syncObj) {\n+                runnable.run();\n+            }\n+        });\n+    }\n+\n+    \/\/ Native implementation of suspendWaiting.\n+    \/\/ Returns false if the method is not able to reach the desired state in several tries.\n+    private static native boolean trySuspendInWaitingState(Thread vthread);\n+\n+    \/\/ Suspends virtual thread and ensures it's suspended in \"waiting\" state\n+    \/\/ (to handle possible spurious wakeups).\n+    \/\/ throws an exception if the method is not able to reach the desired state in several tries.\n+    private static void suspendWaiting(Thread vthread) {\n+        boolean result = trySuspendInWaitingState(vthread);\n+        if (!result) {\n+            throw new RuntimeException(\"Failed to suspend thread in WAITING state\");\n+        }\n+    }\n+\n+    \/\/ Tests thread states (vthread and the carrier thread).\n+    \/\/ expectedStrong specifies value which must be present in vthreat state;\n+    \/\/ expectedWeak is a combination of bits which may be set in vthreat state\n+    \/\/ (at least one of the bit must set, but not all).\n+    \/\/ Note: Last steps of the testing are interrupt\/resume the virtual thread,\n+    \/\/ so after the call vthread is interrupted.\n+    private static native void testThread(Thread vthread, boolean isVThreadSuspended,\n+                                          boolean testInterrupt,\n+                                          int expectedStrong, int expectedWeak);\n+    private static native int getErrorCount();\n+    \/\/ To retry test case when spurious wakeup detected.\n+    private static native int resetErrorCount(int count);\n+\n+    private static boolean waitInNativeReady = false;\n+\n+    \/\/ Sets waitInNativeReady static field to true\n+    \/\/ and then waits until endWait() method is called.\n+    private static native void waitInNative();\n+    \/\/ Signals waitInNative() to exit.\n+    private static native void endWait();\n+\n+    private static void testThreadStates(Thread vthread, boolean isVThreadSuspended,\n+                                         boolean testInterrupt,\n+                                         int expectedStrong, int expectedWeak) {\n+        String name = vthread.toString();\n+        log(\"Thread \" + name);\n+        testThread(vthread, isVThreadSuspended, testInterrupt, expectedStrong, expectedWeak);\n+    }\n+\n+    private static void testThreadStates(Thread vthread, boolean isVThreadSuspended,\n+                                         boolean testInterrupt, int expectedState) {\n+        testThreadStates(vthread, isVThreadSuspended, testInterrupt, expectedState, 0);\n+    }\n+\n+    \/\/ helper class to print status of each test\n+    private static class TestStatus {\n+        private final String name;\n+        private final int startErrorCount;\n+        TestStatus(String name) {\n+            this.name = name;\n+            startErrorCount = getErrorCount();\n+            log(\">>\" + name);\n+        }\n+        void print() {\n+            log(\"<<\" + name + (startErrorCount == getErrorCount() ? \" - OK\" : \" - FAILED\"));\n+            log(\"\");\n+        }\n+    }\n+\n+    private static void log(Object s) {\n+        System.out.println(s);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/GetThreadStateMountedTest\/GetThreadStateMountedTest.java","additions":331,"deletions":0,"binary":false,"changes":331,"status":"added"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <jvmti.h>\n+#include <jvmti_common.h>\n+#include <atomic>\n+\n+static jvmtiEnv *jvmti = nullptr;\n+static jint error_count = 0;\n+\n+extern \"C\" JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+  if (vm->GetEnv((void **)&jvmti, JVMTI_VERSION) != JNI_OK) {\n+    LOG(\"Could not initialize JVMTI\\n\");\n+    return JNI_ERR;\n+  }\n+  jvmtiCapabilities caps;\n+  memset(&caps, 0, sizeof(caps));\n+  caps.can_support_virtual_threads = 1;\n+  caps.can_suspend = 1;\n+  caps.can_signal_thread = 1;\n+  jvmtiError err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"JVMTI AddCapabilities error: %d\\n\", err);\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+\n+extern \"C\" JNIEXPORT jboolean JNICALL\n+Java_GetThreadStateMountedTest_trySuspendInWaitingState(JNIEnv* jni, jclass clazz, jthread vthread) {\n+  const int max_retries = 10;\n+  for (int i = 0; i < max_retries; i++) {\n+    \/\/ wait a bit\n+    sleep_ms(100);\n+\n+    \/\/ suspend the thread\n+    LOG(\"suspend vthread (%d)\\n\", i);\n+    suspend_thread(jvmti, jni, vthread);\n+\n+    jint state = get_thread_state(jvmti, jni, vthread);\n+    if ((state & JVMTI_THREAD_STATE_WAITING) != 0) {\n+      LOG(\"suspended in WAITING state\\n\");\n+      return JNI_TRUE;\n+    }\n+    LOG(\"suspended vthread is not waiting: state = %x (%s)\\n\", state, TranslateState(state));\n+    LOG(\"resume vthread\\n\");\n+    resume_thread(jvmti, jni, vthread);\n+  }\n+  LOG(\"ERROR: failed to suspend in WAITING state in %d tries\\n\", max_retries);\n+  return JNI_FALSE;\n+\n+}\n+\n+static void verify_thread_state(const char *name, JNIEnv* jni,\n+  jthread thread, jint expected_strong, jint expected_weak)\n+{\n+  jint state = get_thread_state(jvmti, jni, thread);\n+  LOG(\"%s state(%x): %s\\n\", name, state, TranslateState(state));\n+  bool failed = false;\n+  \/\/ check 1: all expected_strong bits are set\n+  jint actual_strong = state & expected_strong;\n+  if (actual_strong != expected_strong) {\n+    failed = true;\n+    jint missed = expected_strong - actual_strong;\n+    LOG(\"  ERROR: some mandatory bits are not set (%x): %s\\n\",\n+        missed, TranslateState(missed));\n+  }\n+  \/\/ check 2: no bits other than (expected_strong | expected_weak) are set\n+  jint actual_full = state & (expected_strong | expected_weak);\n+  if (actual_full != state) {\n+    failed = true;\n+    jint unexpected = state - actual_full;\n+    LOG(\"  ERROR: some unexpected bits are set (%x): %s\\n\",\n+        unexpected, TranslateState(unexpected));\n+  }\n+  \/\/ check 3: expected_weak checks\n+  if (expected_weak != 0) {\n+    \/\/ check 3a: at least 1 bit from expected_weak is set\n+    if ((state & expected_weak) == 0) {\n+      failed = true;\n+      LOG(\"  ERROR: no expected 'weak' bits are set\\n\");\n+    }\n+    \/\/ check 3b: not all expected_weak bits are set\n+    if ((state & expected_weak) == expected_weak) {\n+      failed = true;\n+      LOG(\"  ERROR: all expected 'weak' bits are set\\n\");\n+    }\n+  }\n+\n+  if (failed) {\n+    LOG(\"  expected 'strong' state (%x): %s\\n\", expected_strong, TranslateState(expected_strong));\n+    LOG(\"  expected 'weak' state (%x): %s\\n\", expected_weak, TranslateState(expected_weak));\n+    error_count++;\n+  }\n+}\n+\n+extern \"C\" JNIEXPORT void JNICALL\n+Java_GetThreadStateMountedTest_testThread(\n+  JNIEnv* jni, jclass clazz, jthread vthread, jboolean is_vthread_suspended,\n+  jboolean test_interrupt,\n+  jint expected_strong, jint expected_weak)\n+{\n+  jint exp_ct_state = JVMTI_THREAD_STATE_ALIVE\n+                      | JVMTI_THREAD_STATE_WAITING\n+                      | JVMTI_THREAD_STATE_WAITING_INDEFINITELY;\n+  jint exp_vt_state = expected_strong\n+                      | JVMTI_THREAD_STATE_ALIVE;\n+\n+  jthread cthread = get_carrier_thread(jvmti, jni, vthread);\n+\n+  verify_thread_state(\"cthread\", jni, cthread,\n+                      exp_ct_state, 0);\n+  verify_thread_state(\"vthread\", jni, vthread,\n+                      exp_vt_state | (is_vthread_suspended ? JVMTI_THREAD_STATE_SUSPENDED : 0),\n+                      expected_weak);\n+\n+  \/\/ suspend ctread and verify\n+  LOG(\"suspend cthread\\n\");\n+  suspend_thread(jvmti, jni, cthread);\n+  verify_thread_state(\"cthread\", jni, cthread,\n+                      exp_ct_state | JVMTI_THREAD_STATE_SUSPENDED, 0);\n+  verify_thread_state(\"vthread\", jni, vthread,\n+                      exp_vt_state | (is_vthread_suspended ? JVMTI_THREAD_STATE_SUSPENDED : 0),\n+                      expected_weak);\n+\n+  \/\/ suspend vthread and verify\n+  if (!is_vthread_suspended) {\n+    LOG(\"suspend vthread\\n\");\n+    suspend_thread(jvmti, jni, vthread);\n+    verify_thread_state(\"cthread\", jni, cthread,\n+                        exp_ct_state | JVMTI_THREAD_STATE_SUSPENDED, 0);\n+    verify_thread_state(\"vthread\", jni, vthread,\n+                        exp_vt_state | JVMTI_THREAD_STATE_SUSPENDED, expected_weak);\n+  }\n+\n+  \/\/ resume cthread and verify\n+  LOG(\"resume cthread\\n\");\n+  resume_thread(jvmti, jni, cthread);\n+  verify_thread_state(\"cthread\", jni, cthread,\n+                      exp_ct_state, 0);\n+  verify_thread_state(\"vthread\", jni, vthread,\n+                      exp_vt_state | JVMTI_THREAD_STATE_SUSPENDED, expected_weak);\n+\n+  if (test_interrupt) {\n+    \/\/ interrupt vthread (while it's suspended)\n+    LOG(\"interrupt vthread\\n\");\n+    check_jvmti_status(jni, jvmti->InterruptThread(vthread), \"error in JVMTI InterruptThread\");\n+    verify_thread_state(\"cthread\", jni, cthread,\n+                        exp_ct_state, 0);\n+    verify_thread_state(\"vthread\", jni, vthread,\n+                        exp_vt_state | JVMTI_THREAD_STATE_SUSPENDED | JVMTI_THREAD_STATE_INTERRUPTED,\n+                        expected_weak);\n+  }\n+\n+  \/\/ resume vthread\n+  LOG(\"resume vthread\\n\");\n+  resume_thread(jvmti, jni, vthread);\n+\n+  \/\/ don't verify thread state after InterruptThread and ResumeThread\n+}\n+\n+extern \"C\" JNIEXPORT int JNICALL\n+Java_GetThreadStateMountedTest_getErrorCount(JNIEnv* jni, jclass clazz) {\n+  return error_count;\n+}\n+\n+\n+static std::atomic<bool> time_to_exit(false);\n+\n+extern \"C\" JNIEXPORT void JNICALL\n+Java_GetThreadStateMountedTest_waitInNative(JNIEnv* jni, jclass clazz) {\n+  \/\/ Notify main thread that we are ready\n+  jfieldID fid = jni->GetStaticFieldID(clazz, \"waitInNativeReady\", \"Z\");\n+  if (fid == nullptr) {\n+    jni->FatalError(\"cannot get waitInNativeReady field\");\n+    return;\n+  }\n+  jni->SetStaticBooleanField(clazz, fid, JNI_TRUE);\n+\n+  while (!time_to_exit) {\n+    sleep_ms(100);\n+  }\n+}\n+\n+extern \"C\" JNIEXPORT void JNICALL\n+Java_GetThreadStateMountedTest_endWait(JNIEnv* jni, jclass clazz) {\n+  time_to_exit = true;\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/GetThreadStateMountedTest\/libGetThreadStateMountedTest.cpp","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"}]}