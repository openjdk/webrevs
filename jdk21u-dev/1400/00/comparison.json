{"files":[{"patch":"@@ -527,0 +527,4 @@\n+    final void initPending(int count) {\n+        U.putInt(this, PENDING, count);\n+    }\n+\n@@ -727,2 +731,3 @@\n-        ForkJoinPool.WorkQueue q; Thread t; boolean owned;\n-        if (owned = (t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n+        ForkJoinPool.WorkQueue q; Thread t; boolean internal;\n+        if (internal =\n+            (t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n@@ -733,1 +738,1 @@\n-            q.helpComplete(this, owned, maxTasks);\n+            q.helpComplete(this, internal, maxTasks);\n@@ -735,0 +740,1 @@\n+\n@@ -741,1 +747,1 @@\n-    final int trySetException(Throwable ex) {\n+    final void onAuxExceptionSet(Throwable ex) {\n@@ -743,4 +749,3 @@\n-        do {} while (isExceptionalStatus(a.trySetThrown(ex)) &&\n-                     a.onExceptionalCompletion(ex, p) &&\n-                     (a = (p = a).completer) != null && a.status >= 0);\n-        return status;\n+        do {} while (a.onExceptionalCompletion(ex, p) &&\n+                     (a = (p = a).completer) != null &&\n+                     a.trySetThrown(ex));\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CountedCompleter.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import java.util.Objects;\n@@ -51,1 +52,1 @@\n-import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.CountDownLatch;\n@@ -53,2 +54,0 @@\n-import java.util.concurrent.locks.ReentrantLock;\n-import java.util.concurrent.locks.Condition;\n@@ -192,21 +191,33 @@\n-     * functionality and control for a set of worker threads:\n-     * Submissions from non-FJ threads enter into submission queues.\n-     * Workers take these tasks and typically split them into subtasks\n-     * that may be stolen by other workers. Work-stealing based on\n-     * randomized scans generally leads to better throughput than\n-     * \"work dealing\" in which producers assign tasks to idle threads,\n-     * in part because threads that have finished other tasks before\n-     * the signalled thread wakes up (which can be a long time) can\n-     * take the task instead.  Preference rules give first priority to\n-     * processing tasks from their own queues (LIFO or FIFO, depending\n-     * on mode), then to randomized FIFO steals of tasks in other\n-     * queues.  This framework began as vehicle for supporting\n-     * tree-structured parallelism using work-stealing.  Over time,\n-     * its scalability advantages led to extensions and changes to\n-     * better support more diverse usage contexts.  Because most\n-     * internal methods and nested classes are interrelated, their\n-     * main rationale and descriptions are presented here; individual\n-     * methods and nested classes contain only brief comments about\n-     * details. There are a fair number of odd code constructions and\n-     * design decisions for components that reside at the edge of Java\n-     * vs JVM functionality.\n+     * functionality and control for a set of worker threads.  Because\n+     * most internal methods and nested classes are interrelated,\n+     * their main rationale and descriptions are presented here;\n+     * individual methods and nested classes contain only brief\n+     * comments about details. Broadly: submissions from non-FJ\n+     * threads enter into submission queues.  Workers take these tasks\n+     * and typically split them into subtasks that may be stolen by\n+     * other workers. Work-stealing based on randomized scans\n+     * generally leads to better throughput than \"work dealing\" in\n+     * which producers assign tasks to idle threads, in part because\n+     * threads that have finished other tasks before the signalled\n+     * thread wakes up (which can be a long time) can take the task\n+     * instead.  Preference rules give first priority to processing\n+     * tasks from their own queues (LIFO or FIFO, depending on mode),\n+     * then to randomized FIFO steals of tasks in other queues.  This\n+     * framework began as vehicle for supporting tree-structured\n+     * parallelism using work-stealing.  Over time, its scalability\n+     * advantages led to extensions and changes to better support more\n+     * diverse usage contexts.  Here's a brief history of major\n+     * revisions, each also with other minor features and changes.\n+     *\n+     * 1. Only handle recursively structured computational tasks\n+     * 2. Async (FIFO) mode and striped submission queues\n+     * 3. Completion-based tasks (mainly CountedCompleters)\n+     * 4. CommonPool and parallelStream support\n+     * 5. InterruptibleTasks for externally submitted tasks\n+     *\n+     * Most changes involve adaptions of base algorithms using\n+     * combinations of static and dynamic bitwise mode settings (both\n+     * here and in ForkJoinTask), and subclassing of ForkJoinTask.\n+     * There are a fair number of odd code constructions and design\n+     * decisions for components that reside at the edge of Java vs JVM\n+     * functionality.\n@@ -243,10 +254,5 @@\n-     * algorithms similar to the one used here. We also use ordered,\n-     * moded accesses and\/or fences for other control, with modes\n-     * reflecting the presence or absence of other contextual sync\n-     * provided by atomic and\/or volatile accesses. Some methods (or\n-     * their primary loops) begin with an acquire fence or\n-     * otherwise-unnecessary volatile read that amounts to an\n-     * acquiring read of \"this\" to cover all fields (which is\n-     * sometimes stronger than necessary, but less brittle). Some\n-     * constructions are intentionally racy because they use read\n-     * values as hints, not for correctness.\n+     * algorithms similar to the one used here.  We use per-operation\n+     * ordered writes of various kinds for updates, but usually use\n+     * explicit load fences for reads, to cover access of several\n+     * fields of possibly several objects without further constraining\n+     * read-by-read ordering.\n@@ -261,1 +267,1 @@\n-     * that differ only in that a lock (field \"access\"; see below) is\n+     * that differ only in that a lock (using field \"phase\"; see below) is\n@@ -272,2 +278,1 @@\n-     * which requires even internal usages to strictly order accesses\n-     * (using a form of lock release).\n+     * which requires stronger forms of order accesses.\n@@ -294,1 +299,4 @@\n-     *    the following rechecks even if the CAS is not attempted.\n+     *    the following rechecks even if the CAS is not attempted.  To\n+     *    more easily distinguish among kinds of CAS failures, we use\n+     *    the compareAndExchange version, and usually handle null\n+     *    returns (indicating contention) separately from others.\n@@ -315,2 +323,2 @@\n-     *    encourage timely writes to indices using store fences when\n-     *    memory ordering is not already constrained by context.\n+     *    encourage timely writes to indices using otherwise\n+     *    unnecessarily strong writes.\n@@ -334,6 +342,6 @@\n-     *    contention, when possible, non-owners avoid reading the\n-     *    \"top\" index at all, and instead use array reads, including\n-     *    one-ahead reads to check whether to repoll, relying on the\n-     *    fact that a non-empty queue does not have two null slots in\n-     *    a row, except in cases (resizes and shifts) that can be\n-     *    detected with a secondary recheck.\n+     *    contention, non-owners avoid reading the \"top\" when\n+     *    possible, by using one-ahead reads to check whether to\n+     *    repoll, relying on the fact that a non-empty queue does not\n+     *    have two null slots in a row, except in cases (resizes and\n+     *    shifts) that can be detected with a secondary recheck that\n+     *    is less likely to conflict with owner writes.\n@@ -367,8 +375,5 @@\n-     * a simple spinlock because submitters encountering a busy queue\n-     * move to a different position to use or create other queues.\n-     * They (spin) block when registering new queues, and less\n-     * often in tryRemove and helpComplete.  The lock needed for\n-     * external queues is generalized (as field \"access\") for\n-     * operations on owned queues that require a fully-fenced write\n-     * (including push, parking status, and termination) in order to\n-     * deal with Dekker-like signalling constructs described below.\n+     * a simple spinlock (as one role of field \"phase\") because\n+     * submitters encountering a busy queue move to a different\n+     * position to use or create other queues.  They (spin) block when\n+     * registering new queues, or indirectly elsewhere, by revisiting\n+     * later.\n@@ -400,11 +405,28 @@\n-     * subfields. Field \"parallelism\" holds the target parallelism\n-     * (normally corresponding to pool size). It is needed (nearly)\n-     * only in methods updating ctl, so is packed nearby. As of the\n-     * current release, users can dynamically reset target\n-     * parallelism, which is read once per update, so only slowly has\n-     * an effect in creating threads or letting them time out and\n-     * terminate when idle.\n-     *\n-     * Field \"runState\" holds lifetime status, atomically and\n-     * monotonically setting SHUTDOWN, STOP, and finally TERMINATED\n-     * bits. It is updated only via bitwise atomics (getAndBitwiseOr).\n+     * subfields.\n+     *\n+     * Field \"runState\" and per-WorkQueue field \"phase\" play similar\n+     * roles, as lockable, versioned counters. Field runState also\n+     * includes monotonic event bits (SHUTDOWN, STOP, and TERMINATED).\n+     * The version tags enable detection of state changes (by\n+     * comparing two reads) modulo bit wraparound. The bit range in\n+     * each case suffices for purposes of determining quiescence,\n+     * termination, avoiding ABA-like errors, and signal control, most\n+     * of which are ultimately based on at most 15bit ranges (due to\n+     * 32767 max total workers). RunState updates do not need to be\n+     * atomic with respect to ctl updates, but because they are not,\n+     * some care is required to avoid stalls. The seqLock properties\n+     * detect changes and conditionally upgrade to coordinate with\n+     * updates. It is typically held for less than a dozen\n+     * instructions unless the queue array is being resized, during\n+     * which contention is rare. To be conservative, lockRunState is\n+     * implemented as a spin\/sleep loop. Here and elsewhere spin\n+     * constants are short enough to apply even on systems with few\n+     * available processors.  In addition to checking pool status,\n+     * reads of runState sometimes serve as acquire fences before\n+     * reading other fields.\n+     *\n+     * Field \"parallelism\" holds the target parallelism (normally\n+     * corresponding to pool size). Users can dynamically reset target\n+     * parallelism, but is only accessed when signalling or awaiting\n+     * work, so only slowly has an effect in creating threads or\n+     * letting them time out and terminate when idle.\n@@ -414,9 +436,21 @@\n-     * registrationLock, but is otherwise concurrently readable (often\n-     * prefaced by a volatile read of mode to check termination, that\n-     * is required anyway, and serves as an acquire fence). To\n-     * simplify index-based operations, the array size is always a\n-     * power of two, and all readers must tolerate null slots.  Worker\n-     * queues are at odd indices. Worker ids masked with SMASK match\n-     * their index. Shared (submission) queues are at even\n-     * indices. Grouping them together in this way simplifies and\n-     * speeds up task scanning.\n+     * runState lock. It is otherwise concurrently readable but reads\n+     * for use in scans (see below) are always prefaced by a volatile\n+     * read of runState (or equivalent constructions), ensuring that\n+     * its state is current at the point it is used (which is all we\n+     * require). To simplify index-based operations, the array size is\n+     * always a power of two, and all readers must tolerate null\n+     * slots.  Worker queues are at odd indices. Worker phase ids\n+     * masked with SMASK match their index. Shared (submission) queues\n+     * are at even indices. Grouping them together in this way aids in\n+     * task scanning: At top-level, both kinds of queues should be\n+     * sampled with approximately the same probability, which is\n+     * simpler if they are all in the same array. But we also need to\n+     * identify what kind they are without looking at them, leading to\n+     * this odd\/even scheme. One disadvantage is that there are\n+     * usually many fewer submission queues, so there can be many\n+     * wasted probes (null slots). But this is still cheaper than\n+     * alternatives. Other loops over the queues array vary in origin\n+     * and stride depending on whether they cover only submission\n+     * (even) or worker (odd) queues or both, and whether they require\n+     * randomness (in which case cyclically exhaustive strides may be\n+     * used).\n@@ -434,1 +468,5 @@\n-     * indices, not references.\n+     * indices, not references. Operations on queues obtained from\n+     * these indices remain valid (with at most some unnecessary extra\n+     * work) even if an underlying worker failed and was replaced by\n+     * another at the same index. During termination, worker queue\n+     * array updates are disabled.\n@@ -443,1 +481,2 @@\n-     * which can be slow and variable.  In many usages, ramp-up time\n+     * which can be slow and variable (even though usages are\n+     * streamlined as much as possible).  In many usages, ramp-up time\n@@ -447,1 +486,1 @@\n-     * many threads poll for too few tasks.\n+     * many threads poll for too few tasks. (See below.)\n@@ -453,12 +492,13 @@\n-     * and\/or running tasks. Unreleased (\"available\") workers are\n-     * recorded in the ctl stack. These workers are made eligible for\n-     * signalling by enqueuing in ctl (see method awaitWork).  The\n-     * \"queue\" is a form of Treiber stack. This is ideal for\n-     * activating threads in most-recently used order, and improves\n-     * performance and locality, outweighing the disadvantages of\n-     * being prone to contention and inability to release a worker\n-     * unless it is topmost on stack. The top stack state holds the\n-     * value of the \"phase\" field of the worker: its index and status,\n-     * plus a version counter that, in addition to the count subfields\n-     * (also serving as version stamps) provide protection against\n-     * Treiber stack ABA effects.\n+     * and\/or running tasks (we cannot accurately determine\n+     * which). Unreleased (\"available\") workers are recorded in the\n+     * ctl stack. These workers are made eligible for signalling by\n+     * enqueuing in ctl (see method runWorker).  This \"queue\" is a\n+     * form of Treiber stack. This is ideal for activating threads in\n+     * most-recently used order, and improves performance and\n+     * locality, outweighing the disadvantages of being prone to\n+     * contention and inability to release a worker unless it is\n+     * topmost on stack. The top stack state holds the value of the\n+     * \"phase\" field of the worker: its index and status, plus a\n+     * version counter that, in addition to the count subfields (also\n+     * serving as version stamps) provide protection against Treiber\n+     * stack ABA effects.\n@@ -478,10 +518,8 @@\n-     * WorkQueue field \"phase\" is used by both workers and the pool to\n-     * manage and track whether a worker is unsignalled (possibly\n-     * blocked waiting for a signal), conveniently using the sign bit\n-     * to check.  When a worker is enqueued its phase field is set\n-     * negative. Note that phase field updates lag queue CAS releases;\n-     * seeing a negative phase does not guarantee that the worker is\n-     * available (and so is never checked in this way). When queued,\n-     * the lower 16 bits of its phase must hold its pool index. So we\n-     * place the index there upon initialization and never modify\n-     * these bits.\n+     * WorkQueue field \"phase\" encodes the queue array id in lower\n+     * bits, and otherwise acts similarly to the pool runState field:\n+     * The \"IDLE\" bit is clear while active (either a released worker\n+     * or a locked external queue), with other bits serving as a\n+     * version counter to distinguish changes across multiple reads.\n+     * Note that phase field updates lag queue CAS releases; seeing a\n+     * non-idle phase does not guarantee that the worker is available\n+     * (and so is never checked in this way).\n@@ -503,24 +541,52 @@\n-     * on the side of too many workers vs too few to avoid stalls.  If\n-     * computations are purely tree structured, it suffices for every\n-     * worker to activate another when it pushes a task into an empty\n-     * queue, resulting in O(log(#threads)) steps to full activation.\n-     * (To reduce resource usages in some cases, at the expense of\n-     * slower startup in others, activation of an idle thread is\n-     * preferred over creating a new one, here and elsewhere.)  If\n-     * instead, tasks come in serially from only a single producer,\n-     * each worker taking its first (since the last activation) task\n-     * from a queue should signal another if there are more tasks in\n-     * that queue. This is equivalent to, but generally faster than,\n-     * arranging the stealer take two tasks, re-pushing one on its own\n-     * queue, and signalling (because its queue is empty), also\n-     * resulting in logarithmic full activation time. Because we don't\n-     * know about usage patterns (or most commonly, mixtures), we use\n-     * both approaches. Together these are minimally necessary for\n-     * maintaining liveness. However, they do not account for the fact\n-     * that when tasks are short-lived, signals are unnecessary\n-     * because workers will already be scanning for new tasks without\n-     * the need of new signals. We track these cases (variable\n-     * \"prevSrc\" in scan() and related methods) to avoid some\n-     * unnecessary signals and scans.  However, signal contention and\n-     * overhead effects may still occur during ramp-up, ramp-down, and\n-     * small computations involving only a few workers.\n+     * on the side of too many workers vs too few to avoid stalls:\n+     *\n+     *  * If computations are purely tree structured, it suffices for\n+     *    every worker to activate another when it pushes a task into\n+     *    an empty queue, resulting in O(log(#threads)) steps to full\n+     *    activation. Emptiness must be conservatively approximated,\n+     *    sometimes resulting in unnecessary signals.  Also, to reduce\n+     *    resource usages in some cases, at the expense of slower\n+     *    startup in others, activation of an idle thread is preferred\n+     *    over creating a new one, here and elsewhere.\n+     *\n+     *  * If instead, tasks come in serially from only a single\n+     *    producer, each worker taking its first (since the last\n+     *    activation) task from a queue should propagate a signal if\n+     *    there are more tasks in that queue. This is equivalent to,\n+     *    but generally faster than, arranging the stealer take\n+     *    multiple tasks, re-pushing one or more on its own queue, and\n+     *    signalling (because its queue is empty), also resulting in\n+     *    logarithmic full activation time\n+     *\n+     * *  Because we don't know about usage patterns (or most commonly,\n+     *    mixtures), we use both approaches, which present even more\n+     *    opportunities to over-signal.  Note that in either of these\n+     *    contexts, signals may be (and often are) unnecessary because\n+     *    active workers continue scanning after running tasks without\n+     *    the need to be signalled (which is one reason work stealing\n+     *    is often faster than alternatives), so additional workers\n+     *    aren't needed. But there is no efficient way to detect this.\n+     *\n+     * * For rapidly branching tasks that require full pool resources,\n+     *   oversignalling is OK, because signalWork will soon have no\n+     *   more workers to create or reactivate. But for others (mainly\n+     *   externally submitted tasks), overprovisioning may cause very\n+     *   noticeable slowdowns due to contention and resource\n+     *   wastage. All remedies are intrinsically heuristic. We use a\n+     *   strategy that works well in most cases: We track \"sources\"\n+     *   (queue ids) of non-empty (usually polled) queues while\n+     *   scanning. These are maintained in the \"source\" field of\n+     *   WorkQueues for use in method helpJoin and elsewhere (see\n+     *   below). We also maintain them as arguments\/results of\n+     *   top-level polls (argument \"window\" in method scan, with setup\n+     *   in method runWorker) as an encoded sliding window of current\n+     *   and previous two sources (or INVALID_ID if none), and stop\n+     *   signalling when all were from the same source. Also, retries\n+     *   are suppressed on CAS failures by newly activated workers,\n+     *   which serves as a form of admission control.  These\n+     *   mechanisms may result in transiently too few workers, but\n+     *   once workers poll from a new source, they rapidly reactivate\n+     *   others.\n+     *\n+     * * Despite these, signal contention and overhead effects still\n+     *   occur during ramp-up and ramp-down of small computations.\n@@ -530,2 +596,2 @@\n-     * the array (by starting at a random index, and using a constant\n-     * cyclically exhaustive stride.) It uses the same basic polling\n+     * the array (by starting at a given index, and using a constant\n+     * cyclically exhaustive stride.)  It uses the same basic polling\n@@ -533,13 +599,11 @@\n-     * permutation on each invocation. (Non-top-level scans; for\n-     * example in helpJoin, use simpler and faster linear probes\n-     * because they do not systematically contend with top-level\n-     * scans.)  The pseudorandom generator need not have high-quality\n-     * statistical properties in the long term. We use Marsaglia\n-     * XorShifts, seeded with the Weyl sequence from ThreadLocalRandom\n-     * probes, which are cheap and suffice. Scans do not otherwise\n-     * explicitly take into account core affinities, loads, cache\n-     * localities, etc, However, they do exploit temporal locality\n-     * (which usually approximates these) by preferring to re-poll\n-     * from the same queue (using method tryPoll()) after a successful\n-     * poll before trying others (see method topLevelExec), which also\n-     * reduces bookkeeping and scanning overhead.  This also reduces\n+     * permutation on each invocation.  The pseudorandom generator\n+     * need not have high-quality statistical properties in the long\n+     * term. We use Marsaglia XorShifts, seeded with the Weyl sequence\n+     * from ThreadLocalRandom probes, which are cheap and\n+     * suffice. Scans do not otherwise explicitly take into account\n+     * core affinities, loads, cache localities, etc, However, they do\n+     * exploit temporal locality (which usually approximates these) by\n+     * preferring to re-poll from the same queue (either in method\n+     * tryPoll() or scan) after a successful poll before trying others\n+     * (see method topLevelExec), which also reduces bookkeeping,\n+     * cache traffic, and scanning overhead. But it also reduces\n@@ -550,2 +614,2 @@\n-     * found by a worker, it deactivates (see awaitWork).  Note that\n-     * not finding tasks doesn't mean that there won't soon be\n+     * found by a worker, it tries to deactivate (in runWorker).  Note\n+     * that not finding tasks doesn't mean that there won't soon be\n@@ -554,52 +618,59 @@\n-     * is OK, given the above signalling rules that will eventually\n-     * maintain progress.  Blocking and unblocking via park\/unpark can\n-     * cause serious slowdowns when tasks are rapidly but irregularly\n-     * generated (which is often due to garbage collectors and other\n-     * activities). One way to ameliorate is for workers to rescan\n-     * multiple times, even when there are unlikely to be tasks. But\n-     * this causes enough memory and CAS contention to prefer using\n-     * quieter spinwaits in awaitWork; currently set to small values\n-     * that only cover near-miss scenarios for deactivate vs activate\n-     * races. Because idle workers are often not yet blocked (via\n-     * LockSupport.park), we use the WorkQueue access field to\n-     * advertise that a waiter actually needs unparking upon signal.\n-     *\n-     * When idle workers are not continually woken up, the count\n-     * fields in ctl allow efficient and accurate discovery of\n-     * quiescent states (i.e., when all workers are idle) after\n-     * deactivation. However, this voting mechanism alone does not\n-     * guarantee that a pool can become dormant (quiesced or\n-     * terminated), because external racing producers do not vote, and\n-     * can asynchronously submit new tasks. To deal with this, the\n-     * final unparked thread (in awaitWork) scans external queues to\n-     * check for tasks that could have been added during a race window\n-     * that would not be accompanied by a signal, in which case\n-     * re-activating itself (or any other worker) to recheck. The same\n-     * sets of checks are used in tryTerminate, to correctly trigger\n-     * delayed termination (shutDown, followed by quiescence) in the\n-     * presence of racing submissions. In all cases, the notion of the\n-     * \"final\" unparked thread is an approximation, because new\n-     * workers could be in the process of being constructed, which\n-     * occasionally adds some extra unnecessary processing.\n-     *\n-     * Shutdown and Termination. A call to shutdownNow invokes\n-     * tryTerminate to atomically set a mode bit. The calling thread,\n-     * as well as every other worker thereafter terminating, helps\n-     * terminate others by cancelling their unprocessed tasks, and\n-     * interrupting other workers. Calls to non-abrupt shutdown()\n-     * preface this by checking isQuiescent before triggering the\n-     * \"STOP\" phase of termination. During termination, workers are\n-     * stopped using all three of (often in parallel): releasing via\n-     * ctl (method reactivate), interrupts, and cancelling tasks that\n-     * will cause workers to not find work and exit. To support this,\n-     * worker references not removed from the queues array during\n-     * termination. It is possible for late thread creations to still\n-     * be in progress after a quiescent termination reports terminated\n-     * status, but they will also immediately terminate. To conform to\n-     * ExecutorService invoke, invokeAll, and invokeAny specs, we must\n-     * track pool status while waiting in ForkJoinTask.awaitDone, and\n-     * interrupt interruptible callers on termination, while also\n-     * avoiding cancelling other tasks that are normally completing\n-     * during quiescent termination. This is tracked by recording\n-     * ForkJoinTask.POOLSUBMIT in task status and\/or as a bit flag\n-     * argument to joining methods.\n+     * is OK given, a secondary check (in awaitWork) needed to cover\n+     * deactivation\/signal races. Blocking and unblocking via\n+     * park\/unpark can cause serious slowdowns when tasks are rapidly\n+     * but irregularly generated (which is often due to garbage\n+     * collectors and other activities). One way to ameliorate is for\n+     * workers to rescan multiple times, even when there are unlikely\n+     * to be tasks. But this causes enough memory traffic and CAS\n+     * contention to prefer using quieter short spinwaits in awaitWork\n+     * and elsewhere.  Those in awaitWork are set to small values that\n+     * only cover near-miss scenarios for inactivate\/activate races.\n+     * Because idle workers are often not yet blocked (parked), we use\n+     * the WorkQueue parker field to advertise that a waiter actually\n+     * needs unparking upon signal.\n+     *\n+     * Quiescence. Workers scan looking for work, giving up when they\n+     * don't find any, without being sure that none are available.\n+     * However, some required functionality relies on consensus about\n+     * quiescence (also termination, discussed below). The count\n+     * fields in ctl allow accurate discovery of states in which all\n+     * workers are idle.  However, because external (asynchronous)\n+     * submitters are not part of this vote, these mechanisms\n+     * themselves do not guarantee that the pool is in a quiescent\n+     * state with respect to methods isQuiescent, shutdown (which\n+     * begins termination when quiescent), helpQuiesce, and indirectly\n+     * others including tryCompensate. Method quiescent() is\n+     * used in all of these contexts. It provides checks that all\n+     * workers are idle and there are no submissions that they could\n+     * poll if they were not idle, retrying on inconsistent reads of\n+     * queues and using the runState seqLock to retry on queue array\n+     * updates.  (It also reports quiescence if the pool is\n+     * terminating.) A true report means only that there was a moment\n+     * at which quiescence held.  False negatives are inevitable (for\n+     * example when queues indices lag updates, as described above),\n+     * which is accommodated when (tentatively) idle by scanning for\n+     * work etc, and then re-invoking. This includes cases in which\n+     * the final unparked thread (in awaitWork) uses quiescent()\n+     * to check for tasks that could have been added during a race\n+     * window that would not be accompanied by a signal, in which case\n+     * re-activating itself (or any other worker) to rescan. Method\n+     * helpQuiesce acts similarly but cannot rely on ctl counts to\n+     * determine that all workers are inactive because the caller and\n+     * any others executing helpQuiesce are not included in counts.\n+     *\n+     * Termination. A call to shutdownNow invokes tryTerminate to\n+     * atomically set a runState mode bit.  However, the process of\n+     * termination is intrinsically non-atomic. The calling thread, as\n+     * well as other workers thereafter terminating help cancel queued\n+     * tasks and interrupt other workers. These actions race with\n+     * unterminated workers.  By default, workers check for\n+     * termination only when accessing pool state.  This may take a\n+     * while but suffices for structured computational tasks.  But not\n+     * necessarily for others. Class InterruptibleTask (see below)\n+     * further arranges runState checks before executing task bodies,\n+     * and ensures interrupts while terminating. Even so, there are no\n+     * guarantees after an abrupt shutdown that remaining tasks\n+     * complete normally or exceptionally or are cancelled.\n+     * Termination may fail to complete if running tasks ignore both\n+     * task status and interrupts and\/or produce more tasks after\n+     * others that could cancel them have exited.\n@@ -615,33 +686,22 @@\n-     * Normally, the first option when joining a task that is not done\n-     * is to try to take it from local queue and run it.  Otherwise,\n-     * any of several actions may be taken when one worker is waiting\n-     * to join a task stolen (or always held) by another.  Because we\n-     * are multiplexing many tasks on to a pool of workers, we can't\n-     * always just let them block (as in Thread.join).  We also cannot\n-     * just reassign the joiner's run-time stack with another and\n-     * replace it later, which would be a form of \"continuation\", that\n-     * even if possible is not necessarily a good idea since we may\n-     * need both an unblocked task and its continuation to progress.\n-     * Instead we combine two tactics:\n-     *\n-     *   Helping: Arranging for the joiner to execute some task that it\n-     *      could be running if the steal had not occurred.\n-     *\n-     *   Compensating: Unless there are already enough live threads,\n-     *      method tryCompensate() may create or re-activate a spare\n-     *      thread to compensate for blocked joiners until they unblock.\n-     *\n-     * A third form (implemented via tryRemove) amounts to helping a\n-     * hypothetical compensator: If we can readily tell that a\n-     * possible action of a compensator is to steal and execute the\n-     * task being joined, the joining thread can do so directly,\n-     * without the need for a compensation thread; although with a\n-     * possibility of reduced parallelism because of a transient gap\n-     * in the queue array that stalls stealers.\n-     *\n-     * Other intermediate forms available for specific task types (for\n-     * example helpAsyncBlocker) often avoid or postpone the need for\n-     * blocking or compensation.\n-     *\n-     * The ManagedBlocker extension API can't use helping so relies\n-     * only on compensation in method awaitBlocker.\n+     * The \"Join\" part of ForkJoinPools consists of a set of\n+     * mechanisms that sometimes or always (depending on the kind of\n+     * task) avoid context switching or adding worker threads when one\n+     * task would otherwise be blocked waiting for completion of\n+     * another, basically, just by running that task or one of its\n+     * subtasks if not already taken. These mechanics are disabled for\n+     * InterruptibleTasks, that guarantee that callers do not executed\n+     * submitted tasks.\n+     *\n+     * The basic structure of joining is an extended spin\/block scheme\n+     * in which workers check for task completions status between\n+     * steps to find other work, until relevant pool state stabilizes\n+     * enough to believe that no such tasks are available, at which\n+     * point blocking. This is usually a good choice of when to block\n+     * that would otherwise be harder to approximate.\n+     *\n+     * These forms of helping may increase stack space usage, but that\n+     * space is bounded in tree\/dag structured procedurally parallel\n+     * designs to be no more than that if a task were executed only by\n+     * the joining thread. This is arranged by associated task\n+     * subclasses that also help detect and control the ways in which\n+     * this may occur.\n@@ -649,3 +709,16 @@\n-     * The algorithm in helpJoin entails a form of \"linear helping\".\n-     * Each worker records (in field \"source\") a reference to the\n-     * queue from which it last stole a task.  The scan in method\n+     * Normally, the first option when joining a task that is not done\n+     * is to try to take it from the local queue and run it. Method\n+     * tryRemoveAndExec tries to do so.  For tasks with any form of\n+     * subtasks that must be completed first, we try to locate these\n+     * subtasks and run them as well. This is easy when local, but\n+     * when stolen, steal-backs are restricted to the same rules as\n+     * stealing (polling), which requires additional bookkeeping and\n+     * scanning. This cost is still very much worthwhile because of\n+     * its impact on task scheduling and resource control.\n+     *\n+     * The two methods for finding and executing subtasks vary in\n+     * details.  The algorithm in helpJoin entails a form of \"linear\n+     * helping\".  Each worker records (in field \"source\") the index of\n+     * the internal queue from which it last stole a task. (Note:\n+     * because chains cannot include even-numbered external queues,\n+     * they are ignored, and 0 is an OK default.) The scan in method\n@@ -653,7 +726,7 @@\n-     * (i.e., steal back a task from and execute it) that could hasten\n-     * completion of the actively joined task.  Thus, the joiner\n-     * executes a task that would be on its own local deque if the\n-     * to-be-joined task had not been stolen. This is a conservative\n-     * variant of the approach described in Wagner & Calder\n-     * \"Leapfrogging: a portable technique for implementing efficient\n-     * futures\" SIGPLAN Notices, 1993\n+     * (i.e., steal back a task from and execute it) that could make\n+     * progress toward completion of the actively joined task.  Thus,\n+     * the joiner executes a task that would be on its own local deque\n+     * if the to-be-joined task had not been stolen. This is a\n+     * conservative variant of the approach described in Wagner &\n+     * Calder \"Leapfrogging: a portable technique for implementing\n+     * efficient futures\" SIGPLAN Notices, 1993\n@@ -662,3 +735,3 @@\n-     * links.  This requires a linear scan of the queues array to\n-     * locate stealers, but isolates cost to when it is needed, rather\n-     * than adding to per-task overhead.  For CountedCompleters, the\n+     * links.  This requires a linear scan of the queues to locate\n+     * stealers, but isolates cost to when it is needed, rather than\n+     * adding to per-task overhead.  For CountedCompleters, the\n@@ -666,1 +739,2 @@\n-     * but requires a similar check of completion chains.\n+     * but requires a similar (but simpler) check of completion\n+     * chains.\n@@ -669,6 +743,19 @@\n-     * stalls delay recording sources. We avoid some of these cases by\n-     * using snapshotted values of ctl as a check that the numbers of\n-     * workers are not changing.  But even when accurately identified,\n-     * stealers might not ever produce a task that the joiner can in\n-     * turn help with. So, compensation is tried upon failure to find\n-     * tasks to run.\n+     * stalls delay recording sources or issuing subtasks. We avoid\n+     * some of these cases by using snapshotted values of ctl as a\n+     * check that the numbers of workers are not changing, along with\n+     * rescans to deal with contention and stalls.  But even when\n+     * accurately identified, stealers might not ever produce a task\n+     * that the joiner can in turn help with.\n+     *\n+     * Related method helpAsyncBlocker does not directly rely on\n+     * subtask structure, but instead avoids or postpones blocking of\n+     * tagged tasks (CompletableFuture.AsynchronousCompletionTask) by\n+     * executing other asyncs that can be processed in any order.\n+     * This is currently invoked only in non-join-based blocking\n+     * contexts from classes CompletableFuture and\n+     * SubmissionPublisher, that could be further generalized.\n+     *\n+     * When any of the above fail to avoid blocking, we rely on\n+     * \"compensation\" -- an indirect form of context switching that\n+     * either activates an existing worker to take the place of the\n+     * blocked one, or expands the number of workers.\n@@ -682,6 +769,22 @@\n-     * when they cause longer-term oversubscription.  Rather than\n-     * impose arbitrary policies, we allow users to override the\n-     * default of only adding threads upon apparent starvation.  The\n-     * compensation mechanism may also be bounded.  Bounds for the\n-     * commonPool better enable JVMs to cope with programming errors\n-     * and abuse before running out of resources to do so.\n+     * by causing longer-term oversubscription. These are inevitable\n+     * without (unobtainably) perfect information about whether worker\n+     * creation is actually necessary.  False alarms are common enough\n+     * to negatively impact performance, so compensation is by default\n+     * attempted only when it appears possible that the pool could\n+     * stall due to lack of any unblocked workers.  However, we allow\n+     * users to override defaults using the long form of the\n+     * ForkJoinPool constructor. The compensation mechanism may also\n+     * be bounded.  Bounds for the commonPool better enable JVMs to\n+     * cope with programming errors and abuse before running out of\n+     * resources to do so.\n+     *\n+     * The ManagedBlocker extension API can't use helping so relies\n+     * only on compensation in method awaitBlocker. This API was\n+     * designed to highlight the uncertainty of compensation decisions\n+     * by requiring implementation of method isReleasable to abort\n+     * compensation during attempts to obtain a stable snapshot. But\n+     * users now rely upon the fact that if isReleasable always\n+     * returns false, the API can be used to obtain precautionary\n+     * compensation, which is sometimes the only reasonable option\n+     * when running unknown code in tasks; which is now supported more\n+     * simply (see method beginCompensatedBlock).\n@@ -696,19 +799,18 @@\n-     * some System property parsing and with security processing that\n-     * takes far longer than the actual construction when\n-     * SecurityManagers are used or properties are set. The common\n-     * pool is distinguished internally by having both a null\n-     * workerNamePrefix and ISCOMMON config bit set, along with\n-     * PRESET_SIZE set if parallelism was configured by system\n-     * property.\n-     *\n-     * When external threads use ForkJoinTask.fork for the common\n-     * pool, they can perform subtask processing (see helpComplete and\n-     * related methods) upon joins.  This caller-helps policy makes it\n-     * sensible to set common pool parallelism level to one (or more)\n-     * less than the total number of available cores, or even zero for\n-     * pure caller-runs. For the sake of ExecutorService specs, we can\n-     * only do this for tasks entered via fork, not submit.  We track\n-     * this using a task status bit (markPoolSubmission).  In all\n-     * other cases, external threads waiting for joins first check the\n-     * common pool for their task, which fails quickly if the caller\n-     * did not fork to common pool.\n+     * some System property parsing and security processing that takes\n+     * far longer than the actual construction when SecurityManagers\n+     * are used or properties are set. The common pool is\n+     * distinguished by having a null workerNamePrefix (which is an\n+     * odd convention, but avoids the need to decode status in factory\n+     * classes).  It also has PRESET_SIZE config set if parallelism\n+     * was configured by system property.\n+     *\n+     * When external threads use the common pool, they can perform\n+     * subtask processing (see helpComplete and related methods) upon\n+     * joins, unless they are submitted using ExecutorService\n+     * submission methods, which implicitly disallow this.  This\n+     * caller-helps policy makes it sensible to set common pool\n+     * parallelism level to one (or more) less than the total number\n+     * of available cores, or even zero for pure caller-runs. External\n+     * threads waiting for joins first check the common pool for their\n+     * task, which fails quickly if the caller did not fork to common\n+     * pool.\n@@ -720,2 +822,2 @@\n-     * including those that retry helping steps or spin until we are\n-     * sure that none apply if there are no workers.\n+     * including those that retry helping steps until we are sure that\n+     * none apply if there are no workers.\n@@ -732,14 +834,40 @@\n-     * Interrupt handling\n-     * ==================\n-     *\n-     * The framework is designed to manage task cancellation\n-     * (ForkJoinTask.cancel) independently from the interrupt status\n-     * of threads running tasks. (See the public ForkJoinTask\n-     * documentation for rationale.)  Interrupts are issued only in\n-     * tryTerminate, when workers should be terminating and tasks\n-     * should be cancelled anyway. Interrupts are cleared only when\n-     * necessary to ensure that calls to LockSupport.park do not loop\n-     * indefinitely (park returns immediately if the current thread is\n-     * interrupted).  For cases in which task bodies are specified or\n-     * desired to interrupt upon cancellation, ForkJoinTask.cancel can\n-     * be overridden to do so (as is done for invoke{Any,All}).\n+     * InterruptibleTasks\n+     * ====================\n+     *\n+     * Regular ForkJoinTasks manage task cancellation (method cancel)\n+     * independently from the interrupt status of threads running\n+     * tasks.  Interrupts are issued internally only while\n+     * terminating, to wake up workers and cancel queued tasks.  By\n+     * default, interrupts are cleared only when necessary to ensure\n+     * that calls to LockSupport.park do not loop indefinitely (park\n+     * returns immediately if the current thread is interrupted).\n+     *\n+     * To comply with ExecutorService specs, we use subclasses of\n+     * abstract class InterruptibleTask for tasks that require\n+     * stronger interruption and cancellation guarantees.  External\n+     * submitters never run these tasks, even if in the common pool.\n+     * InterruptibleTasks include a \"runner\" field (implemented\n+     * similarly to FutureTask) to support cancel(true).  Upon pool\n+     * shutdown, runners are interrupted so they can cancel. Since\n+     * external joining callers never run these tasks, they must await\n+     * cancellation by others, which can occur along several different\n+     * paths.\n+     *\n+     * Across these APIs, rules for reporting exceptions for tasks\n+     * with results accessed via join() differ from those via get(),\n+     * which differ from those invoked using pool submit methods by\n+     * non-workers (which comply with Future.get() specs). Internal\n+     * usages of ForkJoinTasks ignore interrupt status when executing\n+     * or awaiting completion.  Otherwise, reporting task results or\n+     * exceptions is preferred to throwing InterruptedExecptions,\n+     * which are in turn preferred to timeouts. Similarly, completion\n+     * status is preferred to reporting cancellation.  Cancellation is\n+     * reported as an unchecked exception by join(), and by worker\n+     * calls to get(), but is otherwise wrapped in a (checked)\n+     * ExecutionException.\n+     *\n+     * Worker Threads cannot be VirtualThreads, as enforced by\n+     * requiring ForkJoinWorkerThreads in factories.  There are\n+     * several constructions relying on this.  However as of this\n+     * writing, virtual thread bodies are by default run as some form\n+     * of InterruptibleTask.\n@@ -751,22 +879,23 @@\n-     * ForkJoinPool and WorkQueues and their queue arrays, as well the\n-     * placement of their fields. Caches misses and contention due to\n-     * false-sharing have been observed to slow down some programs by\n-     * more than a factor of four. There is no perfect solution, in\n-     * part because isolating more fields also generates more cache\n-     * misses in more common cases (because some fields snd slots are\n-     * usually read at the same time), and the main means of placing\n-     * memory, the @Contended annotation provides only rough control\n-     * (for good reason). We isolate the ForkJoinPool.ctl field as\n-     * well the set of WorkQueue fields that otherwise cause the most\n-     * false-sharing misses with respect to other fields. Also,\n-     * ForkJoinPool fields are ordered such that fields less prone to\n-     * contention effects are first, offsetting those that otherwise\n-     * would be, while also reducing total footprint vs using\n-     * multiple @Contended regions, which tends to slow down\n-     * less-contended applications.  These arrangements mainly reduce\n-     * cache traffic by scanners, which speeds up finding tasks to\n-     * run.  Initial sizing and resizing of WorkQueue arrays is an\n-     * even more delicate tradeoff because the best strategy may vary\n-     * across garbage collectors. Small arrays are better for locality\n-     * and reduce GC scan time, but large arrays reduce both direct\n-     * false-sharing and indirect cases due to GC bookkeeping\n+     * ForkJoinPool and WorkQueues and their queue arrays, as well as\n+     * the placement of their fields. Caches misses and contention due\n+     * to false-sharing have been observed to slow down some programs\n+     * by more than a factor of four. Effects may vary across initial\n+     * memory configuarations, applications, and different garbage\n+     * collectors and GC settings, so there is no perfect solution.\n+     * Too much isolation may generate more cache misses in common\n+     * cases (because some fields snd slots are usually read at the\n+     * same time). The @Contended annotation provides only rough\n+     * control (for good reason). Similarly for relying on fields\n+     * being placed in size-sorted declaration order.\n+     *\n+     * For class ForkJoinPool, it is usually more effective to order\n+     * fields such that the most commonly accessed fields are unlikely\n+     * to share cache lines with adjacent objects under JVM layout\n+     * rules. For class WorkQueue, an embedded @Contended region\n+     * segregates fields most heavily updated by owners from those\n+     * most commonly read by stealers or other management.  Initial\n+     * sizing and resizing of WorkQueue arrays is an even more\n+     * delicate tradeoff because the best strategy systematically\n+     * varies across garbage collectors. Small arrays are better for\n+     * locality and reduce GC scan time, but large arrays reduce both\n+     * direct false-sharing and indirect cases due to GC bookkeeping\n@@ -774,2 +903,1 @@\n-     * not especially fast because they require atomic transfers, and\n-     * may cause other scanning workers to stall or give up.\n+     * not especially fast because they require atomic transfers.\n@@ -779,2 +907,3 @@\n-     * queues, or their uses must be accompanied by re-evaluation of\n-     * these placement and sizing decisions.)\n+     * queues, or their uses, or JVM layout policies, must be\n+     * accompanied by re-evaluation of these placement and sizing\n+     * decisions.)\n@@ -792,1 +921,3 @@\n-     * with very few invariants. All fields are read into locals\n+     * with very few invariants. All atomic task slot updates use\n+     * Unsafe operations requiring offset positions, not indices, as\n+     * computed by method slotOffset. All fields are read into locals\n@@ -823,1 +954,1 @@\n-     * (1) Static constants\n+     * (1) Static configuration constants\n@@ -837,9 +968,13 @@\n-     * * Use of Unsafe vs VarHandle, including re-instatement of some\n-     *   constructions from pre-VarHandle versions.\n-     * * Reduced memory and signal contention, mainly by distinguishing\n-     *   failure cases.\n-     * * Improved initialization, in part by preparing for possible\n-     *   removal of SecurityManager\n-     * * Enable resizing (includes refactoring quiescence\/termination)\n-     * * Unification of most internal vs external operations; some made\n-     *   possible via use of WorkQueue.access, and POOLSUBMIT status in tasks.\n+     * * New abstract class ForkJoinTask.InterruptibleTask ensures\n+     *   handling of tasks submitted under the ExecutorService\n+     *   API are consistent with specs.\n+     * * Method quiescent() replaces previous quiescence-related\n+     *   checks, relying on versioning and sequence locking instead\n+     *   of ReentrantLock.\n+     * * Termination processing now ensures that internal data\n+     *   structures are maintained consistently enough while stopping\n+     *   to interrupt all workers and cancel all tasks. It also uses a\n+     *   CountDownLatch instead of a Condition for termination because\n+     *   of lock change.\n+     * * Many other changes to avoid performance regressions due\n+     *   to the above.\n@@ -865,1 +1000,1 @@\n-     * requirements, but also far short of MAX_CAP and typical OS\n+     * requirements, but also far short of maximum capacity and typical OS\n@@ -877,20 +1012,36 @@\n-    \/\/ Bounds\n-    static final int SWIDTH    = 16;               \/\/ width of short\n-    static final int SMASK     = 0xffff;           \/\/ short bits == max index\n-    static final int MAX_CAP   = 0x7fff;           \/\/ max #workers - 1\n-\n-    \/\/ pool.runState and workQueue.access bits and sentinels\n-    static final int STOP         = 1 << 31;       \/\/ must be negative\n-    static final int SHUTDOWN     = 1;\n-    static final int TERMINATED   = 2;\n-    static final int PARKED       = -1;            \/\/ access value when parked\n-\n-    \/\/ {pool, workQueue}.config bits\n-    static final int FIFO         = 1 << 16;       \/\/ fifo queue or access mode\n-    static final int SRC          = 1 << 17;       \/\/ set when stealable\n-    static final int CLEAR_TLS    = 1 << 18;       \/\/ set for Innocuous workers\n-    static final int TRIMMED      = 1 << 19;       \/\/ timed out while idle\n-    static final int ISCOMMON     = 1 << 20;       \/\/ set for common pool\n-    static final int PRESET_SIZE  = 1 << 21;       \/\/ size was set by property\n-\n-    static final int UNCOMPENSATE = 1 << 16;       \/\/ tryCompensate return\n+    \/\/ conversions among short, int, long\n+    static final int  SMASK           = 0xffff;      \/\/ (unsigned) short bits\n+    static final long LMASK           = 0xffffffffL; \/\/ lower 32 bits of long\n+    static final long UMASK           = ~LMASK;      \/\/ upper 32 bits\n+\n+    \/\/ masks and sentinels for queue indices\n+    static final int MAX_CAP          = 0x7fff;   \/\/ max # workers\n+    static final int EXTERNAL_ID_MASK = 0x3ffe;   \/\/ max external queue id\n+    static final int INVALID_ID       = 0x4000;   \/\/ unused external queue id\n+\n+    \/\/ pool.runState bits\n+    static final int STOP             = 1 <<  0;   \/\/ terminating\n+    static final int SHUTDOWN         = 1 <<  1;   \/\/ terminate when quiescent\n+    static final int TERMINATED       = 1 <<  2;   \/\/ only set if STOP also set\n+    static final int RS_LOCK          = 1 <<  3;   \/\/ lowest seqlock bit\n+\n+    \/\/ spin\/sleep limits for runState locking and elsewhere\n+    static final int SPIN_WAITS       = 1 <<  7;   \/\/ max calls to onSpinWait\n+    static final int MIN_SLEEP        = 1 << 10;   \/\/ approx 1 usec as nanos\n+    static final int MAX_SLEEP        = 1 << 20;   \/\/ approx 1 sec  as nanos\n+\n+    \/\/ {pool, workQueue} config bits\n+    static final int FIFO             = 1 << 0;   \/\/ fifo queue or access mode\n+    static final int CLEAR_TLS        = 1 << 1;   \/\/ set for Innocuous workers\n+    static final int PRESET_SIZE      = 1 << 2;   \/\/ size was set by property\n+\n+    \/\/ source history window packing used in scan() and runWorker()\n+    static final long RESCAN          = 1L << 63; \/\/ must be negative\n+    static final long WMASK           = ~(((long)SMASK) << 48); \/\/ id bits only\n+    static final long NO_HISTORY      = ((((long)INVALID_ID) << 32) | \/\/ no 3rd\n+                                         (((long)INVALID_ID) << 16)); \/\/ no 2nd\n+\n+    \/\/ others\n+    static final int DEREGISTERED     = 1 << 31;  \/\/ worker terminating\n+    static final int UNCOMPENSATE     = 1 << 16;  \/\/ tryCompensate return\n+    static final int IDLE             = 1 << 16;  \/\/ phase seqlock\/version count\n@@ -916,3 +1067,0 @@\n-    \/\/ Lower and upper word masks\n-    static final long SP_MASK  = 0xffffffffL;\n-    static final long UC_MASK  = ~SP_MASK;\n@@ -927,3 +1075,9 @@\n-    \/\/ sp bits\n-    static final int SS_SEQ    = 1 << 16;  \/\/ version count\n-    static final int INACTIVE  = 1 << 31;  \/\/ phase bit when idle\n+\n+    \/*\n+     * All atomic operations on task arrays (queues) use Unsafe\n+     * operations that take array offsets versus indices, based on\n+     * array base and shift constants established during static\n+     * initialization.\n+     *\/\n+    static final long ABASE;\n+    static final int  ASHIFT;\n@@ -933,0 +1087,8 @@\n+    \/**\n+     * Returns the array offset corresponding to the given index for\n+     * Unsafe task queue operations\n+     *\/\n+    static long slotOffset(int index) {\n+        return ((long)index << ASHIFT) + ABASE;\n+    }\n+\n@@ -1049,3 +1211,3 @@\n-        int stackPred;             \/\/ pool stack (ctl) predecessor link\n-        int config;                \/\/ index, mode, ORed with SRC after init\n-        int base;                  \/\/ index of next slot for poll\n+        \/\/ fields declared in order of their likely layout on most VMs\n+        final ForkJoinWorkerThread owner; \/\/ null if shared\n+        volatile Thread parker;    \/\/ set when parking in awaitWork\n@@ -1053,1 +1215,2 @@\n-        final ForkJoinWorkerThread owner; \/\/ owning thread or null if shared\n+        int base;                  \/\/ index of next slot for poll\n+        final int config;          \/\/ mode bits\n@@ -1059,1 +1222,1 @@\n-        volatile int access;       \/\/ values 0, 1 (locked), PARKED, STOP\n+        volatile int phase;        \/\/ versioned active status\n@@ -1061,1 +1224,1 @@\n-        volatile int phase;        \/\/ versioned, negative if inactive\n+        int stackPred;             \/\/ pool stack (ctl) predecessor link\n@@ -1063,1 +1226,1 @@\n-        volatile int source;       \/\/ source queue id in topLevelExec\n+        volatile int source;       \/\/ source queue id (or DEREGISTERED)\n@@ -1069,1 +1232,0 @@\n-        private static final long ACCESS;\n@@ -1071,2 +1233,4 @@\n-        private static final long ABASE;\n-        private static final int  ASHIFT;\n+        private static final long BASE;\n+        private static final long TOP;\n+        private static final long SOURCE;\n+        private static final long ARRAY;\n@@ -1074,3 +1238,5 @@\n-        static ForkJoinTask<?> getAndClearSlot(ForkJoinTask<?>[] a, int i) {\n-            return (ForkJoinTask<?>)\n-                U.getAndSetReference(a, ((long)i << ASHIFT) + ABASE, null);\n+        final void updateBase(int v) {\n+            U.putIntVolatile(this, BASE, v);\n+        }\n+        final void updateTop(int v) {\n+            U.putIntOpaque(this, TOP, v);\n@@ -1078,4 +1244,2 @@\n-        static boolean casSlotToNull(ForkJoinTask<?>[] a, int i,\n-                                     ForkJoinTask<?> c) {\n-            return U.compareAndSetReference(a, ((long)i << ASHIFT) + ABASE,\n-                                            c, null);\n+        final void forgetSource() {\n+            U.putIntOpaque(this, SOURCE, 0);\n@@ -1083,2 +1247,2 @@\n-        final void forcePhaseActive() {    \/\/ clear sign bit\n-            U.getAndBitwiseAndInt(this, PHASE, 0x7fffffff);\n+        final void updateArray(ForkJoinTask<?>[] a) {\n+            U.getAndSetReference(this, ARRAY, a);\n@@ -1086,2 +1250,2 @@\n-        final int getAndSetAccess(int v) {\n-            return U.getAndSetInt(this, ACCESS, v);\n+        final void unlockPhase() {\n+            U.getAndAddInt(this, PHASE, IDLE);\n@@ -1089,2 +1253,4 @@\n-        final void releaseAccess() {\n-            U.putIntRelease(this, ACCESS, 0);\n+        final boolean tryLockPhase() {    \/\/ seqlock acquire\n+            int p;\n+            return (((p = phase) & IDLE) != 0 &&\n+                    U.compareAndSetInt(this, PHASE, p, p + IDLE));\n@@ -1094,1 +1260,1 @@\n-         * Constructor. For owned queues, most fields are initialized\n+         * Constructor. For internal queues, most fields are initialized\n@@ -1097,1 +1263,7 @@\n-        WorkQueue(ForkJoinWorkerThread owner, int config) {\n+        WorkQueue(ForkJoinWorkerThread owner, int id, int cfg,\n+                  boolean clearThreadLocals) {\n+            if (clearThreadLocals)\n+                cfg |= CLEAR_TLS;\n+            this.config = cfg;\n+            top = base = 1;\n+            this.phase = id;\n@@ -1099,2 +1271,0 @@\n-            this.config = config;\n-            base = top = 1;\n@@ -1107,1 +1277,1 @@\n-            return (config & 0xffff) >>> 1; \/\/ ignore odd\/even tag bit\n+            return (phase & 0xffff) >>> 1; \/\/ ignore odd\/even tag bit\n@@ -1114,1 +1284,1 @@\n-            int unused = access;            \/\/ for ordering effect\n+            int unused = phase;             \/\/ for ordering effect\n@@ -1122,3 +1292,3 @@\n-         * @param pool the pool. Must be non-null unless terminating.\n-         * @param signalIfEmpty true if signal when pushing to empty queue\n-         * @throws RejectedExecutionException if array cannot be resized\n+         * @param pool the pool to signal if was previously empty, else null\n+         * @param internal if caller owns this queue\n+         * @throws RejectedExecutionException if array could not be resized\n@@ -1127,8 +1297,18 @@\n-                        boolean signalIfEmpty) {\n-            boolean resize = false;\n-            int s = top++, b = base, cap, m; ForkJoinTask<?>[] a;\n-            if ((a = array) != null && (cap = a.length) > 0) {\n-                if ((m = (cap - 1)) == s - b) {\n-                    resize = true;            \/\/ rapidly grow until large\n-                    int newCap = (cap < 1 << 24) ? cap << 2 : cap << 1;\n-                    ForkJoinTask<?>[] newArray;\n+                        boolean internal) {\n+            int s = top, b = base, cap, m, room; ForkJoinTask<?>[] a;\n+            if ((a = array) == null || (cap = a.length) <= 0 ||\n+                (room = (m = cap - 1) - (s - b)) < 0) { \/\/ could not resize\n+                if (!internal)\n+                    unlockPhase();\n+                throw new RejectedExecutionException(\"Queue capacity exceeded\");\n+            }\n+            top = s + 1;\n+            long pos = slotOffset(m & s);\n+            if (!internal)\n+                U.putReference(a, pos, task);         \/\/ inside lock\n+            else\n+                U.getAndSetReference(a, pos, task);   \/\/ fully fenced\n+            if (room == 0) {                          \/\/ resize for next time\n+                int newCap;                           \/\/ rapidly grow until large\n+                if ((newCap = (cap < 1 << 24) ? cap << 2 : cap << 1) > 0) {\n+                    ForkJoinTask<?>[] newArray = null;\n@@ -1137,5 +1317,1 @@\n-                    } catch (Throwable ex) {\n-                        top = s;\n-                        access = 0;\n-                        throw new RejectedExecutionException(\n-                            \"Queue capacity exceeded\");\n+                    } catch (OutOfMemoryError ex) {\n@@ -1143,5 +1319,9 @@\n-                    if (newCap > 0) {         \/\/ always true\n-                        int newMask = newCap - 1, k = s;\n-                        do {                  \/\/ poll old, push to new\n-                            newArray[k-- & newMask] = task;\n-                        } while ((task = getAndClearSlot(a, k & m)) != null);\n+                    if (newArray != null) {           \/\/ else throw on next push\n+                        int newMask = newCap - 1;     \/\/ poll old, push to new\n+                        for (int k = s, j = cap; j > 0; --j, --k) {\n+                            if ((newArray[k & newMask] =\n+                                 (ForkJoinTask<?>)U.getAndSetReference(\n+                                     a, slotOffset(k & m), null)) == null)\n+                                break;                \/\/ lost to pollers\n+                        }\n+                        updateArray(newArray);        \/\/ fully fenced\n@@ -1149,1 +1329,0 @@\n-                    array = newArray;\n@@ -1151,6 +1330,0 @@\n-                else\n-                    a[m & s] = task;\n-                getAndSetAccess(0);           \/\/ for memory effects if owned\n-                if ((resize || (a[m & (s - 1)] == null && signalIfEmpty)) &&\n-                    pool != null)\n-                    pool.signalWork();\n@@ -1158,0 +1331,5 @@\n+            if (!internal)\n+                unlockPhase();\n+            if ((room == 0 || room >= m || a[m & (s - 1)] == null) &&\n+                pool != null)\n+                pool.signalWork();\n@@ -1165,1 +1343,1 @@\n-        final ForkJoinTask<?> nextLocalTask(int fifo) {\n+        private ForkJoinTask<?> nextLocalTask(int fifo) {\n@@ -1168,3 +1346,3 @@\n-            int p = top, s = p - 1, b = base, nb, cap;\n-            if (p - b > 0 && a != null && (cap = a.length) > 0) {\n-                do {\n+            int b = base, p = top, cap;\n+            if (a != null && (cap = a.length) > 0) {\n+                for (int m = cap - 1, s, nb; p - b > 0; ) {\n@@ -1172,3 +1350,4 @@\n-                        if ((t = getAndClearSlot(a, (cap - 1) & s)) != null)\n-                            top = s;\n-                        break;                   \/\/ lost race for only task\n+                        if ((t = (ForkJoinTask<?>)U.getAndSetReference(\n+                                 a, slotOffset(m & (s = p - 1)), null)) != null)\n+                            updateTop(s);       \/\/ else lost race for only task\n+                        break;\n@@ -1176,2 +1355,3 @@\n-                    else if ((t = getAndClearSlot(a, (cap - 1) & b)) != null) {\n-                        base = nb;\n+                    if ((t = (ForkJoinTask<?>)U.getAndSetReference(\n+                             a, slotOffset(m & b), null)) != null) {\n+                        updateBase(nb);\n@@ -1180,5 +1360,3 @@\n-                    else {\n-                        while (b == (b = base)) {\n-                            U.loadFence();\n-                            Thread.onSpinWait(); \/\/ spin to reduce memory traffic\n-                        }\n+                    while (b == (b = base)) {\n+                        U.loadFence();\n+                        Thread.onSpinWait();    \/\/ spin to reduce memory traffic\n@@ -1186,2 +1364,1 @@\n-                } while (p - b > 0);\n-                U.storeStoreFence(); \/\/ for timely index updates\n+                }\n@@ -1194,1 +1371,1 @@\n-         * (Always owned, never called for Common pool.)\n+         * (Always internal, never called for Common pool.)\n@@ -1202,0 +1379,2 @@\n+         * @param task the task. Caller must ensure non-null.\n+         * @param internal if caller owns this queue\n@@ -1203,1 +1382,2 @@\n-        final boolean tryUnpush(ForkJoinTask<?> task, boolean owned) {\n+        final boolean tryUnpush(ForkJoinTask<?> task, boolean internal) {\n+            boolean taken = false;\n@@ -1205,12 +1385,8 @@\n-            int p = top, s, cap, k;\n-            if (task != null && base != p && a != null && (cap = a.length) > 0 &&\n-                a[k = (cap - 1) & (s = p - 1)] == task) {\n-                if (owned || getAndSetAccess(1) == 0) {\n-                    if (top != p || a[k] != task ||\n-                        getAndClearSlot(a, k) == null)\n-                        access = 0;\n-                    else {\n-                        top = s;\n-                        access = 0;\n-                        return true;\n-                    }\n+            int p = top, s = p - 1, cap, k;\n+            if (a != null && (cap = a.length) > 0 &&\n+                a[k = (cap - 1) & s] == task &&\n+                (internal || tryLockPhase())) {\n+                if (top == p &&\n+                    U.compareAndSetReference(a, slotOffset(k), task, null)) {\n+                    taken = true;\n+                    updateTop(s);\n@@ -1218,0 +1394,2 @@\n+                if (!internal)\n+                    unlockPhase();\n@@ -1219,1 +1397,1 @@\n-            return false;\n+            return taken;\n@@ -1227,1 +1405,1 @@\n-            int cfg = config, p = top, b = base, cap;\n+            int b = base, cfg = config, p = top, cap;\n@@ -1243,2 +1421,1 @@\n-         * Polls for a task. Used only by non-owners in usually\n-         * uncontended contexts.\n+         * Polls for a task. Used only by non-owners.\n@@ -1249,15 +1426,22 @@\n-            for (int b = base;;) {\n-                int cap; ForkJoinTask<?>[] a;\n-                if ((a = array) == null || (cap = a.length) <= 0)\n-                    break;                        \/\/ currently impossible\n-                int k = (cap - 1) & b, nb = b + 1, nk = (cap - 1) & nb;\n-                ForkJoinTask<?> t = a[k];\n-                U.loadFence();                    \/\/ for re-reads\n-                if (b != (b = base))              \/\/ inconsistent\n-                    ;\n-                else if (t != null && casSlotToNull(a, k, t)) {\n-                    base = nb;\n-                    U.storeFence();\n-                    if (pool != null && a[nk] != null)\n-                        pool.signalWork();        \/\/ propagate\n-                    return t;\n+            for (;;) {\n+                ForkJoinTask<?>[] a = array;\n+                int b = base, cap, k;\n+                if (a == null || (cap = a.length) <= 0)\n+                    break;\n+                ForkJoinTask<?> t = a[k = b & (cap - 1)];\n+                U.loadFence();\n+                if (base == b) {\n+                    Object o;\n+                    int nb = b + 1, nk = nb & (cap - 1);\n+                    if (t == null)\n+                        o = a[k];\n+                    else if (t == (o = U.compareAndExchangeReference(\n+                                       a, slotOffset(k), t, null))) {\n+                        updateBase(nb);\n+                        if (a[nk] != null && pool != null)\n+                            pool.signalWork();    \/\/ propagate\n+                        return t;\n+                    }\n+                    if (o == null && a[nk] == null && array == a &&\n+                        (phase & (IDLE | 1)) != 0 && top - base <= 0)\n+                        break;                    \/\/ empty\n@@ -1265,4 +1449,0 @@\n-                else if (array != a || a[k] != null)\n-                    ;                             \/\/ stale\n-                else if (a[nk] == null && top - b <= 0)\n-                    break;                        \/\/ empty\n@@ -1274,3 +1454,3 @@\n-         * Tries to poll next task in FIFO order, failing on\n-         * contention or stalls. Used only by topLevelExec to repoll\n-         * from the queue obtained from pool.scan.\n+         * Tries to poll next task in FIFO order, failing without\n+         * retries on contention or stalls. Used only by topLevelExec\n+         * to repoll from the queue obtained from pool.scan.\n@@ -1278,19 +1458,9 @@\n-        final ForkJoinTask<?> tryPoll() {\n-            int b = base, cap; ForkJoinTask<?>[] a;\n-            if ((a = array) != null && (cap = a.length) > 0) {\n-                for (;;) {\n-                    int k = (cap - 1) & b, nb = b + 1;\n-                    ForkJoinTask<?> t = a[k];\n-                    U.loadFence();                \/\/ for re-reads\n-                    if (b != (b = base))\n-                        ;                         \/\/ inconsistent\n-                    else if (t != null) {\n-                        if (casSlotToNull(a, k, t)) {\n-                            base = nb;\n-                            U.storeStoreFence();\n-                            return t;\n-                        }\n-                        break;                   \/\/ contended\n-                    }\n-                    else if (a[k] == null)\n-                        break;                   \/\/ empty or stalled\n+        private ForkJoinTask<?> tryPoll() {\n+            ForkJoinTask<?> t; ForkJoinTask<?>[] a; int b, cap, k;\n+            if ((a = array) != null && (cap = a.length) > 0 &&\n+                (t = a[k = (b = base) & (cap - 1)]) != null) {\n+                U.loadFence();\n+                if (base == b &&\n+                    U.compareAndSetReference(a, slotOffset(k), t, null)) {\n+                    updateBase(b + 1);\n+                    return t;\n@@ -1306,2 +1476,2 @@\n-         * remaining local tasks and\/or others available from its\n-         * source queue, if any.\n+         * remaining local tasks and\/or others available from the\n+         * given queue, if any.\n@@ -1309,2 +1479,6 @@\n-        final void topLevelExec(ForkJoinTask<?> task, WorkQueue src) {\n-            int cfg = config, fifo = cfg & FIFO, nstolen = 1;\n+        final void topLevelExec(ForkJoinTask<?> task, WorkQueue src, int srcId) {\n+            int cfg = config, fifo = cfg & FIFO, nstolen = nsteals + 1;\n+            if ((srcId & 1) != 0) \/\/ don't record external sources\n+                source = srcId;\n+            if ((cfg & CLEAR_TLS) != 0)\n+                ThreadLocalRandom.eraseThreadLocals(Thread.currentThread());\n@@ -1313,2 +1487,2 @@\n-                if ((task = nextLocalTask(fifo)) == null &&\n-                    src != null && (task = src.tryPoll()) != null)\n+                if ((task = nextLocalTask(fifo)) == null && src != null &&\n+                    (task = src.tryPoll()) != null)\n@@ -1317,4 +1491,2 @@\n-            nsteals += nstolen;\n-            source = 0;\n-            if ((cfg & CLEAR_TLS) != 0)\n-                ThreadLocalRandom.eraseThreadLocals(Thread.currentThread());\n+            nsteals = nstolen;\n+            forgetSource();\n@@ -1325,2 +1497,1 @@\n-         * runs task if present, shifting others to fill gap.\n-         * @return task status if removed, else 0\n+         * runs task if present.\n@@ -1328,1 +1499,1 @@\n-        final int tryRemoveAndExec(ForkJoinTask<?> task, boolean owned) {\n+        final void tryRemoveAndExec(ForkJoinTask<?> task, boolean internal) {\n@@ -1330,19 +1501,23 @@\n-            int p = top, s = p - 1, d = p - base, cap;\n-            if (task != null && d > 0 && a != null && (cap = a.length) > 0) {\n-                for (int m = cap - 1, i = s; ; --i) {\n-                    ForkJoinTask<?> t; int k;\n-                    if ((t = a[k = i & m]) == task) {\n-                        if (!owned && getAndSetAccess(1) != 0)\n-                            break;                 \/\/ fail if locked\n-                        else if (top != p || a[k] != task ||\n-                                 getAndClearSlot(a, k) == null) {\n-                            access = 0;\n-                            break;                 \/\/ missed\n-                        }\n-                        else {\n-                            if (i != s && i == base)\n-                                base = i + 1;      \/\/ avoid shift\n-                            else {\n-                                for (int j = i; j != s;) \/\/ shift down\n-                                    a[j & m] = getAndClearSlot(a, ++j & m);\n-                                top = s;\n+            int b = base, p = top, s = p - 1, d = p - b, cap;\n+            if (a != null && (cap = a.length) > 0) {\n+                for (int m = cap - 1, i = s; d > 0; --i, --d) {\n+                    ForkJoinTask<?> t; int k; boolean taken;\n+                    if ((t = a[k = i & m]) == null)\n+                        break;\n+                    if (t == task) {\n+                        long pos = slotOffset(k);\n+                        if (!internal && !tryLockPhase())\n+                            break;                  \/\/ fail if locked\n+                        if (taken =\n+                            (top == p &&\n+                             U.compareAndSetReference(a, pos, task, null))) {\n+                            if (i == s)             \/\/ act as pop\n+                                updateTop(s);\n+                            else if (i == base)     \/\/ act as poll\n+                                updateBase(i + 1);\n+                            else {                  \/\/ swap with top\n+                                U.putReferenceVolatile(\n+                                    a, pos, (ForkJoinTask<?>)\n+                                    U.getAndSetReference(\n+                                        a, slotOffset(s & m), null));\n+                                updateTop(s);\n@@ -1350,2 +1525,0 @@\n-                            releaseAccess();\n-                            return task.doExec();\n@@ -1353,2 +1526,4 @@\n-                    }\n-                    else if (t == null || --d == 0)\n+                        if (!internal)\n+                            unlockPhase();\n+                        if (taken)\n+                            task.doExec();\n@@ -1356,0 +1531,1 @@\n+                    }\n@@ -1358,1 +1534,0 @@\n-            return 0;\n@@ -1367,1 +1542,1 @@\n-         * @return task status on exit\n+         * @return task status if known to be done\n@@ -1369,1 +1544,1 @@\n-        final int helpComplete(ForkJoinTask<?> task, boolean owned, int limit) {\n+        final int helpComplete(ForkJoinTask<?> task, boolean internal, int limit) {\n@@ -1373,7 +1548,11 @@\n-                    ForkJoinTask<?>[] a; ForkJoinTask<?> t;\n-                    int p, s, cap, k;\n-                    if ((status = task.status) < 0)\n-                        return status;\n-                    if ((a = array) == null || (cap = a.length) <= 0 ||\n-                        (t = a[k = (cap - 1) & (s = (p = top) - 1)]) == null ||\n-                        !(t instanceof CountedCompleter))\n+                    ForkJoinTask<?>[] a; ForkJoinTask<?> t; boolean taken;\n+                    int stat, p, s, cap, k;\n+                    if ((stat = task.status) < 0) {\n+                        status = stat;\n+                        break;\n+                    }\n+                    if ((a = array) == null || (cap = a.length) <= 0)\n+                        break;\n+                    if ((t = a[k = (cap - 1) & (s = (p = top) - 1)]) == null)\n+                        break;\n+                    if (!(t instanceof CountedCompleter))\n@@ -1381,1 +1560,2 @@\n-                    for (CountedCompleter<?> f = (CountedCompleter<?>)t;;) {\n+                    CountedCompleter<?> f = (CountedCompleter<?>)t;\n+                    for (int steps = cap;;) {       \/\/ bound path\n@@ -1384,2 +1564,2 @@\n-                        else if ((f = f.completer) == null)\n-                            break outer;       \/\/ ineligible\n+                        if ((f = f.completer) == null || --steps == 0)\n+                            break outer;\n@@ -1387,8 +1567,10 @@\n-                    if (!owned && getAndSetAccess(1) != 0)\n-                        break;                 \/\/ fail if locked\n-                    if (top != p || a[k] != t || getAndClearSlot(a, k) == null) {\n-                        access = 0;\n-                        break;                 \/\/ missed\n-                    }\n-                    top = s;\n-                    releaseAccess();\n+                    if (!internal && !tryLockPhase())\n+                        break;\n+                    if (taken =\n+                        (top == p &&\n+                         U.compareAndSetReference(a, slotOffset(k), t, null)))\n+                        updateTop(s);\n+                    if (!internal)\n+                        unlockPhase();\n+                    if (!taken)\n+                        break;\n@@ -1399,1 +1581,0 @@\n-                status = task.status;\n@@ -1411,25 +1592,8 @@\n-            if (blocker != null) {\n-                for (;;) {\n-                    int b = base, cap; ForkJoinTask<?>[] a;\n-                    if ((a = array) == null || (cap = a.length) <= 0 || b == top)\n-                        break;\n-                    int k = (cap - 1) & b, nb = b + 1, nk = (cap - 1) & nb;\n-                    ForkJoinTask<?> t = a[k];\n-                    U.loadFence();                     \/\/ for re-reads\n-                    if (base != b)\n-                        ;\n-                    else if (blocker.isReleasable())\n-                        break;\n-                    else if (a[k] != t)\n-                        ;\n-                    else if (t != null) {\n-                        if (!(t instanceof CompletableFuture\n-                              .AsynchronousCompletionTask))\n-                            break;\n-                        else if (casSlotToNull(a, k, t)) {\n-                            base = nb;\n-                            U.storeStoreFence();\n-                            t.doExec();\n-                        }\n-                    }\n-                    else if (a[nk] == null)\n+            for (;;) {\n+                ForkJoinTask<?>[] a; int b, cap, k;\n+                if ((a = array) == null || (cap = a.length) <= 0)\n+                    break;\n+                ForkJoinTask<?> t = a[k = (b = base) & (cap - 1)];\n+                U.loadFence();\n+                if (t == null) {\n+                    if (top - b <= 0)\n@@ -1438,0 +1602,10 @@\n+                else if (!(t instanceof CompletableFuture\n+                           .AsynchronousCompletionTask))\n+                    break;\n+                if (blocker != null && blocker.isReleasable())\n+                    break;\n+                if (base == b && t != null &&\n+                    U.compareAndSetReference(a, slotOffset(k), t, null)) {\n+                    updateBase(b + 1);\n+                    t.doExec();\n+                }\n@@ -1444,1 +1618,1 @@\n-         * Returns true if owned by a worker thread and not known to be blocked.\n+         * Returns true if internal and not known to be blocked.\n@@ -1448,1 +1622,1 @@\n-            return (access != STOP && (wt = owner) != null &&\n+            return ((wt = owner) != null && (phase & IDLE) != 0 &&\n@@ -1454,7 +1628,0 @@\n-        \/**\n-         * Called in constructors if ThreadLocals not preserved\n-         *\/\n-        final void setClearThreadLocals() {\n-            config |= CLEAR_TLS;\n-        }\n-\n@@ -1464,1 +1631,0 @@\n-            ACCESS = U.objectFieldOffset(klass, \"access\");\n@@ -1466,6 +1632,4 @@\n-            Class<ForkJoinTask[]> aklass = ForkJoinTask[].class;\n-            ABASE = U.arrayBaseOffset(aklass);\n-            int scale = U.arrayIndexScale(aklass);\n-            ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);\n-            if ((scale & (scale - 1)) != 0)\n-                throw new Error(\"array index scale not a power of two\");\n+            BASE = U.objectFieldOffset(klass, \"base\");\n+            TOP = U.objectFieldOffset(klass, \"top\");\n+            SOURCE = U.objectFieldOffset(klass, \"source\");\n+            ARRAY = U.objectFieldOffset(klass, \"array\");\n@@ -1503,12 +1667,3 @@\n-\n-    \/\/ Instance fields\n-    volatile long stealCount;            \/\/ collects worker nsteals\n-    volatile long threadIds;             \/\/ for worker thread names\n-    final long keepAlive;                \/\/ milliseconds before dropping if idle\n-    final long bounds;                   \/\/ min, max threads packed as shorts\n-    final int config;                    \/\/ static configuration bits\n-    volatile int runState;               \/\/ SHUTDOWN, STOP, TERMINATED bits\n-    WorkQueue[] queues;                  \/\/ main registry\n-    final ReentrantLock registrationLock;\n-    Condition termination;               \/\/ lazily constructed\n-    final String workerNamePrefix;       \/\/ null for common pool\n+    \/\/ fields declared in order of their likely layout on most VMs\n+    volatile CountDownLatch termination; \/\/ lazily constructed\n+    final Predicate<? super ForkJoinPool> saturate;\n@@ -1517,1 +1672,0 @@\n-    final Predicate<? super ForkJoinPool> saturate;\n@@ -1519,2 +1673,6 @@\n-\n-    @jdk.internal.vm.annotation.Contended(\"fjpctl\") \/\/ segregate\n+    final String workerNamePrefix;       \/\/ null for common pool\n+    WorkQueue[] queues;                  \/\/ main registry\n+    final long keepAlive;                \/\/ milliseconds before dropping if idle\n+    final long config;                   \/\/ static configuration bits\n+    volatile long stealCount;            \/\/ collects worker nsteals\n+    volatile long threadIds;             \/\/ for worker thread names\n@@ -1522,1 +1680,0 @@\n-    @jdk.internal.vm.annotation.Contended(\"fjpctl\") \/\/ colocate\n@@ -1524,0 +1681,1 @@\n+    volatile int runState;               \/\/ versioned, lockable\n@@ -1531,0 +1689,1 @@\n+    private static final long TERMINATION;\n@@ -1543,3 +1702,0 @@\n-    private int getAndBitwiseOrRunState(int v) {\n-        return U.getAndBitwiseOrInt(this, RUNSTATE, v);\n-    }\n@@ -1558,0 +1714,45 @@\n+    private CountDownLatch cmpExTerminationSignal(CountDownLatch x) {\n+        return (CountDownLatch)\n+            U.compareAndExchangeReference(this, TERMINATION, null, x);\n+    }\n+\n+    \/\/ runState operations\n+\n+    private int getAndBitwiseOrRunState(int v) { \/\/ for status bits\n+        return U.getAndBitwiseOrInt(this, RUNSTATE, v);\n+    }\n+    private boolean casRunState(int c, int v) {\n+        return U.compareAndSetInt(this, RUNSTATE, c, v);\n+    }\n+    private void unlockRunState() {              \/\/ increment lock bit\n+        U.getAndAddInt(this, RUNSTATE, RS_LOCK);\n+    }\n+    private int lockRunState() {                \/\/ lock and return current state\n+        int s, u;                               \/\/ locked when RS_LOCK set\n+        if (((s = runState) & RS_LOCK) == 0 && casRunState(s, u = s + RS_LOCK))\n+            return u;\n+        else\n+            return spinLockRunState();\n+    }\n+    private int spinLockRunState() {            \/\/ spin\/sleep\n+        for (int waits = 0, s, u;;) {\n+            if (((s = runState) & RS_LOCK) == 0) {\n+                if (casRunState(s, u = s + RS_LOCK))\n+                    return u;\n+                waits = 0;\n+            } else if (waits < SPIN_WAITS) {\n+                ++waits;\n+                Thread.onSpinWait();\n+            } else {\n+                if (waits < MIN_SLEEP)\n+                    waits = MIN_SLEEP;\n+                LockSupport.parkNanos(this, (long)waits);\n+                if (waits < MAX_SLEEP)\n+                    waits <<= 1;\n+            }\n+        }\n+    }\n+\n+    static boolean poolIsStopping(ForkJoinPool p) { \/\/ Used by ForkJoinTask\n+        return p != null && (p.runState & STOP) != 0;\n+    }\n@@ -1570,0 +1771,1 @@\n+        SharedThreadContainer ctr = container;\n@@ -1573,1 +1775,1 @@\n-            if (runState >= 0 &&  \/\/ avoid construction if terminating\n+            if ((runState & STOP) == 0 &&  \/\/ avoid construction if terminating\n@@ -1575,1 +1777,4 @@\n-                container.start(wt);\n+                if (ctr != null)\n+                    ctr.start(wt);\n+                else\n+                    wt.start();\n@@ -1597,1 +1802,1 @@\n-     * Finishes initializing and records owned queue.\n+     * Finishes initializing and records internal queue.\n@@ -1602,5 +1807,1 @@\n-        ThreadLocalRandom.localInit();\n-        int seed = ThreadLocalRandom.getProbe();\n-        ReentrantLock lock = registrationLock;\n-        int cfg = config & FIFO;\n-        if (w != null && lock != null) {\n+        if (w != null) {\n@@ -1608,4 +1809,5 @@\n-            cfg |= w.config | SRC;\n-            w.stackPred = seed;\n-            int id = (seed << 1) | 1;                   \/\/ initial index guess\n-            lock.lock();\n+            ThreadLocalRandom.localInit();\n+            int seed = w.stackPred = ThreadLocalRandom.getProbe();\n+            int phaseSeq = seed & ~((IDLE << 1) - 1); \/\/ initial phase tag\n+            int id = ((seed << 1) | 1) & SMASK; \/\/ base of linear-probe-like scan\n+            int stop = lockRunState() & STOP;\n@@ -1613,8 +1815,11 @@\n-                WorkQueue[] qs; int n;                  \/\/ find queue index\n-                if ((qs = queues) != null && (n = qs.length) > 0) {\n-                    int k = n, m = n - 1;\n-                    for (; qs[id &= m] != null && k > 0; id -= 2, k -= 2);\n-                    if (k == 0)\n-                        id = n | 1;                     \/\/ resize below\n-                    w.phase = w.config = id | cfg;      \/\/ now publishable\n-\n+                WorkQueue[] qs; int n;\n+                if (stop == 0 && (qs = queues) != null && (n = qs.length) > 0) {\n+                    for (int k = n, m = n - 1;  ; id += 2) {\n+                        if (qs[id &= m] == null)\n+                            break;\n+                        if ((k -= 2) <= 0) {\n+                            id |= n;\n+                            break;\n+                        }\n+                    }\n+                    w.phase = id | phaseSeq;    \/\/ now publishable\n@@ -1623,1 +1828,1 @@\n-                    else {                              \/\/ expand array\n+                    else {                      \/\/ expand\n@@ -1630,3 +1835,3 @@\n-                            WorkQueue q;\n-                            if ((q = qs[j]) != null)    \/\/ shared queues may move\n-                                as[q.config & am] = q;\n+                            WorkQueue q;        \/\/ shared queues may move\n+                            if ((q = qs[j]) != null)\n+                                as[q.phase & EXTERNAL_ID_MASK & am] = q;\n@@ -1634,1 +1839,1 @@\n-                        U.storeFence();                 \/\/ fill before publish\n+                        U.storeFence();         \/\/ fill before publish\n@@ -1639,1 +1844,1 @@\n-                lock.unlock();\n+                unlockRunState();\n@@ -1654,2 +1859,14 @@\n-        WorkQueue w = (wt == null) ? null : wt.workQueue;\n-        int cfg = (w == null) ? 0 : w.config;\n+        WorkQueue w = null;\n+        int src = 0, phase = 0;\n+        boolean replaceable = false;\n+        if (wt != null && (w = wt.workQueue) != null) {\n+            phase = w.phase;\n+            if ((src = w.source) != DEREGISTERED) { \/\/ else trimmed on timeout\n+                w.source = DEREGISTERED;\n+                if (phase != 0) {         \/\/ else failed to start\n+                    replaceable = true;\n+                    if ((phase & IDLE) != 0)\n+                        reactivate(w);    \/\/ pool stopped before released\n+                }\n+            }\n+        }\n@@ -1657,1 +1874,1 @@\n-        if ((cfg & TRIMMED) == 0)             \/\/ decrement counts\n+        if (src != DEREGISTERED)          \/\/ decrement counts\n@@ -1661,13 +1878,9 @@\n-                                       (SP_MASK & c)))));\n-        else if ((int)c == 0)                 \/\/ was dropped on timeout\n-            cfg &= ~SRC;                      \/\/ suppress signal if last\n-        if (!tryTerminate(false, false) && w != null) {\n-            ReentrantLock lock; WorkQueue[] qs; int n, i;\n-            long ns = w.nsteals & 0xffffffffL;\n-            if ((lock = registrationLock) != null) {\n-                lock.lock();                  \/\/ remove index unless terminating\n-                if ((qs = queues) != null && (n = qs.length) > 0 &&\n-                    qs[i = cfg & (n - 1)] == w)\n-                    qs[i] = null;\n-                stealCount += ns;             \/\/ accumulate steals\n-                lock.unlock();\n+                                       (LMASK & c)))));\n+        else if ((int)c == 0)             \/\/ was dropped on timeout\n+            replaceable = false;\n+        if (w != null) {                  \/\/ cancel remaining tasks\n+            for (ForkJoinTask<?> t; (t = w.nextLocalTask()) != null; ) {\n+                try {\n+                    t.cancel(false);\n+                } catch (Throwable ignore) {\n+                }\n@@ -1675,8 +1888,9 @@\n-            if ((cfg & SRC) != 0)\n-                signalWork();                 \/\/ possibly replace worker\n-        }\n-        if (ex != null) {\n-            if (w != null) {\n-                w.access = STOP;              \/\/ cancel tasks\n-                for (ForkJoinTask<?> t; (t = w.nextLocalTask(0)) != null; )\n-                    ForkJoinTask.cancelIgnoringExceptions(t);\n+        }\n+        if ((tryTerminate(false, false) & STOP) == 0 && w != null) {\n+            WorkQueue[] qs; int n, i;     \/\/ remove index unless terminating\n+            long ns = w.nsteals & 0xffffffffL;\n+            int stop = lockRunState() & STOP;\n+            if (stop == 0 && (qs = queues) != null && (n = qs.length) > 0 &&\n+                qs[i = phase & SMASK & (n - 1)] == w) {\n+                qs[i] = null;\n+                stealCount += ns;         \/\/ accumulate steals\n@@ -1684,1 +1898,1 @@\n-            ForkJoinTask.rethrow(ex);\n+            unlockRunState();\n@@ -1686,0 +1900,4 @@\n+        if ((runState & STOP) == 0 && replaceable)\n+            signalWork(); \/\/ may replace unless trimmed or uninitialized\n+        if (ex != null)\n+            ForkJoinTask.rethrow(ex);\n@@ -1688,1 +1906,1 @@\n-    \/*\n+    \/**\n@@ -1692,27 +1910,10 @@\n-        int pc = parallelism, n;\n-        long c = ctl;\n-        WorkQueue[] qs = queues;\n-        if ((short)(c >>> RC_SHIFT) < pc && qs != null && (n = qs.length) > 0) {\n-            for (;;) {\n-                boolean create = false;\n-                int sp = (int)c & ~INACTIVE;\n-                WorkQueue v = qs[sp & (n - 1)];\n-                int deficit = pc - (short)(c >>> TC_SHIFT);\n-                long ac = (c + RC_UNIT) & RC_MASK, nc;\n-                if (sp != 0 && v != null)\n-                    nc = (v.stackPred & SP_MASK) | (c & TC_MASK);\n-                else if (deficit <= 0)\n-                    break;\n-                else {\n-                    create = true;\n-                    nc = ((c + TC_UNIT) & TC_MASK);\n-                }\n-                if (c == (c = compareAndExchangeCtl(c, nc | ac))) {\n-                    if (create)\n-                        createWorker();\n-                    else {\n-                        Thread owner = v.owner;\n-                        v.phase = sp;\n-                        if (v.access == PARKED)\n-                            LockSupport.unpark(owner);\n-                    }\n+        int pc = parallelism;\n+        for (long c = ctl;;) {\n+            WorkQueue[] qs = queues;\n+            long ac = (c + RC_UNIT) & RC_MASK, nc;\n+            int sp = (int)c, i = sp & SMASK;\n+            if (qs == null || qs.length <= i)\n+                break;\n+            WorkQueue w = qs[i], v = null;\n+            if (sp == 0) {\n+                if ((short)(c >>> TC_SHIFT) >= pc)\n@@ -1720,1 +1921,1 @@\n-                }\n+                nc = ((c + TC_UNIT) & TC_MASK);\n@@ -1722,21 +1923,9 @@\n-        }\n-    }\n-\n-    \/**\n-     * Reactivates any idle worker, if one exists.\n-     *\n-     * @return the signalled worker, or null if none\n-     *\/\n-    private WorkQueue reactivate() {\n-        WorkQueue[] qs; int n;\n-        long c = ctl;\n-        if ((qs = queues) != null && (n = qs.length) > 0) {\n-            for (;;) {\n-                int sp = (int)c & ~INACTIVE;\n-                WorkQueue v = qs[sp & (n - 1)];\n-                long ac = UC_MASK & (c + RC_UNIT);\n-                if (sp == 0 || v == null)\n-                    break;\n-                if (c == (c = compareAndExchangeCtl(\n-                              c, (v.stackPred & SP_MASK) | ac))) {\n-                    Thread owner = v.owner;\n+            else if ((short)(c >>> RC_SHIFT) >= pc || (v = w) == null)\n+                break;\n+            else\n+                nc = (v.stackPred & LMASK) | (c & TC_MASK);\n+            if (c == (c = compareAndExchangeCtl(c, nc | ac))) {\n+                if (v == null)\n+                    createWorker();\n+                else {\n+                    Thread t;\n@@ -1744,3 +1933,2 @@\n-                    if (v.access == PARKED)\n-                        LockSupport.unpark(owner);\n-                    return v;\n+                    if ((t = v.parker) != null)\n+                        U.unpark(t);\n@@ -1748,0 +1936,1 @@\n+                break;\n@@ -1750,1 +1939,0 @@\n-        return null;\n@@ -1754,1 +1942,3 @@\n-     * Tries to deactivate worker w; called only on idle timeout.\n+     * Reactivates the given worker, and possibly interrupts others if\n+     * not top of ctl stack. Called only during shutdown to ensure release\n+     * on termination.\n@@ -1756,11 +1946,20 @@\n-    private boolean tryTrim(WorkQueue w) {\n-        if (w != null) {\n-            int pred = w.stackPred, cfg = w.config | TRIMMED;\n-            long c = ctl;\n-            int sp = (int)c & ~INACTIVE;\n-            if ((sp & SMASK) == (cfg & SMASK) &&\n-                compareAndSetCtl(c, ((pred & SP_MASK) |\n-                                     (UC_MASK & (c - TC_UNIT))))) {\n-                w.config = cfg;  \/\/ add sentinel for deregisterWorker\n-                w.phase = sp;\n-                return true;\n+    private void reactivate(WorkQueue w) {\n+        for (long c = ctl;;) {\n+            WorkQueue[] qs; WorkQueue v; int sp, i;\n+            if ((qs = queues) == null || (sp = (int)c) == 0 ||\n+                qs.length <= (i = sp & SMASK) || (v = qs[i]) == null ||\n+                (v != w && w != null && (w.phase & IDLE) == 0))\n+                break;\n+            if (c == (c = compareAndExchangeCtl(\n+                          c, ((UMASK & (c + RC_UNIT)) | (c & TC_MASK) |\n+                              (v.stackPred & LMASK))))) {\n+                Thread t;\n+                v.phase = sp;\n+                if ((t = v.parker) != null) {\n+                    try {\n+                        t.interrupt();\n+                    } catch (Throwable ignore) {\n+                    }\n+                }\n+                if (v == w)\n+                    break;\n@@ -1769,1 +1968,0 @@\n-        return false;\n@@ -1773,17 +1971,31 @@\n-     * Returns true if any queue is detectably nonempty.  Accurate\n-     * only when workers are quiescent; else conservatively\n-     * approximate.\n-     * @param submissionsOnly if true, only check submission queues\n-     *\/\n-    private boolean hasTasks(boolean submissionsOnly) {\n-        int step = submissionsOnly ? 2 : 1;\n-        for (int checkSum = 0;;) { \/\/ repeat until stable (normally twice)\n-            U.loadFence();\n-            WorkQueue[] qs = queues;\n-            int n = (qs == null) ? 0 : qs.length, sum = 0;\n-            for (int i = 0; i < n; i += step) {\n-                WorkQueue q; int s;\n-                if ((q = qs[i]) != null) {\n-                    if (q.access > 0 || (s = q.top) != q.base)\n-                        return true;\n-                    sum += (s << 16) + i + 1;\n+     * Internal version of isQuiescent and related functionality.\n+     * @return true if terminating or all workers are inactive and\n+     * submission queues are empty and unlocked; if so, setting STOP\n+     * if shutdown is enabled\n+     *\/\n+    private boolean quiescent() {\n+        outer: for (;;) {\n+            long phaseSum = 0L;\n+            boolean swept = false;\n+            for (int e, prevRunState = 0; ; prevRunState = e) {\n+                long c = ctl;\n+                if (((e = runState) & STOP) != 0)\n+                    return true;                          \/\/ terminating\n+                else if ((c & RC_MASK) > 0L)\n+                    return false;                         \/\/ at least one active\n+                else if (!swept || e != prevRunState || (e & RS_LOCK) != 0) {\n+                    long sum = c;\n+                    WorkQueue[] qs = queues; WorkQueue q;\n+                    int n = (qs == null) ? 0 : qs.length;\n+                    for (int i = 0; i < n; ++i) {         \/\/ scan queues\n+                        if ((q = qs[i]) != null) {\n+                            int p = q.phase, s = q.top, b = q.base;\n+                            sum += (p & 0xffffffffL) | ((long)b << 32);\n+                            if ((p & IDLE) == 0 || s - b > 0) {\n+                                if ((i & 1) == 0 && compareAndSetCtl(c, c))\n+                                    signalWork();         \/\/ ensure live\n+                                return false;\n+                            }\n+                        }\n+                    }\n+                    swept = (phaseSum == (phaseSum = sum));\n@@ -1791,0 +2003,8 @@\n+                else if (compareAndSetCtl(c, c) &&        \/\/ confirm\n+                         casRunState(e, (e & SHUTDOWN) != 0 ? e | STOP : e)) {\n+                    if ((e & SHUTDOWN) != 0)              \/\/ enable termination\n+                        interruptAll();\n+                    return true;\n+                }\n+                else\n+                    break;                                \/\/ restart\n@@ -1792,2 +2012,0 @@\n-            if (checkSum == (checkSum = sum))\n-                return false;\n@@ -1804,7 +2022,13 @@\n-        if (w != null) {                        \/\/ skip on failed init\n-            int r = w.stackPred, src = 0;       \/\/ use seed from registerWorker\n-            do {\n-                r ^= r << 13; r ^= r >>> 17; r ^= r << 5; \/\/ xorshift\n-            } while ((src = scan(w, src, r)) >= 0 ||\n-                     (src = awaitWork(w)) == 0);\n-            w.access = STOP;                    \/\/ record normal termination\n+        if (w != null) {\n+            int phase = w.phase, r = w.stackPred; \/\/ seed from registerWorker\n+            for (long window = NO_HISTORY | (r >>> 16);;) {\n+                r ^= r << 13; r ^= r >>> 17; r ^= r << 5;   \/\/ xorshift\n+                if ((runState & STOP) != 0)                 \/\/ terminating\n+                    break;\n+                if (window == (window = scan(w, window & WMASK, r)) &&\n+                    window >= 0L && phase != (phase = awaitWork(w, phase))) {\n+                    if ((phase & IDLE) != 0)\n+                        break;                              \/\/ worker exit\n+                    window = NO_HISTORY | (window & SMASK); \/\/ clear history\n+                }\n+             }\n@@ -1816,2 +2040,2 @@\n-     * each queue starting at a random index with random stride,\n-     * returning source id or retry indicator.\n+     * each queue starting at initial index with random stride,\n+     * returning next scan window and retry indicator.\n@@ -1820,1 +2044,1 @@\n-     * @param prevSrc the two previous queues (if nonzero) stolen from in current phase, packed as int\n+     * @param window up to three queue indices\n@@ -1822,1 +2046,1 @@\n-     * @return the next prevSrc value to use, or negative if none found\n+     * @return the next window to use, with RESCAN set for rescan\n@@ -1824,1 +2048,1 @@\n-    private int scan(WorkQueue w, int prevSrc, int r) {\n+    private long scan(WorkQueue w, long window, int r) {\n@@ -1826,2 +2050,2 @@\n-        int n = (w == null || qs == null) ? 0 : qs.length;\n-        for (int step = (r >>> 16) | 1, i = n; i > 0; --i, r += step) {\n+        int n = (qs == null) ? 0 : qs.length, step = (r << 1) | 1;\n+        outer: for (int i = (short)window, l = n; l > 0; --l, i += step) {\n@@ -1829,1 +2053,1 @@\n-            if ((q = qs[j = r & (n - 1)]) != null &&\n+            if ((q = qs[j = i & SMASK & (n - 1)]) != null &&\n@@ -1831,76 +2055,27 @@\n-                int src = j | SRC, b = q.base;\n-                int k = (cap - 1) & b, nb = b + 1, nk = (cap - 1) & nb;\n-                ForkJoinTask<?> t = a[k];\n-                U.loadFence();                  \/\/ for re-reads\n-                if (q.base != b)                \/\/ inconsistent\n-                    return prevSrc;\n-                else if (t != null && WorkQueue.casSlotToNull(a, k, t)) {\n-                    q.base = nb;\n-                    w.source = src;\n-                    if (src + (src << SWIDTH) != prevSrc &&\n-                        q.base == nb && a[nk] != null)\n-                        signalWork();           \/\/ propagate at most twice\/run\n-                    w.topLevelExec(t, q);\n-                    return src + (prevSrc << SWIDTH);\n-                }\n-                else if (q.array != a || a[k] != null || a[nk] != null)\n-                    return prevSrc;             \/\/ revisit\n-            }\n-        }\n-        return -1;\n-    }\n-\n-    \/**\n-     * Advances phase, enqueues, and awaits signal or termination.\n-     *\n-     * @return negative if terminated, else 0\n-     *\/\n-    private int awaitWork(WorkQueue w) {\n-        if (w == null)\n-            return -1;                           \/\/ currently impossible\n-        int p = (w.phase + SS_SEQ) & ~INACTIVE;  \/\/ advance phase\n-        boolean idle = false;                    \/\/ true if possibly quiescent\n-        if (runState < 0)\n-            return -1;                           \/\/ terminating\n-        long sp = p & SP_MASK, pc = ctl, qc;\n-        w.phase = p | INACTIVE;\n-        do {                                     \/\/ enqueue\n-            w.stackPred = (int)pc;               \/\/ set ctl stack link\n-        } while (pc != (pc = compareAndExchangeCtl(\n-                            pc, qc = ((pc - RC_UNIT) & UC_MASK) | sp)));\n-        if ((qc & RC_MASK) <= 0L) {\n-            if (hasTasks(true) && (w.phase >= 0 || reactivate() == w))\n-                return 0;                        \/\/ check for stragglers\n-            if (runState != 0 && tryTerminate(false, false))\n-                return -1;                       \/\/ quiescent termination\n-            idle = true;\n-        }\n-        WorkQueue[] qs = queues; \/\/ spin for expected #accesses in scan+signal\n-        int spins = ((qs == null) ? 0 : ((qs.length & SMASK) << 1)) | 0xf;\n-        while ((p = w.phase) < 0 && --spins > 0)\n-            Thread.onSpinWait();\n-        if (p < 0) {\n-            long deadline = idle ? keepAlive + System.currentTimeMillis() : 0L;\n-            LockSupport.setCurrentBlocker(this);\n-            for (;;) {                           \/\/ await signal or termination\n-                if (runState < 0)\n-                    return -1;\n-                w.access = PARKED;               \/\/ enable unpark\n-                if (w.phase < 0) {\n-                    if (idle)\n-                        LockSupport.parkUntil(deadline);\n-                    else\n-                        LockSupport.park();\n-                }\n-                w.access = 0;                    \/\/ disable unpark\n-                if (w.phase >= 0) {\n-                    LockSupport.setCurrentBlocker(null);\n-                    break;\n-                }\n-                Thread.interrupted();            \/\/ clear status for next park\n-                if (idle) {                      \/\/ check for idle timeout\n-                    if (deadline - System.currentTimeMillis() < TIMEOUT_SLOP) {\n-                        if (tryTrim(w))\n-                            return -1;\n-                        else                     \/\/ not at head; restart timer\n-                            deadline += keepAlive;\n+                for (;;) {\n+                    int b, k; Object o;\n+                    ForkJoinTask<?> t = a[k = (b = q.base) & (cap - 1)];\n+                    U.loadFence();                \/\/ re-read b and t\n+                    if (q.base == b) {            \/\/ else inconsistent; retry\n+                        int nb = b + 1, nk = nb & (cap - 1);\n+                        if (t == null) {\n+                            if (a[k] == null) {   \/\/ revisit if another task\n+                                if (window >= 0L && a[nk] != null)\n+                                    window |= RESCAN;\n+                                break;\n+                            }\n+                        }\n+                        else if (t == (o = U.compareAndExchangeReference(\n+                                            a, slotOffset(k), t, null))) {\n+                            q.updateBase(nb);\n+                            long pw = window, nw = ((pw << 16) | j) & WMASK;\n+                            window = nw | RESCAN;\n+                            if ((nw != pw || (short)(nw >>> 32) != j) &&\n+                                a[nk] != null)\n+                                signalWork();     \/\/ limit propagation\n+                            if (w != null)        \/\/ always true\n+                                w.topLevelExec(t, q, j);\n+                            break outer;\n+                        }\n+                        else if (o == null)       \/\/ contended\n+                            break;                \/\/ retried unless newly active\n@@ -1911,1 +2086,1 @@\n-        return 0;\n+        return window;\n@@ -1915,2 +2090,5 @@\n-     * Non-overridable version of isQuiescent. Returns true if\n-     * quiescent or already terminating.\n+     * Tries to inactivate, and if successful, awaits signal or termination.\n+     *\n+     * @param w the worker (may be null if already terminated)\n+     * @param p current phase\n+     * @return current phase, with IDLE set if worker should exit\n@@ -1918,9 +2096,59 @@\n-    private boolean canStop() {\n-        long c = ctl;\n-        do {\n-            if (runState < 0)\n-                break;\n-            if ((c & RC_MASK) > 0L || hasTasks(false))\n-                return false;\n-        } while (c != (c = ctl));  \/\/ validate\n-        return true;\n+    private int awaitWork(WorkQueue w, int p) {\n+        if (w != null) {\n+            int idlePhase = p + IDLE, nextPhase = p + (IDLE << 1);\n+            long pc = ctl, qc = (nextPhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n+            w.stackPred = (int)pc;                   \/\/ set ctl stack link\n+            w.phase = idlePhase;                     \/\/ try to inactivate\n+            if (!compareAndSetCtl(pc, qc))           \/\/ contended enque\n+                return w.phase = p;                  \/\/ back out\n+            int ac = (short)(qc >>> RC_SHIFT);\n+            boolean quiescent = (ac <= 0 && quiescent());\n+            if ((runState & STOP) != 0)\n+                return idlePhase;\n+            int spins = ac + ((((int)(qc >>> TC_SHIFT)) & SMASK) << 1);\n+            while ((p = w.phase) == idlePhase && --spins > 0)\n+                Thread.onSpinWait();  \/\/ spin for approx #accesses to signal\n+            if (p == idlePhase) {\n+                long deadline = (!quiescent ? 0L :   \/\/ timeout for trim\n+                                 System.currentTimeMillis() + keepAlive);\n+                WorkQueue[] qs = queues;\n+                int n = (qs == null) ? 0 : qs.length;\n+                for (int i = 0; i < n; ++i) {        \/\/ recheck queues\n+                    WorkQueue q; ForkJoinTask<?>[] a; int cap;\n+                    if ((q = qs[i]) != null &&\n+                        (a = q.array) != null && (cap = a.length) > 0 &&\n+                        a[q.base & (cap - 1)] != null &&\n+                        ctl == qc && compareAndSetCtl(qc, pc)) {\n+                        w.phase = (int)qc;           \/\/ release\n+                        break;\n+                    }\n+                }\n+                if ((p = w.phase) == idlePhase) {    \/\/ emulate LockSupport.park\n+                    LockSupport.setCurrentBlocker(this);\n+                    w.parker = Thread.currentThread();\n+                    for (;;) {\n+                        if ((runState & STOP) != 0 || (p = w.phase) != idlePhase)\n+                            break;\n+                        U.park(quiescent, deadline);\n+                        if ((p = w.phase) != idlePhase || (runState & STOP) != 0)\n+                            break;\n+                        Thread.interrupted();        \/\/ clear for next park\n+                        if (quiescent && TIMEOUT_SLOP >\n+                            deadline - System.currentTimeMillis()) {\n+                            long sp = w.stackPred & LMASK;\n+                            long c = ctl, nc = sp | (UMASK & (c - TC_UNIT));\n+                            if (((int)c & SMASK) == (idlePhase & SMASK) &&\n+                                compareAndSetCtl(c, nc)) {\n+                                w.source = DEREGISTERED;\n+                                w.phase = (int)c;\n+                                break;\n+                            }\n+                            deadline += keepAlive;   \/\/ not head; reset timer\n+                        }\n+                    }\n+                    w.parker = null;\n+                    LockSupport.setCurrentBlocker(null);\n+                }\n+            }\n+        }\n+        return p;\n@@ -1937,10 +2165,12 @@\n-        int r = ThreadLocalRandom.nextSecondarySeed();\n-        if (submissionsOnly)                    \/\/ even indices only\n-            r &= ~1;\n-        int step = (submissionsOnly) ? 2 : 1;\n-        WorkQueue[] qs; int n; WorkQueue q; ForkJoinTask<?> t;\n-        if (runState >= 0 && (qs = queues) != null && (n = qs.length) > 0) {\n-            for (int i = n; i > 0; i -= step, r += step) {\n-                if ((q = qs[r & (n - 1)]) != null &&\n-                    (t = q.poll(this)) != null)\n-                    return t;\n+        if ((runState & STOP) == 0) {\n+            WorkQueue[] qs; int n; WorkQueue q; ForkJoinTask<?> t;\n+            int r = ThreadLocalRandom.nextSecondarySeed();\n+            if (submissionsOnly)                 \/\/ even indices only\n+                r &= ~1;\n+            int step = (submissionsOnly) ? 2 : 1;\n+            if ((qs = queues) != null && (n = qs.length) > 0) {\n+                for (int i = n; i > 0; i -= step, r += step) {\n+                    if ((q = qs[r & (n - 1)]) != null &&\n+                        (t = q.poll(this)) != null)\n+                        return t;\n+                }\n@@ -1961,1 +2191,0 @@\n-     * @param canSaturate to override saturate predicate\n@@ -1964,1 +2193,1 @@\n-    private int tryCompensate(long c, boolean canSaturate) {\n+    private int tryCompensate(long c) {\n@@ -1966,4 +2195,4 @@\n-        long b = bounds;                               \/\/ unpack fields\n-        int pc = parallelism;\n-        int minActive = (short)(b & SMASK),\n-            maxTotal  = (short)(b >>> SWIDTH) + pc,\n+        long b = config;\n+        int pc        = parallelism,                    \/\/ unpack fields\n+            minActive = (short)(b >>> RC_SHIFT),\n+            maxTotal  = (short)(b >>> TC_SHIFT) + pc,\n@@ -1972,11 +2201,11 @@\n-            sp        = (int)c & ~INACTIVE;\n-        if (sp != 0 && active <= pc) {                 \/\/ activate idle worker\n-            WorkQueue[] qs; WorkQueue v; int i;\n-            if (ctl == c && (qs = queues) != null &&\n-                qs.length > (i = sp & SMASK) && (v = qs[i]) != null) {\n-                long nc = (v.stackPred & SP_MASK) | (UC_MASK & c);\n-                if (compareAndSetCtl(c, nc)) {\n-                    v.phase = sp;\n-                    LockSupport.unpark(v.owner);\n-                    return UNCOMPENSATE;\n-                }\n+            sp        = (int)c,\n+            stat      = -1;                             \/\/ default retry return\n+        if (sp != 0 && active <= pc) {                  \/\/ activate idle worker\n+            WorkQueue[] qs; WorkQueue v; int i; Thread t;\n+            if ((qs = queues) != null && qs.length > (i = sp & SMASK) &&\n+                (v = qs[i]) != null &&\n+                compareAndSetCtl(c, (c & UMASK) | (v.stackPred & LMASK))) {\n+                v.phase = sp;\n+                if ((t = v.parker) != null)\n+                    U.unpark(t);\n+                stat = UNCOMPENSATE;\n@@ -1984,1 +2213,0 @@\n-            return -1;                                  \/\/ retry\n@@ -1987,2 +2215,2 @@\n-            long nc = ((RC_MASK & (c - RC_UNIT)) | (~RC_MASK & c));\n-            return compareAndSetCtl(c, nc) ? UNCOMPENSATE : -1;\n+            if (compareAndSetCtl(c, ((c - RC_UNIT) & RC_MASK) | (c & ~RC_MASK)))\n+                stat = UNCOMPENSATE;\n@@ -1990,1 +2218,1 @@\n-        else if (total < maxTotal && total < MAX_CAP) { \/\/ expand pool\n+        else if (total < maxTotal && total < MAX_CAP) { \/\/ try to expand pool\n@@ -1992,2 +2220,4 @@\n-            return (!compareAndSetCtl(c, nc) ? -1 :\n-                    !createWorker() ? 0 : UNCOMPENSATE);\n+            if ((runState & STOP) != 0)                 \/\/ terminating\n+                stat = 0;\n+            else if (compareAndSetCtl(c, nc))\n+                stat = createWorker() ? UNCOMPENSATE : 0;\n@@ -1996,3 +2226,3 @@\n-            return -1;\n-        else if (canSaturate || ((sat = saturate) != null && sat.test(this)))\n-            return 0;\n+            ;\n+        else if ((sat = saturate) != null && sat.test(this))\n+            stat = 0;\n@@ -2002,0 +2232,1 @@\n+        return stat;\n@@ -2019,1 +2250,1 @@\n-     * @param timed true if this is a timed join\n+     * @param internal true if w is owned by a ForkJoinWorkerThread\n@@ -2022,33 +2253,26 @@\n-    final int helpJoin(ForkJoinTask<?> task, WorkQueue w, boolean timed) {\n-        if (w == null || task == null)\n-            return 0;\n-        int wsrc = w.source, wid = (w.config & SMASK) | SRC, r = wid + 2;\n-        long sctl = 0L;                               \/\/ track stability\n-        for (boolean rescan = true;;) {\n-            int s; WorkQueue[] qs;\n-            if ((s = task.status) < 0)\n-                return s;\n-            if (!rescan && sctl == (sctl = ctl)) {\n-                if (runState < 0)\n-                    return 0;\n-                if ((s = tryCompensate(sctl, timed)) >= 0)\n-                    return s;                              \/\/ block\n-            }\n-            rescan = false;\n-            int n = ((qs = queues) == null) ? 0 : qs.length, m = n - 1;\n-            scan: for (int i = n >>> 1; i > 0; --i, r += 2) {\n-                int j, cap; WorkQueue q; ForkJoinTask<?>[] a;\n-                if ((q = qs[j = r & m]) != null && (a = q.array) != null &&\n-                    (cap = a.length) > 0) {\n-                    for (int src = j | SRC;;) {\n-                        int sq = q.source, b = q.base;\n-                        int k = (cap - 1) & b, nb = b + 1;\n-                        ForkJoinTask<?> t = a[k];\n-                        U.loadFence();                \/\/ for re-reads\n-                        boolean eligible = true;      \/\/ check steal chain\n-                        for (int d = n, v = sq;;) {   \/\/ may be cyclic; bound\n-                            WorkQueue p;\n-                            if (v == wid)\n-                                break;\n-                            if (v == 0 || --d == 0 || (p = qs[v & m]) == null) {\n-                                eligible = false;\n+\n+    final int helpJoin(ForkJoinTask<?> task, WorkQueue w, boolean internal) {\n+        if (w != null)\n+            w.tryRemoveAndExec(task, internal);\n+        int s = 0;\n+        if (task != null && (s = task.status) >= 0 && internal && w != null) {\n+            int wid = w.phase & SMASK, r = wid + 2, wsrc = w.source;\n+            long sctl = 0L;                             \/\/ track stability\n+            outer: for (boolean rescan = true;;) {\n+                if ((s = task.status) < 0)\n+                    break;\n+                if (!rescan) {\n+                    if ((runState & STOP) != 0)\n+                        break;\n+                    if (sctl == (sctl = ctl) && (s = tryCompensate(sctl)) >= 0)\n+                        break;\n+                }\n+                rescan = false;\n+                WorkQueue[] qs = queues;\n+                int n = (qs == null) ? 0 : qs.length;\n+                scan: for (int l = n >>> 1; l > 0; --l, r += 2) {\n+                    int j; WorkQueue q;\n+                    if ((q = qs[j = r & SMASK & (n - 1)]) != null) {\n+                        for (;;) {\n+                            int sq = q.source, b, cap, k; ForkJoinTask<?>[] a;\n+                            if ((a = q.array) == null || (cap = a.length) <= 0)\n@@ -2056,0 +2280,18 @@\n+                            ForkJoinTask<?> t = a[k = (b = q.base) & (cap - 1)];\n+                            U.loadFence();\n+                            boolean eligible = false;\n+                            if (t == task)\n+                                eligible = true;\n+                            else if (t != null) {       \/\/ check steal chain\n+                                for (int v = sq, d = cap;;) {\n+                                    WorkQueue p;\n+                                    if (v == wid) {\n+                                        eligible = true;\n+                                        break;\n+                                    }\n+                                    if ((v & 1) == 0 || \/\/ external or none\n+                                        --d < 0 ||      \/\/ bound depth\n+                                        (p = qs[v & (n - 1)]) == null)\n+                                        break;\n+                                    v = p.source;\n+                                }\n@@ -2057,12 +2299,19 @@\n-                            v = p.source;\n-                        }\n-                        if (q.source != sq || q.base != b)\n-                            ;                          \/\/ stale\n-                        else if ((s = task.status) < 0)\n-                            return s;                  \/\/ recheck before taking\n-                        else if (t == null) {\n-                            if (a[k] == null) {\n-                                if (!rescan && eligible &&\n-                                    (q.array != a || q.top != b))\n-                                    rescan = true;     \/\/ resized or stalled\n-                                break;\n+                            if ((s = task.status) < 0)\n+                                break outer;            \/\/ validate\n+                            if (q.source == sq && q.base == b && a[k] == t) {\n+                                int nb = b + 1, nk = nb & (cap - 1);\n+                                if (!eligible) {        \/\/ revisit if nonempty\n+                                    if (!rescan && t == null &&\n+                                        (a[nk] != null || q.top - b > 0))\n+                                        rescan = true;\n+                                    break;\n+                                }\n+                                if (U.compareAndSetReference(\n+                                        a, slotOffset(k), t, null)) {\n+                                    q.updateBase(nb);\n+                                    w.source = j;\n+                                    t.doExec();\n+                                    w.source = wsrc;\n+                                    rescan = true;   \/\/ restart at index r\n+                                    break scan;\n+                                }\n@@ -2071,10 +2320,0 @@\n-                        else if (t != task && !eligible)\n-                            break;\n-                        else if (WorkQueue.casSlotToNull(a, k, t)) {\n-                            q.base = nb;\n-                            w.source = src;\n-                            t.doExec();\n-                            w.source = wsrc;\n-                            rescan = true;\n-                            break scan;\n-                        }\n@@ -2085,0 +2324,1 @@\n+        return s;\n@@ -2090,1 +2330,1 @@\n-     * @param task the task\n+     * @param task root of computation (only called when a CountedCompleter)\n@@ -2092,2 +2332,1 @@\n-     * @param owned true if w is owned by a ForkJoinWorkerThread\n-     * @param timed true if this is a timed join\n+     * @param internal true if w is owned by a ForkJoinWorkerThread\n@@ -2096,35 +2335,26 @@\n-    final int helpComplete(ForkJoinTask<?> task, WorkQueue w, boolean owned,\n-                           boolean timed) {\n-        if (w == null || task == null)\n-            return 0;\n-        int wsrc = w.source, r = w.config;\n-        long sctl = 0L;                               \/\/ track stability\n-        for (boolean rescan = true;;) {\n-            int s; WorkQueue[] qs;\n-            if ((s = w.helpComplete(task, owned, 0)) < 0)\n-                return s;\n-            if (!rescan && sctl == (sctl = ctl)) {\n-                if (!owned || runState < 0)\n-                    return 0;\n-                if ((s = tryCompensate(sctl, timed)) >= 0)\n-                    return s;\n-            }\n-            rescan = false;\n-            int n = ((qs = queues) == null) ? 0 : qs.length, m = n - 1;\n-            scan: for (int i = n; i > 0; --i, ++r) {\n-                int j, cap; WorkQueue q; ForkJoinTask<?>[] a;\n-                if ((q = qs[j = r & m]) != null && (a = q.array) != null &&\n-                    (cap = a.length) > 0) {\n-                    poll: for (int src = j | SRC, b = q.base;;) {\n-                        int k = (cap - 1) & b, nb = b + 1;\n-                        ForkJoinTask<?> t = a[k];\n-                        U.loadFence();                \/\/ for re-reads\n-                        if (b != (b = q.base))\n-                            ;                         \/\/ stale\n-                        else if ((s = task.status) < 0)\n-                            return s;                 \/\/ recheck before taking\n-                        else if (t == null) {\n-                            if (a[k] == null) {\n-                                if (!rescan &&        \/\/ resized or stalled\n-                                    (q.array != a || q.top != b))\n-                                    rescan = true;\n+    final int helpComplete(ForkJoinTask<?> task, WorkQueue w, boolean internal) {\n+        int s = 0;\n+        if (task != null && (s = task.status) >= 0 && w != null) {\n+            int r = w.phase + 1;                          \/\/ for indexing\n+            long sctl = 0L;                               \/\/ track stability\n+            outer: for (boolean rescan = true, locals = true;;) {\n+                if (locals && (s = w.helpComplete(task, internal, 0)) < 0)\n+                    break;\n+                if ((s = task.status) < 0)\n+                    break;\n+                if (!rescan) {\n+                    if ((runState & STOP) != 0)\n+                        break;\n+                    if (sctl == (sctl = ctl) &&\n+                        (!internal || (s = tryCompensate(sctl)) >= 0))\n+                        break;\n+                }\n+                rescan = locals = false;\n+                WorkQueue[] qs = queues;\n+                int n = (qs == null) ? 0 : qs.length;\n+                scan: for (int l = n; l > 0; --l, ++r) {\n+                    int j; WorkQueue q;\n+                    if ((q = qs[j = r & SMASK & (n - 1)]) != null) {\n+                        for (;;) {\n+                            ForkJoinTask<?>[] a; int b, cap, k;\n+                            if ((a = q.array) == null || (cap = a.length) <= 0)\n@@ -2132,0 +2362,13 @@\n+                            ForkJoinTask<?> t = a[k = (b = q.base) & (cap - 1)];\n+                            U.loadFence();\n+                            boolean eligible = false;\n+                            if (t instanceof CountedCompleter) {\n+                                CountedCompleter<?> f = (CountedCompleter<?>)t;\n+                                for (int steps = cap; steps > 0; --steps) {\n+                                    if (f == task) {\n+                                        eligible = true;\n+                                        break;\n+                                    }\n+                                    if ((f = f.completer) == null)\n+                                        break;\n+                                }\n@@ -2133,5 +2376,17 @@\n-                        }\n-                        else if (t instanceof CountedCompleter) {\n-                            CountedCompleter<?> f;\n-                            for (f = (CountedCompleter<?>)t;;) {\n-                                if (f == task)\n+                            if ((s = task.status) < 0)    \/\/ validate\n+                                break outer;\n+                            if (q.base == b) {\n+                                int nb = b + 1, nk = nb & (cap - 1);\n+                                if (eligible) {\n+                                    if (U.compareAndSetReference(\n+                                            a, slotOffset(k), t, null)) {\n+                                        q.updateBase(nb);\n+                                        t.doExec();\n+                                        locals = rescan = true;\n+                                        break scan;\n+                                    }\n+                                }\n+                                else if (a[k] == t) {\n+                                    if (!rescan && t == null &&\n+                                        (a[nk] != null || q.top - b > 0))\n+                                        rescan = true;    \/\/ revisit\n@@ -2139,10 +2394,1 @@\n-                                else if ((f = f.completer) == null)\n-                                    break poll;       \/\/ ineligible\n-                            }\n-                            if (WorkQueue.casSlotToNull(a, k, t)) {\n-                                q.base = nb;\n-                                w.source = src;\n-                                t.doExec();\n-                                w.source = wsrc;\n-                                rescan = true;\n-                                break scan;\n+                                }\n@@ -2151,2 +2397,0 @@\n-                        else\n-                            break;\n@@ -2157,0 +2401,1 @@\n+        return s;\n@@ -2160,3 +2405,3 @@\n-     * Runs tasks until {@code isQuiescent()}. Rather than blocking\n-     * when tasks cannot be found, rescans until all others cannot\n-     * find tasks either.\n+     * Runs tasks until all workers are inactive and no tasks are\n+     * found. Rather than blocking when tasks cannot be found, rescans\n+     * until all others cannot find tasks either.\n@@ -2169,3 +2414,2 @@\n-        long startTime = System.nanoTime(), parkTime = 0L;\n-        int phase; \/\/ w.phase set negative when temporarily quiescent\n-        if (w == null || (phase = w.phase) < 0)\n+        int phase; \/\/ w.phase inactive bit set when temporarily quiescent\n+        if (w == null || ((phase = w.phase) & IDLE) != 0)\n@@ -2173,7 +2417,13 @@\n-        int activePhase = phase, inactivePhase = phase | INACTIVE;\n-        int wsrc = w.source, r = 0;\n-        for (boolean locals = true;;) {\n-            WorkQueue[] qs; WorkQueue q;\n-            if (runState < 0) {             \/\/ terminating\n-                w.phase = activePhase;\n-                return 1;\n+        int wsrc = w.source;\n+        long startTime = System.nanoTime();\n+        long maxSleep = Math.min(nanos >>> 8, MAX_SLEEP); \/\/ approx 1% nanos\n+        long prevSum = 0L;\n+        int activePhase = phase, inactivePhase = phase + IDLE;\n+        int r = phase + 1, waits = 0, returnStatus = 1;\n+        boolean locals = true;\n+        for (int e = runState;;) {\n+            if ((e & STOP) != 0)\n+                break;                      \/\/ terminating\n+            if (interruptible && Thread.interrupted()) {\n+                returnStatus = -1;\n+                break;\n@@ -2182,0 +2432,1 @@\n+                locals = false;\n@@ -2185,22 +2436,10 @@\n-            boolean rescan = false, busy = locals = false, interrupted;\n-            int n = ((qs = queues) == null) ? 0 : qs.length, m = n - 1;\n-            scan: for (int i = n, j; i > 0; --i, ++r) {\n-                if ((q = qs[j = m & r]) != null && q != w) {\n-                    for (int src = j | SRC;;) {\n-                        ForkJoinTask<?>[] a = q.array;\n-                        int b = q.base, cap;\n-                        if (a == null || (cap = a.length) <= 0)\n-                            break;\n-                        int k = (cap - 1) & b, nb = b + 1, nk = (cap - 1) & nb;\n-                        ForkJoinTask<?> t = a[k];\n-                        U.loadFence();      \/\/ for re-reads\n-                        if (q.base != b || q.array != a || a[k] != t)\n-                            ;\n-                        else if (t == null) {\n-                            if (!rescan) {\n-                                if (a[nk] != null || q.top - b > 0)\n-                                    rescan = true;\n-                                else if (!busy &&\n-                                         q.owner != null && q.phase >= 0)\n-                                    busy = true;\n-                            }\n+            WorkQueue[] qs = queues;\n+            int n = (qs == null) ? 0 : qs.length;\n+            long phaseSum = 0L;\n+            boolean rescan = false, busy = false;\n+            scan: for (int l = n; l > 0; --l, ++r) {\n+                int j; WorkQueue q;\n+                if ((q = qs[j = r & SMASK & (n - 1)]) != null && q != w) {\n+                    for (;;) {\n+                        ForkJoinTask<?>[] a; int b, cap, k;\n+                        if ((a = q.array) == null || (cap = a.length) <= 0)\n@@ -2208,2 +2447,2 @@\n-                        }\n-                        else if (phase < 0) \/\/ reactivate before taking\n+                        ForkJoinTask<?> t = a[k = (b = q.base) & (cap - 1)];\n+                        if (t != null && phase == inactivePhase) \/\/ reactivate\n@@ -2211,7 +2450,23 @@\n-                        else if (WorkQueue.casSlotToNull(a, k, t)) {\n-                            q.base = nb;\n-                            w.source = src;\n-                            t.doExec();\n-                            w.source = wsrc;\n-                            rescan = locals = true;\n-                            break scan;\n+                        U.loadFence();\n+                        if (q.base == b && a[k] == t) {\n+                            int nb = b + 1;\n+                            if (t == null) {\n+                                if (!rescan) {\n+                                    int qp = q.phase, mq = qp & (IDLE | 1);\n+                                    phaseSum += qp;\n+                                    if (mq == 0 || q.top - b > 0)\n+                                        rescan = true;\n+                                    else if (mq == 1)\n+                                        busy = true;\n+                                }\n+                                break;\n+                            }\n+                            if (U.compareAndSetReference(\n+                                    a, slotOffset(k), t, null)) {\n+                                q.updateBase(nb);\n+                                w.source = j;\n+                                t.doExec();\n+                                w.source = wsrc;\n+                                rescan = locals = true;\n+                                break scan;\n+                            }\n@@ -2222,4 +2477,7 @@\n-            if (rescan)\n-                ;                   \/\/ retry\n-            else if (phase >= 0) {\n-                parkTime = 0L;\n+            if (e != (e = runState) || prevSum != (prevSum = phaseSum) ||\n+                rescan || (e & RS_LOCK) != 0)\n+                ;                   \/\/ inconsistent\n+            else if (!busy)\n+                break;\n+            else if (phase == activePhase) {\n+                waits = 0;          \/\/ recheck, then sleep\n@@ -2228,12 +2486,3 @@\n-            else if (!busy) {\n-                w.phase = activePhase;\n-                return 1;\n-            }\n-            else if (parkTime == 0L) {\n-                parkTime = 1L << 10; \/\/ initially about 1 usec\n-                Thread.yield();\n-            }\n-            else if ((interrupted = interruptible && Thread.interrupted()) ||\n-                     System.nanoTime() - startTime > nanos) {\n-                w.phase = activePhase;\n-                return interrupted ? -1 : 0;\n+            else if (System.nanoTime() - startTime > nanos) {\n+                returnStatus = 0;   \/\/ timed out\n+                break;\n@@ -2241,0 +2490,2 @@\n+            else if (waits == 0)   \/\/ same as spinLockRunState except\n+                waits = MIN_SLEEP; \/\/   with rescan instead of onSpinWait\n@@ -2242,3 +2493,3 @@\n-                LockSupport.parkNanos(this, parkTime);\n-                if (parkTime < nanos >>> 8 && parkTime < 1L << 20)\n-                    parkTime <<= 1;  \/\/ max sleep approx 1 sec or 1% nanos\n+                LockSupport.parkNanos(this, (long)waits);\n+                if (waits < maxSleep)\n+                    waits <<= 1;\n@@ -2247,0 +2498,2 @@\n+        w.phase = activePhase;\n+        return returnStatus;\n@@ -2257,20 +2510,22 @@\n-        for (long startTime = System.nanoTime(), parkTime = 0L;;) {\n-            ForkJoinTask<?> t;\n-            if ((t = pollScan(false)) != null) {\n-                t.doExec();\n-                parkTime = 0L;\n-            }\n-            else if (canStop())\n-                return 1;\n-            else if (parkTime == 0L) {\n-                parkTime = 1L << 10;\n-                Thread.yield();\n-            }\n-            else if ((System.nanoTime() - startTime) > nanos)\n-                return 0;\n-            else if (interruptible && Thread.interrupted())\n-                return -1;\n-            else {\n-                LockSupport.parkNanos(this, parkTime);\n-                if (parkTime < nanos >>> 8 && parkTime < 1L << 20)\n-                    parkTime <<= 1;\n+        if (!quiescent()) {\n+            long startTime = System.nanoTime();\n+            long maxSleep = Math.min(nanos >>> 8, MAX_SLEEP);\n+            for (int waits = 0;;) {\n+                ForkJoinTask<?> t;\n+                if (interruptible && Thread.interrupted())\n+                    return -1;\n+                else if ((t = pollScan(false)) != null) {\n+                    waits = 0;\n+                    t.doExec();\n+                }\n+                else if (quiescent())\n+                    break;\n+                else if (System.nanoTime() - startTime > nanos)\n+                    return 0;\n+                else if (waits == 0)\n+                    waits = MIN_SLEEP;\n+                else {\n+                    LockSupport.parkNanos(this, (long)waits);\n+                    if (waits < maxSleep)\n+                        waits <<= 1;\n+                }\n@@ -2279,0 +2534,1 @@\n+        return 1;\n@@ -2319,0 +2575,1 @@\n+     * @param r current ThreadLocalRandom.getProbe() value\n@@ -2321,4 +2578,2 @@\n-    final WorkQueue submissionQueue(boolean isSubmit) {\n-        int r;\n-        ReentrantLock lock = registrationLock;\n-        if ((r = ThreadLocalRandom.getProbe()) == 0) {\n+    private WorkQueue submissionQueue(int r) {\n+        if (r == 0) {\n@@ -2328,20 +2583,14 @@\n-        if (lock != null) {                          \/\/ else init error\n-            for (int id = r << 1;;) {                \/\/ even indices only\n-                int n, i; WorkQueue[] qs; WorkQueue q;\n-                if ((qs = queues) == null || (n = qs.length) <= 0)\n-                    break;\n-                else if ((q = qs[i = (n - 1) & id]) == null) {\n-                    WorkQueue w = new WorkQueue(null, id | SRC);\n-                    w.array = new ForkJoinTask<?>[INITIAL_QUEUE_CAPACITY];\n-                    lock.lock();                     \/\/ install under lock\n-                    if (queues == qs && qs[i] == null)\n-                        qs[i] = w;                   \/\/ else lost race; discard\n-                    lock.unlock();\n-                }\n-                else if (q.getAndSetAccess(1) != 0)  \/\/ move and restart\n-                    id = (r = ThreadLocalRandom.advanceProbe(r)) << 1;\n-                else if (isSubmit && runState != 0) {\n-                    q.access = 0;                    \/\/ check while lock held\n-                    break;\n-                }\n-                else\n+        for (;;) {\n+            int n, i, id; WorkQueue[] qs; WorkQueue q;\n+            if ((qs = queues) == null)\n+                break;\n+            if ((n = qs.length) <= 0)\n+                break;\n+            if ((q = qs[i = (id = r & EXTERNAL_ID_MASK) & (n - 1)]) == null) {\n+                WorkQueue w = new WorkQueue(null, id, 0, false);\n+                w.array = new ForkJoinTask<?>[INITIAL_QUEUE_CAPACITY];\n+                int stop = lockRunState() & STOP;\n+                if (stop == 0 && queues == qs && qs[i] == null)\n+                    q = qs[i] = w;                   \/\/ else discard; retry\n+                unlockRunState();\n+                if (q != null)\n@@ -2349,0 +2598,8 @@\n+                if (stop != 0)\n+                    break;\n+            }\n+            else if (!q.tryLockPhase())              \/\/ move index\n+                r = ThreadLocalRandom.advanceProbe(r);\n+            else if ((runState & SHUTDOWN) != 0) {\n+                q.unlockPhase();                     \/\/ check while q lock held\n+                break;\n@@ -2350,0 +2607,2 @@\n+            else\n+                return q;\n@@ -2351,0 +2610,1 @@\n+        tryTerminate(false, false);\n@@ -2354,9 +2614,2 @@\n-    \/**\n-     * Pushes a submission to the pool, using internal queue if called\n-     * from ForkJoinWorkerThread, else external queue.\n-     *\/\n-    private <T> ForkJoinTask<T> poolSubmit(boolean signalIfEmpty,\n-                                           ForkJoinTask<T> task) {\n-        WorkQueue q; Thread t; ForkJoinWorkerThread wt;\n-        U.storeStoreFence();  \/\/ ensure safely publishable\n-        if (task == null) throw new NullPointerException();\n+    private void poolSubmit(boolean signalIfEmpty, ForkJoinTask<?> task) {\n+        Thread t; ForkJoinWorkerThread wt; WorkQueue q; boolean internal;\n@@ -2364,1 +2617,2 @@\n-            (wt = (ForkJoinWorkerThread)t).pool == this)\n+            (wt = (ForkJoinWorkerThread)t).pool == this) {\n+            internal = true;\n@@ -2366,3 +2620,0 @@\n-        else {\n-            task.markPoolSubmission();\n-            q = submissionQueue(true);\n@@ -2370,2 +2621,17 @@\n-        q.push(task, this, signalIfEmpty);\n-        return task;\n+        else {                     \/\/ find and lock queue\n+            internal = false;\n+            q = submissionQueue(ThreadLocalRandom.getProbe());\n+        }\n+        q.push(task, signalIfEmpty ? this : null, internal);\n+    }\n+\n+    \/**\n+     * Returns queue for an external submission, bypassing call to\n+     * submissionQueue if already established and unlocked.\n+     *\/\n+    final WorkQueue externalSubmissionQueue() {\n+        WorkQueue[] qs; WorkQueue q; int n;\n+        int r = ThreadLocalRandom.getProbe();\n+        return (((qs = queues) != null && (n = qs.length) > 0 &&\n+                 (q = qs[r & EXTERNAL_ID_MASK & (n - 1)]) != null && r != 0 &&\n+                 q.tryLockPhase()) ? q : submissionQueue(r));\n@@ -2379,3 +2645,3 @@\n-    private static WorkQueue externalQueue(ForkJoinPool p) {\n-        WorkQueue[] qs;\n-        int r = ThreadLocalRandom.getProbe(), n;\n+    static WorkQueue externalQueue(ForkJoinPool p) {\n+        WorkQueue[] qs; int n;\n+        int r = ThreadLocalRandom.getProbe();\n@@ -2384,1 +2650,1 @@\n-            qs[(n - 1) & (r << 1)] : null;\n+            qs[r & EXTERNAL_ID_MASK & (n - 1)] : null;\n@@ -2394,7 +2660,0 @@\n-    \/**\n-     * Returns queue for an external thread, if one exists\n-     *\/\n-    final WorkQueue externalQueue() {\n-        return externalQueue(this);\n-    }\n-\n@@ -2408,4 +2667,3 @@\n-        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) {\n-            if ((wt = (ForkJoinWorkerThread)t).pool == e)\n-                w = wt.workQueue;\n-        }\n+        if (((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) &&\n+            (wt = (ForkJoinWorkerThread)t).pool == e)\n+            w = wt.workQueue;\n@@ -2413,1 +2671,1 @@\n-            w = ((ForkJoinPool)e).externalQueue();\n+            w = externalQueue((ForkJoinPool)e);\n@@ -2485,15 +2743,18 @@\n-     * @return true if terminating or terminated\n-     *\/\n-    private boolean tryTerminate(boolean now, boolean enable) {\n-        int rs; ReentrantLock lock; Condition cond;\n-        if ((rs = runState) >= 0) {                 \/\/ set SHUTDOWN and\/or STOP\n-            if ((config & ISCOMMON) != 0)\n-                return false;                       \/\/ cannot shutdown\n-            if (!now) {\n-                if ((rs & SHUTDOWN) == 0) {\n-                    if (!enable)\n-                        return false;\n-                    getAndBitwiseOrRunState(SHUTDOWN);\n-                }\n-                if (!canStop())\n-                    return false;\n+     * @return runState on exit\n+     *\/\n+    private int tryTerminate(boolean now, boolean enable) {\n+        int e = runState;\n+        if ((e & STOP) == 0) {\n+            if (now) {\n+                int s = lockRunState();\n+                runState = e = (s + RS_LOCK) | STOP | SHUTDOWN;\n+                if ((s & STOP) == 0)\n+                    interruptAll();\n+            }\n+            else {\n+                int isShutdown = (e & SHUTDOWN);\n+                if (isShutdown == 0 && enable)\n+                    getAndBitwiseOrRunState(isShutdown = SHUTDOWN);\n+                if (isShutdown != 0)\n+                    quiescent();                 \/\/ may trigger STOP\n+                e = runState;\n@@ -2501,9 +2762,3 @@\n-            getAndBitwiseOrRunState(SHUTDOWN | STOP);\n-        }\n-        WorkQueue released = reactivate();          \/\/ try signalling waiter\n-        int tc = (short)(ctl >>> TC_SHIFT);\n-        if (released == null && tc > 0) {           \/\/ help unblock and cancel\n-            Thread current = Thread.currentThread();\n-            WorkQueue w = ((current instanceof ForkJoinWorkerThread) ?\n-                           ((ForkJoinWorkerThread)current).workQueue : null);\n-            int r = (w == null) ? 0 : w.config + 1; \/\/ stagger traversals\n+        }\n+        if ((e & (STOP | TERMINATED)) == STOP) { \/\/ help cancel tasks\n+            int r = (int)Thread.currentThread().threadId(); \/\/ stagger traversals\n@@ -2512,12 +2767,7 @@\n-            for (int i = 0; i < n; ++i) {\n-                WorkQueue q; Thread thread;\n-                if ((q = qs[(r + i) & (n - 1)]) != null &&\n-                    (thread = q.owner) != current && q.access != STOP) {\n-                    for (ForkJoinTask<?> t; (t = q.poll(null)) != null; )\n-                        ForkJoinTask.cancelIgnoringExceptions(t);\n-                    if (thread != null && !thread.isInterrupted()) {\n-                        q.forcePhaseActive();      \/\/ for awaitWork\n-                        try {\n-                            thread.interrupt();\n-                        } catch (Throwable ignore) {\n-                        }\n+            for (int l = n; l > 0; --l, ++r) {\n+                int j = r & SMASK & (n - 1); WorkQueue q; ForkJoinTask<?> t;\n+                while ((q = qs[j]) != null && q.source != DEREGISTERED &&\n+                       (t = q.poll(null)) != null) {\n+                    try {\n+                        t.cancel(false);\n+                    } catch (Throwable ignore) {\n@@ -2527,0 +2777,10 @@\n+            if (((e = runState) & TERMINATED) == 0 && ctl == 0L) {\n+                if ((getAndBitwiseOrRunState(TERMINATED) & TERMINATED) == 0) {\n+                    CountDownLatch done; SharedThreadContainer ctr;\n+                    if ((done = termination) != null)\n+                        done.countDown();\n+                    if ((ctr = container) != null)\n+                        ctr.close();\n+                }\n+                e = runState;\n+            }\n@@ -2528,8 +2788,19 @@\n-        if ((tc <= 0 || (short)(ctl >>> TC_SHIFT) <= 0) &&\n-            (getAndBitwiseOrRunState(TERMINATED) & TERMINATED) == 0 &&\n-            (lock = registrationLock) != null) {\n-            lock.lock();                            \/\/ signal when no workers\n-            if ((cond = termination) != null)\n-                cond.signalAll();\n-            lock.unlock();\n-            container.close();\n+        return e;\n+    }\n+\n+    \/**\n+     * Interrupts all workers\n+     *\/\n+    private void interruptAll() {\n+        Thread current = Thread.currentThread();\n+        WorkQueue[] qs = queues;\n+        int n = (qs == null) ? 0 : qs.length;\n+        for (int i = 1; i < n; i += 2) {\n+            WorkQueue q; Thread o;\n+            if ((q = qs[i]) != null && (o = q.owner) != null && o != current &&\n+                q.source != DEREGISTERED) {\n+                try {\n+                    o.interrupt();\n+                } catch (Throwable ignore) {\n+                }\n+            }\n@@ -2537,1 +2808,12 @@\n-        return true;\n+    }\n+\n+\n+    \/**\n+     * Returns termination signal, constructing if necessary\n+     *\/\n+    private CountDownLatch terminationSignal() {\n+        CountDownLatch signal, s, u;\n+        if ((signal = termination) == null)\n+            signal = ((u = cmpExTerminationSignal(\n+                           s = new CountDownLatch(1))) == null) ? s : u;\n+        return signal;\n@@ -2711,0 +2993,1 @@\n+        int size = 1 << (33 - Integer.numberOfLeadingZeros(p - 1));\n@@ -2715,1 +2998,0 @@\n-        this.config = asyncMode ? FIFO : 0;\n@@ -2717,1 +2999,0 @@\n-        int corep = Math.clamp(corePoolSize, p, MAX_CAP);\n@@ -2720,4 +3001,3 @@\n-        this.bounds = (long)(minAvail & SMASK) | (long)(maxSpares << SWIDTH) |\n-            ((long)corep << 32);\n-        int size = 1 << (33 - Integer.numberOfLeadingZeros(p - 1));\n-        this.registrationLock = new ReentrantLock();\n+        this.config = (((asyncMode ? FIFO : 0) & LMASK) |\n+                       (((long)maxSpares) << TC_SHIFT) |\n+                       (((long)minAvail)  << RC_SHIFT));\n@@ -2771,2 +3051,2 @@\n-        this.config = ISCOMMON | preset;\n-        this.bounds = (long)(1 | (maxSpares << SWIDTH));\n+        this.config = ((preset & LMASK) | (((long)maxSpares) << TC_SHIFT) |\n+                       (1L << RC_SHIFT));\n@@ -2778,1 +3058,0 @@\n-        this.registrationLock = new ReentrantLock();\n@@ -2821,0 +3100,1 @@\n+        Objects.requireNonNull(task);\n@@ -2834,0 +3114,1 @@\n+        Objects.requireNonNull(task);\n@@ -2867,1 +3148,3 @@\n-        return poolSubmit(true, task);\n+        Objects.requireNonNull(task);\n+        poolSubmit(true, task);\n+        return task;\n@@ -2877,1 +3160,6 @@\n-        return poolSubmit(true, new ForkJoinTask.AdaptedCallable<T>(task));\n+        ForkJoinTask<T> t =\n+            (Thread.currentThread() instanceof ForkJoinWorkerThread) ?\n+            new ForkJoinTask.AdaptedCallable<T>(task) :\n+            new ForkJoinTask.AdaptedInterruptibleCallable<T>(task);\n+        poolSubmit(true, t);\n+        return t;\n@@ -2887,1 +3175,6 @@\n-        return poolSubmit(true, new ForkJoinTask.AdaptedRunnable<T>(task, result));\n+        ForkJoinTask<T> t =\n+            (Thread.currentThread() instanceof ForkJoinWorkerThread) ?\n+            new ForkJoinTask.AdaptedRunnable<T>(task, result) :\n+            new ForkJoinTask.AdaptedInterruptibleRunnable<T>(task, result);\n+        poolSubmit(true, t);\n+        return t;\n@@ -2898,3 +3191,7 @@\n-        return poolSubmit(true, (task instanceof ForkJoinTask<?>)\n-                          ? (ForkJoinTask<Void>) task \/\/ avoid re-wrap\n-                          : new ForkJoinTask.AdaptedRunnableAction(task));\n+        ForkJoinTask<?> f = (task instanceof ForkJoinTask<?>) ?\n+            (ForkJoinTask<Void>) task : \/\/ avoid re-wrap\n+            ((Thread.currentThread() instanceof ForkJoinWorkerThread) ?\n+             new ForkJoinTask.AdaptedRunnable<Void>(task, null) :\n+             new ForkJoinTask.AdaptedInterruptibleRunnable<Void>(task, null));\n+        poolSubmit(true, f);\n+        return f;\n@@ -2903,2 +3200,0 @@\n-    \/\/ Added mainly for possible use in Loom\n-\n@@ -2923,4 +3218,2 @@\n-        U.storeStoreFence();  \/\/ ensure safely publishable\n-        task.markPoolSubmission();\n-        WorkQueue q = submissionQueue(true);\n-        q.push(task, this, true);\n+        Objects.requireNonNull(task);\n+        externalSubmissionQueue().push(task, this, false);\n@@ -2947,1 +3240,3 @@\n-        return poolSubmit(false, task);\n+        Objects.requireNonNull(task);\n+        poolSubmit(false, task);\n+        return task;\n@@ -2983,2 +3278,22 @@\n-     * @throws NullPointerException       {@inheritDoc}\n-     * @throws RejectedExecutionException {@inheritDoc}\n+     * Uninterrupible version of {@code invokeAll}. Executes the given\n+     * tasks, returning a list of Futures holding their status and\n+     * results when all complete, ignoring interrupts.  {@link\n+     * Future#isDone} is {@code true} for each element of the returned\n+     * list.  Note that a <em>completed<\/em> task could have\n+     * terminated either normally or by throwing an exception.  The\n+     * results of this method are undefined if the given collection is\n+     * modified while this operation is in progress.\n+     *\n+     * @apiNote This method supports usages that previously relied on an\n+     * incompatible override of\n+     * {@link ExecutorService#invokeAll(java.util.Collection)}.\n+     *\n+     * @param tasks the collection of tasks\n+     * @param <T> the type of the values returned from the tasks\n+     * @return a list of Futures representing the tasks, in the same\n+     *         sequential order as produced by the iterator for the\n+     *         given task list, each of which has completed\n+     * @throws NullPointerException if tasks or any of its elements are {@code null}\n+     * @throws RejectedExecutionException if any task cannot be\n+     *         scheduled for execution\n+     * @since 22\n@@ -2986,2 +3301,1 @@\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) {\n+    public <T> List<Future<T>> invokeAllUninterruptibly(Collection<? extends Callable<T>> tasks) {\n@@ -2991,2 +3305,1 @@\n-                ForkJoinTask<T> f =\n-                    new ForkJoinTask.AdaptedInterruptibleCallable<T>(t);\n+                ForkJoinTask<T> f = ForkJoinTask.adapt(t);\n@@ -3001,1 +3314,1 @@\n-                ForkJoinTask.cancelIgnoringExceptions(e);\n+                e.cancel(true);\n@@ -3006,3 +3319,5 @@\n-    @Override\n-    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,\n-                                         long timeout, TimeUnit unit)\n+    \/**\n+     * Common support for timed and untimed invokeAll\n+     *\/\n+    private  <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,\n+                                           long deadline)\n@@ -3010,1 +3325,0 @@\n-        long nanos = unit.toNanos(timeout);\n@@ -3014,2 +3328,1 @@\n-                ForkJoinTask<T> f =\n-                    new ForkJoinTask.AdaptedInterruptibleCallable<T>(t);\n+                ForkJoinTask<T> f = ForkJoinTask.adaptInterruptible(t);\n@@ -3019,13 +3332,3 @@\n-            long startTime = System.nanoTime(), ns = nanos;\n-            boolean timedOut = (ns < 0L);\n-            for (int i = futures.size() - 1; i >= 0; --i) {\n-                ForkJoinTask<T> f = (ForkJoinTask<T>)futures.get(i);\n-                if (!f.isDone()) {\n-                    if (!timedOut)\n-                        timedOut = !f.quietlyJoin(ns, TimeUnit.NANOSECONDS);\n-                    if (timedOut)\n-                        ForkJoinTask.cancelIgnoringExceptions(f);\n-                    else\n-                        ns = nanos - (System.nanoTime() - startTime);\n-                }\n-            }\n+            for (int i = futures.size() - 1; i >= 0; --i)\n+                ((ForkJoinTask<?>)futures.get(i))\n+                    .quietlyJoinPoolInvokeAllTask(deadline);\n@@ -3035,1 +3338,1 @@\n-                ForkJoinTask.cancelIgnoringExceptions(e);\n+                e.cancel(true);\n@@ -3040,70 +3343,20 @@\n-    \/\/ Task to hold results from InvokeAnyTasks\n-    static final class InvokeAnyRoot<E> extends ForkJoinTask<E> {\n-        private static final long serialVersionUID = 2838392045355241008L;\n-        @SuppressWarnings(\"serial\") \/\/ Conditionally serializable\n-        volatile E result;\n-        final AtomicInteger count;  \/\/ in case all throw\n-        @SuppressWarnings(\"serial\")\n-        final ForkJoinPool pool;    \/\/ to check shutdown while collecting\n-        InvokeAnyRoot(int n, ForkJoinPool p) {\n-            pool = p;\n-            count = new AtomicInteger(n);\n-        }\n-        final void tryComplete(Callable<E> c) { \/\/ called by InvokeAnyTasks\n-            Throwable ex = null;\n-            boolean failed;\n-            if (c == null || Thread.interrupted() ||\n-                (pool != null && pool.runState < 0))\n-                failed = true;\n-            else if (isDone())\n-                failed = false;\n-            else {\n-                try {\n-                    complete(c.call());\n-                    failed = false;\n-                } catch (Throwable tx) {\n-                    ex = tx;\n-                    failed = true;\n-                }\n-            }\n-            if ((pool != null && pool.runState < 0) ||\n-                (failed && count.getAndDecrement() <= 1))\n-                trySetThrown(ex != null ? ex : new CancellationException());\n-        }\n-        public final boolean exec()         { return false; } \/\/ never forked\n-        public final E getRawResult()       { return result; }\n-        public final void setRawResult(E v) { result = v; }\n-    }\n-\n-    \/\/ Variant of AdaptedInterruptibleCallable with results in InvokeAnyRoot\n-    static final class InvokeAnyTask<E> extends ForkJoinTask<E> {\n-        private static final long serialVersionUID = 2838392045355241008L;\n-        final InvokeAnyRoot<E> root;\n-        @SuppressWarnings(\"serial\") \/\/ Conditionally serializable\n-        final Callable<E> callable;\n-        transient volatile Thread runner;\n-        InvokeAnyTask(InvokeAnyRoot<E> root, Callable<E> callable) {\n-            this.root = root;\n-            this.callable = callable;\n-        }\n-        public final boolean exec() {\n-            Thread.interrupted();\n-            runner = Thread.currentThread();\n-            root.tryComplete(callable);\n-            runner = null;\n-            Thread.interrupted();\n-            return true;\n-        }\n-        public final boolean cancel(boolean mayInterruptIfRunning) {\n-            Thread t;\n-            boolean stat = super.cancel(false);\n-            if (mayInterruptIfRunning && (t = runner) != null) {\n-                try {\n-                    t.interrupt();\n-                } catch (Throwable ignore) {\n-                }\n-            }\n-            return stat;\n-        }\n-        public final void setRawResult(E v) {} \/\/ unused\n-        public final E getRawResult()       { return null; }\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n+        throws InterruptedException {\n+        return invokeAll(tasks, 0L);\n+    }\n+    \/\/ for jdk version < 22, replace with\n+    \/\/ \/**\n+    \/\/  * @throws NullPointerException       {@inheritDoc}\n+    \/\/  * @throws RejectedExecutionException {@inheritDoc}\n+    \/\/  *\/\n+    \/\/ @Override\n+    \/\/ public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) {\n+    \/\/     return invokeAllUninterruptibly(tasks);\n+    \/\/ }\n+\n+    @Override\n+    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,\n+                                         long timeout, TimeUnit unit)\n+        throws InterruptedException {\n+        return invokeAll(tasks, (System.nanoTime() + unit.toNanos(timeout)) | 1L);\n@@ -3115,5 +3368,0 @@\n-        int n = tasks.size();\n-        if (n <= 0)\n-            throw new IllegalArgumentException();\n-        InvokeAnyRoot<T> root = new InvokeAnyRoot<T>(n, this);\n-        ArrayList<InvokeAnyTask<T>> fs = new ArrayList<>(n);\n@@ -3121,13 +3369,5 @@\n-            for (Callable<T> c : tasks) {\n-                if (c == null)\n-                    throw new NullPointerException();\n-                InvokeAnyTask<T> f = new InvokeAnyTask<T>(root, c);\n-                fs.add(f);\n-                poolSubmit(true, f);\n-                if (root.isDone())\n-                    break;\n-            }\n-            return root.get();\n-        } finally {\n-            for (InvokeAnyTask<T> f : fs)\n-                ForkJoinTask.cancelIgnoringExceptions(f);\n+            return new ForkJoinTask.InvokeAnyRoot<T>()\n+                .invokeAny(tasks, this, false, 0L);\n+        } catch (TimeoutException cannotHappen) {\n+            assert false;\n+            return null;\n@@ -3141,21 +3381,2 @@\n-        long nanos = unit.toNanos(timeout);\n-        int n = tasks.size();\n-        if (n <= 0)\n-            throw new IllegalArgumentException();\n-        InvokeAnyRoot<T> root = new InvokeAnyRoot<T>(n, this);\n-        ArrayList<InvokeAnyTask<T>> fs = new ArrayList<>(n);\n-        try {\n-            for (Callable<T> c : tasks) {\n-                if (c == null)\n-                    throw new NullPointerException();\n-                InvokeAnyTask<T> f = new InvokeAnyTask<T>(root, c);\n-                fs.add(f);\n-                poolSubmit(true, f);\n-                if (root.isDone())\n-                    break;\n-            }\n-            return root.get(nanos, TimeUnit.NANOSECONDS);\n-        } finally {\n-            for (InvokeAnyTask<T> f : fs)\n-                ForkJoinTask.cancelIgnoringExceptions(f);\n-        }\n+        return new ForkJoinTask.InvokeAnyRoot<T>()\n+            .invokeAny(tasks, this, true, unit.toNanos(timeout));\n@@ -3267,1 +3488,1 @@\n-        return canStop();\n+        return quiescent();\n@@ -3342,1 +3563,8 @@\n-        return hasTasks(true);\n+        WorkQueue[] qs; WorkQueue q;\n+        if ((runState & STOP) == 0 && (qs = queues) != null) {\n+            for (int i = 0; i < qs.length; i += 2) {\n+                if ((q = qs[i]) != null && q.queueSize() > 0)\n+                    return true;\n+            }\n+        }\n+        return false;\n@@ -3391,0 +3619,1 @@\n+        int e = runState;\n@@ -3416,4 +3645,3 @@\n-        int rs = runState;\n-        String level = ((rs & TERMINATED) != 0 ? \"Terminated\" :\n-                        (rs & STOP)       != 0 ? \"Terminating\" :\n-                        (rs & SHUTDOWN)   != 0 ? \"Shutting down\" :\n+        String level = ((e & TERMINATED) != 0 ? \"Terminated\" :\n+                        (e & STOP)       != 0 ? \"Terminating\" :\n+                        (e & SHUTDOWN)   != 0 ? \"Shutting down\" :\n@@ -3449,1 +3677,2 @@\n-        tryTerminate(false, true);\n+        if (workerNamePrefix != null) \/\/ not common pool\n+            tryTerminate(false, true);\n@@ -3472,1 +3701,2 @@\n-        tryTerminate(true, true);\n+        if (workerNamePrefix != null) \/\/ not common pool\n+            tryTerminate(true, true);\n@@ -3482,1 +3712,1 @@\n-        return (runState & TERMINATED) != 0;\n+        return (tryTerminate(false, false) & TERMINATED) != 0;\n@@ -3499,1 +3729,1 @@\n-        return (runState & (STOP | TERMINATED)) == STOP;\n+        return (tryTerminate(false, false) & (STOP | TERMINATED)) == STOP;\n@@ -3508,1 +3738,1 @@\n-        return runState != 0;\n+        return (runState & SHUTDOWN) != 0;\n@@ -3527,1 +3757,0 @@\n-        ReentrantLock lock; Condition cond; boolean terminated;\n@@ -3529,1 +3758,2 @@\n-        if ((config & ISCOMMON) != 0) {\n+        CountDownLatch done;\n+        if (workerNamePrefix == null) {    \/\/ is common pool\n@@ -3532,17 +3762,1 @@\n-            terminated = false;\n-        }\n-        else if (!(terminated = ((runState & TERMINATED) != 0))) {\n-            tryTerminate(false, false);  \/\/ reduce transient blocking\n-            if ((lock = registrationLock) != null &&\n-                !(terminated = (((runState & TERMINATED) != 0)))) {\n-                lock.lock();\n-                try {\n-                    if ((cond = termination) == null)\n-                        termination = cond = lock.newCondition();\n-                    while (!(terminated = ((runState & TERMINATED) != 0)) &&\n-                           nanos > 0L)\n-                        nanos = cond.awaitNanos(nanos);\n-                } finally {\n-                    lock.unlock();\n-                }\n-            }\n+            return false;\n@@ -3550,1 +3764,6 @@\n-        return terminated;\n+        else if ((tryTerminate(false, false) & TERMINATED) != 0 ||\n+                 (done = terminationSignal()) == null ||\n+                 (runState & TERMINATED) != 0)\n+            return true;\n+        else\n+            return done.await(nanos, TimeUnit.NANOSECONDS);\n@@ -3594,6 +3813,8 @@\n-        if ((config & ISCOMMON) == 0) {\n-            boolean terminated = tryTerminate(false, false);\n-            if (!terminated) {\n-                shutdown();\n-                boolean interrupted = false;\n-                while (!terminated) {\n+        if (workerNamePrefix != null) {\n+            checkPermission();\n+            CountDownLatch done = null;\n+            boolean interrupted = false;\n+            while ((tryTerminate(interrupted, true) & TERMINATED) == 0) {\n+                if (done == null)\n+                    done = terminationSignal();\n+                else {\n@@ -3601,6 +3822,4 @@\n-                        terminated = awaitTermination(1L, TimeUnit.DAYS);\n-                    } catch (InterruptedException e) {\n-                        if (!interrupted) {\n-                            shutdownNow();\n-                            interrupted = true;\n-                        }\n+                        done.await();\n+                        break;\n+                    } catch (InterruptedException ex) {\n+                        interrupted = true;\n@@ -3609,3 +3828,0 @@\n-                if (interrupted) {\n-                    Thread.currentThread().interrupt();\n-                }\n@@ -3613,0 +3829,2 @@\n+            if (interrupted)\n+                Thread.currentThread().interrupt();\n@@ -3731,1 +3949,1 @@\n-        if (blocker == null) throw new NullPointerException();\n+        Objects.requireNonNull(blocker);\n@@ -3737,2 +3955,3 @@\n-            if ((comp = tryCompensate(c, false)) >= 0) {\n-                long post = (comp == 0) ? 0L : RC_UNIT;\n+            if ((runState & STOP) != 0)\n+                throw new InterruptedException();\n+            if ((comp = tryCompensate(c)) >= 0) {\n@@ -3742,1 +3961,2 @@\n-                    getAndAddCtl(post);\n+                    if (comp > 0)\n+                        getAndAddCtl(RC_UNIT);\n@@ -3756,9 +3976,4 @@\n-    private long beginCompensatedBlock() {\n-        for (;;) {\n-            int comp;\n-            if ((comp = tryCompensate(ctl, false)) >= 0) {\n-                return (comp == 0) ? 0L : RC_UNIT;\n-            } else {\n-                Thread.onSpinWait();\n-            }\n-        }\n+    final long beginCompensatedBlock() {\n+        int c;\n+        do {} while ((c = tryCompensate(ctl)) < 0);\n+        return (c == 0) ? 0L : RC_UNIT;\n@@ -3771,1 +3986,1 @@\n-        if (post > 0) {\n+        if (post > 0L) {\n@@ -3779,1 +3994,1 @@\n-        if (blocker == null) throw new NullPointerException();\n+        Objects.requireNonNull(blocker);\n@@ -3783,4 +3998,0 @@\n-    \/\/ AbstractExecutorService.newTaskFor overrides rely on\n-    \/\/ undocumented fact that ForkJoinTask.adapt returns ForkJoinTasks\n-    \/\/ that also implement RunnableFuture.\n-\n@@ -3789,1 +4000,3 @@\n-        return new ForkJoinTask.AdaptedRunnable<T>(runnable, value);\n+        return (Thread.currentThread() instanceof ForkJoinWorkerThread) ?\n+            new ForkJoinTask.AdaptedRunnable<T>(runnable, value) :\n+            new ForkJoinTask.AdaptedInterruptibleRunnable<T>(runnable, value);\n@@ -3794,1 +4007,3 @@\n-        return new ForkJoinTask.AdaptedCallable<T>(callable);\n+        return (Thread.currentThread() instanceof ForkJoinWorkerThread) ?\n+            new ForkJoinTask.AdaptedCallable<T>(callable) :\n+            new ForkJoinTask.AdaptedInterruptibleCallable<T>(callable);\n@@ -3809,1 +4024,1 @@\n-        PARALLELISM = U.objectFieldOffset(klass, \"parallelism\");\n+        PARALLELISM =  U.objectFieldOffset(klass, \"parallelism\");\n@@ -3811,0 +4026,7 @@\n+        TERMINATION = U.objectFieldOffset(klass, \"termination\");\n+        Class<ForkJoinTask[]> aklass = ForkJoinTask[].class;\n+        ABASE = U.arrayBaseOffset(aklass);\n+        int scale = U.arrayIndexScale(aklass);\n+        ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);\n+        if ((scale & (scale - 1)) != 0)\n+            throw new Error(\"array index scale not a power of two\");\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":1618,"deletions":1396,"binary":false,"changes":3014,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.Objects;\n@@ -211,1 +212,15 @@\n-     * to methods in ForkJoinWorkerThread and ForkJoinPool.\n+     * to methods in ForkJoinWorkerThread and ForkJoinPool, along with\n+     * recording and reporting exceptions.  The status field mainly\n+     * holds bits recording completion status.  Note that there is no\n+     * status bit representing \"running\", recording whether incomplete\n+     * tasks are queued vs executing. However these cases can be\n+     * distinguished in subclasses of InterruptibleTask that adds this\n+     * capability by recording the running thread.  Cancellation is\n+     * recorded in status bits (ABNORMAL but not THROWN), but reported\n+     * in joining methods by throwing an exception. Other exceptions\n+     * of completed (THROWN) tasks are recorded in the \"aux\" field,\n+     * but are reconstructed (in getException) to produce more useful\n+     * stack traces when reported. Sentinels for interruptions or\n+     * timeouts while waiting for completion are not recorded as\n+     * status bits but are included in return values of methods in\n+     * which they occur.\n@@ -217,0 +232,1 @@\n+     * (4) Subclasses for adaptors and internal usages\n@@ -219,6 +235,0 @@\n-     *\n-     * Revision notes: This class uses jdk-internal Unsafe for atomics\n-     * and special memory modes, rather than VarHandles, to avoid\n-     * initialization dependencies in other jdk components that\n-     * require early parallelism. It also simplifies handling of\n-     * pool-submitted tasks, among other minor improvements.\n@@ -234,3 +244,3 @@\n-        final Thread thread;\n-        final Throwable ex;  \/\/ null if a waiter\n-        Aux next;            \/\/ accessed only via memory-acquire chains\n+        Thread thread;          \/\/ thrower or waiter\n+        final Throwable ex;\n+        Aux next;               \/\/ accessed only via memory-acquire chains\n@@ -262,11 +272,7 @@\n-    static final int DONE         = 1 << 31; \/\/ must be negative\n-    static final int ABNORMAL     = 1 << 16;\n-    static final int THROWN       = 1 << 17;\n-    static final int SMASK        = 0xffff;  \/\/ short bits for tags\n-    static final int UNCOMPENSATE = 1 << 16; \/\/ helpJoin return sentinel\n-    static final int POOLSUBMIT   = 1 << 18; \/\/ for pool.submit vs fork\n-\n-    \/\/ flags for awaitDone (in addition to above)\n-    static final int RAN           = 1;\n-    static final int INTERRUPTIBLE = 2;\n-    static final int TIMED         = 4;\n+    static final int DONE           = 1 << 31; \/\/ must be negative\n+    static final int ABNORMAL       = 1 << 16;\n+    static final int THROWN         = 1 << 17;\n+    static final int HAVE_EXCEPTION = DONE | ABNORMAL | THROWN;\n+    static final int MARKER         = 1 << 30; \/\/ utility marker\n+    static final int SMASK          = 0xffff;  \/\/ short bits for tags\n+    static final int UNCOMPENSATE   = 1 << 16; \/\/ helpJoin sentinel\n@@ -288,0 +294,3 @@\n+\n+    \/\/ Support for waiting and signalling\n+\n@@ -291,6 +300,2 @@\n-\n-    \/**\n-     * Marks this task as an external pool submission.\n-     *\/\n-    final void markPoolSubmission() {\n-        getAndBitwiseOrStatus(POOLSUBMIT);\n+    private Aux compareAndExchangeAux(Aux c, Aux v) {\n+        return (Aux)U.compareAndExchangeReference(this, AUX, c, v);\n@@ -298,1 +303,0 @@\n-\n@@ -301,6 +305,7 @@\n-        for (Aux a; (a = aux) != null && a.ex == null; ) {\n-            if (casAux(a, null)) {             \/\/ detach entire list\n-                for (Thread t; a != null; a = a.next) {\n-                    if ((t = a.thread) != Thread.currentThread() && t != null)\n-                        LockSupport.unpark(t); \/\/ don't self-signal\n-                }\n+        for (Aux a = aux;;) {\n+            if (a == null || a.ex != null)\n+                break;\n+            if (a == (a = compareAndExchangeAux(a, null))) {\n+                do {                \/\/ detach entire list\n+                    LockSupport.unpark(a.thread);\n+                } while ((a = a.next) != null);\n@@ -314,1 +319,0 @@\n-     * @return status on exit\n@@ -316,2 +320,2 @@\n-    private int setDone() {\n-        int s = getAndBitwiseOrStatus(DONE) | DONE;\n+    private void setDone() {\n+        getAndBitwiseOrStatus(DONE);\n@@ -319,1 +323,0 @@\n-        return s;\n@@ -325,1 +328,1 @@\n-     * @return status on exit\n+     * @return previous status\n@@ -327,1 +330,1 @@\n-    private int trySetCancelled() {\n+    final int trySetCancelled() {\n@@ -329,2 +332,8 @@\n-        do {} while ((s = status) >= 0 && !casStatus(s, s |= (DONE | ABNORMAL)));\n-        signalWaiters();\n+        for (;;) {\n+            if ((s = status) < 0)\n+                break;\n+            if (casStatus(s, s | (DONE | ABNORMAL))) {\n+                signalWaiters();\n+                break;\n+            }\n+        }\n@@ -340,1 +349,1 @@\n-     * @return status on exit\n+     * @return true if set\n@@ -342,3 +351,1 @@\n-    final int trySetThrown(Throwable ex) {\n-        Aux h = new Aux(Thread.currentThread(), ex), p = null;\n-        boolean installed = false;\n+    final boolean trySetThrown(Throwable ex) {\n@@ -346,7 +353,12 @@\n-        while ((s = status) >= 0) {\n-            Aux a;\n-            if (!installed && ((a = aux) == null || a.ex == null) &&\n-                (installed = casAux(a, h)))\n-                p = a; \/\/ list of waiters replaced by h\n-            if (installed && casStatus(s, s |= (DONE | ABNORMAL | THROWN)))\n-                break;\n+        boolean set = false, installed = false;\n+        if ((s = status) >= 0) {\n+            Aux a, p = null, h = new Aux(Thread.currentThread(), ex);\n+            do {\n+                if (!installed && ((a = aux) == null || a.ex == null) &&\n+                    (installed = casAux(a, h)))\n+                    p = a; \/\/ list of waiters replaced by h\n+                if (installed && (set = casStatus(s, s | HAVE_EXCEPTION)))\n+                    break;\n+            } while ((s = status) >= 0);\n+            for (; p != null; p = p.next)\n+                LockSupport.unpark(p.thread);\n@@ -354,3 +366,1 @@\n-        for (; p != null; p = p.next)\n-            LockSupport.unpark(p.thread);\n-        return s;\n+        return set;\n@@ -360,3 +370,1 @@\n-     * Records exception unless already done. Overridable in subclasses.\n-     *\n-     * @return status on exit\n+     * Overridable action on setting exception\n@@ -364,2 +372,1 @@\n-    int trySetException(Throwable ex) {\n-        return trySetThrown(ex);\n+    void onAuxExceptionSet(Throwable ex) {\n@@ -369,1 +376,1 @@\n-     * Constructor for subclasses to call.\n+     * Tries to set exception, if so invoking onAuxExceptionSet\n@@ -371,4 +378,3 @@\n-    public ForkJoinTask() {}\n-\n-    static boolean isExceptionalStatus(int s) {  \/\/ needed by subclasses\n-        return (s & THROWN) != 0;\n+    final void trySetException(Throwable ex) {\n+        if (trySetThrown(ex))\n+            onAuxExceptionSet(ex);\n@@ -377,3 +383,2 @@\n-    \/**\n-     * Unless done, calls exec and records status if completed, but\n-     * doesn't wait for completion otherwise.\n+    \/*\n+     * Waits for signal, interrupt, timeout, or pool termination.\n@@ -381,4 +386,9 @@\n-     * @return status on exit from this method\n-     *\/\n-    final int doExec() {\n-        int s; boolean completed;\n+     * @param pool if nonnull, the pool of ForkJoinWorkerThread caller\n+     * @param compensation result from a helping method\n+     * @param interruptible if wait is interruptible\n+     * @param deadline if nonzero, timeout deadline\n+     * @return ABNORMAL if interrupted, 0 on timeout, else status on exit\n+     *\/\n+    private int awaitDone(ForkJoinPool pool, int compensation,\n+                          boolean interruptible, long deadline) {\n+        int s;\n@@ -386,51 +396,2 @@\n-            try {\n-                completed = exec();\n-            } catch (Throwable rex) {\n-                s = trySetException(rex);\n-                completed = false;\n-            }\n-            if (completed)\n-                s = setDone();\n-        }\n-        return s;\n-    }\n-\n-    \/**\n-     * Helps and\/or waits for completion from join, get, or invoke;\n-     * called from either internal or external threads.\n-     *\n-     * @param how flags for POOLSUBMIT, RAN, INTERRUPTIBLE, TIMED\n-     * @param deadline if timed, timeout deadline\n-     * @return ABNORMAL if interrupted, else status on exit\n-     *\/\n-    private int awaitDone(int how, long deadline) {\n-        int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool p;\n-        ForkJoinPool.WorkQueue q = null;\n-        boolean timed = (how & TIMED) != 0;\n-        boolean owned = false, uncompensate = false;\n-        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) {\n-            owned = true;\n-            q = (wt = (ForkJoinWorkerThread)t).workQueue;\n-            p = wt.pool;\n-        }\n-        else if ((p = ForkJoinPool.common) != null && (how & POOLSUBMIT) == 0)\n-            q = p.externalQueue();\n-        if (q != null && p != null) { \/\/ try helping\n-            if (this instanceof CountedCompleter)\n-                s = p.helpComplete(this, q, owned, timed);\n-            else if ((how & RAN) != 0 ||\n-                     (s = q.tryRemoveAndExec(this, owned)) >= 0)\n-                s = (owned) ? p.helpJoin(this, q, timed) : 0;\n-            if (s < 0)\n-                return s;\n-            if (s == UNCOMPENSATE)\n-                uncompensate = true;\n-        }\n-        Aux node = null;\n-        long ns = 0L;\n-        boolean interrupted = false, queued = false;\n-        for (;;) {                    \/\/ install node and await signal\n-            Aux a;\n-            if ((s = status) < 0)\n-                break;\n-            else if (node == null)\n+            Aux node = null;\n+            try {                             \/\/ spinwait if out of memory\n@@ -438,4 +399,1 @@\n-            else if (!queued) {\n-                if (((a = aux) == null || a.ex == null) &&\n-                    (queued = casAux(node.next = a, node)))\n-                    LockSupport.setCurrentBlocker(this);\n+            } catch (OutOfMemoryError ex) {\n@@ -443,10 +401,8 @@\n-            else if (timed && (ns = deadline - System.nanoTime()) <= 0) {\n-                s = 0;\n-                break;\n-            }\n-            else if (Thread.interrupted()) {\n-                interrupted = true;\n-                if ((how & POOLSUBMIT) != 0 && p != null && p.runState < 0)\n-                    cancelIgnoringExceptions(this); \/\/ cancel on shutdown\n-                else if ((how & INTERRUPTIBLE) != 0) {\n-                    s = ABNORMAL;\n+            boolean queued = false;\n+            for (Aux a;;) {                   \/\/ try to install node\n+                if ((s = status) < 0)\n+                    break;\n+                else if (node == null)\n+                    Thread.onSpinWait();\n+                else if (((a = aux) == null || a.ex == null) &&\n+                         (queued = casAux(node.next = a, node)))\n@@ -454,1 +410,0 @@\n-                }\n@@ -456,15 +411,37 @@\n-            else if ((s = status) < 0) \/\/ recheck\n-                break;\n-            else if (timed)\n-                LockSupport.parkNanos(ns);\n-            else\n-                LockSupport.park();\n-        }\n-        if (uncompensate)\n-            p.uncompensate();\n-\n-        if (queued) {\n-            LockSupport.setCurrentBlocker(null);\n-            if (s >= 0) { \/\/ cancellation similar to AbstractQueuedSynchronizer\n-                outer: for (Aux a; (a = aux) != null && a.ex == null; ) {\n-                    for (Aux trail = null;;) {\n+            if (queued) {                     \/\/ await signal or interrupt\n+                LockSupport.setCurrentBlocker(this);\n+                int interrupts = 0;           \/\/ < 0 : throw; > 0 : re-interrupt\n+                for (;;) {\n+                    if ((s = status) < 0)\n+                        break;\n+                    else if (interrupts < 0) {\n+                        s = ABNORMAL;         \/\/ interrupted and not done\n+                        break;\n+                    }\n+                    else if (Thread.interrupted()) {\n+                        if (!ForkJoinPool.poolIsStopping(pool))\n+                            interrupts = interruptible ? -1 : 1;\n+                        else {\n+                            interrupts = 1;   \/\/ re-assert if cleared\n+                            try {\n+                                cancel(true);\n+                            } catch (Throwable ignore) {\n+                            }\n+                        }\n+                    }\n+                    else if (deadline != 0L) {\n+                        long ns;\n+                        if ((ns = deadline - System.nanoTime()) <= 0) {\n+                            s = 0;\n+                            break;\n+                        }\n+                        LockSupport.parkNanos(ns);\n+                    }\n+                    else\n+                        LockSupport.park();\n+                }\n+                node.thread = null;           \/\/ help clean aux; raciness OK\n+                clean: for (Aux a;;) {        \/\/ remove node if still present\n+                    if ((a = aux) == null || a.ex != null)\n+                        break;\n+                    for (Aux prev = null;;) {\n@@ -473,2 +450,2 @@\n-                            if (trail != null)\n-                                trail.casNext(trail, next);\n+                            if (prev != null)\n+                                prev.casNext(prev, next);\n@@ -476,6 +453,2 @@\n-                                break outer; \/\/ cannot be re-encountered\n-                            break;           \/\/ restart\n-                        } else {\n-                            trail = a;\n-                            if ((a = next) == null)\n-                                break outer;\n+                                break clean;\n+                            break;            \/\/ check for failed or stale CAS\n@@ -483,0 +456,3 @@\n+                        prev = a;\n+                        if ((a = next) == null)\n+                            break clean;      \/\/ not found\n@@ -485,4 +461,2 @@\n-            }\n-            else {\n-                signalWaiters();             \/\/ help clean or signal\n-                if (interrupted)\n+                LockSupport.setCurrentBlocker(null);\n+                if (interrupts > 0)\n@@ -492,0 +466,2 @@\n+        if (compensation == UNCOMPENSATE && pool != null)\n+            pool.uncompensate();\n@@ -496,3 +472,8 @@\n-     * Cancels, ignoring any exceptions thrown by cancel.  Cancel is\n-     * spec'ed not to throw any exceptions, but if it does anyway, we\n-     * have no recourse, so guard against this case.\n+     * Tries applicable helping steps while joining this task,\n+     * otherwise invokes blocking version of awaitDone. Called only\n+     * when pre-checked not to be done, and pre-screened for\n+     * interrupts and timeouts, if applicable.\n+     *\n+     * @param interruptible if wait is interruptible\n+     * @param deadline if nonzero, timeout deadline\n+     * @return ABNORMAL if interrupted, else status on exit\n@@ -500,2 +481,25 @@\n-    static final void cancelIgnoringExceptions(Future<?> t) {\n-        if (t != null) {\n+    private int awaitDone(boolean interruptible, long deadline) {\n+        ForkJoinWorkerThread wt; ForkJoinPool p; ForkJoinPool.WorkQueue q;\n+        Thread t; boolean internal; int s;\n+        if (internal =\n+            (t = Thread.currentThread()) instanceof ForkJoinWorkerThread) {\n+            p = (wt = (ForkJoinWorkerThread)t).pool;\n+            q = wt.workQueue;\n+        }\n+        else\n+            q = ForkJoinPool.externalQueue(p = ForkJoinPool.common);\n+        return (((s = (p == null) ? 0 :\n+                  ((this instanceof CountedCompleter) ?\n+                   p.helpComplete(this, q, internal) :\n+                   (this instanceof InterruptibleTask) && !internal ? status :\n+                   p.helpJoin(this, q, internal))) < 0)) ? s :\n+            awaitDone(internal ? p : null, s, interruptible, deadline);\n+    }\n+\n+    \/**\n+     * Runs a task body: Unless done, calls exec and records status if\n+     * completed, but doesn't wait for completion otherwise.\n+     *\/\n+    final void doExec() {\n+        if (status >= 0) {\n+            boolean completed = false;\n@@ -503,2 +507,3 @@\n-                t.cancel(true);\n-            } catch (Throwable ignore) {\n+                completed = exec();\n+            } catch (Throwable rex) {\n+                trySetException(rex);\n@@ -506,0 +511,2 @@\n+            if (completed)\n+                setDone();\n@@ -509,0 +516,2 @@\n+    \/\/ Reporting Exceptions\n+\n@@ -521,0 +530,1 @@\n+     * @param asExecutionException true if wrap as ExecutionException\n@@ -523,5 +533,10 @@\n-    private Throwable getThrowableException() {\n-        Throwable ex; Aux a;\n-        if ((a = aux) == null)\n-            ex = null;\n-        else if ((ex = a.ex) != null && a.thread != Thread.currentThread()) {\n+    private Throwable getException(boolean asExecutionException) {\n+        int s; Throwable ex; Aux a;\n+        if ((s = status) >= 0 || (s & ABNORMAL) == 0)\n+            return null;\n+        else if ((s & THROWN) == 0 || (a = aux) == null || (ex = a.ex) == null) {\n+            ex = new CancellationException();\n+            if (!asExecutionException || !(this instanceof InterruptibleTask))\n+                return ex;         \/\/ else wrap below\n+        }\n+        else if (a.thread != Thread.currentThread()) {\n@@ -549,19 +564,1 @@\n-        return ex;\n-    }\n-\n-    \/**\n-     * Returns exception associated with the given status, or null if none.\n-     *\/\n-    private Throwable getException(int s) {\n-        Throwable ex = null;\n-        if ((s & ABNORMAL) != 0 && (ex = getThrowableException()) == null)\n-            ex = new CancellationException();\n-        return ex;\n-    }\n-\n-    \/**\n-     * Throws exception associated with the given status, or\n-     * CancellationException if none recorded.\n-     *\/\n-    private void reportException(int s) {\n-        ForkJoinTask.<RuntimeException>uncheckedThrow(getThrowableException());\n+        return (asExecutionException) ? new ExecutionException(ex) : ex;\n@@ -571,2 +568,2 @@\n-     * Throws exception for (timed or untimed) get, wrapping if\n-     * necessary in an ExecutionException.\n+     * Throws thrown exception, or CancellationException if none\n+     * recorded.\n@@ -574,9 +571,3 @@\n-    private void reportExecutionException(int s) {\n-        Throwable ex = null, rx;\n-        if (s == ABNORMAL)\n-            ex = new InterruptedException();\n-        else if (s >= 0)\n-            ex = new TimeoutException();\n-        else if ((rx = getThrowableException()) != null)\n-            ex = new ExecutionException(rx);\n-        ForkJoinTask.<RuntimeException>uncheckedThrow(ex);\n+    private void reportException(boolean asExecutionException) {\n+        ForkJoinTask.<RuntimeException>\n+            uncheckedThrow(getException(asExecutionException));\n@@ -606,0 +597,16 @@\n+    \/\/ Utilities shared among ForkJoinTask, ForkJoinPool\n+\n+    \/**\n+     * Sets MARKER bit, returning nonzero if previously set\n+     *\/\n+    final int setForkJoinTaskStatusMarkerBit() {\n+        return getAndBitwiseOrStatus(MARKER) & MARKER;\n+    }\n+\n+    \/**\n+     * Returns nonzero if MARKER bit set.\n+     *\/\n+    final int getForkJoinTaskStatusMarkerBit() {\n+        return status & MARKER;\n+    }\n+\n@@ -608,0 +615,5 @@\n+    \/**\n+     * Constructor for subclasses to call.\n+     *\/\n+    public ForkJoinTask() {}\n+\n@@ -625,5 +637,5 @@\n-        ForkJoinPool p; ForkJoinPool.WorkQueue q;\n-        U.storeStoreFence();  \/\/ ensure safely publishable\n-        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) {\n-            p = (wt = (ForkJoinWorkerThread)t).pool;\n-            q = wt.workQueue;\n+        ForkJoinPool p; ForkJoinPool.WorkQueue q; boolean internal;\n+        if (internal =\n+            (t = Thread.currentThread()) instanceof ForkJoinWorkerThread) {\n+            q = (wt = (ForkJoinWorkerThread)t).workQueue;\n+            p = wt.pool;\n@@ -632,2 +644,2 @@\n-            q = (p = ForkJoinPool.common).submissionQueue(false);\n-        q.push(this, p, true);\n+            q = (p = ForkJoinPool.common).externalSubmissionQueue();\n+        q.push(this, p, internal);\n@@ -650,4 +662,2 @@\n-        if ((s = status) >= 0)\n-            s = awaitDone(s & POOLSUBMIT, 0L);\n-        if ((s & ABNORMAL) != 0)\n-            reportException(s);\n+        if ((((s = status) < 0 ? s : awaitDone(false, 0L)) & ABNORMAL) != 0)\n+            reportException(false);\n@@ -666,6 +676,2 @@\n-        int s;\n-        if ((s = doExec()) >= 0)\n-            s = awaitDone(RAN, 0L);\n-        if ((s & ABNORMAL) != 0)\n-            reportException(s);\n-        return getRawResult();\n+        doExec();\n+        return join();\n@@ -696,11 +702,5 @@\n-        if ((s1 = t1.doExec()) >= 0)\n-            s1 = t1.awaitDone(RAN, 0L);\n-        if ((s1 & ABNORMAL) != 0) {\n-            cancelIgnoringExceptions(t2);\n-            t1.reportException(s1);\n-        }\n-        else {\n-            if ((s2 = t2.status) >= 0)\n-                s2 = t2.awaitDone(0, 0L);\n-            if ((s2 & ABNORMAL) != 0)\n-                t2.reportException(s2);\n+        t1.doExec();\n+        if ((((s1 = t1.status) < 0 ? s1 :\n+              t1.awaitDone(false, 0L)) & ABNORMAL) != 0) {\n+            t2.cancel(false);\n+            t1.reportException(false);\n@@ -708,0 +708,3 @@\n+        else if ((((s2 = t2.status) < 0 ? s2 :\n+                   t2.awaitDone(false, 0L)) & ABNORMAL) != 0)\n+            t2.reportException(false);\n@@ -729,1 +732,1 @@\n-            ForkJoinTask<?> t;\n+            ForkJoinTask<?> t; int s;\n@@ -735,5 +738,4 @@\n-                int s;\n-                if ((s = t.doExec()) >= 0)\n-                    s = t.awaitDone(RAN, 0L);\n-                if ((s & ABNORMAL) != 0)\n-                    ex = t.getException(s);\n+                t.doExec();\n+                if ((((s = t.status) < 0 ? s :\n+                      t.awaitDone(false, 0L)) & ABNORMAL) != 0)\n+                    ex = t.getException(false);\n@@ -746,8 +748,6 @@\n-                ForkJoinTask<?> t;\n-                if ((t = tasks[i]) != null) {\n-                    int s;\n-                    if ((s = t.status) >= 0)\n-                        s = t.awaitDone(0, 0L);\n-                    if ((s & ABNORMAL) != 0 && (ex = t.getException(s)) != null)\n-                        break;\n-                }\n+                ForkJoinTask<?> t; int s;\n+                if ((t = tasks[i]) != null &&\n+                    ((((s = t.status) < 0 ? s :\n+                       t.awaitDone(false, 0L)) & ABNORMAL) != 0) &&\n+                    (ex = t.getException(false)) != null)\n+                    break;\n@@ -757,2 +757,5 @@\n-            for (int i = 1; i <= last; ++i)\n-                cancelIgnoringExceptions(tasks[i]);\n+            for (int i = 1; i <= last; ++i) {\n+                ForkJoinTask<?> t;\n+                if ((t = tasks[i]) != null)\n+                    t.cancel(false);\n+            }\n@@ -792,1 +795,1 @@\n-            ForkJoinTask<?> t;\n+            ForkJoinTask<?> t; int s;\n@@ -798,5 +801,4 @@\n-                int s;\n-                if ((s = t.doExec()) >= 0)\n-                    s = t.awaitDone(RAN, 0L);\n-                if ((s & ABNORMAL) != 0)\n-                    ex = t.getException(s);\n+                t.doExec();\n+                if ((((s = t.status) < 0 ? s :\n+                      t.awaitDone(false, 0L)) & ABNORMAL) != 0)\n+                    ex = t.getException(false);\n@@ -809,8 +811,6 @@\n-                ForkJoinTask<?> t;\n-                if ((t = ts.get(i)) != null) {\n-                    int s;\n-                    if ((s = t.status) >= 0)\n-                        s = t.awaitDone(0, 0L);\n-                    if ((s & ABNORMAL) != 0 && (ex = t.getException(s)) != null)\n-                        break;\n-                }\n+                ForkJoinTask<?> t; int s;\n+                if ((t = ts.get(i)) != null &&\n+                    ((((s = t.status) < 0 ? s :\n+                       t.awaitDone(false, 0L)) & ABNORMAL) != 0) &&\n+                    (ex = t.getException(false)) != null)\n+                    break;\n@@ -820,2 +820,5 @@\n-            for (int i = 1; i <= last; ++i)\n-                cancelIgnoringExceptions(ts.get(i));\n+            for (int i = 1; i <= last; ++i) {\n+                ForkJoinTask<?> t;\n+                if ((t = ts.get(i)) != null)\n+                    t.cancel(false);\n+            }\n@@ -855,1 +858,2 @@\n-        return (trySetCancelled() & (ABNORMAL | THROWN)) == ABNORMAL;\n+        int s = trySetCancelled();\n+        return (s >= 0 || (s & (ABNORMAL | THROWN)) == ABNORMAL);\n@@ -897,2 +901,9 @@\n-        if (!isCompletedNormally())\n-            throw new IllegalStateException();\n+        int s = status;\n+        if ((s & DONE) == 0)\n+             throw new IllegalStateException(\"Task has not completed\");\n+        if ((s & ABNORMAL) != 0) {\n+            if ((s & THROWN) != 0)\n+                throw new IllegalStateException(\"Task completed with exception\");\n+            else\n+                throw new IllegalStateException(\"Task was cancelled\");\n+        }\n@@ -904,1 +915,3 @@\n-        if ((status & (ABNORMAL | THROWN)) != (ABNORMAL | THROWN))\n+        Throwable ex;\n+        if ((status & HAVE_EXCEPTION) != HAVE_EXCEPTION ||\n+            (ex = getException(false)) == null)\n@@ -906,1 +919,1 @@\n-        return getThrowableException();\n+        return ex;\n@@ -917,1 +930,1 @@\n-        return getException(status);\n+        return getException(false);\n@@ -987,7 +1000,8 @@\n-        int s;\n-        if (Thread.interrupted())\n-            s = ABNORMAL;\n-        else if ((s = status) >= 0)\n-            s = awaitDone((s & POOLSUBMIT) | INTERRUPTIBLE, 0L);\n-        if ((s & ABNORMAL) != 0)\n-            reportExecutionException(s);\n+        int stat = status;\n+        int s = ((stat < 0) ? stat :\n+                 (Thread.interrupted()) ? ABNORMAL :\n+                 awaitDone(true, 0L));\n+        if (s == ABNORMAL)\n+            throw new InterruptedException();\n+        else if ((s & ABNORMAL) != 0)\n+            reportException(true);\n@@ -1014,8 +1028,11 @@\n-        int s;\n-        if (Thread.interrupted())\n-            s = ABNORMAL;\n-        else if ((s = status) >= 0 && nanos > 0L)\n-            s = awaitDone((s & POOLSUBMIT) | INTERRUPTIBLE | TIMED,\n-                          nanos + System.nanoTime());\n-        if (s >= 0 || (s & ABNORMAL) != 0)\n-            reportExecutionException(s);\n+        int stat = status;\n+        int s = ((stat < 0) ? stat :\n+                 (Thread.interrupted()) ? ABNORMAL :\n+                 (nanos <= 0L) ? 0 :\n+                 awaitDone(true,  (System.nanoTime() + nanos) | 1L));\n+        if (s == ABNORMAL)\n+            throw new InterruptedException();\n+        else if (s >= 0)\n+            throw new TimeoutException();\n+        else if ((s & ABNORMAL) != 0)\n+            reportException(true);\n@@ -1032,3 +1049,2 @@\n-        int s;\n-        if ((s = status) >= 0)\n-            awaitDone(s & POOLSUBMIT, 0L);\n+        if (status >= 0)\n+            awaitDone(false, 0L);\n@@ -1043,3 +1059,3 @@\n-        int s;\n-        if ((s = doExec()) >= 0)\n-            awaitDone(RAN, 0L);\n+        doExec();\n+        if (status >= 0)\n+            awaitDone(false, 0L);\n@@ -1062,1 +1078,0 @@\n-        int s;\n@@ -1064,5 +1079,5 @@\n-        if (Thread.interrupted())\n-            s = ABNORMAL;\n-        else if ((s = status) >= 0 && nanos > 0L)\n-            s = awaitDone((s & POOLSUBMIT) | INTERRUPTIBLE | TIMED,\n-                          nanos + System.nanoTime());\n+        int stat = status;\n+        int s = ((stat < 0) ? stat :\n+                 (Thread.interrupted()) ? ABNORMAL :\n+                 (nanos <= 0L) ? 0 :\n+                 awaitDone(true, (System.nanoTime() + nanos) | 1L));\n@@ -1071,2 +1086,1 @@\n-        else\n-            return (s < 0);\n+        return (s < 0);\n@@ -1089,1 +1103,1 @@\n-            s = awaitDone((s & POOLSUBMIT) | TIMED, nanos + System.nanoTime());\n+            s = awaitDone(false, (System.nanoTime() + nanos) | 1L);\n@@ -1093,0 +1107,18 @@\n+    \/**\n+     * Utility for possibly-timed ForkJoinPool.invokeAll\n+     *\/\n+    final void quietlyJoinPoolInvokeAllTask(long deadline)\n+        throws InterruptedException {\n+        int s;\n+        if ((s = status) >= 0) {\n+            if (Thread.interrupted())\n+                s = ABNORMAL;\n+            else if (deadline == 0L || deadline - System.nanoTime() > 0L)\n+                s = awaitDone(true, deadline);\n+            if (s == ABNORMAL)\n+                throw new InterruptedException();\n+            else if (s >= 0)\n+                cancel(true);\n+        }\n+    }\n+\n@@ -1163,2 +1195,3 @@\n-        Thread t; ForkJoinPool.WorkQueue q; boolean owned;\n-        if (owned = (t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n+        Thread t; ForkJoinPool.WorkQueue q; boolean internal;\n+        if (internal =\n+            (t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n@@ -1168,1 +1201,1 @@\n-        return (q != null && q.tryUnpush(this, owned));\n+        return (q != null && q.tryUnpush(this, internal));\n@@ -1364,0 +1397,141 @@\n+    \/\/ Factory methods for adaptors below\n+\n+    \/**\n+     * Returns a new {@code ForkJoinTask} that performs the {@code run}\n+     * method of the given {@code Runnable} as its action, and returns\n+     * a null result upon {@link #join}.\n+     *\n+     * @param runnable the runnable action\n+     * @return the task\n+     *\/\n+    public static ForkJoinTask<?> adapt(Runnable runnable) {\n+        return new AdaptedRunnableAction(runnable);\n+    }\n+\n+    \/**\n+     * Returns a new {@code ForkJoinTask} that performs the {@code run}\n+     * method of the given {@code Runnable} as its action, and returns\n+     * the given result upon {@link #join}.\n+     *\n+     * @param runnable the runnable action\n+     * @param result the result upon completion\n+     * @param <T> the type of the result\n+     * @return the task\n+     *\/\n+    public static <T> ForkJoinTask<T> adapt(Runnable runnable, T result) {\n+        return new AdaptedRunnable<T>(runnable, result);\n+    }\n+\n+    \/**\n+     * Returns a new {@code ForkJoinTask} that performs the {@code call}\n+     * method of the given {@code Callable} as its action, and returns\n+     * its result upon {@link #join}, translating any checked exceptions\n+     * encountered into {@code RuntimeException}.\n+     *\n+     * @param callable the callable action\n+     * @param <T> the type of the callable's result\n+     * @return the task\n+     *\/\n+    public static <T> ForkJoinTask<T> adapt(Callable<? extends T> callable) {\n+        return new AdaptedCallable<T>(callable);\n+    }\n+\n+    \/**\n+     * Returns a new {@code ForkJoinTask} that performs the {@code call}\n+     * method of the given {@code Callable} as its action, and returns\n+     * its result upon {@link #join}, translating any checked exceptions\n+     * encountered into {@code RuntimeException}.  Additionally,\n+     * invocations of {@code cancel} with {@code mayInterruptIfRunning\n+     * true} will attempt to interrupt the thread performing the task.\n+     *\n+     * @param callable the callable action\n+     * @param <T> the type of the callable's result\n+     * @return the task\n+     *\n+     * @since 19\n+     *\/\n+    public static <T> ForkJoinTask<T> adaptInterruptible(Callable<? extends T> callable) {\n+        return new AdaptedInterruptibleCallable<T>(callable);\n+    }\n+\n+    \/**\n+     * Returns a new {@code ForkJoinTask} that performs the {@code run}\n+     * method of the given {@code Runnable} as its action, and returns\n+     * the given result upon {@link #join}, translating any checked exceptions\n+     * encountered into {@code RuntimeException}.  Additionally,\n+     * invocations of {@code cancel} with {@code mayInterruptIfRunning\n+     * true} will attempt to interrupt the thread performing the task.\n+     *\n+     * @param runnable the runnable action\n+     * @param result the result upon completion\n+     * @param <T> the type of the result\n+     * @return the task\n+     *\n+     * @since 22\n+     *\/\n+    public static <T> ForkJoinTask<T> adaptInterruptible(Runnable runnable, T result) {\n+        return new AdaptedInterruptibleRunnable<T>(runnable, result);\n+    }\n+\n+    \/**\n+     * Returns a new {@code ForkJoinTask} that performs the {@code\n+     * run} method of the given {@code Runnable} as its action, and\n+     * returns null upon {@link #join}, translating any checked\n+     * exceptions encountered into {@code RuntimeException}.\n+     * Additionally, invocations of {@code cancel} with {@code\n+     * mayInterruptIfRunning true} will attempt to interrupt the\n+     * thread performing the task.\n+     *\n+     * @param runnable the runnable action\n+     * @return the task\n+     *\n+     * @since 22\n+     *\/\n+    public static ForkJoinTask<?> adaptInterruptible(Runnable runnable) {\n+        return new AdaptedInterruptibleRunnable<Void>(runnable, null);\n+    }\n+\n+    \/\/ Serialization support\n+\n+    private static final long serialVersionUID = -7721805057305804111L;\n+\n+    \/**\n+     * Saves this task to a stream (that is, serializes it).\n+     *\n+     * @param s the stream\n+     * @throws java.io.IOException if an I\/O error occurs\n+     * @serialData the current run status and the exception thrown\n+     * during execution, or {@code null} if none\n+     *\/\n+    private void writeObject(java.io.ObjectOutputStream s)\n+        throws java.io.IOException {\n+        Aux a;\n+        s.defaultWriteObject();\n+        s.writeObject((a = aux) == null ? null : a.ex);\n+    }\n+\n+    \/**\n+     * Reconstitutes this task from a stream (that is, deserializes it).\n+     * @param s the stream\n+     * @throws ClassNotFoundException if the class of a serialized object\n+     *         could not be found\n+     * @throws java.io.IOException if an I\/O error occurs\n+     *\/\n+    private void readObject(java.io.ObjectInputStream s)\n+        throws java.io.IOException, ClassNotFoundException {\n+        s.defaultReadObject();\n+        Object ex = s.readObject();\n+        if (ex != null)\n+            aux = new Aux(Thread.currentThread(), (Throwable)ex);\n+    }\n+\n+    static {\n+        U = Unsafe.getUnsafe();\n+        STATUS = U.objectFieldOffset(ForkJoinTask.class, \"status\");\n+        AUX = U.objectFieldOffset(ForkJoinTask.class, \"aux\");\n+        Class<?> dep1 = LockSupport.class; \/\/ ensure loaded\n+        Class<?> dep2 = Aux.class;\n+    }\n+\n+    \/\/ Special subclasses for adaptors and internal tasks\n+\n@@ -1376,1 +1550,1 @@\n-            if (runnable == null) throw new NullPointerException();\n+            Objects.requireNonNull(runnable);\n@@ -1398,1 +1572,1 @@\n-            if (runnable == null) throw new NullPointerException();\n+            Objects.requireNonNull(runnable);\n@@ -1411,28 +1585,0 @@\n-    \/**\n-     * Adapter for Runnables in which failure forces worker exception.\n-     *\/\n-    static final class RunnableExecuteAction extends ForkJoinTask<Void> {\n-        @SuppressWarnings(\"serial\") \/\/ Conditionally serializable\n-        final Runnable runnable;\n-        RunnableExecuteAction(Runnable runnable) {\n-            if (runnable == null) throw new NullPointerException();\n-            this.runnable = runnable;\n-        }\n-        public final Void getRawResult() { return null; }\n-        public final void setRawResult(Void v) { }\n-        public final boolean exec() { runnable.run(); return true; }\n-        int trySetException(Throwable ex) { \/\/ if a handler, invoke it\n-            int s; Thread t; java.lang.Thread.UncaughtExceptionHandler h;\n-            if (isExceptionalStatus(s = trySetThrown(ex)) &&\n-                (h = ((t = Thread.currentThread()).\n-                      getUncaughtExceptionHandler())) != null) {\n-                try {\n-                    h.uncaughtException(t, ex);\n-                } catch (Throwable ignore) {\n-                }\n-            }\n-            return s;\n-        }\n-        private static final long serialVersionUID = 5232453952276885070L;\n-    }\n-\n@@ -1449,1 +1595,1 @@\n-            if (callable == null) throw new NullPointerException();\n+            Objects.requireNonNull(callable);\n@@ -1471,1 +1617,11 @@\n-    static final class AdaptedInterruptibleCallable<T> extends ForkJoinTask<T>\n+    \/**\n+     * Tasks with semantics conforming to ExecutorService conventions.\n+     * Tasks are interruptible when cancelled, including cases of\n+     * cancellation upon pool termination. In addition to recording\n+     * the running thread to enable interrupt in cancel(true), the\n+     * task checks for termination before executing the compute\n+     * method, to cover shutdown races in which the task has not yet\n+     * been cancelled on entry and might not otherwise be cancelled by\n+     * others.\n+     *\/\n+    static abstract class InterruptibleTask<T> extends ForkJoinTask<T>\n@@ -1473,2 +1629,0 @@\n-        @SuppressWarnings(\"serial\") \/\/ Conditionally serializable\n-        final Callable<? extends T> callable;\n@@ -1476,8 +1630,1 @@\n-        @SuppressWarnings(\"serial\") \/\/ Conditionally serializable\n-        T result;\n-        AdaptedInterruptibleCallable(Callable<? extends T> callable) {\n-            if (callable == null) throw new NullPointerException();\n-            this.callable = callable;\n-        }\n-        public final T getRawResult() { return result; }\n-        public final void setRawResult(T v) { result = v; }\n+        abstract T compute() throws Exception;\n@@ -1486,1 +1633,1 @@\n-            runner = Thread.currentThread();\n+            Thread t = runner = Thread.currentThread();\n@@ -1488,7 +1635,11 @@\n-                if (!isDone()) \/\/ recheck\n-                    result = callable.call();\n-                return true;\n-            } catch (RuntimeException rex) {\n-                throw rex;\n-            } catch (Exception ex) {\n-                throw new RuntimeException(ex);\n+                if ((t instanceof ForkJoinWorkerThread) &&\n+                    ForkJoinPool.poolIsStopping(((ForkJoinWorkerThread)t).pool))\n+                    cancel(true);\n+                else {\n+                    try {\n+                        if (status >= 0)\n+                            setRawResult(compute());\n+                    } catch (Exception ex) {\n+                        trySetException(ex);\n+                    }\n+                }\n@@ -1497,1 +1648,0 @@\n-                Thread.interrupted();\n@@ -1499,0 +1649,1 @@\n+            return true;\n@@ -1500,2 +1651,1 @@\n-        public final void run() { invoke(); }\n-        public final boolean cancel(boolean mayInterruptIfRunning) {\n+        public boolean cancel(boolean mayInterruptIfRunning) {\n@@ -1503,5 +1653,6 @@\n-            boolean stat = super.cancel(false);\n-            if (mayInterruptIfRunning && (t = runner) != null) {\n-                try {\n-                    t.interrupt();\n-                } catch (Throwable ignore) {\n+            if (trySetCancelled() >= 0) {\n+                if (mayInterruptIfRunning && (t = runner) != null) {\n+                    try {\n+                        t.interrupt();\n+                    } catch (Throwable ignore) {\n+                    }\n@@ -1509,0 +1660,1 @@\n+                return true;\n@@ -1510,1 +1662,1 @@\n-            return stat;\n+            return isCancelled();\n@@ -1512,0 +1664,2 @@\n+        public final void run() { quietlyInvoke(); }\n+        Object adaptee() { return null; } \/\/ for printing and diagnostics\n@@ -1513,1 +1667,4 @@\n-            return super.toString() + \"[Wrapped task = \" + callable + \"]\";\n+            Object a = adaptee();\n+            String s = super.toString();\n+            return ((a == null) ? s :\n+                    (s + \"[Wrapped task = \" + a.toString() + \"]\"));\n@@ -1519,6 +1676,1 @@\n-     * Returns a new {@code ForkJoinTask} that performs the {@code run}\n-     * method of the given {@code Runnable} as its action, and returns\n-     * a null result upon {@link #join}.\n-     *\n-     * @param runnable the runnable action\n-     * @return the task\n+     * Adapter for Callable-based interruptible tasks.\n@@ -1526,2 +1678,14 @@\n-    public static ForkJoinTask<?> adapt(Runnable runnable) {\n-        return new AdaptedRunnableAction(runnable);\n+    static final class AdaptedInterruptibleCallable<T> extends InterruptibleTask<T> {\n+        @SuppressWarnings(\"serial\") \/\/ Conditionally serializable\n+        final Callable<? extends T> callable;\n+        @SuppressWarnings(\"serial\") \/\/ Conditionally serializable\n+        T result;\n+        AdaptedInterruptibleCallable(Callable<? extends T> callable) {\n+            Objects.requireNonNull(callable);\n+            this.callable = callable;\n+        }\n+        public final T getRawResult() { return result; }\n+        public final void setRawResult(T v) { result = v; }\n+        final T compute() throws Exception { return callable.call(); }\n+        final Object adaptee() { return callable; }\n+        private static final long serialVersionUID = 2838392045355241008L;\n@@ -1531,8 +1695,1 @@\n-     * Returns a new {@code ForkJoinTask} that performs the {@code run}\n-     * method of the given {@code Runnable} as its action, and returns\n-     * the given result upon {@link #join}.\n-     *\n-     * @param runnable the runnable action\n-     * @param result the result upon completion\n-     * @param <T> the type of the result\n-     * @return the task\n+     * Adapter for Runnable-based interruptible tasks.\n@@ -1540,2 +1697,15 @@\n-    public static <T> ForkJoinTask<T> adapt(Runnable runnable, T result) {\n-        return new AdaptedRunnable<T>(runnable, result);\n+    static final class AdaptedInterruptibleRunnable<T> extends InterruptibleTask<T> {\n+        @SuppressWarnings(\"serial\") \/\/ Conditionally serializable\n+        final Runnable runnable;\n+        @SuppressWarnings(\"serial\") \/\/ Conditionally serializable\n+        final T result;\n+        AdaptedInterruptibleRunnable(Runnable runnable, T result) {\n+            Objects.requireNonNull(runnable);\n+            this.runnable = runnable;\n+            this.result = result;\n+        }\n+        public final T getRawResult() { return result; }\n+        public final void setRawResult(T v) { }\n+        final T compute() { runnable.run(); return result; }\n+        final Object adaptee() { return runnable; }\n+        private static final long serialVersionUID = 2838392045355241008L;\n@@ -1545,8 +1715,1 @@\n-     * Returns a new {@code ForkJoinTask} that performs the {@code call}\n-     * method of the given {@code Callable} as its action, and returns\n-     * its result upon {@link #join}, translating any checked exceptions\n-     * encountered into {@code RuntimeException}.\n-     *\n-     * @param callable the callable action\n-     * @param <T> the type of the callable's result\n-     * @return the task\n+     * Adapter for Runnables in which failure forces worker exception.\n@@ -1554,2 +1717,22 @@\n-    public static <T> ForkJoinTask<T> adapt(Callable<? extends T> callable) {\n-        return new AdaptedCallable<T>(callable);\n+    static final class RunnableExecuteAction extends InterruptibleTask<Void> {\n+        @SuppressWarnings(\"serial\") \/\/ Conditionally serializable\n+        final Runnable runnable;\n+        RunnableExecuteAction(Runnable runnable) {\n+            Objects.requireNonNull(runnable);\n+            this.runnable = runnable;\n+        }\n+        public final Void getRawResult() { return null; }\n+        public final void setRawResult(Void v) { }\n+        final Void compute() { runnable.run(); return null; }\n+        final Object adaptee() { return runnable; }\n+        void onAuxExceptionSet(Throwable ex) { \/\/ if a handler, invoke it\n+            Thread t; java.lang.Thread.UncaughtExceptionHandler h;\n+            if ((h = ((t = Thread.currentThread()).\n+                      getUncaughtExceptionHandler())) != null) {\n+                try {\n+                    h.uncaughtException(t, ex);\n+                } catch (Throwable ignore) {\n+                }\n+            }\n+        }\n+        private static final long serialVersionUID = 5232453952276885070L;\n@@ -1559,21 +1742,54 @@\n-     * Returns a new {@code ForkJoinTask} that performs the {@code call}\n-     * method of the given {@code Callable} as its action, and returns\n-     * its result upon {@link #join}, translating any checked exceptions\n-     * encountered into {@code RuntimeException}.  Additionally,\n-     * invocations of {@code cancel} with {@code mayInterruptIfRunning\n-     * true} will attempt to interrupt the thread performing the task.\n-     *\n-     * @param callable the callable action\n-     * @param <T> the type of the callable's result\n-     * @return the task\n-     *\n-     * @since 19\n-     *\/\n-    public static <T> ForkJoinTask<T> adaptInterruptible(Callable<? extends T> callable) {\n-        \/\/ https:\/\/bugs.openjdk.org\/browse\/JDK-8246587\n-        return new AdaptedInterruptibleCallable<T>(callable);\n-    }\n-\n-    \/\/ Serialization support\n-\n-    private static final long serialVersionUID = -7721805057305804111L;\n+     * Task (that is never forked) to hold results for\n+     * ForkJoinPool.invokeAny, or to report exception if all subtasks\n+     * fail or are cancelled or the pool is terminating. Both\n+     * InvokeAnyRoot and InvokeAnyTask objects exist only transiently\n+     * during invokeAny invocations, so serialization support would be\n+     * nonsensical and is omitted.\n+     *\/\n+    @SuppressWarnings(\"serial\")\n+    static final class InvokeAnyRoot<T> extends InterruptibleTask<T> {\n+        volatile T result;\n+        volatile int count; \/\/ number of tasks; decremented in case all tasks fail\n+        InvokeAnyRoot() { }\n+        final void tryComplete(InvokeAnyTask<T> f, T v, Throwable ex,\n+                               boolean completed) {\n+            if (f != null && !isDone()) {\n+                if (ForkJoinPool.poolIsStopping(getPool()))\n+                    trySetCancelled();\n+                else if (f.setForkJoinTaskStatusMarkerBit() == 0) {\n+                    if (completed) {\n+                        result = v;\n+                        quietlyComplete();\n+                    }\n+                    else if (U.getAndAddInt(this, COUNT, -1) <= 1) {\n+                        if (ex == null)\n+                            trySetCancelled();\n+                        else\n+                            trySetException(ex);\n+                    }\n+                }\n+            }\n+        }\n+        public final T compute()            { return null; } \/\/ never forked\n+        public final T getRawResult()       { return result; }\n+        public final void setRawResult(T v) { }\n+\n+        \/\/ Common support for timed and untimed versions of invokeAny\n+        final T invokeAny(Collection<? extends Callable<T>> tasks,\n+                          ForkJoinPool pool, boolean timed, long nanos)\n+            throws InterruptedException, ExecutionException, TimeoutException {\n+            if ((count = tasks.size()) <= 0)\n+                throw new IllegalArgumentException();\n+            if (pool == null)\n+                throw new NullPointerException();\n+            InvokeAnyTask<T> t = null; \/\/ list of submitted tasks\n+            try {\n+                for (Callable<T> c : tasks)\n+                    pool.execute((ForkJoinTask<?>)\n+                                 (t = new InvokeAnyTask<T>(c, this, t)));\n+                return timed ? get(nanos, TimeUnit.NANOSECONDS) : get();\n+            } finally {\n+                for (; t != null; t = t.pred)\n+                    t.onRootCompletion();\n+            }\n+        }\n@@ -1581,13 +1797,6 @@\n-    \/**\n-     * Saves this task to a stream (that is, serializes it).\n-     *\n-     * @param s the stream\n-     * @throws java.io.IOException if an I\/O error occurs\n-     * @serialData the current run status and the exception thrown\n-     * during execution, or {@code null} if none\n-     *\/\n-    private void writeObject(java.io.ObjectOutputStream s)\n-        throws java.io.IOException {\n-        Aux a;\n-        s.defaultWriteObject();\n-        s.writeObject((a = aux) == null ? null : a.ex);\n+        private static final Unsafe U;\n+        private static final long COUNT;\n+        static {\n+            U = Unsafe.getUnsafe();\n+            COUNT = U.objectFieldOffset(InvokeAnyRoot.class, \"count\");\n+        }\n@@ -1597,5 +1806,2 @@\n-     * Reconstitutes this task from a stream (that is, deserializes it).\n-     * @param s the stream\n-     * @throws ClassNotFoundException if the class of a serialized object\n-     *         could not be found\n-     * @throws java.io.IOException if an I\/O error occurs\n+     * Task with results in InvokeAnyRoot (and never independently\n+     * joined).\n@@ -1603,14 +1809,41 @@\n-    private void readObject(java.io.ObjectInputStream s)\n-        throws java.io.IOException, ClassNotFoundException {\n-        s.defaultReadObject();\n-        Object ex = s.readObject();\n-        if (ex != null)\n-            trySetThrown((Throwable)ex);\n-    }\n-\n-    static {\n-        U = Unsafe.getUnsafe();\n-        STATUS = U.objectFieldOffset(ForkJoinTask.class, \"status\");\n-        AUX = U.objectFieldOffset(ForkJoinTask.class, \"aux\");\n-        Class<?> dep1 = LockSupport.class; \/\/ ensure loaded\n-        Class<?> dep2 = Aux.class;\n+    @SuppressWarnings(\"serial\")\n+    static final class InvokeAnyTask<T> extends InterruptibleTask<Void> {\n+        final Callable<? extends T> callable;\n+        final InvokeAnyRoot<T> root;\n+        final InvokeAnyTask<T> pred; \/\/ to traverse on cancellation\n+        InvokeAnyTask(Callable<T> callable, InvokeAnyRoot<T> root,\n+                      InvokeAnyTask<T> pred) {\n+            Objects.requireNonNull(callable);\n+            this.callable = callable;\n+            this.root = root;\n+            this.pred = pred;\n+        }\n+        final Void compute() throws Exception {\n+            InvokeAnyRoot<T> r = root;\n+            T v = null; Throwable ex = null; boolean completed = false;\n+            if (r != null && !r.isDone()) {\n+                try {\n+                    v = callable.call();\n+                    completed = true;\n+                } catch (Exception rex) {\n+                    ex = rex;\n+                } finally {\n+                    r.tryComplete(this, v, ex, completed);\n+                }\n+            }\n+            return null;\n+        }\n+        public final boolean cancel(boolean mayInterruptIfRunning) {\n+            InvokeAnyRoot<T> r;\n+            boolean stat = super.cancel(mayInterruptIfRunning);\n+            if ((r = root) != null)\n+                r.tryComplete(this, null, null, false);\n+            return stat;\n+        }\n+        final void onRootCompletion() {\n+            if (!isDone())\n+                super.cancel(true); \/\/ no need for tryComplete\n+        }\n+        public final Void getRawResult() { return null; }\n+        public final void setRawResult(Void v) { }\n+        final Object adaptee() { return callable; }\n@@ -1618,1 +1851,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":681,"deletions":449,"binary":false,"changes":1130,"status":"modified"},{"patch":"@@ -79,3 +79,2 @@\n-        this.workQueue = new ForkJoinPool.WorkQueue(this, 0);\n-        if (clearThreadLocals)\n-            workQueue.setClearThreadLocals();\n+        this.workQueue = new ForkJoinPool.WorkQueue(this, 0, (int)pool.config,\n+                                                    clearThreadLocals);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinWorkerThread.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -725,2 +725,0 @@\n-java\/util\/concurrent\/forkjoin\/AsyncShutdownNow.java             8286352 linux-all,windows-x64\n-java\/util\/concurrent\/ExecutorService\/CloseTest.java             8288899 macosx-aarch64\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @summary Test ExecutorService.close, including default implementation\n+ * @summary Test implementations of ExecutorService.close\n@@ -28,1 +28,1 @@\n- * @run testng CloseTest\n+ * @run junit CloseTest\n@@ -40,0 +40,1 @@\n+import java.util.stream.Stream;\n@@ -41,23 +42,16 @@\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public class CloseTest {\n-\n-    @DataProvider(name = \"executors\")\n-    public Object[][] executors() {\n-        var defaultThreadFactory = Executors.defaultThreadFactory();\n-        var virtualThreadFactory = Thread.ofVirtual().factory();\n-        return new Object[][] {\n-            \/\/ ensures that default close method is tested\n-            { new DelegatingExecutorService(Executors.newCachedThreadPool()), },\n-\n-            \/\/ implementations that may override close\n-            { new ForkJoinPool(), },\n-            { Executors.newFixedThreadPool(1), },\n-            { Executors.newCachedThreadPool(), },\n-            { Executors.newThreadPerTaskExecutor(defaultThreadFactory), },\n-            { Executors.newThreadPerTaskExecutor(virtualThreadFactory), },\n-        };\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class CloseTest {\n+\n+    static Stream<ExecutorService> executors() {\n+        return Stream.of(\n+                \/\/ ensures that default close method is tested\n+                new DelegatingExecutorService(Executors.newCachedThreadPool()),\n+\n+                \/\/ implementations that may override close\n+                Executors.newCachedThreadPool(),\n+                Executors.newVirtualThreadPerTaskExecutor(),\n+                new ForkJoinPool()\n+        );\n@@ -69,2 +63,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testCloseWithNoTasks(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testCloseWithNoTasks(ExecutorService executor) throws Exception {\n@@ -80,2 +75,4 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testCloseWithRunningTasks(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testCloseWithRunningTasks(ExecutorService executor) throws Exception {\n+        Phaser phaser = new Phaser(2);\n@@ -83,0 +80,1 @@\n+            phaser.arriveAndAwaitAdvance();\n@@ -86,0 +84,2 @@\n+        phaser.arriveAndAwaitAdvance();   \/\/ wait for task to start\n+\n@@ -87,0 +87,1 @@\n+        assertFalse(Thread.interrupted());\n@@ -90,1 +91,79 @@\n-        assertEquals(future.resultNow(), \"foo\");\n+        assertEquals(\"foo\", future.resultNow());\n+    }\n+\n+    \/**\n+     * Test shutdown with tasks running.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testShutdownWithRunningTasks(ExecutorService executor) throws Exception {\n+        Phaser phaser = new Phaser(2);\n+        Future<?> future = executor.submit(() -> {\n+            phaser.arriveAndAwaitAdvance();\n+            Thread.sleep(Duration.ofMillis(100));\n+            return \"foo\";\n+        });\n+        phaser.arriveAndAwaitAdvance();   \/\/ wait for task to start\n+\n+        executor.shutdown();\n+        assertFalse(Thread.interrupted());\n+        assertTrue(executor.isShutdown());\n+        assertTrue(executor.awaitTermination(1,  TimeUnit.MINUTES));\n+        assertTrue(executor.isTerminated());\n+        assertEquals(\"foo\", future.resultNow());\n+    }\n+\n+    \/**\n+     * Test close with multiple tasks running\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testCloseWith2RunningTasks(ExecutorService executor) throws Exception {\n+        Phaser phaser = new Phaser(3);\n+        Future<?> f1 = executor.submit(() -> {\n+            phaser.arriveAndAwaitAdvance();\n+            Thread.sleep(Duration.ofMillis(100));\n+            return \"foo\";\n+        });\n+        Future<?> f2 = executor.submit(() -> {\n+            phaser.arriveAndAwaitAdvance();\n+            Thread.sleep(Duration.ofMillis(100));\n+            return \"bar\";\n+        });\n+        phaser.arriveAndAwaitAdvance();   \/\/ wait for tasks to start\n+\n+        executor.close();  \/\/ waits for task to complete\n+        assertFalse(Thread.interrupted());\n+        assertTrue(executor.isShutdown());\n+        assertTrue(executor.isTerminated());\n+        assertTrue(executor.awaitTermination(10,  TimeUnit.MILLISECONDS));\n+        assertEquals(\"foo\", f1.resultNow());\n+        assertEquals(\"bar\", f2.resultNow());\n+    }\n+\n+    \/**\n+     * Test shutdown with multiple tasks running\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testShutdownWith2RunningTasks(ExecutorService executor) throws Exception {\n+        Phaser phaser = new Phaser(3);\n+        Future<?> f1 = executor.submit(() -> {\n+            phaser.arriveAndAwaitAdvance();\n+            Thread.sleep(Duration.ofMillis(100));\n+            return \"foo\";\n+        });\n+        Future<?> f2 = executor.submit(() -> {\n+            phaser.arriveAndAwaitAdvance();\n+            Thread.sleep(Duration.ofMillis(100));\n+            return \"bar\";\n+        });\n+        phaser.arriveAndAwaitAdvance();   \/\/ wait for tasks to start\n+\n+        executor.shutdown();\n+        assertFalse(Thread.interrupted());\n+        assertTrue(executor.isShutdown());\n+        assertTrue(executor.awaitTermination(1,  TimeUnit.MINUTES));\n+        assertTrue(executor.isTerminated());\n+        assertEquals(\"foo\", f1.resultNow());\n+        assertEquals(\"bar\", f2.resultNow());\n@@ -96,2 +175,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testShutdownBeforeClose(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testShutdownBeforeClose(ExecutorService executor) throws Exception {\n@@ -107,1 +187,0 @@\n-\n@@ -112,1 +191,2 @@\n-        assertEquals(future.resultNow(), \"foo\");\n+        Object s = future.resultNow();\n+        assertEquals(\"foo\", s);\n@@ -118,2 +198,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testTerminateBeforeClose(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testTerminateBeforeClose(ExecutorService executor) throws Exception {\n@@ -122,1 +203,0 @@\n-\n@@ -132,2 +212,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInterruptBeforeClose(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInterruptBeforeClose(ExecutorService executor) throws Exception {\n@@ -152,1 +233,1 @@\n-        expectThrows(ExecutionException.class, future::get);\n+        assertThrows(ExecutionException.class, future::get);\n@@ -158,2 +239,4 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInterruptDuringClose(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInterruptDuringClose(ExecutorService executor) throws Exception {\n+        Phaser phaser = new Phaser(2);\n@@ -161,0 +244,1 @@\n+            phaser.arriveAndAwaitAdvance();\n@@ -164,0 +248,3 @@\n+        phaser.arriveAndAwaitAdvance();  \/\/ wait for task to start\n+\n+        \/\/ schedule main thread to be interrupted\n@@ -166,1 +253,3 @@\n-            try { Thread.sleep( Duration.ofMillis(500)); } catch (Exception ignore) { }\n+            try {\n+                Thread.sleep( Duration.ofMillis(100));\n+            } catch (Exception ignore) { }\n@@ -178,1 +267,1 @@\n-        expectThrows(ExecutionException.class, future::get);\n+        assertThrows(ExecutionException.class, future::get);\n","filename":"test\/jdk\/java\/util\/concurrent\/ExecutorService\/CloseTest.java","additions":133,"deletions":44,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -0,0 +1,787 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test implementations of ExecutorService.invokeAll\/invokeAny\n+ * @run junit InvokeTest\n+ *\/\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.*;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+import static java.lang.Thread.State.*;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class InvokeTest {\n+\n+    private static ScheduledExecutorService scheduler;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        scheduler = Executors.newSingleThreadScheduledExecutor();\n+    }\n+\n+    @AfterAll\n+    static void shutdown() {\n+        scheduler.shutdown();\n+    }\n+\n+    private static Stream<ExecutorService> executors() {\n+        return Stream.of(\n+                Executors.newCachedThreadPool(),\n+                Executors.newVirtualThreadPerTaskExecutor(),\n+                new ForkJoinPool()\n+        );\n+    }\n+\n+    \/**\n+     * Test invokeAny where all tasks complete normally.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAny1(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+            Callable<String> task2 = () -> \"bar\";\n+            String result = executor.invokeAny(List.of(task1, task2));\n+            assertTrue(Set.of(\"foo\", \"bar\").contains(result));\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAny where all tasks complete normally. The completion of the\n+     * first task should cancel remaining tasks.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAny2(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+\n+            var task2Started = new AtomicBoolean();\n+            var task2Interrupted = new CountDownLatch(1);\n+            Callable<String> task2 = () -> {\n+                task2Started.set(true);\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    task2Interrupted.countDown();\n+                }\n+                return null;\n+            };\n+\n+            String result = executor.invokeAny(List.of(task1, task2));\n+            assertEquals(\"foo\", result);\n+\n+            \/\/ if task2 started then it should have been interrupted\n+            if (task2Started.get()) {\n+                task2Interrupted.await();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAny where all tasks complete with exception.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAny3(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            class FooException extends Exception { }\n+            Callable<String> task1 = () -> { throw new FooException(); };\n+            Callable<String> task2 = () -> { throw new FooException(); };\n+            try {\n+                executor.invokeAny(List.of(task1, task2));\n+                fail(\"invokeAny did not throw\");\n+            } catch (ExecutionException e) {\n+                Throwable cause = e.getCause();\n+                assertTrue(cause instanceof FooException);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAny where all tasks complete with exception. The completion\n+     * of the last task is delayed.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAny4(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            class FooException extends Exception { }\n+            Callable<String> task1 = () -> { throw new FooException(); };\n+            Callable<String> task2 = () -> {\n+                Thread.sleep(Duration.ofMillis(50));\n+                throw new FooException();\n+            };\n+            try {\n+                executor.invokeAny(List.of(task1, task2));\n+                fail(\"invokeAny did not throw\");\n+            } catch (ExecutionException e) {\n+                Throwable cause = e.getCause();\n+                assertTrue(cause instanceof FooException);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAny where some, not all, tasks complete normally.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAny5(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            class FooException extends Exception { }\n+            Callable<String> task1 = () -> \"foo\";\n+            Callable<String> task2 = () -> { throw new FooException(); };\n+            String result = executor.invokeAny(List.of(task1, task2));\n+            assertEquals(\"foo\", result);\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAny where some, not all, tasks complete normally. The first\n+     * task to complete normally is delayed.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAny6(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            class FooException extends Exception { }\n+            Callable<String> task1 = () -> {\n+                Thread.sleep(Duration.ofMillis(50));\n+                return \"foo\";\n+            };\n+            Callable<String> task2 = () -> { throw new FooException(); };\n+            String result = executor.invokeAny(List.of(task1, task2));\n+            assertEquals(\"foo\", result);\n+        }\n+    }\n+\n+    \/**\n+     * Test timed-invokeAny where all tasks complete normally before the timeout.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyWithTimeout1(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+            Callable<String> task2 = () -> \"bar\";\n+            String result = executor.invokeAny(List.of(task1, task2), 1, TimeUnit.MINUTES);\n+            assertTrue(Set.of(\"foo\", \"bar\").contains(result));\n+        }\n+    }\n+\n+    \/**\n+     * Test timed-invokeAny where one task completes normally before the timeout.\n+     * The remaining tests should be cancelled.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyWithTimeout2(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+\n+            var task2Started = new AtomicBoolean();\n+            var task2Interrupted = new CountDownLatch(1);\n+            Callable<String> task2 = () -> {\n+                task2Started.set(true);\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    task2Interrupted.countDown();\n+                }\n+                return null;\n+            };\n+\n+            String result = executor.invokeAny(List.of(task1, task2), 1, TimeUnit.MINUTES);\n+            assertEquals(\"foo\", result);\n+\n+            \/\/ if task2 started then it should have been interrupted\n+            if (task2Started.get()) {\n+                task2Interrupted.await();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test timed-invokeAny where timeout expires before any task completes.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyWithTimeout3(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var task1Started = new AtomicBoolean();\n+            var task1Interrupted = new CountDownLatch(1);\n+            Callable<String> task1 = () -> {\n+                task1Started.set(true);\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    task1Interrupted.countDown();\n+                }\n+                return null;\n+            };\n+\n+            var task2Started = new AtomicBoolean();\n+            var task2Interrupted = new CountDownLatch(1);\n+            Callable<String> task2 = () -> {\n+                task2Started.set(true);\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    task2Interrupted.countDown();\n+                }\n+                return null;\n+            };\n+\n+            \/\/ invokeAny should throw TimeoutException\n+            assertThrows(TimeoutException.class,\n+                    () -> executor.invokeAny(List.of(task1, task2), 100, TimeUnit.MILLISECONDS));\n+\n+            \/\/ tasks that started should be interrupted\n+            if (task1Started.get()) {\n+                task1Interrupted.await();\n+            }\n+            if (task2Started.get()) {\n+                task2Interrupted.await();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAny with interrupt status set.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyWithInterruptSet(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> {\n+                Thread.sleep(Duration.ofMinutes(1));\n+                return \"foo\";\n+            };\n+            Callable<String> task2 = () -> {\n+                Thread.sleep(Duration.ofMinutes(1));\n+                return \"bar\";\n+            };\n+            Thread.currentThread().interrupt();\n+            try {\n+                executor.invokeAny(List.of(task1, task2));\n+                fail(\"invokeAny did not throw\");\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.currentThread().isInterrupted());\n+            } finally {\n+                Thread.interrupted(); \/\/ clear interrupt\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test interrupting a thread blocked in invokeAny.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInterruptInvokeAny(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var task1Started = new AtomicBoolean();\n+            var task1Interrupted = new CountDownLatch(1);\n+            Callable<String> task1 = () -> {\n+                task1Started.set(true);\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    task1Interrupted.countDown();\n+                }\n+                return null;\n+            };\n+\n+            var task2Started = new AtomicBoolean();\n+            var task2Interrupted = new CountDownLatch(1);\n+            Callable<String> task2 = () -> {\n+                task2Started.set(true);\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    task2Interrupted.countDown();\n+                }\n+                return null;\n+            };\n+\n+            scheduleInterruptAt(\"invokeAny\");\n+            try {\n+                executor.invokeAny(List.of(task1, task2));\n+                fail(\"invokeAny did not throw\");\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.currentThread().isInterrupted());\n+            } finally {\n+                Thread.interrupted(); \/\/ clear interrupt\n+            }\n+\n+            \/\/ tasks that started should be interrupted\n+            if (task1Started.get()) {\n+                task1Interrupted.await();\n+            }\n+            if (task2Started.get()) {\n+                task2Interrupted.await();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAny after ExecutorService has been shutdown.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyAfterShutdown(ExecutorService executor) throws Exception {\n+        executor.shutdown();\n+        Callable<String> task1 = () -> \"foo\";\n+        Callable<String> task2 = () -> \"bar\";\n+        assertThrows(RejectedExecutionException.class,\n+                () -> executor.invokeAny(List.of(task1, task2)));\n+    }\n+\n+    \/**\n+     * Test invokeAny with empty collection.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyEmpty1(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            assertThrows(IllegalArgumentException.class, () -> executor.invokeAny(List.of()));\n+        }\n+    }\n+\n+    \/**\n+     * Test timed-invokeAny with empty collection.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyEmpty2(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> executor.invokeAny(List.of(), 1, TimeUnit.MINUTES));\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAny with null.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyNull1(ExecutorService executor)throws Exception {\n+        try (executor) {\n+            assertThrows(NullPointerException.class, () -> executor.invokeAny(null));\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAny with null element\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyNull2(ExecutorService executor)throws Exception {\n+        try (executor) {\n+            List<Callable<String>> list = new ArrayList<>();\n+            list.add(() -> \"foo\");\n+            list.add(null);\n+            assertThrows(NullPointerException.class, () -> executor.invokeAny(null));\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAll where all tasks complete normally.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAll1(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+            Callable<String> task2 = () -> {\n+                Thread.sleep(Duration.ofMillis(50));\n+                return \"bar\";\n+            };\n+\n+            List<Future<String>> futures = executor.invokeAll(List.of(task1, task2));\n+            assertTrue(futures.size() == 2);\n+\n+            \/\/ check results\n+            List<String> results = futures.stream().map(Future::resultNow).toList();\n+            assertEquals(results, List.of(\"foo\", \"bar\"));\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAll where all tasks complete with exception.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAll2(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            class FooException extends Exception { }\n+            class BarException extends Exception { }\n+            Callable<String> task1 = () -> { throw new FooException(); };\n+            Callable<String> task2 = () -> {\n+                Thread.sleep(Duration.ofMillis(50));\n+                throw new BarException();\n+            };\n+\n+            List<Future<String>> futures = executor.invokeAll(List.of(task1, task2));\n+            assertTrue(futures.size() == 2);\n+\n+            \/\/ check results\n+            Throwable e1 = assertThrows(ExecutionException.class, () -> futures.get(0).get());\n+            assertTrue(e1.getCause() instanceof FooException);\n+            Throwable e2 = assertThrows(ExecutionException.class, () -> futures.get(1).get());\n+            assertTrue(e2.getCause() instanceof BarException);\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAll where all tasks complete normally before the timeout expires.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAll3(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+            Callable<String> task2 = () -> {\n+                Thread.sleep(Duration.ofMillis(50));\n+                return \"bar\";\n+            };\n+\n+            List<Future<String>> futures = executor.invokeAll(List.of(task1, task2), 1, TimeUnit.MINUTES);\n+            assertTrue(futures.size() == 2);\n+\n+            \/\/ check results\n+            List<String> results = futures.stream().map(Future::resultNow).toList();\n+            assertEquals(results, List.of(\"foo\", \"bar\"));\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAll where some tasks do not complete before the timeout expires.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAll4(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+\n+            var task2Started = new AtomicBoolean();\n+            var task2Interrupted = new CountDownLatch(1);\n+            Callable<String> task2 = () -> {\n+                task2Started.set(true);\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    task2Interrupted.countDown();\n+                }\n+                return null;\n+            };\n+\n+            List<Future<String>> futures = executor.invokeAll(List.of(task1, task2), 1, TimeUnit.SECONDS);\n+            assertTrue(futures.size() == 2);\n+\n+            \/\/ task1 should be done\n+            assertTrue(futures.get(0).isDone());\n+\n+            \/\/ task2 should be cancelled and interrupted\n+            assertTrue(futures.get(1).isCancelled());\n+\n+            \/\/ if task2 started then it should have been interrupted\n+            if (task2Started.get()) {\n+                task2Interrupted.await();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAll with interrupt status set.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllInterrupt1(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+            Callable<String> task2 = () -> {\n+                Thread.sleep(Duration.ofMinutes(1));\n+                return \"bar\";\n+            };\n+\n+            Thread.currentThread().interrupt();\n+            try {\n+                executor.invokeAll(List.of(task1, task2));\n+                fail(\"invokeAll did not throw\");\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.currentThread().isInterrupted());\n+            } finally {\n+                Thread.interrupted(); \/\/ clear interrupt\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test timed-invokeAll with interrupt status set.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllInterrupt3(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+            Callable<String> task2 = () -> {\n+                Thread.sleep(Duration.ofMinutes(1));\n+                return \"bar\";\n+            };\n+\n+            Thread.currentThread().interrupt();\n+            try {\n+                executor.invokeAll(List.of(task1, task2), 1, TimeUnit.MINUTES);\n+                fail(\"invokeAll did not throw\");\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.currentThread().isInterrupted());\n+            } finally {\n+                Thread.interrupted(); \/\/ clear interrupt\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test interrupt with thread blocked in invokeAll.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllInterrupt4(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+\n+            var task2Started = new AtomicBoolean();\n+            var task2Interrupted = new CountDownLatch(1);\n+            Callable<String> task2 = () -> {\n+                task2Started.set(true);\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    task2Interrupted.countDown();\n+                }\n+                return null;\n+            };\n+\n+            scheduleInterruptAt(\"invokeAll\");\n+            try {\n+                executor.invokeAll(List.of(task1, task2));\n+                fail(\"invokeAll did not throw\");\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.currentThread().isInterrupted());\n+            } finally {\n+                Thread.interrupted(); \/\/ clear interrupt\n+            }\n+\n+            \/\/ if task2 started then it should have been interrupted\n+            if (task2Started.get()) {\n+                task2Interrupted.await();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test interrupt with thread blocked in timed-invokeAll.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllInterrupt6(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+\n+            var task2Started = new AtomicBoolean();\n+            var task2Interrupted = new CountDownLatch(1);\n+            Callable<String> task2 = () -> {\n+                task2Started.set(true);\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    task2Interrupted.countDown();\n+                }\n+                return null;\n+            };\n+\n+            scheduleInterruptAt(\"invokeAll\");\n+            try {\n+                executor.invokeAll(List.of(task1, task2), 1, TimeUnit.MINUTES);\n+                fail(\"invokeAll did not throw\");\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.currentThread().isInterrupted());\n+            } finally {\n+                Thread.interrupted(); \/\/ clear interrupt\n+            }\n+\n+            \/\/ if task2 started then it should have been interrupted\n+            if (task2Started.get()) {\n+                task2Interrupted.await();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAll after ExecutorService has been shutdown.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllAfterShutdown1(ExecutorService executor) throws Exception {\n+        executor.shutdown();\n+\n+        Callable<String> task1 = () -> \"foo\";\n+        Callable<String> task2 = () -> \"bar\";\n+        assertThrows(RejectedExecutionException.class,\n+                () -> executor.invokeAll(List.of(task1, task2)));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllAfterShutdown2(ExecutorService executor) throws Exception {\n+        executor.shutdown();\n+\n+        Callable<String> task1 = () -> \"foo\";\n+        Callable<String> task2 = () -> \"bar\";\n+        assertThrows(RejectedExecutionException.class,\n+                () -> executor.invokeAll(List.of(task1, task2), 1, TimeUnit.SECONDS));\n+    }\n+\n+    \/**\n+     * Test invokeAll with empty collection.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllEmpty1(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            List<Future<Object>> list = executor.invokeAll(List.of());\n+            assertTrue(list.size() == 0);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllEmpty2(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            List<Future<Object>> list = executor.invokeAll(List.of(), 1, TimeUnit.SECONDS);\n+            assertTrue(list.size() == 0);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllNull1(ExecutorService executor)throws Exception {\n+        try (executor) {\n+            assertThrows(NullPointerException.class, () -> executor.invokeAll(null));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllNull2(ExecutorService executor)throws Exception {\n+        try (executor) {\n+            List<Callable<String>> tasks = new ArrayList<>();\n+            tasks.add(() -> \"foo\");\n+            tasks.add(null);\n+            assertThrows(NullPointerException.class, () -> executor.invokeAll(tasks));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllNull3(ExecutorService executor)throws Exception {\n+        try (executor) {\n+            assertThrows(NullPointerException.class,\n+                    () -> executor.invokeAll(null, 1, TimeUnit.SECONDS));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllNull4(ExecutorService executor)throws Exception {\n+        try (executor) {\n+            Callable<String> task = () -> \"foo\";\n+            assertThrows(NullPointerException.class,\n+                    () -> executor.invokeAll(List.of(task), 1, null));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllNull5(ExecutorService executor)throws Exception {\n+        try (executor) {\n+            List<Callable<String>> tasks = new ArrayList<>();\n+            tasks.add(() -> \"foo\");\n+            tasks.add(null);\n+            assertThrows(NullPointerException.class,\n+                    () -> executor.invokeAll(tasks, 1, TimeUnit.SECONDS));\n+        }\n+    }\n+\n+    \/**\n+     * Schedules the current thread to be interrupted when it waits (timed or untimed)\n+     * at the given method name.\n+     *\/\n+    private void scheduleInterruptAt(String methodName) {\n+        Thread target = Thread.currentThread();\n+        scheduler.submit(() -> {\n+            try {\n+                boolean found = false;\n+                while (!found) {\n+                    Thread.State state = target.getState();\n+                    assertTrue(state != TERMINATED);\n+                    if ((state == WAITING || state == TIMED_WAITING)\n+                            && contains(target.getStackTrace(), methodName)) {\n+                        found = true;\n+                    } else {\n+                        Thread.sleep(20);\n+                    }\n+                }\n+                target.interrupt();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Returns true if the given stack trace contains an element for the given method name.\n+     *\/\n+    private boolean contains(StackTraceElement[] stack, String methodName) {\n+        return Arrays.stream(stack)\n+                .anyMatch(e -> methodName.equals(e.getMethodName()));\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/ExecutorService\/InvokeTest.java","additions":787,"deletions":0,"binary":false,"changes":787,"status":"added"},{"patch":"@@ -0,0 +1,370 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test implementations of ExecutorService.submit\/execute\n+ * @run junit SubmitTest\n+ *\/\n+\n+import java.time.Duration;\n+import java.util.concurrent.*;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class SubmitTest {\n+\n+    private static Stream<ExecutorService> executors() {\n+        return Stream.of(\n+                Executors.newCachedThreadPool(),\n+                Executors.newVirtualThreadPerTaskExecutor(),\n+                new ForkJoinPool()\n+        );\n+    }\n+\n+    \/**\n+     * Test submit(Runnable) executes the task.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitRunnable(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var latch = new CountDownLatch(1);\n+            Future<?> future = executor.submit(latch::countDown);\n+            latch.await();\n+            assertNull(future.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test submit(Runnable) throws if executor is shutdown.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitRunnableAfterShutdown(ExecutorService executor) {\n+        executor.shutdown();\n+        assertThrows(RejectedExecutionException.class, () -> executor.submit(() -> { }));\n+    }\n+\n+    \/**\n+     * Test task submitted with submit(Runnable) is not interrupted by cancel(false).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitRunnableWithCancelFalse(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var started = new CountDownLatch(1);\n+            var stop = new CountDownLatch(1);\n+            var done = new CountDownLatch(1);\n+            Future<?> future = executor.submit(() -> {\n+                started.countDown();\n+                try {\n+                    stop.await();\n+                } catch (InterruptedException e) {\n+                    \/\/ ignore\n+                } finally {\n+                    done.countDown();\n+                }\n+            });\n+\n+            \/\/ wait for task to start\n+            started.await();\n+\n+            \/\/ cancel(false), task should not be interrupted\n+            future.cancel(false);\n+            assertFalse(done.await(500, TimeUnit.MILLISECONDS));\n+\n+            \/\/ let task finish\n+            stop.countDown();\n+        }\n+    }\n+\n+    \/**\n+     * Test task submitted with submit(Runnable) is interrupted by cancel(true).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitRunnableWithCancelTrue(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var started = new CountDownLatch(1);\n+            var interrupted = new CountDownLatch(1);\n+            Future<?> future = executor.submit(() -> {\n+                started.countDown();\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    interrupted.countDown();\n+                }\n+            });\n+\n+            \/\/ wait for task to start\n+            started.await();\n+\n+            \/\/ cancel(true), task should be interrupted\n+            future.cancel(true);\n+            interrupted.await();\n+        }\n+    }\n+\n+    \/**\n+     * Test task submitted with submit(Runnable) is interrupted if executor is\n+     * stopped with shutdownNow.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitRunnableWithShutdownNow(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var started = new CountDownLatch(1);\n+            var interrupted = new CountDownLatch(1);\n+            Future<?> future = executor.submit(() -> {\n+                started.countDown();\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    interrupted.countDown();\n+                }\n+            });\n+\n+            \/\/ wait for task to start\n+            started.await();\n+\n+            \/\/ shutdown forcefully, task should be interrupted\n+            executor.shutdownNow();\n+            interrupted.await();\n+        }\n+    }\n+\n+    \/**\n+     * Test submit(Runnable) throws if task is null.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitRunnableNull(ExecutorService executor) {\n+        try (executor) {\n+            Runnable nullTask = null;\n+            assertThrows(NullPointerException.class, () -> executor.submit(nullTask));\n+            assertThrows(NullPointerException.class, () -> executor.submit(nullTask, Void.class));\n+        }\n+    }\n+\n+    \/\/\n+\n+    \/**\n+     * Test submit(Callable) executes the task.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitCallable(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var latch = new CountDownLatch(1);\n+            Future<String> future = executor.submit(() -> {\n+                latch.countDown();\n+                return \"foo\";\n+            });\n+            latch.await();\n+            assertEquals(\"foo\", future.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test submit(Callable) throws if executor is shutdown.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitCallableAfterShutdown(ExecutorService executor) {\n+        executor.shutdown();\n+        assertThrows(RejectedExecutionException.class, () -> executor.submit(() -> null));\n+    }\n+\n+    \/**\n+     * Test task submitted with submit(Callable) is not interrupted by cancel(false).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitCallableWithCancelFalse(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var started = new CountDownLatch(1);\n+            var stop = new CountDownLatch(1);\n+            var done = new CountDownLatch(1);\n+            Future<Void> future = executor.submit(() -> {\n+                started.countDown();\n+                try {\n+                    stop.await();\n+                } finally {\n+                    done.countDown();\n+                }\n+                return null;\n+            });\n+\n+            \/\/ wait for task to start\n+            started.await();\n+\n+            \/\/ cancel(false), task should not be interrupted\n+            future.cancel(false);\n+            assertFalse(done.await(500, TimeUnit.MILLISECONDS));\n+\n+            \/\/ let task finish\n+            stop.countDown();\n+        }\n+    }\n+\n+    \/**\n+     * Test task submitted with submit(Callable) is interrupted by cancel(true).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitCallableWithCancelTrue(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var started = new CountDownLatch(1);\n+            var interrupted = new CountDownLatch(1);\n+            Future<Void> future = executor.submit(() -> {\n+                started.countDown();\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    interrupted.countDown();\n+                }\n+                return null;\n+            });\n+\n+            \/\/ wait for task to start\n+            started.await();\n+\n+            \/\/ cancel(true), task should be interrupted\n+            future.cancel(true);\n+            interrupted.await();\n+        }\n+    }\n+\n+    \/**\n+     * Test task submitted with submit(Callable) is interrupted if executor is\n+     * stopped with shutdownNow.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitCallableWithShutdownNow(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var started = new CountDownLatch(1);\n+            var interrupted = new CountDownLatch(1);\n+            Future<Void> future = executor.submit(() -> {\n+                started.countDown();\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    interrupted.countDown();\n+                }\n+                return null;\n+            });\n+\n+            \/\/ wait for task to start\n+            started.await();\n+\n+            \/\/ shutdown forcefully, task should be interrupted\n+            executor.shutdownNow();\n+            interrupted.await();\n+        }\n+    }\n+\n+    \/**\n+     * Test submit(Callable) throws if task is null.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitCallableNull(ExecutorService executor) {\n+        try (executor) {\n+            Callable<Void> nullTask = null;\n+            assertThrows(NullPointerException.class, () -> executor.submit(nullTask));\n+        }\n+    }\n+\n+    \/\/\n+\n+    \/**\n+     * Test execute(Runnable) executes the task.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testExecute(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var latch = new CountDownLatch(1);\n+            executor.execute(latch::countDown);\n+            latch.await();\n+        }\n+    }\n+\n+    \/**\n+     * Test execute(Runnable) throws if executor is shutdown.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testExecuteAfterShutdown(ExecutorService executor) {\n+        executor.shutdown();\n+        assertThrows(RejectedExecutionException.class, () -> executor.execute(() -> { }));\n+    }\n+\n+    \/**\n+     * Test task submitted with execute(Runnable) is interrupted if executor is\n+     * stopped with shutdownNow.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testExecuteWithShutdownNow(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var started = new CountDownLatch(1);\n+            var interrupted = new CountDownLatch(1);\n+            executor.execute(() -> {\n+                started.countDown();\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    interrupted.countDown();\n+                }\n+            });\n+\n+            \/\/ wait for task to start\n+            started.await();\n+\n+            \/\/ shutdown forcefully, task should be interrupted\n+            executor.shutdownNow();\n+            interrupted.await();\n+        }\n+    }\n+\n+    \/**\n+     * Test execute(Runnable) throws if task is null.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testExecuteNull(ExecutorService executor) {\n+        try (executor) {\n+            Runnable nullTask = null;\n+            assertThrows(NullPointerException.class, () -> executor.execute(nullTask));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/ExecutorService\/SubmitTest.java","additions":370,"deletions":0,"binary":false,"changes":370,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng DefaultMethods\n+ * @run junit DefaultMethods\n@@ -31,1 +31,7 @@\n-import java.util.concurrent.*;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.Future;\n+import java.util.stream.Stream;\n@@ -34,3 +40,4 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -38,1 +45,1 @@\n-public class DefaultMethods {\n+class DefaultMethods {\n@@ -40,5 +47,4 @@\n-    @DataProvider(name = \"executors\")\n-    public Object[][] executors() {\n-        return new Object[][] {\n-            \/\/ ensures that default implementation is tested\n-            { new DelegatingExecutorService(Executors.newCachedThreadPool()), },\n+    static Stream<ExecutorService> executors() {\n+        return Stream.of(\n+                \/\/ ensures that default close method is tested\n+                new DelegatingExecutorService(Executors.newCachedThreadPool()),\n@@ -46,4 +52,5 @@\n-            \/\/ executors that may return a Future that overrides the methods\n-            { new ForkJoinPool(), },\n-            { Executors.newCachedThreadPool(), }\n-        };\n+                \/\/ executors that may return a Future that overrides the methods\n+                Executors.newCachedThreadPool(),\n+                Executors.newVirtualThreadPerTaskExecutor(),\n+                new ForkJoinPool()\n+        );\n@@ -55,2 +62,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testRunningTask(ExecutorService executor) {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testRunningTask(ExecutorService executor) {\n@@ -62,2 +70,2 @@\n-                expectThrows(IllegalStateException.class, future::resultNow);\n-                expectThrows(IllegalStateException.class, future::exceptionNow);\n+                assertThrows(IllegalStateException.class, future::resultNow);\n+                assertThrows(IllegalStateException.class, future::exceptionNow);\n@@ -73,2 +81,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testCompletedTask1(ExecutorService executor) {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testCompletedTask1(ExecutorService executor) {\n@@ -79,2 +88,2 @@\n-            assertEquals(future.resultNow(), \"foo\");\n-            expectThrows(IllegalStateException.class, future::exceptionNow);\n+            assertEquals(\"foo\", future.resultNow());\n+            assertThrows(IllegalStateException.class, future::exceptionNow);\n@@ -87,2 +96,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testCompletedTask2(ExecutorService executor) {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testCompletedTask2(ExecutorService executor) {\n@@ -93,2 +103,2 @@\n-            assertEquals(future.resultNow(), null);\n-            expectThrows(IllegalStateException.class, future::exceptionNow);\n+            assertNull(future.resultNow());\n+            assertThrows(IllegalStateException.class, future::exceptionNow);\n@@ -101,2 +111,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testFailedTask(ExecutorService executor) {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testFailedTask(ExecutorService executor) {\n@@ -107,1 +118,1 @@\n-            expectThrows(IllegalStateException.class, future::resultNow);\n+            assertThrows(IllegalStateException.class, future::resultNow);\n@@ -116,2 +127,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testCancelledTask1(ExecutorService executor) {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testCancelledTask1(ExecutorService executor) {\n@@ -124,2 +136,2 @@\n-                expectThrows(IllegalStateException.class, future::resultNow);\n-                expectThrows(IllegalStateException.class, future::exceptionNow);\n+                assertThrows(IllegalStateException.class, future::resultNow);\n+                assertThrows(IllegalStateException.class, future::exceptionNow);\n@@ -135,2 +147,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testCancelledTask2(ExecutorService executor) {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testCancelledTask2(ExecutorService executor) {\n@@ -143,2 +156,2 @@\n-                expectThrows(IllegalStateException.class, future::resultNow);\n-                expectThrows(IllegalStateException.class, future::exceptionNow);\n+                assertThrows(IllegalStateException.class, future::resultNow);\n+                assertThrows(IllegalStateException.class, future::exceptionNow);\n@@ -155,1 +168,1 @@\n-    public void testCompletableFuture1() {\n+    void testCompletableFuture1() {\n@@ -158,2 +171,2 @@\n-        expectThrows(IllegalStateException.class, future::resultNow);\n-        expectThrows(IllegalStateException.class, future::exceptionNow);\n+        assertThrows(IllegalStateException.class, future::resultNow);\n+        assertThrows(IllegalStateException.class, future::exceptionNow);\n@@ -166,1 +179,1 @@\n-    public void testCompletableFuture2() {\n+    void testCompletableFuture2() {\n@@ -170,2 +183,2 @@\n-        assertEquals(future.resultNow(), \"foo\");\n-        expectThrows(IllegalStateException.class, future::exceptionNow);\n+        assertEquals(\"foo\", future.resultNow());\n+        assertThrows(IllegalStateException.class, future::exceptionNow);\n@@ -178,1 +191,1 @@\n-    public void testCompletableFuture3() {\n+    void testCompletableFuture3() {\n@@ -182,2 +195,2 @@\n-        assertEquals(future.resultNow(), null);\n-        expectThrows(IllegalStateException.class, future::exceptionNow);\n+        assertNull(future.resultNow());\n+        assertThrows(IllegalStateException.class, future::exceptionNow);\n@@ -190,1 +203,1 @@\n-    public void testCompletableFuture4() {\n+    void testCompletableFuture4() {\n@@ -194,1 +207,1 @@\n-        expectThrows(IllegalStateException.class, future::resultNow);\n+        assertThrows(IllegalStateException.class, future::resultNow);\n@@ -203,1 +216,1 @@\n-    public void testCompletableFuture5() {\n+    void testCompletableFuture5() {\n@@ -207,2 +220,2 @@\n-        expectThrows(IllegalStateException.class, future::resultNow);\n-        expectThrows(IllegalStateException.class, future::exceptionNow);\n+        assertThrows(IllegalStateException.class, future::resultNow);\n+        assertThrows(IllegalStateException.class, future::exceptionNow);\n","filename":"test\/jdk\/java\/util\/concurrent\/Future\/DefaultMethods.java","additions":66,"deletions":53,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -0,0 +1,1 @@\n+maxOutputSize=2000000\n","filename":"test\/jdk\/java\/util\/concurrent\/TEST.properties","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,2 @@\n- * @run testng AsyncShutdownNow\n- * @summary Test invoking shutdownNow with threads blocked in Future.get,\n- *          invokeAll, and invokeAny\n+ * @summary Test ForkJoinPool.shutdownNow with threads blocked in invokeXXX and Future.get\n+ * @run junit AsyncShutdownNow\n@@ -31,0 +30,1 @@\n+import java.time.Duration;\n@@ -41,0 +41,1 @@\n+import java.util.stream.Stream;\n@@ -43,3 +44,3 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -47,1 +48,1 @@\n-public class AsyncShutdownNow {\n+class AsyncShutdownNow {\n@@ -51,1 +52,1 @@\n-        Thread.sleep(86400_000);\n+        Thread.sleep(Duration.ofDays(1));\n@@ -55,9 +56,5 @@\n-    \/**\n-     * The executors to test.\n-     *\/\n-    @DataProvider(name = \"executors\")\n-    public Object[][] executors() {\n-        return new Object[][] {\n-                { new ForkJoinPool() },\n-                { new ForkJoinPool(1) },\n-        };\n+    static Stream<ForkJoinPool> pools() {\n+        return Stream.of(\n+                new ForkJoinPool(),\n+                new ForkJoinPool(1)\n+        );\n@@ -67,1 +64,1 @@\n-     * Test shutdownNow with running task and thread blocked in Future::get.\n+     * Test shutdownNow with a running task and main thread blocked in Future::get.\n@@ -69,5 +66,5 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testFutureGet(ExecutorService executor) throws Exception {\n-        System.out.format(\"testFutureGet: %s%n\", executor);\n-        try (executor) {\n-            Future<?> future = executor.submit(SLEEP_FOR_A_DAY);\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void testFutureGet(ForkJoinPool pool) throws Exception {\n+        try (pool) {\n+            Future<?> future = pool.submit(SLEEP_FOR_A_DAY);\n@@ -75,2 +72,2 @@\n-            \/\/ shutdownNow when main thread waits in ForkJoinTask.get\n-            onWait(\"java.util.concurrent.ForkJoinTask.get\", executor::shutdownNow);\n+            \/\/ shutdownNow when main thread waits in ForkJoinTask.awaitDone\n+            onWait(\"java.util.concurrent.ForkJoinTask.awaitDone\", pool::shutdownNow);\n@@ -87,1 +84,1 @@\n-     * Test shutdownNow with running task and thread blocked in a timed Future::get.\n+     * Test shutdownNow with a running task and main thread blocked in a timed Future::get.\n@@ -89,5 +86,5 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testTimedFutureGet(ExecutorService executor) throws Exception {\n-        System.out.format(\"testTimedFutureGet: %s%n\", executor);\n-        try (executor) {\n-            Future<?> future = executor.submit(SLEEP_FOR_A_DAY);\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void testTimedFutureGet(ForkJoinPool pool) throws Exception {\n+        try (pool) {\n+            Future<?> future = pool.submit(SLEEP_FOR_A_DAY);\n@@ -95,2 +92,2 @@\n-            \/\/ shutdownNow when main thread waits in ForkJoinTask.get\n-            onWait(\"java.util.concurrent.ForkJoinTask.get\", executor::shutdownNow);\n+            \/\/ shutdownNow when main thread waits in ForkJoinTask.awaitDone\n+            onWait(\"java.util.concurrent.ForkJoinTask.awaitDone\", pool::shutdownNow);\n@@ -107,1 +104,1 @@\n-     * Test shutdownNow with thread blocked in invokeAll.\n+     * Test shutdownNow with running tasks and main thread blocked in invokeAll.\n@@ -109,7 +106,7 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAll(ExecutorService executor) throws Exception {\n-        System.out.format(\"testInvokeAll: %s%n\", executor);\n-        try (executor) {\n-            \/\/ shutdownNow when main thread waits in ForkJoinTask.quietlyJoin\n-            onWait(\"java.util.concurrent.ForkJoinTask.quietlyJoin\", executor::shutdownNow);\n-            List<Future<Void>> futures = executor.invokeAll(List.of(SLEEP_FOR_A_DAY, SLEEP_FOR_A_DAY));\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void testInvokeAll(ForkJoinPool pool) throws Exception {\n+        try (pool) {\n+            \/\/ shutdownNow when main thread waits in ForkJoinTask.awaitDone\n+            onWait(\"java.util.concurrent.ForkJoinTask.awaitDone\", pool::shutdownNow);\n+            List<Future<Void>> futures = pool.invokeAll(List.of(SLEEP_FOR_A_DAY, SLEEP_FOR_A_DAY));\n@@ -129,1 +126,1 @@\n-     * Test shutdownNow with thread blocked in invokeAny.\n+     * Test shutdownNow with running tasks and main thread blocked in invokeAny.\n@@ -131,4 +128,4 @@\n-    @Test(dataProvider = \"executors\", enabled = false)\n-    public void testInvokeAny(ExecutorService executor) throws Exception {\n-        System.out.format(\"testInvokeAny: %s%n\", executor);\n-        try (executor) {\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void testInvokeAny(ForkJoinPool pool) throws Exception {\n+        try (pool) {\n@@ -136,1 +133,1 @@\n-            onWait(\"java.util.concurrent.ForkJoinTask.get\", executor::shutdownNow);\n+            onWait(\"java.util.concurrent.ForkJoinTask.get\", pool::shutdownNow);\n@@ -138,1 +135,1 @@\n-                executor.invokeAny(List.of(SLEEP_FOR_A_DAY, SLEEP_FOR_A_DAY));\n+                pool.invokeAny(List.of(SLEEP_FOR_A_DAY, SLEEP_FOR_A_DAY));\n","filename":"test\/jdk\/java\/util\/concurrent\/forkjoin\/AsyncShutdownNow.java","additions":46,"deletions":49,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -252,7 +252,9 @@\n-            if (n <= 1)\n-                throw new FJException();\n-            else {\n-                FailingFibAction f1 = new FailingFibAction(n - 1);\n-                FailingFibAction f2 = new FailingFibAction(n - 2);\n-                invokeAll(f1, f2);\n-                result = f1.result + f2.result;\n+            if (n > 1) {\n+                try {\n+                    FailingFibAction f1 = new FailingFibAction(n - 1);\n+                    FailingFibAction f2 = new FailingFibAction(n - 2);\n+                    invokeAll(f1, f2);\n+                    result = f1.result + f2.result;\n+                    return;\n+                } catch (CancellationException fallthrough) {\n+                }\n@@ -260,0 +262,1 @@\n+            throw new FJException();\n@@ -392,0 +395,1 @@\n+                Thread.interrupted();\n@@ -507,8 +511,13 @@\n-        ForkJoinTask f = new FibAction(8);\n-        ForkJoinPool pool = null;\n-        try (ForkJoinPool p = new ForkJoinPool()) {\n-            pool = p;\n-            p.execute(f);\n-        }\n-        checkCompletedNormally(f);\n-        assertTrue(pool != null && pool.isTerminated());\n+        Thread t = newStartedThread(new CheckedRunnable() {\n+                public void realRun() throws InterruptedException {\n+                    FibAction f = new FibAction(1);\n+                    ForkJoinPool pool = null;\n+                    try (ForkJoinPool p = new ForkJoinPool()) {\n+                        pool = p;\n+                        p.execute(f);\n+                    }\n+                    assertTrue(pool != null && pool.isTerminated());\n+                    f.join();\n+                    assertEquals(1, f.result);\n+                }});\n+        awaitTermination(t);\n@@ -518,1 +527,1 @@\n-     * Implicitly closing common pool using try-with-resources has no effect.\n+     * Explicitly closing a new pool terminates it\n@@ -520,6 +529,13 @@\n-    public void testCloseCommonPool() {\n-        ForkJoinTask f = new FibAction(8);\n-        ForkJoinPool pool;\n-        try (ForkJoinPool p = pool = ForkJoinPool.commonPool()) {\n-            p.execute(f);\n-        }\n+    public void testClose2() {\n+        Thread t = newStartedThread(new CheckedRunnable() {\n+                public void realRun() throws InterruptedException {\n+                    ForkJoinPool pool = new ForkJoinPool();\n+                    FibAction f = new FibAction(1);\n+                    pool.execute(f);\n+                    pool.close();\n+                    assertTrue(pool.isTerminated());\n+                    f.join();\n+                    assertEquals(1, f.result);\n+                }});\n+        awaitTermination(t);\n+    }\n@@ -527,3 +543,17 @@\n-        assertFalse(pool.isShutdown());\n-        assertFalse(pool.isTerminating());\n-        assertFalse(pool.isTerminated());\n+    \/**\n+     * Explicitly closing a shutdown pool awaits termination\n+     *\/\n+    public void testClose3() {\n+        Thread t = newStartedThread(new CheckedRunnable() {\n+                public void realRun() throws InterruptedException {\n+                    ForkJoinPool pool = new ForkJoinPool();\n+                    FibAction f = new FibAction(1);\n+                    pool.execute(f);\n+                    pool.shutdown();\n+                    pool.close();\n+                    assertTrue(pool.isTerminated());\n+                    f.join();\n+                    assertEquals(1, f.result);\n+                }});\n+        awaitTermination(t);\n+    }\n@@ -531,0 +561,4 @@\n+    \/**\n+     * Implicitly closing common pool using try-with-resources has no effect.\n+     *\/\n+    public void testCloseCommonPool() {\n@@ -533,4 +567,17 @@\n-        if (! \"0\".equals(prop)) {\n-            f.join();\n-            checkCompletedNormally(f);\n-        }\n+        boolean nothreads = \"0\".equals(prop);\n+        Thread t = newStartedThread(new CheckedRunnable() {\n+                public void realRun() throws InterruptedException {\n+                    ForkJoinTask f = new FibAction(8);\n+                    ForkJoinPool pool;\n+                    try (ForkJoinPool p = pool = ForkJoinPool.commonPool()) {\n+                        p.execute(f);\n+                    }\n+                    assertFalse(pool.isShutdown());\n+                    assertFalse(pool.isTerminating());\n+                    assertFalse(pool.isTerminated());\n+                    if (!nothreads) {\n+                        f.join();\n+                        checkCompletedNormally(f);\n+                    }\n+                }});\n+       awaitTermination(t);\n@@ -538,1 +585,0 @@\n-\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ForkJoinPool19Test.java","additions":76,"deletions":30,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -235,7 +235,9 @@\n-            if (n <= 1)\n-                throw new FJException();\n-            else {\n-                FailingFibAction f1 = new FailingFibAction(n - 1);\n-                FailingFibAction f2 = new FailingFibAction(n - 2);\n-                invokeAll(f1, f2);\n-                result = f1.result + f2.result;\n+            if (n > 1) {\n+                try {\n+                    FailingFibAction f1 = new FailingFibAction(n - 1);\n+                    FailingFibAction f2 = new FailingFibAction(n - 2);\n+                    invokeAll(f1, f2);\n+                    result = f1.result + f2.result;\n+                    return;\n+                } catch (CancellationException fallthrough) {\n+                }\n@@ -243,0 +245,1 @@\n+            throw new FJException();\n@@ -405,1 +408,3 @@\n-                } catch (NullPointerException success) {}\n+                } catch (NullPointerException success) {\n+                    f.join();\n+                }\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ForkJoinPool8Test.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -499,1 +499,3 @@\n-                } catch (NullPointerException success) {}\n+                } catch (NullPointerException success) {\n+                    f.join();\n+                }\n@@ -1248,1 +1250,3 @@\n-                } catch (NullPointerException success) {}\n+                } catch (NullPointerException success) {\n+                    f.join();\n+                }\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ForkJoinTaskTest.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+import java.util.concurrent.CancellationException;\n@@ -1672,0 +1673,9 @@\n+    \/\/ Avoids unwanted interrupts when run inder jtreg\n+    static ThreadGroup topThreadGroup() {\n+        for (ThreadGroup g = Thread.currentThread().getThreadGroup(), p; ; g = p)\n+            if ((p = g.getParent()) == null)\n+                return g;\n+    }\n+    static final ThreadGroup jsr166TestThreadGroup =\n+        new ThreadGroup(topThreadGroup(), \"jsr1666TestThreadGroup\");\n+\n@@ -1676,1 +1686,1 @@\n-        Thread t = new Thread(runnable);\n+        Thread t = new Thread(jsr166TestThreadGroup, runnable);\n@@ -1696,4 +1706,6 @@\n-        try {\n-            thread.join(timeoutMillis);\n-        } catch (InterruptedException fail) {\n-            threadUnexpectedException(fail);\n+        for (;;) { \/\/ ignore stray interrupts by test harness\n+            try {\n+                thread.join(timeoutMillis);\n+                break;\n+            } catch (InterruptedException ignore) {\n+            }\n@@ -1943,0 +1955,2 @@\n+            } catch (CancellationException ex) {\n+                throw ex; \/\/ expected by some tests\n@@ -1958,0 +1972,2 @@\n+            } catch (CancellationException ex) {\n+                throw ex;\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/JSR166TestCase.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -165,1 +165,0 @@\n-        assertFalse(a.isCancelled());\n@@ -168,1 +167,2 @@\n-        assertSame(t.getClass(), a.getException().getClass());\n+        if (!a.isCancelled())\n+            assertSame(t.getClass(), a.getException().getClass());\n@@ -225,7 +225,9 @@\n-            if (n <= 1)\n-                throw new FJException();\n-            else {\n-                FailingFibAction f1 = new FailingFibAction(n - 1);\n-                FailingFibAction f2 = new FailingFibAction(n - 2);\n-                invokeAll(f1, f2);\n-                result = f1.result + f2.result;\n+            if (n > 1) {\n+                try {\n+                    FailingFibAction f1 = new FailingFibAction(n - 1);\n+                    FailingFibAction f2 = new FailingFibAction(n - 2);\n+                    invokeAll(f1, f2);\n+                    result = f1.result + f2.result;\n+                    return;\n+                } catch (CancellationException fallthrough) {\n+                }\n@@ -233,0 +235,1 @@\n+            throw new FJException();\n@@ -491,1 +494,3 @@\n-                } catch (NullPointerException success) {}\n+                } catch (NullPointerException success) {\n+                    f.join();\n+                }\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/RecursiveActionTest.java","additions":15,"deletions":10,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -181,1 +181,0 @@\n-        assertFalse(a.isCancelled());\n@@ -184,1 +183,2 @@\n-        assertSame(t.getClass(), a.getException().getClass());\n+        if (!a.isCancelled())\n+            assertSame(t.getClass(), a.getException().getClass());\n@@ -243,5 +243,9 @@\n-            if (n <= 1)\n-                throw new FJException();\n-            FailingFibTask f1 = new FailingFibTask(n - 1);\n-            f1.fork();\n-            return new FibTask(n - 2).compute() + f1.join();\n+            if (n > 1) {\n+                try {\n+                    FailingFibTask f1 = new FailingFibTask(n - 1);\n+                    f1.fork();\n+                    return new FibTask(n - 2).compute() + f1.join();\n+                } catch (CancellationException fallthrough) {\n+                }\n+            }\n+            throw new FJException();\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/RecursiveTaskTest.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+    permission java.lang.RuntimePermission \"modifyThreadGroup\";\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/tck.policy","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}