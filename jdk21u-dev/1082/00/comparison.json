{"files":[{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+   @bug 8340684\n+   @summary Verify unspecified, but long-standing behavior when reading\n+   from an input stream obtained using ZipFile::getInputStream after\n+   the ZipFile has been closed.\n+   @run junit ReadAfterClose\n+ *\/\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.stream.Stream;\n+import java.util.zip.CRC32;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class ReadAfterClose {\n+\n+    \/\/ ZIP file used in this test\n+    private Path zip = Path.of(\"read-after-close.zip\");\n+\n+    \/**\n+     * Create a sample ZIP file for use by this test\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @BeforeEach\n+    public void setUp() throws IOException {\n+        byte[] content = \"hello\".repeat(1000).getBytes(StandardCharsets.UTF_8);\n+        try (OutputStream out = Files.newOutputStream(zip);\n+             ZipOutputStream zo = new ZipOutputStream(out)) {\n+            {\n+                zo.putNextEntry(new ZipEntry(\"deflated.txt\"));\n+                zo.write(content);\n+            }\n+            {\n+                ZipEntry entry = new ZipEntry(\"stored.txt\");\n+                entry.setMethod(ZipEntry.STORED);\n+                CRC32 crc = new CRC32();\n+                crc.update(content);\n+                entry.setCrc(crc.getValue());\n+                entry.setSize(content.length);\n+                zo.putNextEntry(entry);\n+                zo.write(content);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Delete the ZIP file produced by this test\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * Produce arguments with a variation of stored \/ deflated entries,\n+     * and read behavior before closing the ZipFile.\n+     * @return\n+     *\/\n+    public static Stream<Arguments> arguments() {\n+        return Stream.of(\n+                Arguments.of(\"stored.txt\",   true),\n+                Arguments.of(\"stored.txt\",   false),\n+                Arguments.of(\"deflated.txt\", true),\n+                Arguments.of(\"deflated.txt\", false)\n+        );\n+    }\n+    \/**\n+     * Attempting to read from an InputStream obtained by ZipFile.getInputStream\n+     * after the backing ZipFile is closed should throw IOException\n+     *\n+     * @throws IOException if an unexpected IOException occurs\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"arguments\")\n+    public void readAfterClose(String entryName, boolean readFirst) throws IOException {\n+        \/\/ Retain a reference to an input stream backed by a closed ZipFile\n+        InputStream in;\n+        try (ZipFile zf = new ZipFile(zip.toFile())) {\n+            in = zf.getInputStream(new ZipEntry(entryName));\n+            \/\/ Optionally consume a single byte from the stream before closing\n+            if (readFirst) {\n+                in.read();\n+            }\n+        }\n+\n+        assertThrows(IOException.class, () -> {\n+            in.read();\n+        });\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ReadAfterClose.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"}]}