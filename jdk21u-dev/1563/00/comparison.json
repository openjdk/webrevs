{"files":[{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4238978\n+ * @summary This test verifies that the correct blitting loop is being used.\n+ *          The correct output should have a yellow border on the top and\n+ *          left sides of a red box.  The incorrect output would have only\n+ *          a red box -- no yellow border.\"\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.image.BufferedImage;\n+\n+public class ARGBBgToRGB {\n+\n+    public static void main(String[] argv) {\n+        BufferedImage bi = new BufferedImage(256, 256, BufferedImage.TYPE_INT_ARGB);\n+        Graphics2D big = bi.createGraphics();\n+        big.setColor(Color.red);\n+        big.fillRect(30, 30, 150, 150);\n+\n+        BufferedImage bi2 = new BufferedImage(100, 100, BufferedImage.TYPE_INT_ARGB);\n+        Graphics2D big2 = bi2.createGraphics();\n+        big2.drawImage(bi, 0, 0, Color.yellow, null);\n+\n+        int expectYellowPix = bi2.getRGB(0, 0);\n+        int expectRedPix = bi2.getRGB(50, 50);\n+        if ((expectYellowPix != Color.yellow.getRGB()) ||\n+            (expectRedPix != Color.red.getRGB()))\n+        {\n+           throw new RuntimeException(\"Unexpected colors \" + expectYellowPix + \" \" + expectRedPix);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/loops\/ARGBBgToRGB.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4188744\n+ * @summary This test verifies that copyArea performs correctly for negative offset values.\n+ *          The correct output shows that the text area is moved to the left and down,\n+ *          leaving some garbage on the right and the top.\n+ *          The incorrect copy would show the text area garbled and no text is legible.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual CopyNegative\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Image;\n+import java.awt.Panel;\n+\n+public class CopyNegative extends Panel {\n+\n+   private static final String INSTRUCTIONS = \"\"\"\n+       This test verifies that copyArea performs correctly for negative offset values.\n+       The test draws text in an image, then copies the contents repeatedly.\n+       The correct output shows that the text is moved to the left and down,\n+       leaving some garbage on the top \/ right and some legible text at the bottom left.\n+       The incorrect copy would show the whole text area garbled and no text is legible.\n+       \"\"\";\n+\n+    public static void main(String[] argv) throws Exception {\n+       PassFailJFrame.builder()\n+            .title(\"CopyNegativeTest\")\n+            .instructions(INSTRUCTIONS)\n+            .testUI(CopyNegative::createUI)\n+            .testTimeOut(5)\n+            .rows(10)\n+            .columns(50)\n+            .build()\n+            .awaitAndCheck();\n+    }\n+\n+    Image img;\n+\n+    static final int W = 200, H = 200;\n+\n+    static Frame createUI() {\n+        Frame f = new Frame(\"CopyNegative\");\n+        f.add(new CopyNegative());\n+        f.pack();\n+        return f;\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(W, H);\n+    }\n+\n+    private void doCopy() {\n+        Graphics g = img.getGraphics();\n+        g.setColor(Color.white);\n+        g.fillRect(0, 0, W, H);\n+        g.setColor(Color.black);\n+        String text = \"Some Text To Display, it is long enough to fill the entire display line.\";\n+        StringBuffer sb = new StringBuffer(text);\n+\n+        for (int i = 1; i < 50; i++) {\n+            g.drawString(sb.toString(), 5,20 * i - 10);\n+            sb.insert(0, Integer.toString(i));\n+        }\n+        for (int i = 0 ; i < 20 ; i++ ) {\n+            g.copyArea(0, 0, W, H, -3, 3);\n+        }\n+    }\n+\n+    public void paint(Graphics g) {\n+        img = createImage(W, H);\n+        doCopy();\n+        g.drawImage(img, 0, 0, this);\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/java2d\/loops\/CopyNegative.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 4181172\n+ * @summary Confirm that solid white fill is not dithered on an 8-bit indexed surface.\n+ *          The test draws two areas filled with white solid color.\n+ *          The upper left square is filled in aliasing mode and\n+ *          the lower right square is filled in anti-aliasing mode.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.RenderingHints;\n+import java.awt.image.BufferedImage;\n+\n+public class DitheredSolidFill {\n+\n+    public static void main(String args[]) {\n+       BufferedImage bi = new BufferedImage(120, 120, BufferedImage.TYPE_BYTE_INDEXED);\n+       Graphics2D g2D = bi.createGraphics();\n+\n+        g2D.setColor(Color.black);\n+        g2D.fillRect(0, 0, 100, 100);\n+\n+        g2D.setColor(Color.white);\n+        g2D.fillRect(5, 5, 40, 40);\n+        checkPixels(bi, 5, 5, 40, 40);\n+\n+        g2D.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n+        g2D.fillRect(55, 55, 40, 40);\n+        checkPixels(bi, 55, 55, 40, 40);\n+    }\n+\n+    static void checkPixels(BufferedImage bi, int x, int y, int w, int h) {\n+       \/\/ pixel can be off white, but must be the same in all cases.\n+       int expectedPix = bi.getRGB(x, y);\n+       for (int x0 = x; x0 < x + w; x0++) {\n+           for (int y0 = y; y0 < y + h; y0++) {\n+              if (bi.getRGB(x0, y0) != expectedPix) {\n+                  try {\n+                      javax.imageio.ImageIO.write(bi, \"png\", new java.io.File(\"failed.png\"));\n+                  } catch (Exception e) {\n+                  }\n+                  throw new RuntimeException(\"Not expected pix : \" +\n+                                             Integer.toHexString(bi.getRGB(x0, y0)) +\n+                                             \" at \" + x0 + \",\" + y0);\n+              }\n+           }\n+       }\n+   }\n+}\n","filename":"test\/jdk\/sun\/java2d\/loops\/DitheredSolidFill.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4236576\n+  @summary tests that a BufferedImage in TYPE_3BYTE_BGR format is correctly\n+           drawn when there is an offset between the Graphics clip bounds\n+           and the clip box of the underlying device context.\n+  @run main OffsetCalculationTest\n+*\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.Rectangle;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.DataBuffer;\n+\n+public class OffsetCalculationTest {\n+\n+    public static void main(String[] args) {\n+        BufferedImage srcImage = new BufferedImage(500, 500, BufferedImage.TYPE_3BYTE_BGR);\n+\n+        DataBuffer buffer = srcImage.getRaster().getDataBuffer();\n+        for (int i = 2; i < buffer.getSize(); i+=3) {\n+            \/\/ setting each pixel to blue via the data buffer elements.\n+            buffer.setElem(i - 2, 0xff);\n+            buffer.setElem(i - 1, 0);\n+            buffer.setElem(i, 0);\n+        }\n+\n+        int w = 200, h = 200;\n+        BufferedImage destImage = new BufferedImage(w, h, BufferedImage.TYPE_3BYTE_BGR);\n+        Graphics2D g = destImage.createGraphics();\n+        Rectangle r = new Rectangle(0, 0, w, h);\n+        g.setClip(r.x - 1, r.y, r.width + 1, r.height);\n+        g.drawImage(srcImage, 0, 0, null);\n+\n+        int bluepix = Color.blue.getRGB();\n+        for (int y = 0; y < w; y++) {\n+            for (int x = 0; x < h; x++) {\n+                if (destImage.getRGB(x, y) != bluepix) {\n+                     throw new RuntimeException(\"Not Blue\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/loops\/OffsetCalculationTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4088173\n+ * @summary This interactive test verifies that the XOR mode is not affecting\n+ *          the clearRect() call. The correct output looks like:\n+ *\n+ *          \\      \/\n+ *           \\    \/\n+ *                     The backgound is blue.\n+ *                     The lines outside the central rectangle are green.\n+ *                     The central rectangle is also blue (the result of clearRect())\n+ *           \/    \\\n+ *          \/      \\\n+ *\n+ * @key headful\n+ * @run main XORClearRect\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Graphics;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+\n+public class XORClearRect extends Panel {\n+\n+    public static void main(String args[]) throws Exception {\n+        EventQueue.invokeAndWait(XORClearRect::createUI);\n+        try {\n+             Robot robot = new Robot();\n+             robot.waitForIdle();\n+             robot.delay(2000);\n+             Point p = frame.getLocationOnScreen();\n+             int pix = robot.getPixelColor(p.x + 100, p.y + 100).getRGB();\n+             if (pix != Color.blue.getRGB()) {\n+                 throw new RuntimeException(\"Not blue\");\n+             }\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+    }\n+\n+    static volatile Frame frame;\n+\n+    static void createUI() {\n+        frame = new Frame(\"XORClearRect\");\n+        frame.setBackground(Color.blue);\n+        XORClearRect xor = new XORClearRect();\n+        frame.add(xor);\n+        frame.setSize(200,200);\n+        frame.setVisible(true);\n+    }\n+\n+    public XORClearRect() {\n+       setBackground(Color.blue);\n+    }\n+\n+    public void paint(Graphics g) {\n+        g.setColor(Color.green);\n+        g.drawLine(0,0,200,200);\n+        g.drawLine(0,200,200,0);\n+        g.setXORMode(Color.blue);\n+        g.clearRect(50,50,100,100); \/\/expecting the rectangle to be filled\n+                                    \/\/ with the background color (blue)\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/loops\/XORClearRect.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"}]}