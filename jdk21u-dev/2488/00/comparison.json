{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+import jdk.internal.vm.annotation.Stable;\n+\n@@ -29,1 +31,0 @@\n-import java.util.regex.*;\n@@ -51,1 +52,0 @@\n-    static final int    BIG_DECIMAL_EXPONENT = 324; \/\/ i.e. abs(MIN_DECIMAL_EXPONENT)\n@@ -110,1 +110,1 @@\n-        return readJavaFormatString(s).doubleValue();\n+        return readJavaFormatString(s, BINARY_64_IX).doubleValue();\n@@ -122,1 +122,1 @@\n-        return readJavaFormatString(s).floatValue();\n+        return readJavaFormatString(s, BINARY_32_IX).floatValue();\n@@ -191,1 +191,1 @@\n-        private boolean isNegative;\n+        private final boolean isNegative;\n@@ -246,1 +246,0 @@\n-    private static final int INFINITY_LENGTH = INFINITY_REP.length();\n@@ -248,1 +247,0 @@\n-    private static final int NAN_LENGTH = NAN_REP.length();\n@@ -866,6 +864,6 @@\n-            0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3,\n-            4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7,\n-            8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11,\n-            12, 12, 12, 12, 13, 13, 13, 14, 14, 14,\n-            15, 15, 15, 15, 16, 16, 16, 17, 17, 17,\n-            18, 18, 18, 19\n+                0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3,\n+                4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7,\n+                8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 11, 11, 11,\n+                12, 12, 12, 12, 13, 13, 13, 14, 14, 14,\n+                15, 15, 15, 15, 16, 16, 16, 17, 17, 17,\n+                18, 18, 18, 19\n@@ -1037,1 +1035,1 @@\n-        char        digits[];\n+        char[]      digits;\n@@ -1706,6 +1704,6 @@\n-            1.0e0,\n-            1.0e1, 1.0e2, 1.0e3, 1.0e4, 1.0e5,\n-            1.0e6, 1.0e7, 1.0e8, 1.0e9, 1.0e10,\n-            1.0e11, 1.0e12, 1.0e13, 1.0e14, 1.0e15,\n-            1.0e16, 1.0e17, 1.0e18, 1.0e19, 1.0e20,\n-            1.0e21, 1.0e22\n+                1.0e0,\n+                1.0e1, 1.0e2, 1.0e3, 1.0e4, 1.0e5,\n+                1.0e6, 1.0e7, 1.0e8, 1.0e9, 1.0e10,\n+                1.0e11, 1.0e12, 1.0e13, 1.0e14, 1.0e15,\n+                1.0e16, 1.0e17, 1.0e18, 1.0e19, 1.0e20,\n+                1.0e21, 1.0e22\n@@ -1715,3 +1713,3 @@\n-            1.0e0f,\n-            1.0e1f, 1.0e2f, 1.0e3f, 1.0e4f, 1.0e5f,\n-            1.0e6f, 1.0e7f, 1.0e8f, 1.0e9f, 1.0e10f\n+                1.0e0f,\n+                1.0e1f, 1.0e2f, 1.0e3f, 1.0e4f, 1.0e5f,\n+                1.0e6f, 1.0e7f, 1.0e8f, 1.0e9f, 1.0e10f\n@@ -1721,1 +1719,1 @@\n-            1e16, 1e32, 1e64, 1e128, 1e256 };\n+                1e16, 1e32, 1e64, 1e128, 1e256 };\n@@ -1723,1 +1721,1 @@\n-            1e-16, 1e-32, 1e-64, 1e-128, 1e-256 };\n+                1e-16, 1e-32, 1e-64, 1e-128, 1e-256 };\n@@ -1829,96 +1827,64 @@\n-    @SuppressWarnings(\"fallthrough\")\n-    static ASCIIToBinaryConverter readJavaFormatString( String in ) throws NumberFormatException {\n-        boolean isNegative = false;\n-        boolean signSeen   = false;\n-        int     decExp;\n-        char    c;\n-\n-    parseNumber:\n-        try{\n-            in = in.trim(); \/\/ don't fool around with white space.\n-                            \/\/ throws NullPointerException if null\n-            int len = in.length();\n-            if ( len == 0 ) {\n-                throw new NumberFormatException(\"empty String\");\n-            }\n-            int i = 0;\n-            switch (in.charAt(i)){\n-            case '-':\n-                isNegative = true;\n-                \/\/FALLTHROUGH\n-            case '+':\n-                i++;\n-                signSeen = true;\n-            }\n-            c = in.charAt(i);\n-            if(c == 'N') { \/\/ Check for NaN\n-                if((len-i)==NAN_LENGTH && in.indexOf(NAN_REP,i)==i) {\n-                    return A2BC_NOT_A_NUMBER;\n-                }\n-                \/\/ something went wrong, throw exception\n-                break parseNumber;\n-            } else if(c == 'I') { \/\/ Check for Infinity strings\n-                if((len-i)==INFINITY_LENGTH && in.indexOf(INFINITY_REP,i)==i) {\n-                    return isNegative? A2BC_NEGATIVE_INFINITY : A2BC_POSITIVE_INFINITY;\n-                }\n-                \/\/ something went wrong, throw exception\n-                break parseNumber;\n-            } else if (c == '0')  { \/\/ check for hexadecimal floating-point number\n-                if (len > i+1 ) {\n-                    char ch = in.charAt(i+1);\n-                    if (ch == 'x' || ch == 'X' ) { \/\/ possible hex string\n-                        return parseHexString(in);\n-                    }\n-                }\n-            }  \/\/ look for and process decimal floating-point string\n-\n-            char[] digits = new char[ len ];\n-            boolean decSeen = false;\n-            int nDigits = 0;\n-            int decPt = 0;\n-            int nLeadZero = 0;\n-            int nTrailZero = 0;\n-\n-        skipLeadingZerosLoop:\n-            while (i < len) {\n-                c = in.charAt(i);\n-                if (c == '0') {\n-                    nLeadZero++;\n-                } else if (c == '.') {\n-                    if (decSeen) {\n-                        \/\/ already saw one ., this is the 2nd.\n-                        throw new NumberFormatException(\"multiple points\");\n-                    }\n-                    decPt = i;\n-                    if (signSeen) {\n-                        decPt -= 1;\n-                    }\n-                    decSeen = true;\n-                } else {\n-                    break skipLeadingZerosLoop;\n-                }\n-                i++;\n-            }\n-        digitLoop:\n-            while (i < len) {\n-                c = in.charAt(i);\n-                if (c >= '1' && c <= '9') {\n-                    digits[nDigits++] = c;\n-                    nTrailZero = 0;\n-                } else if (c == '0') {\n-                    digits[nDigits++] = c;\n-                    nTrailZero++;\n-                } else if (c == '.') {\n-                    if (decSeen) {\n-                        \/\/ already saw one ., this is the 2nd.\n-                        throw new NumberFormatException(\"multiple points\");\n-                    }\n-                    decPt = i;\n-                    if (signSeen) {\n-                        decPt -= 1;\n-                    }\n-                    decSeen = true;\n-                } else {\n-                    break digitLoop;\n-                }\n-                i++;\n+    \/**\n+     * The input must match the {@link Double#valueOf(String) rules described here},\n+     * about leading and trailing whitespaces, and the grammar.\n+     *\n+     * @param in the non-null input\n+     * @param ix one of the {@code BINARY_<S>_IX} constants, where {@code <S>}\n+     *          is one of 16, 32, 64\n+     * @return an appropriate binary converter\n+     * @throws NullPointerException if the input is null\n+     * @throws NumberFormatException if the input is malformed\n+     *\/\n+    static ASCIIToBinaryConverter readJavaFormatString(String in, int ix) {\n+        \/*\n+         * The scanning proper does not allocate any object,\n+         * nor does it perform any costly computation.\n+         * This means that all scanning errors are detected without consuming\n+         * any heap, before actually throwing.\n+         *\n+         * Once scanning is complete, the method determines the length\n+         * of a prefix of the significand that is sufficient for correct\n+         * rounding according to roundTiesToEven.\n+         * The actual value of the prefix length might not be optimal,\n+         * but is always a safe choice.\n+         *\n+         * For hexadecimal input, the prefix is processed by this method directly,\n+         * without allocating objects before creating the returned instance.\n+         *\n+         * For decimal input, the prefix is copied to the returned instance,\n+         * along with the other information needed for the conversion.\n+         * For comparison, the prefix length is at most\n+         *       23 for BINARY_16_IX (Float16, once integrated in java.base)\n+         *      114 for BINARY_32_IX (float)\n+         *      769 for BINARY_64_IX (double)\n+         *\/\n+        int len = in.length();  \/\/ fail fast on null\n+\n+        \/* Skip leading whitespaces. *\/\n+        int i = skipWhitespaces(in, 0);  \/\/ main running index\n+        if (i == len) {\n+            throw new NumberFormatException(\"empty String\");\n+        }\n+\n+        \/* Scan opt significand sign. *\/\n+        int ch;  \/\/ running char\n+        int ssign = ' ';  \/\/ ' ' iff sign is implicit\n+        if ((ch = in.charAt(i)) == '-' || ch == '+') {  \/\/ i < len\n+            ssign = ch;\n+            ++i;\n+        }\n+\n+        \/*\n+         * In some places the idiom\n+         *      (ch | 0b10_0000) == lowercase-letter\n+         * is used as a shortcut for\n+         *      ch == lowercase-letter || ch == that-same-letter-as-uppercase\n+         *\n+         * Determine whether we are facing a symbolic value or hex notation.\n+         *\/\n+        boolean isDec = true;  \/\/ decimal input until proven to the contrary\n+        if (i < len) {\n+            ch = in.charAt(i);\n+            if (ch == 'I') {\n+                scanSymbolic(in, i, \"Infinity\");\n+                return ssign != '-' ? A2BC_POSITIVE_INFINITY : A2BC_NEGATIVE_INFINITY;\n@@ -1926,26 +1892,3 @@\n-            nDigits -=nTrailZero;\n-            \/\/\n-            \/\/ At this point, we've scanned all the digits and decimal\n-            \/\/ point we're going to see. Trim off leading and trailing\n-            \/\/ zeros, which will just confuse us later, and adjust\n-            \/\/ our initial decimal exponent accordingly.\n-            \/\/ To review:\n-            \/\/ we have seen i total characters.\n-            \/\/ nLeadZero of them were zeros before any other digits.\n-            \/\/ nTrailZero of them were zeros after any other digits.\n-            \/\/ if ( decSeen ), then a . was seen after decPt characters\n-            \/\/ ( including leading zeros which have been discarded )\n-            \/\/ nDigits characters were neither lead nor trailing\n-            \/\/ zeros, nor point\n-            \/\/\n-            \/\/\n-            \/\/ special hack: if we saw no non-zero digits, then the\n-            \/\/ answer is zero!\n-            \/\/ Unfortunately, we feel honor-bound to keep parsing!\n-            \/\/\n-            boolean isZero = (nDigits == 0);\n-            if ( isZero &&  nLeadZero == 0 ){\n-                \/\/ we saw NO DIGITS AT ALL,\n-                \/\/ not even a crummy 0!\n-                \/\/ this is not allowed.\n-                break parseNumber; \/\/ go throw exception\n+            if (ch == 'N') {\n+                scanSymbolic(in, i, \"NaN\");\n+                return A2BC_NOT_A_NUMBER;  \/\/ ignore sign\n@@ -1953,9 +1896,3 @@\n-            \/\/\n-            \/\/ Our initial exponent is decPt, adjusted by the number of\n-            \/\/ discarded zeros. Or, if there was no decPt,\n-            \/\/ then its just nDigits adjusted by discarded trailing zeros.\n-            \/\/\n-            if ( decSeen ){\n-                decExp = decPt - nLeadZero;\n-            } else {\n-                decExp = nDigits + nTrailZero;\n+            if (ch == '0' && i < len - 1 && (in.charAt(i + 1) | 0b10_0000) == 'x') {\n+                isDec = false;\n+                i += 2;\n@@ -1963,0 +1900,1 @@\n+        }\n@@ -1964,62 +1902,2 @@\n-            \/\/\n-            \/\/ Look for 'e' or 'E' and an optionally signed integer.\n-            \/\/\n-            if ( (i < len) &&  (((c = in.charAt(i) )=='e') || (c == 'E') ) ){\n-                int expSign = 1;\n-                int expVal  = 0;\n-                int reallyBig = Integer.MAX_VALUE \/ 10;\n-                boolean expOverflow = false;\n-                switch( in.charAt(++i) ){\n-                case '-':\n-                    expSign = -1;\n-                    \/\/FALLTHROUGH\n-                case '+':\n-                    i++;\n-                }\n-                int expAt = i;\n-            expLoop:\n-                while ( i < len  ){\n-                    if ( expVal >= reallyBig ){\n-                        \/\/ the next character will cause integer\n-                        \/\/ overflow.\n-                        expOverflow = true;\n-                    }\n-                    c = in.charAt(i++);\n-                    if(c>='0' && c<='9') {\n-                        expVal = expVal*10 + ( (int)c - (int)'0' );\n-                    } else {\n-                        i--;           \/\/ back up.\n-                        break expLoop; \/\/ stop parsing exponent.\n-                    }\n-                }\n-                int expLimit = BIG_DECIMAL_EXPONENT + nDigits + nTrailZero;\n-                if (expOverflow || (expVal > expLimit)) {\n-                    \/\/ There is still a chance that the exponent will be safe to\n-                    \/\/ use: if it would eventually decrease due to a negative\n-                    \/\/ decExp, and that number is below the limit.  We check for\n-                    \/\/ that here.\n-                    if (!expOverflow && (expSign == 1 && decExp < 0)\n-                            && (expVal + decExp) < expLimit) {\n-                        \/\/ Cannot overflow: adding a positive and negative number.\n-                        decExp += expVal;\n-                    } else {\n-                        \/\/\n-                        \/\/ The intent here is to end up with\n-                        \/\/ infinity or zero, as appropriate.\n-                        \/\/ The reason for yielding such a small decExponent,\n-                        \/\/ rather than something intuitive such as\n-                        \/\/ expSign*Integer.MAX_VALUE, is that this value\n-                        \/\/ is subject to further manipulation in\n-                        \/\/ doubleValue() and floatValue(), and I don't want\n-                        \/\/ it to be able to cause overflow there!\n-                        \/\/ (The only way we can get into trouble here is for\n-                        \/\/ really outrageous nDigits+nTrailZero, such as 2\n-                        \/\/ billion.)\n-                        \/\/\n-                        decExp = expSign * expLimit;\n-                    }\n-                } else {\n-                    \/\/ this should not overflow, since we tested\n-                    \/\/ for expVal > (MAX+N), where N >= abs(decExp)\n-                    decExp = decExp + expSign*expVal;\n-                }\n+        int pt = 0;  \/\/ index after point, 0 iff absent\n+        int start = i;  \/\/ index of start of the significand, excluding opt sign\n@@ -2027,9 +1905,5 @@\n-                \/\/ if we saw something not a digit ( or end of string )\n-                \/\/ after the [Ee][+-], without seeing any digits at all\n-                \/\/ this is certainly an error. If we saw some digits,\n-                \/\/ but then some trailing garbage, that might be ok.\n-                \/\/ so we just fall through in that case.\n-                \/\/ HUMBUG\n-                if ( i == expAt ) {\n-                    break parseNumber; \/\/ certainly bad\n-                }\n+        \/* Skip opt leading zeros, including an opt point. *\/\n+        while (i < len && ((ch = in.charAt(i)) == '0' || ch == '.')) {\n+            ++i;\n+            if (ch == '.') {\n+                pt = checkMultiplePoints(pt, i);\n@@ -2037,11 +1911,15 @@\n-            \/\/\n-            \/\/ We parsed everything we could.\n-            \/\/ If there are leftovers, then this is not good input!\n-            \/\/\n-            if ( i < len &&\n-                ((i != len - 1) ||\n-                (in.charAt(i) != 'f' &&\n-                 in.charAt(i) != 'F' &&\n-                 in.charAt(i) != 'd' &&\n-                 in.charAt(i) != 'D'))) {\n-                break parseNumber; \/\/ go throw exception\n+        }\n+        int lz = i;  \/\/ index after leading group of zeros or point\n+\n+        \/*\n+         * Scan all remaining chars of the significand, including an opt point.\n+         * Also locate the index after the end of the trailing group of non-zeros\n+         * inside this range of the input.\n+         *\/\n+        int tnz = 0;  \/\/ index after trailing group of non-zeros, 0 iff absent\n+        while (i < len && (isDigit(ch = in.charAt(i), isDec) || ch == '.')) {\n+            i++;\n+            if (ch == '.') {\n+                pt = checkMultiplePoints(pt, i);\n+            } else if (ch != '0') {\n+                tnz = i;\n@@ -2049,2 +1927,16 @@\n-            if(isZero) {\n-                return isNegative ? A2BC_NEGATIVE_ZERO : A2BC_POSITIVE_ZERO;\n+        }\n+        check(in, i - start > (pt != 0 ? 1 : 0));  \/\/ must have at least one digit\n+        int stop = i;  \/\/ index after the significand\n+\n+        \/* Scan exponent part, optional for dec, mandatory for hex. *\/\n+        long ep = 0;  \/\/ exponent, implicitly 0\n+        boolean hasExp = false;\n+        if (i < len && ((ch = in.charAt(i) | 0b10_0000) == 'e' && isDec\n+                || ch == 'p' && !isDec)) {\n+            ++i;\n+\n+            \/* Scan opt exponent sign. *\/\n+            int esign = ' ';  \/\/ esign == ' ' iff the sign is implicit\n+            if (i < len && ((ch = in.charAt(i)) == '-' || ch == '+')) {\n+                esign = ch;\n+                ++i;\n@@ -2052,4 +1944,0 @@\n-            return new ASCIIToBinaryBuffer(isNegative, decExp, digits, nDigits);\n-        } catch ( StringIndexOutOfBoundsException e ){ }\n-        throw new NumberFormatException(\"For input string: \\\"\" + in + \"\\\"\");\n-    }\n@@ -2057,4 +1945,15 @@\n-    private static class HexFloatPattern {\n-        \/**\n-         * Grammar is compatible with hexadecimal floating-point constants\n-         * described in section 6.4.4.2 of the C99 specification.\n+            \/* Scan the exponent digits. Accumulate in ep, clamping at 10^10. *\/\n+            while (i < len && isDigit(ch = in.charAt(i), true)) {  \/\/ ep is decimal\n+                ++i;\n+                ep = appendDecDigit(ep, ch);\n+            }\n+            check(in, i - stop >= 3  \/\/ at least 3 chars after significand\n+                    || i - stop == 2 && esign == ' ');  \/\/ 2 chars, one is digit\n+            if (esign == '-') {\n+                ep = -ep;\n+            }\n+            hasExp = true;\n+        }\n+        \/*\n+         * |ep| < 10^10, or |ep| = 10^10 when considered \"large\".\n+         * A \"large\" ep either generates a zero or an infinity.\n@@ -2062,5 +1961,1 @@\n-        private static final Pattern VALUE = Pattern.compile(\n-                   \/\/1           234                   56                7                   8      9\n-                    \"([-+])?0[xX](((\\\\p{XDigit}+)\\\\.?)|((\\\\p{XDigit}*)\\\\.(\\\\p{XDigit}+)))[pP]([-+])?(\\\\p{Digit}+)[fFdD]?\"\n-                    );\n-    }\n+        check(in, isDec | hasExp);\n@@ -2068,116 +1963,4 @@\n-    \/**\n-     * Converts string s to a suitable floating decimal; uses the\n-     * double constructor and sets the roundDir variable appropriately\n-     * in case the value is later converted to a float.\n-     *\n-     * @param s The <code>String<\/code> to parse.\n-     *\/\n-   static ASCIIToBinaryConverter parseHexString(String s) {\n-            \/\/ Verify string is a member of the hexadecimal floating-point\n-            \/\/ string language.\n-            Matcher m = HexFloatPattern.VALUE.matcher(s);\n-            boolean validInput = m.matches();\n-            if (!validInput) {\n-                \/\/ Input does not match pattern\n-                throw new NumberFormatException(\"For input string: \\\"\" + s + \"\\\"\");\n-            } else { \/\/ validInput\n-                \/\/\n-                \/\/ We must isolate the sign, significand, and exponent\n-                \/\/ fields.  The sign value is straightforward.  Since\n-                \/\/ floating-point numbers are stored with a normalized\n-                \/\/ representation, the significand and exponent are\n-                \/\/ interrelated.\n-                \/\/\n-                \/\/ After extracting the sign, we normalized the\n-                \/\/ significand as a hexadecimal value, calculating an\n-                \/\/ exponent adjust for any shifts made during\n-                \/\/ normalization.  If the significand is zero, the\n-                \/\/ exponent doesn't need to be examined since the output\n-                \/\/ will be zero.\n-                \/\/\n-                \/\/ Next the exponent in the input string is extracted.\n-                \/\/ Afterwards, the significand is normalized as a *binary*\n-                \/\/ value and the input value's normalized exponent can be\n-                \/\/ computed.  The significand bits are copied into a\n-                \/\/ double significand; if the string has more logical bits\n-                \/\/ than can fit in a double, the extra bits affect the\n-                \/\/ round and sticky bits which are used to round the final\n-                \/\/ value.\n-                \/\/\n-                \/\/  Extract significand sign\n-                String group1 = m.group(1);\n-                boolean isNegative = ((group1 != null) && group1.equals(\"-\"));\n-\n-                \/\/  Extract Significand magnitude\n-                \/\/\n-                \/\/ Based on the form of the significand, calculate how the\n-                \/\/ binary exponent needs to be adjusted to create a\n-                \/\/ normalized\/\/hexadecimal* floating-point number; that\n-                \/\/ is, a number where there is one nonzero hex digit to\n-                \/\/ the left of the (hexa)decimal point.  Since we are\n-                \/\/ adjusting a binary, not hexadecimal exponent, the\n-                \/\/ exponent is adjusted by a multiple of 4.\n-                \/\/\n-                \/\/ There are a number of significand scenarios to consider;\n-                \/\/ letters are used in indicate nonzero digits:\n-                \/\/\n-                \/\/ 1. 000xxxx       =>      x.xxx   normalized\n-                \/\/    increase exponent by (number of x's - 1)*4\n-                \/\/\n-                \/\/ 2. 000xxx.yyyy =>        x.xxyyyy        normalized\n-                \/\/    increase exponent by (number of x's - 1)*4\n-                \/\/\n-                \/\/ 3. .000yyy  =>   y.yy    normalized\n-                \/\/    decrease exponent by (number of zeros + 1)*4\n-                \/\/\n-                \/\/ 4. 000.00000yyy => y.yy normalized\n-                \/\/    decrease exponent by (number of zeros to right of point + 1)*4\n-                \/\/\n-                \/\/ If the significand is exactly zero, return a properly\n-                \/\/ signed zero.\n-                \/\/\n-\n-                String significandString;\n-                int signifLength;\n-                int exponentAdjust;\n-                {\n-                    int leftDigits = 0; \/\/ number of meaningful digits to\n-                    \/\/ left of \"decimal\" point\n-                    \/\/ (leading zeros stripped)\n-                    int rightDigits = 0; \/\/ number of digits to right of\n-                    \/\/ \"decimal\" point; leading zeros\n-                    \/\/ must always be accounted for\n-                    \/\/\n-                    \/\/ The significand is made up of either\n-                    \/\/\n-                    \/\/ 1. group 4 entirely (integer portion only)\n-                    \/\/\n-                    \/\/ OR\n-                    \/\/\n-                    \/\/ 2. the fractional portion from group 7 plus any\n-                    \/\/ (optional) integer portions from group 6.\n-                    \/\/\n-                    String group4;\n-                    if ((group4 = m.group(4)) != null) {  \/\/ Integer-only significand\n-                        \/\/ Leading zeros never matter on the integer portion\n-                        significandString = stripLeadingZeros(group4);\n-                        leftDigits = significandString.length();\n-                    } else {\n-                        \/\/ Group 6 is the optional integer; leading zeros\n-                        \/\/ never matter on the integer portion\n-                        String group6 = stripLeadingZeros(m.group(6));\n-                        leftDigits = group6.length();\n-\n-                        \/\/ fraction\n-                        String group7 = m.group(7);\n-                        rightDigits = group7.length();\n-\n-                        \/\/ Turn \"integer.fraction\" into \"integer\"+\"fraction\"\n-                        significandString =\n-                                ((group6 == null) ? \"\" : group6) + \/\/ is the null\n-                                        \/\/ check necessary?\n-                                        group7;\n-                    }\n-\n-                    significandString = stripLeadingZeros(significandString);\n-                    signifLength = significandString.length();\n+        \/* Skip opt [FfDd]? suffix. *\/\n+        if (i < len && (((ch = in.charAt(i) | 0b10_0000)) == 'f' || ch == 'd')) {\n+            ++i;\n+        }\n@@ -2185,8 +1968,2 @@\n-                    \/\/\n-                    \/\/ Adjust exponent as described above\n-                    \/\/\n-                    if (leftDigits >= 1) {  \/\/ Cases 1 and 2\n-                        exponentAdjust = 4 * (leftDigits - 1);\n-                    } else {                \/\/ Cases 3 and 4\n-                        exponentAdjust = -4 * (rightDigits - signifLength + 1);\n-                    }\n+        \/* Skip optional trailing whitespaces, then must be at the end of input. *\/\n+        check(in, skipWhitespaces(in, i) == len);\n@@ -2194,2 +1971,4 @@\n-                    \/\/ If the significand is zero, the exponent doesn't\n-                    \/\/ matter; return a properly signed zero.\n+        \/* By now, the input is syntactically correct. *\/\n+        if (tnz == 0) {  \/\/ all zero digits, so ignore ep and point\n+            return ssign != '-' ? A2BC_POSITIVE_ZERO : A2BC_NEGATIVE_ZERO;\n+        }\n@@ -2197,4 +1976,67 @@\n-                    if (signifLength == 0) { \/\/ Only zeros in input\n-                        return isNegative ? A2BC_NEGATIVE_ZERO : A2BC_POSITIVE_ZERO;\n-                    }\n-                }\n+        \/*\n+         * Virtually adjust the point position to be just after\n+         * the last non-zero digit by adjusting the exponent accordingly\n+         * (without modifying the physical pt, as it is used later on).\n+         *\n+         * Determine the count of digits, excluding leading and trailing zeros.\n+         *\n+         * These are the possible situations:\n+         *         |lz               |tnz     |stop\n+         * 00000000123456000000234567000000000\n+         *\n+         *  |pt     |lz               |tnz     |stop\n+         * .00000000123456000000234567000000000\n+         *\n+         *    |pt   |lz               |tnz     |stop\n+         * 00.000000123456000000234567000000000\n+         *\n+         *          |pt=lz            |tnz     |stop\n+         * 00000000.123456000000234567000000000\n+         *\n+         *         |lz  |pt           |tnz     |stop\n+         * 000000001234.56000000234567000000000\n+         *\n+         *         |lz      |pt       |tnz     |stop\n+         * 0000000012345600.0000234567000000000\n+         *\n+         *         |lz          |pt   |tnz     |stop\n+         * 00000000123456000000.234567000000000\n+         *\n+         *         |lz            |pt |tnz     |stop\n+         * 0000000012345600000023.4567000000000\n+         *\n+         *         |lz                |pt=tnz  |stop\n+         * 00000000123456000000234567.000000000\n+         *\n+         *         |lz               |tnz  |pt |stop\n+         * 0000000012345600000023456700000.0000\n+         *\n+         *         |lz               |tnz      |pt=stop\n+         * 00000000123456000000234567000000000.\n+         *\n+         * In decimal, moving the point by one position means correcting ep by 1.\n+         * In hexadecimal, it means correcting ep by 4.\n+         *\/\n+        long emult = isDec ? 1L : 4L;\n+        int n = tnz - lz;  \/\/ number of significant digits, 1st approximation\n+        if (pt == 0) {\n+            ep += emult * (stop - tnz);\n+        } else {\n+            ep += emult * (pt - tnz);\n+            if (pt > tnz) {  \/\/ '.' was counted as a position, adjust ep\n+                ep -= emult;\n+            } else if (lz < pt) {  \/\/ lz < pt <= tnz\n+                n -= 1;\n+            }\n+        }\n+        \/*\n+         * n = number of significant digits (that is, not counting leading nor\n+         * trailing zeros)\n+         * |ep| < 10^11\n+         *\n+         * The magnitude x of the input meets\n+         *      x = f 10^ep  (decimal)\n+         *      x = f 2^ep  (hexadecimal)\n+         * Integer f = <f_1 ... f_n> consists of the n decimal or hexadecimal\n+         * digits found in part [lz, tnz) of the input, and f_1 != 0, f_n != 0.\n+         *\/\n@@ -2202,13 +2044,14 @@\n-                \/\/  Extract Exponent\n-                \/\/\n-                \/\/ Use an int to read in the exponent value; this should\n-                \/\/ provide more than sufficient range for non-contrived\n-                \/\/ inputs.  If reading the exponent in as an int does\n-                \/\/ overflow, examine the sign of the exponent and\n-                \/\/ significand to determine what to do.\n-                \/\/\n-                String group8 = m.group(8);\n-                boolean positiveExponent = (group8 == null) || group8.equals(\"+\");\n-                long unsignedRawExponent;\n-                try {\n-                    unsignedRawExponent = Integer.parseInt(m.group(9));\n+        if (!isDec) {  \/\/ hexadecimal conversion is performed entirely here\n+            \/*\n+             * Rounding the leftmost P bits +1 rounding bit +1 sticky bit\n+             * has the same outcome as rounding all bits.\n+             * In terms of hex digits, we need room for HEX_COUNT of them.\n+             *\/\n+            int j = 0;\n+            i = lz;\n+            long c = 0;\n+            int le = Math.min(n, HEX_COUNT[ix]);\n+            while (j < le) {\n+                if ((ch = in.charAt(i++)) != '.') {\n+                    ++j;\n+                    c = c << 4 | digitFor(ch);\n@@ -2216,17 +2059,5 @@\n-                catch (NumberFormatException e) {\n-                    \/\/ At this point, we know the exponent is\n-                    \/\/ syntactically well-formed as a sequence of\n-                    \/\/ digits.  Therefore, if an NumberFormatException\n-                    \/\/ is thrown, it must be due to overflowing int's\n-                    \/\/ range.  Also, at this point, we have already\n-                    \/\/ checked for a zero significand.  Thus the signs\n-                    \/\/ of the exponent and significand determine the\n-                    \/\/ final result:\n-                    \/\/\n-                    \/\/                      significand\n-                    \/\/                      +               -\n-                    \/\/ exponent     +       +infinity       -infinity\n-                    \/\/              -       +0.0            -0.0\n-                    return isNegative ?\n-                              (positiveExponent ? A2BC_NEGATIVE_INFINITY : A2BC_NEGATIVE_ZERO)\n-                            : (positiveExponent ? A2BC_POSITIVE_INFINITY : A2BC_POSITIVE_ZERO);\n+            }\n+            if (n > le) {\n+                c |= 0b1;  \/\/ force a sticky bit\n+                ep += 4L * (n - le);\n+            }\n@@ -2234,0 +2065,31 @@\n+            int bl = Long.SIZE - Long.numberOfLeadingZeros(c);  \/\/ bit length\n+            \/*\n+             * Let x = c 2^ep, so 2^(ep+bl-1) <= x < 2^(ep+bl)\n+             * When ep + bl < Q_MIN then x certainly rounds to zero.\n+             * When ep + bl - 1 > E_MAX then x surely rounds to infinity.\n+             *\/\n+            if (ep < Q_MIN[ix] - bl) {\n+                return buildZero(ix, ssign);\n+            }\n+            if (ep > E_MAX[ix] - bl + 1) {\n+                return buildInfinity(ix, ssign);\n+            }\n+            int q = (int) ep;  \/\/ narrowing conversion is safe\n+            int shr;  \/\/ (sh)ift to (r)ight iff shr > 0\n+            if (q > E_MIN[ix] - bl) {\n+                shr = bl - P[ix];\n+                q += shr;\n+            } else {\n+                shr = Q_MIN[ix] - q;\n+                q = Q_MIN[ix];\n+            }\n+            if (shr > 0) {\n+                long thr = 1L << shr;\n+                long tail = (c & thr - 1) << 1;\n+                c >>>= shr;\n+                if (tail > thr || tail == thr && (c & 0b1) != 0) {\n+                    c += 1;\n+                    if (c >= 1L << P[ix]) {  \/\/ but in fact it can't be >\n+                        c >>>= 1;\n+                        q += 1;\n+                    }\n@@ -2235,0 +2097,3 @@\n+            } else {\n+                c <<= -shr;\n+            }\n@@ -2236,6 +2101,9 @@\n-                long rawExponent =\n-                        (positiveExponent ? 1L : -1L) * \/\/ exponent sign\n-                                unsignedRawExponent;            \/\/ exponent magnitude\n-\n-                \/\/ Calculate partially adjusted exponent\n-                long exponent = rawExponent + exponentAdjust;\n+            \/* For now throw on BINARY_16_IX, until Float16 is integrated in java.base. *\/\n+            return switch (ix) {\n+                case BINARY_32_IX ->\n+                        new PreparedASCIIToBinaryBuffer(Double.NaN, buildFloat(ssign, q, c));\n+                case BINARY_64_IX ->\n+                        new PreparedASCIIToBinaryBuffer(buildDouble(ssign, q, c), Float.NaN);\n+                default -> throw new AssertionError(\"unexpected\");\n+            };\n+        }\n@@ -2243,3 +2111,19 @@\n-                \/\/ Starting copying non-zero bits into proper position in\n-                \/\/ a long; copy explicit bit too; this will be masked\n-                \/\/ later for normal values.\n+        \/*\n+         * For decimal inputs, we copy an appropriate prefix of the input and\n+         * rely on another method to do the (sometimes intensive) math conversion.\n+         *\n+         * Define e' = n + ep, which leads to\n+         *      x = <0 . f_1 ... f_n> 10^e', 10^(e'-1) <= x < 10^e'\n+         * If e' <= EP_MIN then x rounds to zero.\n+         * Similarly, if e' >= EP_MAX then x rounds to infinity.\n+         * (See the comments on the fields for their semantics.)\n+         * We return immediately in these cases.\n+         * Otherwise, e' fits in an int named e.\n+         *\/\n+        int e = Math.clamp(ep + n, EP_MIN[ix], EP_MAX[ix]);\n+        if (e == EP_MIN[ix]) {  \/\/ e' <= E_MIN\n+            return ssign != '-' ? A2BC_POSITIVE_ZERO : A2BC_NEGATIVE_ZERO;\n+        }\n+        if (e == EP_MAX[ix]) {  \/\/ e' >= E_MAX\n+            return ssign != '-' ? A2BC_POSITIVE_INFINITY : A2BC_NEGATIVE_INFINITY;\n+        }\n@@ -2247,7 +2131,72 @@\n-                boolean round = false;\n-                boolean sticky = false;\n-                int nextShift;\n-                long significand = 0L;\n-                \/\/ First iteration is different, since we only copy\n-                \/\/ from the leading significand bit; one more exponent\n-                \/\/ adjust will be needed...\n+        \/*\n+         * For further considerations, x also needs to be seen as\n+         *      x = beta 2^q\n+         * with real beta and integer q meeting\n+         *      2^(P-1) <= beta < 2^P and q >= Q_MIN\n+         *      0 < beta < 2^(P-1) and q = Q_MIN\n+         * The (unique) solution is\n+         *      q = max(floor(log2(x)) - (P-1), Q_MIN), beta = x 2^(-q)\n+         * It's usually costly to determine q as here.\n+         * However, estimates to q are cheaper and quick to compute.\n+         *\n+         * Indeed, it's a matter of some simple maths to show that, by defining\n+         *      ql = max(floor((e-1) log2(10)) - (P-1), Q_MIN)\n+         *      qh = max(floor(e log2(10)) - (P-1), Q_MIN)\n+         * then the following hold\n+         *      ql <= q <= qh, and qh - ql <= 4\n+         * Since by now e is relatively small, we can leverage flog2pow10().\n+         *\n+         * When q >= Q_MIN, consider the interval [ 2^(P-1+q), 2^(P+q) ).\n+         * It contains all floating-point values of the form\n+         *      c 2^q, c integer, 2^(P-1) <= c < 2^P (normal values)\n+         * When q = Q_MIN also consider the interval [0, 2^(P-1+q) )\n+         * which contains all floating-point values of the form\n+         *      c 2^q, c integer, 0 <= c < 2^(P-1) (subnormal values and zero)\n+         * For these c values, all numbers of the form\n+         *      (c + 1\/2) 2^q\n+         * also belong to the intervals.\n+         * These are the boundaries of the rounding intervals and are key for\n+         * correct rounding.\n+         *\n+         * First assume ql > 0, so q > 0.\n+         * All rounding boundaries (c + 1\/2) 2^q are integers.\n+         * Hence, to correctly round x, it's enough to retain its integer part,\n+         * +1 non-zero sticky digit iff the fractional part is non-zero.\n+         * (Well, the sticky digit is only needed when the integer part\n+         * coincides with a boundary, but that's hard to detect at this stage.\n+         * Adding the sticky digit is always safe.)\n+         * If n > e we pass the digits <f_1 ... f_e 3> (3 is as good as any other\n+         * non-zero sticky digit) and the exponent e to the conversion routine.\n+         * If n <= e we pass all the digits <f_1 ... f_n> (no sticky digit,\n+         * as the fractional part is empty) and the exponent e to the converter.\n+         *\n+         * Now assume qh <= 0, so q <= 0.\n+         * The boundaries (c + 1\/2) 2^q = (2c + 1) 2^(q-1) have a fractional part\n+         * of 1 - q digits: some (or zero) leading zeros, the rightmost is 5.\n+         * A correct rounding needs to retain the integer part of x (if any),\n+         * 1 - q digits of the fractional part, +1 non-zero sticky digit iff\n+         * the rest of the fractional part beyond the 1 - q digits is non-zero.\n+         * (Again, the sticky digit is only needed when the digit in f at the\n+         * same position as the last 5 of the rounding boundary is 5 as well.\n+         * But let's keep it simple for now.)\n+         * However, q is unknown, so use the conservative ql instead.\n+         * More precisely, if n > e + 1 - ql we pass the leftmost e + 1 - ql\n+         * digits of f, sticky 3, and e.\n+         * Otherwise, n <= e + 1 - ql.\n+         * We pass all n digits of f, no sticky digit, and e to the converter.\n+         *\n+         * Otherwise, ql <= 0 < qh, so -4 < q <= 4.\n+         * Again, since q is not known exactly, we proceed as in the previous\n+         * case, with ql as a safe replacement for q.\n+         *\/\n+        int ql = Math.max(MathUtils.flog2pow10(e - 1) - (P[ix] - 1), Q_MIN[ix]);\n+        int np = e + Math.max(2 - ql, 1);\n+        char[] digits = new char[Math.min(n, np)];\n+        if (n >= np) {\n+            copyDigits(in, digits, np - 1, lz);\n+            digits[np - 1] = '3';  \/\/ append any non-zero sticky digit\n+        } else {\n+            copyDigits(in, digits, n, lz);\n+        }\n+        return new ASCIIToBinaryBuffer(ssign == '-', e, digits, digits.length);\n+    }\n@@ -2255,3 +2204,14 @@\n-                \/\/ IMPORTANT: make leadingDigit a long to avoid\n-                \/\/ surprising shift semantics!\n-                long leadingDigit = getHexDigit(significandString, 0);\n+    private static PreparedASCIIToBinaryBuffer buildZero(int ix, int ssign) {\n+        \/* For now throw on BINARY_16_IX, until Float16 is integrated in java.base. *\/\n+        return switch (ix) {\n+            case BINARY_32_IX ->\n+                    new PreparedASCIIToBinaryBuffer(\n+                            Double.NaN,\n+                            ssign != '-' ? 0.0f : -0.0f);\n+            case BINARY_64_IX ->\n+                    new PreparedASCIIToBinaryBuffer(\n+                            ssign != '-' ? 0.0d : -0.0d,\n+                            Float.NaN);\n+            default -> throw new AssertionError(\"unexpected\");\n+        };\n+    }\n@@ -2259,31 +2219,14 @@\n-                \/\/\n-                \/\/ Left shift the leading digit (53 - (bit position of\n-                \/\/ leading 1 in digit)); this sets the top bit of the\n-                \/\/ significand to 1.  The nextShift value is adjusted\n-                \/\/ to take into account the number of bit positions of\n-                \/\/ the leadingDigit actually used.  Finally, the\n-                \/\/ exponent is adjusted to normalize the significand\n-                \/\/ as a binary value, not just a hex value.\n-                \/\/\n-                if (leadingDigit == 1) {\n-                    significand |= leadingDigit << 52;\n-                    nextShift = 52 - 4;\n-                    \/\/ exponent += 0\n-                } else if (leadingDigit <= 3) { \/\/ [2, 3]\n-                    significand |= leadingDigit << 51;\n-                    nextShift = 52 - 5;\n-                    exponent += 1;\n-                } else if (leadingDigit <= 7) { \/\/ [4, 7]\n-                    significand |= leadingDigit << 50;\n-                    nextShift = 52 - 6;\n-                    exponent += 2;\n-                } else if (leadingDigit <= 15) { \/\/ [8, f]\n-                    significand |= leadingDigit << 49;\n-                    nextShift = 52 - 7;\n-                    exponent += 3;\n-                } else {\n-                    throw new AssertionError(\"Result from digit conversion too large!\");\n-                }\n-                \/\/ The preceding if-else could be replaced by a single\n-                \/\/ code block based on the high-order bit set in\n-                \/\/ leadingDigit.  Given leadingOnePosition,\n+    private static PreparedASCIIToBinaryBuffer buildInfinity(int ix, int ssign) {\n+        \/* For now throw on BINARY_16_IX, until Float16 is integrated in java.base. *\/\n+        return switch (ix) {\n+            case BINARY_32_IX ->\n+                    new PreparedASCIIToBinaryBuffer(\n+                            Double.NaN,\n+                            ssign != '-' ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY);\n+            case BINARY_64_IX ->\n+                    new PreparedASCIIToBinaryBuffer(\n+                            ssign != '-' ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY,\n+                            Float.NaN);\n+            default -> throw new AssertionError(\"unexpected\");\n+        };\n+    }\n@@ -2291,3 +2234,9 @@\n-                \/\/ significand |= leadingDigit << (SIGNIFICAND_WIDTH - leadingOnePosition);\n-                \/\/ nextShift = 52 - (3 + leadingOnePosition);\n-                \/\/ exponent += (leadingOnePosition-1);\n+    private static double buildDouble(int ssign, int q, long c) {\n+        long be = c < 1L << P[BINARY_64_IX] - 1\n+                ? 0\n+                : q + ((DoubleConsts.EXP_BIAS - 1) + P[BINARY_64_IX]);\n+        long bits = (ssign != '-' ? 0L : 1L << Double.SIZE - 1)\n+                | be << P[BINARY_64_IX] - 1\n+                | c & DoubleConsts.SIGNIF_BIT_MASK;\n+        return Double.longBitsToDouble(bits);\n+    }\n@@ -2295,7 +2244,9 @@\n-                \/\/\n-                \/\/ Now the exponent variable is equal to the normalized\n-                \/\/ binary exponent.  Code below will make representation\n-                \/\/ adjustments if the exponent is incremented after\n-                \/\/ rounding (includes overflows to infinity) or if the\n-                \/\/ result is subnormal.\n-                \/\/\n+    private static float buildFloat(int ssign, int q, long c) {\n+        int be = c < 1L << P[BINARY_32_IX] - 1\n+                ? 0\n+                : q + ((FloatConsts.EXP_BIAS - 1) + P[BINARY_32_IX]);\n+        int bits = (ssign != '-' ? 0 : 1 << Float.SIZE - 1)\n+                | be << P[BINARY_32_IX] - 1\n+                | (int) c & FloatConsts.SIGNIF_BIT_MASK;\n+        return Float.intBitsToFloat(bits);\n+    }\n@@ -2303,11 +2254,9 @@\n-                \/\/ Copy digit into significand until the significand can't\n-                \/\/ hold another full hex digit or there are no more input\n-                \/\/ hex digits.\n-                int i = 0;\n-                for (i = 1;\n-                     i < signifLength && nextShift >= 0;\n-                     i++) {\n-                    long currentDigit = getHexDigit(significandString, i);\n-                    significand |= (currentDigit << nextShift);\n-                    nextShift -= 4;\n-                }\n+    private static void copyDigits(String in, char[] digits, int len, int i) {\n+        char ch;\n+        int j = 0;\n+        while (j < len) {\n+            if ((ch = in.charAt(i++)) != '.') {\n+                digits[j++] = ch;\n+            }\n+        }\n+    }\n@@ -2315,46 +2264,4 @@\n-                \/\/ After the above loop, the bulk of the string is copied.\n-                \/\/ Now, we must copy any partial hex digits into the\n-                \/\/ significand AND compute the round bit and start computing\n-                \/\/ sticky bit.\n-\n-                if (i < signifLength) { \/\/ at least one hex input digit exists\n-                    long currentDigit = getHexDigit(significandString, i);\n-\n-                    \/\/ from nextShift, figure out how many bits need\n-                    \/\/ to be copied, if any\n-                    switch (nextShift) { \/\/ must be negative\n-                        case -1:\n-                            \/\/ three bits need to be copied in; can\n-                            \/\/ set round bit\n-                            significand |= ((currentDigit & 0xEL) >> 1);\n-                            round = (currentDigit & 0x1L) != 0L;\n-                            break;\n-\n-                        case -2:\n-                            \/\/ two bits need to be copied in; can\n-                            \/\/ set round and start sticky\n-                            significand |= ((currentDigit & 0xCL) >> 2);\n-                            round = (currentDigit & 0x2L) != 0L;\n-                            sticky = (currentDigit & 0x1L) != 0;\n-                            break;\n-\n-                        case -3:\n-                            \/\/ one bit needs to be copied in\n-                            significand |= ((currentDigit & 0x8L) >> 3);\n-                            \/\/ Now set round and start sticky, if possible\n-                            round = (currentDigit & 0x4L) != 0L;\n-                            sticky = (currentDigit & 0x3L) != 0;\n-                            break;\n-\n-                        case -4:\n-                            \/\/ all bits copied into significand; set\n-                            \/\/ round and start sticky\n-                            round = ((currentDigit & 0x8L) != 0);  \/\/ is top bit set?\n-                            \/\/ nonzeros in three low order bits?\n-                            sticky = (currentDigit & 0x7L) != 0;\n-                            break;\n-\n-                        default:\n-                            throw new AssertionError(\"Unexpected shift distance remainder.\");\n-                            \/\/ break;\n-                    }\n+    \/* Arithmetically \"appends the dec digit\" ch to v >= 0, clamping at 10^10. *\/\n+    private static long appendDecDigit(long v, int ch) {\n+        return v < 10_000_000_000L \/ 10 ? 10 * v + (ch - '0') : 10_000_000_000L;\n+    }\n@@ -2362,1 +2269,6 @@\n-                    \/\/ Round is set; sticky might be set.\n+    \/* Whether ch is a digit char '0-9', 'A-F', or 'a-f', depending on isDec. *\/\n+    private static boolean isDigit(int ch, boolean isDec) {\n+        int lch;  \/\/ lowercase ch\n+        return '0' <= ch && ch <= '9' ||\n+                !isDec && 'a' <= (lch = ch | 0b10_0000) && lch <= 'f';\n+    }\n@@ -2364,9 +2276,4 @@\n-                    \/\/ For the sticky bit, it suffices to check the\n-                    \/\/ current digit and test for any nonzero digits in\n-                    \/\/ the remaining unprocessed input.\n-                    i++;\n-                    while (i < signifLength && !sticky) {\n-                        currentDigit = getHexDigit(significandString, i);\n-                        sticky = sticky || (currentDigit != 0);\n-                        i++;\n-                    }\n+    \/* Returns the numeric value of ch, assuming it is a hexdigit. *\/\n+    private static int digitFor(int ch) {\n+        return ch <= '9' ? ch - '0' : (ch | 0b10_0000) - ('a' - 10);\n+    }\n@@ -2374,110 +2281,9 @@\n-                }\n-                \/\/ else all of string was seen, round and sticky are\n-                \/\/ correct as false.\n-\n-                \/\/ Float calculations\n-                int floatBits = isNegative ? FloatConsts.SIGN_BIT_MASK : 0;\n-                if (exponent >= Float.MIN_EXPONENT) {\n-                    if (exponent > Float.MAX_EXPONENT) {\n-                        \/\/ Float.POSITIVE_INFINITY\n-                        floatBits |= FloatConsts.EXP_BIT_MASK;\n-                    } else {\n-                        int threshShift = DoubleConsts.SIGNIFICAND_WIDTH - FloatConsts.SIGNIFICAND_WIDTH - 1;\n-                        boolean floatSticky = (significand & ((1L << threshShift) - 1)) != 0 || round || sticky;\n-                        int iValue = (int) (significand >>> threshShift);\n-                        if ((iValue & 3) != 1 || floatSticky) {\n-                            iValue++;\n-                        }\n-                        floatBits |= (((((int) exponent) + (FloatConsts.EXP_BIAS - 1))) << SINGLE_EXP_SHIFT) + (iValue >> 1);\n-                    }\n-                } else {\n-                    if (exponent < FloatConsts.MIN_SUB_EXPONENT - 1) {\n-                        \/\/ 0\n-                    } else {\n-                        \/\/ exponent == -127 ==> threshShift = 53 - 2 + (-149) - (-127) = 53 - 24\n-                        int threshShift = (int) ((DoubleConsts.SIGNIFICAND_WIDTH - 2 + FloatConsts.MIN_SUB_EXPONENT) - exponent);\n-                        assert threshShift >= DoubleConsts.SIGNIFICAND_WIDTH - FloatConsts.SIGNIFICAND_WIDTH;\n-                        assert threshShift < DoubleConsts.SIGNIFICAND_WIDTH;\n-                        boolean floatSticky = (significand & ((1L << threshShift) - 1)) != 0 || round || sticky;\n-                        int iValue = (int) (significand >>> threshShift);\n-                        if ((iValue & 3) != 1 || floatSticky) {\n-                            iValue++;\n-                        }\n-                        floatBits |= iValue >> 1;\n-                    }\n-                }\n-                float fValue = Float.intBitsToFloat(floatBits);\n-\n-                \/\/ Check for overflow and update exponent accordingly.\n-                if (exponent > Double.MAX_EXPONENT) {         \/\/ Infinite result\n-                    \/\/ overflow to properly signed infinity\n-                    return isNegative ? A2BC_NEGATIVE_INFINITY : A2BC_POSITIVE_INFINITY;\n-                } else {  \/\/ Finite return value\n-                    if (exponent <= Double.MAX_EXPONENT && \/\/ (Usually) normal result\n-                            exponent >= Double.MIN_EXPONENT) {\n-\n-                        \/\/ The result returned in this block cannot be a\n-                        \/\/ zero or subnormal; however after the\n-                        \/\/ significand is adjusted from rounding, we could\n-                        \/\/ still overflow in infinity.\n-\n-                        \/\/ AND exponent bits into significand; if the\n-                        \/\/ significand is incremented and overflows from\n-                        \/\/ rounding, this combination will update the\n-                        \/\/ exponent correctly, even in the case of\n-                        \/\/ Double.MAX_VALUE overflowing to infinity.\n-\n-                        significand = ((( exponent +\n-                                (long) DoubleConsts.EXP_BIAS) <<\n-                                (DoubleConsts.SIGNIFICAND_WIDTH - 1))\n-                                & DoubleConsts.EXP_BIT_MASK) |\n-                                (DoubleConsts.SIGNIF_BIT_MASK & significand);\n-\n-                    } else {  \/\/ Subnormal or zero\n-                        \/\/ (exponent < Double.MIN_EXPONENT)\n-\n-                        if (exponent < (DoubleConsts.MIN_SUB_EXPONENT - 1)) {\n-                            \/\/ No way to round back to nonzero value\n-                            \/\/ regardless of significand if the exponent is\n-                            \/\/ less than -1075.\n-                            return isNegative ? A2BC_NEGATIVE_ZERO : A2BC_POSITIVE_ZERO;\n-                        } else { \/\/  -1075 <= exponent <= MIN_EXPONENT -1 = -1023\n-                            \/\/\n-                            \/\/ Find bit position to round to; recompute\n-                            \/\/ round and sticky bits, and shift\n-                            \/\/ significand right appropriately.\n-                            \/\/\n-\n-                            sticky = sticky || round;\n-                            round = false;\n-\n-                            \/\/ Number of bits of significand to preserve is\n-                            \/\/ exponent - abs_min_exp +1\n-                            \/\/ check:\n-                            \/\/ -1075 +1074 + 1 = 0\n-                            \/\/ -1023 +1074 + 1 = 52\n-\n-                            int bitsDiscarded = 53 -\n-                                    ((int) exponent - DoubleConsts.MIN_SUB_EXPONENT + 1);\n-                            assert bitsDiscarded >= 1 && bitsDiscarded <= 53;\n-\n-                            \/\/ What to do here:\n-                            \/\/ First, isolate the new round bit\n-                            round = (significand & (1L << (bitsDiscarded - 1))) != 0L;\n-                            if (bitsDiscarded > 1) {\n-                                \/\/ create mask to update sticky bits; low\n-                                \/\/ order bitsDiscarded bits should be 1\n-                                long mask = ~((~0L) << (bitsDiscarded - 1));\n-                                sticky = sticky || ((significand & mask) != 0L);\n-                            }\n-\n-                            \/\/ Now, discard the bits\n-                            significand = significand >> bitsDiscarded;\n-\n-                            significand = ((((long) (Double.MIN_EXPONENT - 1) + \/\/ subnorm exp.\n-                                    (long) DoubleConsts.EXP_BIAS) <<\n-                                    (DoubleConsts.SIGNIFICAND_WIDTH - 1))\n-                                    & DoubleConsts.EXP_BIT_MASK) |\n-                                    (DoubleConsts.SIGNIF_BIT_MASK & significand);\n-                        }\n-                    }\n+    \/*\n+     * Starting at i, skips all chars in ['\\0', ' '].\n+     * Returns the index after the whitespaces.\n+     *\/\n+    private static int skipWhitespaces(String in, int i) {\n+        int len = in.length();\n+        for (; i < len && in.charAt(i) <= ' '; ++i);  \/\/ empty body\n+        return i;\n+    }\n@@ -2485,2 +2291,10 @@\n-                    \/\/ The significand variable now contains the currently\n-                    \/\/ appropriate exponent bits too.\n+    \/*\n+     * Attempts to scan sub and optional trailing whitespaces, starting at index i.\n+     * The optional whitespaces must be at the end of in.\n+     *\/\n+    private static void scanSymbolic(String in, int i, String sub) {\n+        int high = i + sub.length();  \/\/ might overflow, checked in next line\n+        check(in, i <= high && high <= in.length()\n+                && in.indexOf(sub, i, high) == i\n+                && skipWhitespaces(in, high) == in.length());\n+    }\n@@ -2488,26 +2302,10 @@\n-                    \/\/\n-                    \/\/ Determine if significand should be incremented;\n-                    \/\/ making this determination depends on the least\n-                    \/\/ significant bit and the round and sticky bits.\n-                    \/\/\n-                    \/\/ Round to nearest even rounding table, adapted from\n-                    \/\/ table 4.7 in \"Computer Arithmetic\" by IsraelKoren.\n-                    \/\/ The digit to the left of the \"decimal\" point is the\n-                    \/\/ least significant bit, the digits to the right of\n-                    \/\/ the point are the round and sticky bits\n-                    \/\/\n-                    \/\/ Number       Round(x)\n-                    \/\/ x0.00        x0.\n-                    \/\/ x0.01        x0.\n-                    \/\/ x0.10        x0.\n-                    \/\/ x0.11        x1. = x0. +1\n-                    \/\/ x1.00        x1.\n-                    \/\/ x1.01        x1.\n-                    \/\/ x1.10        x1. + 1\n-                    \/\/ x1.11        x1. + 1\n-                    \/\/\n-                    boolean leastZero = ((significand & 1L) == 0L);\n-                    if ((leastZero && round && sticky) ||\n-                            ((!leastZero) && round)) {\n-                        significand++;\n-                    }\n+    \/*\n+     * Returns i if this is the first time the scanner detects a point.\n+     * Throws otherwise.\n+     *\/\n+    private static int checkMultiplePoints(int pt, int i) {\n+        if (pt != 0) {\n+            throw new NumberFormatException(\"multiple points\");\n+        }\n+        return i;\n+    }\n@@ -2515,3 +2313,4 @@\n-                    double value = isNegative ?\n-                            Double.longBitsToDouble(significand | DoubleConsts.SIGN_BIT_MASK) :\n-                            Double.longBitsToDouble(significand );\n+    private static final int MAX_OUT = 1_000;\n+    private static final String OMITTED = \" ... \";\n+    private static final int L_HALF = (MAX_OUT - OMITTED.length()) \/ 2;\n+    private static final int R_HALF = MAX_OUT - (L_HALF + OMITTED.length());\n@@ -2519,2 +2318,5 @@\n-                    return new PreparedASCIIToBinaryBuffer(value, fValue);\n-                }\n+    private static void check(String in, boolean expected) {\n+        if (!expected) {\n+            int len = in.length();\n+            if (len > MAX_OUT) {  \/\/ discard middle chars to achieve a length of MAX_OUT\n+                in = in.substring(0, L_HALF) + OMITTED + in.substring(len - R_HALF);\n@@ -2522,0 +2324,2 @@\n+            throw new NumberFormatException(\"For input string: \\\"\" + in + \"\\\"\");\n+        }\n@@ -2524,2 +2328,21 @@\n-    \/**\n-     * Returns <code>s<\/code> with any leading zeros removed.\n+    \/*\n+     * According to IEEE 754-2019, a finite positive binary floating-point\n+     * of precision P is (uniquely) expressed as\n+     *      c 2^q\n+     * where integers c and q meet\n+     *      Q_MIN <= q <= Q_MAX\n+     *      either      2^(P-1) <= c < 2^P  (normal)\n+     *      or          0 < c < 2^(P-1)  &  q = Q_MIN  (subnormal)\n+     *      c = <d_0 d_1 ... d_(P-1)>, d_i in [0, 2)\n+     *\n+     * Equivalently, the fp value can be (uniquely) expressed as\n+     *      m 2^ep\n+     * where integer ep and real f meet\n+     *      ep = q + P - 1\n+     *      m = c 2^(1-P)\n+     * Hence,\n+     *      E_MIN = Q_MIN + P - 1, E_MAX = Q_MAX + P - 1,\n+     *      1 <= m < 2      (normal)\n+     *      m < 1           (subnormal)\n+     *      m = <d_0 . d_1 ... d_(P-1)>\n+     * with a (binary) point between d_0 and d_1\n@@ -2527,11 +2350,0 @@\n-    static String stripLeadingZeros(String s) {\n-        if(!s.isEmpty() && s.charAt(0)=='0') {\n-            for(int i=1; i<s.length(); i++) {\n-                if(s.charAt(i)!='0') {\n-                    return s.substring(i);\n-                }\n-            }\n-            return \"\";\n-        }\n-        return s;\n-    }\n@@ -2539,3 +2351,3 @@\n-    \/**\n-     * Extracts a hexadecimal digit from position <code>position<\/code>\n-     * of string <code>s<\/code>.\n+    \/*\n+     * These constants are used to indicate the IEEE binary floating-point format\n+     * as an index (ix) to some methods and static arrays in this class.\n@@ -2543,8 +2355,87 @@\n-    static int getHexDigit(String s, int position) {\n-        int value = Character.digit(s.charAt(position), 16);\n-        if (value <= -1 || value >= 16) {\n-            throw new AssertionError(\"Unexpected failure of digit conversion of \" +\n-                                     s.charAt(position));\n-        }\n-        return value;\n-    }\n+    private static final int BINARY_16_IX = 0;\n+    private static final int BINARY_32_IX = 1;\n+    private static final int BINARY_64_IX = 2;\n+\/\/    private static final int BINARY_128_IX = 3;\n+\/\/    private static final int BINARY_256_IX = 4;\n+\n+    \/* The precision of the format. *\/\n+    @Stable\n+    private static final int[] P = {\n+            11, 24, 53, \/\/ 113, 237,\n+    };\n+\n+    \/*\n+     * EP_MIN = max{e : 10^e <= MIN_VALUE\/2}.\n+     * Note that MIN_VALUE\/2 is the 0 threshold.\n+     * Less or equal values round to 0 when using roundTiesToEven.\n+     * Equivalently, EP_MIN = floor(log10(2^(Q_MIN-1))).\n+     *\/\n+    @Stable\n+    private static final int[] EP_MIN = {\n+            -8, -46, -324, \/\/ -4_966, -78_985,\n+    };\n+\n+    \/*\n+     * EP_MAX = min{e : MAX_VALUE + ulp(MAX_VALUE)\/2 <= 10^(e-1)}.\n+     * Note that MAX_VALUE + ulp(MAX_VALUE)\/2 is the infinity threshold.\n+     * Greater or equal values round to infinity when using roundTiesToEven.\n+     * Equivalently, EP_MAX = ceil(log10((2^P - 1\/2) 2^Q_MAX)) + 1.\n+     *\/\n+    @Stable\n+    private static final int[] EP_MAX = {\n+            6, 40, 310, \/\/ 4_934, 78_915,\n+    };\n+\n+    \/* Exponent width. *\/\n+    @Stable\n+    private static final int[] W = {\n+            (1 << 4 + BINARY_16_IX) - P[BINARY_16_IX],\n+            (1 << 4 + BINARY_32_IX) - P[BINARY_32_IX],\n+            (1 << 4 + BINARY_64_IX) - P[BINARY_64_IX],\n+\/\/            (1 << 4 + BINARY_128_IX) - P[BINARY_128_IX],\n+\/\/            (1 << 4 + BINARY_256_IX) - P[BINARY_256_IX],\n+    };\n+\n+    \/* Maximum exponent in the m 2^e representation. *\/\n+    @Stable\n+    private static final int[] E_MAX = {\n+            (1 << W[BINARY_16_IX] - 1) - 1,\n+            (1 << W[BINARY_32_IX] - 1) - 1,\n+            (1 << W[BINARY_64_IX] - 1) - 1,\n+\/\/            (1 << W[BINARY_128_IX] - 1) - 1,\n+\/\/            (1 << W[BINARY_256_IX] - 1) - 1,\n+    };\n+\n+    \/* Minimum exponent in the m 2^e representation. *\/\n+    @Stable\n+    private static final int[] E_MIN = {\n+            1 - E_MAX[BINARY_16_IX],\n+            1 - E_MAX[BINARY_32_IX],\n+            1 - E_MAX[BINARY_64_IX],\n+\/\/            1 - E_MAX[BINARY_128_IX],\n+\/\/            1 - E_MAX[BINARY_256_IX],\n+    };\n+\n+    \/* Minimum exponent in the c 2^q representation. *\/\n+    @Stable\n+    private static final int[] Q_MIN = {\n+            E_MIN[BINARY_16_IX] - (P[BINARY_16_IX] - 1),\n+            E_MIN[BINARY_32_IX] - (P[BINARY_32_IX] - 1),\n+            E_MIN[BINARY_64_IX] - (P[BINARY_64_IX] - 1),\n+\/\/            E_MIN[BINARY_128_IX] - (P[BINARY_128_IX] - 1),\n+\/\/            E_MIN[BINARY_256_IX] - (P[BINARY_256_IX] - 1),\n+    };\n+\n+    \/*\n+     * The most significant P +1 rounding bit +1 sticky bit = P + 2 bits in a\n+     * hexadecimal string need up to HEX_COUNT = floor(P\/4) + 2 hex digits.\n+     *\/\n+    @Stable\n+    private static final int[] HEX_COUNT = {\n+            P[BINARY_16_IX] \/ 4 + 2,\n+            P[BINARY_32_IX] \/ 4 + 2,\n+            P[BINARY_64_IX] \/ 4 + 2,\n+\/\/            P[BINARY_128_IX] \/ 4 + 2,\n+\/\/            P[BINARY_256_IX] \/ 4 + 2,\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/math\/FloatingDecimal.java","additions":599,"deletions":708,"binary":false,"changes":1307,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8371652\n+ * @summary Double.parseDouble with large strings should return Double Infinity\n+ * @run main\/othervm -Xmx6G ParseLargeStrings\n+ *\/\n+\n+public class ParseLargeStrings {\n+\n+    public static void main(String args[]) {\n+        String s = \"9999999999e10000\";\n+        checkParseResult(s);\n+\n+        s = \"9\".repeat(Integer.MAX_VALUE - 100) + \"e10000\";\n+        checkParseResult(s);\n+\n+        int x = 1 + Integer.MAX_VALUE \/ 2;\n+        s = \"9\".repeat(x) + \"e\" + x;\n+        checkParseResult(s);\n+    }\n+\n+    private static void checkParseResult(String s) {\n+        double d = Double.parseDouble(s);\n+        if (!Double.isInfinite(d)) {\n+            throw new Error(\"parseDouble(\" + s + \"): \" + d + \" (expected: Infinity)\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Double\/ParseLargeStrings.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"}]}