{"files":[{"patch":"@@ -1053,1 +1053,0 @@\n-\n@@ -1056,0 +1055,41 @@\n+\n+  if (CheckJNICalls) {\n+    \/\/ Check if this is a virtual thread continuation\n+    Label L_skip_vthread_code;\n+    __ ldrw(rscratch1, Address(sp, ContinuationEntry::flags_offset()));\n+    __ cbzw(rscratch1, L_skip_vthread_code);\n+\n+    \/\/ If the held monitor count is > 0 and this vthread is terminating then\n+    \/\/ it failed to release a JNI monitor. So we issue the same log message\n+    \/\/ that JavaThread::exit does.\n+    __ ldr(rscratch1, Address(rthread, JavaThread::jni_monitor_count_offset()));\n+    __ cbz(rscratch1, L_skip_vthread_code);\n+\n+    \/\/ Save return value potentially containing the exception oop in callee-saved R19.\n+    __ mov(r19, r0);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::log_jni_monitor_still_held));\n+    \/\/ Restore potential return value.\n+    __ mov(r0, r19);\n+\n+    \/\/ For vthreads we have to explicitly zero the JNI monitor count of the carrier\n+    \/\/ on termination. The held count is implicitly zeroed below when we restore from\n+    \/\/ the parent held count (which has to be zero).\n+    __ str(zr, Address(rthread, JavaThread::jni_monitor_count_offset()));\n+\n+    __ bind(L_skip_vthread_code);\n+  }\n+#ifdef ASSERT\n+  else {\n+    \/\/ Check if this is a virtual thread continuation\n+    Label L_skip_vthread_code;\n+    __ ldrw(rscratch1, Address(sp, ContinuationEntry::flags_offset()));\n+    __ cbzw(rscratch1, L_skip_vthread_code);\n+\n+    \/\/ See comment just above. If not checking JNI calls the JNI count is only\n+    \/\/ needed for assertion checking.\n+    __ str(zr, Address(rthread, JavaThread::jni_monitor_count_offset()));\n+\n+    __ bind(L_skip_vthread_code);\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -1725,1 +1725,1 @@\n-\/\/   R8_ARG6, R9_ARG7, R10_ARG8\n+\/\/   R8_ARG6, R9_ARG7, R10_ARG8, R15_esp\n@@ -1740,0 +1740,48 @@\n+  __ st_ptr(tmp1, JavaThread::cont_fastpath_offset(), R16_thread);\n+\n+  if (CheckJNICalls) {\n+    \/\/ Check if this is a virtual thread continuation\n+    Label L_skip_vthread_code;\n+    __ lwz(R0, in_bytes(ContinuationEntry::flags_offset()), R1_SP);\n+    __ cmpwi(CCR0, R0, 0);\n+    __ beq(CCR0, L_skip_vthread_code);\n+\n+    \/\/ If the held monitor count is > 0 and this vthread is terminating then\n+    \/\/ it failed to release a JNI monitor. So we issue the same log message\n+    \/\/ that JavaThread::exit does.\n+    __ ld(R0, in_bytes(JavaThread::jni_monitor_count_offset()), R16_thread);\n+    __ cmpdi(CCR0, R0, 0);\n+    __ beq(CCR0, L_skip_vthread_code);\n+\n+    \/\/ Save return value potentially containing the exception oop\n+    Register ex_oop = R15_esp;   \/\/ nonvolatile register\n+    __ mr(ex_oop, R3_RET);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::log_jni_monitor_still_held));\n+    \/\/ Restore potental return value\n+    __ mr(R3_RET, ex_oop);\n+\n+    \/\/ For vthreads we have to explicitly zero the JNI monitor count of the carrier\n+    \/\/ on termination. The held count is implicitly zeroed below when we restore from\n+    \/\/ the parent held count (which has to be zero).\n+    __ li(tmp1, 0);\n+    __ std(tmp1, in_bytes(JavaThread::jni_monitor_count_offset()), R16_thread);\n+\n+    __ bind(L_skip_vthread_code);\n+  }\n+#ifdef ASSERT\n+  else {\n+    \/\/ Check if this is a virtual thread continuation\n+    Label L_skip_vthread_code;\n+    __ lwz(R0, in_bytes(ContinuationEntry::flags_offset()), R1_SP);\n+    __ cmpwi(CCR0, R0, 0);\n+    __ beq(CCR0, L_skip_vthread_code);\n+\n+    \/\/ See comment just above. If not checking JNI calls the JNI count is only\n+    \/\/ needed for assertion checking.\n+    __ li(tmp1, 0);\n+    __ std(tmp1, in_bytes(JavaThread::jni_monitor_count_offset()), R16_thread);\n+\n+    __ bind(L_skip_vthread_code);\n+  }\n+#endif\n+\n@@ -1742,1 +1790,0 @@\n-  __ st_ptr(tmp1, JavaThread::cont_fastpath_offset(), R16_thread);\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":51,"deletions":4,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -925,0 +925,41 @@\n+\n+  if (CheckJNICalls) {\n+    \/\/ Check if this is a virtual thread continuation\n+    Label L_skip_vthread_code;\n+    __ lwu(t0, Address(sp, ContinuationEntry::flags_offset()));\n+    __ beqz(t0, L_skip_vthread_code);\n+\n+    \/\/ If the held monitor count is > 0 and this vthread is terminating then\n+    \/\/ it failed to release a JNI monitor. So we issue the same log message\n+    \/\/ that JavaThread::exit does.\n+    __ ld(t0, Address(xthread, JavaThread::jni_monitor_count_offset()));\n+    __ beqz(t0, L_skip_vthread_code);\n+\n+    \/\/ Save return value potentially containing the exception oop in callee-saved x9\n+    __ mv(x9, x10);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::log_jni_monitor_still_held));\n+    \/\/ Restore potential return value\n+    __ mv(x10, x9);\n+\n+    \/\/ For vthreads we have to explicitly zero the JNI monitor count of the carrier\n+    \/\/ on termination. The held count is implicitly zeroed below when we restore from\n+    \/\/ the parent held count (which has to be zero).\n+    __ sd(zr, Address(xthread, JavaThread::jni_monitor_count_offset()));\n+\n+    __ bind(L_skip_vthread_code);\n+  }\n+#ifdef ASSERT\n+  else {\n+    \/\/ Check if this is a virtual thread continuation\n+    Label L_skip_vthread_code;\n+    __ lwu(t0, Address(sp, ContinuationEntry::flags_offset()));\n+    __ beqz(t0, L_skip_vthread_code);\n+\n+    \/\/ See comment just above. If not checking JNI calls the JNI count is only\n+    \/\/ needed for assertion checking.\n+    __ sd(zr, Address(xthread, JavaThread::jni_monitor_count_offset()));\n+\n+    __ bind(L_skip_vthread_code);\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":42,"deletions":1,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1365,1 +1365,0 @@\n-\n@@ -1368,0 +1367,40 @@\n+\n+  if (CheckJNICalls) {\n+    \/\/ Check if this is a virtual thread continuation\n+    Label L_skip_vthread_code;\n+    __ cmpl(Address(rsp, ContinuationEntry::flags_offset()), 0);\n+    __ jcc(Assembler::equal, L_skip_vthread_code);\n+\n+    \/\/ If the held monitor count is > 0 and this vthread is terminating then\n+    \/\/ it failed to release a JNI monitor. So we issue the same log message\n+    \/\/ that JavaThread::exit does.\n+    __ cmpptr(Address(r15_thread, JavaThread::jni_monitor_count_offset()), 0);\n+    __ jcc(Assembler::equal, L_skip_vthread_code);\n+\n+    \/\/ rax may hold an exception oop, save it before the call\n+    __ push(rax);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::log_jni_monitor_still_held));\n+    __ pop(rax);\n+\n+    \/\/ For vthreads we have to explicitly zero the JNI monitor count of the carrier\n+    \/\/ on termination. The held count is implicitly zeroed below when we restore from\n+    \/\/ the parent held count (which has to be zero).\n+    __ movq(Address(r15_thread, JavaThread::jni_monitor_count_offset()), 0);\n+\n+    __ bind(L_skip_vthread_code);\n+  }\n+#ifdef ASSERT\n+  else {\n+    \/\/ Check if this is a virtual thread continuation\n+    Label L_skip_vthread_code;\n+    __ cmpl(Address(rsp, ContinuationEntry::flags_offset()), 0);\n+    __ jcc(Assembler::equal, L_skip_vthread_code);\n+\n+    \/\/ See comment just above. If not checking JNI calls the JNI count is only\n+    \/\/ needed for assertion checking.\n+    __ movq(Address(r15_thread, JavaThread::jni_monitor_count_offset()), 0);\n+\n+    __ bind(L_skip_vthread_code);\n+  }\n+#endif\n+\n@@ -3724,1 +3763,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":40,"deletions":2,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -871,0 +871,14 @@\n+    \/\/ Check for monitor counts being out of sync.\n+    assert(held_monitor_count() == jni_monitor_count(),\n+           \"held monitor count should be equal to jni: \" INT64_FORMAT \" != \" INT64_FORMAT,\n+           (int64_t)held_monitor_count(), (int64_t)jni_monitor_count());\n+    \/\/ All in-use monitors, including JNI-locked ones, should have been released above.\n+    assert(held_monitor_count() == 0, \"Failed to unlock \" INT64_FORMAT \" object monitors\",\n+           (int64_t)held_monitor_count());\n+  } else {\n+    \/\/ Check for monitor counts being out of sync.\n+    assert(held_monitor_count() == jni_monitor_count(),\n+           \"held monitor count should be equal to jni: \" INT64_FORMAT \" != \" INT64_FORMAT,\n+           (int64_t)held_monitor_count(), (int64_t)jni_monitor_count());\n+    \/\/ It is possible that a terminating thread failed to unlock monitors it locked\n+    \/\/ via JNI so we don't assert the count is zero.\n@@ -873,7 +887,1 @@\n-  \/\/ Since above code may not release JNI monitors and if someone forgot to do an\n-  \/\/ JNI monitorexit, held count should be equal jni count.\n-  \/\/ Consider scan all object monitor for this owner if JNI count > 0 (at least on detach).\n-  assert(this->held_monitor_count() == this->jni_monitor_count(),\n-         \"held monitor count should be equal to jni: \" INT64_FORMAT \" != \" INT64_FORMAT,\n-         (int64_t)this->held_monitor_count(), (int64_t)this->jni_monitor_count());\n-  if (CheckJNICalls && this->jni_monitor_count() > 0) {\n+  if (CheckJNICalls && jni_monitor_count() > 0) {\n@@ -883,1 +891,1 @@\n-      exit_type == JavaThread::normal_exit ? \"exiting\" : \"detaching\", os::current_thread_id());\n+                   exit_type == JavaThread::normal_exit ? \"exiting\" : \"detaching\", os::current_thread_id());\n@@ -921,3 +929,6 @@\n-  log_info(os, thread)(\"JavaThread %s (tid: \" UINTX_FORMAT \").\",\n-    exit_type == JavaThread::normal_exit ? \"exiting\" : \"detaching\",\n-    os::current_thread_id());\n+  if (log_is_enabled(Info, os, thread)) {\n+    ResourceMark rm(this);\n+    log_info(os, thread)(\"JavaThread %s (name: \\\"%s\\\", tid: \" UINTX_FORMAT \").\",\n+                         exit_type == JavaThread::normal_exit ? \"exiting\" : \"detaching\",\n+                         name(), os::current_thread_id());\n+  }\n@@ -1913,0 +1924,2 @@\n+\/\/ Slow-path increment of the held monitor counts. JNI locking is always\n+\/\/ this slow-path.\n@@ -1915,1 +1928,1 @@\n-  assert(_held_monitor_count >= 0, \"Must always be greater than 0: \" INT64_FORMAT, (int64_t)_held_monitor_count);\n+  assert(_held_monitor_count >= 0, \"Must always be non-negative: \" INT64_FORMAT, (int64_t)_held_monitor_count);\n@@ -1918,1 +1931,1 @@\n-    assert(_jni_monitor_count >= 0, \"Must always be greater than 0: \" INT64_FORMAT, (int64_t)_jni_monitor_count);\n+    assert(_jni_monitor_count >= 0, \"Must always be non-negative: \" INT64_FORMAT, (int64_t)_jni_monitor_count);\n@@ -1921,0 +1934,2 @@\n+  assert(_held_monitor_count >= _jni_monitor_count, \"Monitor count discrepancy detected - held count \"\n+         INT64_FORMAT \" is less than JNI count \" INT64_FORMAT, (int64_t)_held_monitor_count, (int64_t)_jni_monitor_count);\n@@ -1924,0 +1939,2 @@\n+\/\/ Slow-path decrement of the held monitor counts. JNI unlocking is always\n+\/\/ this slow-path.\n@@ -1932,0 +1949,6 @@\n+  \/\/ When a thread is detaching with still owned JNI monitors, the logic that releases\n+  \/\/ the monitors doesn't know to set the \"jni\" flag and so the counts can get out of sync.\n+  \/\/ So we skip this assert if the thread is exiting. Once all monitors are unlocked the\n+  \/\/ JNI count is directly set to zero.\n+  assert(_held_monitor_count >= _jni_monitor_count || is_exiting(), \"Monitor count discrepancy detected - held count \"\n+         INT64_FORMAT \" is less than JNI count \" INT64_FORMAT, (int64_t)_held_monitor_count, (int64_t)_jni_monitor_count);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":36,"deletions":13,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -810,0 +810,1 @@\n+  static ByteSize jni_monitor_count_offset()  { return byte_offset_of(JavaThread, _jni_monitor_count); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2268,0 +2268,14 @@\n+\/\/ This is only called when CheckJNICalls is true, and only\n+\/\/ for virtual thread termination.\n+JRT_LEAF(void,  SharedRuntime::log_jni_monitor_still_held())\n+  assert(CheckJNICalls, \"Only call this when checking JNI usage\");\n+  if (log_is_enabled(Debug, jni)) {\n+    JavaThread* current = JavaThread::current();\n+    int64_t vthread_id = java_lang_Thread::thread_id(current->vthread());\n+    int64_t carrier_id = java_lang_Thread::thread_id(current->threadObj());\n+    log_debug(jni)(\"VirtualThread (tid: \" INT64_FORMAT \", carrier id: \" INT64_FORMAT\n+                   \") exiting with Objects still locked by JNI MonitorEnter.\",\n+                   vthread_id, carrier_id);\n+  }\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -355,0 +355,3 @@\n+  \/\/ Issue UL warning for unlocked JNI monitor on virtual thread termination\n+  static void log_jni_monitor_still_held();\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -25,0 +28,3 @@\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.List;\n@@ -26,0 +32,16 @@\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/*\n+ * Tests that JNI monitors work correctly with virtual threads,\n+ * There are multiple test scenarios that we check using unified logging output\n+ * (both positive and negative tests). Each test case is handled by its own @-test\n+ * definition so that we can run each sub-test independently.\n+ *\n+ * The original bug was only discovered because the ForkJoinPool worker thread terminated\n+ * and trigerred an assertion failure. So we use a custom scheduler to give us control.\n+ *\/\n@@ -28,2 +50,3 @@\n- * @test JNIMonitor\n- * @summary Tests that JNI monitors work correctly with virtual threads\n+ * @test id=normal\n+ * @bug 8327743\n+ * @summary Normal lock then unlock\n@@ -31,2 +54,53 @@\n- * @compile JNIMonitor.java\n- * @run main\/native\/othervm JNIMonitor\n+ * @modules java.base\/java.lang:+open\n+ * @requires vm.continuations\n+ * @run driver JNIMonitor Normal\n+ *\/\n+\n+\/**\n+ * @test id=multiNormal\n+ * @bug 8327743\n+ * @summary Normal lock then unlock by multiple threads\n+ * @library \/test\/lib\n+ * @modules java.base\/java.lang:+open\n+ * @requires vm.continuations\n+ * @run driver JNIMonitor MultiNormal\n+ *\/\n+\n+\/**\n+ * @test id=missingUnlock\n+ * @bug 8327743\n+ * @summary Don't do the unlock and exit normally\n+ * @library \/test\/lib\n+ * @modules java.base\/java.lang:+open\n+ * @requires vm.continuations\n+ * @run driver JNIMonitor MissingUnlock\n+ *\/\n+\n+\/**\n+ * @test id=multiMissingUnlock\n+ * @bug 8327743\n+ * @summary Don't do the unlock and exit normally, by multiple threads\n+ * @library \/test\/lib\n+ * @modules java.base\/java.lang:+open\n+ * @requires vm.continuations\n+ * @run driver JNIMonitor MultiMissingUnlock\n+ *\/\n+\n+\/**\n+ * @test id=missingUnlockWithThrow\n+ * @bug 8327743\n+ * @summary Don't do the unlock and exit by throwing\n+ * @library \/test\/lib\n+ * @modules java.base\/java.lang:+open\n+ * @requires vm.continuations\n+ * @run driver JNIMonitor MissingUnlockWithThrow\n+ *\/\n+\n+\/**\n+ * @test id=multiMissingUnlockWithThrow\n+ * @bug 8327743\n+ * @summary Don't do the unlock and exit by throwing, by multiple threads\n+ * @library \/test\/lib\n+ * @modules java.base\/java.lang:+open\n+ * @requires vm.continuations\n+ * @run driver JNIMonitor MultiMissingUnlockWithThrow\n@@ -37,0 +111,75 @@\n+    public static void main(String[] args) throws Exception {\n+        String test = args[0];\n+        String[] cmdArgs = new String[] {\n+            \"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n+            \/\/ Grant access to ThreadBuilders$VirtualThreadBuilder\n+            \"--add-opens=java.base\/java.lang=ALL-UNNAMED\",\n+            \/\/ Enable the JNI warning\n+            \"-Xcheck:jni\",\n+            \"-Xlog:jni=debug\",\n+            \/\/ Enable thread termination logging as a visual cross-check\n+            \"-Xlog:thread+os=info\",\n+            \"JNIMonitor$\" + test,\n+        };\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(cmdArgs);\n+        oa.shouldHaveExitValue(0);\n+        oa.stdoutShouldMatch(terminated);\n+\n+        switch(test) {\n+            case \"Normal\":\n+            case \"MultiNormal\":\n+                oa.stdoutShouldNotMatch(stillLocked);\n+                break;\n+            case \"MissingUnlock\":\n+                oa.stdoutShouldMatch(stillLocked);\n+                break;\n+            case \"MultiMissingUnlock\":\n+                parseOutputForPattern(oa.stdoutAsLines(), stillLocked, MULTI_THREAD_COUNT);\n+                break;\n+            case \"MissingUnlockWithThrow\":\n+                oa.stdoutShouldMatch(stillLocked);\n+                oa.stderrShouldContain(throwMsg);\n+                break;\n+            case \"MultiMissingUnlockWithThrow\":\n+                parseOutputForPattern(oa.stdoutAsLines(), stillLocked, MULTI_THREAD_COUNT);\n+                parseOutputForPattern(oa.stderrAsLines(), throwMsg, MULTI_THREAD_COUNT);\n+                break;\n+\n+            default: throw new Error(\"Unknown arg: \" + args[0]);\n+        }\n+        oa.reportDiagnosticSummary();\n+    }\n+\n+    \/\/ The number of threads for a multi tests. Arbitrarily chosen to be > 1 but small\n+    \/\/ enough to not waste too much time.\n+    static final int MULTI_THREAD_COUNT = 5;\n+\n+    \/\/ The logging message for leaving a monitor JNI locked has the form\n+    \/\/   [0.187s][debug][jni] VirtualThread (tid: 28, carrier id: 29) exiting with Objects still locked by JNI MonitorEnter.\n+    \/\/ but if the test is run with other logging options then whitespace may get introduced in the\n+    \/\/ log decorator sections, so ignore those.\n+    static final String stillLocked = \"VirtualThread \\\\(tid:.*exiting with Objects still locked by JNI MonitorEnter\";\n+    \/\/ The carrier thread termination logging has the form:\n+    \/\/ [1.394s][info][os,thread] JavaThread exiting (name: \"pool-1-thread-1\", tid: 3090592).\n+    static final String terminated = \"JavaThread exiting \\\\(name: \\\"pool-1-thread-1\\\"\";\n+\n+    static final String throwMsg = \"Terminating via exception as requested\";\n+\n+    \/\/ Check the process logging output for the given pattern to see if the expected number of\n+    \/\/ lines are found.\n+    private static void parseOutputForPattern(List<String> lines, String pattern, int expected) {\n+        Pattern p = Pattern.compile(pattern);\n+        int found = 0;\n+        for (String line : lines) {\n+            Matcher m = p.matcher(line);\n+            if (m.find()) {\n+                found++;\n+            }\n+        }\n+        if (found != expected) {\n+            throw new RuntimeException(\"Checking for pattern \\\"\" + pattern + \"\\\": expected \"\n+                                       + expected + \" but found \" + found);\n+        }\n+    }\n+\n+\n@@ -40,3 +189,0 @@\n-    static {\n-        System.loadLibrary(\"JNIMonitor\");\n-    }\n@@ -44,4 +190,15 @@\n-    public static void main(String[] args) throws Throwable {\n-        final Object monitor = new Object();\n-        final AtomicReference<Throwable> exception = new AtomicReference();\n-        Thread.ofVirtual().start(() -> {\n+    \/\/ Isolate the native library loading to the actual test cases, not the class that\n+    \/\/ jtreg Driver will load and execute.\n+    static class TestBase {\n+\n+        static {\n+            System.loadLibrary(\"JNIMonitor\");\n+        }\n+\n+        \/\/ This gives us a way to control the scheduler used for our virtual threads. The test\n+        \/\/ only works as intended when the virtual threads run on the same carrier thread (as\n+        \/\/ that carrier maintains ownership of the monitor if the virtual thread fails to unlock it).\n+        \/\/ The original issue was also only discovered due to the carrier thread terminating\n+        \/\/ unexpectedly, so we can force that condition too by shutting down our custom scheduler.\n+        private static Thread.Builder.OfVirtual virtualThreadBuilder(Executor scheduler) {\n+            Thread.Builder.OfVirtual builder = Thread.ofVirtual();\n@@ -49,7 +206,45 @@\n-                int res = monitorEnter(monitor);\n-                Asserts.assertTrue(res == 0, \"monitorEnter should return 0.\");\n-                Thread.yield();\n-                res = monitorExit(monitor);\n-                Asserts.assertTrue(res == 0, \"monitorExit should return 0.\");\n-            } catch (Throwable t) {\n-                exception.set(t);\n+                Class<?> clazz = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n+                Constructor<?> ctor = clazz.getDeclaredConstructor(Executor.class);\n+                ctor.setAccessible(true);\n+                return (Thread.Builder.OfVirtual) ctor.newInstance(scheduler);\n+            } catch (InvocationTargetException e) {\n+                Throwable cause = e.getCause();\n+                if (cause instanceof RuntimeException re) {\n+                    throw re;\n+                }\n+                throw new RuntimeException(e);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        static void runTest(int nThreads, boolean skipUnlock, boolean throwOnExit) throws Throwable {\n+            final Object monitor = new Object();\n+            final AtomicReference<Throwable> exception = new AtomicReference();\n+            \/\/ Ensure all our VT's operate of the same carrier, sequentially.\n+            ExecutorService scheduler = Executors.newSingleThreadExecutor();\n+            ThreadFactory factory = virtualThreadBuilder(scheduler).factory();\n+            for (int i = 0 ; i < nThreads; i++) {\n+                Thread th = factory.newThread(() -> {\n+                        try {\n+                            int res = monitorEnter(monitor);\n+                            Asserts.assertTrue(res == 0, \"monitorEnter should return 0.\");\n+                            Asserts.assertTrue(Thread.holdsLock(monitor), \"monitor should be owned\");\n+                            Thread.yield();\n+                            if (!skipUnlock) {\n+                                res = monitorExit(monitor);\n+                                Asserts.assertTrue(res == 0, \"monitorExit should return 0.\");\n+                                Asserts.assertFalse(Thread.holdsLock(monitor), \"monitor should be unowned\");\n+                            }\n+                        } catch (Throwable t) {\n+                            exception.set(t);\n+                        }\n+                        if (throwOnExit) {\n+                            throw new RuntimeException(throwMsg);\n+                        }\n+                    });\n+                th.start();\n+                th.join();\n+                if (exception.get() != null) {\n+                    throw exception.get();\n+                }\n@@ -57,3 +252,10 @@\n-        }).join();\n-        if (exception.get() != null) {\n-            throw exception.get();\n+            \/\/ Now force carrier thread to shutdown.\n+            scheduler.shutdown();\n+        }\n+    }\n+\n+    \/\/ These are the actual test case classes that get exec'd.\n+\n+    static class Normal extends TestBase {\n+        public static void main(String[] args) throws Throwable {\n+            runTest(1, false, false);\n@@ -62,0 +264,31 @@\n+\n+    static class MultiNormal extends TestBase {\n+        public static void main(String[] args) throws Throwable {\n+            runTest(MULTI_THREAD_COUNT, false, false);\n+        }\n+    }\n+\n+    static class MissingUnlock extends TestBase  {\n+        public static void main(String[] args) throws Throwable {\n+            runTest(1, true, false);\n+        }\n+    }\n+\n+    static class MultiMissingUnlock extends TestBase {\n+        public static void main(String[] args) throws Throwable {\n+            runTest(MULTI_THREAD_COUNT, true, false);\n+        }\n+    }\n+\n+    static class MissingUnlockWithThrow extends TestBase {\n+        public static void main(String[] args) throws Throwable {\n+            runTest(1, true, true);\n+        }\n+    }\n+\n+    static class MultiMissingUnlockWithThrow extends TestBase {\n+        public static void main(String[] args) throws Throwable {\n+            runTest(MULTI_THREAD_COUNT, true, true);\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/vthread\/JNIMonitor\/JNIMonitor.java","additions":255,"deletions":22,"binary":false,"changes":277,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+    static int t_num = 0;\n@@ -81,1 +82,2 @@\n-            Thread.currentThread().setName(\"Worker-Thread\");\n+            Thread.currentThread().setName((isVirtual ? \"Virtual-\" : \"\") + \"Worker-Thread-\" + t_num);\n+            t_num++;\n@@ -84,0 +86,3 @@\n+                System.out.println(\"Thread doing JNI call: \"\n+                                   + Thread.currentThread().getName());\n+\n@@ -95,1 +100,3 @@\n-            System.out.println(\"Main starting worker thread.\");\n+            System.out.print(\"Main starting worker thread for \");\n+            System.out.print(isVirtual ? \"virtual \" : \"non-virtual \");\n+            System.out.println(jni ? \"JNI\" : \"non-JNI\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetOwnedMonitorInfo\/GetOwnedMonitorInfoTest.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"}]}