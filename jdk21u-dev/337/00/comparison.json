{"files":[{"patch":"@@ -870,1 +870,1 @@\n-  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libTestPsig.c libnativeStack.c exeGetCreatedJavaVMs.c\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libMonitorWithDeadObjectTest.c libTestPsig.c libnativeStack.c exeGetCreatedJavaVMs.c\n@@ -1511,0 +1511,1 @@\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libMonitorWithDeadObjectTest += -lpthread\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -991,1 +991,1 @@\n-  ObjectSynchronizer::monitors_iterate(&jmc, java_thread);\n+  ObjectSynchronizer::owned_monitors_iterate(&jmc, java_thread);\n@@ -1018,1 +1018,1 @@\n-  ObjectSynchronizer::monitors_iterate(&jmc, java_thread);\n+  ObjectSynchronizer::owned_monitors_iterate(&jmc, java_thread);\n@@ -2181,0 +2181,7 @@\n+\n+  if (obj == nullptr) {\n+    \/\/ This can happen if JNI code drops all references to the\n+    \/\/ owning object.\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1836,1 +1836,1 @@\n-  return ObjectSynchronizer::request_deflate_idle_monitors();\n+  return ObjectSynchronizer::request_deflate_idle_monitors_from_wb();\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-    (void)ObjectSynchronizer::deflate_idle_monitors(\/* ObjectMonitorsHashtable is not needed here *\/ nullptr);\n+    (void)ObjectSynchronizer::deflate_idle_monitors();\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -512,10 +512,0 @@\n-  if (ObjectSynchronizer::is_final_audit() && owner_is_DEFLATER_MARKER()) {\n-    \/\/ The final audit can see an already deflated ObjectMonitor on the\n-    \/\/ in-use list because MonitorList::unlink_deflated() might have\n-    \/\/ blocked for the final safepoint before unlinking all the deflated\n-    \/\/ monitors.\n-    assert(contentions() < 0, \"must be negative: contentions=%d\", contentions());\n-    \/\/ Already returned 'true' when it was originally deflated.\n-    return false;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -66,39 +66,0 @@\n-class ObjectMonitorsHashtable::PtrList :\n-  public LinkedListImpl<ObjectMonitor*,\n-                        AnyObj::C_HEAP, mtThread,\n-                        AllocFailStrategy::RETURN_NULL> {};\n-\n-class CleanupObjectMonitorsHashtable: StackObj {\n- public:\n-  bool do_entry(void*& key, ObjectMonitorsHashtable::PtrList*& list) {\n-    list->clear();  \/\/ clear the LinkListNodes\n-    delete list;    \/\/ then delete the LinkedList\n-    return true;\n-  }\n-};\n-\n-ObjectMonitorsHashtable::~ObjectMonitorsHashtable() {\n-  CleanupObjectMonitorsHashtable cleanup;\n-  _ptrs->unlink(&cleanup);  \/\/ cleanup the LinkedLists\n-  delete _ptrs;             \/\/ then delete the hash table\n-}\n-\n-void ObjectMonitorsHashtable::add_entry(void* key, ObjectMonitor* om) {\n-  ObjectMonitorsHashtable::PtrList* list = get_entry(key);\n-  if (list == nullptr) {\n-    \/\/ Create new list and add it to the hash table:\n-    list = new (mtThread) ObjectMonitorsHashtable::PtrList;\n-    add_entry(key, list);\n-  }\n-  list->add(om);  \/\/ Add the ObjectMonitor to the list.\n-  _om_count++;\n-}\n-\n-bool ObjectMonitorsHashtable::has_entry(void* key, ObjectMonitor* om) {\n-  ObjectMonitorsHashtable::PtrList* list = get_entry(key);\n-  if (list == nullptr || list->find(om) == nullptr) {\n-    return false;\n-  }\n-  return true;\n-}\n-\n@@ -1102,6 +1063,3 @@\n-\/\/ Iterate ObjectMonitors where the owner == thread; this does NOT include\n-\/\/ ObjectMonitors where owner is set to a stack-lock address in thread.\n-\/\/\n-\/\/ This version of monitors_iterate() works with the in-use monitor list.\n-\/\/\n-void ObjectSynchronizer::monitors_iterate(MonitorClosure* closure, JavaThread* thread) {\n+\/\/ Iterate over all ObjectMonitors.\n+template <typename Function>\n+void ObjectSynchronizer::monitors_iterate(Function function) {\n@@ -1110,17 +1068,2 @@\n-    ObjectMonitor* mid = iter.next();\n-    if (mid->owner() != thread) {\n-      \/\/ Not owned by the target thread and intentionally skips when owner\n-      \/\/ is set to a stack-lock address in the target thread.\n-      continue;\n-    }\n-    if (!mid->is_being_async_deflated() && mid->object_peek() != nullptr) {\n-      \/\/ Only process with closure if the object is set.\n-\n-      \/\/ monitors_iterate() is only called at a safepoint or when the\n-      \/\/ target thread is suspended or when the target thread is\n-      \/\/ operating on itself. The current closures in use today are\n-      \/\/ only interested in an owned ObjectMonitor and ownership\n-      \/\/ cannot be dropped under the calling contexts so the\n-      \/\/ ObjectMonitor cannot be async deflated.\n-      closure->do_monitor(mid);\n-    }\n+    ObjectMonitor* monitor = iter.next();\n+    function(monitor);\n@@ -1130,21 +1073,15 @@\n-\/\/ This version of monitors_iterate() works with the specified linked list.\n-\/\/\n-void ObjectSynchronizer::monitors_iterate(MonitorClosure* closure,\n-                                          ObjectMonitorsHashtable::PtrList* list,\n-                                          JavaThread* thread) {\n-  typedef LinkedListIterator<ObjectMonitor*> ObjectMonitorIterator;\n-  ObjectMonitorIterator iter(list->head());\n-  while (!iter.is_empty()) {\n-    ObjectMonitor* mid = *iter.next();\n-    \/\/ Owner set to a stack-lock address in thread should never be seen here:\n-    assert(mid->owner() == thread, \"must be\");\n-    if (!mid->is_being_async_deflated() && mid->object_peek() != nullptr) {\n-      \/\/ Only process with closure if the object is set.\n-\n-      \/\/ monitors_iterate() is only called at a safepoint or when the\n-      \/\/ target thread is suspended or when the target thread is\n-      \/\/ operating on itself. The current closures in use today are\n-      \/\/ only interested in an owned ObjectMonitor and ownership\n-      \/\/ cannot be dropped under the calling contexts so the\n-      \/\/ ObjectMonitor cannot be async deflated.\n-      closure->do_monitor(mid);\n+\/\/ Iterate ObjectMonitors owned by any thread and where the owner `filter`\n+\/\/ returns true.\n+template <typename OwnerFilter>\n+void ObjectSynchronizer::owned_monitors_iterate_filtered(MonitorClosure* closure, OwnerFilter filter) {\n+  monitors_iterate([&](ObjectMonitor* monitor) {\n+    \/\/ This function is only called at a safepoint or when the\n+    \/\/ target thread is suspended or when the target thread is\n+    \/\/ operating on itself. The current closures in use today are\n+    \/\/ only interested in an owned ObjectMonitor and ownership\n+    \/\/ cannot be dropped under the calling contexts so the\n+    \/\/ ObjectMonitor cannot be async deflated.\n+    if (monitor->has_owner() && filter(monitor->owner_raw())) {\n+      assert(!monitor->is_being_async_deflated(), \"Owned monitors should not be deflating\");\n+\n+      closure->do_monitor(monitor);\n@@ -1152,1 +1089,14 @@\n-  }\n+  });\n+}\n+\n+\/\/ Iterate ObjectMonitors where the owner == thread; this does NOT include\n+\/\/ ObjectMonitors where owner is set to a stack-lock address in thread.\n+void ObjectSynchronizer::owned_monitors_iterate(MonitorClosure* closure, JavaThread* thread) {\n+  auto thread_filter = [&](void* owner) { return owner == thread; };\n+  return owned_monitors_iterate_filtered(closure, thread_filter);\n+}\n+\n+\/\/ Iterate ObjectMonitors owned by any thread.\n+void ObjectSynchronizer::owned_monitors_iterate(MonitorClosure* closure) {\n+  auto all_filter = [&](void* owner) { return true; };\n+  return owned_monitors_iterate_filtered(closure, all_filter);\n@@ -1259,1 +1209,7 @@\n-bool ObjectSynchronizer::request_deflate_idle_monitors() {\n+void ObjectSynchronizer::request_deflate_idle_monitors() {\n+  MonitorLocker ml(MonitorDeflation_lock, Mutex::_no_safepoint_check_flag);\n+  set_is_async_deflation_requested(true);\n+  ml.notify_all();\n+}\n+\n+bool ObjectSynchronizer::request_deflate_idle_monitors_from_wb() {\n@@ -1264,5 +1220,3 @@\n-  set_is_async_deflation_requested(true);\n-  {\n-    MonitorLocker ml(MonitorDeflation_lock, Mutex::_no_safepoint_check_flag);\n-    ml.notify_all();\n-  }\n+\n+  request_deflate_idle_monitors();\n+\n@@ -1585,7 +1539,0 @@\n-\/\/ If table != nullptr, we gather owned ObjectMonitors indexed by the\n-\/\/ owner in the table. Please note that ObjectMonitors where the owner\n-\/\/ is set to a stack-lock address are NOT associated with the JavaThread\n-\/\/ that holds that stack-lock. All of the current consumers of\n-\/\/ ObjectMonitorsHashtable info only care about JNI locked monitors and\n-\/\/ those do not have the owner set to a stack-lock address.\n-\/\/\n@@ -1593,2 +1540,1 @@\n-                                                elapsedTimer* timer_p,\n-                                                ObjectMonitorsHashtable* table) {\n+                                                elapsedTimer* timer_p) {\n@@ -1605,12 +1551,0 @@\n-    } else if (table != nullptr) {\n-      \/\/ The caller is interested in the owned ObjectMonitors. This does\n-      \/\/ not include when owner is set to a stack-lock address in thread.\n-      \/\/ This also does not capture unowned ObjectMonitors that cannot be\n-      \/\/ deflated because of a waiter.\n-      void* key = mid->owner();\n-      \/\/ Since deflate_idle_monitors() and deflate_monitor_list() can be\n-      \/\/ called more than once, we have to make sure the entry has not\n-      \/\/ already been added.\n-      if (key != nullptr && !table->has_entry(key, mid)) {\n-        table->add_entry(key, mid);\n-      }\n@@ -1666,3 +1600,2 @@\n-\/\/ ObjectMonitors. It is also called via do_final_audit_and_print_stats()\n-\/\/ and VM_ThreadDump::doit() by the VMThread.\n-size_t ObjectSynchronizer::deflate_idle_monitors(ObjectMonitorsHashtable* table) {\n+\/\/ ObjectMonitors.\n+size_t ObjectSynchronizer::deflate_idle_monitors() {\n@@ -1693,1 +1626,1 @@\n-  size_t deflated_count = deflate_monitor_list(current, ls, &timer, table);\n+  size_t deflated_count = deflate_monitor_list(current, ls, &timer);\n@@ -1696,5 +1629,2 @@\n-  if (deflated_count > 0 || is_final_audit()) {\n-    \/\/ There are ObjectMonitors that have been deflated or this is the\n-    \/\/ final audit and all the remaining ObjectMonitors have been\n-    \/\/ deflated, BUT the MonitorDeflationThread blocked for the final\n-    \/\/ safepoint during unlinking.\n+  if (deflated_count > 0) {\n+    \/\/ There are ObjectMonitors that have been deflated.\n@@ -1752,4 +1682,0 @@\n-    if (table != nullptr) {\n-      ls->print_cr(\"ObjectMonitorsHashtable: key_count=\" SIZE_FORMAT \", om_count=\" SIZE_FORMAT,\n-                   table->key_count(), table->om_count());\n-    }\n@@ -1808,1 +1734,1 @@\n-  ObjectSynchronizer::monitors_iterate(&rjmc, current);\n+  ObjectSynchronizer::owned_monitors_iterate(&rjmc, current);\n@@ -1862,6 +1788,0 @@\n-    \/\/ Do deflations in order to reduce the in-use monitor population\n-    \/\/ that is reported by ObjectSynchronizer::log_in_use_monitor_details()\n-    \/\/ which is called by ObjectSynchronizer::audit_and_print_stats().\n-    while (deflate_idle_monitors(\/* ObjectMonitorsHashtable is not needed here *\/ nullptr) > 0) {\n-      ; \/\/ empty\n-    }\n@@ -1916,1 +1836,1 @@\n-    log_in_use_monitor_details(ls);\n+    log_in_use_monitor_details(ls, !on_exit \/* log_all *\/);\n@@ -1962,3 +1882,1 @@\n-    \/\/ This should not happen, but if it does, it is not fatal.\n-    out->print_cr(\"WARNING: monitor=\" INTPTR_FORMAT \": in-use monitor is \"\n-                  \"deflated.\", p2i(n));\n+    \/\/ This could happen when monitor deflation blocks for a safepoint.\n@@ -1967,0 +1885,1 @@\n+\n@@ -1996,2 +1915,1 @@\n-void ObjectSynchronizer::log_in_use_monitor_details(outputStream* out) {\n-  stringStream ss;\n+void ObjectSynchronizer::log_in_use_monitor_details(outputStream* out, bool log_all) {\n@@ -1999,0 +1917,1 @@\n+    stringStream ss;\n@@ -2004,12 +1923,18 @@\n-    MonitorList::Iterator iter = _in_use_list.iterator();\n-    while (iter.has_next()) {\n-      ObjectMonitor* mid = iter.next();\n-      const oop obj = mid->object_peek();\n-      const markWord mark = mid->header();\n-      ResourceMark rm;\n-      out->print(INTPTR_FORMAT \"  %d%d%d  \" INTPTR_FORMAT \"  %s\", p2i(mid),\n-                 mid->is_busy(), mark.hash() != 0, mid->owner() != nullptr,\n-                 p2i(obj), obj == nullptr ? \"\" : obj->klass()->external_name());\n-      if (mid->is_busy()) {\n-        out->print(\" (%s)\", mid->is_busy_to_string(&ss));\n-        ss.reset();\n+\n+    auto is_interesting = [&](ObjectMonitor* monitor) {\n+      return log_all || monitor->has_owner() || monitor->is_busy();\n+    };\n+\n+    monitors_iterate([&](ObjectMonitor* monitor) {\n+      if (is_interesting(monitor)) {\n+        const oop obj = monitor->object_peek();\n+        const markWord mark = monitor->header();\n+        ResourceMark rm;\n+        out->print(INTPTR_FORMAT \"  %d%d%d  \" INTPTR_FORMAT \"  %s\", p2i(monitor),\n+                   monitor->is_busy(), mark.hash() != 0, monitor->owner() != nullptr,\n+                   p2i(obj), obj == nullptr ? \"\" : obj->klass()->external_name());\n+        if (monitor->is_busy()) {\n+          out->print(\" (%s)\", monitor->is_busy_to_string(&ss));\n+          ss.reset();\n+        }\n+        out->cr();\n@@ -2017,2 +1942,1 @@\n-      out->cr();\n-    }\n+    });\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":75,"deletions":151,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -39,49 +39,0 @@\n-\/\/ Hash table of void* to a list of ObjectMonitor* owned by the JavaThread.\n-\/\/ The JavaThread's owner key is either a JavaThread* or a stack lock\n-\/\/ address in the JavaThread so we use \"void*\".\n-\/\/\n-class ObjectMonitorsHashtable {\n- private:\n-  static unsigned int ptr_hash(void* const& s1) {\n-    \/\/ 2654435761 = 2^32 * Phi (golden ratio)\n-    return (unsigned int)(((uint32_t)(uintptr_t)s1) * 2654435761u);\n-  }\n-\n- public:\n-  class PtrList;\n-\n- private:\n-  \/\/ ResourceHashtable SIZE is specified at compile time so we\n-  \/\/ use 1031 which is the first prime after 1024.\n-  typedef ResourceHashtable<void*, PtrList*, 1031, AnyObj::C_HEAP, mtThread,\n-                            &ObjectMonitorsHashtable::ptr_hash> PtrTable;\n-  PtrTable* _ptrs;\n-  size_t _key_count;\n-  size_t _om_count;\n-\n- public:\n-  \/\/ ResourceHashtable is passed to various functions and populated in\n-  \/\/ different places so we allocate it using C_HEAP to make it immune\n-  \/\/ from any ResourceMarks that happen to be in the code paths.\n-  ObjectMonitorsHashtable() : _ptrs(new (mtThread) PtrTable), _key_count(0), _om_count(0) {}\n-\n-  ~ObjectMonitorsHashtable();\n-\n-  void add_entry(void* key, ObjectMonitor* om);\n-\n-  void add_entry(void* key, PtrList* list) {\n-    _ptrs->put(key, list);\n-    _key_count++;\n-  }\n-\n-  PtrList* get_entry(void* key) {\n-    PtrList** listpp = _ptrs->get(key);\n-    return (listpp == nullptr) ? nullptr : *listpp;\n-  }\n-\n-  bool has_entry(void* key, ObjectMonitor* om);\n-\n-  size_t key_count() { return _key_count; }\n-  size_t om_count() { return _om_count; }\n-};\n-\n@@ -175,0 +126,9 @@\n+  \/\/ Iterate over all ObjectMonitors.\n+  template <typename Function>\n+  static void monitors_iterate(Function function);\n+\n+  \/\/ Iterate ObjectMonitors owned by any thread and where the owner `filter`\n+  \/\/ returns true.\n+  template <typename OwnerFilter>\n+  static void owned_monitors_iterate_filtered(MonitorClosure* closure, OwnerFilter filter);\n+\n@@ -176,8 +136,5 @@\n-  \/\/ ObjectMonitors where owner is set to a stack lock address in thread:\n-  \/\/\n-  \/\/ This version of monitors_iterate() works with the in-use monitor list.\n-  static void monitors_iterate(MonitorClosure* m, JavaThread* thread);\n-  \/\/ This version of monitors_iterate() works with the specified linked list.\n-  static void monitors_iterate(MonitorClosure* closure,\n-                               ObjectMonitorsHashtable::PtrList* list,\n-                               JavaThread* thread);\n+  \/\/ ObjectMonitors where owner is set to a stack lock address in thread.\n+  static void owned_monitors_iterate(MonitorClosure* m, JavaThread* thread);\n+\n+  \/\/ Iterate ObjectMonitors owned by any thread.\n+  static void owned_monitors_iterate(MonitorClosure* closure);\n@@ -188,3 +145,3 @@\n-  \/\/ GC: we currently use aggressive monitor deflation policy\n-  \/\/ Basically we try to deflate all monitors that are not busy.\n-  static size_t deflate_idle_monitors(ObjectMonitorsHashtable* table);\n+  \/\/ We currently use aggressive monitor deflation policy;\n+  \/\/ basically we try to deflate all monitors that are not busy.\n+  static size_t deflate_idle_monitors();\n@@ -196,2 +153,1 @@\n-  static size_t deflate_monitor_list(Thread* current, LogStream* ls, elapsedTimer* timer_p,\n-                                     ObjectMonitorsHashtable* table);\n+  static size_t deflate_monitor_list(Thread* current, LogStream* ls, elapsedTimer* timer_p);\n@@ -207,1 +163,2 @@\n-  static bool request_deflate_idle_monitors();  \/\/ for whitebox test support\n+  static void request_deflate_idle_monitors();\n+  static bool request_deflate_idle_monitors_from_wb();  \/\/ for whitebox test support\n@@ -217,1 +174,1 @@\n-  static void log_in_use_monitor_details(outputStream* out);\n+  static void log_in_use_monitor_details(outputStream* out, bool log_all);\n@@ -255,0 +212,7 @@\n+\/\/ Interface to visit monitors\n+class ObjectMonitorsView {\n+public:\n+  \/\/ Visit monitors that belong to the given thread\n+  virtual void visit(MonitorClosure* closure, JavaThread* thread) = 0;\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":28,"deletions":64,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -52,0 +53,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -268,0 +270,105 @@\n+\/\/ Hash table of void* to a list of ObjectMonitor* owned by the JavaThread.\n+\/\/ The JavaThread's owner key is either a JavaThread* or a stack lock\n+\/\/ address in the JavaThread so we use \"void*\".\n+\/\/\n+class ObjectMonitorsDump : public MonitorClosure, public ObjectMonitorsView {\n+ private:\n+  static unsigned int ptr_hash(void* const& s1) {\n+    \/\/ 2654435761 = 2^32 * Phi (golden ratio)\n+    return (unsigned int)(((uint32_t)(uintptr_t)s1) * 2654435761u);\n+  }\n+\n+ private:\n+  class ObjectMonitorLinkedList :\n+    public LinkedListImpl<ObjectMonitor*,\n+                          AnyObj::C_HEAP, mtThread,\n+                          AllocFailStrategy::RETURN_NULL> {};\n+\n+  \/\/ ResourceHashtable SIZE is specified at compile time so we\n+  \/\/ use 1031 which is the first prime after 1024.\n+  typedef ResourceHashtable<void*, ObjectMonitorLinkedList*, 1031, AnyObj::C_HEAP, mtThread,\n+                            &ObjectMonitorsDump::ptr_hash> PtrTable;\n+  PtrTable* _ptrs;\n+  size_t _key_count;\n+  size_t _om_count;\n+\n+  void add_list(void* key, ObjectMonitorLinkedList* list) {\n+    _ptrs->put(key, list);\n+    _key_count++;\n+  }\n+\n+  ObjectMonitorLinkedList* get_list(void* key) {\n+    ObjectMonitorLinkedList** listpp = _ptrs->get(key);\n+    return (listpp == nullptr) ? nullptr : *listpp;\n+  }\n+\n+  void add(ObjectMonitor* monitor) {\n+    void* key = monitor->owner();\n+\n+    ObjectMonitorLinkedList* list = get_list(key);\n+    if (list == nullptr) {\n+      \/\/ Create new list and add it to the hash table:\n+      list = new (mtThread) ObjectMonitorLinkedList;\n+      _ptrs->put(key, list);\n+      _key_count++;\n+    }\n+\n+    assert(list->find(monitor) == nullptr, \"Should not contain duplicates\");\n+    list->add(monitor);  \/\/ Add the ObjectMonitor to the list.\n+    _om_count++;\n+  }\n+\n+ public:\n+  \/\/ ResourceHashtable is passed to various functions and populated in\n+  \/\/ different places so we allocate it using C_HEAP to make it immune\n+  \/\/ from any ResourceMarks that happen to be in the code paths.\n+  ObjectMonitorsDump() : _ptrs(new (mtThread) PtrTable), _key_count(0), _om_count(0) {}\n+\n+  ~ObjectMonitorsDump() {\n+    class CleanupObjectMonitorsDump: StackObj {\n+     public:\n+      bool do_entry(void*& key, ObjectMonitorLinkedList*& list) {\n+        list->clear();  \/\/ clear the LinkListNodes\n+        delete list;    \/\/ then delete the LinkedList\n+        return true;\n+      }\n+    } cleanup;\n+\n+    _ptrs->unlink(&cleanup);  \/\/ cleanup the LinkedLists\n+    delete _ptrs;             \/\/ then delete the hash table\n+  }\n+\n+  \/\/ Implements MonitorClosure used to collect all owned monitors in the system\n+  void do_monitor(ObjectMonitor* monitor) override {\n+    assert(monitor->has_owner(), \"Expects only owned monitors\");\n+\n+    if (monitor->is_owner_anonymous()) {\n+      \/\/ There's no need to collect anonymous owned monitors\n+      \/\/ because the caller of this code is only interested\n+      \/\/ in JNI owned monitors.\n+      return;\n+    }\n+\n+    if (monitor->object_peek() == nullptr) {\n+      \/\/ JNI code doesn't necessarily keep the monitor object\n+      \/\/ alive. Filter out monitors with dead objects.\n+      return;\n+    }\n+\n+    add(monitor);\n+  }\n+\n+  \/\/ Implements the ObjectMonitorsView interface\n+  void visit(MonitorClosure* closure, JavaThread* thread) override {\n+    ObjectMonitorLinkedList* list = get_list(thread);\n+    LinkedListIterator<ObjectMonitor*> iter(list != nullptr ? list->head() : nullptr);\n+    while (!iter.is_empty()) {\n+      ObjectMonitor* monitor = *iter.next();\n+      closure->do_monitor(monitor);\n+    }\n+  }\n+\n+  size_t key_count() { return _key_count; }\n+  size_t om_count() { return _om_count; }\n+};\n+\n@@ -282,2 +389,1 @@\n-  ObjectMonitorsHashtable table;\n-  ObjectMonitorsHashtable* tablep = nullptr;\n+  ObjectMonitorsDump object_monitors;\n@@ -285,7 +391,12 @@\n-    \/\/ The caller wants locked monitor information and that's expensive to gather\n-    \/\/ when there are a lot of inflated monitors. So we deflate idle monitors and\n-    \/\/ gather information about owned monitors at the same time.\n-    tablep = &table;\n-    while (ObjectSynchronizer::deflate_idle_monitors(tablep) > 0) {\n-      ; \/* empty *\/\n-    }\n+    \/\/ Gather information about owned monitors.\n+    ObjectSynchronizer::owned_monitors_iterate(&object_monitors);\n+\n+    \/\/ If there are many object monitors in the system then the above iteration\n+    \/\/ can start to take time. Be friendly to following thread dumps by telling\n+    \/\/ the MonitorDeflationThread to deflate monitors.\n+    \/\/\n+    \/\/ This is trying to be somewhat backwards compatible with the previous\n+    \/\/ implementation, which performed monitor deflation right here. We might\n+    \/\/ want to reconsider the need to trigger monitor deflation from the thread\n+    \/\/ dumping and instead maybe tweak the deflation heuristics.\n+    ObjectSynchronizer::request_deflate_idle_monitors();\n@@ -308,1 +419,1 @@\n-      snapshot_thread(jt, tcl, tablep);\n+      snapshot_thread(jt, tcl, &object_monitors);\n@@ -343,1 +454,1 @@\n-      snapshot_thread(jt, tcl, tablep);\n+      snapshot_thread(jt, tcl, &object_monitors);\n@@ -349,1 +460,1 @@\n-                                    ObjectMonitorsHashtable* table) {\n+                                    ObjectMonitorsView* monitors) {\n@@ -351,1 +462,1 @@\n-  snapshot->dump_stack_at_safepoint(_max_depth, _with_locked_monitors, table, false);\n+  snapshot->dump_stack_at_safepoint(_max_depth, _with_locked_monitors, monitors, false);\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":124,"deletions":13,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-class ObjectMonitorsHashtable;\n+class ObjectMonitorsView;\n@@ -207,1 +207,1 @@\n-                       ObjectMonitorsHashtable* table);\n+                       ObjectMonitorsView* monitors);\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -690,1 +691,1 @@\n-void ThreadStackTrace::dump_stack_at_safepoint(int maxDepth, ObjectMonitorsHashtable* table, bool full) {\n+void ThreadStackTrace::dump_stack_at_safepoint(int maxDepth, ObjectMonitorsView* monitors, bool full) {\n@@ -726,11 +727,1 @@\n-    if (table != nullptr) {\n-      \/\/ Get the ObjectMonitors locked by the target thread, if any,\n-      \/\/ and does not include any where owner is set to a stack lock\n-      \/\/ address in the target thread:\n-      ObjectMonitorsHashtable::PtrList* list = table->get_entry(_thread);\n-      if (list != nullptr) {\n-        ObjectSynchronizer::monitors_iterate(&imc, list, _thread);\n-      }\n-    } else {\n-      ObjectSynchronizer::monitors_iterate(&imc, _thread);\n-    }\n+    monitors->visit(&imc, _thread);\n@@ -991,1 +982,1 @@\n-                                             ObjectMonitorsHashtable* table, bool full) {\n+                                             ObjectMonitorsView* monitors, bool full) {\n@@ -993,1 +984,1 @@\n-  _stack_trace->dump_stack_at_safepoint(max_depth, table, full);\n+  _stack_trace->dump_stack_at_safepoint(max_depth, monitors, full);\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-class ObjectMonitorsHashtable;\n+class ObjectMonitorsView;\n@@ -267,1 +267,1 @@\n-                                      ObjectMonitorsHashtable* table, bool full);\n+                                      ObjectMonitorsView* monitors, bool full);\n@@ -290,1 +290,1 @@\n-  void            dump_stack_at_safepoint(int max_depth, ObjectMonitorsHashtable* table, bool full);\n+  void            dump_stack_at_safepoint(int max_depth, ObjectMonitorsView* monitors, bool full);\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -402,0 +402,1 @@\n+ -runtime\/Monitor\/ConcurrentDeflation.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadInfo;\n+import java.lang.management.ThreadMXBean;\n+\n+\/*\n+ * @test\n+ * @bug 8318757\n+ * @summary Test concurrent monitor deflation by MonitorDeflationThread and thread dumping\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:GuaranteedAsyncDeflationInterval=2000 -XX:+UnlockExperimentalVMOptions -XX:LockingMode=0 ConcurrentDeflation\n+ *\/\n+\n+public class ConcurrentDeflation {\n+    public static final long TOTAL_RUN_TIME_NS = 10_000_000_000L;\n+    public static Object[] monitors = new Object[1000];\n+    public static int monitorCount;\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread threadDumper = new Thread(() -> dumpThreads());\n+        threadDumper.start();\n+        Thread monitorCreator = new Thread(() -> createMonitors());\n+        monitorCreator.start();\n+\n+        threadDumper.join();\n+        monitorCreator.join();\n+    }\n+\n+    static private void dumpThreads() {\n+        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();\n+        int dumpCount = 0;\n+        long startTime = System.nanoTime();\n+        while (System.nanoTime() - startTime < TOTAL_RUN_TIME_NS) {\n+            threadBean.dumpAllThreads(true, false);\n+            dumpCount++;\n+            try {\n+                Thread.sleep(10);\n+            } catch (InterruptedException e) {}\n+        }\n+        System.out.println(\"Dumped all thread info \" + dumpCount + \" times\");\n+    }\n+\n+    static private void createMonitors() {\n+        int index = 0;\n+        long startTime = System.nanoTime();\n+        while (System.nanoTime() - startTime < TOTAL_RUN_TIME_NS) {\n+            index = index++ % 1000;\n+            monitors[index] = new Object();\n+            synchronized (monitors[index]) {\n+                monitorCount++;\n+            }\n+        }\n+        System.out.println(\"Created \" + monitorCount + \" monitors\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/ConcurrentDeflation.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @bug 8320515\n+ * @summary This test checks that ObjectMonitors with dead objects don't\n+ *          cause asserts, crashes, or failures when various sub-systems\n+ *          in the JVM find them.\n+ * @library \/testlibrary \/test\/lib\n+ * @modules jdk.management\n+ *\/\n+\n+\/*\n+ * @requires os.family != \"windows\" & os.family != \"aix\"\n+ * @test id=DetachThread\n+ * @run main\/othervm\/native MonitorWithDeadObjectTest 0\n+ *\/\n+\n+\/*\n+ * @requires os.family != \"windows\" & os.family != \"aix\"\n+ * @test id=DumpThreadsBeforeDetach\n+ * @run main\/othervm\/native MonitorWithDeadObjectTest 1\n+ *\/\n+\n+\/*\n+ * @requires os.family != \"windows\" & os.family != \"aix\"\n+ * @test id=DumpThreadsAfterDetach\n+ * @run main\/othervm\/native MonitorWithDeadObjectTest 2\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ThreadMXBean;\n+\n+public class MonitorWithDeadObjectTest {\n+    public static native void createMonitorWithDeadObject();\n+    public static native void createMonitorWithDeadObjectDumpThreadsBeforeDetach();\n+\n+    static {\n+        System.loadLibrary(\"MonitorWithDeadObjectTest\");\n+    }\n+\n+    private static void dumpThreadsWithLockedMonitors() {\n+        ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();\n+        threadBean.dumpAllThreads(true, false);\n+    }\n+\n+    private static void testDetachThread() {\n+        \/\/ Create an ObjectMonitor with a dead object from an attached thread.\n+        \/\/ This used to provoke an assert in DetachCurrentThread.\n+        createMonitorWithDeadObject();\n+    }\n+\n+    private static void testDumpThreadsBeforeDetach() {\n+        \/\/ Create an ObjectMonitor with a dead object from an attached thread\n+        \/\/ and perform a thread dump before detaching the thread.\n+        createMonitorWithDeadObjectDumpThreadsBeforeDetach();\n+    }\n+\n+    private static void testDumpThreadsAfterDetach() {\n+        createMonitorWithDeadObject();\n+\n+        \/\/ The thread dumping code used to not tolerate monitors with dead\n+        \/\/ objects and the detach code used to not unlock these monitors, so\n+        \/\/ test that we don't end up with a bug where these monitors are not\n+        \/\/ unlocked and then passed to the thread dumping code.\n+        dumpThreadsWithLockedMonitors();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        int test = Integer.parseInt(args[0]);\n+        switch (test) {\n+            case 0: testDetachThread(); break;\n+            case 1: testDumpThreadsBeforeDetach(); break;\n+            case 2: testDumpThreadsAfterDetach(); break;\n+            default: throw new RuntimeException(\"Unknown test\");\n+        };\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/MonitorWithDeadObjectTest.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <pthread.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+static JavaVM* jvm;\n+static pthread_t attacher;\n+\n+#define die(x) do { printf(\"%s:%s\\n\",x , __func__); perror(x); exit(EXIT_FAILURE); } while (0)\n+\n+static void check_exception(JNIEnv* env, const char* msg) {\n+  if ((*env)->ExceptionCheck(env)) {\n+    fprintf(stderr, \"Error: %s\", msg);\n+    exit(-1);\n+  }\n+}\n+\n+#define check(env, what, msg)                      \\\n+  check_exception((env), (msg));                   \\\n+  do {                                             \\\n+    if ((what) == 0) {                             \\\n+      fprintf(stderr, #what \"is null: %s\", (msg)); \\\n+      exit(-2);                                    \\\n+    }                                              \\\n+  } while (0)\n+\n+static jobject create_object(JNIEnv* env) {\n+  jclass clazz = (*env)->FindClass(env, \"java\/lang\/Object\");\n+  check(env, clazz, \"No class\");\n+\n+  jmethodID constructor = (*env)->GetMethodID(env, clazz, \"<init>\", \"()V\");\n+  check(env, constructor, \"No constructor\");\n+\n+  jobject obj = (*env)->NewObject(env, clazz, constructor);\n+  check(env, constructor, \"No object\");\n+\n+  return obj;\n+}\n+\n+static void system_gc(JNIEnv* env) {\n+  jclass clazz = (*env)->FindClass(env, \"java\/lang\/System\");\n+  check(env, clazz, \"No class\");\n+\n+  jmethodID method = (*env)->GetStaticMethodID(env, clazz, \"gc\", \"()V\");\n+  check(env, method, \"No method\");\n+\n+  (*env)->CallStaticVoidMethod(env, clazz, method);\n+  check_exception(env, \"Calling System.gc()\");\n+}\n+\n+static void thread_dump_with_locked_monitors(JNIEnv* env) {\n+  jclass ManagementFactoryClass = (*env)->FindClass(env, \"java\/lang\/management\/ManagementFactory\");\n+  check(env, ManagementFactoryClass, \"No ManagementFactory class\");\n+\n+  jmethodID getThreadMXBeanMethod = (*env)->GetStaticMethodID(env, ManagementFactoryClass, \"getThreadMXBean\", \"()Ljava\/lang\/management\/ThreadMXBean;\");\n+  check(env, getThreadMXBeanMethod, \"No getThreadMXBean method\");\n+\n+  jobject threadBean = (*env)->CallStaticObjectMethod(env, ManagementFactoryClass, getThreadMXBeanMethod);\n+  check(env, threadBean, \"Calling getThreadMXBean()\");\n+\n+  jclass ThreadMXBeanClass = (*env)->FindClass(env, \"java\/lang\/management\/ThreadMXBean\");\n+  check(env, ThreadMXBeanClass, \"No ThreadMXBean class\");\n+\n+  jmethodID dumpAllThreadsMethod = (*env)->GetMethodID(env, ThreadMXBeanClass, \"dumpAllThreads\", \"(ZZ)[Ljava\/lang\/management\/ThreadInfo;\");\n+  check(env, dumpAllThreadsMethod, \"No dumpAllThreads method\");\n+\n+  \/\/ The 'lockedMonitors == true' is what causes the monitor with a dead object to be examined.\n+  jobject array = (*env)->CallObjectMethod(env, threadBean, dumpAllThreadsMethod, JNI_TRUE \/* lockedMonitors *\/, JNI_FALSE \/* lockedSynchronizers*\/);\n+  check(env, array, \"Calling dumpAllThreads(true, false)\");\n+}\n+\n+static void create_monitor_with_dead_object(JNIEnv* env) {\n+  jobject obj = create_object(env);\n+\n+  if ((*env)->MonitorEnter(env, obj) != 0) die(\"MonitorEnter\");\n+\n+  \/\/ Drop the last strong reference to the object associated with the monitor.\n+  \/\/ The monitor only keeps a weak reference to the object.\n+  (*env)->DeleteLocalRef(env, obj);\n+\n+  \/\/ Let the GC clear the weak reference to the object.\n+  system_gc(env);\n+}\n+\n+static void* create_monitor_with_dead_object_in_thread(void* arg) {\n+  JNIEnv* env;\n+  int res = (*jvm)->AttachCurrentThread(jvm, (void**)&env, NULL);\n+  if (res != JNI_OK) die(\"AttachCurrentThread\");\n+\n+  \/\/ Make the correct incantation to create a monitor with a dead object.\n+  create_monitor_with_dead_object(env);\n+\n+  \/\/ DetachCurrentThread will try to unlock held monitors. This has been a\n+  \/\/ source of at least two bugs:\n+  \/\/ - When the object reference in the monitor was cleared, the monitor\n+  \/\/   iterator code would skip it, preventing it from being unlocked when\n+  \/\/   the owner thread detached, leaving it lingering in the system.\n+  \/\/ - When the monitor iterator API was rewritten the code was changed to\n+  \/\/   assert that we didn't have \"owned\" monitors with dead objects. This\n+  \/\/   test provokes that situation and that asserts.\n+  if ((*jvm)->DetachCurrentThread(jvm) != JNI_OK) die(\"DetachCurrentThread\");\n+\n+  return NULL;\n+}\n+\n+static void* create_monitor_with_dead_object_and_dump_threads_in_thread(void* arg) {\n+  JNIEnv* env;\n+  int res = (*jvm)->AttachCurrentThread(jvm, (void**)&env, NULL);\n+  if (res != JNI_OK) die(\"AttachCurrentThread\");\n+\n+  \/\/ Make the correct incantation to create a monitor with a dead object.\n+  create_monitor_with_dead_object(env);\n+\n+  \/\/ Perform a thread dump that checks for all thread's monitors.\n+  \/\/ That code didn't expect the monitor iterators to return monitors\n+  \/\/ with dead objects and therefore asserted\/crashed.\n+  thread_dump_with_locked_monitors(env);\n+\n+  if ((*jvm)->DetachCurrentThread(jvm) != JNI_OK) die(\"DetachCurrentThread\");\n+\n+  return NULL;\n+}\n+\n+JNIEXPORT void JNICALL Java_MonitorWithDeadObjectTest_createMonitorWithDeadObject(JNIEnv* env, jclass jc) {\n+  void* ret;\n+\n+  (*env)->GetJavaVM(env, &jvm);\n+\n+  if (pthread_create(&attacher, NULL, create_monitor_with_dead_object_in_thread, NULL) != 0) die(\"pthread_create\");\n+  if (pthread_join(attacher, &ret) != 0) die(\"pthread_join\");\n+}\n+\n+JNIEXPORT void JNICALL Java_MonitorWithDeadObjectTest_createMonitorWithDeadObjectDumpThreadsBeforeDetach(JNIEnv* env, jclass jc) {\n+  void* ret;\n+\n+  (*env)->GetJavaVM(env, &jvm);\n+\n+  if (pthread_create(&attacher, NULL, create_monitor_with_dead_object_and_dump_threads_in_thread, NULL) != 0) die(\"pthread_create\");\n+  if (pthread_join(attacher, &ret) != 0) die(\"pthread_join\");\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/libMonitorWithDeadObjectTest.c","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -27,2 +27,4 @@\n- * @bug 8185164\n- * @summary Checks that a contended monitor does not show up in the list of owned monitors\n+ * @bug 8185164 8320515\n+ * @summary Checks that a contended monitor does not show up in the list of owned monitors.\n+ *          8320515 piggy-backs on this test and injects an owned monitor with a dead object,\n+            and checks that that monitor isn't exposed to GetOwnedMonitorInfo.\n@@ -49,0 +51,1 @@\n+    private static native void jniMonitorEnter(Object obj);\n@@ -52,0 +55,14 @@\n+    private static void jniMonitorEnterAndLetObjectDie() {\n+        \/\/ The monitor iterator used by GetOwnedMonitorInfo used to\n+        \/\/ assert when an owned monitor with a dead object was found.\n+        \/\/ Inject this situation into this test that performs other\n+        \/\/ GetOwnedMonitorInfo testing.\n+        Object obj = new Object() {};\n+        jniMonitorEnter(obj);\n+        if (!Thread.holdsLock(obj)) {\n+            throw new RuntimeException(\"The object is not locked\");\n+        }\n+        obj = null;\n+        System.gc();\n+    }\n+\n@@ -53,2 +70,4 @@\n-        runTest(true);\n-        runTest(false);\n+        runTest(true, true);\n+        runTest(true, false);\n+        runTest(false, true);\n+        runTest(false, false);\n@@ -57,1 +76,1 @@\n-    public static void runTest(boolean isVirtual) throws Exception {\n+    public static void runTest(boolean isVirtual, boolean jni) throws Exception {\n@@ -62,0 +81,6 @@\n+            Thread.currentThread().setName(\"Worker-Thread\");\n+\n+            if (jni) {\n+                jniMonitorEnterAndLetObjectDie();\n+            }\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetOwnedMonitorInfo\/GetOwnedMonitorInfoTest.java","additions":30,"deletions":5,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include <stdlib.h>\n@@ -267,0 +268,8 @@\n+JNIEXPORT void JNICALL\n+Java_GetOwnedMonitorInfoTest_jniMonitorEnter(JNIEnv* env, jclass cls, jobject obj) {\n+    if ((*env)->MonitorEnter(env, obj) != 0) {\n+        fprintf(stderr, \"MonitorEnter failed\");\n+        exit(-1);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/GetOwnedMonitorInfo\/libGetOwnedMonitorInfoTest.c","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}