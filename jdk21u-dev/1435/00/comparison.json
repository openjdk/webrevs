{"files":[{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4286726\n+ * @summary Java2D raster printing: large text may overflow glyph cache.\n+ *          Draw a large glyphvector, the 'A' glyph should appear and not get flushed.\n+*\/\n+\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Graphics2D;\n+import java.awt.RenderingHints;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+import java.awt.geom.Point2D;\n+import java.awt.image.BufferedImage;\n+import java.util.HashMap;\n+\n+\/**\n+ * Draw a very large glyphvector on a surface.\n+ * If the cache was flushed the first glyph is not rendered.\n+ * Note: the implementation no longer uses glyphs for rendering large text,\n+ * but in principle the test is still useful.\n+ *\/\n+public class CacheFlushTest {\n+\n+    static final int WIDTH = 400, HEIGHT = 600;\n+    static final int FONTSIZE = 250;\n+    static final String TEST = \"ABCDEFGHIJKLMNOP\";\n+    static final HashMap<RenderingHints.Key, Object> HINTS = new HashMap<>();\n+\n+    static {\n+      HINTS.put(RenderingHints.KEY_ANTIALIASING,\n+                RenderingHints.VALUE_ANTIALIAS_ON);\n+      HINTS.put(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n+      HINTS.put(RenderingHints.KEY_FRACTIONALMETRICS,\n+                RenderingHints.VALUE_FRACTIONALMETRICS_ON);\n+    }\n+\n+    public static void main(String args[]) {\n+        BufferedImage bi = new BufferedImage(WIDTH, HEIGHT, BufferedImage.TYPE_INT_RGB);\n+\n+        Graphics2D g2d = bi.createGraphics();\n+        g2d.addRenderingHints(HINTS);\n+        g2d.setColor(Color.white);\n+        g2d.fillRect(0, 0, WIDTH, HEIGHT);\n+        g2d.setColor(Color.black);\n+\n+        FontRenderContext frc = g2d.getFontRenderContext();\n+        Font font = new Font(Font.DIALOG, Font.PLAIN, 250);\n+        GlyphVector gv = font.createGlyphVector(frc, TEST);\n+\n+        \/* Set the positions of all but the first glyph to be offset vertically but\n+         * FONTSIZE pixels. So if the first glyph \"A\" is not flushed we can tell this\n+         * by checking for non-white pixels in the range for the default y offset of 0\n+         * from the specified y location.\n+         *\/\n+        Point2D.Float pt = new Point2D.Float(20f, FONTSIZE);\n+        for (int i = 1; i < gv.getNumGlyphs(); ++i) {\n+            gv.setGlyphPosition(i, pt);\n+            pt.x += 25f;\n+            pt.y = FONTSIZE;\n+        }\n+        g2d.drawGlyphVector(gv, 20, FONTSIZE);\n+        \/* Now expect to find at least one black pixel in the rect (0,0) -> (WIDTH, FONTSIZE) *\/\n+        boolean found = false;\n+        int blackPixel = Color.black.getRGB();\n+        for (int y = 0; y < FONTSIZE; y++) {\n+            for (int x = 0; x < WIDTH; x++) {\n+                if (bi.getRGB(x, y) == blackPixel) {\n+                    found = true;\n+                    break;\n+                }\n+            }\n+            if (found == true) {\n+                break;\n+            }\n+        }\n+        if (!found) {\n+            throw new RuntimeException(\"NO BLACK PIXELS\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/awt\/font\/CacheFlushTest.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4198081\n+ * @key headful\n+ * @summary Arabic characters should appear instead of boxes and be correctly shaped.\n+ *          Hebrew characters should appear instead of boxes.\n+ *          Test is made headful so there's no excuse for test systems not having the fonts.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.GridLayout;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+import java.awt.geom.Rectangle2D;\n+\n+public class TestArabicHebrew extends Panel {\n+\n+    static volatile Frame frame;\n+    static volatile Font font = new Font(Font.DIALOG, Font.PLAIN, 36);\n+\n+    static void createUI() {\n+        frame = new Frame(\"Test Arabic\/Hebrew\");\n+        frame.setLayout(new BorderLayout());\n+        TestArabicHebrew panel = new TestArabicHebrew();\n+        frame.add(panel, BorderLayout.CENTER);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        EventQueue.invokeAndWait(TestArabicHebrew::createUI);\n+        try {\n+             checkStrings();\n+        } finally {\n+           if (frame != null && args.length == 0) {\n+               EventQueue.invokeAndWait(frame::dispose);\n+           }\n+        }\n+    }\n+\n+    static void checkString(String script, String str) {\n+        int index = font.canDisplayUpTo(str);\n+        if (index != -1) {\n+            throw new RuntimeException(\"Cannot display char \" +  index + \" for \" + script);\n+        }\n+    }\n+\n+    static void checkStrings() {\n+        checkString(\"Arabic\", arabic);\n+        checkString(\"Hebrew\", hebrew);\n+        checkString(\"Latin-1 Supplement\", latin1sup);\n+    }\n+\n+    \/\/ Table of arabic unicode characters - minimal support level\n+    \/\/ Includes arabic chars from basic block up to 0652 and\n+    \/\/ corresponding shaped characters from the arabic\n+    \/\/ extended-B block from fe80 to fefc (does include lam-alef\n+    \/\/ ligatures).\n+    \/\/ Does not include arabic-indic digits nor \"arabic extended\"\n+    \/\/ range.\n+\n+    static final String arabic =\n+    \"\\u060c\\u061b\\u061f\\u0621\\u0622\\u0623\\u0624\\u0625\\u0626\\u0627\"\n+    + \"\\u0628\\u0629\\u062a\\u062b\\u062c\\u062d\\u062e\\u062f\\u0630\\u0631\"\n+    + \"\\u0632\\u0633\\u0634\\u0635\\u0636\\u0637\\u0638\\u0639\\u063a\\u0640\"\n+    + \"\\u0641\\u0642\\u0643\\u0644\\u0645\\u0646\\u0647\\u0648\\u0649\\u064a\"\n+    + \"\\u064b\\u064c\\u064d\\u064e\\u064f\\u0650\\u0651\\u0652\\ufe80\\ufe81\"\n+    + \"\\ufe82\\ufe83\\ufe84\\ufe85\\ufe86\\ufe87\\ufe88\\ufe89\\ufe8a\\ufe8b\"\n+    + \"\\ufe8c\\ufe8d\\ufe8e\\ufe8f\\ufe90\\ufe91\\ufe92\\ufe93\\ufe94\\ufe95\"\n+    + \"\\ufe96\\ufe97\\ufe98\\ufe99\\ufe9a\\ufe9b\\ufe9c\\ufe9d\\ufe9e\\ufe9f\"\n+    + \"\\ufea0\\ufea1\\ufea2\\ufea3\\ufea4\\ufea5\\ufea6\\ufea7\\ufea8\\ufea9\"\n+    + \"\\ufeaa\\ufeab\\ufeac\\ufead\\ufeae\\ufeaf\\ufeb0\\ufeb1\\ufeb2\\ufeb3\"\n+    + \"\\ufeb4\\ufeb5\\ufeb6\\ufeb7\\ufeb8\\ufeb9\\ufeba\\ufebb\\ufebc\\ufebd\"\n+    + \"\\ufebe\\ufebf\\ufec0\\ufec1\\ufec2\\ufec3\\ufec4\\ufec5\\ufec6\\ufec7\"\n+    + \"\\ufec8\\ufec9\\ufeca\\ufecb\\ufecc\\ufecd\\ufece\\ufecf\\ufed0\\ufed1\"\n+    + \"\\ufed2\\ufed3\\ufed4\\ufed5\\ufed6\\ufed7\\ufed8\\ufed9\\ufeda\\ufedb\"\n+    + \"\\ufedc\\ufedd\\ufede\\ufedf\\ufee0\\ufee1\\ufee2\\ufee3\\ufee4\\ufee5\"\n+    + \"\\ufee6\\ufee7\\ufee8\\ufee9\\ufeea\\ufeeb\\ufeec\\ufeed\\ufeee\\ufeef\"\n+    + \"\\ufef0\\ufef1\\ufef2\\ufef3\\ufef4\\ufef5\\ufef6\\ufef7\\ufef8\\ufef9\"\n+    + \"\\ufefa\\ufefb\\ufefc\";\n+\n+    \/\/ hebrew table includes all characters in hebrew block\n+\n+    static final String hebrew =\n+    \"\\u0591\\u0592\\u0593\\u0594\\u0595\\u0596\\u0597\\u0598\\u0599\\u059a\"\n+    + \"\\u059b\\u059c\\u059d\\u059e\\u059f\\u05a0\\u05a1\\u05a3\\u05a4\\u05a5\"\n+    + \"\\u05a6\\u05a7\\u05a8\\u05a9\\u05aa\\u05ab\\u05ac\\u05ad\\u05ae\\u05af\"\n+    + \"\\u05b0\\u05b1\\u05b2\\u05b3\\u05b4\\u05b5\\u05b6\\u05b7\\u05b8\\u05b9\"\n+    + \"\\u05bb\\u05bc\\u05bd\\u05be\\u05bf\\u05c0\\u05c1\\u05c2\\u05c3\\u05c4\"\n+    + \"\\u05d0\\u05d1\\u05d2\\u05d3\\u05d4\\u05d5\\u05d6\\u05d7\\u05d8\\u05d9\"\n+    + \"\\u05da\\u05db\\u05dc\\u05dd\\u05de\\u05df\\u05e0\\u05e1\\u05e2\\u05e3\"\n+    + \"\\u05e4\\u05e5\\u05e6\\u05e7\\u05e8\\u05e9\\u05ea\\u05f0\\u05f1\\u05f2\"\n+    + \"\\u05f3\\u05f4\";\n+\n+    \/\/ latin 1 supplement table includes all non-control characters\n+    \/\/ in this range.  Included because of comment in code that claims\n+    \/\/ some problems displaying this range with some SJIS fonts.\n+\n+    static final String latin1sup =\n+    \"\\u00a0\\u00a1\\u00a2\\u00a3\\u00a4\\u00a5\\u00a6\\u00a7\"\n+    + \"\\u00a8\\u00a9\\u00aa\\u00ab\\u00ac\\u00ad\\u00ae\\u00af\\u00b0\\u00b1\"\n+    + \"\\u00b2\\u00b3\\u00b4\\u00b5\\u00b6\\u00b7\\u00b8\\u00b9\\u00ba\\u00bb\"\n+    + \"\\u00bc\\u00bd\\u00be\\u00bf\\u00c0\\u00c1\\u00c2\\u00c3\\u00c4\\u00c5\"\n+    + \"\\u00c6\\u00c7\\u00c8\\u00c9\\u00ca\\u00cb\\u00cc\\u00cd\\u00ce\\u00cf\"\n+    + \"\\u00d0\\u00d1\\u00d2\\u00d3\\u00d4\\u00d5\\u00d6\\u00d7\\u00d8\\u00d9\"\n+    + \"\\u00da\\u00db\\u00dc\\u00dd\\u00de\\u00df\\u00e0\\u00e1\\u00e2\\u00e3\"\n+    + \"\\u00e4\\u00e5\\u00e6\\u00e7\\u00e8\\u00e9\\u00ea\\u00eb\\u00ec\\u00ed\"\n+    + \"\\u00ee\\u00ef\\u00f0\\u00f1\\u00f2\\u00f3\\u00f4\\u00f5\\u00f6\\u00f7\"\n+    + \"\\u00f8\\u00f9\\u00fa\\u00fb\\u00fc\\u00fd\\u00fe\\u00ff\";\n+\n+    public TestArabicHebrew() {\n+        setLayout(new GridLayout(3, 1));\n+\n+        FontRenderContext frc = new FontRenderContext(null, false, false);\n+        add(new SubGlyphPanel(\"Arabic\", arabic, font, frc));\n+        add(new SubGlyphPanel(\"Hebrew\", hebrew, font, frc));\n+        add(new SubGlyphPanel(\"Latin-1 Supplement\", latin1sup, font, frc));\n+    }\n+\n+  static class SubGlyphPanel extends Panel {\n+      String title;\n+      Dimension extent;\n+      GlyphVector[] vectors;\n+\n+      static final int kGlyphsPerLine = 20;\n+\n+      SubGlyphPanel(String title, String chars, Font font, FontRenderContext frc) {\n+\n+          this.title = title;\n+          setBackground(Color.white);\n+\n+          double width = 0;\n+          double height = 0;\n+\n+          int max = chars.length();\n+          vectors = new GlyphVector[(max + kGlyphsPerLine - 1) \/ kGlyphsPerLine];\n+          for (int i = 0; i < vectors.length; i++) {\n+              int start = i * 20;\n+              int limit = Math.min(max, (i + 1) * kGlyphsPerLine);\n+              String substr = \"\";\n+              for (int j = start; j < limit; ++j) {\n+                  substr = substr.concat(chars.charAt(j) + \" \");\n+              }\n+              GlyphVector gv = font.createGlyphVector(frc, substr);\n+              vectors[i] = gv;\n+              Rectangle2D bounds = gv.getLogicalBounds();\n+\n+              width = Math.max(width, bounds.getWidth());\n+              height += bounds.getHeight();\n+          }\n+\n+          extent = new Dimension((int)(width + 1), (int)(height + 1 + 30)); \/\/ room for title\n+\n+          setSize(getPreferredSize());\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(extent);\n+    }\n+\n+    public Dimension getMinimumSize() {\n+        return getPreferredSize();\n+    }\n+\n+    public Dimension getMaximumSize() {\n+        return getPreferredSize();\n+    }\n+\n+    public void paint(Graphics g) {\n+        Graphics2D g2d = (Graphics2D)g;\n+\n+        g.drawString(title, 10, 20);\n+\n+        float x = 10;\n+        float y = 30;\n+        for (int i = 0; i < vectors.length; ++i) {\n+            GlyphVector gv = vectors[i];\n+            Rectangle2D bounds = gv.getLogicalBounds();\n+            g2d.drawGlyphVector(gv, x, (float)(y - bounds.getY()));\n+            y += bounds.getHeight();\n+        }\n+    }\n+  }\n+}\n","filename":"test\/jdk\/sun\/awt\/font\/TestArabicHebrew.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"},{"patch":"@@ -0,0 +1,155 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4269775\n+ * @summary Check that different text rendering APIs agree\n+ *\/\n+\n+\/**\n+ * Draw into an image rendering the same text string nine different\n+ * ways: as a TextLayout, a simple String, and a GlyphVector, each\n+ * with three different x scale factors. The expectation is that each\n+ * set of three strings would appear the same although offset in y to\n+ * avoid overlap. The bug was that the y positions of the individual characters\n+ * of the TextLayout and GlyphVector were wrong, so the strings appeared\n+ * to be rendered at different angles.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Font;\n+import java.awt.Graphics2D;\n+import java.awt.RenderingHints;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+import java.awt.font.TextLayout;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.BufferedImage;\n+import java.util.HashMap;\n+\n+public class TestDevTransform {\n+\n+    static HashMap<RenderingHints.Key, Object> hints = new HashMap<>();\n+\n+    static {\n+      hints.put(RenderingHints.KEY_ANTIALIASING,\n+                RenderingHints.VALUE_ANTIALIAS_ON);\n+      hints.put(RenderingHints.KEY_TEXT_ANTIALIASING,\n+                RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n+      hints.put(RenderingHints.KEY_FRACTIONALMETRICS,\n+                RenderingHints.VALUE_FRACTIONALMETRICS_ON);\n+    }\n+\n+    static String test = \"This is only a test\";\n+    static double angle = Math.PI \/ 6.0;  \/\/ Rotate 30 degrees\n+    static final int W = 400, H = 400;\n+\n+    static void draw(Graphics2D g2d, TextLayout layout,\n+                      float x, float y, float scalex) {\n+        AffineTransform saveTransform = g2d.getTransform();\n+        g2d.translate(x, y);\n+        g2d.rotate(angle);\n+        g2d.scale(scalex, 1f);\n+        layout.draw(g2d, 0f, 0f);\n+        g2d.setTransform(saveTransform);\n+      }\n+\n+    static void draw(Graphics2D g2d, String string,\n+                      float x, float y, float scalex) {\n+      AffineTransform saveTransform = g2d.getTransform();\n+      g2d.translate(x, y);\n+      g2d.rotate(angle);\n+      g2d.scale(scalex, 1f);\n+      g2d.drawString(string, 0f, 0f);\n+      g2d.setTransform(saveTransform);\n+    }\n+\n+    static void draw(Graphics2D g2d, GlyphVector gv,\n+                      float x, float y, float scalex) {\n+        AffineTransform saveTransform = g2d.getTransform();\n+        g2d.translate(x, y);\n+        g2d.rotate(angle);\n+        g2d.scale(scalex, 1f);\n+        g2d.drawGlyphVector(gv, 0f, 0f);\n+        g2d.setTransform(saveTransform);\n+      }\n+\n+    static void init(Graphics2D g2d) {\n+         g2d.setColor(Color.white);\n+         g2d.fillRect(0, 0, W, H);\n+         g2d.setColor(Color.black);\n+         g2d.scale(1.481f, 1.481);   \/\/ Convert to 108 dpi\n+         g2d.addRenderingHints(hints);\n+         Font font = new Font(Font.DIALOG, Font.PLAIN, 12);\n+         g2d.setFont(font);\n+    }\n+\n+    static void compare(BufferedImage bi1, BufferedImage bi2) {\n+        for (int x = 0; x < bi1.getWidth(); x++) {\n+            for (int y = 0; y < bi1.getHeight(); y++) {\n+                if (bi1.getRGB(x, y) != bi2.getRGB(x, y)) {\n+                    throw new RuntimeException(\"Different rendering\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void main(String args[]) {\n+\n+      BufferedImage tl_Image = new BufferedImage(W, H, BufferedImage.TYPE_INT_RGB);\n+      {\n+          Graphics2D tl_g2d = tl_Image.createGraphics();\n+          init(tl_g2d);\n+          FontRenderContext frc = tl_g2d.getFontRenderContext();\n+          \/\/ Specify font from graphics to be sure it is the same as the other cases.\n+          TextLayout tl = new TextLayout(test, tl_g2d.getFont(), frc);\n+          draw(tl_g2d, tl, 10f, 12f, 3.0f);\n+          draw(tl_g2d, tl, 10f, 24f, 1.0f);\n+          draw(tl_g2d, tl, 10f, 36f, 0.33f);\n+      }\n+\n+      BufferedImage st_Image = new BufferedImage(400, 400, BufferedImage.TYPE_INT_RGB);\n+      {\n+          Graphics2D st_g2d = st_Image.createGraphics();\n+          init(st_g2d);\n+          draw(st_g2d, test, 10f, 12f, 3.0f);\n+          draw(st_g2d, test, 10f, 24f, 1.0f);\n+          draw(st_g2d, test, 10f, 36f, .33f);\n+      }\n+\n+      BufferedImage gv_Image = new BufferedImage(400, 400, BufferedImage.TYPE_INT_RGB);\n+      {\n+          Graphics2D gv_g2d = gv_Image.createGraphics();\n+          init(gv_g2d);\n+          FontRenderContext frc = gv_g2d.getFontRenderContext();\n+          GlyphVector gv = gv_g2d.getFont().createGlyphVector(frc, test);\n+          draw(gv_g2d, gv, 10f, 12f, 3.0f);\n+          draw(gv_g2d, gv, 10f, 24f, 1.0f);\n+          draw(gv_g2d, gv, 10f, 36f, .33f);\n+      }\n+\n+      compare(tl_Image, st_Image);\n+      compare(gv_Image, st_Image);\n+  }\n+}\n","filename":"test\/jdk\/sun\/awt\/font\/TestDevTransform.java","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4277201\n+ * @summary verifies that invoking a fill on a brand new Graphics object\n+ *          does not stroke the shape in addition to filling it\n+ * @key headful\n+ *\/\n+\n+\/*\n+ * This test case tests for a problem with initializing GDI graphics\n+ * contexts (HDCs) where a pen is left installed in the graphics object\n+ * even though the AWT believes that there is no Pen installed.  The\n+ * result is that when you try to fill a shape, GDI will both fill and\n+ * stroke it.\n+*\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+\n+public class TestPen extends Panel {\n+\n+    static volatile TestPen pen;\n+    static volatile Frame frame;\n+\n+    public TestPen() {\n+        setForeground(Color.black);\n+        setBackground(Color.white);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return new Dimension(200, 200);\n+    }\n+\n+    public void paint(Graphics g) {\n+        g.setColor(Color.green);\n+        g.fillOval(50, 50, 100, 100);\n+    }\n+\n+   static void createUI() {\n+        frame = new Frame();\n+        pen = new TestPen();\n+        frame.add(pen);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String argv[]) throws Exception {\n+        try {\n+            EventQueue.invokeAndWait(TestPen::createUI);\n+            Robot robot = new Robot();\n+            robot.waitForIdle();\n+            robot.delay(2000);\n+            Point p = pen.getLocationOnScreen();\n+            Dimension d = pen.getSize();\n+            Rectangle r = new Rectangle(p.x + 1, p.y + 1, d.width - 2, d.height - 2);\n+            BufferedImage bi = robot.createScreenCapture(r);\n+            int blackPixel = Color.black.getRGB();\n+            for (int y = 0; y < bi.getHeight(); y++ ) {\n+                for (int x = 0; x < bi.getWidth(); x++ ) {\n+                    if (bi.getRGB(x, y) == blackPixel) {\n+                        throw new RuntimeException(\"Black pixel !\");\n+                    }\n+                }\n+            }\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/awt\/windows\/TestPen.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"}]}