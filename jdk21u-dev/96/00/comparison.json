{"files":[{"patch":"@@ -168,1 +168,1 @@\n-  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb);\n+  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, bool allow_cb_null = false);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb) {\n+inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, bool allow_cb_null) {\n@@ -106,1 +106,1 @@\n-  assert(_cb != nullptr, \"pc: \" INTPTR_FORMAT, p2i(pc));\n+  assert(_cb != nullptr || allow_cb_null, \"pc: \" INTPTR_FORMAT, p2i(pc));\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-  return frame(fr->link(), fr->link(), fr->sender_pc());\n+  return frame(fr->sender_sp(), fr->link(), fr->sender_pc());\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -155,0 +155,10 @@\n+\/\/ The \"Procedure Call Standard for the Arm 64-bit Architecture\" doesn't\n+\/\/ specify a location for the frame record within a stack frame (6.4.6).\n+\/\/ GCC currently chooses to save it at the top of the frame (lowest address).\n+\/\/ This means that using fr->sender_sp() to set the caller's frame _unextended_sp,\n+\/\/ as we do in x86, is wrong. Using fr->link() instead only makes sense for\n+\/\/ native frames. Setting a correct value for _unextended_sp is important\n+\/\/ if this value is later used to get that frame's caller. This will happen\n+\/\/ if we end up calling frame::sender_for_compiled_frame(), which will be the\n+\/\/ case if the _pc is associated with a CodeBlob that has a _frame_size > 0\n+\/\/ (nmethod, runtime stub, safepoint stub, etc).\n@@ -156,1 +166,6 @@\n-  return frame(fr->link(), fr->link(), fr->sender_pc());\n+  address pc = fr->sender_pc();\n+  CodeBlob* cb = CodeCache::find_blob(pc);\n+  bool use_codeblob = cb != nullptr && cb->frame_size() > 0;\n+  assert(!use_codeblob || !Interpreter::contains(pc), \"should not be an interpreter frame\");\n+  intptr_t* sender_sp = use_codeblob ? (fr->link() + frame::metadata_words - cb->frame_size()) : fr->link();\n+  return frame(sender_sp, sender_sp, fr->link(), pc, cb, true \/* allow_cb_null *\/);\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -429,1 +429,1 @@\n-    if (fr.is_java_frame() || fr.is_native_frame() || fr.is_runtime_frame()) {\n+    if (fr.is_interpreted_frame() || (fr.cb() != nullptr && fr.cb()->frame_size() > 0)) {\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.Utils;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\/*\n+ * @test StackWalkNativeToJava\n+ * @bug 8316309\n+ * @summary Check that walking the stack works fine when going from C++ frame to Java frame.\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @requires os.family != \"windows\"\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @run driver StackWalkNativeToJava\n+ *\/\n+\n+public class StackWalkNativeToJava {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Check stack walking works fine when sender of C++ frame\n+        \/\/ is a Java native method.\n+        testStackWalkNativeToJavaNative(\"-Xint\");\n+        testStackWalkNativeToJavaNative(\"-Xcomp\", \"-XX:CompileCommand=dontinline,StackWalkNativeToJava$TestNativeToJavaNative::*\");\n+\n+        \/\/ Check stack walking works fine when sender of C++ frame\n+        \/\/ is a runtime stub or interpreted Java method (VM call from Java).\n+        testStackWalkNativeToJava(\"-Xint\");\n+        testStackWalkNativeToJava(\"-Xcomp\", \"-XX:TieredStopAtLevel=3\",\n+                                  \"-XX:CompileCommand=dontinline,StackWalkNativeToJava$TestNativeToJava::*\");\n+    }\n+\n+    public static void testStackWalkNativeToJavaNative(String... extraFlags) throws Exception {\n+        List<String> commands = new ArrayList<>();\n+        commands.add(\"-Xbootclasspath\/a:.\");\n+        commands.add(\"-XX:-CreateCoredumpOnCrash\");\n+        commands.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        commands.add(\"-XX:AbortVMOnException=java.lang.IllegalMonitorStateException\");\n+        commands.add(\"-XX:+ErrorFileToStdout\");\n+        commands.addAll(Arrays.asList(extraFlags));\n+        commands.add(\"StackWalkNativeToJava$TestNativeToJavaNative\");\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(commands);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotContain(\"java.lang.RuntimeException: Reached statement after obj.wait()\");\n+        output.shouldNotContain(\"[error occurred during error reporting (printing native stack\");\n+        String[] res = output.getOutput().split(\"StackWalkNativeToJava\\\\$TestNativeToJavaNative\\\\.callNativeMethod\\\\(\\\\)V\");\n+        assertTrue(res.length - 1 == 2, res.length - 1);\n+        output.shouldNotHaveExitValue(0);\n+    }\n+\n+    public static class TestNativeToJavaNative {\n+        public static void main(String[] args) throws Exception {\n+            TestNativeToJavaNative test = new TestNativeToJavaNative();\n+            test.callNativeMethod();\n+        }\n+\n+        public void callNativeMethod() throws Exception {\n+            Object obj = new Object();\n+            \/\/ Trigger a fatal exit due to IllegalMonitorStateException during\n+            \/\/ a call to the VM from a Java native method.\n+            obj.wait();\n+            throw new RuntimeException(\"Reached statement after obj.wait()\");\n+        }\n+    }\n+\n+    public static void testStackWalkNativeToJava(String... extraFlags) throws Exception {\n+        List<String> commands = new ArrayList<>();\n+        commands.add(\"-Xbootclasspath\/a:.\");\n+        commands.add(\"-XX:-CreateCoredumpOnCrash\");\n+        commands.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        commands.add(\"-XX:DiagnoseSyncOnValueBasedClasses=1\");\n+        commands.add(\"-XX:+ErrorFileToStdout\");\n+        commands.addAll(Arrays.asList(extraFlags));\n+        commands.add(\"StackWalkNativeToJava$TestNativeToJava\");\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(commands);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldNotContain(\"java.lang.RuntimeException: Reached statement after synchronized\");\n+        output.shouldNotContain(\"[error occurred during error reporting (printing native stack\");\n+        String[] res = output.getOutput().split(\"StackWalkNativeToJava\\\\$TestNativeToJava\\\\.callVMMethod\\\\(\\\\)V\");\n+        assertTrue(res.length - 1 == 2, res.length - 1);\n+        output.shouldNotHaveExitValue(0);\n+    }\n+\n+    public static class TestNativeToJava {\n+        static Integer counter = 0;\n+\n+        public static void main(String[] args) throws Exception {\n+            TestNativeToJava test = new TestNativeToJava();\n+            test.callVMMethod();\n+        }\n+\n+        public void callVMMethod() throws Exception {\n+            \/\/ Trigger a fatal exit for trying to synchronize on a value based class\n+            \/\/ during a call to the VM from a Java method.\n+            synchronized (counter) {\n+                counter++;\n+            }\n+            throw new RuntimeException(\"Reached statement after synchronized\");\n+        }\n+    }\n+\n+    private static void assertTrue(boolean condition, int count) {\n+        if (!condition) {\n+            throw new RuntimeException(\"Count error: count was \" + count);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/StackWalkNativeToJava.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"}]}