{"files":[{"patch":"@@ -67,3 +67,0 @@\n-#ifdef ASSERT\n-    _resource_allocate_bit_mask = false;\n-#endif\n@@ -178,3 +175,7 @@\n-#ifdef ASSERT\n-  _resource_allocate_bit_mask = true;\n-#endif\n+}\n+\n+InterpreterOopMap::~InterpreterOopMap() {\n+  if (has_valid_mask() && mask_size() > small_mask_limit) {\n+    assert(_bit_mask[0] != 0, \"should have pointer to C heap\");\n+    FREE_C_HEAP_ARRAY(uintptr_t, _bit_mask[0]);\n+  }\n@@ -400,3 +401,5 @@\n-void InterpreterOopMap::resource_copy(OopMapCacheEntry* from) {\n-  assert(_resource_allocate_bit_mask,\n-    \"Should not resource allocate the _bit_mask\");\n+void InterpreterOopMap::copy_from(const OopMapCacheEntry* src) {\n+  \/\/ The expectation is that this InterpreterOopMap is recently created\n+  \/\/ and empty. It is used to get a copy of a cached entry.\n+  assert(!has_valid_mask(), \"InterpreterOopMap object can only be filled once\");\n+  assert(src->has_valid_mask(), \"Cannot copy entry with an invalid mask\");\n@@ -404,5 +407,5 @@\n-  set_method(from->method());\n-  set_bci(from->bci());\n-  set_mask_size(from->mask_size());\n-  set_expression_stack_size(from->expression_stack_size());\n-  _num_oops = from->num_oops();\n+  set_method(src->method());\n+  set_bci(src->bci());\n+  set_mask_size(src->mask_size());\n+  set_expression_stack_size(src->expression_stack_size());\n+  _num_oops = src->num_oops();\n@@ -411,3 +414,2 @@\n-  if (from->mask_size() <= small_mask_limit) {\n-    memcpy((void *)_bit_mask, (void *)from->_bit_mask,\n-      mask_word_size() * BytesPerWord);\n+  if (src->mask_size() <= small_mask_limit) {\n+    memcpy(_bit_mask, src->_bit_mask, mask_word_size() * BytesPerWord);\n@@ -415,14 +417,2 @@\n-    \/\/ The expectation is that this InterpreterOopMap is a recently created\n-    \/\/ and empty. It is used to get a copy of a cached entry.\n-    \/\/ If the bit mask has a value, it should be in the\n-    \/\/ resource area.\n-    assert(_bit_mask[0] == 0 ||\n-      Thread::current()->resource_area()->contains((void*)_bit_mask[0]),\n-      \"The bit mask should have been allocated from a resource area\");\n-    \/\/ Allocate the bit_mask from a Resource area for performance.  Allocating\n-    \/\/ from the C heap as is done for OopMapCache has a significant\n-    \/\/ performance impact.\n-    _bit_mask[0] = (uintptr_t) NEW_RESOURCE_ARRAY(uintptr_t, mask_word_size());\n-    assert(_bit_mask[0] != 0, \"bit mask was not allocated\");\n-    memcpy((void*) _bit_mask[0], (void*) from->_bit_mask[0],\n-      mask_word_size() * BytesPerWord);\n+    _bit_mask[0] = (uintptr_t) NEW_C_HEAP_ARRAY(uintptr_t, mask_word_size(), mtClass);\n+    memcpy((void*) _bit_mask[0], (void*) src->_bit_mask[0], mask_word_size() * BytesPerWord);\n@@ -511,1 +501,1 @@\n-        entry_for->resource_copy(entry);\n+        entry_for->copy_from(entry);\n@@ -525,1 +515,1 @@\n-  entry_for->resource_copy(tmp);\n+  entry_for->copy_from(tmp);\n@@ -625,1 +615,3 @@\n-  entry->resource_copy(tmp);\n+  if (tmp->has_valid_mask()) {\n+    entry->copy_from(tmp);\n+  }\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":26,"deletions":34,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-\/\/ bit_mask can fit into two words it is stored in\n+\/\/ bit_mask can fit into four words it is stored in\n@@ -42,3 +42,4 @@\n-\/\/ For InterpreterOopMap the bit_mask is allocated in\n-\/\/ a resource area for better performance.  InterpreterOopMap\n-\/\/ should only be created and deleted during same garbage collection.\n+\/\/ For InterpreterOopMap the bit_mask is allocated in the C heap\n+\/\/ to avoid issues with allocations from the resource area that have\n+\/\/ to live accross the oop closure. InterpreterOopMap should only be\n+\/\/ created and deleted during the same garbage collection.\n@@ -85,1 +86,1 @@\n-  int            _mask_size;      \/\/ the mask size in bits\n+  int            _mask_size;      \/\/ the mask size in bits (USHRT_MAX if invalid)\n@@ -129,0 +130,1 @@\n+  ~InterpreterOopMap();\n@@ -130,5 +132,5 @@\n-  \/\/ Copy the OopMapCacheEntry in parameter \"from\" into this\n-  \/\/ InterpreterOopMap.  If the _bit_mask[0] in \"from\" points to\n-  \/\/ allocated space (i.e., the bit mask was to large to hold\n-  \/\/ in-line), allocate the space from a Resource area.\n-  void resource_copy(OopMapCacheEntry* from);\n+  \/\/ Copy the OopMapCacheEntry in parameter \"src\" into this\n+  \/\/ InterpreterOopMap.  If the _bit_mask[0] in \"src\" points to\n+  \/\/ allocated space (i.e., the bit mask was too large to hold\n+  \/\/ in-line), allocate the space from the C heap.\n+  void copy_from(const OopMapCacheEntry* src);\n@@ -146,0 +148,2 @@\n+  \/\/ Determines if a valid mask has been computed\n+  bool has_valid_mask() const { return _mask_size != USHRT_MAX; }\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.hpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -955,1 +955,0 @@\n-  ResourceMark rm(thread);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}