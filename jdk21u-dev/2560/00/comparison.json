{"files":[{"patch":"@@ -37,1 +37,2 @@\n-import java.util.Optional;\n+\n+import java.util.regex.Pattern;\n@@ -53,3 +54,0 @@\n-    private static final Path NS_MNT   = Path.of(\"ns\/mnt\");\n-    private static final Path NS_PID   = Path.of(\"ns\/pid\");\n-    private static final Path SELF     = PROC.resolve(\"self\");\n@@ -59,14 +57,0 @@\n-    private static final Optional<Path> SELF_MNT_NS;\n-\n-    static {\n-        Path nsPath = null;\n-\n-        try {\n-            nsPath = Files.readSymbolicLink(SELF.resolve(NS_MNT));\n-        } catch (IOException e) {\n-            \/\/ do nothing\n-        } finally {\n-            SELF_MNT_NS = Optional.ofNullable(nsPath);\n-        }\n-    }\n-\n@@ -99,0 +83,3 @@\n+\n+            boolean timedout = false;\n+\n@@ -100,1 +87,1 @@\n-                sendQuitTo(pid);\n+                checkCatchesAndSendQuitTo(pid, false);\n@@ -105,1 +92,1 @@\n-                long time_spend = 0;\n+                long time_spent = 0;\n@@ -114,2 +101,3 @@\n-                    time_spend += delay;\n-                    if (time_spend > timeout\/2 && !socket_file.exists()) {\n+                    timedout = (time_spent += delay) > timeout;\n+\n+                    if (time_spent > timeout\/2 && !socket_file.exists()) {\n@@ -117,1 +105,1 @@\n-                        sendQuitTo(pid);\n+                        checkCatchesAndSendQuitTo(pid, !timedout);\n@@ -119,1 +107,2 @@\n-                } while (time_spend <= timeout && !socket_file.exists());\n+                } while (!timedout && !socket_file.exists());\n+\n@@ -124,2 +113,1 @@\n-                          \"or HotSpot VM not loaded\", socket_path, pid,\n-                                      time_spend));\n+                          \"or HotSpot VM not loaded\", socket_path, pid, time_spent));\n@@ -259,73 +247,26 @@\n-        \/\/ We need to handle at least 4 different cases:\n-        \/\/ 1. Caller and target processes share PID namespace and root filesystem (host to host or container to\n-        \/\/    container with both \/tmp mounted between containers).\n-        \/\/ 2. Caller and target processes share PID namespace and root filesystem but the target process has elevated\n-        \/\/    privileges (host to host).\n-        \/\/ 3. Caller and target processes share PID namespace but NOT root filesystem (container to container).\n-        \/\/ 4. Caller and target processes share neither PID namespace nor root filesystem (host to container).\n-\n-        Optional<ProcessHandle> target = ProcessHandle.of(pid);\n-        Optional<ProcessHandle> ph = target;\n-        long nsPid = ns_pid;\n-        Optional<Path> prevPidNS = Optional.empty();\n-\n-        while (ph.isPresent()) {\n-            final var curPid = ph.get().pid();\n-            final var procPidPath = PROC.resolve(Long.toString(curPid));\n-            Optional<Path> targetMountNS = Optional.empty();\n-\n-            try {\n-                \/\/ attempt to read the target's mnt ns id\n-                targetMountNS = Optional.ofNullable(Files.readSymbolicLink(procPidPath.resolve(NS_MNT)));\n-            } catch (IOException e) {\n-                \/\/ if we fail to read the target's mnt ns id then we either don't have access or it no longer exists!\n-                if (!Files.exists(procPidPath)) {\n-                    throw new IOException(String.format(\"unable to attach, %s non-existent! process: %d terminated\", procPidPath, pid));\n-                }\n-                \/\/ the process still exists, but we don't have privileges to read its procfs\n-            }\n-\n-            final var sameMountNS = SELF_MNT_NS.isPresent() && SELF_MNT_NS.equals(targetMountNS);\n-\n-            if (sameMountNS) {\n-                return TMPDIR.toString(); \/\/ we share TMPDIR in common!\n-            } else {\n-                \/\/ we could not read the target's mnt ns\n-                final var procPidRootTmp = procPidPath.resolve(ROOT_TMP);\n-                if (Files.isReadable(procPidRootTmp)) {\n-                    return procPidRootTmp.toString(); \/\/ not in the same mnt ns but tmp is accessible via \/proc\n-                }\n-            }\n-\n-            \/\/ let's attempt to obtain the pid ns, best efforts to avoid crossing pid ns boundaries (as with a container)\n-            Optional<Path> curPidNS = Optional.empty();\n-\n-            try {\n-                \/\/ attempt to read the target's pid ns id\n-                curPidNS = Optional.ofNullable(Files.readSymbolicLink(procPidPath.resolve(NS_PID)));\n-            } catch (IOException e) {\n-                \/\/ if we fail to read the target's pid ns id then we either don't have access or it no longer exists!\n-                if (!Files.exists(procPidPath)) {\n-                    throw new IOException(String.format(\"unable to attach, %s non-existent! process: %d terminated\", procPidPath, pid));\n-                }\n-                \/\/ the process still exists, but we don't have privileges to read its procfs\n-            }\n-\n-            \/\/ recurse \"up\" the process hierarchy if appropriate. PID 1 cannot have a parent in the same namespace\n-            final var havePidNSes = prevPidNS.isPresent() && curPidNS.isPresent();\n-            final var ppid = ph.get().parent();\n-\n-            if (ppid.isPresent() && (havePidNSes && curPidNS.equals(prevPidNS)) || (!havePidNSes && nsPid > 1)) {\n-                ph = ppid;\n-                nsPid = getNamespacePid(ph.get().pid()); \/\/ get the ns pid of the parent\n-                prevPidNS = curPidNS;\n-            } else {\n-                ph = Optional.empty();\n-            }\n-        }\n-\n-        if (target.orElseThrow(AttachNotSupportedException::new).isAlive()) {\n-            return TMPDIR.toString(); \/\/ fallback...\n-        } else {\n-            throw new IOException(String.format(\"unable to attach, process: %d terminated\", pid));\n-        }\n+        final var procPidRoot = PROC.resolve(Long.toString(pid)).resolve(ROOT_TMP);\n+\n+        \/* We need to handle at least 4 different cases:\n+         * 1. Caller and target processes share PID namespace and root filesystem (host to host or container to\n+         *    container with both \/tmp mounted between containers).\n+         * 2. Caller and target processes share PID namespace and root filesystem but the target process has elevated\n+         *    privileges (host to host).\n+         * 3. Caller and target processes share PID namespace but NOT root filesystem (container to container).\n+         * 4. Caller and target processes share neither PID namespace nor root filesystem (host to container)\n+         *\n+         * if target is elevated, we cant use \/proc\/<pid>\/... so we have to fallback to \/tmp, but that may not be shared\n+         * with the target\/attachee process, we can try, except in the case where the ns_pid also exists in this pid ns\n+         * which is ambiguous, if we share \/tmp with the intended target, the attach will succeed, if we do not,\n+         * then we will potentially attempt to attach to some arbitrary process with the same pid (in this pid ns)\n+         * as that of the intended target (in its * pid ns).\n+         *\n+         * so in that case we should prehaps throw - or risk sending SIGQUIT to some arbitrary process... which could kill it\n+         *\n+         * however we can also check the target pid's signal masks to see if it catches SIGQUIT and only do so if in\n+         * fact it does ... this reduces the risk of killing an innocent process in the current ns as opposed to\n+         * attaching to the actual target JVM ... c.f: checkCatchesAndSendQuitTo() below.\n+         *\n+         * note that if pid == ns_pid we are in a shared pid ns with the target and may (potentially) share \/tmp\n+         *\/\n+\n+        return (Files.isWritable(procPidRoot) ? procPidRoot : TMPDIR).toString();\n@@ -380,0 +321,64 @@\n+    private static final String FIELD = \"field\";\n+    private static final String MASK  = \"mask\";\n+\n+    private static final Pattern SIGNAL_MASK_PATTERN = Pattern.compile(\"(?<\" + FIELD + \">Sig\\\\p{Alpha}{3}):\\\\s+(?<\" + MASK + \">\\\\p{XDigit}{16}).*\");\n+\n+    private static final long SIGQUIT = 0b100; \/\/ mask bit for SIGQUIT\n+\n+    private static boolean checkCatchesAndSendQuitTo(int pid, boolean throwIfNotReady) throws AttachNotSupportedException, IOException {\n+        var quitIgn = false;\n+        var quitBlk = false;\n+        var quitCgt = false;\n+\n+        final var procPid = PROC.resolve(Integer.toString(pid));\n+\n+        var readBlk = false;\n+        var readIgn = false;\n+        var readCgt = false;\n+\n+\n+        if (!Files.exists(procPid)) throw new IOException(\"non existent JVM pid: \" + pid);\n+\n+        for (var line : Files.readAllLines(procPid.resolve(\"status\"))) {\n+\n+            if (!line.startsWith(\"Sig\")) continue; \/\/ to speed things up ... avoids the matcher\/RE invocation...\n+\n+            final var m = SIGNAL_MASK_PATTERN.matcher(line);\n+\n+            if (!m.matches()) continue;\n+\n+            var       sigmask = m.group(MASK);\n+            final var slen    = sigmask.length();\n+\n+            sigmask = sigmask.substring(slen \/ 2 , slen); \/\/ only really interested in the non r\/t signals ...\n+\n+            final var sigquit = (Long.valueOf(sigmask, 16) & SIGQUIT) != 0L;\n+\n+            switch (m.group(FIELD)) {\n+                case \"SigBlk\": { quitBlk = sigquit; readBlk = true; break; }\n+                case \"SigIgn\": { quitIgn = sigquit; readIgn = true; break; }\n+                case \"SigCgt\": { quitCgt = sigquit; readCgt = true; break; }\n+            }\n+\n+            if (readBlk && readIgn && readCgt) break;\n+        }\n+\n+        final boolean  okToSendQuit = (!quitIgn && quitCgt); \/\/ ignore blocked as it may be temporary ...\n+\n+        if (okToSendQuit) {\n+            sendQuitTo(pid);\n+        } else if (throwIfNotReady) {\n+            final var cmdline = Files.lines(procPid.resolve(\"cmdline\")).findFirst();\n+\n+            var cmd = \"null\"; \/\/ default\n+\n+            if (cmdline.isPresent()) {\n+                cmd = cmdline.get();\n+                cmd = cmd.substring(0, cmd.length() - 1); \/\/ remove trailing \\0\n+            }\n+\n+            throw new AttachNotSupportedException(\"pid: \" + pid + \" cmd: '\" + cmd + \"' state is not ready to participate in attach handshake!\");\n+        }\n+\n+        return okToSendQuit;\n+    }\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":104,"deletions":99,"binary":false,"changes":203,"status":"modified"}]}