{"files":[{"patch":"@@ -783,1 +783,1 @@\n-                    cf.complete(finisher.apply(subscriber));\n+                    cf.completeAsync(() -> finisher.apply(subscriber));\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ResponseSubscribers.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.StackWalker.StackFrame;\n@@ -35,0 +36,3 @@\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n@@ -37,0 +41,1 @@\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -38,0 +43,1 @@\n+import java.util.function.Predicate;\n@@ -60,0 +66,1 @@\n+ * @bug 8193365 8317295\n@@ -79,0 +86,3 @@\n+    static final StackWalker WALKER =\n+            StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n+\n@@ -267,2 +277,2 @@\n-    void testCollectionWithoutFinisheBlocking(String uri) throws Exception {\n-        System.out.printf(now() + \"testCollectionWithoutFinisheBlocking(%s) starting%n\", uri);\n+    void testCollectionWithoutFinisherBlocking(String uri) throws Exception {\n+        System.out.printf(now() + \"testCollectionWithoutFinisherBlocking(%s) starting%n\", uri);\n@@ -458,9 +468,37 @@\n-            client.sendAsync(request, BodyHandlers.fromSubscriber(BodySubscribers.ofInputStream(),\n-                            ins -> {\n-                                InputStream is = ins.getBody().toCompletableFuture().join();\n-                                return new String(uncheckedReadAllBytes(is), UTF_8);\n-                            }))\n-                    .thenApply(FlowAdapterSubscriberTest::assert200ResponseCode)\n-                    .thenApply(HttpResponse::body)\n-                    .thenAccept(body -> assertEquals(body, \"May the wind always be at your back.\"))\n-                    .join();\n+            var adaptee = BodySubscribers.ofInputStream();\n+            var exec = Executors.newSingleThreadExecutor();\n+\n+            \/\/ Use an executor to pull on the InputStream in order to reach the\n+            \/\/ point where the Subscriber gets completed and the finisher function\n+            \/\/ is called. If we didn't use an executor here, the finisher function\n+            \/\/ may never get called.\n+            var futureResult = exec.submit(() -> uncheckedReadAllBytes(\n+                    adaptee.getBody().toCompletableFuture().join()));\n+            Supplier<byte[]> bytes = () -> {\n+                try {\n+                    return futureResult.get();\n+                } catch (InterruptedException e) {\n+                    throw new CompletionException(e);\n+                } catch (ExecutionException e) {\n+                    throw new CompletionException(e.getCause());\n+                }\n+            };\n+\n+            AtomicReference<AssertionError> failed = new AtomicReference<>();\n+            Function<? super Flow.Subscriber<List<ByteBuffer>>, String> finisher = (s) -> {\n+                failed.set(checkThreadAndStack());\n+                return new String(bytes.get(), UTF_8);\n+            };\n+\n+            try {\n+                var cf = client.sendAsync(request, BodyHandlers.fromSubscriber(adaptee,\n+                                finisher))\n+                        .thenApply(FlowAdapterSubscriberTest::assert200ResponseCode)\n+                        .thenApply(HttpResponse::body)\n+                        .thenAccept(body -> assertEquals(body, \"May the wind always be at your back.\"))\n+                        .join();\n+                var error = failed.get();\n+                if (error != null) throw error;\n+            } finally {\n+                exec.close();\n+            }\n@@ -470,0 +508,23 @@\n+    static final Predicate<StackFrame> DAT = sfe ->\n+            sfe.getClassName().startsWith(\"FlowAdapterSubscriberTest\");\n+    static final Predicate<StackFrame> JUC = sfe ->\n+            sfe.getClassName().startsWith(\"java.util.concurrent\");\n+    static final Predicate<StackFrame> JLT = sfe ->\n+            sfe.getClassName().startsWith(\"java.lang.Thread\");\n+    static final Predicate<StackFrame> RSP = sfe ->\n+            sfe.getClassName().startsWith(\"jdk.internal.net.http.ResponseSubscribers\");\n+    static final Predicate<StackFrame> NotDATorJUCorJLT = Predicate.not(DAT.or(JUC).or(JLT).or(RSP));\n+\n+\n+    AssertionError checkThreadAndStack() {\n+        System.out.println(\"Check stack trace\");\n+        List<StackFrame> otherFrames = WALKER.walk(s -> s.filter(NotDATorJUCorJLT).toList());\n+        if (!otherFrames.isEmpty()) {\n+            System.out.println(\"Found unexpected trace: \");\n+            otherFrames.forEach(f -> System.out.printf(\"\\t%s%n\", f));\n+            return new AssertionError(\"Dependant action has unexpected frame in \" +\n+                    Thread.currentThread() + \": \" + otherFrames.get(0));\n+        }\n+        return null;\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/FlowAdapterSubscriberTest.java","additions":72,"deletions":11,"binary":false,"changes":83,"status":"modified"}]}