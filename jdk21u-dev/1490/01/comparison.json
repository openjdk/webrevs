{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/gtest\/compiler\/test_directivesParser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-  MemRegion heap(NULL, num_regions_in_test * HeapRegion::GrainWords);\n+  MemRegion heap(nullptr, num_regions_in_test * HeapRegion::GrainWords);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_freeRegionList.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-    if (_workers == NULL) {\n+    if (_workers == nullptr) {\n@@ -90,1 +90,1 @@\n-WorkerThreads* G1CardSetTest::_workers = NULL;\n+WorkerThreads* G1CardSetTest::_workers = nullptr;\n@@ -100,1 +100,1 @@\n-    if (results != NULL) {\n+    if (results != nullptr) {\n@@ -272,1 +272,1 @@\n-    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), NULL);\n+    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), nullptr);\n@@ -294,1 +294,1 @@\n-    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), NULL);\n+    add_cards(&card_set, CardsPerRegion, cards1, ARRAY_SIZE(cards1), nullptr);\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSet.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-    if (_workers == NULL) {\n+    if (_workers == nullptr) {\n@@ -51,1 +51,1 @@\n-WorkerThreads* G1MapperWorkers::_workers = NULL;\n+WorkerThreads* G1MapperWorkers::_workers = nullptr;\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_stressCommitUncommit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-    ASSERT_EQ((BufferNode*)NULL, nodes[i]->next());\n+    ASSERT_EQ(nullptr, nodes[i]->next());\n@@ -105,1 +105,1 @@\n-    assert(node != NULL, \"precondition\");\n+    assert(node != nullptr, \"precondition\");\n@@ -172,1 +172,1 @@\n-      if (node != NULL) {\n+      if (node != nullptr) {\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_bufferNodeAllocator.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-  \/\/ Test that NULL is not in the heap.\n-  ASSERT_FALSE(heap->is_in(NULL)) << \"NULL is unexpectedly in the heap\";\n+  \/\/ Test that nullptr is not in the heap.\n+  ASSERT_FALSE(heap->is_in(nullptr)) << \"null is unexpectedly in the heap\";\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_collectedHeap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-      if (setter2 != NULL) {\n+      if (setter2 != nullptr) {\n@@ -83,1 +83,1 @@\n-      test(setter, NULL, checker);\n+      test(setter, nullptr, checker);\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_collectorPolicy.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,2 +107,2 @@\n-\/\/ Using EXPECT_EQ can't use NULL directly. Otherwise AIX build breaks.\n-const OopBlock* const NULL_BLOCK = NULL;\n+\/\/ Using EXPECT_EQ can't use nullptr directly. Otherwise AIX build breaks.\n+const OopBlock* const NULL_BLOCK = nullptr;\n@@ -113,1 +113,1 @@\n-       block != NULL;\n+       block != nullptr;\n@@ -122,1 +122,1 @@\n-  for (OopBlock* block = list.head(); block != NULL; block = next) {\n+  for (OopBlock* block = list.head(); block != nullptr; block = next) {\n@@ -129,1 +129,1 @@\n-  return list.chead() == NULL;\n+  return list.chead() == nullptr;\n@@ -142,1 +142,1 @@\n-  *entry = NULL;\n+  *entry = nullptr;\n@@ -153,1 +153,1 @@\n-       (block != NULL) && block->is_empty();\n+       (block != nullptr) && block->is_empty();\n@@ -167,1 +167,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -206,1 +206,1 @@\n-    EXPECT_TRUE(_entries[i] != NULL);\n+    EXPECT_TRUE(_entries[i] != nullptr);\n@@ -218,2 +218,2 @@\n-  for ( ; (block != NULL) && block->is_empty(); block = list.prev(*block)) {}\n-  for ( ; block != NULL; block = list.prev(*block)) {\n+  for ( ; (block != nullptr) && block->is_empty(); block = list.prev(*block)) {}\n+  for ( ; block != nullptr; block = list.prev(*block)) {\n@@ -242,1 +242,1 @@\n-  EXPECT_TRUE(ptr != NULL);\n+  EXPECT_TRUE(ptr != nullptr);\n@@ -252,1 +252,1 @@\n-  EXPECT_NE(block, (OopBlock*)NULL);\n+  EXPECT_NE(block, (OopBlock*)nullptr);\n@@ -329,1 +329,1 @@\n-  ASSERT_TRUE(entries[0] != NULL);\n+  ASSERT_TRUE(entries[0] != nullptr);\n@@ -342,1 +342,1 @@\n-    ASSERT_TRUE(entries[i] != NULL);\n+    ASSERT_TRUE(entries[i] != nullptr);\n@@ -345,1 +345,1 @@\n-    if (block == NULL) {\n+    if (block == nullptr) {\n@@ -353,1 +353,1 @@\n-      block = NULL;\n+      block = nullptr;\n@@ -361,1 +361,1 @@\n-  if (block != NULL) {\n+  if (block != nullptr) {\n@@ -378,1 +378,1 @@\n-       block != NULL;\n+       block != nullptr;\n@@ -398,1 +398,1 @@\n-    if (_entries[i] != NULL) {\n+    if (_entries[i] != nullptr) {\n@@ -400,1 +400,1 @@\n-      _entries[i] = NULL;\n+      _entries[i] = nullptr;\n@@ -430,1 +430,1 @@\n-    if (_entries[i] != NULL) {\n+    if (_entries[i] != nullptr) {\n@@ -432,1 +432,1 @@\n-      _entries[i] = NULL;\n+      _entries[i] = nullptr;\n@@ -461,1 +461,1 @@\n-      *to_release[i] = NULL;\n+      *to_release[i] = nullptr;\n@@ -512,1 +512,1 @@\n-    EXPECT_EQ(NULL, entries[i]);\n+    EXPECT_EQ(nullptr, entries[i]);\n@@ -549,1 +549,1 @@\n-    if (*ptr != NULL) {\n+    if (*ptr != nullptr) {\n@@ -556,1 +556,1 @@\n-    if (*ptr != NULL) {\n+    if (*ptr != nullptr) {\n@@ -598,1 +598,1 @@\n-      ASSERT_TRUE(entries[allocated] != NULL);\n+      ASSERT_TRUE(entries[allocated] != nullptr);\n@@ -875,1 +875,1 @@\n-WorkerThreads* OopStorageTestParIteration::_workers = NULL;\n+WorkerThreads* OopStorageTestParIteration::_workers = nullptr;\n@@ -878,1 +878,1 @@\n-  if (_workers == NULL) {\n+  if (_workers == nullptr) {\n@@ -1077,1 +1077,1 @@\n-      ASSERT_TRUE(entries[allocated] != NULL);\n+      ASSERT_TRUE(entries[allocated] != nullptr);\n@@ -1095,1 +1095,1 @@\n-    _entries[i] = NULL;\n+    _entries[i] = nullptr;\n@@ -1101,1 +1101,1 @@\n-    _entries[i] = NULL;\n+    _entries[i] = nullptr;\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_oopStorage.cpp","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-WorkerThreads* OopStorageParIterPerf::_workers = NULL;\n+WorkerThreads* OopStorageParIterPerf::_workers = nullptr;\n@@ -80,1 +80,1 @@\n-  if (_workers == NULL) {\n+  if (_workers == nullptr) {\n@@ -129,1 +129,1 @@\n-    _worker_times(NULL),\n+    _worker_times(nullptr),\n@@ -155,1 +155,1 @@\n-  virtual void do_oop(oop* p) { guarantee(*p == NULL, \"expected NULL\"); }\n+  virtual void do_oop(oop* p) { guarantee(*p == nullptr, \"expected null\"); }\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_oopStorage_parperf.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-    array(NULL, title, 3),\n+    array(nullptr, title, 3),\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_workerDataArray.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,1 @@\n-  check_is_weak_good_or_null((uintptr_t)NULL);\n+  check_is_weak_good_or_null((uintptr_t)nullptr);\n","filename":"test\/hotspot\/gtest\/gc\/x\/test_xAddress.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,1 @@\n-    if (_jvm != NULL) {\n+    if (_jvm != nullptr) {\n@@ -154,1 +154,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -247,1 +247,1 @@\n-  if (java_home == NULL) {\n+  if (java_home == nullptr) {\n@@ -273,1 +273,1 @@\n-  JVMInitializerListener* jvm_listener = NULL;\n+  JVMInitializerListener* jvm_listener = nullptr;\n@@ -276,1 +276,1 @@\n-    JavaVM* jvm = NULL;\n+    JavaVM* jvm = nullptr;\n@@ -303,1 +303,1 @@\n-  if (jvm_listener != NULL) {\n+  if (jvm_listener != nullptr) {\n@@ -326,2 +326,2 @@\n-  hdl = CreateThread(NULL, STACK_SIZE, thread_wrapper, (void*)args, 0, NULL);\n-  if (hdl == NULL) {\n+  hdl = CreateThread(nullptr, STACK_SIZE, thread_wrapper, (void*)args, 0, nullptr);\n+  if (hdl == nullptr) {\n@@ -354,1 +354,1 @@\n-  if (pthread_join(tid, NULL) != 0) {\n+  if (pthread_join(tid, nullptr) != 0) {\n","filename":"test\/hotspot\/gtest\/gtestMain.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -203,1 +203,1 @@\n-  assert(description != NULL, \"invariant\");\n+  assert(description != nullptr, \"invariant\");\n","filename":"test\/hotspot\/gtest\/jfr\/test_adaptiveSampler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,1 @@\n-      *network_interfaces = NULL;\n+      *network_interfaces = nullptr;\n","filename":"test\/hotspot\/gtest\/jfr\/test_networkUtilization.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-    MockJavaThread* next() { return NULL; }\n+    MockJavaThread* next() { return nullptr; }\n@@ -92,1 +92,1 @@\n-    MockJavaThread* next() { return NULL; }\n+    MockJavaThread* next() { return nullptr; }\n","filename":"test\/hotspot\/gtest\/jfr\/test_threadCpuLoad.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-LogTestFixture::LogTestFixture() : _n_snapshots(0), _configuration_snapshot(NULL) {\n+LogTestFixture::LogTestFixture() : _n_snapshots(0), _configuration_snapshot(nullptr) {\n@@ -101,1 +101,1 @@\n-    if (str != NULL) {\n+    if (str != nullptr) {\n@@ -108,1 +108,1 @@\n-    set_log_config(name, selection, decorators, \/* options = *\/ NULL);\n+    set_log_config(name, selection, decorators, \/* options = *\/ nullptr);\n@@ -113,1 +113,1 @@\n-  if (_configuration_snapshot == NULL) {\n+  if (_configuration_snapshot == nullptr) {\n@@ -121,1 +121,1 @@\n-  _configuration_snapshot = NULL;\n+  _configuration_snapshot = nullptr;\n","filename":"test\/hotspot\/gtest\/logging\/logTestFixture.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-  return strstr(haystack, needle) != NULL;\n+  return strstr(haystack, needle) != nullptr;\n@@ -63,1 +63,1 @@\n-  failed = !CreateDirectory(name, NULL);\n+  failed = !CreateDirectory(name, nullptr);\n@@ -118,1 +118,1 @@\n-\/\/ Returns NULL on EOF.\n+\/\/ Returns nullptr on EOF.\n@@ -120,1 +120,1 @@\n-  assert(fp != NULL, \"invalid fp\");\n+  assert(fp != nullptr, \"invalid fp\");\n@@ -124,1 +124,1 @@\n-  if (pos < 0) return NULL;\n+  if (pos < 0) return nullptr;\n@@ -127,1 +127,1 @@\n-  while (ret != NULL && buf[strlen(buf) - 1] != '\\n' && !feof(fp)) {\n+  while (ret != nullptr && buf[strlen(buf) - 1] != '\\n' && !feof(fp)) {\n@@ -142,1 +142,1 @@\n-  assert(fp != NULL, \"error opening file %s: %s\", filename, os::strerror(errno));\n+  assert(fp != nullptr, \"error opening file %s: %s\", filename, os::strerror(errno));\n@@ -145,1 +145,1 @@\n-  while (substrs[idx] != NULL) {\n+  while (substrs[idx] != nullptr) {\n@@ -148,1 +148,1 @@\n-    if (line == NULL) {\n+    if (line == nullptr) {\n@@ -151,1 +151,1 @@\n-    for (char* match = strstr(line, substrs[idx]); match != NULL;) {\n+    for (char* match = strstr(line, substrs[idx]); match != nullptr;) {\n@@ -154,1 +154,1 @@\n-      if (substrs[idx] == NULL) {\n+      if (substrs[idx] == nullptr) {\n@@ -162,1 +162,1 @@\n-  return substrs[idx] == NULL;\n+  return substrs[idx] == nullptr;\n@@ -166,1 +166,1 @@\n-  const char* strs[] = {substr, NULL};\n+  const char* strs[] = {substr, nullptr};\n","filename":"test\/hotspot\/gtest\/logging\/logTestUtils.inline.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,1 +94,1 @@\n-    if (f != NULL) {\n+    if (f != nullptr) {\n@@ -149,1 +149,1 @@\n-  strs[MULTI_LINES] = NULL;\n+  strs[MULTI_LINES] = nullptr;\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    GCTraceTime(Debug, gc) timer(\"Test GC\", NULL, GCCause::_allocation_failure, true);\n+    GCTraceTime(Debug, gc) timer(\"Test GC\", nullptr, GCCause::_allocation_failure, true);\n@@ -54,1 +54,1 @@\n-    NULL\n+    nullptr\n@@ -71,1 +71,1 @@\n-    GCTraceTime(Debug, gc, ref) timer(\"Test GC\", NULL, GCCause::_allocation_failure, true);\n+    GCTraceTime(Debug, gc, ref) timer(\"Test GC\", nullptr, GCCause::_allocation_failure, true);\n@@ -77,1 +77,1 @@\n-    NULL\n+    nullptr\n@@ -92,1 +92,1 @@\n-    GCTraceTime(Debug, gc) timer(\"Test GC\", NULL, GCCause::_allocation_failure, false);\n+    GCTraceTime(Debug, gc) timer(\"Test GC\", nullptr, GCCause::_allocation_failure, false);\n@@ -100,1 +100,1 @@\n-    NULL\n+    nullptr\n@@ -123,1 +123,1 @@\n-    GCTraceTime(Debug, gc) timer(\"Test GC\", NULL, GCCause::_no_gc, true);\n+    GCTraceTime(Debug, gc) timer(\"Test GC\", nullptr, GCCause::_no_gc, true);\n@@ -131,1 +131,1 @@\n-    NULL\n+    nullptr\n@@ -146,1 +146,1 @@\n-    GCTraceTime(Debug, gc) timer(\"Test GC\", NULL, GCCause::_no_gc, false);\n+    GCTraceTime(Debug, gc) timer(\"Test GC\", nullptr, GCCause::_no_gc, false);\n@@ -154,1 +154,1 @@\n-    NULL\n+    nullptr\n","filename":"test\/hotspot\/gtest\/logging\/test_gcTraceTime.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-  ASSERT_NE((void*)NULL, fp);\n+  ASSERT_NE(nullptr, fp);\n@@ -94,1 +94,1 @@\n-  \/\/ Log a dummy line so that fgets doesn't return NULL because the file is empty.\n+  \/\/ Log a dummy line so that fgets doesn't return nullptr because the file is empty.\n@@ -125,1 +125,1 @@\n-  \/\/ Log a dummy line so that fgets doesn't return NULL because the file is empty.\n+  \/\/ Log a dummy line so that fgets doesn't return nullptr because the file is empty.\n@@ -156,1 +156,1 @@\n-  \/\/ Log a dummy line so that fgets doesn't return NULL because the file is empty.\n+  \/\/ Log a dummy line so that fgets doesn't return nullptr because the file is empty.\n","filename":"test\/hotspot\/gtest\/logging\/test_log.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,1 +135,1 @@\n-    for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+    for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -143,1 +143,1 @@\n-    for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+    for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -163,1 +163,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -185,1 +185,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -202,1 +202,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -215,1 +215,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -340,1 +340,1 @@\n-    for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+    for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -430,1 +430,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -444,1 +444,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -461,1 +461,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -479,1 +479,1 @@\n-  LogConfiguration::parse_log_arguments(\"stdout\", \"logging=trace\", NULL, NULL, &ls);\n+  LogConfiguration::parse_log_arguments(\"stdout\", \"logging=trace\", nullptr, nullptr, &ls);\n@@ -495,1 +495,1 @@\n-  bool success = LogConfiguration::parse_log_arguments(\"stdout\", invalid_tagset, NULL, NULL, &ss);\n+  bool success = LogConfiguration::parse_log_arguments(\"stdout\", invalid_tagset, nullptr, nullptr, &ss);\n@@ -530,1 +530,1 @@\n-  for (const char* p = strstr(haystack, needle); p != NULL; p = strstr(p + 1, needle)) {\n+  for (const char* p = strstr(haystack, needle); p != nullptr; p = strstr(p + 1, needle)) {\n@@ -542,1 +542,1 @@\n-  bool success = LogConfiguration::parse_log_arguments(\"#1\", \"all=warning\", NULL, NULL, &ss);\n+  bool success = LogConfiguration::parse_log_arguments(\"#1\", \"all=warning\", nullptr, nullptr, &ss);\n@@ -560,1 +560,1 @@\n-  LogConfiguration::parse_log_arguments(\"stdout\", nonexisting_tagset, NULL, NULL, &ss);\n+  LogConfiguration::parse_log_arguments(\"stdout\", nonexisting_tagset, nullptr, nullptr, &ss);\n","filename":"test\/hotspot\/gtest\/logging\/test_logConfiguration.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-    double cur = strtod(d.decoration(LogDecorators::uptime_decorator, buf, sizeof(buf)), NULL);\n+    double cur = strtod(d.decoration(LogDecorators::uptime_decorator, buf, sizeof(buf)), nullptr);\n@@ -126,1 +126,1 @@\n-      julong val = strtoull(d.decoration(decorator, buf, sizeof(buf)), NULL, 10);\n+      julong val = strtoull(d.decoration(decorator, buf, sizeof(buf)), nullptr, 10);\n@@ -142,1 +142,1 @@\n-  time_t expected_ts = time(NULL);\n+  time_t expected_ts = time(nullptr);\n@@ -177,1 +177,1 @@\n-  time_t expected_ts = time(NULL);\n+  time_t expected_ts = time(nullptr);\n@@ -237,1 +237,1 @@\n-    EXPECT_EQ(ids[i].expected, strtol(reported, NULL, 10));\n+    EXPECT_EQ(ids[i].expected, strtol(reported, nullptr, 10));\n","filename":"test\/hotspot\/gtest\/logging\/test_logDecorations.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-  NULL, \/\/ LogLevel::Off\n+  nullptr, \/\/ LogLevel::Off\n@@ -135,1 +135,1 @@\n-                             \"another error\", \"warning line\", \"debug line\", NULL };\n+                             \"another error\", \"warning line\", \"debug line\", nullptr };\n@@ -159,1 +159,1 @@\n-  const char* expected[] = { start_marker, \"0123456789\", end_marker, NULL };\n+  const char* expected[] = { start_marker, \"0123456789\", end_marker, nullptr };\n@@ -181,1 +181,1 @@\n-  expected_lines[lines] = NULL;\n+  expected_lines[lines] = nullptr;\n@@ -204,1 +204,1 @@\n-  msg.set_prefix(NULL);\n+  msg.set_prefix(nullptr);\n@@ -213,1 +213,1 @@\n-    NULL\n+    nullptr\n@@ -241,1 +241,1 @@\n-  const char* tmp[] = {\"manual flush info\", \"manual flush info\", NULL};\n+  const char* tmp[] = {\"manual flush info\", \"manual flush info\", nullptr};\n","filename":"test\/hotspot\/gtest\/logging\/test_logMessageTest.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -96,1 +96,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n","filename":"test\/hotspot\/gtest\/logging\/test_logSelectionList.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,1 @@\n-  const char* message_order[] = {\"1\", \"I am one line\", \"2\", \"but\", \"3\", \"I am not\", NULL};\n+  const char* message_order[] = {\"1\", \"I am one line\", \"2\", \"but\", \"3\", \"I am not\", nullptr};\n@@ -119,1 +119,1 @@\n-  const char* message_order[] = {\"1\", \"2\" , \"3\", \"I am one line\", \"but\", \"I am not\", NULL};\n+  const char* message_order[] = {\"1\", \"2\" , \"3\", \"I am one line\", \"but\", \"I am not\", nullptr};\n","filename":"test\/hotspot\/gtest\/logging\/test_logStream.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-  char* last_tag = NULL;\n+  char* last_tag = nullptr;\n@@ -78,1 +78,1 @@\n-    ASSERT_TRUE(end != NULL) <<  \"line should end with newline\";\n+    ASSERT_TRUE(end != nullptr) <<  \"line should end with newline\";\n@@ -84,1 +84,1 @@\n-    EXPECT_TRUE(last_tag == NULL || strcmp(last_tag, tag) < 0) << tag << \" should be listed before \" << last_tag;\n+    EXPECT_TRUE(last_tag == nullptr || strcmp(last_tag, tag) < 0) << tag << \" should be listed before \" << last_tag;\n","filename":"test\/hotspot\/gtest\/logging\/test_logTag.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -51,1 +51,1 @@\n-  EXPECT_FALSE(ts.has_output(NULL));\n+  EXPECT_FALSE(ts.has_output(nullptr));\n@@ -142,1 +142,1 @@\n-  for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n@@ -157,1 +157,1 @@\n-    for (LogTagSet* other = ts->next(); other != NULL; other = other->next()) {\n+    for (LogTagSet* other = ts->next(); other != nullptr; other = other->next()) {\n","filename":"test\/hotspot\/gtest\/logging\/test_logTagSet.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-  for (LogTagSetDescription* d = tagset_descriptions; d->tagset != NULL; d++) {\n+  for (LogTagSetDescription* d = tagset_descriptions; d->tagset != nullptr; d++) {\n@@ -54,1 +54,1 @@\n-  ASSERT_NE((void*)NULL, fp);\n+  ASSERT_NE((void*)nullptr, fp);\n@@ -59,1 +59,1 @@\n-  for (LogTagSetDescription* d = tagset_descriptions; d->tagset != NULL; d++) {\n+  for (LogTagSetDescription* d = tagset_descriptions; d->tagset != nullptr; d++) {\n","filename":"test\/hotspot\/gtest\/logging\/test_logTagSetDescriptions.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-\/\/ Test behavior for Afree(NULL) and Arealloc(NULL, x)\n+\/\/ Test behavior for Afree(nullptr) and Arealloc(nullptr, x)\n@@ -100,1 +100,1 @@\n-  ar.Afree(NULL, 10); \/\/ should just be ignored\n+  ar.Afree(nullptr, 10); \/\/ should just be ignored\n@@ -105,1 +105,1 @@\n-  void* p = ar.Arealloc(NULL, 0, 20); \/\/ equivalent to Amalloc(20)\n+  void* p = ar.Arealloc(nullptr, 0, 20); \/\/ equivalent to Amalloc(20)\n@@ -241,1 +241,1 @@\n-    void* p = NULL;\n+    void* p = nullptr;\n@@ -300,1 +300,1 @@\n-      ptrs[i] = NULL;\n+      ptrs[i] = nullptr;\n","filename":"test\/hotspot\/gtest\/memory\/test_arena.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-  ASSERT_TRUE(p != NULL) << \"NULL pointer given to check\";\n+  ASSERT_TRUE(p != nullptr) << \"nullptr pointer given to check\";\n@@ -133,1 +133,1 @@\n-  EXPECT_TRUE(GuardedMemory::free_copy(NULL)) << \"Expected free NULL to be OK\";\n+  EXPECT_TRUE(GuardedMemory::free_copy(nullptr)) << \"Expected free nullptr to be OK\";\n@@ -138,1 +138,1 @@\n-  guarded_memory_test_check(str_copy, str_sz, NULL);\n+  guarded_memory_test_check(str_copy, str_sz, nullptr);\n@@ -145,1 +145,1 @@\n-  void* no_data = NULL;\n+  void* no_data = nullptr;\n","filename":"test\/hotspot\/gtest\/memory\/test_guardedMemory.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-    EXPECT_TRUE(rs.base() != NULL) << \"rs.special: \" << rs.special();\n+    EXPECT_TRUE(rs.base() != nullptr) << \"rs.special: \" << rs.special();\n@@ -81,1 +81,1 @@\n-    ReservedSpace rs(size, alignment, page_size, (char *) NULL);\n+    ReservedSpace rs(size, alignment, page_size, (char *) nullptr);\n@@ -83,1 +83,1 @@\n-    ASSERT_TRUE(rs.base() != NULL) << \"rs.special = \" << rs.special();\n+    ASSERT_TRUE(rs.base() != nullptr) << \"rs.special = \" << rs.special();\n@@ -112,1 +112,1 @@\n-    EXPECT_TRUE(rs.base() != NULL) << \"rs.special: \" << rs.special();\n+    EXPECT_TRUE(rs.base() != nullptr) << \"rs.special: \" << rs.special();\n@@ -372,1 +372,1 @@\n-                     (char *)NULL); \/\/ requested_address\n+                     (char *)nullptr); \/\/ requested_address\n@@ -374,1 +374,1 @@\n-    EXPECT_TRUE(rs.base() != NULL);\n+    EXPECT_TRUE(rs.base() != nullptr);\n@@ -392,1 +392,1 @@\n-    EXPECT_TRUE(rs.base() != NULL);\n+    EXPECT_TRUE(rs.base() != nullptr);\n@@ -417,1 +417,1 @@\n-    EXPECT_TRUE(rs.base() != NULL);\n+    EXPECT_TRUE(rs.base() != nullptr);\n","filename":"test\/hotspot\/gtest\/memory\/test_virtualspace.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-  assert(word_size > 0 && p != NULL, \"sanity\");\n+  assert(word_size > 0 && p != nullptr, \"sanity\");\n@@ -64,1 +64,1 @@\n-  assert(p != NULL, \"sanity\");\n+  assert(p != nullptr, \"sanity\");\n@@ -77,1 +77,1 @@\n-  assert(word_size > 0 && p != NULL, \"sanity\");\n+  assert(word_size > 0 && p != nullptr, \"sanity\");\n@@ -83,1 +83,1 @@\n-  assert(word_size > 0 && p != NULL, \"sanity\");\n+  assert(word_size > 0 && p != nullptr, \"sanity\");\n@@ -89,1 +89,1 @@\n-  assert(word_size > 0 && p != NULL, \"sanity\");\n+  assert(word_size > 0 && p != nullptr, \"sanity\");\n","filename":"test\/hotspot\/gtest\/metaspace\/metaspaceGtestCommon.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-  TestMap(size_t len) : _len(len), _arr(NULL) {\n+  TestMap(size_t len) : _len(len), _arr(nullptr) {\n@@ -148,1 +148,1 @@\n-\/\/ Some helpers to avoid typing out those annoying casts for NULL\n+\/\/ Some helpers to avoid typing out those annoying casts for nullptr\n@@ -150,4 +150,4 @@\n-#define ASSERT_NOT_NULL(ptr)      ASSERT_NE((void*)NULL, (void*)ptr)\n-#define ASSERT_NULL(ptr)          ASSERT_EQ((void*)NULL, (void*)ptr)\n-#define EXPECT_NOT_NULL(ptr)      EXPECT_NE((void*)NULL, (void*)ptr)\n-#define EXPECT_NULL(ptr)          EXPECT_EQ((void*)NULL, (void*)ptr)\n+#define ASSERT_NOT_NULL(ptr)      ASSERT_NE(nullptr, (void*)ptr)\n+#define ASSERT_NULL(ptr)          ASSERT_EQ(nullptr, (void*)ptr)\n+#define EXPECT_NOT_NULL(ptr)      EXPECT_NE(nullptr, (void*)ptr)\n+#define EXPECT_NULL(ptr)          EXPECT_EQ(nullptr, (void*)ptr)\n@@ -191,1 +191,1 @@\n-  FeederBuffer(size_t size) : _buf(NULL), _cap(size), _used(0) {\n+  FeederBuffer(size_t size) : _buf(nullptr), _cap(size), _used(0) {\n@@ -201,1 +201,1 @@\n-      return NULL;\n+      return nullptr;\n","filename":"test\/hotspot\/gtest\/metaspace\/metaspaceGtestCommon.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-  *p_return_value = NULL;\n+  *p_return_value = nullptr;\n@@ -41,1 +41,1 @@\n-  if (c != NULL) {\n+  if (c != nullptr) {\n","filename":"test\/hotspot\/gtest\/metaspace\/metaspaceGtestContexts.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-    Metachunk* c = NULL;\n+    Metachunk* c = nullptr;\n","filename":"test\/hotspot\/gtest\/metaspace\/metaspaceGtestContexts.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,2 +71,2 @@\n-    case cond_null:     return _slots[slot] == NULL;\n-    case cond_non_null: return _slots[slot] != NULL;\n+    case cond_null:     return _slots[slot] == nullptr;\n+    case cond_non_null: return _slots[slot] != nullptr;\n@@ -98,1 +98,1 @@\n-      _slots[i] = NULL;\n+      _slots[i] = nullptr;\n@@ -112,1 +112,1 @@\n-  bool slot_is_null(int i) const                      { check_index(i); return _slots[i] == NULL; }\n+  bool slot_is_null(int i) const                      { check_index(i); return _slots[i] == nullptr; }\n","filename":"test\/hotspot\/gtest\/metaspace\/metaspaceGtestSparseArray.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-    EXPECT_EQ(p, (MetaWord*)NULL);\n+    EXPECT_EQ(p, (MetaWord*)nullptr);\n@@ -106,1 +106,1 @@\n-          EXPECT_EQ(p, (MetaWord*)NULL);\n+          EXPECT_EQ(p, (MetaWord*)nullptr);\n@@ -139,1 +139,1 @@\n-      if (p != NULL) {\n+      if (p != nullptr) {\n@@ -160,1 +160,1 @@\n-      if (p != NULL) {\n+      if (p != nullptr) {\n@@ -170,1 +170,1 @@\n-        ASSERT_EQ(real_size, (size_t)NULL);\n+        ASSERT_EQ(real_size, (size_t)nullptr);\n@@ -189,1 +189,1 @@\n-        ASSERT_NE(p, (MetaWord*) NULL);\n+        ASSERT_NE(p, (MetaWord*) nullptr);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_binlist.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-  MetaWord* p = NULL;\n+  MetaWord* p = nullptr;\n@@ -281,1 +281,1 @@\n-    MetaWord* p = NULL;\n+    MetaWord* p = nullptr;\n@@ -309,1 +309,1 @@\n-      if (p != NULL) {\n+      if (p != nullptr) {\n@@ -316,1 +316,1 @@\n-    } while (p != NULL && added < max_blocks);\n+    } while (p != nullptr && added < max_blocks);\n@@ -338,1 +338,1 @@\n-      if (p != NULL) {\n+      if (p != nullptr) {\n","filename":"test\/hotspot\/gtest\/metaspace\/test_blocktree.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-    Metachunk* c = NULL;\n+    Metachunk* c = nullptr;\n@@ -121,1 +121,1 @@\n-    if (c == NULL) {\n+    if (c == nullptr) {\n@@ -165,1 +165,1 @@\n-    _chunks.set_at(slot, NULL);\n+    _chunks.set_at(slot, nullptr);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_chunkManager_stress.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-    if (_elems[index] == NULL) {\n+    if (_elems[index] == nullptr) {\n@@ -56,1 +56,1 @@\n-    _elems[index] = NULL;\n+    _elems[index] = nullptr;\n@@ -69,1 +69,1 @@\n-    if (_elems[index] != NULL) {\n+    if (_elems[index] != nullptr) {\n@@ -85,1 +85,1 @@\n-    if (_elems[index] == NULL) {\n+    if (_elems[index] == nullptr) {\n","filename":"test\/hotspot\/gtest\/metaspace\/test_chunkheaderpool.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-    if (p != NULL) {\n+    if (p != nullptr) {\n@@ -85,1 +85,1 @@\n-    if (a != NULL) {\n+    if (a != nullptr) {\n@@ -104,1 +104,1 @@\n-    if (p != NULL) {\n+    if (p != nullptr) {\n@@ -118,1 +118,1 @@\n-    for (allocation_t* a = _allocations; a != NULL; a = a->next) {\n+    for (allocation_t* a = _allocations; a != nullptr; a = a->next) {\n@@ -180,1 +180,1 @@\n-    _allocations(NULL),\n+    _allocations(nullptr),\n","filename":"test\/hotspot\/gtest\/metaspace\/test_freeblocks.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-  MetaspaceIsMetaspaceObjTest() : _lock(NULL), _ms(NULL) {}\n+  MetaspaceIsMetaspaceObjTest() : _lock(nullptr), _ms(nullptr) {}\n@@ -78,1 +78,1 @@\n-    ASSERT_FALSE(MetaspaceObj::is_valid((MetaspaceObj*)NULL));\n+    ASSERT_FALSE(MetaspaceObj::is_valid((MetaspaceObj*)nullptr));\n@@ -96,1 +96,1 @@\n-    _ms = NULL;\n+    _ms = nullptr;\n@@ -98,1 +98,1 @@\n-    _lock = NULL;\n+    _lock = nullptr;\n","filename":"test\/hotspot\/gtest\/metaspace\/test_is_metaspace_obj.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-  Metachunk* c = NULL;\n+  Metachunk* c = nullptr;\n@@ -73,1 +73,1 @@\n-    Metachunk* c = NULL;\n+    Metachunk* c = nullptr;\n@@ -106,1 +106,1 @@\n-  Metachunk* c = NULL;\n+  Metachunk* c = nullptr;\n@@ -139,1 +139,1 @@\n-  Metachunk* c = NULL;\n+  Metachunk* c = nullptr;\n@@ -155,1 +155,1 @@\n-    Metachunk* c = NULL;\n+    Metachunk* c = nullptr;\n@@ -170,1 +170,1 @@\n-    Metachunk* c = NULL;\n+    Metachunk* c = nullptr;\n@@ -205,1 +205,1 @@\n-    Metachunk* c1 = NULL;\n+    Metachunk* c1 = nullptr;\n@@ -209,1 +209,1 @@\n-    Metachunk* c2 = NULL;\n+    Metachunk* c2 = nullptr;\n@@ -237,1 +237,1 @@\n-  Metachunk* c = NULL;\n+  Metachunk* c = nullptr;\n@@ -313,1 +313,1 @@\n-    Metachunk* c = NULL;\n+    Metachunk* c = nullptr;\n@@ -390,1 +390,1 @@\n-  Metachunk* c = NULL;\n+  Metachunk* c = nullptr;\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metachunk.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-    Metachunk* c = NULL;\n+    Metachunk* c = nullptr;\n@@ -98,1 +98,1 @@\n-    Metachunk* c = NULL;\n+    Metachunk* c = nullptr;\n@@ -125,1 +125,1 @@\n-    while (c != NULL) {\n+    while (c != nullptr) {\n@@ -156,1 +156,1 @@\n-  Metachunk* c = NULL;\n+  Metachunk* c = nullptr;\n@@ -165,1 +165,1 @@\n-  Metachunk* c_0 = NULL;\n+  Metachunk* c_0 = nullptr;\n@@ -169,1 +169,1 @@\n-  Metachunk* c_full = NULL;\n+  Metachunk* c_full = nullptr;\n@@ -173,1 +173,1 @@\n-  Metachunk* c_1g = NULL;\n+  Metachunk* c_1g = nullptr;\n@@ -177,1 +177,1 @@\n-  Metachunk* c_2g = NULL;\n+  Metachunk* c_2g = nullptr;\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metachunklist.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,1 +112,1 @@\n-    if (_arena != NULL) {\n+    if (_arena != nullptr) {\n@@ -117,1 +117,1 @@\n-      _arena = NULL;\n+      _arena = nullptr;\n@@ -127,2 +127,2 @@\n-    if (p_used != NULL) {\n-      if (p_committed != NULL) {\n+    if (p_used != nullptr) {\n+      if (p_committed != nullptr) {\n@@ -134,1 +134,1 @@\n-    if (p_committed != NULL && p_capacity != NULL) {\n+    if (p_committed != nullptr && p_capacity != nullptr) {\n@@ -147,1 +147,1 @@\n-    MetaWord* dummy = NULL;\n+    MetaWord* dummy = nullptr;\n@@ -153,1 +153,1 @@\n-    MetaWord* dummy = NULL;\n+    MetaWord* dummy = nullptr;\n@@ -174,1 +174,1 @@\n-    if (p == NULL) {\n+    if (p == nullptr) {\n@@ -197,1 +197,1 @@\n-    MetaWord* dummy = NULL;\n+    MetaWord* dummy = nullptr;\n@@ -422,1 +422,1 @@\n-    MetaWord* p1 = NULL;\n+    MetaWord* p1 = nullptr;\n@@ -426,1 +426,1 @@\n-    helper.usage_numbers_with_test(&used1, NULL, &capacity1);\n+    helper.usage_numbers_with_test(&used1, nullptr, &capacity1);\n@@ -432,1 +432,1 @@\n-    helper.usage_numbers_with_test(&used2, NULL, &capacity2);\n+    helper.usage_numbers_with_test(&used2, nullptr, &capacity2);\n@@ -436,1 +436,1 @@\n-    MetaWord* p2 = NULL;\n+    MetaWord* p2 = nullptr;\n@@ -440,1 +440,1 @@\n-    helper.usage_numbers_with_test(&used3, NULL, &capacity3);\n+    helper.usage_numbers_with_test(&used3, nullptr, &capacity3);\n@@ -487,2 +487,2 @@\n-  MetaWord* p = NULL;\n-  while ( (helper3.allocate_from_arena_with_tests(&p, 1), p != NULL) &&\n+  MetaWord* p = nullptr;\n+  while ( (helper3.allocate_from_arena_with_tests(&p, 1), p != nullptr) &&\n@@ -748,1 +748,1 @@\n-    MetaWord* p = NULL, *p2 = NULL;\n+    MetaWord* p = nullptr, *p2 = nullptr;\n@@ -761,1 +761,1 @@\n-    helper.usage_numbers_with_test(&used1, &committed1, NULL);\n+    helper.usage_numbers_with_test(&used1, &committed1, nullptr);\n@@ -772,1 +772,1 @@\n-    helper.usage_numbers_with_test(&used2, &committed2, NULL);\n+    helper.usage_numbers_with_test(&used2, &committed2, nullptr);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-    MetaWord* p; \/\/ NULL if deallocated\n+    MetaWord* p; \/\/ nullptr if deallocated\n@@ -81,1 +81,1 @@\n-      if (p != NULL) {\n+      if (p != nullptr) {\n@@ -137,2 +137,2 @@\n-    _arena(NULL),\n-    _lock(NULL),\n+    _arena(nullptr),\n+    _lock(nullptr),\n@@ -141,1 +141,1 @@\n-    _allocations(NULL),\n+    _allocations(nullptr),\n@@ -157,1 +157,1 @@\n-    while (a != NULL) {\n+    while (a != nullptr) {\n@@ -181,1 +181,1 @@\n-    if (p != NULL) {\n+    if (p != nullptr) {\n@@ -204,1 +204,1 @@\n-    while (a && a->p != NULL && os::random() % 10 != 0) {\n+    while (a && a->p != nullptr && os::random() % 10 != 0) {\n@@ -207,1 +207,1 @@\n-    if (a != NULL && a->p != NULL) {\n+    if (a != nullptr && a->p != nullptr) {\n@@ -211,1 +211,1 @@\n-      a->p = NULL; a->word_size = 0;\n+      a->p = nullptr; a->word_size = 0;\n@@ -271,1 +271,1 @@\n-    _testbeds.set_at(slotindex, NULL);\n+    _testbeds.set_at(slotindex, nullptr);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena_stress.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-    Metachunk* c = NULL;\n+    Metachunk* c = nullptr;\n@@ -267,1 +267,1 @@\n-    Metachunk* result = NULL;\n+    Metachunk* result = nullptr;\n@@ -302,1 +302,1 @@\n-    _node(NULL),\n+    _node(nullptr),\n@@ -336,1 +336,1 @@\n-    Metachunk* c = NULL;\n+    Metachunk* c = nullptr;\n@@ -340,1 +340,1 @@\n-      if (c != NULL) {\n+      if (c != nullptr) {\n@@ -343,1 +343,1 @@\n-    } while (c != NULL && rc);\n+    } while (c != nullptr && rc);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_virtualspacenode.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,1 @@\n-  \/\/ very low, like the result of an overflow or of accessing a NULL this pointer\n+  \/\/ very low, like the result of an overflow or of accessing a null this pointer\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_buffer_overflow_detection.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-    p4 = os_realloc(NULL, 10);           \/\/ realloc with NULL pointer\n+    p4 = os_realloc(nullptr, 10);        \/\/ realloc with null pointer\n@@ -91,1 +91,1 @@\n-    os::free(NULL);                      \/\/ free(null)\n+    os::free(nullptr);                      \/\/ free(null)\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmtpreinit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-    allocations[i] = NULL;\n+    allocations[i] = nullptr;\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmtpreinitmap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,4 +86,4 @@\n-  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n-      << \"thr->_threads_hazard_ptr must be NULL\";\n-  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) NULL)\n-      << \"thr->_threads_list_ptr must be NULL\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)nullptr)\n+      << \"thr->_threads_hazard_ptr must be null\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) nullptr)\n+      << \"thr->_threads_list_ptr must be null\";\n@@ -108,2 +108,2 @@\n-    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+        << \"list_ptr1->previous() must be null\";\n@@ -128,4 +128,4 @@\n-  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n-      << \"thr->_threads_hazard_ptr must match be NULL\";\n-  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) NULL)\n-      << \"thr->_threads_list_ptr must be NULL\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)nullptr)\n+      << \"thr->_threads_hazard_ptr must match be null\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) nullptr)\n+      << \"thr->_threads_list_ptr must be null\";\n@@ -150,2 +150,2 @@\n-    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+        << \"list_ptr1->previous() must be null\";\n@@ -198,2 +198,2 @@\n-      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-          << \"list_ptr1->previous() must be NULL\";\n+      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+          << \"list_ptr1->previous() must be null\";\n@@ -218,3 +218,3 @@\n-    \/\/ Verify the current thread's hazard ptr is NULL:\n-    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n-        << \"thr->_threads_hazard_ptr must be NULL\";\n+    \/\/ Verify the current thread's hazard ptr is null:\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)nullptr)\n+        << \"thr->_threads_hazard_ptr must be null\";\n@@ -228,2 +228,2 @@\n-    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+        << \"list_ptr1->previous() must be null\";\n@@ -250,4 +250,4 @@\n-  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n-      << \"thr->_threads_hazard_ptr must match be NULL\";\n-  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) NULL)\n-      << \"thr->_threads_list_ptr must be NULL\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)nullptr)\n+      << \"thr->_threads_hazard_ptr must match be null\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) nullptr)\n+      << \"thr->_threads_list_ptr must be null\";\n@@ -272,2 +272,2 @@\n-    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+        << \"list_ptr1->previous() must be null\";\n@@ -320,2 +320,2 @@\n-      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-          << \"list_ptr1->previous() must be NULL\";\n+      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+          << \"list_ptr1->previous() must be null\";\n@@ -386,2 +386,2 @@\n-        EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-            << \"list_ptr1->previous() must be NULL\";\n+        EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+            << \"list_ptr1->previous() must be null\";\n@@ -406,3 +406,3 @@\n-      \/\/ Verify the current thread's hazard ptr is NULL:\n-      EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n-          << \"thr->_threads_hazard_ptr must be NULL\";\n+      \/\/ Verify the current thread's hazard ptr is null:\n+      EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)nullptr)\n+          << \"thr->_threads_hazard_ptr must be null\";\n@@ -434,2 +434,2 @@\n-      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-          << \"list_ptr1->previous() must be NULL\";\n+      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+          << \"list_ptr1->previous() must be null\";\n@@ -454,3 +454,3 @@\n-    \/\/ Verify the current thread's hazard ptr is NULL:\n-    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n-        << \"thr->_threads_hazard_ptr must be NULL\";\n+    \/\/ Verify the current thread's hazard ptr is null:\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)nullptr)\n+        << \"thr->_threads_hazard_ptr must be null\";\n@@ -464,2 +464,2 @@\n-    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+        << \"list_ptr1->previous() must be null\";\n@@ -486,4 +486,4 @@\n-  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n-      << \"thr->_threads_hazard_ptr must match be NULL\";\n-  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) NULL)\n-      << \"thr->_threads_list_ptr must be NULL\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)nullptr)\n+      << \"thr->_threads_hazard_ptr must match be null\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) nullptr)\n+      << \"thr->_threads_list_ptr must be null\";\n@@ -508,2 +508,2 @@\n-    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+        << \"list_ptr1->previous() must be null\";\n@@ -556,2 +556,2 @@\n-      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-          << \"list_ptr1->previous() must be NULL\";\n+      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+          << \"list_ptr1->previous() must be null\";\n@@ -576,3 +576,3 @@\n-    \/\/ Verify the current thread's hazard ptr is NULL:\n-    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n-        << \"thr->_threads_hazard_ptr must be NULL\";\n+    \/\/ Verify the current thread's hazard ptr is null:\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)nullptr)\n+        << \"thr->_threads_hazard_ptr must be null\";\n@@ -586,2 +586,2 @@\n-    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+        << \"list_ptr1->previous() must be null\";\n@@ -636,2 +636,2 @@\n-      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-          << \"list_ptr1->previous() must be NULL\";\n+      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+          << \"list_ptr1->previous() must be null\";\n@@ -656,3 +656,3 @@\n-    \/\/ Verify the current thread's hazard ptr is NULL:\n-    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n-        << \"thr->_threads_hazard_ptr must be NULL\";\n+    \/\/ Verify the current thread's hazard ptr is null:\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)nullptr)\n+        << \"thr->_threads_hazard_ptr must be null\";\n@@ -666,2 +666,2 @@\n-    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n-        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)nullptr)\n+        << \"list_ptr1->previous() must be null\";\n@@ -688,4 +688,4 @@\n-  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n-      << \"thr->_threads_hazard_ptr must match be NULL\";\n-  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) NULL)\n-      << \"thr->_threads_list_ptr must be NULL\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)nullptr)\n+      << \"thr->_threads_hazard_ptr must match be null\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) nullptr)\n+      << \"thr->_threads_list_ptr must be null\";\n","filename":"test\/hotspot\/gtest\/runtime\/test_ThreadsListHandle.cpp","additions":64,"deletions":64,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,1 +157,1 @@\n-  jint err = parse_xss(NULL \/* Silence error messages *\/, str, &value);\n+  jint err = parse_xss(nullptr \/* Silence error messages *\/, str, &value);\n@@ -234,1 +234,1 @@\n-    if (str == NULL) {\n+    if (str == nullptr) {\n@@ -276,1 +276,1 @@\n-      NULL,\n+      nullptr,\n@@ -286,1 +286,1 @@\n-      NULL,\n+      nullptr,\n@@ -296,1 +296,1 @@\n-      NULL,\n+      nullptr,\n@@ -452,1 +452,1 @@\n-  if (flag == NULL) { \/\/ not available in product builds\n+  if (flag == nullptr) { \/\/ not available in product builds\n@@ -467,1 +467,1 @@\n-  if (flag == NULL) { \/\/ not available in product builds\n+  if (flag == nullptr) { \/\/ not available in product builds\n@@ -482,1 +482,1 @@\n-  if (flag == NULL) { \/\/ not available in product builds\n+  if (flag == nullptr) { \/\/ not available in product builds\n@@ -498,1 +498,1 @@\n-  if (flag == NULL) { \/\/ not available in product builds\n+  if (flag == nullptr) { \/\/ not available in product builds\n@@ -558,1 +558,1 @@\n-  if (flag == NULL) { \/\/ not available in product builds\n+  if (flag == nullptr) { \/\/ not available in product builds\n@@ -600,1 +600,1 @@\n-    if (errno == 0 && end != NULL && *end == '\\0') {\n+    if (errno == 0 && end != nullptr && *end == '\\0') {\n","filename":"test\/hotspot\/gtest\/runtime\/test_arguments.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,3 @@\n-  TempNewSymbol retval = ClassLoader::package_from_class_name(NULL, &bad_class_name);\n-  ASSERT_TRUE(bad_class_name) << \"Function did not set bad_class_name with NULL class name\";\n-  ASSERT_TRUE(retval == NULL) << \"Wrong package for NULL class name pointer\";\n+  TempNewSymbol retval = ClassLoader::package_from_class_name(nullptr, &bad_class_name);\n+  ASSERT_TRUE(bad_class_name) << \"Function did not set bad_class_name with null class name\";\n+  ASSERT_TRUE(retval == nullptr) << \"Wrong package for null class name pointer\";\n@@ -42,1 +42,1 @@\n-  ASSERT_TRUE(retval == NULL) << \"Wrong package for empty string\";\n+  ASSERT_TRUE(retval == nullptr) << \"Wrong package for empty string\";\n@@ -50,1 +50,1 @@\n-  ASSERT_TRUE(retval == NULL) << \"Wrong package for class with no slashes\";\n+  ASSERT_TRUE(retval == nullptr) << \"Wrong package for class with no slashes\";\n@@ -58,1 +58,1 @@\n-  ASSERT_TRUE(retval == NULL) << \"Wrong package for class with just slash\";\n+  ASSERT_TRUE(retval == nullptr) << \"Wrong package for class with just slash\";\n@@ -106,1 +106,1 @@\n-  ASSERT_TRUE(retval == NULL) << \"Wrong package for class with leading '[L'\";\n+  ASSERT_TRUE(retval == nullptr) << \"Wrong package for class with leading '[L'\";\n","filename":"test\/hotspot\/gtest\/runtime\/test_classLoader.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    ASSERT_TRUE(rmr != NULL);\n+    ASSERT_TRUE(rmr != nullptr);\n@@ -63,1 +63,1 @@\n-    for (const CommittedMemoryRegion* region = iter.next(); region != NULL; region = iter.next()) {\n+    for (const CommittedMemoryRegion* region = iter.next(); region != nullptr; region = iter.next()) {\n@@ -101,1 +101,1 @@\n-    ASSERT_NE(base, (char*)NULL);\n+    ASSERT_NE(base, (char*)nullptr);\n@@ -115,1 +115,1 @@\n-    ASSERT_TRUE(rmr != NULL);\n+    ASSERT_TRUE(rmr != nullptr);\n@@ -119,1 +119,1 @@\n-    for (const CommittedMemoryRegion* region = iter.next(); region != NULL; region = iter.next()) {\n+    for (const CommittedMemoryRegion* region = iter.next(); region != nullptr; region = iter.next()) {\n@@ -122,1 +122,1 @@\n-        ASSERT_TRUE(iter.next() == NULL);\n+        ASSERT_TRUE(iter.next() == nullptr);\n@@ -142,1 +142,1 @@\n-    ASSERT_TRUE(rmr == NULL);\n+    ASSERT_TRUE(rmr == nullptr);\n@@ -167,1 +167,1 @@\n-    ASSERT_NE(base, (char*)NULL);\n+    ASSERT_NE(base, (char*)nullptr);\n","filename":"test\/hotspot\/gtest\/runtime\/test_committed_virtualmemory.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,1 @@\n-  JVMFlag* flag = (name == NULL) ? NULL : JVMFlag::find_flag(name);\n+  JVMFlag* flag = (name == nullptr) ? nullptr : JVMFlag::find_flag(name);\n@@ -104,1 +104,1 @@\n-  ASSERT_EQ((get_flag<JVM_FLAG_TYPE(int)>(NULL)), JVMFlag::INVALID_FLAG);\n+  ASSERT_EQ((get_flag<JVM_FLAG_TYPE(int)>(nullptr)), JVMFlag::INVALID_FLAG);\n","filename":"test\/hotspot\/gtest\/runtime\/test_globals.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -315,2 +315,2 @@\n-  check_snprintf_result(0, 0, pf(NULL, 0, \"%s\", \"\"), expect_count);\n-  check_snprintf_result(0, 0, pf(NULL, 0, \"\"), expect_count);\n+  check_snprintf_result(0, 0, pf(nullptr, 0, \"%s\", \"\"), expect_count);\n+  check_snprintf_result(0, 0, pf(nullptr, 0, \"\"), expect_count);\n@@ -370,1 +370,1 @@\n-  bool exec_supported = (p != NULL);\n+  bool exec_supported = (p != nullptr);\n@@ -403,2 +403,2 @@\n-  address p = NULL;\n-  for (int tries = 0; tries < 256 && p == NULL; tries ++) {\n+  address p = nullptr;\n+  for (int tries = 0; tries < 256 && p == nullptr; tries ++) {\n@@ -408,1 +408,1 @@\n-    EXPECT_NE(p, (address)NULL);\n+    EXPECT_NE(p, (address)nullptr);\n@@ -422,1 +422,1 @@\n-      if (q == NULL) {\n+      if (q == nullptr) {\n@@ -426,1 +426,1 @@\n-        p = NULL;\n+        p = nullptr;\n@@ -442,1 +442,1 @@\n-  EXPECT_NE(p, (address)NULL);\n+  EXPECT_NE(p, (address)nullptr);\n@@ -493,1 +493,1 @@\n-  ASSERT_NE(p, (address)NULL);\n+  ASSERT_NE(p, (address)nullptr);\n@@ -532,1 +532,1 @@\n-  ASSERT_NE(p, (char*)NULL);\n+  ASSERT_NE(p, (char*)nullptr);\n@@ -626,1 +626,1 @@\n-  ASSERT_FALSE(os::win32::find_mapping((address)NULL, &mapping_info));\n+  ASSERT_FALSE(os::win32::find_mapping((address)nullptr, &mapping_info));\n@@ -632,1 +632,1 @@\n-    ASSERT_NE(p, (address)NULL);\n+    ASSERT_NE(p, (address)nullptr);\n@@ -661,1 +661,1 @@\n-  ASSERT_NE(p, (address)NULL);\n+  ASSERT_NE(p, (address)nullptr);\n@@ -690,1 +690,1 @@\n-    ASSERT_NE(p, (address)NULL);\n+    ASSERT_NE(p, (address)nullptr);\n@@ -797,2 +797,2 @@\n-  LOG(\"os::print_function_and_library_name(st, NULL) expects FALSE.\");\n-  addr = NULL;\n+  LOG(\"os::print_function_and_library_name(st, nullptr) expects FALSE.\");\n+  addr = nullptr;\n@@ -815,1 +815,1 @@\n-                                                    provide_scratch_buffer ? tmp : NULL,\n+                                                    provide_scratch_buffer ? tmp : nullptr,\n@@ -861,1 +861,1 @@\n-  const char* result = NULL;\n+  const char* result = nullptr;\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-      if (_ptr != NULL) {\n+      if (_ptr != nullptr) {\n@@ -90,2 +90,2 @@\n-    char* addr = ShmMemory::reserve_memory_special_shm(size, alignment, NULL, false);\n-    if (addr != NULL) {\n+    char* addr = ShmMemory::reserve_memory_special_shm(size, alignment, nullptr, false);\n+    if (addr != nullptr) {\n@@ -108,1 +108,1 @@\n-    char* addr = HugeTlbfsMemory::reserve_memory_special_huge_tlbfs(size, lp, lp, NULL, false);\n+    char* addr = HugeTlbfsMemory::reserve_memory_special_huge_tlbfs(size, lp, lp, nullptr, false);\n@@ -110,1 +110,1 @@\n-    if (addr != NULL) {\n+    if (addr != nullptr) {\n@@ -134,2 +134,2 @@\n-      char* p = HugeTlbfsMemory::reserve_memory_special_huge_tlbfs(size, alignment, lp, NULL, false);\n-      if (p != NULL) {\n+      char* p = HugeTlbfsMemory::reserve_memory_special_huge_tlbfs(size, alignment, lp, nullptr, false);\n+      if (p != nullptr) {\n@@ -162,1 +162,1 @@\n-  char* const mapping = (char*) ::mmap(NULL, mapping_size,\n+  char* const mapping = (char*) ::mmap(nullptr, mapping_size,\n@@ -175,1 +175,1 @@\n-      if (p != NULL) {\n+      if (p != nullptr) {\n@@ -203,1 +203,1 @@\n-  char* const mapping = (char*) ::mmap(NULL, mapping_size,\n+  char* const mapping = (char*) ::mmap(nullptr, mapping_size,\n@@ -227,2 +227,2 @@\n-      \/\/ return NULL (as per contract, it cannot return another address)\n-      EXPECT_TRUE(p == NULL) << \" size = \" << size\n+      \/\/ return null (as per contract, it cannot return another address)\n+      EXPECT_TRUE(p == nullptr) << \" size = \" << size\n@@ -266,1 +266,1 @@\n-    char* addr = os::Linux::reserve_memory_special_huge_tlbfs(size, alignment, page_size, NULL, false);\n+    char* addr = os::Linux::reserve_memory_special_huge_tlbfs(size, alignment, page_size, nullptr, false);\n@@ -268,1 +268,1 @@\n-    if (addr != NULL) {\n+    if (addr != nullptr) {\n@@ -300,1 +300,1 @@\n-    \/\/ 1) with req_addr == NULL\n+    \/\/ 1) with req_addr == nullptr\n@@ -308,1 +308,1 @@\n-    char* const mapping1 = (char*) ::mmap(NULL, mapping_size,\n+    char* const mapping1 = (char*) ::mmap(nullptr, mapping_size,\n@@ -313,1 +313,1 @@\n-    char* const mapping2 = (char*) ::mmap(NULL, mapping_size,\n+    char* const mapping2 = (char*) ::mmap(nullptr, mapping_size,\n@@ -327,2 +327,2 @@\n-        char* p = os::Linux::reserve_memory_special_huge_tlbfs(size, alignment, lp, NULL, false);\n-        if (p != NULL) {\n+        char* p = os::Linux::reserve_memory_special_huge_tlbfs(size, alignment, lp, nullptr, false);\n+        if (p != nullptr) {\n@@ -343,1 +343,1 @@\n-        if (p != NULL) {\n+        if (p != nullptr) {\n@@ -359,2 +359,2 @@\n-        \/\/ return NULL (as per contract, it cannot return another address)\n-        EXPECT_TRUE(p == NULL);\n+        \/\/ return nullptr (as per contract, it cannot return another address)\n+        EXPECT_TRUE(p == nullptr);\n@@ -382,1 +382,1 @@\n-    char* addr = os::Linux::reserve_memory_special_shm(size, alignment, NULL, false);\n+    char* addr = os::Linux::reserve_memory_special_shm(size, alignment, nullptr, false);\n@@ -384,1 +384,1 @@\n-    if (addr != NULL) {\n+    if (addr != nullptr) {\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux.cpp","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-    NULL,                   \/\/ root_path, ignored\n+    nullptr,                \/\/ root_path, ignored\n@@ -72,1 +72,1 @@\n-    NULL,                   \/\/ root_path, ignored\n+    nullptr,                \/\/ root_path, ignored\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux_cgroups.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-      if (_ptr != NULL) {\n+      if (_ptr != nullptr) {\n@@ -56,1 +56,1 @@\n-\/\/ different valid one. A NULL return value at this point is not considered an error but may\n+\/\/ different valid one. A nullptr return value at this point is not considered an error but may\n@@ -70,2 +70,2 @@\n-  char* result = os::reserve_memory_special(large_allocation_size, os::large_page_size(), os::large_page_size(), NULL, false);\n-  if (result == NULL) {\n+  char* result = os::reserve_memory_special(large_allocation_size, os::large_page_size(), os::large_page_size(), nullptr, false);\n+  if (result == nullptr) {\n@@ -81,1 +81,1 @@\n-  EXPECT_TRUE(actual_location == NULL) << \"Should not be allowed to reserve within present reservation\";\n+  EXPECT_TRUE(actual_location == nullptr) << \"Should not be allowed to reserve within present reservation\";\n@@ -86,1 +86,1 @@\n-  EXPECT_TRUE(actual_location != NULL) << \"Unexpected reservation failure, cant verify correct location\";\n+  EXPECT_TRUE(actual_location != nullptr) << \"Unexpected reservation failure, cant verify correct location\";\n@@ -93,2 +93,2 @@\n-  char* aligned_request = os::reserve_memory_special(new_large_size, alignment, os::large_page_size(), NULL, false);\n-  EXPECT_TRUE(aligned_request != NULL) << \"Unexpected reservation failure, cant verify correct alignment\";\n+  char* aligned_request = os::reserve_memory_special(new_large_size, alignment, os::large_page_size(), nullptr, false);\n+  EXPECT_TRUE(aligned_request != nullptr) << \"Unexpected reservation failure, cant verify correct alignment\";\n@@ -142,1 +142,1 @@\n-  BOOL result = CreateDirectoryW(abs_path, NULL);\n+  BOOL result = CreateDirectoryW(abs_path, nullptr);\n@@ -168,1 +168,1 @@\n-  HANDLE h = CreateFileW(abs_path, 0, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);\n+  HANDLE h = CreateFileW(abs_path, 0, 0, nullptr, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, nullptr);\n@@ -221,1 +221,1 @@\n-    if (path_start == NULL) {\n+    if (path_start == nullptr) {\n@@ -248,1 +248,1 @@\n-      } else if (path_start != NULL) {\n+      } else if (path_start != nullptr) {\n@@ -400,1 +400,1 @@\n-        if (w_path != NULL) {\n+        if (w_path != nullptr) {\n@@ -420,1 +420,1 @@\n-            HANDLE h = ::CreateFileW(w_path, 0, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);\n+            HANDLE h = ::CreateFileW(w_path, 0, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, nullptr);\n@@ -442,1 +442,1 @@\n-      HANDLE h = ::CreateFileA(buf, 0, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);\n+      HANDLE h = ::CreateFileA(buf, 0, FILE_SHARE_READ, nullptr, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, nullptr);\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_windows.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,4 +37,4 @@\n-  ASSERT_NE(PerfMemory::start(), (char*)NULL) << \"PerfMemory::_start should not be NULL\";\n-  ASSERT_NE(PerfMemory::end(), (char*)NULL) << \"PerfMemory::_end should not be NULL\";\n-  ASSERT_NE(PerfMemoryTest::top(), (char*)NULL) << \"PerfMemory::_top should not be NULL\";\n-  ASSERT_NE(PerfMemoryTest::prologue(), (PerfDataPrologue*)NULL) << \"PerfMemory::_prologue should not be NULL\";\n+  ASSERT_NE(PerfMemory::start(), (char*)nullptr) << \"PerfMemory::_start should not be null\";\n+  ASSERT_NE(PerfMemory::end(), (char*)nullptr) << \"PerfMemory::_end should not be null\";\n+  ASSERT_NE(PerfMemoryTest::top(), (char*)nullptr) << \"PerfMemory::_top should not be null\";\n+  ASSERT_NE(PerfMemoryTest::prologue(), (PerfDataPrologue*)nullptr) << \"PerfMemory::_prologue should not be null\";\n","filename":"test\/hotspot\/gtest\/runtime\/test_perfdata.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-  \/\/ Also test NULL, but not on AIX, where NULL is readable\n+  \/\/ Also test nullptr, but not on AIX, where nullptr is readable\n@@ -69,1 +69,1 @@\n-  a = SafeFetchN(NULL, 0);\n+  a = SafeFetchN(nullptr, 0);\n@@ -71,1 +71,1 @@\n-  a = SafeFetchN(NULL, ~patternN);\n+  a = SafeFetchN(nullptr, ~patternN);\n@@ -83,1 +83,1 @@\n-  \/\/ Also test NULL, but not on AIX, where NULL is readable\n+  \/\/ Also test nullptr, but not on AIX, where nullptr is readable\n@@ -85,1 +85,1 @@\n-  a = SafeFetch32(NULL, 0);\n+  a = SafeFetch32(nullptr, 0);\n@@ -87,1 +87,1 @@\n-  a = SafeFetch32(NULL, ~pattern32);\n+  a = SafeFetch32(nullptr, ~pattern32);\n@@ -108,1 +108,1 @@\n-\/\/ Try with Thread::current being NULL. SafeFetch should work then too.\n+\/\/ Try with Thread::current being nullptr. SafeFetch should work then too.\n","filename":"test\/hotspot\/gtest\/runtime\/test_safefetch.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,2 +188,2 @@\n-  jobject buffer = env->NewDirectByteBuffer(NULL, (jlong)capacity);\n-  ASSERT_NE((void*)NULL, buffer);\n+  jobject buffer = env->NewDirectByteBuffer(nullptr, (jlong)capacity);\n+  ASSERT_NE((void*)nullptr, buffer);\n","filename":"test\/hotspot\/gtest\/runtime\/test_threads.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-    check_inner((rmr), NULL, 0, __FILE__, __LINE__);  \\\n+    check_inner((rmr), nullptr, 0, __FILE__, __LINE__);  \\\n@@ -64,1 +64,1 @@\n-  for (const CommittedMemoryRegion* region = iter.next(); region != NULL; region = iter.next()) {\n+  for (const CommittedMemoryRegion* region = iter.next(); region != nullptr; region = iter.next()) {\n@@ -79,1 +79,1 @@\n-  for (const CommittedMemoryRegion* region = iter.next(); region != NULL; region = iter.next()) {\n+  for (const CommittedMemoryRegion* region = iter.next(); region != nullptr; region = iter.next()) {\n","filename":"test\/hotspot\/gtest\/runtime\/test_virtualMemoryTracker.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,2 +58,2 @@\n-  for (int i = 0; VMStructs::localHotSpotVMTypes[i].typeName != NULL; i++) {\n-    for (int j = i + 1; VMStructs::localHotSpotVMTypes[j].typeName != NULL; j++) {\n+  for (int i = 0; VMStructs::localHotSpotVMTypes[i].typeName != nullptr; i++) {\n+    for (int j = i + 1; VMStructs::localHotSpotVMTypes[j].typeName != nullptr; j++) {\n","filename":"test\/hotspot\/gtest\/runtime\/test_vmStructs.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  if (p != NULL && s > 0) {\n+  if (p != nullptr && s > 0) {\n@@ -44,1 +44,1 @@\n-  if (p == NULL || s == 0) {\n+  if (p == nullptr || s == 0) {\n@@ -48,1 +48,1 @@\n-  const char* first_wrong = NULL;\n+  const char* first_wrong = nullptr;\n@@ -59,1 +59,1 @@\n-  if (first_wrong != NULL) {\n+  if (first_wrong != nullptr) {\n@@ -68,1 +68,1 @@\n-  return first_wrong == NULL;\n+  return first_wrong == nullptr;\n","filename":"test\/hotspot\/gtest\/testutils.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-  \/\/ Tolerates p == NULL or s == 0.\n+  \/\/ Tolerates p == nullptr or s == 0.\n@@ -41,1 +41,1 @@\n-  \/\/ If p == NULL or size == 0, returns true.\n+  \/\/ If p == nullptr or size == 0, returns true.\n@@ -56,2 +56,2 @@\n-\/\/ (ASSERT|EXPECT)_NOT_NULL: check that the given pointer is not NULL\n-\/\/ (ASSERT|EXPECT)_NULL: check that the given pointer is NULL\n+\/\/ (ASSERT|EXPECT)_NOT_NULL: check that the given pointer is not null\n+\/\/ (ASSERT|EXPECT)_NULL: check that the given pointer is null\n","filename":"test\/hotspot\/gtest\/testutils.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-    return Pointer::get_hash(_val, NULL);\n+    return Pointer::get_hash(_val, nullptr);\n@@ -122,1 +122,1 @@\n-    EXPECT_NE(value, (uintptr_t*)NULL) << \"expected valid value\";\n+    EXPECT_NE(value, (uintptr_t*)nullptr) << \"expected valid value\";\n@@ -565,1 +565,1 @@\n-    return TestInterface::get_hash(_val, NULL);\n+    return TestInterface::get_hash(_val, nullptr);\n@@ -687,1 +687,1 @@\n-  RunnerSimpleInserterThread(Semaphore* post) : CHTTestThread(0, 0, NULL, post) {\n+  RunnerSimpleInserterThread(Semaphore* post) : CHTTestThread(0, 0, nullptr, post) {\n@@ -771,1 +771,1 @@\n-  RunnerDeleteInserterThread(Semaphore* post) : CHTTestThread(0, 0, NULL, post) {\n+  RunnerDeleteInserterThread(Semaphore* post) : CHTTestThread(0, 0, nullptr, post) {\n@@ -798,1 +798,1 @@\n-        tv = tmp != NULL ? *tmp : 0;\n+        tv = tmp != nullptr ? *tmp : 0;\n@@ -897,1 +897,1 @@\n-  RunnerGSInserterThread(Semaphore* post) : CHTTestThread(0, 0, NULL, post) {\n+  RunnerGSInserterThread(Semaphore* post) : CHTTestThread(0, 0, nullptr, post) {\n@@ -1039,1 +1039,1 @@\n-  RunnerGI_BD_InserterThread(Semaphore* post) : CHTTestThread(0, 0, NULL, post) {\n+  RunnerGI_BD_InserterThread(Semaphore* post) : CHTTestThread(0, 0, nullptr, post) {\n","filename":"test\/hotspot\/gtest\/utilities\/test_concurrentHashtable.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-  while (head != NULL) {\n+  while (head != nullptr) {\n@@ -73,1 +73,1 @@\n-  ASSERT_TRUE(i != NULL) << \"Should find it\";\n+  ASSERT_TRUE(i != nullptr) << \"Should find it\";\n@@ -77,1 +77,1 @@\n-  ASSERT_TRUE(i == NULL) << \"Not in the list\";\n+  ASSERT_TRUE(i == nullptr) << \"Not in the list\";\n@@ -80,1 +80,1 @@\n-  ASSERT_TRUE(node != NULL) << \"6 is in the list\";\n+  ASSERT_TRUE(node != nullptr) << \"6 is in the list\";\n@@ -139,1 +139,1 @@\n-  EXPECT_EQ(it2.next(), (Integer* )NULL);\n+  EXPECT_EQ(it2.next(), (Integer* )nullptr);\n@@ -148,1 +148,1 @@\n-  EXPECT_EQ(il.find(404), (int* )NULL);\n+  EXPECT_EQ(il.find(404), (int* )nullptr);\n@@ -192,1 +192,1 @@\n-  ASSERT_TRUE(node != NULL) << \"4 is in the list\";\n+  ASSERT_TRUE(node != nullptr) << \"4 is in the list\";\n","filename":"test\/hotspot\/gtest\/utilities\/test_linkedlist.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,2 +85,2 @@\n-  ASSERT_TRUE(stack.pop() == NULL);\n-  ASSERT_TRUE(stack.top() == NULL);\n+  ASSERT_TRUE(stack.pop() == nullptr);\n+  ASSERT_TRUE(stack.top() == nullptr);\n@@ -104,1 +104,1 @@\n-    ASSERT_TRUE(e != NULL);\n+    ASSERT_TRUE(e != nullptr);\n@@ -110,1 +110,1 @@\n-  ASSERT_TRUE(stack.pop() == NULL);\n+  ASSERT_TRUE(stack.pop() == nullptr);\n@@ -116,1 +116,1 @@\n-  ASSERT_TRUE(other_stack.pop() == NULL);\n+  ASSERT_TRUE(other_stack.pop() == nullptr);\n@@ -118,2 +118,2 @@\n-  ASSERT_TRUE(other_stack.top() == NULL);\n-  ASSERT_TRUE(other_stack.pop() == NULL);\n+  ASSERT_TRUE(other_stack.top() == nullptr);\n+  ASSERT_TRUE(other_stack.pop() == nullptr);\n@@ -125,2 +125,2 @@\n-  ASSERT_TRUE(stack.pop() == NULL);\n-  ASSERT_TRUE(stack.top() == NULL);\n+  ASSERT_TRUE(stack.pop() == nullptr);\n+  ASSERT_TRUE(stack.top() == nullptr);\n@@ -132,1 +132,1 @@\n-    ASSERT_TRUE(e != NULL);\n+    ASSERT_TRUE(e != nullptr);\n@@ -137,1 +137,1 @@\n-  ASSERT_TRUE(other_stack.pop() == NULL);\n+  ASSERT_TRUE(other_stack.pop() == nullptr);\n@@ -144,2 +144,2 @@\n-  ASSERT_TRUE(other_stack.top() == NULL);\n-  ASSERT_TRUE(other_stack.pop() == NULL);\n+  ASSERT_TRUE(other_stack.top() == nullptr);\n+  ASSERT_TRUE(other_stack.pop() == nullptr);\n@@ -155,1 +155,1 @@\n-    ASSERT_TRUE(e != NULL);\n+    ASSERT_TRUE(e != nullptr);\n@@ -160,1 +160,1 @@\n-  ASSERT_TRUE(other_stack.pop() == NULL);\n+  ASSERT_TRUE(other_stack.pop() == nullptr);\n@@ -165,1 +165,1 @@\n-  ASSERT_TRUE(stack1.pop() == NULL);\n+  ASSERT_TRUE(stack1.pop() == nullptr);\n@@ -175,1 +175,1 @@\n-    if (e0 == NULL) break;\n+    if (e0 == nullptr) break;\n@@ -185,1 +185,1 @@\n-    ASSERT_TRUE(e != NULL);\n+    ASSERT_TRUE(e != nullptr);\n@@ -190,1 +190,1 @@\n-    ASSERT_TRUE(e1 != NULL);\n+    ASSERT_TRUE(e1 != nullptr);\n@@ -198,2 +198,2 @@\n-  ASSERT_TRUE(stack.pop() == NULL);\n-  ASSERT_TRUE(stack1.pop() == NULL);\n+  ASSERT_TRUE(stack.pop() == nullptr);\n+  ASSERT_TRUE(stack1.pop() == nullptr);\n@@ -232,1 +232,1 @@\n-      if (e != NULL) {\n+      if (e != nullptr) {\n@@ -303,1 +303,1 @@\n-  while (final_stack.pop() != NULL) {}\n+  while (final_stack.pop() != nullptr) {}\n","filename":"test\/hotspot\/gtest\/utilities\/test_lockFreeStack.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  MyMetaData() : _a(NULL), _b(NULL) {}\n+  MyMetaData() : _a(nullptr), _b(nullptr) {}\n@@ -67,1 +67,1 @@\n-      _visited[i] = NULL;\n+      _visited[i] = nullptr;\n@@ -95,1 +95,1 @@\n-    EXPECT_TRUE(array->at(i) == NULL) << \"should be initialized to null\";\n+    EXPECT_TRUE(array->at(i) == nullptr) << \"should be initialized to null\";\n@@ -120,2 +120,2 @@\n-    EXPECT_TRUE(array->at(i)._a == NULL) << \"should be initialized to null\";\n-    EXPECT_TRUE(array->at(i)._b == NULL) << \"should be initialized to null\";\n+    EXPECT_TRUE(array->at(i)._a == nullptr) << \"should be initialized to null\";\n+    EXPECT_TRUE(array->at(i)._b == nullptr) << \"should be initialized to null\";\n","filename":"test\/hotspot\/gtest\/utilities\/test_metaspaceClosure.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-  ASSERT_TRUE(queue->pop() == NULL);\n+  ASSERT_TRUE(queue->pop() == nullptr);\n@@ -100,1 +100,1 @@\n-    ASSERT_TRUE(e != NULL);\n+    ASSERT_TRUE(e != nullptr);\n@@ -106,1 +106,1 @@\n-  ASSERT_TRUE(queue.pop() == NULL);\n+  ASSERT_TRUE(queue.pop() == nullptr);\n@@ -114,1 +114,1 @@\n-  ASSERT_TRUE(other_queue.pop() == NULL);\n+  ASSERT_TRUE(other_queue.pop() == nullptr);\n@@ -122,1 +122,1 @@\n-  ASSERT_TRUE(queue.pop() == NULL);\n+  ASSERT_TRUE(queue.pop() == nullptr);\n@@ -127,1 +127,1 @@\n-    ASSERT_TRUE(e != NULL);\n+    ASSERT_TRUE(e != nullptr);\n@@ -132,1 +132,1 @@\n-  ASSERT_TRUE(other_queue.pop() == NULL);\n+  ASSERT_TRUE(other_queue.pop() == nullptr);\n@@ -137,1 +137,1 @@\n-  ASSERT_TRUE(queue1.pop() == NULL);\n+  ASSERT_TRUE(queue1.pop() == nullptr);\n@@ -145,2 +145,2 @@\n-  ASSERT_TRUE(e0 != NULL);\n-  ASSERT_TRUE(e1 != NULL);\n+  ASSERT_TRUE(e0 != nullptr);\n+  ASSERT_TRUE(e1 != nullptr);\n@@ -162,1 +162,1 @@\n-    ASSERT_TRUE(e != NULL);\n+    ASSERT_TRUE(e != nullptr);\n@@ -167,1 +167,1 @@\n-    ASSERT_TRUE(e1 != NULL);\n+    ASSERT_TRUE(e1 != nullptr);\n@@ -175,2 +175,2 @@\n-  ASSERT_TRUE(queue.pop() == NULL);\n-  ASSERT_TRUE(queue1.pop() == NULL);\n+  ASSERT_TRUE(queue.pop() == nullptr);\n+  ASSERT_TRUE(queue1.pop() == nullptr);\n@@ -209,1 +209,1 @@\n-      if (e != NULL) {\n+      if (e != nullptr) {\n@@ -281,1 +281,1 @@\n-  while (final_queue.pop() != NULL) {}\n+  while (final_queue.pop() != nullptr) {}\n","filename":"test\/hotspot\/gtest\/utilities\/test_nonblockingQueue.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,2 @@\n-\/\/ NOTE: This is a little weird. NULL is not treated any special: ObjectBitSet will happily\n-\/\/ allocate a fragement for the memory range starting at 0 and mark the first bit when passing NULL.\n+\/\/ NOTE: This is a little weird. nullptr is not treated any special: ObjectBitSet will happily\n+\/\/ allocate a fragement for the memory range starting at 0 and mark the first bit when passing nullptr.\n@@ -41,3 +41,3 @@\n-  ASSERT_FALSE(obs.is_marked((oop)NULL));\n-  obs.mark_obj((oop) NULL);\n-  ASSERT_TRUE(obs.is_marked((oop)NULL));\n+  ASSERT_FALSE(obs.is_marked((oop)nullptr));\n+  obs.mark_obj((oop) nullptr);\n+  ASSERT_TRUE(obs.is_marked((oop)nullptr));\n","filename":"test\/hotspot\/gtest\/utilities\/test_objectBitSet.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,2 +84,2 @@\n-    int* test_array = NULL;\n-    int* expected_array = NULL;\n+    int* test_array = nullptr;\n+    int* expected_array = nullptr;\n","filename":"test\/hotspot\/gtest\/utilities\/test_quicksort.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,2 +46,2 @@\n-TEST_VM_ASSERT_MSG(vmErrorTest, assert1, \"assert.str == NULL. failed: expected null\") {\n-  vmassert(str == NULL, \"expected null\");\n+TEST_VM_ASSERT_MSG(vmErrorTest, assert1, \"assert.str == nullptr. failed: expected null\") {\n+  vmassert(str == nullptr, \"expected null\");\n@@ -55,2 +55,2 @@\n-TEST_VM_ASSERT_MSG(vmErrorTest, guarantee1, \"guarantee.str == NULL. failed: expected null\") {\n-  guarantee(str == NULL, \"expected null\");\n+TEST_VM_ASSERT_MSG(vmErrorTest, guarantee1, \"guarantee.str == nullptr. failed: expected null\") {\n+  guarantee(str == nullptr, \"expected null\");\n","filename":"test\/hotspot\/gtest\/utilities\/test_vmerror.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -461,0 +461,1 @@\n+java\/awt\/Dialog\/ChoiceModalDialogTest.java 8161475 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6213128\n+ * @key headful\n+ * @summary Tests that choice is releasing input capture when a modal\n+ *          dialog is shown\n+ * @run main ChoiceModalDialogTest\n+ *\/\n+\n+import java.awt.Choice;\n+import java.awt.Dialog;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Robot;\n+import java.awt.TextField;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyAdapter;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+public class ChoiceModalDialogTest {\n+    static Frame f;\n+    static Dialog d;\n+    static volatile boolean keyOK;\n+    static volatile boolean mouseOK;\n+    static TextField tf;\n+    static Choice c;\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot r;\n+        try {\n+            r = new Robot();\n+            r.setAutoDelay(100);\n+            EventQueue.invokeAndWait(() -> {\n+                f = new Frame(\"Frame\");\n+                c = new Choice();\n+                f.setBounds(100, 300, 300, 200);\n+                f.setLayout(new FlowLayout());\n+                tf = new TextField(3);\n+                f.add(tf);\n+\n+                c.add(\"1\");\n+                c.add(\"2\");\n+                c.add(\"3\");\n+                c.add(\"4\");\n+                f.add(c);\n+\n+                tf.addFocusListener(new FocusAdapter() {\n+                    public void focusLost(FocusEvent ev) {\n+                        d = new Dialog(f, \"Dialog\", true);\n+                        d.setBounds(300, 300, 200, 150);\n+                        d.addKeyListener(new KeyAdapter() {\n+                            public void keyPressed(KeyEvent ev) {\n+                                keyOK = true;\n+                            }\n+                        });\n+                        d.addMouseListener(new MouseAdapter() {\n+                            public void mousePressed(MouseEvent ev) {\n+                                mouseOK = true;\n+                            }\n+                        });\n+                        d.setVisible(true);\n+                    }\n+                });\n+\n+                f.setVisible(true);\n+                f.toFront();\n+            });\n+            r.waitForIdle();\n+            r.delay(1000);\n+            EventQueue.invokeAndWait(() -> {\n+                r.mouseMove(tf.getLocationOnScreen().x + tf.getSize().width \/ 2,\n+                        tf.getLocationOnScreen().y + tf.getSize().height \/ 2);\n+            });\n+            r.waitForIdle();\n+            r.delay(500);\n+            EventQueue.invokeAndWait(() -> {\n+                r.mouseMove(c.getLocationOnScreen().x + c.getSize().width - 4,\n+                        c.getLocationOnScreen().y + c.getSize().height \/ 2);\n+                r.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                r.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            });\n+            r.waitForIdle();\n+            r.delay(500);\n+            EventQueue.invokeAndWait(() -> {\n+                r.mouseMove(d.getLocationOnScreen().x + d.getSize().width \/ 2,\n+                        d.getLocationOnScreen().y + d.getSize().height \/ 2);\n+                r.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                r.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+                r.keyPress(KeyEvent.VK_A);\n+                r.keyRelease(KeyEvent.VK_A);\n+            });\n+            r.waitForIdle();\n+            r.delay(500);\n+            if (!mouseOK) {\n+                throw new RuntimeException(\"Test Failed due to Mouse release failure!\");\n+            }\n+            if (!keyOK) {\n+                throw new RuntimeException(\"Test Failed due to Key release failure!\");\n+            }\n+            System.out.println(\"Test Passed!\");\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (d != null) {\n+                    d.dispose();\n+                }\n+                if (f != null) {\n+                    f.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/ChoiceModalDialogTest.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4255230 4191946\n+ * @summary Tests to verify Dialog inherits background from its owner\n+ * @requires (os.family == \"windows\")\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual DialogBackgroundTest\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Dialog;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.Menu;\n+import java.awt.MenuBar;\n+import java.awt.MenuItem;\n+import java.awt.TextField;\n+import java.awt.Window;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+\n+public class DialogBackgroundTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                Perform the following steps:\n+                1) Select \"New Frame\" from the \"File\" menu of the\n+                   \"TreeCopy Frame #1\" frame.\n+                2) Select \"Configure\" from the \"File\" menu in the\n+                   *new* frame.\n+                   If label text \"This is a label:\" in the appeared\n+                   \"Configuration Dialog\" dialog has a grey background\n+                   test PASSES, otherwise it FAILS\n+                   \"\"\";\n+        TreeCopy treeCopy = new TreeCopy(++TreeCopy.windowCount, null);\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(treeCopy)\n+                .logArea(8)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n+\n+class TreeCopy extends Frame implements ActionListener {\n+    TextField tfRoot;\n+    ConfigDialog configDlg;\n+    MenuItem miConfigure = new MenuItem(\"Configure...\");\n+    MenuItem miNewWindow = new MenuItem(\"New Frame\");\n+    static int windowCount = 0;\n+    Window parent;\n+\n+    public TreeCopy(int windowNum, Window myParent) {\n+        super();\n+        setTitle(\"TreeCopy Frame #\" + windowNum);\n+        MenuBar mb = new MenuBar();\n+        Menu m = new Menu(\"File\");\n+        configDlg = new ConfigDialog(this);\n+        parent = myParent;\n+\n+        m.add(miConfigure);\n+        m.add(miNewWindow);\n+        miConfigure.addActionListener(this);\n+        miNewWindow.addActionListener(this);\n+        mb.add(m);\n+        setMenuBar(mb);\n+        m.addActionListener(this);\n+\n+        tfRoot = new TextField();\n+        tfRoot.setEditable(false);\n+        add(tfRoot);\n+\n+        addWindowListener(new WindowAdapter() {\n+            public void windowClosing(WindowEvent we) {\n+                dispose();\n+            }\n+        });\n+\n+        setSize(200, 100);\n+        setLocationRelativeTo(parent);\n+    }\n+\n+    public void actionPerformed(ActionEvent ae) {\n+        Object source = ae.getSource();\n+\n+        if (source == miConfigure) {\n+            configDlg.setVisible(true);\n+            if (configDlg.getBackground() != configDlg.labelColor)\n+                PassFailJFrame.log(\"FAIL: Test failed!!!\");\n+        } else if (source == miNewWindow) {\n+            new TreeCopy(++windowCount, this).setVisible(true);\n+        }\n+    }\n+}\n+\n+class ConfigDialog extends Dialog implements ActionListener {\n+    public Button okButton;\n+    public Button cancelButton;\n+    public Label l2;\n+    public Color labelColor;\n+\n+    public ConfigDialog(Frame parent) {\n+        super(parent, \"Configuration Dialog\");\n+        okButton = new Button(\"OK\");\n+        cancelButton = new Button(\"Cancel\");\n+        l2 = new Label(\"This is a label:\");\n+\n+        setLayout(new FlowLayout());\n+        add(l2);\n+        add(okButton);\n+        add(cancelButton);\n+\n+        okButton.addActionListener(this);\n+        cancelButton.addActionListener(this);\n+\n+        pack();\n+        labelColor = l2.getBackground();\n+    }\n+\n+    public void actionPerformed(ActionEvent ae) {\n+        dispose();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/DialogBackgroundTest.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4232374\n+ * @summary Tests that dismissing a modal dialog does not enable\n+ *          disabled components\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual EnabledResetTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Dialog;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Window;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+\n+public class EnabledResetTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. Press \"Create Child\" twice to create three windows\n+                   Verify that the parent windows are disabled\n+                2. Press \"Create Modal Dialog\"\n+                   Verify that the parent windows are disabled\n+                3. Press \"enable\"\n+                   Verify that no windows accept mouse events\n+                4. Press \"ok\"\n+                   Verify that the first window is still disabled\n+                   If all the verifications are done, then test is\n+                   PASSED, else test fails.\n+                   \"\"\";\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(new ChildDialog(1, null))\n+                .build()\n+                .awaitAndCheck();\n+    }\n+}\n+\n+class ChildDialog extends Frame implements ActionListener {\n+    Window parent;\n+    int id;\n+    Button b, c, d;\n+\n+    public ChildDialog(int frameNumber, Window myParent) {\n+        super();\n+        id = frameNumber;\n+        parent = myParent;\n+\n+        setTitle(\"Frame Number \" + id);\n+\n+        b = new Button(\"Dismiss me\");\n+        c = new Button(\"Create Child\");\n+        d = new Button(\"Create Modal Dialog\");\n+\n+        setLayout(new BorderLayout());\n+        add(\"North\", c);\n+        add(\"Center\", d);\n+        add(\"South\", b);\n+        pack();\n+\n+        b.addActionListener(this);\n+        c.addActionListener(this);\n+        d.addActionListener(this);\n+    }\n+\n+    public void setVisible(boolean b) {\n+        if (parent != null) {\n+            if (b) {\n+                parent.setEnabled(false);\n+            } else {\n+                parent.setEnabled(true);\n+                parent.requestFocus();\n+            }\n+        }\n+\n+        super.setVisible(b);\n+    }\n+\n+    public void dispose() {\n+        if (parent != null) {\n+            parent.setEnabled(true);\n+            parent.requestFocus();\n+        }\n+        super.dispose();\n+    }\n+\n+\n+    public void actionPerformed(ActionEvent evt) {\n+        if (evt.getSource() == c) {\n+            (new ChildDialog(id + 1, this)).setVisible(true);\n+        } else if (evt.getSource() == d) {\n+            Dialog D = new Dialog(this, \"Modal Dialog \");\n+            D.setLayout(new FlowLayout());\n+            Button b = new Button(\"ok\");\n+            Button e = new Button(\"enable\");\n+            D.add(b);\n+            D.add(e);\n+            D.setModal(true);\n+            D.pack();\n+            b.addActionListener(this);\n+            e.addActionListener(this);\n+            D.setVisible(true);\n+        } else if (evt.getSource() == b) {\n+            dispose();\n+        } else if (evt.getSource() instanceof Button) {\n+            if (\"ok\".equals(evt.getActionCommand())) {\n+                Button target = (Button) evt.getSource();\n+                Window w = (Window) target.getParent();\n+                w.dispose();\n+            }\n+            if (\"enable\".equals(evt.getActionCommand())) {\n+                parent.setEnabled(true);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/EnabledResetTest.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4414105\n+ * @summary Tests that FileDialog returns null when cancelled\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual FileDialogGetFileTest\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.FileDialog;\n+import java.awt.Frame;\n+\n+public class FileDialogGetFileTest {\n+    static FileDialog fd;\n+    static Frame frame;\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                1. Open FileDialog from \"Show File Dialog\" button.\n+                2. Click cancel button without selecting any file\/folder.\n+                3. If FileDialog.getFile return null then test PASSES,\n+                   else test FAILS automatically.\n+                   \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(initialize())\n+                .logArea(4)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Frame initialize() {\n+        frame = new Frame(\"FileDialog GetFile test\");\n+        fd = new FileDialog(frame);\n+        fd.setFile(\"FileDialogGetFileTest.html\");\n+        fd.setBounds(100, 100, 400, 400);\n+        Button showBtn = new Button(\"Show File Dialog\");\n+        frame.add(showBtn);\n+        frame.pack();\n+        showBtn.addActionListener(e -> {\n+            fd.setVisible(true);\n+            if (fd.getFile() != null) {\n+                PassFailJFrame.forceFail(\"Test failed: FileDialog returned non-null value\");\n+            } else {\n+                PassFailJFrame.log(\"Test Passed!\");\n+            }\n+        });\n+        return frame;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Dialog\/FileDialogGetFileTest.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"}]}