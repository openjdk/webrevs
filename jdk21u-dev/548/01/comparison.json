{"files":[{"patch":"@@ -602,1 +602,1 @@\n-  \/\/ these classes are unloading.  Must be called\n+  \/\/ these classes are unloading.  This must be called\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,3 +189,0 @@\n-  void set_unloading_next(ClassLoaderData* unloading_next);\n-  ClassLoaderData* unloading_next() const;\n-\n@@ -193,0 +190,2 @@\n+\n+public:\n@@ -195,0 +194,5 @@\n+  void set_unloading_next(ClassLoaderData* unloading_next);\n+  ClassLoaderData* unloading_next() const;\n+  void unload();\n+\n+private:\n@@ -206,0 +210,2 @@\n+  void classes_do(void f(Klass* const));\n+\n@@ -207,1 +213,0 @@\n-  void unload();\n@@ -210,1 +215,0 @@\n-  void classes_do(void f(Klass* const));\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -127,1 +128,0 @@\n-ClassLoaderData* ClassLoaderDataGraph::_unloading_head = nullptr;\n@@ -345,5 +345,1 @@\n-  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n-  for (ClassLoaderData* cld = _unloading_head; cld != nullptr; cld = cld->unloading_next()) {\n-    assert(cld->is_unloading(), \"invariant\");\n-    cld->classes_do(f);\n-  }\n+  ClassUnloadingContext::context()->classes_unloading_do(f);\n@@ -428,1 +424,2 @@\n-      data->unload();\n+\n+      ClassUnloadingContext::context()->register_unloading_class_loader_data(data);\n@@ -438,2 +435,0 @@\n-      data->set_unloading_next(_unloading_head);\n-      _unloading_head = data;\n@@ -472,10 +467,3 @@\n-  ClassLoaderData* list = _unloading_head;\n-  _unloading_head = nullptr;\n-  ClassLoaderData* next = list;\n-  bool classes_unloaded = false;\n-  while (next != nullptr) {\n-    ClassLoaderData* purge_me = next;\n-    next = purge_me->unloading_next();\n-    delete purge_me;\n-    classes_unloaded = true;\n-  }\n+  ClassUnloadingContext::context()->purge_class_loader_data();\n+\n+  bool classes_unloaded = ClassUnloadingContext::context()->has_unloaded_classes();\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":7,"deletions":19,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-  \/\/ All unlinked CLDs\n-  static ClassLoaderData* _unloading_head;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-  blob->flush();\n+  blob->purge(true \/* free_code_cache_data *\/, true \/* unregister_nmethod *\/);\n@@ -176,1 +176,1 @@\n-void CodeBlob::flush() {\n+void CodeBlob::purge(bool free_code_cache_data, bool unregister_nmethod) {\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-  virtual void flush();\n+  virtual void purge(bool free_code_cache_data, bool unregister_nmethod);\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -609,1 +610,1 @@\n-  get_code_heap(cb)->deallocate(cb);\n+  heap->deallocate(cb);\n@@ -973,30 +974,2 @@\n-\/\/ Register an is_unloading nmethod to be flushed after unlinking\n-void CodeCache::register_unlinked(nmethod* nm) {\n-  assert(nm->unlinked_next() == nullptr, \"Only register for unloading once\");\n-  for (;;) {\n-    \/\/ Only need acquire when reading the head, when the next\n-    \/\/ pointer is walked, which it is not here.\n-    nmethod* head = Atomic::load(&_unlinked_head);\n-    nmethod* next = head != nullptr ? head : nm; \/\/ Self looped means end of list\n-    nm->set_unlinked_next(next);\n-    if (Atomic::cmpxchg(&_unlinked_head, head, nm) == head) {\n-      break;\n-    }\n-  }\n-}\n-\n-\/\/ Flush all the nmethods the GC unlinked\n-void CodeCache::flush_unlinked_nmethods() {\n-  nmethod* nm = _unlinked_head;\n-  _unlinked_head = nullptr;\n-  size_t freed_memory = 0;\n-  while (nm != nullptr) {\n-    nmethod* next = nm->unlinked_next();\n-    freed_memory += nm->total_size();\n-    nm->flush();\n-    if (next == nm) {\n-      \/\/ Self looped means end of list\n-      break;\n-    }\n-    nm = next;\n-  }\n+\/\/ Restart compiler if possible and required..\n+void CodeCache::maybe_restart_compiler(size_t freed_memory) {\n@@ -1016,1 +989,0 @@\n-nmethod* volatile CodeCache::_unlinked_head = nullptr;\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":4,"deletions":32,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -109,1 +109,0 @@\n-  static nmethod* volatile _unlinked_head;\n@@ -216,2 +215,1 @@\n-  static void flush_unlinked_nmethods();\n-  static void register_unlinked(nmethod* nm);\n+  static void maybe_restart_compiler(size_t freed_memory);\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-  virtual void flush() = 0;\n+  virtual void purge(bool free_code_cache_data, bool unregister_nmethod) = 0;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -642,1 +643,1 @@\n-  _unlinked_next(nullptr),\n+  _is_unlinked(false),\n@@ -786,1 +787,1 @@\n-  _unlinked_next(nullptr),\n+  _is_unlinked(false),\n@@ -1409,1 +1410,1 @@\n-  if (_unlinked_next != nullptr) {\n+  if (_is_unlinked) {\n@@ -1443,1 +1444,1 @@\n-  CodeCache::register_unlinked(this);\n+  ClassUnloadingContext::context()->register_unlinked_nmethod(this);\n@@ -1446,1 +1447,3 @@\n-void nmethod::flush() {\n+void nmethod::purge(bool free_code_cache_data, bool unregister_nmethod) {\n+  assert(!free_code_cache_data, \"must only call not freeing code cache data\");\n+\n@@ -1466,1 +1469,4 @@\n-  Universe::heap()->unregister_nmethod(this);\n+  if (unregister_nmethod) {\n+    Universe::heap()->unregister_nmethod(this);\n+  }\n+\n@@ -1469,2 +1475,1 @@\n-  CodeBlob::flush();\n-  CodeCache::free(this);\n+  CodeBlob::purge(free_code_cache_data, unregister_nmethod);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-  nmethod* _unlinked_next;\n+  bool _is_unlinked;\n@@ -444,2 +444,2 @@\n-  nmethod* unlinked_next() const                  { return _unlinked_next; }\n-  void set_unlinked_next(nmethod* next)           { _unlinked_next = next; }\n+  bool is_unlinked() const                        { return _is_unlinked; }\n+  void set_is_unlinked()                          { assert(!_is_unlinked, \"already unlinked\"); _is_unlinked = true; }\n@@ -525,1 +525,1 @@\n-  void flush();\n+  void purge(bool free_code_cache_data, bool unregister_nmethod);\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1778,1 +1778,1 @@\n-    blob->flush();\n+    blob->purge(true \/* free_code_cache_data *\/, true \/* unregister_nmethod *\/);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -192,0 +192,9 @@\n+  \/\/ Removes dead\/unlinked entries.\n+  void bulk_remove() {\n+    auto delete_check = [&] (nmethod** value) {\n+      return (*value)->is_unlinked();\n+    };\n+\n+    clean(delete_check);\n+  }\n+\n@@ -260,0 +269,5 @@\n+void G1CodeRootSet::bulk_remove() {\n+  assert(!_is_iterating, \"should not mutate while iterating the table\");\n+  _table->bulk_remove();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeRootSet.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+  void bulk_remove();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeRootSet.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"classfile\/stringTable.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -77,0 +77,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -858,4 +859,0 @@\n-  \/\/ Delete metaspaces for unloaded class loaders and clean up loader_data graph\n-  ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n-  DEBUG_ONLY(MetaspaceUtils::verify();)\n-\n@@ -2599,0 +2596,59 @@\n+void G1CollectedHeap::unload_classes_and_code(const char* description, BoolObjectClosure* is_alive, GCTimer* timer) {\n+  GCTraceTime(Debug, gc, phases) debug(description, timer);\n+\n+  ClassUnloadingContext ctx(workers()->active_workers(),\n+                            false \/* unregister_nmethods_during_purge *\/,\n+                            false \/* lock_codeblob_free_separately *\/);\n+  {\n+    CodeCache::UnlinkingScope scope(is_alive);\n+    bool unloading_occurred = SystemDictionary::do_unloading(timer);\n+    GCTraceTime(Debug, gc, phases) t(\"G1 Complete Cleaning\", timer);\n+    complete_cleaning(unloading_occurred);\n+  }\n+  {\n+    GCTraceTime(Debug, gc, phases) t(\"Purge Unlinked NMethods\", timer);\n+    ctx.purge_nmethods();\n+  }\n+  {\n+    GCTraceTime(Debug, gc, phases) ur(\"Unregister NMethods\", timer);\n+    G1CollectedHeap::heap()->bulk_unregister_nmethods();\n+  }\n+  {\n+    GCTraceTime(Debug, gc, phases) t(\"Free Code Blobs\", timer);\n+    ctx.free_code_blobs();\n+  }\n+  {\n+    GCTraceTime(Debug, gc, phases) t(\"Purge Class Loader Data\", timer);\n+    ClassLoaderDataGraph::purge(true \/* at_safepoint *\/);\n+    DEBUG_ONLY(MetaspaceUtils::verify();)\n+  }\n+}\n+\n+class G1BulkUnregisterNMethodTask : public WorkerTask {\n+  HeapRegionClaimer _hrclaimer;\n+\n+  class UnregisterNMethodsHeapRegionClosure : public HeapRegionClosure {\n+  public:\n+\n+    bool do_heap_region(HeapRegion* hr) {\n+      hr->rem_set()->bulk_remove_code_roots();\n+      return false;\n+    }\n+  } _cl;\n+\n+public:\n+  G1BulkUnregisterNMethodTask(uint num_workers)\n+  : WorkerTask(\"G1 Remove Unlinked NMethods From Code Root Set Task\"),\n+    _hrclaimer(num_workers) { }\n+\n+  void work(uint worker_id) {\n+    G1CollectedHeap::heap()->heap_region_par_iterate_from_worker_offset(&_cl, &_hrclaimer, worker_id);\n+  }\n+};\n+\n+void G1CollectedHeap::bulk_unregister_nmethods() {\n+  uint num_workers = workers()->active_workers();\n+  G1BulkUnregisterNMethodTask t(num_workers);\n+  workers()->run_task(&t);\n+}\n+\n@@ -3018,25 +3074,0 @@\n-class UnregisterNMethodOopClosure: public OopClosure {\n-  G1CollectedHeap* _g1h;\n-  nmethod* _nm;\n-\n-public:\n-  UnregisterNMethodOopClosure(G1CollectedHeap* g1h, nmethod* nm) :\n-    _g1h(g1h), _nm(nm) {}\n-\n-  void do_oop(oop* p) {\n-    oop heap_oop = RawAccess<>::oop_load(p);\n-    if (!CompressedOops::is_null(heap_oop)) {\n-      oop obj = CompressedOops::decode_not_null(heap_oop);\n-      HeapRegion* hr = _g1h->heap_region_containing(obj);\n-      assert(!hr->is_continues_humongous(),\n-             \"trying to remove code root \" PTR_FORMAT \" in continuation of humongous region \" HR_FORMAT\n-             \" starting at \" HR_FORMAT,\n-             p2i(_nm), HR_FORMAT_PARAMS(hr), HR_FORMAT_PARAMS(hr->humongous_start_region()));\n-\n-      hr->remove_code_root(_nm);\n-    }\n-  }\n-\n-  void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n-};\n-\n@@ -3050,3 +3081,2 @@\n-  guarantee(nm != nullptr, \"sanity\");\n-  UnregisterNMethodOopClosure reg_cl(this, nm);\n-  nm->oops_do(&reg_cl, true);\n+  \/\/ We always unregister nmethods in bulk during code unloading only.\n+  ShouldNotReachHere();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":63,"deletions":33,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -1268,0 +1268,4 @@\n+  void unload_classes_and_code(const char* description, BoolObjectClosure* cl, GCTimer* timer);\n+\n+  void bulk_unregister_nmethods();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"code\/codeCache.hpp\"\n@@ -1248,0 +1246,6 @@\n+    \/\/ Unload Klasses, String, Code Cache, etc.\n+    if (ClassUnloadingWithConcurrentMark) {\n+      G1CMIsAliveClosure is_alive(_g1h);\n+      _g1h->unload_classes_and_code(\"Class Unloading\", &is_alive, _gc_timer_cm);\n+    }\n+\n@@ -1285,6 +1289,0 @@\n-    \/\/ Clean out dead classes\n-    if (ClassUnloadingWithConcurrentMark) {\n-      GCTraceTime(Debug, gc, phases) debug(\"Purge Metaspace\", _gc_timer_cm);\n-      ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n-    }\n-\n@@ -1615,3 +1613,0 @@\n-  \/\/ Is alive closure.\n-  G1CMIsAliveClosure g1_is_alive(_g1h);\n-\n@@ -1674,12 +1669,2 @@\n-    WeakProcessor::weak_oops_do(_g1h->workers(), &g1_is_alive, &do_nothing_cl, 1);\n-  }\n-\n-  \/\/ Unload Klasses, String, Code Cache, etc.\n-  if (ClassUnloadingWithConcurrentMark) {\n-    GCTraceTime(Debug, gc, phases) debug(\"Class Unloading\", _gc_timer_cm);\n-    {\n-      CodeCache::UnlinkingScope scope(&g1_is_alive);\n-      bool unloading_occurred = SystemDictionary::do_unloading(_gc_timer_cm);\n-      _g1h->complete_cleaning(unloading_occurred);\n-    }\n-    CodeCache::flush_unlinked_nmethods();\n+    G1CMIsAliveClosure is_alive(_g1h);\n+    WeakProcessor::weak_oops_do(_g1h->workers(), &is_alive, &do_nothing_cl, 1);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":8,"deletions":23,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -27,3 +27,0 @@\n-#include \"classfile\/systemDictionary.hpp\"\n-#include \"code\/codeCache.hpp\"\n-#include \"compiler\/oopMap.hpp\"\n@@ -44,0 +41,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -322,8 +320,1 @@\n-    GCTraceTime(Debug, gc, phases) debug(\"Phase 1: Class Unloading and Cleanup\", scope()->timer());\n-    {\n-      CodeCache::UnlinkingScope unloading_scope(&_is_alive);\n-      \/\/ Unload classes and purge the SystemDictionary.\n-      bool unloading_occurred = SystemDictionary::do_unloading(scope()->timer());\n-      _heap->complete_cleaning(unloading_occurred);\n-    }\n-    CodeCache::flush_unlinked_nmethods();\n+    _heap->unload_classes_and_code(\"Phase 1: Class Unloading and Cleanup\", &_is_alive, scope()->timer());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -113,0 +113,4 @@\n+void HeapRegionRemSet::bulk_remove_code_roots() {\n+  _code_roots.bulk_remove();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -154,0 +154,1 @@\n+  void bulk_remove_code_roots();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -530,0 +530,8 @@\n+void ParallelScavengeHeap::prune_scavengable_nmethods() {\n+  ScavengableNMethods::prune_nmethods_not_into_young();\n+}\n+\n+void ParallelScavengeHeap::prune_unlinked_nmethods() {\n+  ScavengableNMethods::prune_unlinked_nmethods();\n+}\n+\n@@ -861,4 +869,0 @@\n-void ParallelScavengeHeap::prune_scavengable_nmethods() {\n-  ScavengableNMethods::prune_nmethods();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  void prune_unlinked_nmethods();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -1027,3 +1028,6 @@\n-  \/\/ Delete metaspaces for unloaded class loaders and clean up loader_data graph\n-  ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n-  DEBUG_ONLY(MetaspaceUtils::verify();)\n+  {\n+    \/\/ Delete metaspaces for unloaded class loaders and clean up loader_data graph\n+    GCTraceTime(Debug, gc, phases) t(\"Purge Class Loader Data\", gc_timer());\n+    ClassLoaderDataGraph::purge(true \/* at_safepoint *\/);\n+    DEBUG_ONLY(MetaspaceUtils::verify();)\n+  }\n@@ -1767,0 +1771,4 @@\n+    ClassUnloadingContext ctx(1 \/* num_nmethod_unlink_workers *\/,\n+                              false \/* unregister_nmethods_during_purge *\/,\n+                              false \/* lock_codeblob_free_separately *\/);\n+\n@@ -2056,0 +2064,2 @@\n+    ClassUnloadingContext* ctx = ClassUnloadingContext::context();\n+\n@@ -2067,2 +2077,13 @@\n-    \/\/ Release unloaded nmethods's memory.\n-    CodeCache::flush_unlinked_nmethods();\n+    {\n+      GCTraceTime(Debug, gc, phases) t(\"Purge Unlinked NMethods\", gc_timer());\n+      \/\/ Release unloaded nmethod's memory.\n+      ctx->purge_nmethods();\n+    }\n+    {\n+      GCTraceTime(Debug, gc, phases) ur(\"Unregister NMethods\", &_gc_timer);\n+      ParallelScavengeHeap::heap()->prune_unlinked_nmethods();\n+    }\n+    {\n+      GCTraceTime(Debug, gc, phases) t(\"Free Code Blobs\", gc_timer());\n+      ctx->free_code_blobs();\n+    }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -199,0 +200,2 @@\n+    ClassUnloadingContext* ctx = ClassUnloadingContext::context();\n+\n@@ -210,2 +213,13 @@\n-    \/\/ Release unloaded nmethod's memory.\n-    CodeCache::flush_unlinked_nmethods();\n+    {\n+      GCTraceTime(Debug, gc, phases) t(\"Purge Unlinked NMethods\", gc_timer());\n+      \/\/ Release unloaded nmethod's memory.\n+      ctx->purge_nmethods();\n+    }\n+    {\n+      GCTraceTime(Debug, gc, phases) ur(\"Unregister NMethods\", gc_timer());\n+      gch->prune_unlinked_nmethods();\n+    }\n+    {\n+      GCTraceTime(Debug, gc, phases) t(\"Free Code Blobs\", gc_timer());\n+      ctx->free_code_blobs();\n+    }\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/scavengableNMethods.hpp\"\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"classfile\/classLoaderData.inline.hpp\"\n+#include \"code\/nmethod.hpp\"\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+ClassUnloadingContext* ClassUnloadingContext::_context = nullptr;\n+\n+ClassUnloadingContext::ClassUnloadingContext(uint num_workers,\n+                                             bool unregister_nmethods_during_purge,\n+                                             bool lock_codeblob_free_separately) :\n+  _cld_head(nullptr),\n+  _num_nmethod_unlink_workers(num_workers),\n+  _unlinked_nmethods(nullptr),\n+  _unregister_nmethods_during_purge(unregister_nmethods_during_purge),\n+  _lock_codeblob_free_separately(lock_codeblob_free_separately) {\n+\n+  assert(_context == nullptr, \"context already set\");\n+  _context = this;\n+\n+  assert(num_workers > 0, \"must be\");\n+\n+  _unlinked_nmethods = NEW_C_HEAP_ARRAY(NMethodSet*, num_workers, mtGC);\n+  for (uint i = 0; i < num_workers; ++i) {\n+    _unlinked_nmethods[i] = new NMethodSet();\n+  }\n+}\n+\n+ClassUnloadingContext::~ClassUnloadingContext() {\n+  for (uint i = 0; i < _num_nmethod_unlink_workers; ++i) {\n+    delete _unlinked_nmethods[i];\n+  }\n+  FREE_C_HEAP_ARRAY(NMethodSet*, _unlinked_nmethods);\n+\n+  assert(_context == this, \"context not set correctly\");\n+  _context = nullptr;\n+}\n+\n+bool ClassUnloadingContext::has_unloaded_classes() const {\n+  return _cld_head != nullptr;\n+}\n+\n+void ClassUnloadingContext::register_unloading_class_loader_data(ClassLoaderData* cld) {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+\n+  cld->unload();\n+\n+  cld->set_unloading_next(_cld_head);\n+  _cld_head = cld;\n+}\n+\n+void ClassUnloadingContext::purge_class_loader_data() {\n+  for (ClassLoaderData* cld = _cld_head; cld != nullptr;) {\n+    assert(cld->is_unloading(), \"invariant\");\n+\n+    ClassLoaderData* next = cld->unloading_next();\n+    delete cld;\n+    cld = next;\n+  }\n+}\n+\n+void ClassUnloadingContext::classes_unloading_do(void f(Klass* const)) {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  for (ClassLoaderData* cld = _cld_head; cld != nullptr; cld = cld->unloading_next()) {\n+    assert(cld->is_unloading(), \"invariant\");\n+    cld->classes_do(f);\n+  }\n+}\n+\n+void ClassUnloadingContext::register_unlinked_nmethod(nmethod* nm) {\n+  assert(_context != nullptr, \"no context set\");\n+\n+  assert(!nm->is_unlinked(), \"Only register for unloading once\");\n+  assert(_num_nmethod_unlink_workers == 1 || Thread::current()->is_Worker_thread(), \"must be worker thread if parallel\");\n+\n+  uint worker_id = _num_nmethod_unlink_workers == 1 ? 0 : WorkerThread::worker_id();\n+  assert(worker_id < _num_nmethod_unlink_workers, \"larger than expected worker id %u\", worker_id);\n+\n+  _unlinked_nmethods[worker_id]->append(nm);\n+\n+  nm->set_is_unlinked();\n+}\n+\n+void ClassUnloadingContext::purge_nmethods() {\n+  assert(_context != nullptr, \"no context set\");\n+\n+  size_t freed_memory = 0;\n+\n+  for (uint i = 0; i < _num_nmethod_unlink_workers; ++i) {\n+    NMethodSet* set = _unlinked_nmethods[i];\n+    for (nmethod* nm : *set) {\n+      freed_memory += nm->size();\n+      nm->purge(false \/* free_code_cache_data *\/, _unregister_nmethods_during_purge);\n+    }\n+  }\n+\n+  CodeCache::maybe_restart_compiler(freed_memory);\n+}\n+\n+void ClassUnloadingContext::free_code_blobs() {\n+  assert(_context != nullptr, \"no context set\");\n+\n+  \/\/ Sort nmethods before freeing to benefit from optimizations. If Nmethods were\n+  \/\/ collected in parallel, use a new temporary buffer for the result, otherwise\n+  \/\/ sort in-place.\n+  NMethodSet* nmethod_set = nullptr;\n+\n+  bool is_parallel = _num_nmethod_unlink_workers > 1;\n+\n+  \/\/ Merge all collected nmethods into a huge array.\n+  if (is_parallel) {\n+    int num_nmethods = 0;\n+\n+    for (uint i = 0; i < _num_nmethod_unlink_workers; ++i) {\n+      num_nmethods += _unlinked_nmethods[i]->length();\n+    }\n+    nmethod_set = new NMethodSet(num_nmethods);\n+    for (uint i = 0; i < _num_nmethod_unlink_workers; ++i) {\n+      nmethod_set->appendAll(_unlinked_nmethods[i]);\n+    }\n+  } else {\n+    nmethod_set = _unlinked_nmethods[0];\n+  }\n+\n+  \/\/ Sort by ascending address.\n+  auto sort_nmethods = [] (nmethod** a, nmethod** b) -> int {\n+    uintptr_t u_a = (uintptr_t)*a;\n+    uintptr_t u_b = (uintptr_t)*b;\n+    if (u_a == u_b) return 0;\n+    if (u_a < u_b) return -1;\n+    return 1;\n+  };\n+  nmethod_set->sort(sort_nmethods);\n+\n+  \/\/ And free. Duplicate loop for clarity depending on where we want the locking.\n+  if (_lock_codeblob_free_separately) {\n+    for (nmethod* nm : *nmethod_set) {\n+      MutexLocker ml(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+      CodeCache::free(nm);\n+    }\n+  } else {\n+    MutexLocker ml(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    for (nmethod* nm : *nmethod_set) {\n+      CodeCache::free(nm);\n+    }\n+  }\n+\n+  if (is_parallel) {\n+    delete nmethod_set;\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/classUnloadingContext.cpp","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_CLASSUNLOADINGCONTEXT_HPP\n+#define SHARE_GC_SHARED_CLASSUNLOADINGCONTEXT_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+class ClassLoaderData;\n+class Klass;\n+class nmethod;\n+\n+class ClassUnloadingContext : public CHeapObj<mtGC> {\n+  static ClassUnloadingContext* _context;\n+\n+  ClassLoaderData* volatile _cld_head;\n+\n+  const uint _num_nmethod_unlink_workers;\n+\n+  using NMethodSet = GrowableArrayCHeap<nmethod*, mtGC>;\n+  NMethodSet** _unlinked_nmethods;\n+\n+  bool _unregister_nmethods_during_purge;\n+  bool _lock_codeblob_free_separately;\n+\n+public:\n+  static ClassUnloadingContext* context() { assert(_context != nullptr, \"context not set\"); return _context; }\n+\n+  \/\/ Num_nmethod_unlink_workers configures the maximum numbers of threads unlinking\n+  \/\/     nmethods.\n+  \/\/ unregister_nmethods_during_purge determines whether unloaded nmethods should\n+  \/\/     be unregistered from the garbage collector during purge. If not, ,the caller\n+  \/\/     is responsible to do that later.\n+  \/\/ lock_codeblob_free_separately determines whether freeing the code blobs takes\n+  \/\/     the CodeCache_lock during the whole operation (=false) or per code blob\n+  \/\/     free operation (=true).\n+  ClassUnloadingContext(uint num_nmethod_unlink_workers,\n+                        bool unregister_nmethods_during_purge,\n+                        bool lock_codeblob_free_separately);\n+  ~ClassUnloadingContext();\n+\n+  bool has_unloaded_classes() const;\n+\n+  void register_unloading_class_loader_data(ClassLoaderData* cld);\n+  void purge_class_loader_data();\n+\n+  void classes_unloading_do(void f(Klass* const));\n+\n+  \/\/ Register unloading nmethods, potentially in parallel.\n+  void register_unlinked_nmethod(nmethod* nm);\n+  void purge_nmethods();\n+  void free_code_blobs();\n+\n+  void purge_and_free_nmethods() {\n+    purge_nmethods();\n+    free_code_blobs();\n+  }\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_CLASSUNLOADINGCONTEXT_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/classUnloadingContext.hpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -558,0 +559,4 @@\n+    ClassUnloadingContext ctx(1 \/* num_nmethod_unlink_workers *\/,\n+                              false \/* unregister_nmethods_during_purge *\/,\n+                              false \/* lock_codeblob_free_separately *\/);\n+\n@@ -573,1 +578,1 @@\n-    ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n+    ClassLoaderDataGraph::purge(true \/* at_safepoint *\/);\n@@ -614,1 +619,5 @@\n-  ScavengableNMethods::prune_nmethods();\n+  ScavengableNMethods::prune_nmethods_not_into_young();\n+}\n+\n+void GenCollectedHeap::prune_unlinked_nmethods() {\n+  ScavengableNMethods::prune_unlinked_nmethods();\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -208,0 +208,1 @@\n+  void prune_unlinked_nmethods();\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -62,12 +62,2 @@\n-  assert_locked_or_safepoint(CodeCache_lock);\n-\n-  if (gc_data(nm).on_list()) {\n-    nmethod* prev = nullptr;\n-    for (nmethod* cur = _head; cur != nullptr; cur = gc_data(cur).next()) {\n-      if (cur == nm) {\n-        unlist_nmethod(cur, prev);\n-        return;\n-      }\n-      prev = cur;\n-    }\n-  }\n+  \/\/ All users of this method only unregister in bulk during code unloading.\n+  ShouldNotReachHere();\n@@ -175,1 +165,1 @@\n-void ScavengableNMethods::prune_nmethods() {\n+void ScavengableNMethods::prune_nmethods_not_into_young() {\n@@ -179,0 +169,27 @@\n+void ScavengableNMethods::prune_unlinked_nmethods() {\n+  assert_locked_or_safepoint(CodeCache_lock);\n+\n+  debug_only(mark_on_list_nmethods());\n+\n+  nmethod* prev = nullptr;\n+  nmethod* cur = _head;\n+  while (cur != nullptr) {\n+    ScavengableNMethodsData data = gc_data(cur);\n+    debug_only(data.clear_marked());\n+    assert(data.on_list(), \"else shouldn't be on this list\");\n+\n+    nmethod* const next = data.next();\n+\n+    if (cur->is_unlinked()) {\n+      unlist_nmethod(cur, prev);\n+    } else {\n+      prev = cur;\n+    }\n+\n+    cur = next;\n+  }\n+\n+  \/\/ Check for stray marks.\n+  debug_only(verify_unlisted_nmethods(nullptr));\n+}\n+\n@@ -221,1 +238,1 @@\n-    if (data.on_list())\n+    if (data.on_list()) {\n@@ -223,0 +240,1 @@\n+    }\n@@ -233,1 +251,4 @@\n-    verify_nmethod(nm);\n+    \/\/ Can not verify already unlinked nmethods as they are partially invalid already.\n+    if (!nm->is_unlinked()) {\n+      verify_nmethod(nm);\n+    }\n","filename":"src\/hotspot\/share\/gc\/shared\/scavengableNMethods.cpp","additions":36,"deletions":15,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,2 +49,4 @@\n-  \/\/ Remove nmethods that no longer have scavengable oops.\n-  static void prune_nmethods();\n+  \/\/ Remove nmethods that no longer have oops into young gen.\n+  static void prune_nmethods_not_into_young();\n+  \/\/ Remvoe unlinked (dead) nmethods.\n+  static void prune_unlinked_nmethods();\n","filename":"src\/hotspot\/share\/gc\/shared\/scavengableNMethods.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -238,1 +239,1 @@\n-  CodeCache::flush_unlinked_nmethods();\n+  ClassUnloadingContext::context()->purge_and_free_nmethods();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -1770,0 +1771,4 @@\n+  ClassUnloadingContext ctx(_workers->active_workers(),\n+                            true \/* unregister_nmethods_during_purge *\/,\n+                            false \/* lock_codeblob_free_separately *\/);\n+\n@@ -1787,1 +1792,1 @@\n-    CodeCache::flush_unlinked_nmethods();\n+    ClassUnloadingContext::context()->purge_and_free_nmethods();\n@@ -1794,1 +1799,1 @@\n-    ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n+    ClassLoaderDataGraph::purge(true \/* at_safepoint *\/);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -141,0 +142,4 @@\n+  ClassUnloadingContext ctx(heap->workers()->active_workers(),\n+                            true \/* unregister_nmethods_during_purge *\/,\n+                            true \/* lock_codeblob_free_separately *\/);\n+\n@@ -184,1 +189,1 @@\n-      ClassLoaderDataGraph::purge(\/*at_safepoint*\/false);\n+      ClassLoaderDataGraph::purge(false \/* at_safepoint *\/);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUnload.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -323,0 +324,4 @@\n+  ClassUnloadingContext ctx(_workers.active_workers(),\n+                            true \/* unregister_nmethods_during_purge *\/,\n+                            true \/* lock_codeblob_free_separately *\/);\n+\n","filename":"src\/hotspot\/share\/gc\/x\/xHeap.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -365,1 +366,1 @@\n-  CodeCache::flush_unlinked_nmethods();\n+  ClassUnloadingContext::context()->purge_and_free_nmethods();\n","filename":"src\/hotspot\/share\/gc\/x\/xNMethod.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -1323,0 +1324,4 @@\n+  ClassUnloadingContext ctx(_workers.active_workers(),\n+                            true \/* unregister_nmethods_during_purge *\/,\n+                            true \/* lock_codeblob_free_separately *\/);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/classUnloadingContext.hpp\"\n@@ -446,1 +447,1 @@\n-  CodeCache::flush_unlinked_nmethods();\n+  ClassUnloadingContext::context()->purge_and_free_nmethods();\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}