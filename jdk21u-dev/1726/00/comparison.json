{"files":[{"patch":"@@ -3855,2 +3855,0 @@\n-    Register tmp3_aliased = len;\n-\n@@ -3860,2 +3858,2 @@\n-    andl(tmp1, 64 - 1);   \/\/ tail count (in chars) 0x3F\n-    andl(len, ~(64 - 1));    \/\/ vector count (in chars)\n+    andl(tmp1, 0x0000003f); \/\/ tail count (in chars) 0x3F\n+    andl(len,  0xffffffc0); \/\/ vector count (in chars)\n@@ -3881,0 +3879,2 @@\n+\n+    \/\/ check the tail for absense of negatives\n@@ -3883,4 +3883,7 @@\n-    mov64(tmp3_aliased, 0xFFFFFFFFFFFFFFFF);\n-    shlxq(tmp3_aliased, tmp3_aliased, tmp1);\n-    notq(tmp3_aliased);\n-    kmovql(mask2, tmp3_aliased);\n+    {\n+      Register tmp3_aliased = len;\n+      mov64(tmp3_aliased, 0xFFFFFFFFFFFFFFFF);\n+      shlxq(tmp3_aliased, tmp3_aliased, tmp1);\n+      notq(tmp3_aliased);\n+      kmovql(mask2, tmp3_aliased);\n+    }\n@@ -3918,0 +3921,5 @@\n+    \/\/ do a full check for negative registers in the tail\n+    movl(len, tmp1); \/\/ tmp1 holds low 6-bit from original len;\n+                     \/\/ ary1 already pointing to the right place\n+    jmpb(TAIL_START);\n+\n@@ -3919,1 +3927,1 @@\n-    \/\/ At least one byte in the last 64 bytes is negative.\n+    \/\/ At least one byte in the last 64 byte block was negative.\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,0 @@\n-package compiler.intrinsics.string;\n-\n@@ -28,1 +26,1 @@\n- * @bug 8999999\n+ * @bug 8281146\n@@ -30,0 +28,1 @@\n+ * @key randomness\n@@ -31,0 +30,1 @@\n+ * @library \/test\/lib\n@@ -35,0 +35,24 @@\n+\/*\n+ * @test\n+ * @bug 8281146 8318509\n+ * @summary Validates StringCoding.countPositives intrinsic for AVX3 works with and without\n+ *          AVX3Threshold=0\n+ * @key randomness\n+ * @library \/compiler\/patches\n+ * @library \/test\/lib\n+ *\n+ * @build java.base\/java.lang.Helper\n+ * @requires vm.cpu.features ~= \".*avx512.*\"\n+ * @run main\/othervm\/timeout=1200 -XX:UseAVX=3 compiler.intrinsics.string.TestCountPositives\n+ * @run main\/othervm\/timeout=1200 -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:AVX3Threshold=0 compiler.intrinsics.string.TestCountPositives\n+ *\/\n+\/**\n+ * This test was derived from compiler.intrinsics.string.TestHasNegatives\n+ *\/\n+package compiler.intrinsics.string;\n+\n+import java.lang.Helper;\n+import java.util.Random;\n+import java.util.stream.IntStream;\n+\n+import jdk.test.lib.Utils;\n@@ -38,1 +62,3 @@\n-    private static byte[] tBa = new byte[4096 + 16];\n+    private static byte[] bytes = new byte[4096 + 32];\n+\n+    private static final Random RANDOM = Utils.getRandomInstance();\n@@ -43,1 +69,2 @@\n-     * length, and number of negative bytes.\n+     * length, and number of negative bytes. The lowest index that will be\n+     * negative is marked by negOffset\n@@ -45,2 +72,2 @@\n-    public static void initialize(int off, int len, int neg) {\n-        assert (len + off <= tBa.length);\n+    public static void initialize(int off, int len, int neg, int negOffset) {\n+        assert (len + off <= bytes.length);\n@@ -49,1 +76,1 @@\n-            tBa[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n+            bytes[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n@@ -53,1 +80,1 @@\n-            tBa[i] = (byte) (((i - off + 15) & 0x7F));\n+            bytes[i] = (byte) (((i - off + 15) & 0x7F));\n@@ -58,5 +85,3 @@\n-            int div = (neg > 1) ? (len - 1) \/ (neg - 1) : 0;\n-            int idx;\n-            for (int i = 0; i < neg; ++i) {\n-                idx = off + (len - 1) - div * i;\n-                tBa[idx] = (byte) (0x80 | tBa[idx]);\n+            for (int i = 0; i < neg; i++) {\n+                int idx = off + RANDOM.nextInt(len - negOffset) + negOffset;\n+                bytes[idx] = (byte) (0x80 | bytes[idx]);\n@@ -66,2 +91,2 @@\n-        for (int i = len + off; i < tBa.length; ++i) {\n-            tBa[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n+        for (int i = len + off; i < bytes.length; ++i) {\n+            bytes[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n@@ -71,4 +96,0 @@\n-    \/** Sizes of array segments to test. *\/\n-    private static int sizes[] = { 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 13, 17, 19, 23, 37, 61, 131,\n-            4099 };\n-\n@@ -80,2 +101,22 @@\n-        int len, off;\n-        int ng;\n+        for (int off = 0; off < 16; off++) { \/\/ starting offset of array segment\n+            \/\/ Test all array segment sizes 1-63\n+            for (int len = 1; len < 64; len++) {\n+                test_countPositives(off, len, 0, 0);\n+                test_countPositives(off, len, 1, 0);\n+                test_countPositives(off, len, RANDOM.nextInt(30) + 2, 0);\n+            }\n+            \/\/ Test a random selection of sizes between 64 and 4099, inclusive\n+            for (int i = 0; i < 20; i++) {\n+                int len = 64 + RANDOM.nextInt(4100 - 64);\n+                test_countPositives(off, len, 0, 0);\n+                test_countPositives(off, len, 1, 0);\n+                test_countPositives(off, len, RANDOM.nextInt(len) + 2, 0);\n+            }\n+            for (int len : new int[] { 128, 2048 }) {\n+                \/\/ test with negatives only in a 1-63 byte tail\n+                int tail = RANDOM.nextInt(63) + 1;\n+                int ng = RANDOM.nextInt(tail) + 1;\n+                test_countPositives(off, len + tail, ng, len);\n+            }\n+        }\n+    }\n@@ -83,22 +124,11 @@\n-        for (ng = 0; ng < 57; ++ng) { \/\/ number of negatives in array segment\n-            for (off = 0; off < 8; ++off) { \/\/ starting offset of array segment\n-                for (int i = 0; i < sizes.length; ++i) { \/\/ array segment size\n-                                                         \/\/ choice\n-                    len = sizes[i];\n-                    if (len + off > tBa.length)\n-                        continue;\n-                    initialize(off, len, ng);\n-                    int calculated = Helper.StringCodingCountPositives(tBa, off, len);\n-                    int expected = countPositives(tBa, off, len);\n-                    if (calculated != expected) {\n-                        if (expected != len && calculated >= 0 && calculated < expected) {\n-                            \/\/ allow intrinsics to return early with a lower value,\n-                            \/\/ but only if we're not expecting the full length (no\n-                            \/\/ negative bytes)\n-                            continue;\n-                        }\n-                        throw new Exception(\"Failed test countPositives \" + \"offset: \" + off + \" \"\n-                                + \"length: \" + len + \" \" + \"return: \" + calculated + \" expected: \" + expected + \" negatives: \"\n-                                + ng);\n-                    }\n-                }\n+    private static void test_countPositives(int off, int len, int ng, int ngOffset) throws Exception {\n+        assert (len + off < bytes.length);\n+        initialize(off, len, ng, ngOffset);\n+        int calculated = Helper.StringCodingCountPositives(bytes, off, len);\n+        int expected = countPositives(bytes, off, len);\n+        if (calculated != expected) {\n+            if (expected != len && ng >= 0 && calculated >= 0 && calculated < expected) {\n+                \/\/ allow intrinsics to return early with a lower value,\n+                \/\/ but only if we're not expecting the full length (no\n+                \/\/ negative bytes)\n+                return;\n@@ -106,0 +136,3 @@\n+            throw new Exception(\"Failed test countPositives \" + \"offset: \" + off + \" \"\n+                    + \"length: \" + len + \" \" + \"return: \" + calculated + \" expected: \" + expected + \" negatives: \"\n+                    + ng + \" offset: \" + ngOffset);\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestCountPositives.java","additions":78,"deletions":45,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @library \/test\/lib\n@@ -33,0 +34,14 @@\n+\/*\n+ * @test\n+ * @bug 8054307 8318509\n+ * @summary Validates StringCoding.hasNegatives intrinsic for AVX3 works with and without\n+ *          AVX3Threshold=0\n+ * @key randomness\n+ * @library \/compiler\/patches\n+ * @library \/test\/lib\n+ *\n+ * @build java.base\/java.lang.Helper\n+ * @requires vm.cpu.features ~= \".*avx512.*\"\n+ * @run main\/othervm\/timeout=1200 -XX:UseAVX=3 compiler.intrinsics.string.TestHasNegatives\n+ * @run main\/othervm\/timeout=1200 -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:AVX3Threshold=0 compiler.intrinsics.string.TestHasNegatives\n+ *\/\n@@ -36,4 +51,6 @@\n-\/*\n- * @summary Validates StringCoding.hasNegatives intrinsic with a small\n- *          range of tests.\n- *\/\n+import java.lang.Helper;\n+import java.util.Random;\n+import java.util.stream.IntStream;\n+\n+import jdk.test.lib.Utils;\n+\n@@ -42,1 +59,3 @@\n-    private static byte[] tBa = new byte[4096 + 16];\n+    private static byte[] bytes = new byte[4096 + 32];\n+\n+    private static final Random RANDOM = Utils.getRandomInstance();\n@@ -50,1 +69,1 @@\n-        assert (len + off <= tBa.length);\n+        assert (len + off <= bytes.length);\n@@ -53,1 +72,1 @@\n-            tBa[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n+            bytes[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n@@ -57,1 +76,1 @@\n-            tBa[i] = (byte) (((i - off + 15) & 0x7F));\n+            bytes[i] = (byte) (((i - off + 15) & 0x7F));\n@@ -62,5 +81,3 @@\n-            int div = (neg > 1) ? (len - 1) \/ (neg - 1) : 0;\n-            int idx;\n-            for (int i = 0; i < neg; ++i) {\n-                idx = off + (len - 1) - div * i;\n-                tBa[idx] = (byte) (0x80 | tBa[idx]);\n+            for (int i = 0; i < neg; i++) {\n+                int idx = off + RANDOM.nextInt(len);\n+                bytes[idx] = (byte) (0x80 | bytes[idx]);\n@@ -70,2 +87,2 @@\n-        for (int i = len + off; i < tBa.length; ++i) {\n-            tBa[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n+        for (int i = len + off; i < bytes.length; ++i) {\n+            bytes[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n@@ -75,4 +92,0 @@\n-    \/** Sizes of array segments to test. *\/\n-    private static int sizes[] = { 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 13, 17, 19, 23, 37, 61, 131,\n-            4099 };\n-\n@@ -84,19 +97,6 @@\n-        int len, off;\n-        int ng;\n-        boolean r;\n-\n-        for (ng = 0; ng < 57; ++ng) { \/\/ number of negatives in array segment\n-            for (off = 0; off < 8; ++off) { \/\/ starting offset of array segment\n-                for (int i = 0; i < sizes.length; ++i) { \/\/ array segment size\n-                                                         \/\/ choice\n-                    len = sizes[i];\n-                    if (len + off > tBa.length)\n-                        continue;\n-                    initialize(off, len, ng);\n-                    r = Helper.StringCodingHasNegatives(tBa, off, len);\n-                    if (r ^ ((ng == 0) ? false : true)) {\n-                        throw new Exception(\"Failed test hasNegatives \" + \"offset: \" + off + \" \"\n-                                + \"length: \" + len + \" \" + \"return: \" + r + \" \" + \"negatives: \"\n-                                + ng);\n-                    }\n-                }\n+        for (int off = 0; off < 16; off++) { \/\/ starting offset of array segment\n+            \/\/ Test all array segment sizes 1-63\n+            for (int len = 1; len < 64; len++) {\n+                test_hasNegatives(off, len, 0);\n+                test_hasNegatives(off, len, 1);\n+                test_hasNegatives(off, len, RANDOM.nextInt(30) + 2);\n@@ -104,0 +104,19 @@\n+            \/\/ Test a random selection of sizes between 64 and 4099, inclusive\n+            for (int i = 0; i < 20; i++) {\n+                int len = 64 + RANDOM.nextInt(4100 - 64);\n+                test_hasNegatives(off, len, 0);\n+                test_hasNegatives(off, len, 1);\n+                test_hasNegatives(off, len, RANDOM.nextInt(len) + 2);\n+            }\n+        }\n+    }\n+\n+    private static void test_hasNegatives(int off, int len, int maxNegatives) throws Exception {\n+        assert (len + off < bytes.length);\n+        initialize(off, len, maxNegatives);\n+        boolean expected = (maxNegatives > 0);\n+        boolean actual = Helper.StringCodingHasNegatives(bytes, off, len);\n+        if (actual != expected) {\n+            throw new Exception(\"Failed test hasNegatives \" + \"offset: \" + off + \" \"\n+                    + \"length: \" + len + \" \" + \"return: \" + actual + \" \" + \"negatives: \"\n+                    + maxNegatives);\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestHasNegatives.java","additions":58,"deletions":39,"binary":false,"changes":97,"status":"modified"}]}