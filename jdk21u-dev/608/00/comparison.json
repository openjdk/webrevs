{"files":[{"patch":"@@ -1621,2 +1621,2 @@\n-  \/\/ Lazily create the _oop_map_cache at first request\n-  \/\/ Lock-free access requires load_acquire.\n+  \/\/ Lazily create the _oop_map_cache at first request.\n+  \/\/ Load_acquire is needed to safely get instance published with CAS by another thread.\n@@ -1625,6 +1625,7 @@\n-    MutexLocker x(OopMapCacheAlloc_lock);\n-    \/\/ Check if _oop_map_cache was allocated while we were waiting for this lock\n-    if ((oop_map_cache = _oop_map_cache) == nullptr) {\n-      oop_map_cache = new OopMapCache();\n-      \/\/ Ensure _oop_map_cache is stable, since it is examined without a lock\n-      Atomic::release_store(&_oop_map_cache, oop_map_cache);\n+    \/\/ Try to install new instance atomically.\n+    oop_map_cache = new OopMapCache();\n+    OopMapCache* other = Atomic::cmpxchg(&_oop_map_cache, (OopMapCache*)nullptr, oop_map_cache);\n+    if (other != nullptr) {\n+      \/\/ Someone else managed to install before us, ditch local copy and use the existing one.\n+      delete oop_map_cache;\n+      oop_map_cache = other;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -104,1 +104,0 @@\n-Mutex*   OopMapCacheAlloc_lock        = nullptr;\n@@ -359,1 +358,0 @@\n-  MUTEX_DEFL(OopMapCacheAlloc_lock          , PaddedMutex  ,  Threads_lock, true);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,1 +100,0 @@\n-extern Mutex*   OopMapCacheAlloc_lock;           \/\/ protects allocation of oop_map caches\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}