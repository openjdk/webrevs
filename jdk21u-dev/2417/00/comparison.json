{"files":[{"patch":"@@ -2014,0 +2014,9 @@\n+void InterpreterMacroAssembler::verify_field_offset(Register reg) {\n+  \/\/ Verify the field offset is not in the header, implicitly checks for 0\n+  Label L;\n+  mv(t0, oopDesc::base_offset_in_bytes());\n+  bge(reg, t0, L);\n+  stop(\"bad field offset\");\n+  bind(L);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -304,0 +304,2 @@\n+  void verify_field_offset(Register reg) NOT_DEBUG_RETURN;\n+\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -134,0 +134,1 @@\n+  assert_different_registers(bc_reg, temp_reg);\n@@ -189,1 +190,5 @@\n-  \/\/ patch bytecode\n+  \/\/ Patch bytecode with release store to coordinate with ResolvedFieldEntry loads\n+  \/\/ in fast bytecode codelets. load_field_entry has a memory barrier that gains\n+  \/\/ the needed ordering, together with control dependency on entering the fast codelet\n+  \/\/ itself.\n+  __ membar(MacroAssembler::LoadStore | MacroAssembler::StoreStore);\n@@ -2911,0 +2916,1 @@\n+  __ verify_field_offset(x11);\n@@ -3006,0 +3012,2 @@\n+  __ verify_field_offset(x11);\n+\n@@ -3062,0 +3070,4 @@\n+\n+  \/\/ Must prevent reordering of the following cp cache loads with bytecode load\n+  __ membar(MacroAssembler::LoadLoad);\n+\n@@ -3064,0 +3076,1 @@\n+  __ verify_field_offset(x11);\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"}]}