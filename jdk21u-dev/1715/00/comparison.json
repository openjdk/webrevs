{"files":[{"patch":"@@ -2742,4 +2742,0 @@\n-      \/* If we get an out-of-range offset it is a bug in the compiler,\n-         so we assert here. *\/\n-      assert(Address::offset_ok_for_immed(addr.offset(), exact_log2(size_in_memory)),\n-             \"c2 compiler bug\");\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test TestUnalignedAccess\n+ * @summary AArch64: C2 compilation hits offset_ok_for_immed: assert \"c2 compiler bug\".\n+ * @bug 8319690\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run main\/othervm compiler.c2.TestUnalignedAccess\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -Xmx1g\n+ *                   -XX:CompileCommand=compileonly,compiler.c2.TestUnalignedAccess*::<clinit>\n+ *                   compiler.c2.TestUnalignedAccess\n+ *\/\n+\n+public class TestUnalignedAccess {\n+\n+    public static final int LEN = 2040;\n+\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    static void sink(int x) {}\n+\n+    public static long lseed = 1;\n+    public static int iseed = 2;\n+    public static short sseed = 3;\n+    public static byte bseed = 4;\n+    public static long lres = lseed;\n+    public static int ires = iseed;\n+    public static short sres = sseed;\n+    public static byte bres = bseed;\n+\n+    public static class TestLong {\n+\n+        private static final byte[] BYTES = new byte[LEN];\n+        private static final long rawdata = 0xbeef;\n+        private static final long data;\n+\n+        static {\n+            sink(2);\n+            \/\/ Signed immediate byte offset: range -256 to 255\n+            \/\/ Positive immediate byte offset: a multiple of 8 in the range 0 to 32760\n+            \/\/ Other immediate byte offsets can't be encoded in the instruction field.\n+\n+            \/\/ 1030 can't be encoded as \"base + offset\" mode into the instruction field.\n+            UNSAFE.putLongUnaligned(BYTES, 1030, rawdata);\n+            lres += UNSAFE.getLongUnaligned(BYTES, 1030);\n+            \/\/ 127 can be encoded into simm9 field.\n+            UNSAFE.putLongUnaligned(BYTES, 127, lres);\n+            lres += UNSAFE.getLongUnaligned(BYTES, 127);\n+            \/\/ 1096 can be encoded into uimm12 field.\n+            UNSAFE.putLongUnaligned(BYTES, 1096, lres);\n+            data = UNSAFE.getLongUnaligned(BYTES, 1096);\n+        }\n+\n+    }\n+\n+    public static class TestInt {\n+\n+        private static final byte[] BYTES = new byte[LEN];\n+        private static final int rawdata = 0xbeef;\n+        private static final int data;\n+        static {\n+            sink(2);\n+            \/\/ Signed immediate byte offset: range -256 to 255\n+            \/\/ Positive immediate byte offset, a multiple of 4 in the range 0 to 16380\n+            \/\/ Other immediate byte offsets can't be encoded in the instruction field.\n+\n+            \/\/ 274 can't be encoded as \"base + offset\" mode into the instruction field.\n+            UNSAFE.putIntUnaligned(BYTES, 274, rawdata);\n+            ires += UNSAFE.getIntUnaligned(BYTES, 274);\n+            \/\/ 255 can be encoded into simm9 field.\n+            UNSAFE.putIntUnaligned(BYTES, 255, ires);\n+            ires += UNSAFE.getIntUnaligned(BYTES, 255);\n+            \/\/ 528 can be encoded into uimm12 field.\n+            UNSAFE.putIntUnaligned(BYTES, 528, ires);\n+            data = UNSAFE.getIntUnaligned(BYTES, 528);\n+        }\n+\n+    }\n+\n+    public static class TestShort {\n+\n+        private static final byte[] BYTES = new byte[LEN];\n+        private static final short rawdata = (short)0xbeef;\n+        private static final short data;\n+        static {\n+            sink(2);\n+            \/\/ Signed immediate byte offset: range -256 to 255\n+            \/\/ Positive immediate byte offset: a multiple of 2 in the range 0 to 8190\n+            \/\/ Other immediate byte offsets can't be encoded in the instruction field.\n+\n+            \/\/ 257 can't be encoded as \"base + offset\" mode into the instruction field.\n+            UNSAFE.putShortUnaligned(BYTES, 257, rawdata);\n+            sres = (short) (sres + UNSAFE.getShortUnaligned(BYTES, 257));\n+            \/\/ 253 can be encoded into simm9 field.\n+            UNSAFE.putShortUnaligned(BYTES, 253, sres);\n+            sres = (short) (sres + UNSAFE.getShortUnaligned(BYTES, 253));\n+            \/\/ 272 can be encoded into uimm12 field.\n+            UNSAFE.putShortUnaligned(BYTES, 272, sres);\n+            data = UNSAFE.getShortUnaligned(BYTES, 272);\n+        }\n+\n+    }\n+\n+    public static class TestByte {\n+\n+        private static final byte[] BYTES = new byte[LEN];\n+        private static final byte rawdata = (byte)0x3f;\n+        private static final byte data;\n+        static {\n+            sink(2);\n+            \/\/ Signed immediate byte offset: range -256 to 255\n+            \/\/ Positive immediate byte offset: range 0 to 4095\n+            \/\/ Other immediate byte offsets can't be encoded in the instruction field.\n+\n+            \/\/ 272 can be encoded into simm9 field.\n+            UNSAFE.putByte(BYTES, 272, rawdata);\n+            bres = (byte) (bres + UNSAFE.getByte(BYTES, 272));\n+            \/\/ 53 can be encoded into simm9 field.\n+            UNSAFE.putByte(BYTES, 53, bres);\n+            bres = (byte) (bres + UNSAFE.getByte(BYTES, 53));\n+            \/\/ 1027 can be encoded into uimm12 field.\n+            UNSAFE.putByte(BYTES, 1027, bres);\n+            data = UNSAFE.getByte(BYTES, 1027);\n+        }\n+\n+    }\n+\n+    static void test() {\n+        TestLong ta = new TestLong();\n+        Asserts.assertEquals(ta.data, (ta.rawdata + lseed) * 2, \"putUnaligned long failed!\");\n+\n+        TestInt tb = new TestInt();\n+        Asserts.assertEquals(tb.data, (tb.rawdata + iseed) * 2, \"putUnaligned int failed!\");\n+\n+        TestShort tc = new TestShort();\n+        Asserts.assertEquals(tc.data, (short) (((short) (tc.rawdata + sseed)) * 2), \"putUnaligned short failed!\");\n+\n+        TestByte td = new TestByte();\n+        Asserts.assertEquals(td.data, (byte) (((byte) (td.rawdata + bseed)) * 2), \"put byte failed!\");\n+    }\n+\n+    public static void main(String[] strArr) {\n+        test();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUnalignedAccess.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"}]}