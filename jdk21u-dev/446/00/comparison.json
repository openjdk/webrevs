{"files":[{"patch":"@@ -98,2 +98,1 @@\n-VtableStub* VtableStubs::_table[VtableStubs::N];\n-int VtableStubs::_number_of_vtable_stubs = 0;\n+VtableStub* volatile VtableStubs::_table[VtableStubs::N];\n@@ -129,0 +128,2 @@\n+  assert(VtableStub::_receiver_location == VMRegImpl::Bad(), \"initialized multiple times?\");\n+\n@@ -132,2 +133,0 @@\n-    assert(_number_of_vtable_stubs == 0, \"potential performance bug: VtableStubs initialized more than once\");\n-    assert(is_power_of_2(int(N)), \"N must be a power of 2\");\n@@ -135,1 +134,1 @@\n-      _table[i] = nullptr;\n+      Atomic::store(&_table[i], (VtableStub*)nullptr);\n@@ -262,1 +261,1 @@\n-  VtableStub* s = _table[hash];\n+  VtableStub* s = Atomic::load(&_table[hash]);\n@@ -272,4 +271,4 @@\n-  \/\/ enter s at the beginning of the corresponding list\n-  s->set_next(_table[h]);\n-  _table[h] = s;\n-  _number_of_vtable_stubs++;\n+  \/\/ Insert s at the beginning of the corresponding list.\n+  s->set_next(Atomic::load(&_table[h]));\n+  \/\/ Make sure that concurrent readers not taking the mutex observe the writing of \"next\".\n+  Atomic::release_store(&_table[h], s);\n@@ -283,1 +282,1 @@\n-  for (s = _table[hash]; s != nullptr && s != stub; s = s->next()) {}\n+  for (s = Atomic::load(&_table[hash]); s != nullptr && s != stub; s = s->next()) {}\n@@ -302,3 +301,0 @@\n-  \/\/ Note: No locking needed since any change to the data structure\n-  \/\/       happens with an atomic store into it (we don't care about\n-  \/\/       consistency with the _number_of_vtable_stubs counter).\n@@ -306,1 +302,1 @@\n-    for (VtableStub* s = _table[i]; s != nullptr; s = s->next()) {\n+    for (VtableStub* s = Atomic::load_acquire(&_table[i]); s != nullptr; s = s->next()) {\n@@ -318,4 +314,3 @@\n-    for (int i = 0; i < N; i++) {\n-        for (VtableStub* s = _table[i]; s != nullptr; s = s->next()) {\n-            f(s);\n-        }\n+  for (int i = 0; i < N; i++) {\n+    for (VtableStub* s = Atomic::load_acquire(&_table[i]); s != nullptr; s = s->next()) {\n+      f(s);\n@@ -323,0 +318,1 @@\n+  }\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":15,"deletions":19,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+  static_assert(is_power_of_2((int)N), \"N must be a power of 2\");\n+\n@@ -84,2 +86,1 @@\n-  static VtableStub* _table[N];                  \/\/ table of existing stubs\n-  static int         _number_of_vtable_stubs;    \/\/ number of stubs created so far (for statistics)\n+  static VtableStub* volatile _table[N];                  \/\/ table of existing stubs\n@@ -111,1 +112,0 @@\n-  static int         number_of_vtable_stubs() { return _number_of_vtable_stubs; }\n","filename":"src\/hotspot\/share\/code\/vtableStubs.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}