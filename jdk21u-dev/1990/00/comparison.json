{"files":[{"patch":"@@ -318,0 +318,5 @@\n+        if (len == 0) {\n+            mag = ZERO.mag;\n+            signum = ZERO.signum;\n+            return;\n+        }\n@@ -319,2 +324,3 @@\n-        if (val[off] < 0) {\n-            mag = makePositive(val, off, len);\n+        int b = val[off];\n+        if (b < 0) {\n+            mag = makePositive(b, val, off, len);\n@@ -323,1 +329,1 @@\n-            mag = stripLeadingZeroBytes(val, off, len);\n+            mag = stripLeadingZeroBytes(b, val, off, len);\n@@ -4571,1 +4577,5 @@\n-    \/**\n+    private static int[] stripLeadingZeroBytes(byte[] a, int from, int len) {\n+        return stripLeadingZeroBytes(Integer.MIN_VALUE, a, from, len);\n+    }\n+\n+    \/*\n@@ -4573,0 +4583,8 @@\n+     * The returned array is either empty, or its 0-th element is non-zero,\n+     * meeting the \"minimal\" requirement for field mag (see comment on mag).\n+     *\n+     * The range [from, from + len) must be well-formed w.r.t. array a.\n+     *\n+     * b < -128 means that a[from] has not yet been read.\n+     * Otherwise, b must be a[from], have been read only once before invoking\n+     * this method, and len > 0 must hold.\n@@ -4574,18 +4592,11 @@\n-    private static int[] stripLeadingZeroBytes(byte[] a, int off, int len) {\n-        int indexBound = off + len;\n-        int keep;\n-\n-        \/\/ Find first nonzero byte\n-        for (keep = off; keep < indexBound && a[keep] == 0; keep++)\n-            ;\n-\n-        \/\/ Allocate new array and copy relevant part of input array\n-        int intLength = ((indexBound - keep) + 3) >>> 2;\n-        int[] result = new int[intLength];\n-        int b = indexBound - 1;\n-        for (int i = intLength-1; i >= 0; i--) {\n-            result[i] = a[b--] & 0xff;\n-            int bytesRemaining = b - keep + 1;\n-            int bytesToTransfer = Math.min(3, bytesRemaining);\n-            for (int j=8; j <= (bytesToTransfer << 3); j += 8)\n-                result[i] |= ((a[b--] & 0xff) << j);\n+    private static int[] stripLeadingZeroBytes(int b, byte[] a, int from, int len) {\n+        \/*\n+         * Except for the first byte, each read access to the input array a\n+         * is of the form a[from++].\n+         * The index from is never otherwise altered, except right below,\n+         * and only increases in steps of 1, always up to index to.\n+         * Hence, each byte in the array is read exactly once, from lower to\n+         * higher indices (from most to least significant byte).\n+         *\/\n+        if (len == 0) {\n+            return ZERO.mag;\n@@ -4593,1 +4604,44 @@\n-        return result;\n+        int to = from + len;\n+        if (b < -128) {\n+            b = a[from];\n+        }\n+        \/* Either way, a[from] has now been read exactly once, skip to next. *\/\n+        ++from;\n+        \/*\n+         * Set up the shortest int[] for the sequence of the bytes\n+         *      b, a[from+1], ..., a[to-1]    (len > 0)\n+         * Shortest means first skipping leading zeros.\n+         *\/\n+        for (; b == 0 && from < to; b = a[from++])\n+            ;  \/\/empty body\n+        if (b == 0) {\n+            \/* Here, from == to as well. All bytes are zeros. *\/\n+            return ZERO.mag;\n+        }\n+        \/*\n+         * Allocate just enough ints to hold (to - from + 1) bytes, that is\n+         *      ((to - from + 1) + 3) \/ 4 = (to - from) \/ 4 + 1\n+         *\/\n+        int[] res = new int[((to - from) >> 2) + 1];\n+        \/*\n+         * A \"digit\" is a group of 4 adjacent bytes aligned w.r.t. index to.\n+         * (Implied 0 bytes are prepended as needed.)\n+         * b is the most significant byte not 0.\n+         * Digit d0 spans the range of indices that includes current (from - 1).\n+         *\/\n+        int d0 = b & 0xFF;\n+        while (((to - from) & 0x3) != 0) {\n+            d0 = d0 << 8 | a[from++] & 0xFF;\n+        }\n+        res[0] = d0;\n+        \/*\n+         * Prepare the remaining digits.\n+         * (to - from) is a multiple of 4, so prepare an int for every 4 bytes.\n+         * This is a candidate for Unsafe.copy[Swap]Memory().\n+         *\/\n+        int i = 1;\n+        while (from < to) {\n+            res[i++] = a[from++] << 24 | (a[from++] & 0xFF) << 16\n+                    | (a[from++] & 0xFF) << 8 | (a[from++] & 0xFF);\n+        }\n+        return res;\n@@ -4596,1 +4650,1 @@\n-    \/**\n+    \/*\n@@ -4599,0 +4653,4 @@\n+     *\n+     * len > 0 must hold.\n+     * The range [from, from + len) must be well-formed w.r.t. array a.\n+     * b is assumed to be the result of reading a[from] and to meet b < 0.\n@@ -4600,39 +4658,43 @@\n-    private static int[] makePositive(byte[] a, int off, int len) {\n-        int keep, k;\n-        int indexBound = off + len;\n-\n-        \/\/ Find first non-sign (0xff) byte of input\n-        for (keep=off; keep < indexBound && a[keep] == -1; keep++)\n-            ;\n-\n-\n-        \/* Allocate output array.  If all non-sign bytes are 0x00, we must\n-         * allocate space for one extra output byte. *\/\n-        for (k=keep; k < indexBound && a[k] == 0; k++)\n-            ;\n-\n-        int extraByte = (k == indexBound) ? 1 : 0;\n-        int intLength = ((indexBound - keep + extraByte) + 3) >>> 2;\n-        int result[] = new int[intLength];\n-\n-        \/* Copy one's complement of input into output, leaving extra\n-         * byte (if it exists) == 0x00 *\/\n-        int b = indexBound - 1;\n-        for (int i = intLength-1; i >= 0; i--) {\n-            result[i] = a[b--] & 0xff;\n-            int numBytesToTransfer = Math.min(3, b-keep+1);\n-            if (numBytesToTransfer < 0)\n-                numBytesToTransfer = 0;\n-            for (int j=8; j <= 8*numBytesToTransfer; j += 8)\n-                result[i] |= ((a[b--] & 0xff) << j);\n-\n-            \/\/ Mask indicates which bits must be complemented\n-            int mask = -1 >>> (8*(3-numBytesToTransfer));\n-            result[i] = ~result[i] & mask;\n-        }\n-\n-        \/\/ Add one to one's complement to generate two's complement\n-        for (int i=result.length-1; i >= 0; i--) {\n-            result[i] = (int)((result[i] & LONG_MASK) + 1);\n-            if (result[i] != 0)\n-                break;\n+    private static int[] makePositive(int b, byte[] a, int from, int len) {\n+        \/*\n+         * By assumption, b == a[from] < 0 and len > 0.\n+         *\n+         * First collect the bytes into the resulting array res.\n+         * Then convert res to two's complement.\n+         *\n+         * Except for b == a[from], each read access to the input array a\n+         * is of the form a[from++].\n+         * The index from is never otherwise altered, except right below,\n+         * and only increases in steps of 1, always up to index to.\n+         * Hence, each byte in the array is read exactly once, from lower to\n+         * higher indices (from most to least significant byte).\n+         *\/\n+        int to = from + len;\n+        \/* b == a[from] has been read exactly once, skip to next index. *\/\n+        ++from;\n+        \/* Skip leading -1 bytes. *\/\n+        for (; b == -1 && from < to; b = a[from++])\n+            ;  \/\/empty body\n+        \/*\n+         * A \"digit\" is a group of 4 adjacent bytes aligned w.r.t. index to.\n+         * b is the most significant byte not -1, or -1 only if from == to.\n+         * Digit d0 spans the range of indices that includes current (from - 1).\n+         * (Implied -1 bytes are prepended to array a as needed.)\n+         * It usually corresponds to res[0], except for the special case below.\n+         *\/\n+        int d0 = -1 << 8 | b & 0xFF;\n+        while (((to - from) & 0x3) != 0) {\n+            d0 = d0 << 8 | (b = a[from++]) & 0xFF;\n+        }\n+        int f = from;  \/\/ keeps the current from for sizing purposes later\n+        \/* Skip zeros adjacent to d0, if at all. *\/\n+        for (; b == 0 && from < to; b = a[from++])\n+            ;  \/\/empty body\n+        \/*\n+         * b is the most significant non-zero byte at or after (f - 1),\n+         * or 0 only if from == to.\n+         * Digit d spans the range of indices that includes (f - 1).\n+         *\/\n+        int d = b & 0xFF;\n+        while (((to - from) & 0x3) != 0) {\n+            d = d << 8 | a[from++] & 0xFF;\n@@ -4640,2 +4702,36 @@\n-\n-        return result;\n+        \/*\n+         * If the situation here is like this:\n+         * index:                      f                        to == from\n+         *      ..., -1,-1,  0,0,0,0,  0,0,0,0,  ...,  0,0,0,0\n+         * digit:               d0                        d\n+         * then, as shown, the number of zeros is a positive multiple of 4.\n+         * The array res needs a minimal length of (1 + 1 + (to - f) \/ 4)\n+         * to accommodate the two's complement, including a leading 1.\n+         * In any other case, there is at least one byte that is non-zero.\n+         * The array for the two's complement has length (0 + 1 + (to - f) \/ 4).\n+         * c is 1, resp., 0 for the two situations.\n+         *\/\n+        int c = (to - from | d0 | d) == 0 ? 1 : 0;\n+        int[] res = new int[c + 1 + ((to - f) >> 2)];\n+        res[0] = c == 0 ? d0 : -1;\n+        int i = res.length - ((to - from) >> 2);\n+        if (i > 1) {\n+            res[i - 1] = d;\n+        }\n+        \/*\n+         * Prepare the remaining digits.\n+         * (to - from) is a multiple of 4, so prepare an int for every 4 bytes.\n+         * This is a candidate for Unsafe.copy[Swap]Memory().\n+         *\/\n+        while (from < to) {\n+            res[i++] = a[from++] << 24 | (a[from++] & 0xFF) << 16\n+                    | (a[from++] & 0xFF) << 8 | (a[from++] & 0xFF);\n+        }\n+        \/* Convert to two's complement. Here, i == res.length *\/\n+        while (--i >= 0 && res[i] == 0)\n+            ;  \/\/ empty body\n+        res[i] = -res[i];\n+        while (--i >= 0) {\n+            res[i] = ~res[i];\n+        }\n+        return res;\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":161,"deletions":65,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.RandomFactory;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import java.math.Accessor;\n+import java.math.BigInteger;\n+import java.util.Random;\n+\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/**\n+ * @test\n+ * @bug 8319174\n+ * @summary Exercises minimality of BigInteger.mag field (use -Dseed=X to set PRANDOM seed)\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @build java.base\/java.math.Accessor\n+ * @key randomness\n+ * @run junit\/othervm -DmaxDurationMillis=3000 ByteArrayConstructorTest\n+ *\/\n+public class ByteArrayConstructorTest {\n+\n+    private static final int DEFAULT_MAX_DURATION_MILLIS = 3_000;\n+\n+    public static final int N = 1_024;\n+\n+    private static int maxDurationMillis;\n+    private static final Random rnd = RandomFactory.getRandom();\n+    private volatile boolean stop = false;\n+\n+    @BeforeAll\n+    static void setMaxDurationMillis() {\n+        maxDurationMillis = Math.max(maxDurationMillis(), 0);\n+    }\n+\n+    @Test\n+    public void testNonNegative() throws InterruptedException {\n+        byte[] ba = nonNegativeBytes();\n+        doBigIntegers(ba, ba[0]);  \/\/ a mask to flip to 0 and back to ba[0]\n+    }\n+\n+    @Test\n+    public void testNegative() throws InterruptedException {\n+        byte[] ba = negativeBytes();\n+        doBigIntegers(ba, (byte) ~ba[0]);  \/\/ a mask to flip to -1 and back to ba[0]\n+    }\n+\n+    \/*\n+     * Starts a thread th that keeps flipping the \"sign\" byte in the array ba\n+     * from the original value to 0 or -1 and back, depending on ba[0] being\n+     * non-negative or negative, resp.\n+     * (ba is \"big endian\", the least significant byte is the one with the\n+     * highest index.)\n+     *\n+     * In the meantime, the current thread keeps creating BigInteger instances\n+     * with ba and checks that the internal invariant holds, despite the\n+     * attempts by thread th to racily modify ba.\n+     * It does so at least as indicated by maxDurationMillis.\n+     *\n+     * Finally, this thread requests th to stop and joins with it, either\n+     * because maxDurationMillis has expired, or because of an invalid invariant.\n+     *\/\n+    private void doBigIntegers(byte[] ba, byte mask) throws InterruptedException {\n+        Thread th = new Thread(() -> {\n+            while (!stop) {\n+                ba[0] ^= mask;\n+            }\n+        });\n+        th.start();\n+\n+        try {\n+            createBigIntegers(maxDurationMillis, ba);\n+        } finally {\n+            stop = true;\n+            th.join(1_000);\n+        }\n+    }\n+\n+    private void createBigIntegers(int maxDurationMillis, byte[] ba) {\n+        long start = System.currentTimeMillis();\n+        while (System.currentTimeMillis() - start < maxDurationMillis) {\n+            BigInteger bi = new BigInteger(ba);\n+            int[] mag = Accessor.mag(bi);\n+            assertTrue(mag.length == 0 || mag[0] != 0,\n+                    String.format(\"inconsistent BigInteger: mag.length=%d, mag[0]=%d\",\n+                        mag.length, mag[0]));\n+        }\n+    }\n+\n+    private byte[] nonNegativeBytes() {\n+        byte[] ba = new byte[1 + N];\n+        byte b0;\n+        while ((b0 = (byte) rnd.nextInt()) < 0);  \/\/ empty body\n+        rnd.nextBytes(ba);\n+        ba[0] = b0;\n+        \/* Except for ba[0], fill most significant half with zeros. *\/\n+        for (int i = 1; i <= N \/ 2; ++i) {\n+            ba[i] = 0;\n+        }\n+        return ba;\n+    }\n+\n+    private byte[] negativeBytes() {\n+        byte[] ba = new byte[1 + N];\n+        byte b0;\n+        while ((b0 = (byte) rnd.nextInt()) >= 0);  \/\/ empty body\n+        rnd.nextBytes(ba);\n+        ba[0] = b0;\n+        \/* Except for ba[0], fill most significant half with -1 bytes. *\/\n+        for (int i = 1; i <= N \/ 2; ++i) {\n+            ba[i] = -1;\n+        }\n+        return ba;\n+    }\n+\n+    private static int maxDurationMillis() {\n+        try {\n+            return Integer.parseInt(System.getProperty(\"maxDurationMillis\",\n+                    Integer.toString(DEFAULT_MAX_DURATION_MILLIS)));\n+        } catch (NumberFormatException ignore) {\n+        }\n+        return DEFAULT_MAX_DURATION_MILLIS;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/math\/BigInteger\/ByteArrayConstructorTest.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -24,5 +24,6 @@\n- \/**\n-  * A no-op Java agent.\n-  *\/\n-public class JavaAgent {\n-    public static void agentmain(String args) {\n+package java.math;\n+\n+public class Accessor {\n+\n+    public static int[] mag(BigInteger bi) {\n+        return bi.mag;\n@@ -30,0 +31,1 @@\n+\n","filename":"test\/jdk\/java\/math\/BigInteger\/java.base\/java\/math\/Accessor.java","additions":7,"deletions":5,"binary":false,"changes":12,"previous_filename":"test\/jdk\/sun\/tools\/jcmd\/JavaAgent.java","status":"copied"}]}