{"files":[{"patch":"@@ -136,0 +136,1 @@\n+java\/awt\/EventQueue\/PushPopDeadlock\/PushPopDeadlock.java 8024034 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4212687\n+ * @summary Verifies that calling EventQueue.push() and EventQueue.pop()\n+ *          does not deadlock.\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual PushPopDeadlock\n+ *\/\n+\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+\n+public class PushPopDeadlock {\n+    static int counter = 0;\n+    static Robot robot;\n+    static Frame f;\n+    static Label l;\n+\n+    public static void main(String[] args) throws Exception {\n+        robot = new Robot();\n+        String INSTRUCTIONS = \"\"\"\n+                Click rapidly in the Frame labeled 'Click Here!'.\n+                The number in the Frame should continue to increase. If the number\n+                stops increasing (remains at a constant value), the test fails.\n+                \"\"\";\n+\n+        PassFailJFrame pfJFrame = PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .rows((int) INSTRUCTIONS.lines().count() + 2)\n+                .columns(35)\n+                .testUI(PushPopDeadlock::createUI)\n+                .build();\n+        PushPopDeadlock.test();\n+        pfJFrame.awaitAndCheck();\n+    }\n+\n+    public static Frame createUI() {\n+        f = new Frame(\"Click Here!\");\n+        l = new Label(\"Counter: \" + counter);\n+        f.add(l);\n+        f.setSize(200, 200);\n+        return f;\n+    }\n+\n+    public static void test() {\n+        EventQueue q = new EventQueue() {\n+            public void push(EventQueue queue) {\n+                super.push(queue);\n+                pop();\n+            }\n+        };\n+        EventQueue q2 = new EventQueue();\n+\n+        Toolkit.getDefaultToolkit().getSystemEventQueue().push(q);\n+\n+        new Thread(() -> {\n+            while (true) {\n+                robot.delay(500);\n+                l.setText(\"Counter: \" + ++counter);\n+                q.push(q2);\n+                try {\n+                    Thread.currentThread().sleep(500);\n+                } catch (InterruptedException e) {\n+                    return;\n+                }\n+            }\n+        }).start();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/EventQueue\/PushPopDeadlock\/PushPopDeadlock.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4058400\n+ * @summary Tests that calling addNotify on a lightweight component more than\n+ *          once does not break event dispatching for that component.\n+ * @key headful\n+ * @run main MultipleAddNotifyTest\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+\n+public class MultipleAddNotifyTest {\n+    static volatile boolean passFlag;\n+    static volatile int posX;\n+    static volatile int posY;\n+    static Frame f;\n+    static LightComponent l;\n+\n+    public static void main(String[] args) throws Exception {\n+        Robot r;\n+        try {\n+            r = new Robot();\n+            r.setAutoWaitForIdle(true);\n+            passFlag = false;\n+\n+            EventQueue.invokeAndWait(() -> {\n+                f = new Frame(\"Multiple addNotify Test\");\n+                l = new LightComponent();\n+                f.setLayout(new FlowLayout());\n+                l.addMouseListener(new MouseAdapter() {\n+                    @Override\n+                    public void mouseClicked(MouseEvent e) {\n+                        System.out.println(\"Mouse Clicked\");\n+                        passFlag = true;\n+                    }\n+                });\n+                f.add(l);\n+                f.addNotify();\n+                f.addNotify();\n+\n+                if (!l.isVisible()) {\n+                    throw new RuntimeException(\"Test failed. LW Component \" +\n+                            \"not visible.\");\n+                }\n+                f.setSize(200, 200);\n+                f.setLocationRelativeTo(null);\n+                f.setVisible(true);\n+            });\n+            r.waitForIdle();\n+            r.delay(1000);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                posX = f.getX() + l.getWidth() + (l.getWidth() \/ 2);\n+                posY = f.getY() + l.getHeight();\n+            });\n+\n+            r.mouseMove(posX, posY);\n+            r.delay(500);\n+\n+            r.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            r.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            r.delay(500);\n+\n+            if (!passFlag) {\n+                throw new RuntimeException(\"Test failed. MouseClicked event \" +\n+                        \"not working properly.\");\n+            }\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (f != null) {\n+                    f.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\n+\n+class LightComponent extends Component {\n+    public void paint(Graphics g) {\n+        setSize(100, 100);\n+        Dimension d = getSize();\n+        g.setColor(Color.red);\n+        g.fillRect(0, 0, d.width, d.height);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/LightweightComponent\/MultipleAddNotifyTest\/MultipleAddNotifyTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4476083\n+ * @summary Disabled components do not receive MouseEvent in Popups\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual PopupTest\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Component;\n+import java.awt.Frame;\n+\n+import javax.swing.JButton;\n+import javax.swing.JLabel;\n+import javax.swing.JMenuItem;\n+import javax.swing.JPopupMenu;\n+\n+public class PopupTest {\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                PopupMenus should disappear when a disabled component is\n+                clicked.\n+\n+                Step 1. Pop down the popup menu by clicking on it.\n+                Step 2. Click on the disabled component to make the menu\n+                disappear.\n+\n+                If the menu disappears when the disabled component is clicked,\n+                the test passes, otherwise, the test fails.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(35)\n+                .testUI(PopupTest::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    private static Frame createUI() {\n+        Frame f = new Frame(\"Disabled Component in Popup Test\");\n+        f.setLayout(new BorderLayout());\n+\n+        JButton b = new JButton(\"step 1: press me to display menu\");\n+        b.addActionListener(e -> {\n+            JPopupMenu m = new JPopupMenu();\n+            m.add(new JMenuItem(\"item 1\"));\n+            m.add(new JMenuItem(\"item 2\"));\n+            m.add(new JMenuItem(\"item 3\"));\n+            m.add(new JMenuItem(\"item 4\"));\n+            m.add(new JMenuItem(\"item 5\"));\n+            m.add(new JMenuItem(\"item 6\"));\n+            m.show((Component) e.getSource(), 0, 10);\n+        });\n+\n+        JLabel disabled = new JLabel(\"step 2: click me. the menu should be \" +\n+                \"dismissed\");\n+        disabled.setEnabled(false);\n+\n+        JLabel enabled = new JLabel(\"step 3: there is no step 3\");\n+\n+        f.add(BorderLayout.NORTH, b);\n+        f.add(BorderLayout.CENTER, disabled);\n+        f.add(BorderLayout.SOUTH, enabled);\n+        f.setSize(300, 200);\n+        return f;\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/LightweightComponent\/PopupTest\/PopupTest.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,455 @@\n+\/*\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4148078\n+ * @summary Repainting problems in scrolled panel\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual PanelRepaint\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Scrollbar;\n+import java.awt.TextField;\n+import java.awt.event.AdjustmentEvent;\n+import java.awt.event.AdjustmentListener;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+\n+public class PanelRepaint extends Panel implements FocusListener {\n+    static ScrollPanel sPanel;\n+    static Panel panel;\n+\n+    public static void main(String[] args) throws Exception {\n+        String INSTRUCTIONS = \"\"\"\n+                Using scrollbars or tab keys to scroll the panel and\n+                the panel is messy sometimes, e.g. one row bumps into\n+                another. If all components painted correctly, the test passes.\n+                Otherwise, the test fails.\n+                \"\"\";\n+\n+        PassFailJFrame.builder()\n+                .title(\"Test Instructions\")\n+                .instructions(INSTRUCTIONS)\n+                .columns(35)\n+                .testUI(PanelRepaint::createUI)\n+                .build()\n+                .awaitAndCheck();\n+    }\n+\n+    public static Frame createUI() {\n+        Frame f = new Frame(\"Panel Repaint Test\");\n+        f.setLayout(new FlowLayout());\n+        f.setSize(620, 288);\n+        PanelRepaint pr = new PanelRepaint();\n+\n+        panel = new Panel();\n+        panel.setLayout(null);\n+        panel.setSize(500, 500);\n+        sPanel = new ScrollPanel(panel);\n+\n+        Button btn = new Button(\"Open\");\n+        pr.addComp(btn);\n+        btn.setBounds(400, 10, 60, 20);\n+        btn.setActionCommand(\"OPEN\");\n+\n+        Button btn1 = new Button(\"Close\");\n+        pr.addComp(btn1);\n+        btn1.setBounds(400, 50, 60, 20);\n+        btn1.setActionCommand(\"CLOSE\");\n+\n+        TextField t1 = new TextField(\"1\");\n+        pr.addComp(t1);\n+        t1.setBounds(10, 10, 100, 20);\n+        TextField t2 = new TextField(\"2\");\n+        pr.addComp(t2);\n+        t2.setBounds(10, 50, 100, 20);\n+        TextField t3 = new TextField(\"3\");\n+        pr.addComp(t3);\n+        t3.setBounds(10, 90, 100, 20);\n+        TextField t4 = new TextField(\"4\");\n+        pr.addComp(t4);\n+        t4.setBounds(10, 130, 100, 20);\n+        TextField t5 = new TextField(\"5\");\n+        pr.addComp(t5);\n+        t5.setBounds(10, 170, 100, 20);\n+        TextField t6 = new TextField(\"6\");\n+        pr.addComp(t6);\n+        t6.setBounds(10, 210, 100, 20);\n+        TextField t7 = new TextField(\"7\");\n+        pr.addComp(t7);\n+        t7.setBounds(10, 250, 100, 20);\n+        TextField t8 = new TextField(\"8\");\n+        pr.addComp(t8);\n+        t8.setBounds(10, 290, 100, 20);\n+        TextField t9 = new TextField(\"9\");\n+        pr.addComp(t9);\n+        t9.setBounds(10, 330, 100, 20);\n+\n+        TextField t11 = new TextField(\"1\");\n+        pr.addComp(t11);\n+        t11.setBounds(120, 10, 100, 20);\n+        TextField t12 = new TextField(\"2\");\n+        pr.addComp(t12);\n+        t12.setBounds(120, 50, 100, 20);\n+        TextField t13 = new TextField(\"3\");\n+        pr.addComp(t13);\n+        t13.setBounds(120, 90, 100, 20);\n+        TextField t14 = new TextField(\"4\");\n+        pr.addComp(t14);\n+        t14.setBounds(120, 130, 100, 20);\n+        TextField t15 = new TextField(\"5\");\n+        pr.addComp(t15);\n+        t15.setBounds(120, 170, 100, 20);\n+        TextField t16 = new TextField(\"6\");\n+        pr.addComp(t16);\n+        t16.setBounds(120, 210, 100, 20);\n+        TextField t17 = new TextField(\"7\");\n+        pr.addComp(t17);\n+        t17.setBounds(120, 250, 100, 20);\n+        TextField t18 = new TextField(\"8\");\n+        pr.addComp(t18);\n+        t18.setBounds(120, 290, 100, 20);\n+        TextField t19 = new TextField(\"9\");\n+        pr.addComp(t19);\n+        t19.setBounds(120, 330, 100, 20);\n+\n+\n+        TextField t21 = new TextField(\"1\");\n+        pr.addComp(t21);\n+        t21.setBounds(240, 10, 100, 20);\n+        TextField t22 = new TextField(\"2\");\n+        pr.addComp(t22);\n+        t22.setBounds(240, 50, 100, 20);\n+        TextField t23 = new TextField(\"3\");\n+        pr.addComp(t23);\n+        t23.setBounds(240, 90, 100, 20);\n+        TextField t24 = new TextField(\"4\");\n+        pr.addComp(t24);\n+        t24.setBounds(240, 130, 100, 20);\n+        TextField t25 = new TextField(\"5\");\n+        pr.addComp(t25);\n+        t25.setBounds(240, 170, 100, 20);\n+        TextField t26 = new TextField(\"6\");\n+        pr.addComp(t26);\n+        t26.setBounds(240, 210, 100, 20);\n+        TextField t27 = new TextField(\"7\");\n+        pr.addComp(t27);\n+        t27.setBounds(240, 250, 100, 20);\n+        TextField t28 = new TextField(\"8\");\n+        pr.addComp(t28);\n+        t28.setBounds(240, 290, 100, 20);\n+        TextField t29 = new TextField(\"9\");\n+        pr.addComp(t29);\n+        t29.setBounds(240, 330, 100, 20);\n+\n+        pr.add(sPanel);\n+        f.add(pr);\n+        sPanel.setBounds(100, 100, 500, 250);\n+        sPanel.doLayout();\n+        return f;\n+    }\n+\n+    public void addComp(Component c) {\n+        panel.add(c);\n+        c.addFocusListener(this);\n+    }\n+\n+    public void focusGained(FocusEvent e) {\n+        sPanel.showComponent(e.getComponent());\n+    }\n+\n+    public void focusLost(FocusEvent e) {\n+    }\n+}\n+\n+class ScrollPanel extends Panel implements AdjustmentListener {\n+    \/**\n+     * Constructor\n+     *\/\n+    public ScrollPanel(Component c) {\n+        setLayout(null);\n+        setBackground(Color.lightGray);\n+        add(hScroll = new Scrollbar(Scrollbar.HORIZONTAL));\n+        add(vScroll = new Scrollbar(Scrollbar.VERTICAL));\n+        add(square = new Panel());\n+        square.setBackground(Color.lightGray);\n+        add(c);\n+    }\n+\n+    \/**\n+     * Scroll up\/down\/left\/right to show the component specified\n+     *\n+     * @param comp is the component to be shown\n+     *\/\n+    public void showComponent(Component comp) {\n+        Component view = getComponent(3);\n+        Rectangle viewRect = view.getBounds();\n+        Rectangle scrollRect = getBounds();\n+        Rectangle rect = comp.getBounds();\n+        while (comp != null) {\n+            Component parent = comp.getParent();\n+            if (parent == null || parent == view) {\n+                break;\n+            }\n+            Point p = parent.getLocation();\n+            rect.x += p.x;\n+            rect.y += p.y;\n+            comp = parent;\n+        }\n+\n+        int i = viewRect.y + rect.y;\n+        int j = (viewRect.y + rect.y + rect.height + ScrollPanel.H_HEIGHT)\n+                - (scrollRect.height);\n+\n+        if (i < 0) {\n+            vertUpdate(i);\n+        } else if (j > 0) {\n+            vertUpdate(j);\n+        }\n+\n+        i = viewRect.x + rect.x;\n+        j = (viewRect.x + rect.x + rect.width + (V_WIDTH * 2)) - (scrollRect.width);\n+\n+        if (i < 0) {\n+            horzUpdate(i);\n+        } else if (j > 0) {\n+            horzUpdate(j);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the panel component of ScrollPanel\n+     *\n+     * @return the panel component of ScrollPanel\n+     *\/\n+    public Component getScrolled() {\n+        return getComponent(3);\n+    }\n+\n+    \/**\n+     * updates the scroll panel vertically with value i passed\n+     *\n+     * @param i the value to be updated with\n+     *\/\n+    public void vertUpdate(int i) {\n+        update(true, vScroll.getValue() + i);\n+    }\n+\n+    \/**\n+     * updates the scroll panel horizontally with value i passed\n+     *\n+     * @param i the value to be updated with\n+     *\/\n+    public void horzUpdate(int i) {\n+        update(false, hScroll.getValue() + i);\n+    }\n+\n+    \/**\n+     * updates the scroll panel vertically if bVert is true else horizontally\n+     *\n+     * @param n is the value\n+     *\/\n+    public void update(boolean bVert, int n) {\n+        if (n < 0) n = 0;\n+        if (bVert) {\n+            if (n > max.height) {\n+                n = max.height;\n+            }\n+            if (offset.y != n) {\n+                offset.y = n;\n+                vScroll.setValue(n);\n+            }\n+        } else {\n+            if (n > max.width) {\n+                n = max.width;\n+            }\n+            if (offset.x != n) {\n+                offset.x = n;\n+                hScroll.setValue(n);\n+            }\n+        }\n+        getScrolled().setLocation(-offset.x, -offset.y);\n+    }\n+\n+    \/**\n+     * Implementation of AdjustmentListener\n+     *\/\n+    public void adjustmentValueChanged(AdjustmentEvent e) {\n+        boolean bVert = e.getSource() == vScroll;\n+        update(bVert, e.getValue());\n+    }\n+\n+    \/**\n+     * Reimplementation of Component Methods\n+     *\/\n+    public void addNotify() {\n+        super.addNotify();\n+        vScroll.addAdjustmentListener(this);\n+        hScroll.addAdjustmentListener(this);\n+    }\n+\n+    public void removeNotify() {\n+        super.removeNotify();\n+        vScroll.removeAdjustmentListener(this);\n+        hScroll.removeAdjustmentListener(this);\n+    }\n+\n+    public void setBounds(int x, int y, int w, int h) {\n+        super.setBounds(x, y, w, h);\n+        doLayout();\n+    }\n+\n+    public void doLayout() {\n+        Component c = getScrolled();\n+        Dimension d = c.getSize();\n+        if (d.width == 0 || d.height == 0) {\n+            d = c.getPreferredSize();\n+        }\n+        vert = 0;\n+        horz = 0;\n+        Dimension m = getSize();\n+        if (d.height > m.height || isScroll(true, m.height - horz, 0, d.height)) {\n+            vert = V_WIDTH;\n+        }\n+        if (d.width + vert > m.width || isScroll(false, m.width - vert, 0, d.width)) {\n+            horz = H_HEIGHT;\n+        }\n+        if (d.height + horz > m.height || isScroll(true, m.height - horz, 0, d.height)) {\n+            vert = V_WIDTH;\n+        }\n+        if (d.width + vert > m.width || isScroll(false, m.width - vert, 0, d.width)) {\n+            horz = H_HEIGHT;\n+        }\n+        if (horz != 0) {\n+            if (m.width <= 0) {\n+                m.width = 1;\n+            }\n+            hScroll.setBounds(0, m.height - H_HEIGHT, m.width - vert, H_HEIGHT);\n+            hScroll.setValues(offset.x, m.width - vert, 0, d.width);\n+            int i = d.width \/ 10;\n+            if (i < 2) {\n+                i = 2;\n+            }\n+            hScroll.setBlockIncrement(i);\n+            i = d.width \/ 50;\n+            if (i < 1) {\n+                i = 1;\n+            }\n+            hScroll.setUnitIncrement(i);\n+            max.width = d.width;\n+            hScroll.setVisible(true);\n+        } else {\n+            offset.x = 0;\n+        }\n+        if (vert != 0) {\n+            if (m.height <= 0) {\n+                m.height = 1;\n+            }\n+            vScroll.setBounds(m.width - V_WIDTH, 0, V_WIDTH, m.height - horz);\n+            vScroll.setValues(offset.y, m.height - horz, 0, d.height);\n+            int i = d.height \/ 10;\n+            if (i < 2) i = 2;\n+            vScroll.setBlockIncrement(i);\n+            i = d.height \/ 50;\n+            if (i < 1) i = 1;\n+            vScroll.setUnitIncrement(i);\n+            max.height = d.height;\n+            vScroll.setVisible(true);\n+        } else {\n+            offset.y = 0;\n+        }\n+        if (horz != 0 && vert != 0) {\n+            square.setBounds(m.width - V_WIDTH, m.height - H_HEIGHT, V_WIDTH, H_HEIGHT);\n+            square.setVisible(true);\n+        } else {\n+            square.setVisible(false);\n+        }\n+        c.setBounds(-offset.x, -offset.y, d.width, d.height);\n+        c.repaint();\n+        updateScroll(true, offset.y);\n+        updateScroll(false, offset.x);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return getScrolled().getPreferredSize();\n+    }\n+\n+    public Dimension getMinimumSize() {\n+        return getScrolled().getMinimumSize();\n+    }\n+\n+    boolean isScroll(boolean bVert, int visible, int min, int max) {\n+        int tot = max - min;\n+        int net = tot - visible;\n+        if (net <= 0) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    void updateScroll(boolean bVert, int n) {\n+        Component c = getScrolled();\n+        Dimension d = c.getSize();\n+        Dimension m = getSize();\n+        m.width -= vert;\n+        m.height -= horz;\n+        if (bVert) {\n+            if (n >= 0 && d.height > m.height) {\n+                if (n + m.height > d.height)\n+                    n = d.height - m.height;\n+            } else\n+                n = 0;\n+            update(true, n);\n+        } else {\n+            if (n >= 0 && d.width > m.width) {\n+                if (n + m.width > d.width)\n+                    n = d.width - m.width;\n+            } else\n+                n = 0;\n+            update(false, n);\n+        }\n+    }\n+\n+    static Scrollbar hScroll;\n+    static Scrollbar vScroll;\n+    static int vert = 0;\n+    static int horz = 0;\n+\n+    static Point offset = new Point();\n+    static Dimension max = new Dimension();\n+    \/\/  ScrollTimer timer;\n+    static Component square;\n+    final static int V_WIDTH = 17;\n+    final static int H_HEIGHT = 17;\n+}\n","filename":"test\/jdk\/java\/awt\/Panel\/PanelRepaint\/PanelRepaint.java","additions":455,"deletions":0,"binary":false,"changes":455,"status":"added"}]}