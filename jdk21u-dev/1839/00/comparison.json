{"files":[{"patch":"@@ -1475,0 +1475,50 @@\n+static char* _image_release_file_content = nullptr;\n+\n+void os::read_image_release_file() {\n+  assert(_image_release_file_content == nullptr, \"release file content must not be already set\");\n+  const char* home = Arguments::get_java_home();\n+  stringStream ss;\n+  ss.print(\"%s\/release\", home);\n+\n+  FILE* file = fopen(ss.base(), \"rb\");\n+  if (file == nullptr) {\n+    return;\n+  }\n+  fseek(file, 0, SEEK_END);\n+  long sz = ftell(file);\n+  if (sz == -1) {\n+    return;\n+  }\n+  fseek(file, 0, SEEK_SET);\n+\n+  char* tmp = (char*) os::malloc(sz + 1, mtInternal);\n+  if (tmp == nullptr) {\n+    fclose(file);\n+    return;\n+  }\n+\n+  size_t elements_read = fread(tmp, 1, sz, file);\n+  if (elements_read < (size_t)sz) {\n+    tmp[elements_read] = '\\0';\n+  } else {\n+    tmp[sz] = '\\0';\n+  }\n+  \/\/ issues with \\r in line endings on Windows, so better replace those\n+  for (size_t i = 0; i < elements_read; i++) {\n+    if (tmp[i] == '\\r') {\n+      tmp[i] = ' ';\n+    }\n+  }\n+  Atomic::release_store(&_image_release_file_content, tmp);\n+  fclose(file);\n+}\n+\n+void os::print_image_release_file(outputStream* st) {\n+  char* ifrc = Atomic::load_acquire(&_image_release_file_content);\n+  if (ifrc != nullptr) {\n+    st->print_cr(\"%s\", ifrc);\n+  } else {\n+    st->print_cr(\"<release file has not been read>\");\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -643,0 +643,5 @@\n+\n+  \/\/ read\/store and print the release file of the image\n+  static void read_image_release_file();\n+  static void print_image_release_file(outputStream* st);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -411,0 +411,13 @@\n+\/\/ One-shot PeriodicTask subclass for reading the release file\n+class ReadReleaseFileTask : public PeriodicTask {\n+ public:\n+  ReadReleaseFileTask() : PeriodicTask(100) {}\n+\n+  virtual void task() {\n+    os::read_image_release_file();\n+\n+    \/\/ Reclaim our storage and disenroll ourself.\n+    delete this;\n+  }\n+};\n+\n@@ -558,0 +571,4 @@\n+  \/\/ Have the WatcherThread read the release file in the background.\n+  ReadReleaseFileTask* read_task = new ReadReleaseFileTask();\n+  read_task->enroll();\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1294,0 +1294,4 @@\n+  STEP_IF(\"printing release file content\", _verbose)\n+    st->print_cr(\"Release file:\");\n+    os::print_image_release_file(st);\n+\n@@ -1469,0 +1473,4 @@\n+  \/\/ STEP(\"printing release file content\")\n+  st->print_cr(\"Release file:\");\n+  os::print_image_release_file(st);\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}