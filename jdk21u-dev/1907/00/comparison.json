{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,3 @@\n+import com.sun.org.apache.xpath.internal.objects.XBoolean;\n+import com.sun.org.apache.xpath.internal.objects.XNumber;\n+import com.sun.org.apache.xpath.internal.objects.XObject;\n@@ -28,0 +31,1 @@\n+import java.util.GregorianCalendar;\n@@ -30,4 +34,4 @@\n-\n-import com.sun.org.apache.xpath.internal.objects.XBoolean;\n-import com.sun.org.apache.xpath.internal.objects.XNumber;\n-import com.sun.org.apache.xpath.internal.objects.XObject;\n+import javax.xml.datatype.DatatypeConfigurationException;\n+import javax.xml.datatype.DatatypeConstants;\n+import javax.xml.datatype.DatatypeFactory;\n+import javax.xml.datatype.XMLGregorianCalendar;\n@@ -47,1 +51,1 @@\n- * @LastModified: Nov 2017\n+ * @LastModified: Nov 2023\n@@ -78,21 +82,7 @@\n-      Calendar cal = Calendar.getInstance();\n-      Date datetime = cal.getTime();\n-      \/\/ Format for date and time.\n-      SimpleDateFormat dateFormat = new SimpleDateFormat(dt);\n-\n-      StringBuffer buff = new StringBuffer(dateFormat.format(datetime));\n-      \/\/ Must also include offset from UTF.\n-      \/\/ Get the offset (in milliseconds).\n-      int offset = cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET);\n-      \/\/ If there is no offset, we have \"Coordinated\n-      \/\/ Universal Time.\"\n-      if (offset == 0)\n-        buff.append(\"Z\");\n-      else\n-      {\n-        \/\/ Convert milliseconds to hours and minutes\n-        int hrs = offset\/(60*60*1000);\n-        \/\/ In a few cases, the time zone may be +\/-hh:30.\n-        int min = offset%(60*60*1000);\n-        char posneg = hrs < 0? '-': '+';\n-        buff.append(posneg).append(formatDigits(hrs)).append(':').append(formatDigits(min));\n+      String resultStr = \"\";\n+      try {\n+         GregorianCalendar cal = new GregorianCalendar();\n+         cal.setTime(new Date());\n+         XMLGregorianCalendar xCal = DatatypeFactory.newInstance().newXMLGregorianCalendar(cal);\n+         xCal.setMillisecond(DatatypeConstants.FIELD_UNDEFINED);\n+         resultStr = xCal.toXMLFormat();\n@@ -100,1 +90,5 @@\n-      return buff.toString();\n+      catch (DatatypeConfigurationException ex) {\n+\n+      }\n+\n+      return resultStr;\n@@ -138,0 +132,1 @@\n+      if (\"\".equals(datetimeIn)) return EMPTY_STR;\n@@ -254,1 +249,1 @@\n-      if (ad || yr == Double.NaN)\n+      if (ad || Double.isNaN(yr))\n@@ -607,1 +602,1 @@\n-      if (dbl == Double.NaN)\n+      if (Double.isNaN(dbl))\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/lib\/ExsltDatetime.java","additions":25,"deletions":30,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n- * @LastModified: Sep 2021\n+ * @LastModified: Nov 2023\n@@ -844,1 +844,1 @@\n-            if (elemPrio == Double.NaN || elemPrio < nodePrio ||\n+            if (Double.isNaN(elemPrio) || elemPrio < nodePrio ||\n@@ -859,1 +859,1 @@\n-            if (textPrio == Double.NaN || textPrio < nodePrio ||\n+            if (Double.isNaN(textPrio) || textPrio < nodePrio ||\n@@ -1184,1 +1184,1 @@\n-            if (elemPrio == Double.NaN || elemPrio < nodePrio ||\n+            if (Double.isNaN(elemPrio) || elemPrio < nodePrio ||\n@@ -1200,1 +1200,1 @@\n-            if (textPrio == Double.NaN || textPrio < nodePrio ||\n+            if (Double.isNaN(textPrio) || textPrio < nodePrio ||\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/compiler\/Mode.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,0 @@\n-import com.sun.org.apache.xml.internal.utils.IntVector;\n@@ -25,0 +24,1 @@\n+import java.util.HashMap;\n@@ -56,1 +56,1 @@\n- * @LastModified: Oct 2017\n+ * @LastModified: Nov 2023\n@@ -61,3 +61,1 @@\n-  static final int HASHPRIME=101;\n-  int[] m_hashStart=new int[HASHPRIME];\n-  IntVector m_hashChain;\n+  HashMap<String, Integer> m_stringToInt;\n@@ -74,1 +72,1 @@\n-      m_hashChain= new IntVector(chainSize);\n+      m_stringToInt = new HashMap<>();\n@@ -89,3 +87,1 @@\n-      for(int i=0;i<HASHPRIME;++i)\n-        m_hashStart[i]=NULL;\n-      m_hashChain.removeAllElements();\n+      m_stringToInt.clear();\n@@ -110,14 +106,2 @@\n-      int hashslot=s.hashCode()%HASHPRIME;\n-      if(hashslot<0) hashslot=-hashslot;\n-\n-      \/\/ Is it one we already know?\n-      int hashlast=m_hashStart[hashslot];\n-      int hashcandidate=hashlast;\n-      while(hashcandidate!=NULL)\n-        {\n-          if(m_intToString.get(hashcandidate).equals(s))\n-            return hashcandidate;\n-\n-          hashlast=hashcandidate;\n-          hashcandidate=m_hashChain.elementAt(hashcandidate);\n-        }\n+      Integer index = m_stringToInt.get(s);\n+      if(index != null) return index;\n@@ -128,6 +112,1 @@\n-\n-      m_hashChain.addElement(NULL);     \/\/ Initialize to no-following-same-hash\n-      if(hashlast==NULL)  \/\/ First for this hash\n-        m_hashStart[hashslot]=newIndex;\n-      else \/\/ Link from previous with same hash\n-        m_hashChain.setElementAt(newIndex,hashlast);\n+      m_stringToInt.put(s, newIndex);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/dtm\/ref\/DTMStringPool.java","additions":9,"deletions":30,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## Apache Xalan v2.7.2\n+## Apache Xalan v2.7.3\n","filename":"src\/java.xml\/share\/legal\/xalan.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}