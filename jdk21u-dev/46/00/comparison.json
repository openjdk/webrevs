{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,4 @@\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.CharsetDecoder;\n+import java.nio.charset.CoderResult;\n@@ -72,0 +76,5 @@\n+    \/\/ For fcharset control word\n+    protected CharsetDecoder decoder = null;\n+    private byte[] ba = new byte[2];\n+    protected ByteBuffer decoderBB = ByteBuffer.wrap(ba);\n+\n@@ -103,0 +112,3 @@\n+    \/\/ Defined for replacement character\n+    static final char REPLACEMENT_CHAR = '\\uFFFD';\n+\n@@ -112,0 +124,3 @@\n+    \/\/ Initialize byte buffer for CharsetDecoder\n+    decoderBB.clear();\n+    decoderBB.limit(1);\n@@ -185,0 +200,3 @@\n+          \/\/ SBCS: ASCII character\n+          \/\/ DBCS: Non lead byte\n+          ch = decode(ch);\n@@ -304,1 +322,3 @@\n-          ch = translationTable[pendingCharacter];\n+          \/\/ Use translationTable if decoder is not defined\n+          ch = decoder == null ? translationTable[pendingCharacter]\n+                               : decode((char)pendingCharacter);\n@@ -363,0 +383,33 @@\n+    \/\/ For fcharset control word\n+    private char[] ca = new char[1];\n+    private CharBuffer decoderCB = CharBuffer.wrap(ca);\n+\n+    private char decode(char ch) {\n+        if (decoder == null) return ch;\n+        decoderBB.put((byte) ch);\n+        decoderBB.rewind();\n+        decoderCB.clear();\n+        CoderResult cr = decoder.decode(decoderBB, decoderCB, false);\n+        if (cr.isUnderflow()) {\n+            if (decoderCB.position() == 1) {\n+                \/\/ Converted to Unicode (including replacement character)\n+                decoder.reset();\n+                decoderBB.clear();\n+                decoderBB.limit(1);\n+                return ca[0];\n+            } else {\n+                \/\/ Detected lead byte\n+                decoder.reset();\n+                decoderBB.limit(2);\n+                decoderBB.position(1);\n+                return 0; \/\/ Skip write operation if return value is 0\n+            }\n+        } else {\n+            \/\/ Fallback, should not be called\n+            decoder.reset();\n+            decoderBB.clear();\n+            decoderBB.limit(1);\n+            return REPLACEMENT_CHAR;\n+        }\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/rtf\/RTFParser.java","additions":55,"deletions":2,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,5 @@\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetDecoder;\n+import java.nio.charset.CodingErrorAction;\n@@ -90,0 +95,4 @@\n+  \/** This Dictionary maps Integer font numbers to Charset font charset. *\/\n+  Dictionary<Integer, Charset> fcharsetTable;\n+  \/** This Dictionary maps String font charset to String code page. *\/\n+  static Dictionary<String, String> fcharsetToCP = null;\n@@ -136,0 +145,1 @@\n+      textKeywords.put(\"line\",       \"\\n\");\n@@ -162,1 +172,44 @@\n-\/* TODO: per-font font encodings ( \\fcharset control word ) ? *\/\n+    \/**\n+     * Windows font charset\n+     *\/\n+    private static final int ANSI_CHARSET        = 0;\n+    private static final int DEFAULT_CHARSET     = 1;\n+    private static final int SYMBOL_CHARSET      = 2;\n+    private static final int MAC_CHARSET         = 77;\n+    private static final int SHIFTJIS_CHARSET    = 128;\n+    private static final int HANGUL_CHARSET      = 129;\n+    private static final int JOHAB_CHARSET       = 130;\n+    private static final int GB2312_CHARSET      = 134;\n+    private static final int CHINESEBIG5_CHARSET = 136;\n+    private static final int GREEK_CHARSET       = 161;\n+    private static final int TURKISH_CHARSET     = 162;\n+    private static final int VIETNAMESE_CHARSET  = 163;\n+    private static final int HEBREW_CHARSET      = 177;\n+    private static final int ARABIC_CHARSET      = 178;\n+    private static final int BALTIC_CHARSET      = 186;\n+    private static final int RUSSIAN_CHARSET     = 204;\n+    private static final int THAI_CHARSET        = 222;\n+    private static final int EASTEUROPE_CHARSET  = 238;\n+    private static final int OEM_CHARSET         = 255;\n+\n+    static {\n+        fcharsetToCP = new Hashtable<String, String>();\n+        fcharsetToCP.put(\"fcharset\" + ANSI_CHARSET, \"windows-1252\");\n+        fcharsetToCP.put(\"fcharset\" + SHIFTJIS_CHARSET, \"ms932\");\n+        fcharsetToCP.put(\"fcharset\" + HANGUL_CHARSET, \"ms949\");\n+        fcharsetToCP.put(\"fcharset\" + JOHAB_CHARSET, \"ms1361\");\n+        fcharsetToCP.put(\"fcharset\" + GB2312_CHARSET, \"ms936\");\n+        fcharsetToCP.put(\"fcharset\" + CHINESEBIG5_CHARSET, \"ms950\");\n+        fcharsetToCP.put(\"fcharset\" + GREEK_CHARSET, \"windows-1253\");\n+        fcharsetToCP.put(\"fcharset\" + TURKISH_CHARSET, \"windows-1254\");\n+        fcharsetToCP.put(\"fcharset\" + VIETNAMESE_CHARSET, \"windows-1258\");\n+        fcharsetToCP.put(\"fcharset\" + HEBREW_CHARSET, \"windows-1255\");\n+        fcharsetToCP.put(\"fcharset\" + ARABIC_CHARSET, \"windows-1256\");\n+        fcharsetToCP.put(\"fcharset\" + BALTIC_CHARSET, \"windows-1257\");\n+        fcharsetToCP.put(\"fcharset\" + RUSSIAN_CHARSET, \"windows-1251\");\n+        fcharsetToCP.put(\"fcharset\" + THAI_CHARSET, \"ms874\");\n+        fcharsetToCP.put(\"fcharset\" + EASTEUROPE_CHARSET, \"windows-1250\");\n+    }\n+\n+    \/\/ Defined for replacement character\n+    private static final String REPLACEMENT_CHAR = \"\\uFFFD\";\n@@ -177,0 +230,1 @@\n+    fcharsetTable = new Hashtable<Integer, Charset>();\n@@ -765,0 +819,19 @@\n+        \/\/ For fcharset control word\n+        if (keyword.equals(\"fcharset\")) {\n+            String fcharset = keyword+parameter;\n+            String csName = fcharsetToCP.get(fcharset);\n+            Charset cs;\n+            if (csName != null) {\n+                try {\n+                    cs = Charset.forName(csName);\n+                } catch (IllegalArgumentException iae) {\n+                    \/\/ Fallback, should not be called\n+                    cs = ISO_8859_1;\n+                }\n+            } else {\n+                \/\/ Fallback, fcharset control word number is not defined\n+                cs = ISO_8859_1;\n+            }\n+            fcharsetTable.put(nextFontNumber, cs);\n+            return true;\n+        }\n@@ -1219,0 +1292,19 @@\n+\n+            \/\/ Check lead byte is stored or not\n+            if (decoderBB.position() == 1) {\n+                handleText(REPLACEMENT_CHAR);\n+            }\n+            \/\/ Reset decoder byte buffer\n+            decoderBB.clear();\n+            decoderBB.limit(1);\n+            \/\/ Check fcharset is used or not\n+            Charset cs = fcharsetTable.get(parameter);\n+            if (cs != null) {\n+                decoder = cs.newDecoder();\n+                decoder.onMalformedInput(CodingErrorAction.REPLACE)\n+                       .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+            } else {\n+                \/\/ fcharset is not used, use translationTable\n+                decoder = null;\n+            }\n+\n@@ -1613,0 +1705,6 @@\n+            \/\/ Check lead byte is stored or not\n+            if (decoderBB.position() == 1) {\n+                handleText(REPLACEMENT_CHAR);\n+                decoderBB.clear();\n+                decoderBB.limit(1);\n+            }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/rtf\/RTFReader.java","additions":100,"deletions":2,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6928542\n+ * @summary Verify RTFEditorKit.read() with fcharset\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStreamReader;\n+import java.io.PrintStream;\n+import javax.swing.text.Document;\n+import javax.swing.text.Element;\n+import javax.swing.text.rtf.RTFEditorKit;\n+\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+\n+public class RTFReadFontCharsetTest {\n+    public static void main(String[] args) throws Exception {\n+        String s =\n+            \"{\\\\rtf1\\\\fbidis\\\\ansi\\\\ansicpg932\\\\deff0\\\\nouicomp\" +\n+            \"at\\\\deflang1033\\\\deflangfe1041{\\\\fonttbl{\\\\f0\\\\fni\" +\n+            \"l\\\\fcharset0 Segoe UI;}{\\\\f1\\\\fnil\\\\fcharset128 Yu\" +\n+            \" Gothic UI;}{\\\\f2\\\\fswiss\\\\fprq2\\\\fcharset129 Malg\" +\n+            \"un Gothic;}{\\\\f3\\\\fnil\\\\fcharset134 Microsoft YaHe\" +\n+            \"i;}{\\\\f4\\\\fnil\\\\fcharset136 Microsoft JhengHei;}{\\\\\" +\n+            \"f5\\\\fnil\\\\fcharset161 Segoe UI;}{\\\\f6\\\\fnil\\\\fcha\" +\n+            \"rset162 Segoe UI;}{\\\\f7\\\\fnil\\\\fcharset163 Segoe U\" +\n+            \"I;}{\\\\f8\\\\fnil\\\\fcharset177 Segoe UI;}{\\\\f9\\\\fnil\\\\\" +\n+            \"fcharset178 Segoe UI;}{\\\\f10\\\\fnil\\\\fcharset186 S\" +\n+            \"egoe UI;}{\\\\f11\\\\fnil\\\\fcharset204 Segoe UI;}{\\\\f1\" +\n+            \"2\\\\fnil\\\\fcharset222 Leelawadee UI;}{\\\\f13\\\\fnil\\\\\" +\n+            \"fcharset0 Leelawadee UI;}{\\\\f14\\\\fnil\\\\fcharset238\" +\n+            \" Segoe UI;}}\\r\\n{\\\\*\\\\generator Riched20 10.0.1904\" +\n+            \"1}\\\\viewkind4\\\\uc1 \\r\\n\\\\pard\\\\ltrpar\\\\nowidctlpar\" +\n+            \"\\\\sa200\\\\sl276\\\\slmult1\\\\f0\\\\fs22\\\\lang1041 Gr\\\\'f\" +\n+            \"cezi -  Switzerland 0\\\\line\\\\f1\\\\'82\\\\'b1\\\\'82\\\\'f\" +\n+            \"1\\\\'82\\\\'c9\\\\'82\\\\'bf\\\\'82\\\\'cd - Japanese 128\\\\li\" +\n+            \"ne\\\\f2\\\\lang17\\\\'be\\\\'c8\\\\'b3\\\\'e7\\\\'c7\\\\'cf\\\\'bc\\\\\" +\n+            \"'bc\\\\'bf\\\\'e4\\\\lang1041  - Korean 129\\\\line\\\\kern\" +\n+            \"ing2\\\\f3\\\\lang1033\\\\'c4\\\\'e3\\\\'ba\\\\'c3 - China 134\" +\n+            \"\\\\line\\\\f4\\\\'bb\\\\'4f\\\\'c6\\\\'57 - Traditional Chine\" +\n+            \"se - Taiwan 136\\\\line\\\\kerning0\\\\f5\\\\lang17\\\\'e3\\\\\" +\n+            \"'e5\\\\'e9\\\\'e1 \\\\'f3\\\\'ef\\\\'f5 - Greek\\\\f0\\\\lang104\" +\n+            \"1  161\\\\line\\\\f6\\\\lang17 A\\\\'f0a\\\\'e7 - \\\\f0 Turki\" +\n+            \"sh (Tree) 162\\\\line\\\\f7\\\\'fe\\\\f0\\\\lang1041  \\\\lang\" +\n+            \"1033 - \\\\lang17 Vietnam currency\\\\lang1041  163\\\\l\" +\n+            \"ine\\\\f8\\\\rtlch\\\\lang17\\\\'f9\\\\'c8\\\\'d1\\\\'ec\\\\'e5\\\\'\" +\n+            \"c9\\\\'ed\\\\f0\\\\ltrch  - Hebrew 177\\\\line\\\\f9\\\\rtlch\\\\\" +\n+            \"lang1025\\\\'e3\\\\'d1\\\\'cd\\\\'c8\\\\'c7\\\\f0\\\\ltrch\\\\lan\" +\n+            \"g17  - Arabic 178\\\\line\\\\kerning2\\\\f10\\\\lang1033 A\" +\n+            \"\\\\'e8i\\\\'fb - Lithuanian (Thank you) 186\\\\kerning0\" +\n+            \"\\\\f0\\\\lang1041\\\\line\\\\kerning2\\\\f11\\\\lang1049\\\\'c7\" +\n+            \"\\\\'e4\\\\'f0\\\\'e0\\\\'e2\\\\'f1\\\\'f2\\\\'e2\\\\'f3\\\\'e9\\\\'f2\" +\n+            \"\\\\'e5\\\\f0\\\\lang1033  - Russian 204\\\\line\\\\kerning0\" +\n+            \"\\\\f12\\\\lang1054\\\\'ca\\\\'c7\\\\'d1\\\\'ca\\\\'b4\\\\'d5 \\\\f1\" +\n+            \"3\\\\lang1033 - Thailand 222\\\\line\\\\kerning2\\\\f14 cz\" +\n+            \"e\\\\'9c\\\\'e6 - Polish 238\\\\par\\r\\n}\\r\\n\\u0000\";\n+        String expected =\n+            \"Gr\\u00fcezi -  Switzerland 0\\n\" +\n+            \"\\u3053\\u3093\\u306b\\u3061\\u306f - Japanese 128\\n\" +\n+            \"\\uc548\\ub155\\ud558\\uc138\\uc694 - Korean 129\\n\" +\n+            \"\\u4f60\\u597d - China 134\\n\" +\n+            \"\\u81fa\\u7063 - Traditional Chinese - Taiwan 136\\n\" +\n+            \"\\u03b3\\u03b5\\u03b9\\u03b1 \\u03c3\\u03bf\\u03c5 - Greek 161\\n\" +\n+            \"A\\u011fa\\u00e7 - Turkish (Tree) 162\\n\" +\n+            \"\\u20ab - Vietnam currency 163\\n\" +\n+            \"\\u05e9\\u05b8\\u05c1\\u05dc\\u05d5\\u05b9\\u05dd - Hebrew 177\\n\" +\n+            \"\\u0645\\u0631\\u062d\\u0628\\u0627 - Arabic 178\\n\" +\n+            \"A\\u010di\\u016b - Lithuanian (Thank you) 186\\n\" +\n+            \"\\u0417\\u0434\\u0440\\u0430\\u0432\\u0441\\u0442\" +\n+            \"\\u0432\\u0443\\u0439\\u0442\\u0435 - Russian 204\\n\" +\n+            \"\\u0e2a\\u0e27\\u0e31\\u0e2a\\u0e14\\u0e35 - Thailand 222\\n\" +\n+            \"cze\\u015b\\u0107 - Polish 238\\n\" +\n+            \"\\n\";\n+        ByteArrayInputStream bais = new ByteArrayInputStream(\n+            s.getBytes(ISO_8859_1));\n+        InputStreamReader isr = new InputStreamReader(bais, ISO_8859_1);\n+        RTFEditorKit kit = new RTFEditorKit();\n+        Document doc = kit.createDefaultDocument();\n+        kit.read(isr, doc, 0);\n+        Element elem = doc.getDefaultRootElement();\n+        int elemStart = elem.getStartOffset();\n+        int elemEnd = elem.getEndOffset();\n+        String text = doc.getText(elemStart, elemEnd - elemStart);\n+        if (!expected.equals(text)) {\n+            System.err.println(\"Read data\");\n+            System.err.println(\"=========\");\n+            dump(text, System.err);\n+            System.err.println(\"Expected data\");\n+            System.err.println(\"=============\");\n+            dump(expected, System.err);\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+\n+    private static void dump(String s, PrintStream ps) {\n+        for(char ch : s.toCharArray()) {\n+            if (ch == '\\\\')\n+                ps.print(\"\\\\\\\\\");\n+            else if (ch >= 0x20 && ch <= 0x7e)\n+                ps.print(ch);\n+            else if (ch == '\\n')\n+                ps.println();\n+            else\n+                ps.printf(\"\\\\u%04x\", (int)ch);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/javax\/swing\/text\/rtf\/RTFReadFontCharsetTest.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"}]}