{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333 7029979 8295753\n+ * @bug 4313887 6838333 7029979\n@@ -35,2 +35,0 @@\n-import static java.nio.file.LinkOption.*;\n-\n@@ -40,2 +38,0 @@\n-    static boolean supportsLinks;\n-\n@@ -45,2 +41,0 @@\n-            supportsLinks = TestUtil.supportsLinks(dir);\n-\n@@ -52,5 +46,0 @@\n-\n-            \/\/ toRealPath method\n-            testToRealPath(dir);\n-\n-\n@@ -95,130 +84,0 @@\n-    \/**\n-     * Exercise toRealPath method\n-     *\/\n-    static void testToRealPath(Path dir) throws IOException {\n-        final Path file = Files.createFile(dir.resolve(\"foo\"));\n-        final Path link = dir.resolve(\"link\");\n-\n-        \/**\n-         * Test: toRealPath() will access same file as toRealPath(NOFOLLOW_LINKS)\n-         *\/\n-        assertTrue(Files.isSameFile(file.toRealPath(), file.toRealPath(NOFOLLOW_LINKS)));\n-\n-        \/**\n-         * Test: toRealPath should fail if file does not exist\n-         *\/\n-        Path doesNotExist = dir.resolve(\"DoesNotExist\");\n-        try {\n-            doesNotExist.toRealPath();\n-            throw new RuntimeException(\"IOException expected\");\n-        } catch (IOException expected) {\n-        }\n-        try {\n-            doesNotExist.toRealPath(NOFOLLOW_LINKS);\n-            throw new RuntimeException(\"IOException expected\");\n-        } catch (IOException expected) {\n-        }\n-\n-        \/**\n-         * Test: toRealPath() should resolve links\n-         *\/\n-        if (supportsLinks) {\n-            Path resolvedFile = file;\n-            if (Platform.isWindows()) {\n-                \/\/ Path::toRealPath does not work with environments using the\n-                \/\/ legacy subst mechanism. This is a workaround to keep the\n-                \/\/ test working if 'dir' points to a location on a subst drive.\n-                \/\/ See JDK-8213216.\n-                \/\/\n-                Path tempLink = dir.resolve(\"tempLink\");\n-                Files.createSymbolicLink(tempLink, dir.toAbsolutePath());\n-                Path resolvedDir = tempLink.toRealPath();\n-                Files.delete(tempLink);\n-                resolvedFile = resolvedDir.resolve(file.getFileName());\n-            }\n-\n-            Files.createSymbolicLink(link, resolvedFile.toAbsolutePath());\n-            assertTrue(link.toRealPath().equals(resolvedFile.toRealPath()));\n-            Files.delete(link);\n-        }\n-\n-        \/**\n-         * Test: toRealPath(NOFOLLOW_LINKS) should not resolve links\n-         *\/\n-        if (supportsLinks) {\n-            Files.createSymbolicLink(link, file.toAbsolutePath());\n-            assertTrue(link.toRealPath(NOFOLLOW_LINKS).getFileName().equals(link.getFileName()));\n-            Files.delete(link);\n-        }\n-\n-        \/**\n-         * Test: toRealPath(NOFOLLOW_LINKS) with broken link\n-         *\/\n-        if (supportsLinks) {\n-            Path broken = Files.createSymbolicLink(link, doesNotExist);\n-            assertTrue(link.toRealPath(NOFOLLOW_LINKS).getFileName().equals(link.getFileName()));\n-            Files.delete(link);\n-        }\n-\n-        \/**\n-         * Test: toRealPath should eliminate \".\"\n-         *\/\n-        assertTrue(dir.resolve(\".\").toRealPath().equals(dir.toRealPath()));\n-        assertTrue(dir.resolve(\".\").toRealPath(NOFOLLOW_LINKS).equals(dir.toRealPath(NOFOLLOW_LINKS)));\n-\n-        \/**\n-         * Test: toRealPath should eliminate \"..\" when it doesn't follow a\n-         *       symbolic link\n-         *\/\n-        Path subdir = Files.createDirectory(dir.resolve(\"subdir\"));\n-        assertTrue(subdir.resolve(\"..\").toRealPath().equals(dir.toRealPath()));\n-        assertTrue(subdir.resolve(\"..\").toRealPath(NOFOLLOW_LINKS).equals(dir.toRealPath(NOFOLLOW_LINKS)));\n-\n-        \/**\n-         * Test: toRealPath yields accurate case of path elements when\n-         *       not following links\n-         *\/\n-        if (Platform.isOSX()) {\n-            \/\/ theTarget = dir\/subdir\/theTarget\n-            Path theTarget = Path.of(subdir.toString(), \"theTarget\");\n-            Files.createFile(theTarget);\n-\n-            \/\/ dir\/theLink -> dir\/subdir\n-            Path theLink = Path.of(dir.toString(), \"theLink\");\n-            Files.createSymbolicLink(theLink, subdir);\n-\n-            \/\/ thePath = dir\/thelink\/thetarget (all lower case)\n-            Path thePath = Path.of(dir.toString(), \"thelink\", \"thetarget\");\n-            Path noFollow = thePath.toRealPath(NOFOLLOW_LINKS);\n-            int nc = noFollow.getNameCount();\n-\n-            \/\/ Real path should retain case as dir\/theLink\/theTarget\n-            assertTrue(noFollow.getName(nc - 2).equals(Path.of(\"theLink\")));\n-            assertTrue(noFollow.getName(nc - 1).equals(Path.of(\"theTarget\")));\n-            assertTrue(noFollow.toString().equals(\n-                Path.of(dir.toString(), \"theLink\", \"theTarget\").toString()));\n-\n-            \/\/ Test where a link is preceded by \"..\" in the path\n-            Path superBeforeLink =\n-                Path.of(subdir.toString(), \"..\", \"thelink\", \"thetarget\");\n-            noFollow = superBeforeLink.toRealPath(NOFOLLOW_LINKS);\n-            nc = noFollow.getNameCount();\n-            assertTrue(noFollow.getName(nc - 2).equals(Path.of(\"theLink\")));\n-            assertTrue(noFollow.getName(nc - 1).equals(Path.of(\"theTarget\")));\n-\n-            \/\/ Test where a link is followed by \"..\" in the path\n-            Path linkBeforeSuper =\n-                Path.of(dir.toString(), \"thelink\", \"..\", \"subdir\", \"thetarget\");\n-            noFollow = linkBeforeSuper.toRealPath(NOFOLLOW_LINKS);\n-            nc = noFollow.getNameCount();\n-            assertTrue(noFollow.getName(nc - 4).equals(Path.of(\"theLink\")));\n-            assertTrue(noFollow.getName(nc - 1).equals(Path.of(\"theTarget\")));\n-\n-            Files.delete(theTarget);\n-        }\n-\n-        \/\/ clean-up\n-        Files.delete(subdir);\n-        Files.delete(file);\n-    }\n-\n","filename":"test\/jdk\/java\/nio\/file\/Path\/Misc.java","additions":2,"deletions":143,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8295753\n+ * @summary Verify correct operation of Path.toRealPath\n+ * @library .. \/test\/lib\n+ * @build ToRealPath jdk.test.lib.Platform\n+ * @run junit ToRealPath\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import jdk.test.lib.Platform;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.EnabledIf;\n+import org.junit.jupiter.api.condition.EnabledOnOs;\n+import org.junit.jupiter.api.condition.OS;\n+\n+import static java.nio.file.LinkOption.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ToRealPath {\n+    static final boolean SUPPORTS_LINKS;\n+    static final Path DIR;\n+    static final Path SUBDIR;\n+    static final Path FILE;\n+    static final Path LINK;\n+\n+    static {\n+        try {\n+            DIR = TestUtil.createTemporaryDirectory();\n+            SUBDIR = Files.createDirectory(DIR.resolve(\"subdir\"));\n+            FILE = Files.createFile(DIR.resolve(\"foo\"));\n+            LINK = DIR.resolve(\"link\");\n+            SUPPORTS_LINKS = TestUtil.supportsLinks(DIR);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    };\n+\n+    public boolean supportsLinks() {\n+        return SUPPORTS_LINKS;\n+    }\n+\n+    @Test\n+    public void locateSameFile() throws IOException {\n+        assertTrue(Files.isSameFile(FILE.toRealPath(),\n+                                    FILE.toRealPath(NOFOLLOW_LINKS)));\n+    }\n+\n+    @Test\n+    public void failNotExist() {\n+        Path doesNotExist = DIR.resolve(\"DoesNotExist\");\n+        assertThrows(IOException.class, () -> doesNotExist.toRealPath());\n+    }\n+\n+    @Test\n+    public void failNotExistNoFollow() {\n+        Path doesNotExist = DIR.resolve(\"DoesNotExist\");\n+        assertThrows(IOException.class,\n+                     () -> doesNotExist.toRealPath(NOFOLLOW_LINKS));\n+    }\n+\n+    @EnabledIf(\"supportsLinks\")\n+    @Test\n+    public void shouldResolveLinks() throws IOException {\n+        Path resolvedFile = FILE;\n+        if (Platform.isWindows()) {\n+            \/\/ Path::toRealPath does not work with environments using the\n+            \/\/ legacy subst mechanism. This is a workaround to keep the\n+            \/\/ test working if 'dir' points to a location on a subst drive.\n+            \/\/ See JDK-8213216.\n+            \/\/\n+            Path tempLink = DIR.resolve(\"tempLink\");\n+            Files.createSymbolicLink(tempLink, DIR.toAbsolutePath());\n+            Path resolvedDir = tempLink.toRealPath();\n+            Files.delete(tempLink);\n+            resolvedFile = resolvedDir.resolve(FILE.getFileName());\n+        }\n+\n+        Files.createSymbolicLink(LINK, resolvedFile.toAbsolutePath());\n+        assertTrue(LINK.toRealPath().equals(resolvedFile.toRealPath()));\n+        Files.delete(LINK);\n+    }\n+\n+    @Test\n+    @EnabledIf(\"supportsLinks\")\n+    public void shouldNotResolveLinks() throws IOException {\n+        Files.createSymbolicLink(LINK, FILE.toAbsolutePath());\n+        assertEquals(LINK.toRealPath(NOFOLLOW_LINKS).getFileName(),\n+                     LINK.getFileName());\n+        Files.delete(LINK);\n+    }\n+\n+    @Test\n+    public void eliminateDot() throws IOException {\n+        assertEquals(DIR.resolve(\".\").toRealPath(),\n+                     DIR.toRealPath());\n+    }\n+\n+    @Test\n+    public void eliminateDotNoFollow() throws IOException {\n+        assertEquals(DIR.resolve(\".\").toRealPath(NOFOLLOW_LINKS),\n+                     DIR.toRealPath(NOFOLLOW_LINKS));\n+    }\n+\n+    @Test\n+    public void eliminateDots() throws IOException {\n+        assertEquals(SUBDIR.resolve(\"..\").toRealPath(),\n+                     DIR.toRealPath());\n+    }\n+\n+    @Test\n+    public void eliminateDotsNoFollow() throws IOException {\n+        assertEquals(SUBDIR.resolve(\"..\").toRealPath(NOFOLLOW_LINKS),\n+                     DIR.toRealPath(NOFOLLOW_LINKS));\n+    }\n+\n+    @Test\n+    @EnabledOnOs(OS.MAC)\n+    public final void macOSTests() throws IOException {\n+        \/\/ theTarget = dir\/subdir\/theTarget\n+        Path theTarget = Path.of(SUBDIR.toString(), \"theTarget\");\n+        Files.createFile(theTarget);\n+\n+        \/\/ dir\/theLink -> dir\/subdir\n+        Path theLink = Path.of(DIR.toString(), \"theLink\");\n+        Files.createSymbolicLink(theLink, SUBDIR);\n+\n+        \/\/ thePath = dir\/thelink\/thetarget (all lower case)\n+        Path thePath = Path.of(DIR.toString(), \"thelink\", \"thetarget\");\n+        Path noFollow = thePath.toRealPath(NOFOLLOW_LINKS);\n+        int nc = noFollow.getNameCount();\n+\n+        \/\/ Real path should retain case as dir\/theLink\/theTarget\n+        assertEquals(noFollow.getName(nc - 2), Path.of(\"theLink\"));\n+        assertEquals(noFollow.getName(nc - 1), Path.of(\"theTarget\"));\n+        assertEquals(noFollow.toString(),\n+                     Path.of(DIR.toString(), \"theLink\", \"theTarget\").toString());\n+\n+        \/\/ Test where a link is preceded by \"..\" in the path\n+        Path superBeforeLink =\n+            Path.of(SUBDIR.toString(), \"..\", \"thelink\", \"thetarget\");\n+        noFollow = superBeforeLink.toRealPath(NOFOLLOW_LINKS);\n+        nc = noFollow.getNameCount();\n+        assertEquals(noFollow.getName(nc - 2), Path.of(\"theLink\"));\n+        assertEquals(noFollow.getName(nc - 1), Path.of(\"theTarget\"));\n+\n+        \/\/ Test where a link is followed by \"..\" in the path\n+        Path linkBeforeSuper =\n+            Path.of(DIR.toString(), \"thelink\", \"..\", \"subdir\", \"thetarget\");\n+        noFollow = linkBeforeSuper.toRealPath(NOFOLLOW_LINKS);\n+        nc = noFollow.getNameCount();\n+        assertEquals(noFollow.getName(nc - 4), Path.of(\"theLink\"));\n+        assertEquals(noFollow.getName(nc - 1), Path.of(\"theTarget\"));\n+\n+        Files.delete(theTarget);\n+    }\n+\n+    @AfterAll\n+    public static void cleanup() throws IOException {\n+        Files.delete(SUBDIR);\n+        Files.delete(FILE);\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Path\/ToRealPath.java","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"}]}