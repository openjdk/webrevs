{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,0 +143,1 @@\n+                && profileClass != ICC_Profile.CLASS_DEVICELINK\n@@ -146,1 +147,1 @@\n-            throw new IllegalArgumentException(\"Invalid profile type\");\n+            throw new IllegalArgumentException(\"Invalid profile class\");\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_ColorSpace.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -762,0 +762,1 @@\n+    private static final int HEADER_SIZE = 128;\n@@ -792,0 +793,4 @@\n+            byte[] theHeader = new byte[HEADER_SIZE];\n+            System.arraycopy(data, 0, theHeader, 0, HEADER_SIZE);\n+            verifyHeader(theHeader);\n+\n@@ -796,0 +801,1 @@\n+\n@@ -981,0 +987,4 @@\n+        return getProfileClass(theHeader);\n+    }\n+\n+    private static int getProfileClass(byte[] theHeader) {\n@@ -1022,0 +1032,5 @@\n+    private static int getColorSpaceType(byte[] theHeader) {\n+        int theColorSpaceSig = intFromBigEndian(theHeader, icHdrColorSpace);\n+        return iccCStoJCS(theColorSpaceSig);\n+    }\n+\n@@ -1041,0 +1056,15 @@\n+    private static int getPCSType(byte[] theHeader) {\n+        int thePCSSig = intFromBigEndian(theHeader, icHdrPcs);\n+        int theDeviceClass = intFromBigEndian(theHeader, icHdrDeviceClass);\n+\n+        if (theDeviceClass == icSigLinkClass) {\n+            return iccCStoJCS(thePCSSig);\n+        } else {\n+            return switch (thePCSSig) {\n+                case icSigXYZData -> ColorSpace.TYPE_XYZ;\n+                case icSigLabData -> ColorSpace.TYPE_Lab;\n+                default -> throw new IllegalArgumentException(\"Unexpected PCS type\");\n+            };\n+        }\n+    }\n+\n@@ -1121,0 +1151,3 @@\n+        if (tagSignature == ICC_Profile.icSigHead) {\n+            verifyHeader(tagData);\n+        }\n@@ -1124,0 +1157,30 @@\n+    private static void verifyHeader(byte[] data) {\n+        if (data == null || data.length < HEADER_SIZE) {\n+            throw new IllegalArgumentException(\"Invalid header data\");\n+        }\n+        getProfileClass(data);\n+        getColorSpaceType(data);\n+        getPCSType(data);\n+        checkRenderingIntent(data);\n+    }\n+\n+    private static boolean checkRenderingIntent(byte[] header) {\n+        int index = ICC_Profile.icHdrRenderingIntent;\n+\n+        \/* According to ICC spec, only the least-significant 16 bits shall be\n+         * used to encode the rendering intent. The most significant 16 bits\n+         * shall be set to zero. Thus, we are ignoring two most significant\n+         * bytes here. Please refer ICC Spec Document for more details.\n+         *\/\n+        int renderingIntent = ((header[index+2] & 0xff) <<  8) |\n+                              (header[index+3] & 0xff);\n+\n+        switch (renderingIntent) {\n+            case icPerceptual, icMediaRelativeColorimetric,\n+                    icSaturation, icAbsoluteColorimetric -> {\n+                return true;\n+            }\n+            default -> throw new IllegalArgumentException(\"Unknown Rendering Intent\");\n+        }\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/color\/ICC_Profile.java","additions":64,"deletions":1,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -0,0 +1,261 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8337703\n+ * @summary To verify if ICC_Profile's setData() and getInstance() methods\n+ *          validate header data and throw IAE for invalid values.\n+ * @run main ValidateICCHeaderData\n+ *\/\n+\n+import java.awt.color.ColorSpace;\n+import java.awt.color.ICC_Profile;\n+import java.awt.image.BufferedImage;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.ByteBuffer;\n+\n+public class ValidateICCHeaderData {\n+    private static ICC_Profile profile;\n+\n+    private static final boolean DEBUG = false;\n+    private static final int VALID_HEADER_SIZE = 128;\n+    private static final int HEADER_TAG = ICC_Profile.icSigHead;\n+    private static final int PROFILE_CLASS_START_INDEX = ICC_Profile.icHdrDeviceClass;\n+    private static final int COLOR_SPACE_START_INDEX = ICC_Profile.icHdrColorSpace;\n+    private static final int RENDER_INTENT_START_INDEX = ICC_Profile.icHdrRenderingIntent;\n+    private static final int PCS_START_INDEX = ICC_Profile.icHdrPcs;\n+\n+    private static final int[] VALID_PROFILE_CLASS = new int[] {\n+            ICC_Profile.icSigInputClass, ICC_Profile.icSigDisplayClass,\n+            ICC_Profile.icSigOutputClass, ICC_Profile.icSigLinkClass,\n+            ICC_Profile.icSigAbstractClass, ICC_Profile.icSigColorSpaceClass,\n+            ICC_Profile.icSigNamedColorClass\n+    };\n+\n+    private static final int[] VALID_COLOR_SPACE = new int[] {\n+            ICC_Profile.icSigXYZData, ICC_Profile.icSigLabData,\n+            ICC_Profile.icSigLuvData, ICC_Profile.icSigYCbCrData,\n+            ICC_Profile.icSigYxyData, ICC_Profile.icSigRgbData,\n+            ICC_Profile.icSigGrayData, ICC_Profile.icSigHsvData,\n+            ICC_Profile.icSigHlsData, ICC_Profile.icSigCmykData,\n+            ICC_Profile.icSigSpace2CLR, ICC_Profile.icSigSpace3CLR,\n+            ICC_Profile.icSigSpace4CLR, ICC_Profile.icSigSpace5CLR,\n+            ICC_Profile.icSigSpace6CLR, ICC_Profile.icSigSpace7CLR,\n+            ICC_Profile.icSigSpace8CLR, ICC_Profile.icSigSpace9CLR,\n+            ICC_Profile.icSigSpaceACLR, ICC_Profile.icSigSpaceBCLR,\n+            ICC_Profile.icSigSpaceCCLR, ICC_Profile.icSigSpaceDCLR,\n+            ICC_Profile.icSigSpaceECLR, ICC_Profile.icSigSpaceFCLR,\n+            ICC_Profile.icSigCmyData\n+    };\n+\n+    private static final int[] VALID_RENDER_INTENT = new int[] {\n+            ICC_Profile.icPerceptual, ICC_Profile.icMediaRelativeColorimetric,\n+            ICC_Profile.icSaturation, ICC_Profile.icAbsoluteColorimetric\n+    };\n+\n+    private static void createCopyOfBuiltInProfile() {\n+        ICC_Profile builtInProfile = ICC_Profile.getInstance(ColorSpace.CS_sRGB);\n+        \/\/copy of SRGB BuiltIn Profile that can be modified\n+        \/\/using ICC_Profile.setData()\n+        profile = ICC_Profile.getInstance(builtInProfile.getData());\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        createCopyOfBuiltInProfile();\n+\n+        System.out.println(\"CASE 1: Testing VALID Profile Classes ...\");\n+        testValidHeaderData(VALID_PROFILE_CLASS, PROFILE_CLASS_START_INDEX, 4);\n+        System.out.println(\"CASE 1: Passed \\n\");\n+\n+        \/\/ PCS field validation for Profile class != DEVICE_LINK\n+        System.out.println(\"CASE 2: Testing VALID PCS Type\"\n+                           + \" for Profile class != DEVICE_LINK ...\");\n+        testValidHeaderData(new int[] {ICC_Profile.icSigXYZData, ICC_Profile.icSigLabData},\n+                PCS_START_INDEX, 4);\n+        System.out.println(\"CASE 2: Passed \\n\");\n+\n+        System.out.println(\"CASE 3: Testing INVALID PCS Type\"\n+                           + \" for Profile class != DEVICE_LINK ...\");\n+        testInvalidHeaderData(ICC_Profile.icSigCmykData, PCS_START_INDEX, 4);\n+        System.out.println(\"CASE 3: Passed \\n\");\n+\n+        System.out.println(\"CASE 4: Testing DEVICE LINK PROFILE CLASS ...\");\n+        testValidHeaderData(new int[] {ICC_Profile.icSigLinkClass},\n+                PROFILE_CLASS_START_INDEX, 4);\n+        \/\/to check if instantiating BufferedImage with\n+        \/\/ICC_Profile device class = CLASS_DEVICELINK does not throw IAE.\n+        BufferedImage img = new BufferedImage(100, 100,\n+                                              BufferedImage.TYPE_3BYTE_BGR);\n+        System.out.println(\"CASE 4: Passed \\n\");\n+\n+        \/\/ PCS field validation for Profile class == DEVICE_LINK\n+        System.out.println(\"CASE 5: Testing VALID PCS Type\"\n+                           + \" for Profile class == DEVICE_LINK ...\");\n+        testValidHeaderData(VALID_COLOR_SPACE, PCS_START_INDEX, 4);\n+        System.out.println(\"CASE 5: Passed \\n\");\n+\n+        System.out.println(\"CASE 6: Testing INVALID PCS Type\"\n+                           + \" for Profile class == DEVICE_LINK ...\");\n+        \/\/original icSigLabData = 0x4C616220\n+        int invalidSigLabData = 0x4C616221;\n+        testInvalidHeaderData(invalidSigLabData, PCS_START_INDEX, 4);\n+        System.out.println(\"CASE 6: Passed \\n\");\n+\n+        System.out.println(\"CASE 7: Testing VALID Color Spaces ...\");\n+        testValidHeaderData(VALID_COLOR_SPACE, COLOR_SPACE_START_INDEX, 4);\n+        System.out.println(\"CASE 7: Passed \\n\");\n+\n+        System.out.println(\"CASE 8: Testing VALID Rendering Intent ...\");\n+        testValidHeaderData(VALID_RENDER_INTENT, RENDER_INTENT_START_INDEX, 4);\n+        System.out.println(\"CASE 8: Passed \\n\");\n+\n+        System.out.println(\"CASE 9: Testing INVALID Profile Class ...\");\n+        \/\/original icSigInputClass = 0x73636E72\n+        int invalidSigInputClass = 0x73636E70;\n+        testInvalidHeaderData(invalidSigInputClass, PROFILE_CLASS_START_INDEX, 4);\n+        System.out.println(\"CASE 9: Passed \\n\");\n+\n+        System.out.println(\"CASE 10: Testing INVALID Color Space ...\");\n+        \/\/original icSigXYZData = 0x58595A20\n+        int invalidSigXYZData = 0x58595A21;\n+        testInvalidHeaderData(invalidSigXYZData, COLOR_SPACE_START_INDEX, 4);\n+        System.out.println(\"CASE 10: Passed \\n\");\n+\n+        System.out.println(\"CASE 11: Testing INVALID Rendering Intent ...\");\n+        \/\/valid rendering intent values are 0-3\n+        int invalidRenderIntent = 5;\n+        testInvalidHeaderData(invalidRenderIntent, RENDER_INTENT_START_INDEX, 4);\n+        System.out.println(\"CASE 11: Passed \\n\");\n+\n+        System.out.println(\"CASE 12: Testing INVALID Header Size ...\");\n+        testInvalidHeaderSize();\n+        System.out.println(\"CASE 12: Passed \\n\");\n+\n+        System.out.println(\"CASE 13: Testing ICC_Profile.getInstance(..)\"\n+                           + \" with VALID profile data ...\");\n+        testProfileCreation(true);\n+        System.out.println(\"CASE 13: Passed \\n\");\n+\n+        System.out.println(\"CASE 14: Testing ICC_Profile.getInstance(..)\"\n+                           + \" with INVALID profile data ...\");\n+        testProfileCreation(false);\n+        System.out.println(\"CASE 14: Passed \\n\");\n+\n+        System.out.println(\"CASE 15: Testing Deserialization of ICC_Profile ...\");\n+        testDeserialization();\n+        System.out.println(\"CASE 15: Passed \\n\");\n+\n+        System.out.println(\"Successfully completed testing all 15 cases. Test Passed !!\");\n+    }\n+\n+    private static void testValidHeaderData(int[] validData, int startIndex,\n+                                            int fieldLength) {\n+        for (int value : validData) {\n+            setTag(value, startIndex, fieldLength);\n+        }\n+    }\n+\n+    private static void testInvalidHeaderData(int invalidData, int startIndex,\n+                                              int fieldLength) {\n+        try {\n+            setTag(invalidData, startIndex, fieldLength);\n+            throw new RuntimeException(\"Test Failed ! Expected IAE NOT thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            System.out.println(\"Expected IAE thrown: \" + iae.getMessage());\n+        }\n+    }\n+\n+    private static void setTag(int value, int startIndex, int fieldLength) {\n+        byte[] byteArray;\n+        if (startIndex == RENDER_INTENT_START_INDEX) {\n+            byteArray = ByteBuffer.allocate(4).putInt(value).array();\n+        } else {\n+            BigInteger big = BigInteger.valueOf(value);\n+            byteArray = (big.toByteArray());\n+        }\n+\n+        if (DEBUG) {\n+            System.out.print(\"Byte Array : \");\n+            for (int i = 0; i < byteArray.length; i++) {\n+                System.out.print(byteArray[i] + \" \");\n+            }\n+            System.out.println(\"\\n\");\n+        }\n+\n+        byte[] iccProfileHeaderData = profile.getData(HEADER_TAG);\n+        System.arraycopy(byteArray, 0, iccProfileHeaderData, startIndex, fieldLength);\n+        profile.setData(HEADER_TAG, iccProfileHeaderData);\n+    }\n+\n+    private static void testProfileCreation(boolean validCase) {\n+        ICC_Profile builtInProfile = ICC_Profile.getInstance(ColorSpace.CS_GRAY);\n+        byte[] profileData = builtInProfile.getData();\n+\n+        int validDeviceClass = ICC_Profile.icSigInputClass;\n+        BigInteger big = BigInteger.valueOf(validDeviceClass);\n+        \/\/valid case set device class to 0x73636E72 (icSigInputClass)\n+        \/\/invalid case set device class to 0x00000000\n+        byte[] field = validCase ? big.toByteArray()\n+                                 : ByteBuffer.allocate(4).putInt(0).array();\n+        System.arraycopy(field, 0, profileData, PROFILE_CLASS_START_INDEX, 4);\n+\n+        try {\n+            ICC_Profile.getInstance(profileData);\n+            if (!validCase) {\n+                throw new RuntimeException(\"Test Failed ! Expected IAE NOT thrown\");\n+            }\n+        } catch (IllegalArgumentException iae) {\n+            if (!validCase) {\n+                System.out.println(\"Expected IAE thrown: \" + iae.getMessage());\n+            } else {\n+                throw new RuntimeException(\"Unexpected IAE thrown\");\n+            }\n+        }\n+    }\n+\n+    private static void testInvalidHeaderSize() {\n+        byte[] iccProfileHeaderData = profile.getData(HEADER_TAG);\n+        byte[] invalidHeaderSize = new byte[VALID_HEADER_SIZE - 1];\n+        System.arraycopy(iccProfileHeaderData, 0,\n+                invalidHeaderSize, 0, invalidHeaderSize.length);\n+        try {\n+            profile.setData(HEADER_TAG, invalidHeaderSize);\n+            throw new RuntimeException(\"Test Failed ! Expected IAE NOT thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            System.out.println(\"Expected IAE thrown: \" + iae.getMessage());\n+        }\n+    }\n+\n+    private static void testDeserialization() throws IOException {\n+        \/\/invalidSRGB.icc is serialized on older version of JDK\n+        \/\/Upon deserialization, the invalid profile is expected to throw IAE\n+        try {\n+            ICC_Profile.getInstance(\".\/invalidSRGB.icc\");\n+            throw new RuntimeException(\"Test Failed ! Expected IAE NOT thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            System.out.println(\"Expected IAE thrown: \" + iae.getMessage());\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/ValidateICCHeaderData\/ValidateICCHeaderData.java","additions":261,"deletions":0,"binary":false,"changes":261,"status":"added"},{"filename":"test\/jdk\/java\/awt\/color\/ICC_Profile\/ValidateICCHeaderData\/invalidSRGB.icc","binary":true,"previous_filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/profiles\/sRGB.pf","status":"copied"}]}