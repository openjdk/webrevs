{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8206929 8212885\n+ * @bug 8206929 8212885 8333857\n@@ -50,0 +50,3 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n@@ -59,0 +62,1 @@\n+    static TestMode testMode;\n@@ -61,1 +65,2 @@\n-        new ResumeChecksClient(TestMode.valueOf(args[0])).run();\n+        testMode = TestMode.valueOf(args[0]);\n+        new ResumeChecksClient().test();\n@@ -64,8 +69,2 @@\n-    private final TestMode testMode;\n-    public ResumeChecksClient(TestMode mode) {\n-        this.testMode = mode;\n-    }\n-\n-    private void run() throws Exception {\n-        Server server = startServer();\n-        server.signal();\n+    private void test() throws Exception {\n+        Server server = new Server();\n@@ -73,4 +72,7 @@\n-        while (!server.started) {\n-            Thread.yield();\n-        }\n-        SSLSession firstSession = connect(sslContext, server.port, testMode, false);\n+        HexFormat hex = HexFormat.of();\n+        long firstStartTime = System.currentTimeMillis();\n+        SSLSession firstSession = connect(sslContext, server.port, true);\n+        System.err.println(\"firstStartTime = \" + firstStartTime);\n+        System.err.println(\"firstId = \" + hex.formatHex(firstSession.getId()));\n+        System.err.println(\"firstSession.getCreationTime() = \" +\n+            firstSession.getCreationTime());\n@@ -78,1 +80,0 @@\n-        server.signal();\n@@ -80,5 +81,6 @@\n-        Thread.sleep(10);\n-        SSLSession secondSession = connect(sslContext, server.port, testMode, true);\n-\n-        server.go = false;\n-        server.signal();\n+        SSLSession secondSession = connect(sslContext, server.port, false);\n+        System.err.println(\"secondStartTime = \" + secondStartTime);\n+        \/\/ Note: Ids will never match with TLS 1.3 due to spec\n+        System.err.println(\"secondId = \" + hex.formatHex(secondSession.getId()));\n+        System.err.println(\"secondSession.getCreationTime() = \" +\n+            secondSession.getCreationTime());\n@@ -89,1 +91,7 @@\n-            checkResumedSession(firstSession, secondSession);\n+            try {\n+                checkResumedSession(firstSession, secondSession);\n+            } catch (Exception e) {\n+                throw new AssertionError(\"secondSession did not resume: FAIL\",\n+                    e);\n+            }\n+            System.out.println(\"secondSession used resumption: PASS\");\n@@ -96,2 +104,8 @@\n-            if (secondSession.getCreationTime() <= secondStartTime) {\n-                throw new RuntimeException(\"Existing session was used\");\n+            try {\n+                checkResumedSession(firstSession, secondSession);\n+                System.err.println(\"firstSession  = \" + firstSession);\n+                System.err.println(\"secondSession = \" + secondSession);\n+                throw new AssertionError(\"Second connection should not \" +\n+                    \"have resumed first session:  FAIL\");\n+            } catch (Exception e) {\n+                System.out.println(\"secondSession didn't use resumption: PASS\");\n@@ -101,1 +115,1 @@\n-            throw new RuntimeException(\"unknown mode: \" + testMode);\n+            throw new AssertionError(\"unknown mode: \" + testMode);\n@@ -137,1 +151,1 @@\n-        TestMode mode, boolean second) {\n+        boolean first) {\n@@ -144,38 +158,16 @@\n-            switch (mode) {\n-            case BASIC:\n-                \/\/ do nothing to ensure resumption works\n-                break;\n-            case VERSION_2_TO_3:\n-                if (second) {\n-                    params.setProtocols(new String[] {\"TLSv1.3\"});\n-                } else {\n-                    params.setProtocols(new String[] {\"TLSv1.2\"});\n-                }\n-                break;\n-            case VERSION_3_TO_2:\n-                if (second) {\n-                    params.setProtocols(new String[] {\"TLSv1.2\"});\n-                } else {\n-                    params.setProtocols(new String[] {\"TLSv1.3\"});\n-                }\n-                break;\n-            case CIPHER_SUITE:\n-                if (second) {\n-                    params.setCipherSuites(\n-                        new String[] {\"TLS_AES_256_GCM_SHA384\"});\n-                } else {\n-                    params.setCipherSuites(\n-                        new String[] {\"TLS_AES_128_GCM_SHA256\"});\n-                }\n-                break;\n-            case SIGNATURE_SCHEME:\n-                AlgorithmConstraints constraints =\n-                    params.getAlgorithmConstraints();\n-                if (second) {\n-                    params.setAlgorithmConstraints(new NoSig(\"ecdsa\"));\n-                } else {\n-                    params.setAlgorithmConstraints(new NoSig(\"rsa\"));\n-                }\n-                break;\n-            default:\n-                throw new RuntimeException(\"unknown mode: \" + mode);\n+            switch (testMode) {\n+                case BASIC -> {}  \/\/ do nothing\n+                case VERSION_2_TO_3 -> params.setProtocols(new String[]{\n+                    first ? \"TLSv1.2\" : \"TLSv1.3\"});\n+                case VERSION_3_TO_2 -> params.setProtocols(new String[]{\n+                    first ? \"TLSv1.3\" : \"TLSv1.2\"});\n+                case CIPHER_SUITE -> params.setCipherSuites(\n+                    new String[]{\n+                        first ? \"TLS_AES_128_GCM_SHA256\" :\n+                            \"TLS_AES_256_GCM_SHA384\"});\n+                case SIGNATURE_SCHEME ->\n+                    params.setAlgorithmConstraints(new NoSig(\n+                        first ? \"rsa\" : \"ecdsa\"));\n+                default ->\n+                    throw new AssertionError(\"unknown mode: \" +\n+                        testMode);\n@@ -198,1 +190,1 @@\n-            throw new RuntimeException(ex);\n+            throw new AssertionError(ex);\n@@ -277,12 +269,5 @@\n-    private static Server startServer() {\n-        Server server = new Server();\n-        new Thread(server).start();\n-        return server;\n-    }\n-\n-    private static class Server extends SSLContextTemplate implements Runnable {\n-\n-        public volatile boolean go = true;\n-        private boolean signal = false;\n-        public volatile int port = 0;\n-        public volatile boolean started = false;\n+    private static class Server extends SSLContextTemplate {\n+        public int port;\n+        private final SSLServerSocket ssock;\n+        ExecutorService threadPool = Executors.newFixedThreadPool(1);\n+        CountDownLatch serverLatch = new CountDownLatch(1);\n@@ -290,17 +275,1 @@\n-        private synchronized void waitForSignal() {\n-            while (!signal) {\n-                try {\n-                    wait();\n-                } catch (InterruptedException ex) {\n-                    \/\/ do nothing\n-                }\n-            }\n-            signal = false;\n-        }\n-        public synchronized void signal() {\n-            signal = true;\n-            notify();\n-        }\n-\n-        @Override\n-        public void run() {\n+        Server() {\n@@ -308,1 +277,0 @@\n-\n@@ -311,3 +279,2 @@\n-                SSLServerSocket ssock = (SSLServerSocket)\n-                    fac.createServerSocket(0);\n-                this.port = ssock.getLocalPort();\n+                ssock = (SSLServerSocket) fac.createServerSocket(0);\n+                port = ssock.getLocalPort();\n@@ -315,3 +282,2 @@\n-                waitForSignal();\n-                started = true;\n-                while (go) {\n+                \/\/ Thread to allow multiple clients to connect\n+                new Thread(() -> {\n@@ -319,11 +285,6 @@\n-                        System.out.println(\"Waiting for connection\");\n-                        Socket sock = ssock.accept();\n-                        BufferedReader reader = new BufferedReader(\n-                            new InputStreamReader(sock.getInputStream()));\n-                        String line = reader.readLine();\n-                        System.out.println(\"server read: \" + line);\n-                        PrintWriter out = new PrintWriter(\n-                            new OutputStreamWriter(sock.getOutputStream()));\n-                        out.println(line);\n-                        out.flush();\n-                        waitForSignal();\n+                        System.err.println(\"Server starting to accept\");\n+                        serverLatch.countDown();\n+                        do {\n+                            threadPool.submit(\n+                                new ServerThread((SSLSocket) ssock.accept()));\n+                        } while (true);\n@@ -331,1 +292,3 @@\n-                        ex.printStackTrace();\n+                        throw new AssertionError(\"Server Down\", ex);\n+                    } finally {\n+                        threadPool.close();\n@@ -333,0 +296,29 @@\n+                }).start();\n+\n+            } catch (Exception e) {\n+                throw new AssertionError(e);\n+            }\n+        }\n+\n+        static class ServerThread extends Thread {\n+            SSLSocket sock;\n+\n+            ServerThread(SSLSocket s) {\n+                this.sock = s;\n+                System.err.println(\"(Server) client connection on port \" +\n+                    sock.getPort());\n+            }\n+\n+            public void run() {\n+                try {\n+                    BufferedReader reader = new BufferedReader(\n+                        new InputStreamReader(sock.getInputStream()));\n+                    String line = reader.readLine();\n+                    System.out.println(\"server read: \" + line);\n+                    PrintWriter out = new PrintWriter(\n+                        new OutputStreamWriter(sock.getOutputStream()));\n+                    out.println(line);\n+                    out.flush();\n+                    out.close();\n+                } catch (Exception e) {\n+                    throw new AssertionError(\"Server thread error\", e);\n@@ -334,2 +326,0 @@\n-            } catch (Exception ex) {\n-                throw new RuntimeException(ex);\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/ResumeChecksClient.java","additions":105,"deletions":115,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8206929\n+ * @bug 8206929 8333857\n@@ -51,0 +51,3 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n@@ -63,5 +66,3 @@\n-    public static void main(String[] args) throws Exception {\n-\n-        new ResumeChecksServer(TestMode.valueOf(args[0])).run();\n-    }\n-    private final TestMode testMode;\n+    static CountDownLatch latch = new CountDownLatch(1);\n+    static TestMode testMode;\n+    static int serverPort;\n@@ -69,2 +70,3 @@\n-    public ResumeChecksServer(TestMode testMode) {\n-        this.testMode = testMode;\n+    public static void main(String[] args) throws Exception {\n+        testMode = TestMode.valueOf(args[0]);\n+        new ResumeChecksServer().test();\n@@ -73,2 +75,3 @@\n-    private void run() throws Exception {\n-        SSLSession secondSession = null;\n+    private void test() throws Exception {\n+        SSLSession firstSession, secondSession;\n+        HexFormat hex = HexFormat.of();\n@@ -76,4 +79,3 @@\n-        SSLContext sslContext = createServerSSLContext();\n-        ServerSocketFactory fac = sslContext.getServerSocketFactory();\n-        SSLServerSocket ssock = (SSLServerSocket)\n-            fac.createServerSocket(0);\n+        serverPort = new Server().port;\n+        latch.await();\n+        Client c = new Client(serverPort);\n@@ -81,1 +83,3 @@\n-        Client client = startClient(ssock.getLocalPort());\n+        System.out.println(\"Waiting for connection\");\n+        long firstStartTime = System.currentTimeMillis();\n+        firstSession = c.test();\n@@ -83,5 +87,4 @@\n-        try {\n-            connect(client, ssock, testMode, false);\n-        } catch (Exception ex) {\n-            throw new RuntimeException(ex);\n-        }\n+        System.err.println(\"firstStartTime = \" + firstStartTime);\n+        System.err.println(\"firstId = \" + hex.formatHex(firstSession.getId()));\n+        System.err.println(\"firstSession.getCreationTime() = \" +\n+            firstSession.getCreationTime());\n@@ -90,8 +93,1 @@\n-        Thread.sleep(10);\n-        try {\n-            secondSession = connect(client, ssock, testMode, true);\n-        } catch (SSLHandshakeException ex) {\n-            \/\/ this is expected\n-        } catch (Exception ex) {\n-            throw new RuntimeException(ex);\n-        }\n+        secondSession = c.test();\n@@ -99,2 +95,5 @@\n-        client.go = false;\n-        client.signal();\n+        System.err.println(\"secondStartTime = \" + secondStartTime);\n+        \/\/ Note: Ids will never match with TLS 1.3 due to spec\n+        System.err.println(\"secondId = \" + hex.formatHex(secondSession.getId()));\n+        System.err.println(\"secondSession.getCreationTime() = \" +\n+            secondSession.getCreationTime());\n@@ -105,2 +104,3 @@\n-            if (secondSession.getCreationTime() > secondStartTime) {\n-                throw new RuntimeException(\"Session was not reused\");\n+            if (firstSession.getCreationTime() !=\n+                secondSession.getCreationTime()) {\n+                throw new AssertionError(\"Session was not reused: FAIL\");\n@@ -108,0 +108,2 @@\n+\n+            System.out.println(\"secondSession used resumption: PASS\");\n@@ -118,2 +120,2 @@\n-            if (secondSession.getCreationTime() <= secondStartTime) {\n-                throw new RuntimeException(\"Existing session was used\");\n+            if (secondSession.getCreationTime() < secondStartTime) {\n+                throw new AssertionError(\"Existing session was used: FAIL\");\n@@ -121,0 +123,1 @@\n+            System.out.println(\"secondSession not resumed: PASS\");\n@@ -123,1 +126,1 @@\n-            throw new RuntimeException(\"unknown mode: \" + testMode);\n+            throw new AssertionError(\"unknown mode: \" + testMode);\n@@ -128,1 +131,0 @@\n-\n@@ -135,1 +137,0 @@\n-\n@@ -143,0 +144,1 @@\n+\n@@ -145,1 +147,0 @@\n-\n@@ -148,0 +149,1 @@\n+\n@@ -150,1 +152,0 @@\n-\n@@ -155,2 +156,0 @@\n-    private static SSLSession connect(Client client, SSLServerSocket ssock,\n-        TestMode mode, boolean second) throws Exception {\n@@ -158,5 +157,4 @@\n-        try {\n-            client.signal();\n-            System.out.println(\"Waiting for connection\");\n-            SSLSocket sock = (SSLSocket) ssock.accept();\n-            SSLParameters params = sock.getSSLParameters();\n+    private static class Client extends SSLContextTemplate {\n+        private final int port;\n+        private final SSLContext sc;\n+        public SSLSession session;\n@@ -164,52 +162,18 @@\n-            switch (mode) {\n-            case BASIC:\n-                \/\/ do nothing to ensure resumption works\n-                break;\n-            case CLIENT_AUTH:\n-                if (second) {\n-                    params.setNeedClientAuth(true);\n-                } else {\n-                    params.setNeedClientAuth(false);\n-                }\n-                break;\n-            case VERSION_2_TO_3:\n-                if (second) {\n-                    params.setProtocols(new String[] {\"TLSv1.3\"});\n-                } else {\n-                    params.setProtocols(new String[] {\"TLSv1.2\"});\n-                }\n-                break;\n-            case VERSION_3_TO_2:\n-                if (second) {\n-                    params.setProtocols(new String[] {\"TLSv1.2\"});\n-                } else {\n-                    params.setProtocols(new String[] {\"TLSv1.3\"});\n-                }\n-                break;\n-            case CIPHER_SUITE:\n-                if (second) {\n-                    params.setCipherSuites(\n-                        new String[] {\"TLS_AES_128_GCM_SHA256\"});\n-                } else {\n-                    params.setCipherSuites(\n-                        new String[] {\"TLS_AES_256_GCM_SHA384\"});\n-                }\n-                break;\n-            case SIGNATURE_SCHEME:\n-                params.setNeedClientAuth(true);\n-                AlgorithmConstraints constraints =\n-                    params.getAlgorithmConstraints();\n-                if (second) {\n-                    params.setAlgorithmConstraints(new NoSig(\"ecdsa\"));\n-                } else {\n-                    params.setAlgorithmConstraints(new NoSig(\"rsa\"));\n-                }\n-                break;\n-            default:\n-                throw new RuntimeException(\"unknown mode: \" + mode);\n-            }\n-            sock.setSSLParameters(params);\n-            BufferedReader reader = new BufferedReader(\n-                new InputStreamReader(sock.getInputStream()));\n-            String line = reader.readLine();\n-            System.out.println(\"server read: \" + line);\n+        Client(int port) throws Exception {\n+            sc = createClientSSLContext();\n+            this.port = port;\n+        }\n+\n+        public SSLSession test() throws Exception {\n+            SSLSocket sock = null;\n+            latch.await();\n+            do {\n+                try {\n+                    sock = (SSLSocket) sc.getSocketFactory().createSocket();\n+                } catch (IOException e) {\n+                    \/\/ If the server never starts, test will time out.\n+                    System.err.println(\"client trying again to connect\");\n+                    Thread.sleep(500);\n+                 }\n+            } while (sock == null);\n+            sock.connect(new InetSocketAddress(\"localhost\", port));\n@@ -218,1 +182,1 @@\n-            out.println(line);\n+            out.println(\"message\");\n@@ -220,0 +184,4 @@\n+            BufferedReader reader = new BufferedReader(\n+                new InputStreamReader(sock.getInputStream()));\n+            String inMsg = reader.readLine();\n+            System.out.println(\"Client received: \" + inMsg);\n@@ -221,1 +189,1 @@\n-            SSLSession result = sock.getSession();\n+            session = sock.getSession();\n@@ -223,5 +191,1 @@\n-            return result;\n-        } catch (SSLHandshakeException ex) {\n-            if (!second) {\n-                throw ex;\n-            }\n+            return session;\n@@ -229,7 +193,0 @@\n-        return null;\n-    }\n-\n-    private static Client startClient(int port) {\n-        Client client = new Client(port);\n-        new Thread(client).start();\n-        return client;\n@@ -238,12 +195,16 @@\n-    private static class Client extends SSLContextTemplate implements Runnable {\n-\n-        public volatile boolean go = true;\n-        private boolean signal = false;\n-        private final int port;\n-\n-        Client(int port) {\n-            this.port = port;\n-        }\n-\n-        private synchronized void waitForSignal() {\n-            while (!signal) {\n+    \/\/ The server will only have two connections each tests\n+    private static class Server extends SSLContextTemplate {\n+        public int port;\n+        ExecutorService threadPool = Executors.newFixedThreadPool(1);\n+        \/\/ Stores the certs from the first connection in mode LOCAL_CERTS\n+        \/\/ first connection to the server\n+        static boolean first = true;\n+\n+        Server() throws Exception {\n+            SSLContext sc = createServerSSLContext();\n+            ServerSocketFactory fac = sc.getServerSocketFactory();\n+            SSLServerSocket ssock = (SSLServerSocket) fac.createServerSocket(0);\n+            port = ssock.getLocalPort();\n+\n+            \/\/ Thread to allow multiple clients to connect\n+            new Thread(() -> {\n@@ -251,3 +212,9 @@\n-                    wait();\n-                } catch (InterruptedException ex) {\n-                    \/\/ do nothing\n+                    System.err.println(\"Server starting to accept\");\n+                    latch.countDown();\n+                    do {\n+                        threadPool.submit(new ServerThread(ssock.accept()));\n+                    } while (true);\n+                } catch (Exception ex) {\n+                    throw new AssertionError(\"Server Down\", ex);\n+                } finally {\n+                    threadPool.close();\n@@ -255,12 +222,1 @@\n-            }\n-            signal = false;\n-\n-            try {\n-                Thread.sleep(1000);\n-            } catch (InterruptedException ex) {\n-                \/\/ do nothing\n-            }\n-        }\n-        public synchronized void signal() {\n-            signal = true;\n-            notify();\n+            }).start();\n@@ -269,2 +225,2 @@\n-        public void run() {\n-            try {\n+        static class ServerThread implements Runnable {\n+            final SSLSocket sock;\n@@ -272,1 +228,5 @@\n-                SSLContext sc = createClientSSLContext();\n+            ServerThread(Socket s) {\n+                this.sock = (SSLSocket) s;\n+                System.err.println(\"(Server) client connection on port \" +\n+                    sock.getPort());\n+            }\n@@ -274,19 +234,24 @@\n-                waitForSignal();\n-                while (go) {\n-                    try {\n-                        SSLSocket sock = (SSLSocket)\n-                            sc.getSocketFactory().createSocket();\n-                        sock.connect(new InetSocketAddress(\"localhost\", port));\n-                        PrintWriter out = new PrintWriter(\n-                            new OutputStreamWriter(sock.getOutputStream()));\n-                        out.println(\"message\");\n-                        out.flush();\n-                        BufferedReader reader = new BufferedReader(\n-                            new InputStreamReader(sock.getInputStream()));\n-                        String inMsg = reader.readLine();\n-                        System.out.println(\"Client received: \" + inMsg);\n-                        out.close();\n-                        sock.close();\n-                        waitForSignal();\n-                    } catch (Exception ex) {\n-                        ex.printStackTrace();\n+\n+            public void run() {\n+                try {\n+                    SSLParameters params = sock.getSSLParameters();\n+                    switch (testMode) {\n+                        case BASIC -> {}  \/\/ do nothing\n+                        case CLIENT_AUTH -> params.setNeedClientAuth(!first);\n+                        case VERSION_2_TO_3 -> params.setProtocols(new String[]{\n+                            first ? \"TLSv1.2\" : \"TLSv1.3\"});\n+                        case VERSION_3_TO_2 -> params.setProtocols(new String[]{\n+                            first ? \"TLSv1.3\" : \"TLSv1.2\"});\n+                        case CIPHER_SUITE -> params.setCipherSuites(\n+                            new String[]{\n+                                first ? \"TLS_AES_256_GCM_SHA384\" :\n+                                    \"TLS_AES_128_GCM_SHA256\"});\n+                        case SIGNATURE_SCHEME -> {\n+                            params.setNeedClientAuth(true);\n+                            params.setAlgorithmConstraints(new NoSig(\n+                                first ? \"ecdsa_secp521r1_sha512\" :\n+                                    \"ecdsa_secp384r1_sha384\"));\n+                        }\n+                        default ->\n+                            throw new AssertionError(\"Server: \" +\n+                                \"unknown mode: \" + testMode);\n@@ -294,0 +259,15 @@\n+                    sock.setSSLParameters(params);\n+                    BufferedReader reader = new BufferedReader(\n+                        new InputStreamReader(sock.getInputStream()));\n+                    String line = reader.readLine();\n+                    System.err.println(\"server read: \" + line);\n+                    PrintWriter out = new PrintWriter(\n+                        new OutputStreamWriter(sock.getOutputStream()));\n+                    out.println(line);\n+                    out.flush();\n+                    out.close();\n+                    SSLSession session = sock.getSession();\n+                    first = false;\n+                    System.err.println(\"server socket closed: \" + session);\n+                } catch (Exception e) {\n+                    throw new AssertionError(\"Server error\", e);\n@@ -295,2 +275,0 @@\n-            } catch (Exception ex) {\n-                throw new RuntimeException(ex);\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/ResumeChecksServer.java","additions":141,"deletions":163,"binary":false,"changes":304,"status":"modified"}]}