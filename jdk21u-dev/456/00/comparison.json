{"files":[{"patch":"@@ -114,2 +114,1 @@\n-  bool expunge = Atomic::load(&_cleaning_epoch) == 0;\n-  if (expunge) {\n+  if (delete_on_release()) {\n@@ -181,1 +180,34 @@\n-  nmethodBucket* b = dependencies_not_unloading();\n+  \/\/ Assume that the dependency is not deleted immediately but moved into the\n+  \/\/ purge list when calling this.\n+  assert(!delete_on_release(), \"should not delete on release\");\n+\n+  nmethodBucket* first = Atomic::load_acquire(_dependency_context_addr);\n+  if (first == nullptr) {\n+    return;\n+  }\n+\n+  nmethodBucket* cur = first;\n+  nmethodBucket* last = cur;\n+  jlong count = 0;\n+  for (; cur != nullptr; cur = cur->next()) {\n+    assert(cur->get_nmethod()->is_unloading(), \"must be\");\n+    last = cur;\n+    count++;\n+  }\n+\n+  \/\/ Add the whole list to the purge list at once.\n+  nmethodBucket* old_purge_list_head = Atomic::load(&_purge_list);\n+  for (;;) {\n+    last->set_purge_list_next(old_purge_list_head);\n+    nmethodBucket* next_purge_list_head = Atomic::cmpxchg(&_purge_list, old_purge_list_head, first);\n+    if (old_purge_list_head == next_purge_list_head) {\n+      break;\n+    }\n+    old_purge_list_head = next_purge_list_head;\n+  }\n+\n+  if (UsePerfData) {\n+    _perf_total_buckets_stale_count->inc(count);\n+    _perf_total_buckets_stale_acc_count->inc(count);\n+  }\n+\n@@ -183,1 +215,0 @@\n-  assert(b == nullptr, \"All dependents should be unloading\");\n@@ -237,0 +268,4 @@\n+bool DependencyContext::delete_on_release() {\n+  return Atomic::load(&_cleaning_epoch) == 0;\n+}\n+\n","filename":"src\/hotspot\/share\/code\/dependencyContext.cpp","additions":39,"deletions":4,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+  static bool delete_on_release();\n","filename":"src\/hotspot\/share\/code\/dependencyContext.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}