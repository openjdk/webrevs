{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -44,1 +45,1 @@\n-  CgroupV1Controller* cpu = nullptr;\n+  CgroupV1CpuController* cpu = nullptr;\n@@ -64,5 +65,9 @@\n-    \/\/ Note: any index in cg_infos will do as the path is the same for\n-    \/\/       all controllers.\n-    CgroupController* unified = new CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path,\n-                                                       cg_infos[MEMORY_IDX]._cgroup_path,\n-                                                       cg_infos[MEMORY_IDX]._read_only);\n+    \/\/ Note: We use the memory for non-cpu non-memory controller look-ups.\n+    \/\/       Perhaps we ought to have separate controllers for all.\n+    CgroupV2Controller mem_other = CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path,\n+                                                      cg_infos[MEMORY_IDX]._cgroup_path,\n+                                                      cg_infos[MEMORY_IDX]._read_only);\n+    CgroupV2MemoryController* memory = new CgroupV2MemoryController(mem_other);\n+    CgroupV2CpuController* cpu = new CgroupV2CpuController(CgroupV2Controller(cg_infos[CPU_IDX]._mount_path,\n+                                                                              cg_infos[CPU_IDX]._cgroup_path,\n+                                                                              cg_infos[CPU_IDX]._read_only));\n@@ -71,1 +76,1 @@\n-    return new CgroupV2Subsystem(unified);\n+    return new CgroupV2Subsystem(memory, cpu, mem_other);\n@@ -105,1 +110,1 @@\n-        memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path, info._read_only);\n+        memory = new CgroupV1MemoryController(CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only));\n@@ -111,1 +116,1 @@\n-        cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only);\n+        cpu = new CgroupV1CpuController(CgroupV1Controller(info._root_mount_path, info._mount_path, info._read_only));\n@@ -561,1 +566,1 @@\n-  int cpu_count, limit_count;\n+  int cpu_count;\n@@ -567,1 +572,1 @@\n-  CachingCgroupController* contrl = cpu_controller();\n+  CachingCgroupController<CgroupCpuController>* contrl = cpu_controller();\n@@ -575,17 +580,2 @@\n-  cpu_count = limit_count = os::Linux::active_processor_count();\n-  int quota  = cpu_quota();\n-  int period = cpu_period();\n-\n-  if (quota > -1 && period > 0) {\n-    quota_count = ceilf((float)quota \/ (float)period);\n-    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n-  }\n-\n-  \/\/ Use quotas\n-  if (quota_count != 0) {\n-    limit_count = quota_count;\n-  }\n-\n-  result = MIN2(cpu_count, limit_count);\n-  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n-\n+  cpu_count = os::Linux::active_processor_count();\n+  result = CgroupUtil::processor_count(contrl->controller(), cpu_count);\n@@ -608,1 +598,1 @@\n-  CachingCgroupController* contrl = memory_controller();\n+  CachingCgroupController<CgroupMemoryController>* contrl = memory_controller();\n@@ -615,22 +605,1 @@\n-  jlong mem_limit = read_memory_limit_in_bytes();\n-\n-  if (mem_limit <= 0 || mem_limit >= phys_mem) {\n-    jlong read_mem_limit = mem_limit;\n-    const char *reason;\n-    if (mem_limit >= phys_mem) {\n-      \/\/ Exceeding physical memory is treated as unlimited. Cg v1's implementation\n-      \/\/ of read_memory_limit_in_bytes() caps this at phys_mem since Cg v1 has no\n-      \/\/ value to represent 'max'. Cg v2 may return a value >= phys_mem if e.g. the\n-      \/\/ container engine was started with a memory flag exceeding it.\n-      reason = \"ignored\";\n-      mem_limit = -1;\n-    } else if (OSCONTAINER_ERROR == mem_limit) {\n-      reason = \"failed\";\n-    } else {\n-      assert(mem_limit == -1, \"Expected unlimited\");\n-      reason = \"unlimited\";\n-    }\n-    log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n-                             reason, read_mem_limit, phys_mem);\n-  }\n-\n+  jlong mem_limit = contrl->controller()->read_memory_limit_in_bytes(phys_mem);\n@@ -801,0 +770,46 @@\n+\n+\/\/ CgroupSubsystem implementations\n+\n+jlong CgroupSubsystem::memory_and_swap_limit_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  julong host_swap = os::Linux::host_swap();\n+  return memory_controller()->controller()->memory_and_swap_limit_in_bytes(phys_mem, host_swap);\n+}\n+\n+jlong CgroupSubsystem::memory_soft_limit_in_bytes() {\n+  julong phys_mem = os::Linux::physical_memory();\n+  return memory_controller()->controller()->memory_soft_limit_in_bytes(phys_mem);\n+}\n+\n+jlong CgroupSubsystem::memory_usage_in_bytes() {\n+  return memory_controller()->controller()->memory_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::memory_max_usage_in_bytes() {\n+  return memory_controller()->controller()->memory_max_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::rss_usage_in_bytes() {\n+  return memory_controller()->controller()->rss_usage_in_bytes();\n+}\n+\n+jlong CgroupSubsystem::cache_usage_in_bytes() {\n+  return memory_controller()->controller()->cache_usage_in_bytes();\n+}\n+\n+int CgroupSubsystem::cpu_quota() {\n+  return cpu_controller()->controller()->cpu_quota();\n+}\n+\n+int CgroupSubsystem::cpu_period() {\n+  return cpu_controller()->controller()->cpu_period();\n+}\n+\n+int CgroupSubsystem::cpu_shares() {\n+  return cpu_controller()->controller()->cpu_shares();\n+}\n+\n+void CgroupSubsystem::print_version_specific_info(outputStream* st) {\n+  julong phys_mem = os::Linux::physical_memory();\n+  memory_controller()->controller()->print_version_specific_info(st, phys_mem);\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":66,"deletions":51,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -183,0 +183,1 @@\n+template <class T>\n@@ -185,1 +186,1 @@\n-    CgroupController* _controller;\n+    T* _controller;\n@@ -189,1 +190,1 @@\n-    CachingCgroupController(CgroupController* cont) {\n+    CachingCgroupController(T* cont) {\n@@ -195,1 +196,1 @@\n-    CgroupController* controller() { return _controller; }\n+    T* controller() { return _controller; }\n@@ -198,1 +199,2 @@\n-class CgroupSubsystem: public CHeapObj<mtInternal> {\n+\/\/ Pure virtual class representing version agnostic CPU controllers\n+class CgroupCpuController: public CHeapObj<mtInternal> {\n@@ -200,3 +202,0 @@\n-    jlong memory_limit_in_bytes();\n-    int active_processor_count();\n-\n@@ -206,2 +205,7 @@\n-    virtual jlong pids_max() = 0;\n-    virtual jlong pids_current() = 0;\n+    virtual bool is_read_only() = 0;\n+};\n+\n+\/\/ Pure virtual class representing version agnostic memory controllers\n+class CgroupMemoryController: public CHeapObj<mtInternal> {\n+  public:\n+    virtual jlong read_memory_limit_in_bytes(julong upper_bound) = 0;\n@@ -209,2 +213,2 @@\n-    virtual jlong memory_and_swap_limit_in_bytes() = 0;\n-    virtual jlong memory_soft_limit_in_bytes() = 0;\n+    virtual jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) = 0;\n+    virtual jlong memory_soft_limit_in_bytes(julong upper_bound) = 0;\n@@ -214,0 +218,11 @@\n+    virtual void print_version_specific_info(outputStream* st, julong host_mem) = 0;\n+    virtual bool is_read_only() = 0;\n+};\n+\n+class CgroupSubsystem: public CHeapObj<mtInternal> {\n+  public:\n+    jlong memory_limit_in_bytes();\n+    int active_processor_count();\n+\n+    virtual jlong pids_max() = 0;\n+    virtual jlong pids_current() = 0;\n@@ -218,1 +233,0 @@\n-    virtual jlong read_memory_limit_in_bytes() = 0;\n@@ -220,4 +234,14 @@\n-    virtual CachingCgroupController* memory_controller() = 0;\n-    virtual CachingCgroupController* cpu_controller() = 0;\n-\n-    virtual void print_version_specific_info(outputStream* st) = 0;\n+    virtual CachingCgroupController<CgroupMemoryController>* memory_controller() = 0;\n+    virtual CachingCgroupController<CgroupCpuController>* cpu_controller() = 0;\n+\n+    int cpu_quota();\n+    int cpu_period();\n+    int cpu_shares();\n+\n+    jlong memory_usage_in_bytes();\n+    jlong memory_and_swap_limit_in_bytes();\n+    jlong memory_soft_limit_in_bytes();\n+    jlong memory_max_usage_in_bytes();\n+    jlong rss_usage_in_bytes();\n+    jlong cache_usage_in_bytes();\n+    void print_version_specific_info(outputStream* st);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":40,"deletions":16,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cgroupUtil_linux.hpp\"\n+\n+int CgroupUtil::processor_count(CgroupCpuController* cpu_ctrl, int host_cpus) {\n+  assert(host_cpus > 0, \"physical host cpus must be positive\");\n+  int limit_count = host_cpus;\n+  int quota  = cpu_ctrl->cpu_quota();\n+  int period = cpu_ctrl->cpu_period();\n+  int quota_count = 0;\n+  int result = 0;\n+\n+  if (quota > -1 && period > 0) {\n+    quota_count = ceilf((float)quota \/ (float)period);\n+    log_trace(os, container)(\"CPU Quota count based on quota\/period: %d\", quota_count);\n+  }\n+\n+  \/\/ Use quotas\n+  if (quota_count != 0) {\n+    limit_count = quota_count;\n+  }\n+\n+  result = MIN2(host_cpus, limit_count);\n+  log_trace(os, container)(\"OSContainer::active_processor_count: %d\", result);\n+  return result;\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CGROUP_UTIL_LINUX_HPP\n+#define CGROUP_UTIL_LINUX_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+\n+class CgroupUtil: AllStatic {\n+\n+  public:\n+    static int processor_count(CgroupCpuController* cpu, int host_cpus);\n+};\n+\n+#endif \/\/ CGROUP_UTIL_LINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/cgroupUtil_linux.hpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -79,1 +80,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(this, \"\/memory.use_hierarchy\", \"Use Hierarchy\", use_hierarchy);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.use_hierarchy\", \"Use Hierarchy\", use_hierarchy);\n@@ -84,1 +85,1 @@\n-  CgroupV1Controller::set_subsystem_path(cgroup_path);\n+  reader()->set_subsystem_path(cgroup_path);\n@@ -91,1 +92,23 @@\n-jlong CgroupV1Subsystem::read_memory_limit_in_bytes() {\n+static inline\n+void verbose_log(julong read_mem_limit, julong host_mem) {\n+  if (log_is_enabled(Debug, os, container)) {\n+    jlong mem_limit = (jlong)read_mem_limit; \/\/ account for negative values\n+    if (mem_limit < 0 || read_mem_limit >= host_mem) {\n+      const char *reason;\n+      if (mem_limit == OSCONTAINER_ERROR) {\n+        reason = \"failed\";\n+      } else if (mem_limit == -1) {\n+        reason = \"unlimited\";\n+      } else {\n+        assert(read_mem_limit >= host_mem, \"Expected read value exceeding host_mem\");\n+        \/\/ Exceeding physical memory is treated as unlimited. This implementation\n+        \/\/ caps it at host_mem since Cg v1 has no value to represent 'max'.\n+        reason = \"ignored\";\n+      }\n+      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n+                               reason, mem_limit, host_mem);\n+    }\n+  }\n+}\n+\n+jlong CgroupV1MemoryController::read_memory_limit_in_bytes(julong phys_mem) {\n@@ -93,2 +116,2 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.limit_in_bytes\", \"Memory Limit\", memlimit);\n-  if (memlimit >= os::Linux::physical_memory()) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.limit_in_bytes\", \"Memory Limit\", memlimit);\n+  if (memlimit >= phys_mem) {\n@@ -96,2 +119,1 @@\n-    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n-    if (mem_controller->is_hierarchical()) {\n+    if (is_hierarchical()) {\n@@ -99,3 +121,1 @@\n-      bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n-                                                                   \"hierarchical_memory_limit\",\n-                                                                   &hier_memlimit);\n+      bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"hierarchical_memory_limit\", &hier_memlimit);\n@@ -106,3 +126,2 @@\n-      if (hier_memlimit >= os::Linux::physical_memory()) {\n-        log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n-      } else {\n+      if (hier_memlimit < phys_mem) {\n+        verbose_log(hier_memlimit, phys_mem);\n@@ -111,0 +130,1 @@\n+      log_trace(os, container)(\"Hierarchical Memory Limit is: Unlimited\");\n@@ -112,0 +132,1 @@\n+    verbose_log(memlimit, phys_mem);\n@@ -113,2 +134,2 @@\n-  }\n-  else {\n+  } else {\n+    verbose_log(memlimit, phys_mem);\n@@ -131,2 +152,1 @@\n-jlong CgroupV1Subsystem::read_mem_swap() {\n-  julong host_total_memsw;\n+jlong CgroupV1MemoryController::read_mem_swap(julong host_total_memsw) {\n@@ -135,2 +155,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", memswlimit);\n-  host_total_memsw = os::Linux::host_swap() + os::Linux::physical_memory();\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", memswlimit);\n@@ -139,2 +158,1 @@\n-    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n-    if (mem_controller->is_hierarchical()) {\n+    if (is_hierarchical()) {\n@@ -142,3 +160,3 @@\n-      bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n-                                                                   matchline,\n-                                                                   &hier_memswlimit);\n+      bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\",\n+                                                           matchline,\n+                                                           &hier_memswlimit);\n@@ -161,2 +179,2 @@\n-jlong CgroupV1Subsystem::memory_and_swap_limit_in_bytes() {\n-  jlong memory_swap = read_mem_swap();\n+jlong CgroupV1MemoryController::memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) {\n+  jlong memory_swap = read_mem_swap(host_mem + host_swap);\n@@ -171,1 +189,1 @@\n-    jlong memlimit = read_memory_limit_in_bytes();\n+    jlong memlimit = read_memory_limit_in_bytes(host_mem);\n@@ -189,1 +207,1 @@\n-jlong CgroupV1Subsystem::read_mem_swappiness() {\n+jlong CgroupV1MemoryController::read_mem_swappiness() {\n@@ -191,1 +209,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.swappiness\", \"Swappiness\", swappiness);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.swappiness\", \"Swappiness\", swappiness);\n@@ -195,1 +213,1 @@\n-jlong CgroupV1Subsystem::memory_soft_limit_in_bytes() {\n+jlong CgroupV1MemoryController::memory_soft_limit_in_bytes(julong phys_mem) {\n@@ -197,2 +215,2 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", memsoftlimit);\n-  if (memsoftlimit >= os::Linux::physical_memory()) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", memsoftlimit);\n+  if (memsoftlimit >= phys_mem) {\n@@ -226,1 +244,1 @@\n-jlong CgroupV1Subsystem::memory_usage_in_bytes() {\n+jlong CgroupV1MemoryController::memory_usage_in_bytes() {\n@@ -228,1 +246,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.usage_in_bytes\", \"Memory Usage\", memusage);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.usage_in_bytes\", \"Memory Usage\", memusage);\n@@ -240,1 +258,1 @@\n-jlong CgroupV1Subsystem::memory_max_usage_in_bytes() {\n+jlong CgroupV1MemoryController::memory_max_usage_in_bytes() {\n@@ -242,1 +260,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", memmaxusage);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", memmaxusage);\n@@ -246,1 +264,1 @@\n-jlong CgroupV1Subsystem::rss_usage_in_bytes() {\n+jlong CgroupV1MemoryController::rss_usage_in_bytes() {\n@@ -248,1 +266,1 @@\n-  bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n+  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\",\n@@ -258,1 +276,1 @@\n-jlong CgroupV1Subsystem::cache_usage_in_bytes() {\n+jlong CgroupV1MemoryController::cache_usage_in_bytes() {\n@@ -260,1 +278,1 @@\n-  bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n+  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\",\n@@ -270,1 +288,1 @@\n-jlong CgroupV1Subsystem::kernel_memory_usage_in_bytes() {\n+jlong CgroupV1MemoryController::kernel_memory_usage_in_bytes() {\n@@ -272,1 +290,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", kmem_usage);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", kmem_usage);\n@@ -276,1 +294,1 @@\n-jlong CgroupV1Subsystem::kernel_memory_limit_in_bytes() {\n+jlong CgroupV1MemoryController::kernel_memory_limit_in_bytes(julong phys_mem) {\n@@ -278,2 +296,2 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", kmem_limit);\n-  if (kmem_limit >= os::Linux::physical_memory()) {\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", kmem_limit);\n+  if (kmem_limit >= phys_mem) {\n@@ -285,1 +303,1 @@\n-jlong CgroupV1Subsystem::kernel_memory_max_usage_in_bytes() {\n+jlong CgroupV1MemoryController::kernel_memory_max_usage_in_bytes() {\n@@ -287,1 +305,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", kmem_max_usage);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", kmem_max_usage);\n@@ -291,1 +309,1 @@\n-void CgroupV1Subsystem::print_version_specific_info(outputStream* st) {\n+void CgroupV1MemoryController::print_version_specific_info(outputStream* st, julong phys_mem) {\n@@ -293,1 +311,1 @@\n-  jlong kmem_limit = kernel_memory_limit_in_bytes();\n+  jlong kmem_limit = kernel_memory_limit_in_bytes(phys_mem);\n@@ -323,1 +341,1 @@\n-int CgroupV1Subsystem::cpu_quota() {\n+int CgroupV1CpuController::cpu_quota() {\n@@ -325,2 +343,1 @@\n-  bool is_ok = _cpu->controller()->\n-                  read_number(\"\/cpu.cfs_quota_us\", &quota);\n+  bool is_ok = reader()->read_number(\"\/cpu.cfs_quota_us\", &quota);\n@@ -338,1 +355,1 @@\n-int CgroupV1Subsystem::cpu_period() {\n+int CgroupV1CpuController::cpu_period() {\n@@ -340,1 +357,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_cpu->controller(), \"\/cpu.cfs_period_us\", \"CPU Period\", period);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.cfs_period_us\", \"CPU Period\", period);\n@@ -354,1 +371,1 @@\n-int CgroupV1Subsystem::cpu_shares() {\n+int CgroupV1CpuController::cpu_shares() {\n@@ -356,1 +373,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_cpu->controller(), \"\/cpu.shares\", \"CPU Shares\", shares);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.shares\", \"CPU Shares\", shares);\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":73,"deletions":56,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-    char *_root;\n-    char *_mount_point;\n+    char* _root;\n+    char* _mount_point;\n@@ -42,1 +42,1 @@\n-    char *_path;\n+    char* _path;\n@@ -45,5 +45,16 @@\n-    CgroupV1Controller(char *root, char *mountpoint, bool ro) {\n-      _root = os::strdup(root);\n-      _mount_point = os::strdup(mountpoint);\n-      _path = nullptr;\n-      _read_only = ro;\n+    CgroupV1Controller(char *root,\n+                       char *mountpoint,\n+                       bool ro) : _root(os::strdup(root)),\n+                                  _mount_point(os::strdup(mountpoint)),\n+                                  _read_only(ro),\n+                                  _path(nullptr) {\n+    }\n+    \/\/ Shallow copy constructor\n+    CgroupV1Controller(const CgroupV1Controller& o) : _root(o._root),\n+                                                      _mount_point(o._mount_point),\n+                                                      _read_only(o._read_only),\n+                                                      _path(o._path) {\n+    }\n+    ~CgroupV1Controller() {\n+      \/\/ At least one subsystem controller exists with paths to malloc'd path\n+      \/\/ names\n@@ -52,2 +63,2 @@\n-    virtual void set_subsystem_path(char *cgroup_path);\n-    char *subsystem_path() { return _path; }\n+    void set_subsystem_path(char *cgroup_path);\n+    char *subsystem_path() override { return _path; }\n@@ -57,1 +68,1 @@\n-class CgroupV1MemoryController: public CgroupV1Controller {\n+class CgroupV1MemoryController final : public CgroupMemoryController {\n@@ -59,0 +70,3 @@\n+  private:\n+    CgroupV1Controller _reader;\n+    CgroupV1Controller* reader() { return &_reader; }\n@@ -62,0 +76,14 @@\n+    jlong read_memory_limit_in_bytes(julong upper_bound) override;\n+    jlong memory_usage_in_bytes() override;\n+    jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swap) override;\n+    jlong memory_soft_limit_in_bytes(julong upper_bound) override;\n+    jlong memory_max_usage_in_bytes() override;\n+    jlong rss_usage_in_bytes() override;\n+    jlong cache_usage_in_bytes() override;\n+    jlong kernel_memory_usage_in_bytes();\n+    jlong kernel_memory_limit_in_bytes(julong host_mem);\n+    jlong kernel_memory_max_usage_in_bytes();\n+    void print_version_specific_info(outputStream* st, julong host_mem) override;\n+    bool is_read_only() override {\n+      return reader()->is_read_only();\n+    }\n@@ -69,0 +97,2 @@\n+    jlong read_mem_swappiness();\n+    jlong read_mem_swap(julong host_total_memsw);\n@@ -71,2 +101,3 @@\n-    CgroupV1MemoryController(char *root, char *mountpoint, bool ro) : CgroupV1Controller(root, mountpoint, ro) {\n-      _uses_mem_hierarchy = false;\n+    CgroupV1MemoryController(const CgroupV1Controller& reader)\n+      : _reader(reader),\n+        _uses_mem_hierarchy(false) {\n@@ -77,1 +108,15 @@\n-class CgroupV1Subsystem: public CgroupSubsystem {\n+class CgroupV1CpuController final : public CgroupCpuController {\n+\n+  private:\n+    CgroupV1Controller _reader;\n+    CgroupV1Controller* reader() { return &_reader; }\n+  public:\n+    int cpu_quota() override;\n+    int cpu_period() override;\n+    int cpu_shares() override;\n+    void set_subsystem_path(char *cgroup_path) {\n+      reader()->set_subsystem_path(cgroup_path);\n+    }\n+    bool is_read_only() override {\n+      return reader()->is_read_only();\n+    }\n@@ -80,7 +125,5 @@\n-    jlong read_memory_limit_in_bytes();\n-    jlong memory_and_swap_limit_in_bytes();\n-    jlong memory_soft_limit_in_bytes();\n-    jlong memory_usage_in_bytes();\n-    jlong memory_max_usage_in_bytes();\n-    jlong rss_usage_in_bytes();\n-    jlong cache_usage_in_bytes();\n+    CgroupV1CpuController(const CgroupV1Controller& reader) : _reader(reader) {\n+    }\n+};\n+\n+class CgroupV1Subsystem: public CgroupSubsystem {\n@@ -88,0 +131,1 @@\n+  public:\n@@ -95,5 +139,0 @@\n-    int cpu_quota();\n-    int cpu_period();\n-\n-    int cpu_shares();\n-\n@@ -104,2 +143,0 @@\n-    void print_version_specific_info(outputStream* st);\n-\n@@ -109,2 +146,2 @@\n-    CachingCgroupController * memory_controller() { return _memory; }\n-    CachingCgroupController * cpu_controller() { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController>* memory_controller() { return _memory; }\n+    CachingCgroupController<CgroupCpuController>* cpu_controller() { return _cpu; }\n@@ -114,1 +151,1 @@\n-    CachingCgroupController* _memory = nullptr;\n+    CachingCgroupController<CgroupMemoryController>* _memory = nullptr;\n@@ -116,1 +153,1 @@\n-    CachingCgroupController* _cpu = nullptr;\n+    CachingCgroupController<CgroupCpuController>* _cpu = nullptr;\n@@ -120,3 +157,0 @@\n-    jlong read_mem_swappiness();\n-    jlong read_mem_swap();\n-\n@@ -125,1 +159,1 @@\n-                      CgroupV1Controller* cpu,\n+                      CgroupV1CpuController* cpu,\n@@ -128,6 +162,6 @@\n-                      CgroupV1MemoryController* memory) {\n-      _cpuset = cpuset;\n-      _cpu = new CachingCgroupController(cpu);\n-      _cpuacct = cpuacct;\n-      _pids = pids;\n-      _memory = new CachingCgroupController(memory);\n+                      CgroupV1MemoryController* memory) :\n+      _memory(new CachingCgroupController<CgroupMemoryController>(memory)),\n+      _cpuset(cpuset),\n+      _cpu(new CachingCgroupController<CgroupCpuController>(cpu)),\n+      _cpuacct(cpuacct),\n+      _pids(pids) {\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":76,"deletions":42,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cgroupUtil_linux.hpp\"\n@@ -37,1 +38,1 @@\n-int CgroupV2Subsystem::cpu_shares() {\n+int CgroupV2CpuController::cpu_shares() {\n@@ -39,1 +40,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/cpu.weight\", \"Raw value for CPU Shares\", shares);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/cpu.weight\", \"Raw value for CPU Shares\", shares);\n@@ -86,1 +87,1 @@\n-int CgroupV2Subsystem::cpu_quota() {\n+int CgroupV2CpuController::cpu_quota() {\n@@ -88,1 +89,1 @@\n-  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", true \/* use_first *\/, &quota_val);\n+  bool is_ok = reader()->read_numerical_tuple_value(\"\/cpu.max\", true \/* use_first *\/, &quota_val);\n@@ -98,1 +99,3 @@\n-  return _unified->is_read_only();\n+  return _unified.is_read_only() &&\n+         _memory->controller()->is_read_only() &&\n+         _cpu->controller()->is_read_only();\n@@ -103,1 +106,1 @@\n-  CONTAINER_READ_STRING_CHECKED(_unified, \"\/cpuset.cpus\", \"cpuset.cpus\", cpus, 1024);\n+  CONTAINER_READ_STRING_CHECKED(unified(), \"\/cpuset.cpus\", \"cpuset.cpus\", cpus, 1024);\n@@ -109,1 +112,1 @@\n-  CONTAINER_READ_STRING_CHECKED(_unified, \"\/cpuset.mems\", \"cpuset.mems\", mems, 1024);\n+  CONTAINER_READ_STRING_CHECKED(unified(), \"\/cpuset.mems\", \"cpuset.mems\", mems, 1024);\n@@ -113,1 +116,1 @@\n-int CgroupV2Subsystem::cpu_period() {\n+int CgroupV2CpuController::cpu_period() {\n@@ -115,1 +118,1 @@\n-  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", false \/* use_first *\/, &period_val);\n+  bool is_ok = reader()->read_numerical_tuple_value(\"\/cpu.max\", false \/* use_first *\/, &period_val);\n@@ -134,1 +137,1 @@\n-jlong CgroupV2Subsystem::memory_usage_in_bytes() {\n+jlong CgroupV2MemoryController::memory_usage_in_bytes() {\n@@ -136,1 +139,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/memory.current\", \"Memory Usage\", memusage);\n+  CONTAINER_READ_NUMBER_CHECKED(reader(), \"\/memory.current\", \"Memory Usage\", memusage);\n@@ -140,1 +143,1 @@\n-jlong CgroupV2Subsystem::memory_soft_limit_in_bytes() {\n+jlong CgroupV2MemoryController::memory_soft_limit_in_bytes(julong phys_mem) {\n@@ -142,1 +145,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.low\", \"Memory Soft Limit\", mem_soft_limit);\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(reader(), \"\/memory.low\", \"Memory Soft Limit\", mem_soft_limit);\n@@ -146,1 +149,1 @@\n-jlong CgroupV2Subsystem::memory_max_usage_in_bytes() {\n+jlong CgroupV2MemoryController::memory_max_usage_in_bytes() {\n@@ -152,1 +155,1 @@\n-jlong CgroupV2Subsystem::rss_usage_in_bytes() {\n+jlong CgroupV2MemoryController::rss_usage_in_bytes() {\n@@ -154,2 +157,1 @@\n-  bool is_ok = _memory->controller()->\n-                    read_numerical_key_value(\"\/memory.stat\", \"anon\", &rss);\n+  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"anon\", &rss);\n@@ -163,1 +165,1 @@\n-jlong CgroupV2Subsystem::cache_usage_in_bytes() {\n+jlong CgroupV2MemoryController::cache_usage_in_bytes() {\n@@ -165,2 +167,1 @@\n-  bool is_ok = _memory->controller()->\n-                    read_numerical_key_value(\"\/memory.stat\", \"file\", &cache);\n+  bool is_ok = reader()->read_numerical_key_value(\"\/memory.stat\", \"file\", &cache);\n@@ -179,1 +180,2 @@\n-jlong CgroupV2Subsystem::memory_and_swap_limit_in_bytes() {\n+jlong CgroupV2MemoryController::memory_and_swap_limit_in_bytes(julong phys_mem,\n+                                                               julong host_swap \/* unused in cg v2 *\/) {\n@@ -181,1 +183,1 @@\n-  bool is_ok = _memory->controller()->read_number_handle_max(\"\/memory.swap.max\", &swap_limit);\n+  bool is_ok = reader()->read_number_handle_max(\"\/memory.swap.max\", &swap_limit);\n@@ -186,1 +188,1 @@\n-    return read_memory_limit_in_bytes();\n+    return read_memory_limit_in_bytes(phys_mem);\n@@ -190,1 +192,1 @@\n-    jlong memory_limit = read_memory_limit_in_bytes();\n+    jlong memory_limit = read_memory_limit_in_bytes(phys_mem);\n@@ -198,6 +200,0 @@\n-jlong CgroupV2Subsystem::mem_swp_limit_val() {\n-  jlong swap_limit;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.swap.max\", \"Swap Limit\", swap_limit);\n-  return swap_limit;\n-}\n-\n@@ -205,1 +201,2 @@\n-jlong CgroupV2Subsystem::mem_swp_current_val() {\n+static\n+jlong memory_swap_current_value(CgroupV2Controller* ctrl) {\n@@ -207,1 +204,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/memory.swap.current\", \"Swap currently used\", swap_current);\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.swap.current\", \"Swap currently used\", swap_current);\n@@ -211,1 +208,8 @@\n-\/* memory_limit_in_bytes\n+static\n+jlong memory_limit_value(CgroupV2Controller* ctrl) {\n+  jlong memory_limit;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.max\", \"Memory Limit\", memory_limit);\n+  return memory_limit;\n+}\n+\n+\/* read_memory_limit_in_bytes\n@@ -219,4 +223,33 @@\n-jlong CgroupV2Subsystem::read_memory_limit_in_bytes() {\n-  jlong memory_limit;\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.max\", \"Memory Limit\", memory_limit);\n-  return memory_limit;\n+jlong CgroupV2MemoryController::read_memory_limit_in_bytes(julong phys_mem) {\n+  jlong limit = memory_limit_value(reader());\n+  if (log_is_enabled(Trace, os, container)) {\n+    if (limit == -1) {\n+      log_trace(os, container)(\"Memory Limit is: Unlimited\");\n+    } else {\n+      log_trace(os, container)(\"Memory Limit is: \" JLONG_FORMAT, limit);\n+    }\n+  }\n+  if (log_is_enabled(Debug, os, container)) {\n+    julong read_limit = (julong)limit; \/\/ avoid signed\/unsigned compare\n+    if (limit < 0 || read_limit >= phys_mem) {\n+      const char* reason;\n+      if (limit == -1) {\n+        reason = \"unlimited\";\n+      } else if (limit == OSCONTAINER_ERROR) {\n+        reason = \"failed\";\n+      } else {\n+        assert(read_limit >= phys_mem, \"Expected mem limit to exceed host memory\");\n+        reason = \"ignored\";\n+      }\n+      log_debug(os, container)(\"container memory limit %s: \" JLONG_FORMAT \", using host value \" JLONG_FORMAT,\n+                               reason, limit, phys_mem);\n+    }\n+  }\n+  return limit;\n+}\n+\n+static\n+jlong memory_swap_limit_value(CgroupV2Controller* ctrl) {\n+  jlong swap_limit;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(ctrl, \"\/memory.swap.max\", \"Swap Limit\", swap_limit);\n+  return swap_limit;\n@@ -225,3 +258,3 @@\n-void CgroupV2Subsystem::print_version_specific_info(outputStream* st) {\n-  jlong swap_current = mem_swp_current_val();\n-  jlong swap_limit = mem_swp_limit_val();\n+void CgroupV2MemoryController::print_version_specific_info(outputStream* st, julong phys_mem) {\n+  jlong swap_current = memory_swap_current_value(reader());\n+  jlong swap_limit = memory_swap_limit_value(reader());\n@@ -253,1 +286,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/pids.max\", \"Maximum number of tasks\", pids_max);\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(unified(), \"\/pids.max\", \"Maximum number of tasks\", pids_max);\n@@ -267,1 +300,1 @@\n-  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/pids.current\", \"Current number of tasks\", pids_current);\n+  CONTAINER_READ_NUMBER_CHECKED(unified(), \"\/pids.current\", \"Current number of tasks\", pids_current);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":75,"deletions":42,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -43,5 +43,16 @@\n-    CgroupV2Controller(char * mount_path, char *cgroup_path, bool ro) {\n-      _mount_path = mount_path;\n-      _cgroup_path = os::strdup(cgroup_path);\n-      _path = construct_path(mount_path, cgroup_path);\n-      _read_only = ro;\n+    CgroupV2Controller(char* mount_path,\n+                       char *cgroup_path,\n+                       bool ro) :  _mount_path(os::strdup(mount_path)),\n+                                   _cgroup_path(os::strdup(cgroup_path)),\n+                                   _read_only(ro),\n+                                   _path(construct_path(mount_path, cgroup_path)) {\n+    }\n+    \/\/ Shallow copy constructor\n+    CgroupV2Controller(const CgroupV2Controller& o) :\n+                                            _mount_path(o._mount_path),\n+                                            _cgroup_path(o._cgroup_path),\n+                                            _read_only(o._read_only),\n+                                            _path(o._path) {\n+    }\n+    ~CgroupV2Controller() {\n+      \/\/ At least one controller exists with references to the paths\n@@ -50,2 +61,38 @@\n-    char *subsystem_path() { return _path; }\n-    bool is_read_only() { return _read_only; }\n+    char *subsystem_path() override { return _path; }\n+    bool is_read_only() override { return _read_only; }\n+};\n+\n+class CgroupV2CpuController: public CgroupCpuController {\n+  private:\n+    CgroupV2Controller _reader;\n+    CgroupV2Controller* reader() { return &_reader; }\n+  public:\n+    CgroupV2CpuController(const CgroupV2Controller& reader) : _reader(reader) {\n+    }\n+    int cpu_quota() override;\n+    int cpu_period() override;\n+    int cpu_shares() override;\n+    bool is_read_only() override {\n+      return reader()->is_read_only();\n+    }\n+};\n+\n+class CgroupV2MemoryController final: public CgroupMemoryController {\n+  private:\n+    CgroupV2Controller _reader;\n+    CgroupV2Controller* reader() { return &_reader; }\n+  public:\n+    CgroupV2MemoryController(const CgroupV2Controller& reader) : _reader(reader) {\n+    }\n+\n+    jlong read_memory_limit_in_bytes(julong upper_bound) override;\n+    jlong memory_and_swap_limit_in_bytes(julong host_mem, julong host_swp) override;\n+    jlong memory_soft_limit_in_bytes(julong upper_bound) override;\n+    jlong memory_usage_in_bytes() override;\n+    jlong memory_max_usage_in_bytes() override;\n+    jlong rss_usage_in_bytes() override;\n+    jlong cache_usage_in_bytes() override;\n+    void print_version_specific_info(outputStream* st, julong host_mem) override;\n+    bool is_read_only() override {\n+      return reader()->is_read_only();\n+    }\n@@ -57,1 +104,1 @@\n-    CgroupController* _unified = nullptr;\n+    CgroupV2Controller _unified;\n@@ -59,2 +106,2 @@\n-    CachingCgroupController* _memory = nullptr;\n-    CachingCgroupController* _cpu = nullptr;\n+    CachingCgroupController<CgroupMemoryController>* _memory = nullptr;\n+    CachingCgroupController<CgroupCpuController>* _cpu = nullptr;\n@@ -62,2 +109,1 @@\n-    jlong mem_swp_limit_val();\n-    jlong mem_swp_current_val();\n+    CgroupV2Controller* unified() { return &_unified; }\n@@ -66,4 +112,6 @@\n-    CgroupV2Subsystem(CgroupController * unified) {\n-      _unified = unified;\n-      _memory = new CachingCgroupController(unified);\n-      _cpu = new CachingCgroupController(unified);\n+    CgroupV2Subsystem(CgroupV2MemoryController* memory,\n+                      CgroupV2CpuController* cpu,\n+                      CgroupV2Controller unified) :\n+        _unified(unified),\n+        _memory(new CachingCgroupController<CgroupMemoryController>(memory)),\n+        _cpu(new CachingCgroupController<CgroupCpuController>(cpu)) {\n@@ -72,20 +120,8 @@\n-    jlong read_memory_limit_in_bytes();\n-    int cpu_quota();\n-    int cpu_period();\n-    int cpu_shares();\n-    jlong memory_and_swap_limit_in_bytes();\n-    jlong memory_soft_limit_in_bytes();\n-    jlong memory_usage_in_bytes();\n-    jlong memory_max_usage_in_bytes();\n-    jlong rss_usage_in_bytes();\n-    jlong cache_usage_in_bytes();\n-\n-    char * cpu_cpuset_cpus();\n-    char * cpu_cpuset_memory_nodes();\n-    jlong pids_max();\n-    jlong pids_current();\n-\n-    bool is_containerized();\n-    void print_version_specific_info(outputStream* st);\n-\n-    const char * container_type() {\n+    char * cpu_cpuset_cpus() override;\n+    char * cpu_cpuset_memory_nodes() override;\n+    jlong pids_max() override;\n+    jlong pids_current() override;\n+\n+    bool is_containerized() override;\n+\n+    const char * container_type() override {\n@@ -94,2 +130,2 @@\n-    CachingCgroupController * memory_controller() { return _memory; }\n-    CachingCgroupController * cpu_controller() { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController>* memory_controller() { return _memory; }\n+    CachingCgroupController<CgroupCpuController>* cpu_controller() { return _cpu; }\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":74,"deletions":38,"binary":false,"changes":112,"status":"modified"}]}