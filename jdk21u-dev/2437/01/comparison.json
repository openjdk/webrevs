{"files":[{"patch":"@@ -5916,1 +5916,1 @@\n-\/\/     return zero (0) if copy fails, otherwise 'len'.\n+\/\/     return index of non-latin1 character if copy fails, otherwise 'len'.\n@@ -6133,0 +6133,3 @@\n+\/\/ Intrinsic for java.lang.StringUTF16.compress(char[] src, int srcOff, byte[] dst, int dstOff, int len)\n+\/\/ Return the array length if every element in array can be encoded,\n+\/\/ otherwise, the index of first non-latin1 (> 0xff) character.\n@@ -6139,3 +6142,0 @@\n-  \/\/ Adjust result: res == len ? len : 0\n-  cmp(len, res);\n-  csel(res, res, zr, EQ);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -12802,10 +12802,2 @@\n-    Label Lskip, Ldone;\n-    __ li($result$$Register, 0);\n-    __ string_compress_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,\n-                          $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register, Ldone);\n-    __ rldicl_($tmp1$$Register, $len$$Register, 0, 64-3); \/\/ Remaining characters.\n-    __ beq(CCR0, Lskip);\n-    __ string_compress($src$$Register, $dst$$Register, $tmp1$$Register, $tmp2$$Register, Ldone);\n-    __ bind(Lskip);\n-    __ mr($result$$Register, $len$$Register);\n-    __ bind(Ldone);\n+    __ encode_iso_array($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register, $tmp2$$Register,\n+                        $tmp3$$Register, $tmp4$$Register, $tmp5$$Register, $result$$Register, false);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1771,1 +1771,3 @@\n-\/\/ result: the array length if every element in array can be encoded; 0, otherwise.\n+\/\/ Intrinsic for java.lang.StringUTF16.compress(char[] src, int srcOff, byte[] dst, int dstOff, int len)\n+\/\/ result: the array length if every element in array can be encoded,\n+\/\/ otherwise, the index of first non-latin1 (> 0xff) character.\n@@ -1774,1 +1776,0 @@\n-  Label done;\n@@ -1776,3 +1777,0 @@\n-  beqz(len, done);\n-  mv(result, zr);\n-  bind(done);\n@@ -1786,1 +1784,1 @@\n-\/\/     return zero (0) if copy fails, otherwise 'len'.\n+\/\/     return index of non-latin1 character if copy fails, otherwise 'len'.\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -10180,1 +10180,1 @@\n-                       $tmp$$Register, false, false);\n+                       $tmp$$Register, true, false);\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -8840,1 +8840,3 @@\n-\/\/   ..\\jdk\\src\\java.base\\share\\classes\\java\\lang\\StringUTF16.java\n+\/\/ Intrinsic for java.lang.StringUTF16.compress(char[] src, int srcOff, byte[] dst, int dstOff, int len)\n+\/\/ Return the array length if every element in array can be encoded,\n+\/\/ otherwise, the index of first non-latin1 (> 0xff) character.\n@@ -8842,1 +8844,1 @@\n-\/\/   private static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+\/\/   public static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n@@ -8844,3 +8846,3 @@\n-\/\/       int c = src[srcOff++];\n-\/\/       if (c >>> 8 != 0) {\n-\/\/         return 0;\n+\/\/       char c = src[srcOff];\n+\/\/       if (c > 0xff) {\n+\/\/           return i;  \/\/ return index of non-latin1 char\n@@ -8848,1 +8850,3 @@\n-\/\/       dst[dstOff++] = (byte)c;\n+\/\/       dst[dstOff] = (byte)c;\n+\/\/       srcOff++;\n+\/\/       dstOff++;\n@@ -8856,1 +8860,1 @@\n-  Label copy_chars_loop, return_length, return_zero, done;\n+  Label copy_chars_loop, done, reset_sp, copy_tail;\n@@ -8871,1 +8875,1 @@\n-  push(len);\n+  movl(result, len);\n@@ -8877,1 +8881,1 @@\n-    Label copy_32_loop, copy_loop_tail, below_threshold;\n+    Label copy_32_loop, copy_loop_tail, below_threshold, reset_for_copy_tail;\n@@ -8882,1 +8886,1 @@\n-    \/\/ if length of the string is less than 16, handle it in an old fashioned way\n+    \/\/ if length of the string is less than 32, handle it the old fashioned way\n@@ -8888,2 +8892,2 @@\n-    movl(result, 0x00FF);\n-    evpbroadcastw(tmp2Reg, result, Assembler::AVX_512bit);\n+    movl(tmp5, 0x00FF);\n+    evpbroadcastw(tmp2Reg, tmp5, Assembler::AVX_512bit);\n@@ -8892,1 +8896,1 @@\n-    jcc(Assembler::zero, post_alignment);\n+    jccb(Assembler::zero, post_alignment);\n@@ -8901,1 +8905,1 @@\n-    jcc(Assembler::zero, post_alignment);\n+    jccb(Assembler::zero, post_alignment);\n@@ -8904,4 +8908,5 @@\n-    movl(result, 0xFFFFFFFF);\n-    shlxl(result, result, tmp5);\n-    notl(result);\n-    kmovdl(mask2, result);\n+    movl(len, 0xFFFFFFFF);\n+    shlxl(len, len, tmp5);\n+    notl(len);\n+    kmovdl(mask2, len);\n+    movl(len, result);\n@@ -8912,1 +8917,1 @@\n-    jcc(Assembler::carryClear, return_zero);\n+    jcc(Assembler::carryClear, copy_tail);\n@@ -8927,1 +8932,1 @@\n-    jcc(Assembler::zero, copy_loop_tail);\n+    jccb(Assembler::zero, copy_loop_tail);\n@@ -8937,1 +8942,1 @@\n-    jcc(Assembler::carryClear, return_zero);\n+    jccb(Assembler::carryClear, reset_for_copy_tail);\n@@ -8943,1 +8948,1 @@\n-    jcc(Assembler::notZero, copy_32_loop);\n+    jccb(Assembler::notZero, copy_32_loop);\n@@ -8948,1 +8953,1 @@\n-    jcc(Assembler::zero, return_length);\n+    jcc(Assembler::zero, done);\n@@ -8953,3 +8958,3 @@\n-    movl(result, 0xFFFFFFFF);\n-    shlxl(result, result, len);\n-    notl(result);\n+    movl(tmp5, 0xFFFFFFFF);\n+    shlxl(tmp5, tmp5, len);\n+    notl(tmp5);\n@@ -8957,1 +8962,1 @@\n-    kmovdl(mask2, result);\n+    kmovdl(mask2, tmp5);\n@@ -8962,1 +8967,1 @@\n-    jcc(Assembler::carryClear, return_zero);\n+    jcc(Assembler::carryClear, copy_tail);\n@@ -8965,1 +8970,7 @@\n-    jmp(return_length);\n+    jmp(done);\n+\n+    bind(reset_for_copy_tail);\n+    lea(src, Address(src, tmp5, Address::times_2));\n+    lea(dst, Address(dst, tmp5, Address::times_1));\n+    subptr(len, tmp5);\n+    jmp(copy_chars_loop);\n@@ -8971,1 +8982,1 @@\n-    Label copy_32_loop, copy_16, copy_tail;\n+    Label copy_32_loop, copy_16, copy_tail_sse, reset_for_copy_tail;\n@@ -8973,1 +8984,3 @@\n-    movl(result, len);\n+    \/\/ vectored compression\n+    testl(len, 0xfffffff8);\n+    jcc(Assembler::zero, copy_tail);\n@@ -8976,0 +8989,2 @@\n+    movdl(tmp1Reg, tmp5);\n+    pshufd(tmp1Reg, tmp1Reg, 0);   \/\/ store Unicode mask in tmp1Reg\n@@ -8977,5 +8992,2 @@\n-    \/\/ vectored compression\n-    andl(len, 0xfffffff0);    \/\/ vector count (in chars)\n-    andl(result, 0x0000000f);    \/\/ tail count (in chars)\n-    testl(len, len);\n-    jcc(Assembler::zero, copy_16);\n+    andl(len, 0xfffffff0);\n+    jccb(Assembler::zero, copy_16);\n@@ -8984,2 +8996,0 @@\n-    movdl(tmp1Reg, tmp5);\n-    pshufd(tmp1Reg, tmp1Reg, 0);   \/\/ store Unicode mask in tmp1Reg\n@@ -8998,1 +9008,1 @@\n-    jcc(Assembler::notZero, return_zero);\n+    jccb(Assembler::notZero, reset_for_copy_tail);\n@@ -9002,1 +9012,1 @@\n-    jcc(Assembler::notZero, copy_32_loop);\n+    jccb(Assembler::notZero, copy_32_loop);\n@@ -9006,5 +9016,3 @@\n-    movl(len, result);\n-    andl(len, 0xfffffff8);    \/\/ vector count (in chars)\n-    andl(result, 0x00000007);    \/\/ tail count (in chars)\n-    testl(len, len);\n-    jccb(Assembler::zero, copy_tail);\n+    \/\/ len = 0\n+    testl(result, 0x00000008);     \/\/ check if there's a block of 8 chars to compress\n+    jccb(Assembler::zero, copy_tail_sse);\n@@ -9012,2 +9020,0 @@\n-    movdl(tmp1Reg, tmp5);\n-    pshufd(tmp1Reg, tmp1Reg, 0);   \/\/ store Unicode mask in tmp1Reg\n@@ -9018,1 +9024,1 @@\n-    jccb(Assembler::notZero, return_zero);\n+    jccb(Assembler::notZero, reset_for_copy_tail);\n@@ -9023,0 +9029,1 @@\n+    jmpb(copy_tail_sse);\n@@ -9024,1 +9031,9 @@\n-    bind(copy_tail);\n+    bind(reset_for_copy_tail);\n+    movl(tmp5, result);\n+    andl(tmp5, 0x0000000f);\n+    lea(src, Address(src, tmp5, Address::times_2));\n+    lea(dst, Address(dst, tmp5, Address::times_1));\n+    subptr(len, tmp5);\n+    jmpb(copy_chars_loop);\n+\n+    bind(copy_tail_sse);\n@@ -9026,0 +9041,1 @@\n+    andl(len, 0x00000007);    \/\/ tail count (in chars)\n@@ -9028,0 +9044,1 @@\n+  bind(copy_tail);\n@@ -9029,1 +9046,1 @@\n-  jccb(Assembler::zero, return_length);\n+  jccb(Assembler::zero, done);\n@@ -9035,4 +9052,4 @@\n-  load_unsigned_short(result, Address(src, len, Address::times_2));\n-  testl(result, 0xff00);      \/\/ check if Unicode char\n-  jccb(Assembler::notZero, return_zero);\n-  movb(Address(dst, len, Address::times_1), result);  \/\/ ASCII char; compress to 1 byte\n+  load_unsigned_short(tmp5, Address(src, len, Address::times_2));\n+  testl(tmp5, 0xff00);      \/\/ check if Unicode char\n+  jccb(Assembler::notZero, reset_sp);\n+  movb(Address(dst, len, Address::times_1), tmp5);  \/\/ ASCII char; compress to 1 byte\n@@ -9040,6 +9057,1 @@\n-  jcc(Assembler::notZero, copy_chars_loop);\n-\n-  \/\/ if compression succeeded, return length\n-  bind(return_length);\n-  pop(result);\n-  jmpb(done);\n+  jccb(Assembler::notZero, copy_chars_loop);\n@@ -9047,4 +9059,3 @@\n-  \/\/ if compression failed, return 0\n-  bind(return_zero);\n-  xorl(result, result);\n-  addptr(rsp, wordSize);\n+  \/\/ add len then return (len will be zero if compress succeeded, otherwise negative)\n+  bind(reset_sp);\n+  addl(result, len);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":75,"deletions":64,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -1678,5 +1678,4 @@\n-            this.value = StringUTF16.compress(value, off, len);\n-            if (this.value != null) {\n-                this.coder = LATIN1;\n-                return;\n-            }\n+            byte[] val = StringUTF16.compress(value, off, len);\n+            this.coder = StringUTF16.coderFromArrayLen(val, len);\n+            this.value = val;\n+            return;\n@@ -1723,0 +1722,3 @@\n+                    \/\/ store c to make sure it has a UTF16 char\n+                    StringUTF16.putChar(this.value, j++, c);\n+                    i++;\n@@ -1810,0 +1812,4 @@\n+                    \/\/ Store c to make sure sb has a UTF16 char\n+                    StringUTF16.putChar(this.value, j++, c);\n+                    count = j;\n+                    i++;\n@@ -1921,0 +1927,4 @@\n+     * <p>\n+     * The contents are unspecified if the {@code CharSequence}\n+     * is modified during the method call or an exception is thrown\n+     * when accessing the {@code CharSequence}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -347,6 +347,4 @@\n-            byte[] val = StringLatin1.toBytes(codePoints, offset, count);\n-            if (val != null) {\n-                this.coder = LATIN1;\n-                this.value = val;\n-                return;\n-            }\n+            byte[] val = StringUTF16.compress(codePoints, offset, count);\n+            this.coder = StringUTF16.coderFromArrayLen(val, count);\n+            this.value = val;\n+            return;\n@@ -544,8 +542,5 @@\n-                int sl = offset + length;\n-                byte[] dst = new byte[length];\n-                if (dp > 0) {\n-                    System.arraycopy(bytes, offset, dst, 0, dp);\n-                    offset += dp;\n-                }\n-                while (offset < sl) {\n-                    int b1 = bytes[offset++];\n+                \/\/ Decode with a stable copy, to be the result if the decoded length is the same\n+                byte[] latin1 = Arrays.copyOfRange(bytes, offset, offset + length);\n+                int sp = dp;            \/\/ first dp bytes are already in the copy\n+                while (sp < length) {\n+                    int b1 = latin1[sp++];\n@@ -553,1 +548,1 @@\n-                        dst[dp++] = (byte)b1;\n+                        latin1[dp++] = (byte)b1;\n@@ -556,2 +551,2 @@\n-                    if ((b1 & 0xfe) == 0xc2 && offset < sl) { \/\/ b1 either 0xc2 or 0xc3\n-                        int b2 = bytes[offset];\n+                    if ((b1 & 0xfe) == 0xc2 && sp < length) { \/\/ b1 either 0xc2 or 0xc3\n+                        int b2 = latin1[sp];\n@@ -559,2 +554,2 @@\n-                            dst[dp++] = (byte)decode2(b1, b2);\n-                            offset++;\n+                            latin1[dp++] = (byte)decode2(b1, b2);\n+                            sp++;\n@@ -566,1 +561,1 @@\n-                    offset--;\n+                    sp--;\n@@ -569,3 +564,3 @@\n-                if (offset == sl) {\n-                    if (dp != dst.length) {\n-                        dst = Arrays.copyOf(dst, dp);\n+                if (sp == length) {\n+                    if (dp != latin1.length) {\n+                        latin1 = Arrays.copyOf(latin1, dp);\n@@ -573,1 +568,1 @@\n-                    this.value = dst;\n+                    this.value = latin1;\n@@ -577,4 +572,3 @@\n-                byte[] buf = StringUTF16.newBytesFor(length);\n-                StringLatin1.inflate(dst, 0, buf, 0, dp);\n-                dst = buf;\n-                dp = decodeUTF8_UTF16(bytes, offset, sl, dst, dp, true);\n+                byte[] utf16 = StringUTF16.newBytesFor(length);\n+                StringLatin1.inflate(latin1, 0, utf16, 0, dp);\n+                dp = decodeUTF8_UTF16(latin1, sp, length, utf16, dp, true);\n@@ -582,1 +576,1 @@\n-                    dst = Arrays.copyOf(dst, dp << 1);\n+                    utf16 = Arrays.copyOf(utf16, dp << 1);\n@@ -584,1 +578,1 @@\n-                this.value = dst;\n+                this.value = utf16;\n@@ -656,6 +650,4 @@\n-                    byte[] bs = StringUTF16.compress(ca, 0, clen);\n-                    if (bs != null) {\n-                        value = bs;\n-                        coder = LATIN1;\n-                        return;\n-                    }\n+                    byte[] val = StringUTF16.compress(ca, 0, clen);;\n+                    this.coder = StringUTF16.coderFromArrayLen(val, clen);\n+                    this.value = val;\n+                    return;\n@@ -687,6 +679,4 @@\n-                byte[] bs = StringUTF16.compress(ca, 0, caLen);\n-                if (bs != null) {\n-                    value = bs;\n-                    coder = LATIN1;\n-                    return;\n-                }\n+                byte[] val = StringUTF16.compress(ca, 0, caLen);\n+                this.coder = StringUTF16.coderFromArrayLen(val, caLen);\n+                this.value = val;\n+                return;\n@@ -830,4 +820,3 @@\n-            byte[] bs = StringUTF16.compress(ca, 0, caLen);\n-            if (bs != null) {\n-                return new String(bs, LATIN1);\n-            }\n+            byte[] val = StringUTF16.compress(ca, 0, caLen);\n+            byte coder = StringUTF16.coderFromArrayLen(val, caLen);\n+            return new String(val, coder);\n@@ -4753,1 +4742,1 @@\n-     * Package private constructor. Trailing Void argument is there for\n+     * Private constructor. Trailing Void argument is there for\n@@ -4760,0 +4749,3 @@\n+     *\n+     * <p> The contents of the string are unspecified if the character array\n+     * is modified during string construction.\n@@ -4761,1 +4753,1 @@\n-    String(char[] value, int off, int len, Void sig) {\n+    private String(char[] value, int off, int len, Void sig) {\n@@ -4769,5 +4761,3 @@\n-            if (val != null) {\n-                this.value = val;\n-                this.coder = LATIN1;\n-                return;\n-            }\n+            this.coder = StringUTF16.coderFromArrayLen(val, len);\n+            this.value = val;\n+            return;\n@@ -4782,0 +4772,3 @@\n+     *\n+     * <p> The contents of the string are unspecified if the {@code StringBuilder}\n+     * is modified during string construction.\n@@ -4792,6 +4785,3 @@\n-                byte[] buf = StringUTF16.compress(val, 0, length);\n-                if (buf != null) {\n-                    this.coder = LATIN1;\n-                    this.value = buf;\n-                    return;\n-                }\n+                this.value = StringUTF16.compress(val, 0, length);\n+                this.coder = StringUTF16.coderFromArrayLen(this.value, length);\n+                return;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":50,"deletions":60,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -50,0 +50,4 @@\n+    public static boolean canEncode(char cp) {\n+        return cp <= 0xff;\n+    }\n+\n@@ -51,1 +55,1 @@\n-        return cp >>> 8 == 0;\n+        return cp >=0 && cp <= 0xff;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import jdk.internal.vm.annotation.DontInline;\n@@ -45,0 +44,2 @@\n+    \/\/ Return a new byte array for a UTF16-coded string for len chars\n+    \/\/ Throw an exception if out of range\n@@ -46,0 +47,6 @@\n+        return new byte[newBytesLength(len)];\n+    }\n+\n+    \/\/ Check the size of a UTF16-coded string\n+    \/\/ Throw an exception if out of range\n+    public static int newBytesLength(int len) {\n@@ -49,1 +56,1 @@\n-        if (len > MAX_LENGTH) {\n+        if (len >= MAX_LENGTH) {\n@@ -53,1 +60,1 @@\n-        return new byte[len << 1];\n+        return len << 1;\n@@ -150,0 +157,7 @@\n+    \/**\n+     * {@return an encoded byte[] for the UTF16 characters in char[]}\n+     * No checking is done on the characters, some may or may not be latin1.\n+     * @param value a char array\n+     * @param off an offset\n+     * @param len a length\n+     *\/\n@@ -160,4 +174,48 @@\n-    public static byte[] compress(char[] val, int off, int len) {\n-        byte[] ret = new byte[len];\n-        if (compress(val, off, ret, 0, len) == len) {\n-            return ret;\n+    \/\/ Clever way to get the coder from a byte array returned from compress\n+    \/\/ that maybe either latin1 or UTF16-coded\n+    \/\/ Equivalent to (len == val.length) ? LATIN1 : UTF16\n+    @ForceInline\n+    static byte coderFromArrayLen(byte[] value, int len) {\n+        return (byte) ((len - value.length) >>> Integer.SIZE - 1);\n+    }\n+\n+    \/**\n+     * {@return Compress the char array (containing UTF16) into a compact strings byte array}\n+     * If all the chars are LATIN1, it returns an array with len == count,\n+     * otherwise, it contains UTF16 characters.\n+     * <p>\n+     * A UTF16 array is returned *only* if at least 1 non-latin1 character is present.\n+     * This must be true even if the input array is modified while this method is executing.\n+     * This is assured by copying the characters while checking for latin1.\n+     * If all characters are latin1, a byte array with length equals count is returned,\n+     * indicating all latin1 chars. The scan may be implemented as an intrinsic,\n+     * which returns the index of the first non-latin1 character.\n+     * When the first non-latin1 character is found, it switches to creating a new\n+     * buffer; the saved prefix of latin1 characters is copied to the new buffer;\n+     * and the remaining input characters are copied to the buffer.\n+     * The index of the known non-latin1 character is checked, if it is latin1,\n+     * the input has been changed. In this case, a second attempt is made to compress to\n+     * latin1 from the copy made in the first pass to the originally allocated latin1 buffer.\n+     * If it succeeds the return value is latin1, otherwise, the utf16 value is returned.\n+     * In this unusual case, the result is correct for the snapshot of the value.\n+     * The resulting string contents are unspecified if the input array is modified during this\n+     * operation, but it is ensured that at least 1 non-latin1 character is present in\n+     * the non-latin1 buffer.\n+     *\n+     * @param val   a char array\n+     * @param off   starting offset\n+     * @param count count of chars to be compressed, {@code count} > 0\n+     *\/\n+    @ForceInline\n+    public static byte[] compress(final char[] val, final int off, final int count) {\n+        byte[] latin1 = new byte[count];\n+        int ndx = compress(val, off, latin1, 0, count);\n+        if (ndx != count) {\n+            \/\/ Switch to UTF16\n+            byte[] utf16 = toBytes(val, off, count);\n+            \/\/ If the original character that was found to be non-latin1 is latin1 in the copy\n+            \/\/ try to make a latin1 string from the copy\n+            if (getChar(utf16, ndx) > 0xff\n+                    || compress(utf16, 0, latin1, 0, count) != count) {\n+                return utf16;\n+            }\n@@ -165,1 +223,27 @@\n-        return null;\n+        return latin1;     \/\/ latin1 success\n+    }\n+\n+    \/**\n+     * {@return Compress the internal byte array (containing UTF16) into a compact strings byte array}\n+     * If all the chars are LATIN1, it returns an array with len == count,\n+     * otherwise, it contains UTF16 characters.\n+     * <p>\n+     * Refer to the description of the algorithm in {@link #compress(char[], int, int)}.\n+     *\n+     * @param val   a byte array with UTF16 coding\n+     * @param off   starting offset\n+     * @param count count of chars to be compressed, {@code count} > 0\n+     *\/\n+    public static byte[] compress(final byte[] val, final int off, final int count) {\n+        byte[] latin1 = new byte[count];\n+        int ndx = compress(val, off, latin1, 0, count);\n+        if (ndx != count) {\/\/ Switch to UTF16\n+            byte[] utf16 = Arrays.copyOfRange(val, off << 1, newBytesLength(off + count));\n+            \/\/ If the original character that was found to be non-latin1 is latin1 in the copy\n+            \/\/ try to make a latin1 string from the copy\n+            if (getChar(utf16, ndx) > 0xff\n+                    || compress(utf16, 0, latin1, 0, count) != count) {\n+                return utf16;\n+            }\n+        }\n+        return latin1;     \/\/ latin1 success\n@@ -168,4 +252,59 @@\n-    public static byte[] compress(byte[] val, int off, int len) {\n-        byte[] ret = new byte[len];\n-        if (compress(val, off, ret, 0, len) == len) {\n-            return ret;\n+    \/**\n+     * {@return compress the code points into a compact strings byte array}\n+     * If all the chars are LATIN1, returns an array with len == count.\n+     * If not, a new byte array is allocated and code points converted to UTF16.\n+     * The algorithm is similar to that of {@link #compress(char[], int, int)}.\n+     * <p>\n+     * The resulting encoding is attempted in several steps:\n+     * <UL>\n+     *     <LI>If no non-latin1 characters are found, the encoding is latin1<\/LI>\n+     *     <LI>If an estimate of the number of characters needed to represent the codepoints is\n+     *         equal to the string length, they are all BMP with at least 1 UTF16 character\n+     *         and are copied to the result. <\/LI>\n+     *     <LI>The extractCodePoints method is called to carefully expand surrogates. <\/LI>\n+     * <\/UL>\n+     *\n+     * @param val   an int array of code points\n+     * @param off   starting offset\n+     * @param count length of code points to be compressed, length > 0\n+     *\/\n+    public static byte[] compress(final int[] val, int off, final int count) {\n+        \/\/ Optimistically copy all latin1 code points to the destination\n+        byte[] latin1 = new byte[count];\n+        final int end = off + count;\n+        for (int ndx = 0; ndx < count; ndx++, off++) {\n+            int cp = val[off];\n+            if (cp >= 0 && cp <= 0xff) {\n+                latin1[ndx] = (byte)cp;\n+            } else {\n+                \/\/ Pass 1: Compute precise size of char[]; see extractCodePoints for caveat\n+                int estSize = ndx + computeCodePointSize(val, off, end);\n+\n+                \/\/ Pass 2: Switch to UTF16\n+                \/\/ cp = val[ndx] is at least one code point known to be UTF16\n+                byte[] utf16 = newBytesFor(estSize);\n+                if (ndx > 0) {\n+                    StringLatin1.inflate(latin1, 0, utf16, 0, ndx); \/\/ inflate latin1 bytes\n+                }\n+\n+                if (estSize == count) {\n+                    \/\/ Based on the computed size, all remaining code points are BMP and\n+                    \/\/ can be copied without checking again\n+                    putChar(utf16, ndx, cp);        \/\/ ensure utf16 has a UTF16 char\n+                    off++;\n+                    for (int i = ndx + 1; i < count; i++, off++) {\n+                        putChar(utf16, i, val[off]);\n+                    }\n+                } else {\n+                    \/\/ Some codepoint is a surrogate pair\n+                    utf16 = extractCodepoints(val, off, end, utf16, ndx);\n+\n+                    \/\/ The original character that was found to be UTF16 is not UTF16 in the copy\n+                    \/\/ Try to make a latin1 string from the copy\n+                    if (getChar(utf16, ndx) <= 0xff &&\n+                            compress(utf16, 0, latin1, 0, count) == count) {\n+                        return latin1;     \/\/ latin1 success\n+                    }\n+                }\n+                return utf16;\n+            }\n@@ -173,1 +312,65 @@\n-        return null;\n+        return latin1;     \/\/ Latin1 success\n+    }\n+\n+    \/\/ Extract code points into chars in the byte array\n+    \/\/\n+    \/\/ Guard against possible races with the input array changing between the previous\n+    \/\/ computation of the required output size and storing the bmp or surrogates.\n+    \/\/ If a BMP code point is changed to a supplementary code point it would require 2 chars\n+    \/\/ in the output. Changing a supplementary char to BMP would reduce the size.\n+    \/\/ If the utf16 destination is not large enough, it is resized to fit the\n+    \/\/ remaining codepoints assuming they occupy 2 characters.\n+    \/\/ The destination may be copied to return exactly the final length.\n+    \/\/ The additional allocations and compression only occur if the input array is modified.\n+    private static byte[] extractCodepoints(int[] val, int off, int end, byte[] dst, int dstOff) {\n+        while (off < end) {\n+            \/\/ Compute a minimum estimate on the number of characters can be put into the dst\n+            \/\/ given the current codepoint and the number of remaining codepoints\n+            int codePoint = val[off];           \/\/ read each codepoint from val only once\n+            int dstLimit = dstOff\n+                    + Character.charCount(codePoint)\n+                    + (end - off - 1);\n+            if (dstLimit > (dst.length >> 1)) {\n+                \/\/ Resize to hold the remaining codepoints assuming they are all surrogates.\n+                \/\/ By resizing to the maximum that might be needed, only a single resize will occur.\n+                \/\/ dstLimit includes only a single char per codepoint, pad with an additional for each.\n+                int maxRemaining = dstLimit + (end - off - 1);\n+                dst = Arrays.copyOf(dst, newBytesLength(maxRemaining));\n+            }\n+            \/\/ Efficiently copy as many codepoints as fit within the current estimated limit\n+            \/\/ The dst at least enough space for the current codepoint.\n+            while (true) {\n+                if (Character.isBmpCodePoint(codePoint)) {\n+                    putChar(dst, dstOff++, codePoint);\n+                } else {\n+                    putChar(dst, dstOff++, Character.highSurrogate(codePoint));\n+                    putChar(dst, dstOff++, Character.lowSurrogate(codePoint));\n+                }\n+                off++;\n+                if (dstOff + 2 > dstLimit)\n+                    break;      \/\/ no space for another surrogate; recompute limit\n+                codePoint = val[off];\n+            }\n+        }\n+        if (dstOff != (dst.length >> 1)) {\n+            \/\/ Truncate to actual length; should only occur if a codepoint was racily\n+            \/\/ changed from a surrogate to a BMP character.\n+            return Arrays.copyOf(dst, newBytesLength(dstOff));\n+        }\n+        return dst;\n+    }\n+\n+    \/\/ Compute the number of chars needed to represent the code points from off to end-1\n+    private static int computeCodePointSize(int[] val, int off, int end) {\n+        int n = end - off;\n+        while (off < end) {\n+            int codePoint = val[off++];\n+            if (Character.isBmpCodePoint(codePoint)) {\n+                continue;\n+            } else if (Character.isValidCodePoint(codePoint)) {\n+                n++;\n+            } else {\n+                throw new IllegalArgumentException(Integer.toString(codePoint));\n+            }\n+        }\n+        return n;\n@@ -181,3 +384,2 @@\n-            if (c > 0xFF) {\n-                len = 0;\n-                break;\n+            if (c > 0xff) {\n+                return i;  \/\/ return index of non-latin1 char\n@@ -199,3 +401,2 @@\n-            if (c > 0xFF) {\n-                len = 0;\n-                break;\n+            if (c > 0xff) {\n+                return i;  \/\/ return index of non-latin1 char\n@@ -210,0 +411,1 @@\n+    \/\/ Create the UTF16 buffer for !COMPACT_STRINGS\n@@ -212,11 +414,2 @@\n-        \/\/ Pass 1: Compute precise size of char[]\n-        int n = len;\n-        for (int i = index; i < end; i++) {\n-            int cp = val[i];\n-            if (Character.isBmpCodePoint(cp))\n-                continue;\n-            else if (Character.isValidCodePoint(cp))\n-                n++;\n-            else throw new IllegalArgumentException(Integer.toString(cp));\n-        }\n-        \/\/ Pass 2: Allocate and fill in <high, low> pair\n+        int n = computeCodePointSize(val, index, end);\n+\n@@ -224,11 +417,2 @@\n-        for (int i = index, j = 0; i < end; i++, j++) {\n-            int cp = val[i];\n-            if (Character.isBmpCodePoint(cp)) {\n-                putChar(buf, j, cp);\n-            } else {\n-                putChar(buf, j++, Character.highSurrogate(cp));\n-                putChar(buf, j, Character.lowSurrogate(cp));\n-            }\n-        }\n-        return buf;\n-    }\n+        return extractCodepoints(val, index, end, buf, 0);\n+     }\n@@ -655,4 +839,3 @@\n-                byte[] val = compress(buf, 0, len);\n-                if (val != null) {\n-                    return new String(val, LATIN1);\n-                }\n+                byte[] res = StringUTF16.compress(buf, 0, len);\n+                byte coder = StringUTF16.coderFromArrayLen(res, len);\n+                return new String(res, coder);\n@@ -773,4 +956,3 @@\n-            byte[] lat1Result = compress(result, 0, resultLen);\n-            if (lat1Result != null) {\n-                return new String(lat1Result, LATIN1);\n-            }\n+            byte[] res = StringUTF16.compress(result, 0, resultLen);\n+            byte coder = StringUTF16.coderFromArrayLen(res, resultLen);\n+            return new String(res, coder);    \/\/ combination 6\n@@ -840,1 +1022,1 @@\n-        if (bits > 0xFF) {\n+        if (bits < 0 || bits > 0xff) {\n@@ -941,1 +1123,1 @@\n-        if (bits > 0xFF) {\n+        if (bits < 0 || bits > 0xff) {\n@@ -1170,4 +1352,3 @@\n-            byte[] buf = compress(val, index, len);\n-            if (buf != null) {\n-                return new String(buf, LATIN1);\n-            }\n+            byte[] res = StringUTF16.compress(val, index, len);\n+            byte coder = StringUTF16.coderFromArrayLen(res, len);\n+            return new String(res, coder);\n@@ -1504,2 +1685,2 @@\n-    static final int HI_BYTE_SHIFT;\n-    static final int LO_BYTE_SHIFT;\n+    private static final int HI_BYTE_SHIFT;\n+    private static final int LO_BYTE_SHIFT;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":238,"deletions":57,"binary":false,"changes":295,"status":"modified"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8311906\n+ * @summary Validates String constructor intrinsics using varied input data.\n+ * @key randomness\n+ * @library \/compiler\/patches \/test\/lib\n+ * @build java.base\/java.lang.Helper\n+ * @run main\/othervm\/timeout=1200 -Xbatch -XX:CompileThreshold=100 compiler.intrinsics.string.TestStringConstructionIntrinsics\n+ *\/\n+\/*\n+ * @test\n+ * @bug 8311906\n+ * @summary Validates String constructor intrinsic for AVX3 works with and without\n+ *          AVX3Threshold=0\n+ * @key randomness\n+ * @library \/compiler\/patches \/test\/lib\n+ * @build java.base\/java.lang.Helper\n+ * @requires vm.cpu.features ~= \".*avx512.*\"\n+ * @run main\/othervm\/timeout=1200 -Xbatch -XX:CompileThreshold=100 -XX:UseAVX=3 compiler.intrinsics.string.TestStringConstructionIntrinsics\n+ * @run main\/othervm\/timeout=1200 -Xbatch -XX:CompileThreshold=100 -XX:UseAVX=3 -XX:+UnlockDiagnosticVMOptions -XX:AVX3Threshold=0 compiler.intrinsics.string.TestStringConstructionIntrinsics\n+ *\/\n+\n+package compiler.intrinsics.string;\n+\n+import java.lang.Helper;\n+import java.util.Random;\n+\n+import jdk.test.lib.Utils;\n+\n+public class TestStringConstructionIntrinsics {\n+\n+    private static byte[] bytes = new byte[2 * (4096 + 32)];\n+\n+    private static char[] chars = new char[4096 + 32];\n+\n+    \/\/ Used a scratch buffer, sized to accommodate inflated\n+    private static byte[] dst = new byte[bytes.length * 2];\n+\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    \/**\n+     * Completely initialize the bytes test array. The lowest index that will be\n+     * non-latin1 is marked by nlOffset\n+     *\/\n+    public static void initializeBytes(int off, int len, int nonLatin1, int nlOffset) {\n+        int maxLen = bytes.length >> 1;\n+        assert (len + off < maxLen);\n+        \/\/ insert \"canary\" (non-latin1) values before offset\n+        for (int i = 0; i < off; i++) {\n+            Helper.putCharSB(bytes, i, ((i + 15) & 0x7F) | 0x180);\n+        }\n+        \/\/ fill the array segment\n+        for (int i = off; i < len + off; i++) {\n+            Helper.putCharSB(bytes, i, ((i - off + 15) & 0xFF));\n+        }\n+        if (nonLatin1 != 0) {\n+            \/\/ modify a number disparate indexes to be non-latin1\n+            for (int i = 0; i < nonLatin1; i++) {\n+                int idx = off + RANDOM.nextInt(len - nlOffset) + nlOffset;\n+                Helper.putCharSB(bytes, i, ((i + 15) & 0x7F) | 0x180);\n+            }\n+        }\n+        \/\/ insert \"canary\" non-latin1 values after array segment\n+        for (int i = len + off; i < maxLen; i++) {\n+            Helper.putCharSB(bytes, i, ((i + 15) & 0x7F) | 0x180);\n+        }\n+    }\n+\n+    \/**\n+     * Completely initialize the char test array. The lowest index that will be\n+     * non-latin1 is marked by nlOffset\n+     *\/\n+    public static void initializeChars(int off, int len, int nonLatin1, int nlOffset) {\n+        assert (len + off <= chars.length);\n+        \/\/ insert \"canary\" non-latin1 values before offset\n+        for (int i = 0; i < off; ++i) {\n+            chars[i] = (char) (((i + 15) & 0x7F) | 0x180);\n+        }\n+        \/\/ fill the array segment\n+        for (int i = off; i < len + off; ++i) {\n+            chars[i] = (char) (((i - off + 15) & 0xFF));\n+        }\n+        if (nonLatin1 != 0) {\n+            \/\/ modify a number disparate chars inside\n+            \/\/ segment to be non-latin1.\n+            for (int i = 0; i < nonLatin1; i++) {\n+                int idx = off + RANDOM.nextInt(len - nlOffset) + nlOffset;\n+                chars[idx] = (char) (0x180 | chars[idx]);\n+            }\n+        }\n+        \/\/ insert \"canary\" non-latin1 values after array segment\n+        for (int i = len + off; i < chars.length; ++i) {\n+            chars[i] = (char) (((i + 15) & 0x7F) | 0x180);\n+        }\n+    }\n+\n+    \/**\n+     * Test different array segment sizes, offsets, and number of non-latin1\n+     * chars.\n+     *\/\n+    public static void testConstructBytes() throws Exception {\n+        for (int off = 0; off < 16; off++) { \/\/ starting offset of array segment\n+            \/\/ Test all array segment sizes 1-63\n+            for (int len = 1; len < 64; len++) {\n+                testConstructBytes(off, len, 0, 0);\n+                testConstructBytes(off, len, 1, 0);\n+                testConstructBytes(off, len, RANDOM.nextInt(30) + 2, 0);\n+            }\n+            \/\/ Test a random selection of sizes between 64 and 4099, inclusive\n+            for (int i = 0; i < 20; i++) {\n+                int len = 64 + RANDOM.nextInt(4100 - 64);\n+                testConstructBytes(off, len, 0, 0);\n+                testConstructBytes(off, len, 1, 0);\n+                testConstructBytes(off, len, RANDOM.nextInt(len) + 2, 0);\n+            }\n+            for (int len : new int[] { 128, 2048 }) {\n+                \/\/ test with negatives only in a 1-63 byte tail\n+                int tail = RANDOM.nextInt(63) + 1;\n+                int ng = RANDOM.nextInt(tail) + 1;\n+                testConstructBytes(off, len + tail, ng, len);\n+            }\n+        }\n+    }\n+\n+    private static void testConstructBytes(int off, int len, int ng, int ngOffset) throws Exception {\n+        assert (len + off < bytes.length);\n+        initializeBytes(off, len, ng, ngOffset);\n+        byte[] dst = new byte[bytes.length];\n+\n+        int calculated = Helper.compress(bytes, off, dst, 0, len);\n+        int expected = compress(bytes, off, dst, 0, len);\n+        if (calculated != expected) {\n+            if (expected != len && ng >= 0 && calculated >= 0 && calculated < expected) {\n+                \/\/ allow intrinsics to return early with a lower value,\n+                \/\/ but only if we're not expecting the full length (no\n+                \/\/ negative bytes)\n+                return;\n+            }\n+            throw new Exception(\"Failed testConstructBytes: \" + \"offset: \" + off + \" \"\n+                    + \"length: \" + len + \" \" + \"return: \" + calculated + \" expected: \" + expected + \" negatives: \"\n+                    + ng + \" offset: \" + ngOffset);\n+        }\n+    }\n+\n+    private static int compress(byte[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+        for (int i = 0; i < len; i++) {\n+            char c = Helper.charAt(src, srcOff);\n+            if (c > 0xff) {\n+                return i;  \/\/ return index of non-latin1 char\n+            }\n+            dst[dstOff] = (byte)c;\n+            srcOff++;\n+            dstOff++;\n+        }\n+        return len;\n+    }\n+\n+    \/**\n+     * Test different array segment sizes, offsets, and number of non-latin1\n+     * chars.\n+     *\/\n+    public static void testConstructChars() throws Exception {\n+        for (int off = 0; off < 16; off++) { \/\/ starting offset of array segment\n+            \/\/ Test all array segment sizes 1-63\n+            for (int len = 1; len < 64; len++) {\n+                testConstructChars(off, len, 0, 0);\n+                testConstructChars(off, len, 1, 0);\n+                testConstructChars(off, len, RANDOM.nextInt(30) + 2, 0);\n+            }\n+            \/\/ Test a random selection of sizes between 64 and 4099, inclusive\n+            for (int i = 0; i < 20; i++) {\n+                int len = 64 + RANDOM.nextInt(4100 - 64);\n+                testConstructChars(off, len, 0, 0);\n+                testConstructChars(off, len, 1, 0);\n+                testConstructChars(off, len, RANDOM.nextInt(len) + 2, 0);\n+            }\n+            for (int len : new int[] { 128, 2048 }) {\n+                \/\/ test with negatives only in a 1-63 byte tail\n+                int tail = RANDOM.nextInt(63) + 1;\n+                int ng = RANDOM.nextInt(tail) + 1;\n+                testConstructChars(off, len + tail, ng, len);\n+            }\n+        }\n+    }\n+\n+    private static void testConstructChars(int off, int len, int nonLatin1, int nlOffset) throws Exception {\n+        assert (len + off < bytes.length);\n+        initializeChars(off, len, nonLatin1, nlOffset);\n+\n+        int calculated = Helper.compress(chars, off, dst, 0, len);\n+        int expected = compress(chars, off, dst, 0, len);\n+        if (calculated != expected) {\n+            if (expected != len && nonLatin1 >= 0 && calculated >= 0 && calculated < expected) {\n+                \/\/ allow intrinsics to return early with a lower value,\n+                \/\/ but only if we're not expecting the full length (no\n+                \/\/ negative bytes)\n+                return;\n+            }\n+            throw new Exception(\"Failed testConstructChars: \" + \"offset: \" + off + \" \"\n+                    + \"length: \" + len + \" \" + \"return: \" + calculated + \" expected: \" + expected + \" non-latin1: \"\n+                    + nonLatin1 + \" offset: \" + nlOffset);\n+        }\n+    }\n+\n+    private static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+        for (int i = 0; i < len; i++) {\n+            char c = src[srcOff];\n+            if (c > 0xff) {\n+                return i;  \/\/ return index of non-latin1 char\n+            }\n+            dst[dstOff] = (byte)c;\n+            srcOff++;\n+            dstOff++;\n+        }\n+        return len;\n+    }\n+\n+    public void run() throws Exception {\n+        \/\/ iterate to eventually get intrinsic inlined\n+        for (int j = 0; j < 200; ++j) {\n+            testConstructBytes();\n+            testConstructChars();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        (new TestStringConstructionIntrinsics()).run();\n+        System.out.println(\"string construction intrinsics validated\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestStringConstructionIntrinsics.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -47,0 +47,5 @@\n+    @jdk.internal.vm.annotation.ForceInline\n+    public static int compress(byte[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+        return StringUTF16.compress(src, srcOff, dst, dstOff, len);\n+    }\n+\n@@ -54,0 +59,5 @@\n+    @jdk.internal.vm.annotation.ForceInline\n+    public static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) {\n+        return StringUTF16.compress(src, srcOff, dst, dstOff, len);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/patches\/java.base\/java\/lang\/Helper.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,4 +25,6 @@\n-    @test\n-    @bug 8054307\n-    @summary test chars() and codePoints()\n-*\/\n+ * @test\n+ * @bug 8054307 8311906 8321514\n+ * @summary test String chars() and codePoints()\n+ * @run main\/othervm -XX:+CompactStrings Chars\n+ * @run main\/othervm -XX:-CompactStrings Chars\n+ *\/\n@@ -47,0 +49,2 @@\n+            testCharsSubrange(cc, ccExp);\n+            testIntsSubrange(ccExp);\n@@ -54,0 +58,1 @@\n+            testCharsSubrange(cc, ccExp);\n@@ -72,0 +77,2 @@\n+            testCharsSubrange(cc, ccExp);\n+            testIntsSubrange(ccExp);\n@@ -79,1 +86,43 @@\n-            throw new RuntimeException(\"chars\/codePoints() failed!\");\n+            throw new RuntimeException(\"testChars failed!\");\n+        }\n+    }\n+\n+    static void testCharsSubrange(char[] cc, int[] expected) {\n+        int[] offsets = { 7, 31 };   \/\/ offsets to test\n+        int LENGTH = 13;\n+        for (int i = 0; i < offsets.length; i++) {\n+            int offset = Math.max(0, offsets[i]);       \/\/ confine to the input array\n+            int count = Math.min(LENGTH, cc.length - offset);\n+            String str = new String(cc, offset, count);\n+            int[] actual = str.chars().toArray();\n+            int errOffset = Arrays.mismatch(actual, 0, actual.length,\n+                    expected, offset, offset + count);\n+            if (errOffset >= 0) {\n+                System.err.printf(\"expected[%d] (%d) != actual[%d] (%d)%n\",\n+                        offset + errOffset, expected[offset + errOffset],\n+                        errOffset, actual[errOffset]);\n+                System.err.println(\"expected: \" + Arrays.toString(expected));\n+                System.err.println(\"actual: \" + Arrays.toString(actual));\n+                throw new RuntimeException(\"testCharsSubrange failed!\");\n+            }\n+        }\n+    }\n+\n+    static void testIntsSubrange(int[] expected) {\n+        int[] offsets = { 7, 31 };   \/\/ offsets to test\n+        int LENGTH = 13;\n+        for (int i = 0; i < offsets.length; i++) {\n+            int offset = Math.max(0, offsets[i]);       \/\/ confine to the input array\n+            int count = Math.min(LENGTH, expected.length - offset);\n+            String str = new String(expected, offset, count);\n+            int[] actual = str.chars().toArray();\n+            int errOffset = Arrays.mismatch(actual, 0, actual.length,\n+                    expected, offset, offset + count);\n+            if (errOffset >= 0) {\n+                System.err.printf(\"expected[%d] (%d) != actual[%d] (%d)%n\",\n+                        offset + errOffset, expected[offset + errOffset],\n+                        errOffset, actual[errOffset]);\n+                System.err.println(\"expected: \" + Arrays.toString(expected));\n+                System.err.println(\"actual: \" + Arrays.toString(actual));\n+                throw new RuntimeException(\"testIntsSubrange failed!\");\n+            }\n@@ -86,1 +135,1 @@\n-            throw new RuntimeException(\"chars\/codePoints() failed!\");\n+            throw new RuntimeException(\"testCPs failed!\");\n","filename":"test\/jdk\/java\/lang\/String\/Chars.java","additions":56,"deletions":7,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+import java.nio.charset.StandardCharsets;\n+\n+\/*\n+ * @test\n+ * @bug 8077559 8321180\n+ * @summary Tests Compact String for maximum size strings\n+ * @requires os.maxMemory >= 8g & vm.bits == 64\n+ * @requires vm.flagless\n+ * @run junit\/othervm -XX:+CompactStrings -Xmx8g MaxSizeUTF16String\n+ * @run junit\/othervm -XX:-CompactStrings -Xmx8g MaxSizeUTF16String\n+ * @run junit\/othervm -Xcomp -Xmx8g MaxSizeUTF16String\n+ *\/\n+\n+public class MaxSizeUTF16String {\n+\n+    private final static int MAX_UTF16_STRING_LENGTH = Integer.MAX_VALUE \/ 2;\n+\n+    private final static String EXPECTED_OOME_MESSAGE = \"UTF16 String size is\";\n+    private final static String EXPECTED_VM_LIMIT_MESSAGE = \"Requested array size exceeds VM limit\";\n+    private final static String UNEXPECTED_JAVA_HEAP_SPACE = \"Java heap space\";\n+\n+    \/\/ Create a large UTF-8 byte array with a single non-latin1 character\n+    private static byte[] generateUTF8Data(int byteSize) {\n+        byte[] nonAscii = \"\\u0100\".getBytes(StandardCharsets.UTF_8);\n+        byte[] arr = new byte[byteSize];\n+        System.arraycopy(nonAscii, 0, arr, 0, nonAscii.length); \/\/ non-latin1 at start\n+        return arr;\n+    }\n+\n+    \/\/ Create a large char array with a single non-latin1 character\n+    private static char[] generateCharData(int size) {\n+        char[] nonAscii = \"\\u0100\".toCharArray();\n+        char[] arr = new char[size];\n+        System.arraycopy(nonAscii, 0, arr, 0, nonAscii.length); \/\/ non-latin1 at start\n+        return arr;\n+    }\n+\n+    @Test\n+    public void testMaxUTF8() {\n+        \/\/ Overly large UTF-8 data with 1 non-latin1 char\n+        final byte[] large_utf8_bytes = generateUTF8Data(MAX_UTF16_STRING_LENGTH + 1);\n+        int[] sizes = new int[] {\n+                MAX_UTF16_STRING_LENGTH + 1,\n+                MAX_UTF16_STRING_LENGTH,\n+                MAX_UTF16_STRING_LENGTH - 1};\n+        for (int size : sizes) {\n+            System.err.println(\"Checking max UTF16 string len: \" + size);\n+            try {\n+                \/\/ Use only part of the UTF-8 byte array\n+                new String(large_utf8_bytes, 0, size, StandardCharsets.UTF_8);\n+                if (size >= MAX_UTF16_STRING_LENGTH) {\n+                    fail(\"Expected OutOfMemoryError with message prefix: \" + EXPECTED_OOME_MESSAGE);\n+                }\n+            } catch (OutOfMemoryError ex) {\n+                if (ex.getMessage().equals(UNEXPECTED_JAVA_HEAP_SPACE)) {\n+                    \/\/ Insufficient heap size\n+                    throw ex;\n+                }\n+                if (!ex.getMessage().startsWith(EXPECTED_OOME_MESSAGE) &&\n+                        !ex.getMessage().startsWith(EXPECTED_VM_LIMIT_MESSAGE)) {\n+                    fail(\"Failed: Not the OutOfMemoryError expected\", ex);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testMaxCharArray() {\n+        \/\/ Overly large UTF-8 data with 1 non-latin1 char\n+        final char[] large_char_array = generateCharData(MAX_UTF16_STRING_LENGTH + 1);\n+        int[] sizes = new int[]{\n+                MAX_UTF16_STRING_LENGTH + 1,\n+                MAX_UTF16_STRING_LENGTH,\n+                MAX_UTF16_STRING_LENGTH - 1};\n+        for (int size : sizes) {\n+            System.err.println(\"Checking max UTF16 string len: \" + size);\n+            try {\n+                \/\/ Large char array with 1 non-latin1 char\n+                new String(large_char_array, 0, size);\n+                if (size >= MAX_UTF16_STRING_LENGTH) {\n+                    fail(\"Expected OutOfMemoryError with message prefix: \" + EXPECTED_OOME_MESSAGE);\n+                }\n+            } catch (OutOfMemoryError ex) {\n+                if (ex.getMessage().equals(UNEXPECTED_JAVA_HEAP_SPACE)) {\n+                    \/\/ Insufficient heap size\n+                    throw ex;\n+                }\n+                if (!ex.getMessage().startsWith(EXPECTED_OOME_MESSAGE) &&\n+                        !ex.getMessage().startsWith(EXPECTED_VM_LIMIT_MESSAGE)) {\n+                    throw new RuntimeException(\"Wrong exception message: \" + ex.getMessage(), ex);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/CompactString\/MaxSizeUTF16String.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,437 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package test.java.lang.String;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.ConcurrentModificationException;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.EnabledIf;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/*\n+ * @test\n+ * @bug 8311906\n+ * @modules java.base\/java.lang:open\n+ * @summary check String's racy constructors\n+ * @run junit\/othervm -XX:+CompactStrings test.java.lang.String.StringRacyConstructor\n+ * @run junit\/othervm -XX:-CompactStrings test.java.lang.String.StringRacyConstructor\n+ *\/\n+\n+public class StringRacyConstructor {\n+    private static final byte LATIN1 = 0;\n+    private static final byte UTF16  = 1;\n+\n+    private static final Field STRING_CODER_FIELD;\n+    private static final Field SB_CODER_FIELD;\n+    private static final boolean COMPACT_STRINGS;\n+\n+    static {\n+        try {\n+            STRING_CODER_FIELD = String.class.getDeclaredField(\"coder\");\n+            STRING_CODER_FIELD.setAccessible(true);\n+            SB_CODER_FIELD = Class.forName(\"java.lang.AbstractStringBuilder\").getDeclaredField(\"coder\");\n+            SB_CODER_FIELD.setAccessible(true);\n+            COMPACT_STRINGS = isCompactStrings();\n+        } catch (NoSuchFieldException ex ) {\n+            throw new ExceptionInInitializerError(ex);\n+        } catch (ClassNotFoundException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/* {@return true iff CompactStrings are enabled}\n+     *\/\n+    public static boolean isCompactStrings() {\n+        try {\n+            Field compactStringField = String.class.getDeclaredField(\"COMPACT_STRINGS\");\n+            compactStringField.setAccessible(true);\n+            return compactStringField.getBoolean(null);\n+        } catch (NoSuchFieldException ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        } catch (IllegalAccessException iae) {\n+            throw new AssertionError(iae);\n+        }\n+    }\n+\n+    \/\/ Return the coder for the String\n+    private static int coder(String s) {\n+        try {\n+            return STRING_CODER_FIELD.getByte(s);\n+        } catch (IllegalAccessException iae) {\n+            throw new AssertionError(iae);\n+        }\n+    }\n+\n+    \/\/ Return the coder for the StringBuilder\n+    private static int sbCoder(StringBuilder sb) {\n+        try {\n+            return SB_CODER_FIELD.getByte(sb);\n+        } catch (IllegalAccessException iae) {\n+            throw new AssertionError(iae);\n+        }\n+    }\n+\n+    \/\/ Return a summary of the internals of the String\n+    \/\/ The coder and indicate if the coder matches the string contents\n+    private static String inspectString(String s) {\n+        try {\n+            char[] chars = s.toCharArray();\n+            String r = new String(chars);\n+\n+            boolean invalidCoder = coder(s) != coder(r);\n+            String coder = STRING_CODER_FIELD.getByte(s) == 0 ? \"isLatin1\" : \"utf16\";\n+            return (invalidCoder ? \"INVALID CODER\" : \"\" ) + \" \\\"\" + s + \"\\\", coder: \" + coder;\n+        } catch (IllegalAccessException ex ) {\n+            return \"EXCEPTION: \" + ex.getMessage();\n+        }\n+    }\n+\n+    \/**\n+     * {@return true if the coder matches the presence\/lack of UTF16 characters}\n+     * If it returns false, the coder and the contents have failed the precondition for string.\n+     * @param orig a string\n+     *\/\n+    private static boolean validCoder(String orig) {\n+        if (!COMPACT_STRINGS) {\n+            assertEquals(UTF16, coder(orig), \"Non-COMPACT STRINGS coder must be UTF16\");\n+        }\n+        int accum = 0;\n+        for (int i = 0; i < orig.length(); i++)\n+            accum |= orig.charAt(i);\n+        byte expectedCoder = (accum < 256) ? LATIN1 : UTF16;\n+        return expectedCoder == coder(orig);\n+    }\n+\n+    \/\/ Check a StringBuilder for consistency of coder and latin1 vs UTF16\n+    private static boolean validCoder(StringBuilder orig) {\n+        int accum = 0;\n+        for (int i = 0; i < orig.length(); i++)\n+            accum |= orig.charAt(i);\n+        byte expectedCoder = (accum < 256) ? LATIN1 : UTF16;\n+        return expectedCoder == sbCoder(orig);\n+    }\n+\n+    @Test\n+    @EnabledIf(\"test.java.lang.String.StringRacyConstructor#isCompactStrings\")\n+    public void checkStringRange() {\n+        char[] chars = {'a', 'b', 'c', 0xff21, 0xff22, 0xff23};\n+        String orig = new String(chars);\n+        char[] xx = orig.toCharArray();\n+        String stringFromChars = new String(xx);\n+        assertEquals(orig, stringFromChars, \"mixed chars\");\n+        assertTrue(validCoder(stringFromChars), \"invalid coder\"\n+                + \", invalid coder: \" + inspectString(stringFromChars));\n+    }\n+\n+    private static List<String> strings() {\n+        return List.of(\"01234\", \" \");\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"strings\")\n+    @EnabledIf(\"test.java.lang.String.StringRacyConstructor#isCompactStrings\")\n+    public void racyString(String orig) {\n+        String racyString = racyStringConstruction(orig);\n+        \/\/ The contents are indeterminate due to the race\n+        assertTrue(validCoder(racyString), orig + \" string invalid\"\n+                + \", racyString: \" + inspectString(racyString));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"strings\")\n+    @EnabledIf(\"test.java.lang.String.StringRacyConstructor#isCompactStrings\")\n+    public void racyCodePoint(String orig) {\n+        String iffyString = racyStringConstructionCodepoints(orig);\n+        \/\/ The contents are indeterminate due to the race\n+        assertTrue(validCoder(iffyString), \"invalid coder in non-deterministic string\"\n+                + \", orig:\" + inspectString(orig)\n+                + \", iffyString: \" + inspectString(iffyString));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"strings\")\n+    @EnabledIf(\"test.java.lang.String.StringRacyConstructor#isCompactStrings\")\n+    public void racyCodePointSurrogates(String orig) {\n+        String iffyString = racyStringConstructionCodepointsSurrogates(orig);\n+        \/\/ The contents are indeterminate due to the race\n+        if (!orig.equals(iffyString))\n+            System.err.println(\"orig: \" + orig + \", iffy: \" + iffyString + Arrays.toString(iffyString.codePoints().toArray()));\n+        assertTrue(validCoder(iffyString), \"invalid coder in non-deterministic string\"\n+                + \", orig:\" + inspectString(orig)\n+                + \", iffyString: \" + inspectString(iffyString));\n+    }\n+\n+    \/\/ Test the private methods of StringUTF16 that compress and copy COMPRESSED_STRING\n+    \/\/ encoded byte arrays.\n+    @Test\n+    public void verifyUTF16CopyBytes()\n+            throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n+        Class<?> stringUTF16 = Class.forName(\"java.lang.StringUTF16\");\n+        Method mCompressChars = stringUTF16.getDeclaredMethod(\"compress\",\n+                char[].class, int.class, byte[].class, int.class, int.class);\n+        mCompressChars.setAccessible(true);\n+\n+        \/\/ First warmup the intrinsic and check 1 case\n+        char[] chars = {'a', 'b', 'c', 0xff21, 0xff22, 0xff23};\n+        byte[] bytes = new byte[chars.length];\n+        int printWarningCount = 0;\n+\n+        for (int i = 0; i < 1_000_000; i++) {   \/\/ repeat to get C2 to kick in\n+            \/\/ Copy only latin1 chars from UTF-16 converted prefix (3 chars -> 3 bytes)\n+            int intResult = (int) mCompressChars.invoke(null, chars, 0, bytes, 0, chars.length);\n+            if (intResult == 0) {\n+                if (printWarningCount == 0) {\n+                    printWarningCount = 1;\n+                    System.err.println(\"Intrinsic for StringUTF16.compress returned 0, may not have been updated.\");\n+                }\n+            } else {\n+                assertEquals(3, intResult, \"return length not-equal, iteration: \" + i);\n+            }\n+        }\n+\n+        \/\/ Exhaustively check compress returning the correct index of the non-latin1 char.\n+        final int SIZE = 48;\n+        final byte FILL_BYTE = 'R';\n+        chars = new char[SIZE];\n+        bytes = new byte[chars.length];\n+        for (int i = 0; i < SIZE; i++) { \/\/ Every starting index\n+            for (int j = i; j < SIZE; j++) {  \/\/ Every location of non-latin1\n+                Arrays.fill(chars, 'A');\n+                Arrays.fill(bytes, FILL_BYTE);\n+                chars[j] = 0xFF21;\n+                int intResult = (int) mCompressChars.invoke(null, chars, i, bytes, 0, chars.length - i);\n+                assertEquals(j - i, intResult, \"compress found wrong index\");\n+                assertEquals(FILL_BYTE, bytes[j], \"extra character stored\");\n+            }\n+        }\n+\n+    }\n+\n+    \/\/ Check that a concatenated \"hello\" has a valid coder\n+    @Test\n+    @EnabledIf(\"test.java.lang.String.StringRacyConstructor#isCompactStrings\")\n+    public void checkConcatAndIntern() {\n+        var helloWorld = \"hello world\";\n+        String helloToo = racyStringConstruction(\"hell\".concat(\"o\"));\n+        String o = helloToo.intern();\n+        var hello = \"hello\";\n+        assertTrue(validCoder(helloToo), \"startsWith: \"\n+                + \", hell: \" + inspectString(helloToo)\n+                + \", o: \" + inspectString(o)\n+                + \", hello: \" + inspectString(hello)\n+                + \", hello world: \" + inspectString(helloWorld));\n+    }\n+\n+    \/\/ Check that an empty string with racy construction has a valid coder\n+    @Test\n+    @EnabledIf(\"test.java.lang.String.StringRacyConstructor#isCompactStrings\")\n+    public void racyEmptyString() {\n+        var space = racyStringConstruction(\" \");\n+        var trimmed = space.trim();\n+        assertTrue(validCoder(trimmed), \"empty string invalid coder\"\n+                + \", trimmed: \" + inspectString(trimmed));\n+    }\n+\n+    \/\/ Check that an exception in a user implemented CharSequence doesn't result in\n+    \/\/ an invalid coder when appended to a StringBuilder\n+    @Test\n+    @EnabledIf(\"test.java.lang.String.StringRacyConstructor#isCompactStrings\")\n+    void charSequenceException() {\n+        ThrowingCharSequence bs = new ThrowingCharSequence(\"A\\u2030\\uFFFD\");\n+        var sb = new StringBuilder();\n+        try {\n+            sb.append(bs);\n+            fail(\"An IllegalArgumentException should have been thrown\");\n+        } catch (IllegalArgumentException ex) {\n+            \/\/ ignore expected\n+        }\n+        assertTrue(validCoder(sb), \"invalid coder in StringBuilder\");\n+    }\n+\n+    \/**\n+     * Given a latin-1 String, attempt to create a copy that is\n+     * incorrectly encoded as UTF-16.\n+     *\/\n+    public static String racyStringConstruction(String original) throws ConcurrentModificationException {\n+        if (original.chars().max().getAsInt() >= 256) {\n+            throw new IllegalArgumentException(\n+                    \"Only work with latin-1 Strings\");\n+        }\n+\n+        char[] chars = original.toCharArray();\n+\n+        \/\/ In another thread, flip the first character back\n+        \/\/ and forth between being latin-1 or not\n+        Thread thread = new Thread(() -> {\n+            while (!Thread.interrupted()) {\n+                chars[0] ^= 256;\n+            }\n+        });\n+        thread.start();\n+\n+        \/\/ at the same time call the String constructor,\n+        \/\/ until we hit the race condition\n+        int i = 0;\n+        while (true) {\n+            i++;\n+            String s = new String(chars);\n+            if ((s.charAt(0) < 256 && !original.equals(s)) || i > 1_000_000) {\n+                thread.interrupt();\n+                try {\n+                    thread.join();\n+                } catch (InterruptedException ie) {\n+                    \/\/ ignore interrupt\n+                }\n+                return s;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Given a latin-1 String, creates a copy that is\n+     * incorrectly encoded as UTF-16 using the APIs for Codepoints.\n+     *\/\n+    public static String racyStringConstructionCodepoints(String original) throws ConcurrentModificationException {\n+        if (original.chars().max().getAsInt() >= 256) {\n+            throw new IllegalArgumentException(\n+                    \"Can only work with latin-1 Strings\");\n+        }\n+\n+        int len = original.length();\n+        int[] codePoints = new int[len];\n+        for (int i = 0; i < len; i++) {\n+            codePoints[i] = original.charAt(i);\n+        }\n+\n+        \/\/ In another thread, flip the first character back\n+        \/\/ and forth between being latin-1 or not\n+        Thread thread = new Thread(() -> {\n+            while (!Thread.interrupted()) {\n+                codePoints[0] ^= 256;\n+            }\n+        });\n+        thread.start();\n+\n+        \/\/ at the same time call the String constructor,\n+        \/\/ until we hit the race condition\n+        int i = 0;\n+        while (true) {\n+            i++;\n+            String s = new String(codePoints, 0, len);\n+            if ((s.charAt(0) < 256 && !original.equals(s)) || i > 1_000_000) {\n+                thread.interrupt();\n+                try {\n+                    thread.join();\n+                } catch (InterruptedException ie) {\n+                    \/\/ ignore interrupt\n+                }\n+                return s;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns a string created from a codepoint array that has been racily\n+     * modified to contain high and low surrogates. The string is a different length\n+     * than the original due to the surrogate encoding.\n+     *\/\n+    public static String racyStringConstructionCodepointsSurrogates(String original) throws ConcurrentModificationException {\n+        if (original.chars().max().getAsInt() >= 256) {\n+            throw new IllegalArgumentException(\n+                    \"Can only work with latin-1 Strings\");\n+        }\n+\n+        int len = original.length();\n+        int[] codePoints = new int[len];\n+        for (int i = 0; i < len; i++) {\n+            codePoints[i] = original.charAt(i);\n+        }\n+\n+        \/\/ In another thread, flip the first character back\n+        \/\/ and forth between being latin-1 or as a surrogate pair.\n+        Thread thread = new Thread(() -> {\n+            while (!Thread.interrupted()) {\n+                codePoints[0] ^= 0x10000;\n+            }\n+        });\n+        thread.start();\n+\n+        \/\/ at the same time call the String constructor,\n+        \/\/ until we hit the race condition\n+        int i = 0;\n+        while (true) {\n+            i++;\n+            String s = new String(codePoints, 0, len);\n+            if ((s.length() != original.length()) || i > 1_000_000) {\n+                thread.interrupt();\n+                try {\n+                    thread.join();\n+                } catch (InterruptedException ie) {\n+                    \/\/ ignore interrupt\n+                }\n+                return s;\n+            }\n+        }\n+    }\n+\n+    \/\/ A CharSequence that returns characters from a string and throws IllegalArgumentException\n+    \/\/ when the character requested is 0xFFFD (the replacement character)\n+    \/\/ The string contents determine when the exception is thrown.\n+    static class ThrowingCharSequence implements CharSequence {\n+        private final String aString;\n+\n+        ThrowingCharSequence(String aString) {\n+            this.aString = aString;\n+        }\n+\n+        @Override\n+        public int length() {\n+            return aString.length();\n+        }\n+\n+        @Override\n+        public char charAt(int index) {\n+            char ch = aString.charAt(index);\n+            if (ch == 0xFFFD) {\n+                throw new IllegalArgumentException(\"Replacement character at index \" + index);\n+            }\n+            return ch;\n+        }\n+\n+        @Override\n+        \/\/ Not used; returns the entire string\n+        public CharSequence subSequence(int start, int end) {\n+            return this;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/StringRacyConstructor.java","additions":437,"deletions":0,"binary":false,"changes":437,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import static java.nio.charset.StandardCharsets.UTF_16;\n@@ -34,0 +33,3 @@\n+import static java.nio.charset.StandardCharsets.UTF_16;\n+import static java.nio.charset.StandardCharsets.UTF_16BE;\n+import static java.nio.charset.StandardCharsets.UTF_16LE;\n@@ -43,0 +45,1 @@\n+import static org.testng.Assert.assertEquals;\n@@ -45,1 +48,0 @@\n-import org.testng.annotations.AfterClass;\n@@ -51,1 +53,1 @@\n- * @bug 8201276 8205058 8209576 8287541 8288589\n+ * @bug 8201276 8205058 8209576 8287541 8288589 8325590\n@@ -64,0 +66,1 @@\n+    final static String TEXT_PERSON_CART_WHEELING = \"\\ud83e\\udd38\";\n@@ -68,0 +71,4 @@\n+    private static final Charset UTF_32   = Charset.forName(\"utf-32\");\n+    private static final Charset UTF_32BE = Charset.forName(\"utf-32be\");\n+    private static final Charset UTF_32LE = Charset.forName(\"utf-32le\");\n+\n@@ -157,1 +164,10 @@\n-            {testFiles[1], TEXT_UNICODE, UTF_8, UTF_8}\n+            {testFiles[1], TEXT_UNICODE, UTF_8, UTF_8},\n+            {testFiles[1], TEXT_ASCII, US_ASCII, ISO_8859_1},\n+            {testFiles[1], TEXT_PERSON_CART_WHEELING, UTF_16, UTF_16},\n+            {testFiles[1], TEXT_PERSON_CART_WHEELING, UTF_16BE, UTF_16BE},\n+            {testFiles[1], TEXT_PERSON_CART_WHEELING, UTF_16LE, UTF_16LE},\n+            {testFiles[1], TEXT_PERSON_CART_WHEELING, UTF_32, UTF_32},\n+            {testFiles[1], TEXT_PERSON_CART_WHEELING, UTF_32BE, UTF_32BE},\n+            {testFiles[1], TEXT_PERSON_CART_WHEELING, UTF_32LE, UTF_32LE},\n+            {testFiles[1], TEXT_PERSON_CART_WHEELING, WINDOWS_1252, WINDOWS_1252},\n+            {testFiles[1], TEXT_PERSON_CART_WHEELING, WINDOWS_31J, WINDOWS_31J}\n@@ -307,0 +323,15 @@\n+    \/\/ Verify File.readString with UTF16 to confirm proper string length and contents.\n+    \/\/ A regression test for 8325590\n+    @Test\n+    public void testSingleUTF16() throws IOException {\n+        String original = \"\";    \/\/ \"\\ud83e\\udd38\";\n+        Files.writeString(testFiles[0], original, UTF_16);\n+        String actual = Files.readString(testFiles[0], UTF_16);\n+        if (!actual.equals(original)) {\n+            System.out.printf(\"expected (%s), was (%s)\\n\", original, actual);\n+            System.out.printf(\"expected UTF_16 bytes: %s\\n\", Arrays.toString(original.getBytes(UTF_16)));\n+            System.out.printf(\"actual UTF_16 bytes: %s\\n\", Arrays.toString(actual.getBytes(UTF_16)));\n+        }\n+        assertEquals(actual, original, \"Round trip string mismatch with multi-byte encoding\");\n+    }\n+\n","filename":"test\/jdk\/java\/nio\/file\/Files\/ReadWriteString.java","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-package micro.org.openjdk.bench.java.lang;\n+package org.openjdk.bench.java.lang;\n@@ -27,0 +27,1 @@\n+import org.openjdk.jmh.infra.Blackhole;\n@@ -29,0 +30,1 @@\n+import java.util.Arrays;\n@@ -39,40 +41,1 @@\n-  @Param({\"7\", \"64\"})\n-  public int size;\n-\n-  \/\/ Offset to use for ranged newStrings\n-  @Param(\"1\")\n-  public int offset;\n-  private byte[] array;\n-\n-  @Setup\n-  public void setup() {\n-      if (offset > size) {\n-        offset = size;\n-      }\n-      array = \"a\".repeat(size).getBytes(StandardCharsets.UTF_8);\n-  }\n-\n-  @Benchmark\n-  public String newStringFromArray() {\n-      return new String(array);\n-  }\n-\n-  @Benchmark\n-  public String newStringFromArrayWithCharset() {\n-      return new String(array, StandardCharsets.UTF_8);\n-  }\n-\n-  @Benchmark\n-  public String newStringFromArrayWithCharsetName() throws Exception {\n-      return new String(array, StandardCharsets.UTF_8.name());\n-  }\n-\n-  @Benchmark\n-  public String newStringFromRangedArray() {\n-    return new String(array, offset, array.length - offset);\n-  }\n-\n-  @Benchmark\n-  public String newStringFromRangedArrayWithCharset() {\n-      return new String(array, offset, array.length - offset, StandardCharsets.UTF_8);\n-  }\n+    private static final char INTEROBANG = 0x2030;\n@@ -80,0 +43,109 @@\n+    \/\/ Fixed offset to use for ranged newStrings\n+    public final int offset = 1;\n+\n+    @Param({\"7\", \"64\"})\n+    public int size;\n+\n+    private byte[] array;\n+    private char[] chars;\n+    private char[] charsMixedBegin;\n+    private char[] charsMixedSmall;\n+    private char[] charsMixedEnd;\n+    private int[] codePointsLatin1;\n+    private int[] codePointsMixedBegin;\n+    private int[] codePointsMixedSmall;\n+\n+    private static int[] intCopyOfChars(char[] chars, int newLength) {\n+        int[] res = new int[newLength];\n+        for (int i = 0; i < Math.min(chars.length, newLength); i++)\n+            res[i] = chars[i];\n+        return res;\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        String s = \"a\".repeat(size);\n+        array = s.getBytes(StandardCharsets.UTF_8);\n+        chars = s.toCharArray();\n+        charsMixedBegin = Arrays.copyOf(chars, array.length);\n+        charsMixedBegin[0] = INTEROBANG;\n+        charsMixedSmall = Arrays.copyOf(chars, array.length);\n+        charsMixedSmall[Math.min(charsMixedSmall.length - 1, 7)] = INTEROBANG;\n+        charsMixedEnd = new char[size + 7];\n+        Arrays.fill(charsMixedEnd, 'a');\n+        charsMixedEnd[charsMixedEnd.length - 1] = INTEROBANG;\n+\n+        codePointsLatin1 = intCopyOfChars(chars, array.length);\n+        codePointsMixedBegin = intCopyOfChars(chars, array.length);\n+        codePointsMixedBegin[0] = INTEROBANG;\n+        codePointsMixedSmall = intCopyOfChars(chars, array.length);\n+        codePointsMixedSmall[Math.min(codePointsMixedSmall.length - 1, 7)] = INTEROBANG;\n+    }\n+\n+    @Benchmark\n+    public String newStringFromBytes() {\n+        return new String(array);\n+    }\n+\n+    @Benchmark\n+    public String newStringFromBytesRanged() {\n+        return new String(array, offset, array.length - offset);\n+    }\n+\n+    @Benchmark\n+    public String newStringFromBytesRangedWithCharsetUTF8() {\n+        return new String(array, offset, array.length - offset, StandardCharsets.UTF_8);\n+    }\n+\n+    @Benchmark\n+    public String newStringFromBytesWithCharsetUTF8() {\n+        return new String(array, StandardCharsets.UTF_8);\n+    }\n+\n+    @Benchmark\n+    public String newStringFromBytesWithCharsetNameUTF8() throws Exception {\n+        return new String(array, StandardCharsets.UTF_8.name());\n+    }\n+\n+    @Benchmark\n+    public String newStringFromCharsLatin1() {\n+        return new String(chars);\n+    }\n+\n+    @Benchmark\n+    public String newStringFromCharsMixedBegin() {\n+        return new String(charsMixedBegin);\n+    }\n+\n+    @Benchmark\n+    public String newStringFromCharsMixedSmall() {\n+        return new String(charsMixedSmall);\n+    }\n+\n+    @Benchmark\n+    public String newStringFromCharsMixedEnd() {\n+        return new String(charsMixedEnd);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void newStringFromCharsMixedAll(Blackhole bh) {\n+        bh.consume(new String(charsMixedBegin));\n+        bh.consume(new String(charsMixedSmall));\n+        bh.consume(new String(chars));\n+    }\n+\n+    @Benchmark\n+    public String newStringFromCodePointRangedLatin1() {\n+        return new String(codePointsLatin1, 0, codePointsLatin1.length);\n+    }\n+\n+    @Benchmark\n+    public String newStringFromCodePointRangedMixedBegin() {\n+        return new String(codePointsMixedBegin, 0, codePointsMixedBegin.length);\n+    }\n+\n+    @Benchmark\n+    public String newStringFromCodePointRangedMixedSmall() {\n+        return new String(codePointsMixedSmall, 0, codePointsMixedSmall.length);\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringConstructor.java","additions":113,"deletions":41,"binary":false,"changes":154,"status":"modified"}]}