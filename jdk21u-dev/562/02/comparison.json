{"files":[{"patch":"@@ -428,4 +428,2 @@\n-  \/\/ in the shared heap. This also has the side effect of pre-initializing the\n-  \/\/ identity_hash for all shared objects, so they are less likely to be written\n-  \/\/ into during run time, increasing the potential of memory sharing.\n-  if (src_obj != nullptr) {\n+  \/\/ in the shared heap.\n+  if (src_obj != nullptr && !src_obj->fast_no_hash_check()) {\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -279,6 +279,0 @@\n-\n-    \/\/ The archived objects are discovered in a predictable order. Compute\n-    \/\/ their identity_hash() as soon as we see them. This ensures that the\n-    \/\/ the identity_hash in the object header will have a predictable value,\n-    \/\/ making the archive reproducible.\n-    obj->identity_hash();\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -106,1 +106,4 @@\n-  _hashStateX = os::random();\n+  \/\/ If we are dumping, keep ihashes constant. Note that during dumping we only\n+  \/\/ ever run one java thread, and no other thread should generate ihashes either,\n+  \/\/ so using a constant seed should work fine.\n+  _hashStateX = DumpSharedSpaces ? 0x12345678 : os::random();\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}