{"files":[{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.cr7200264;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestDriver {\n+    private final Map<String, Long> expectedVectorizationNumbers\n+            = new HashMap<>();\n+\n+    public void addExpectedVectorization(String v, long num) {\n+        expectedVectorizationNumbers.put(v, num);\n+    }\n+\n+    public void run() throws Throwable {\n+        verifyVectorizationNumber(executeApplication());\n+    }\n+\n+    private List<String> executeApplication() throws Throwable {\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeTestJava(\n+            \"-Xbatch\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+PrintCompilation\",\n+            \"-XX:+TraceNewVectors\",\n+            \"-XX:+IgnoreUnrecognizedVMOptions\",\n+            \"-XX:StressLongCountedLoop=0\", \/\/ make sure int loops do not get converted to long\n+            TestIntVect.class.getName());\n+        outputAnalyzer.shouldHaveExitValue(0);\n+        return outputAnalyzer.asLines();\n+    }\n+\n+    private void verifyVectorizationNumber(List<String> vectorizationLog) {\n+        for (Map.Entry<String, Long> entry : expectedVectorizationNumbers.entrySet()) {\n+            String v = entry.getKey();\n+            long actualNum = vectorizationLog.stream()\n+                    .filter(s -> s.contains(v)).count();\n+            long expectedNum = entry.getValue();\n+            Asserts.assertGTE(actualNum, expectedNum,\n+                              \"Unexpected \" + entry.getKey() + \" number\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr7200264\/TestDriver.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,8 +24,0 @@\n-\/**\n- * @test\n- * @bug 7200264\n- * @summary 7192963 changes disabled shift vectors\n- * @library \/test\/lib \/\n- * @run driver compiler.c2.cr7200264.TestIntVect\n- *\/\n-\n@@ -33,3 +25,0 @@\n-\n-import compiler.lib.ir_framework.*;\n-\n@@ -37,1 +26,1 @@\n- * Based on test\/hotspot\/jtreg\/compiler\/c2\/cr6340864\/TestIntVect.java without performance tests.\n+ * Copy of test\/compiler\/6340864\/TestIntVect.java without performance tests.\n@@ -40,849 +29,452 @@\n-\n-    private static final int ARRLEN = 997;\n-    private static final int ITERS  = 11000;\n-    private static final int ADD_INIT = Integer.MAX_VALUE-500;\n-    private static final int BIT_MASK = 0xEC80F731;\n-    private static final int VALUE = 15;\n-    private static final int SHIFT = 32;\n-\n-    public static void main(String[] args) {\n-        TestFramework.run();\n-    }\n-\n-    @Run(test = {\n-           \"test_sum\", \"test_addc\", \"test_addv\", \"test_adda\", \"test_subc\",\n-           \"test_subv\", \"test_suba\", \"test_mulc\", \"test_mulc_n\", \"test_mulv\",\n-           \"test_mula\", \"test_divc\", \"test_divc_n\", \"test_divv\", \"test_diva\",\n-           \"test_andc\", \"test_andv\", \"test_anda\", \"test_orc\", \"test_orv\",\n-           \"test_ora\", \"test_xorc\", \"test_xorv\", \"test_xora\", \"test_sllc\",\n-           \"test_sllc_n\", \"test_sllc_o\", \"test_sllc_on\", \"test_sllv\",\n-           \"test_srlc\", \"test_srlc_n\", \"test_srlc_o\", \"test_srlc_on\",\n-           \"test_srlv\", \"test_srac\", \"test_srac_n\", \"test_srac_o\",\n-           \"test_srac_on\", \"test_srav\", \"test_pack2\", \"test_unpack2\",\n-           \"test_pack2_swap\", \"test_unpack2_swap\"\n-         },\n-         mode = RunMode.STANDALONE)\n-    public void run() {\n-        System.out.println(\"Testing Integer vectors\");\n-\n-        \/\/ Initialize\n-        int[] a0 = new int[ARRLEN];\n-        int[] a1 = new int[ARRLEN];\n-        int[] a2 = new int[ARRLEN];\n-        int[] a3 = new int[ARRLEN];\n-        int[] a4 = new int[ARRLEN];\n-        long[] p2 = new long[ARRLEN\/2];\n-        int gold_sum = 0;\n-        for (int i=0; i<ARRLEN; i++) {\n-            int val = (int)(ADD_INIT+i);\n-            gold_sum += val;\n-            a1[i] = val;\n-            a2[i] = (int)VALUE;\n-            a3[i] = (int)-VALUE;\n-            a4[i] = (int)BIT_MASK;\n-        }\n-\n-        System.out.println(\"Warmup\");\n-        for (int i=0; i<ITERS; i++) {\n-            test_sum(a1);\n-            test_addc(a0, a1);\n-            test_addv(a0, a1, (int)VALUE);\n-            test_adda(a0, a1, a2);\n-            test_subc(a0, a1);\n-            test_subv(a0, a1, (int)VALUE);\n-            test_suba(a0, a1, a2);\n-            test_mulc(a0, a1);\n-            test_mulv(a0, a1, (int)VALUE);\n-            test_mula(a0, a1, a2);\n-            test_divc(a0, a1);\n-            test_divv(a0, a1, (int)VALUE);\n-            test_diva(a0, a1, a2);\n-            test_mulc_n(a0, a1);\n-            test_mulv(a0, a1, (int)-VALUE);\n-            test_mula(a0, a1, a3);\n-            test_divc_n(a0, a1);\n-            test_divv(a0, a1, (int)-VALUE);\n-            test_diva(a0, a1, a3);\n-            test_andc(a0, a1);\n-            test_andv(a0, a1, (int)BIT_MASK);\n-            test_anda(a0, a1, a4);\n-            test_orc(a0, a1);\n-            test_orv(a0, a1, (int)BIT_MASK);\n-            test_ora(a0, a1, a4);\n-            test_xorc(a0, a1);\n-            test_xorv(a0, a1, (int)BIT_MASK);\n-            test_xora(a0, a1, a4);\n-            test_sllc(a0, a1);\n-            test_sllv(a0, a1, VALUE);\n-            test_srlc(a0, a1);\n-            test_srlv(a0, a1, VALUE);\n-            test_srac(a0, a1);\n-            test_srav(a0, a1, VALUE);\n-            test_sllc_n(a0, a1);\n-            test_sllv(a0, a1, -VALUE);\n-            test_srlc_n(a0, a1);\n-            test_srlv(a0, a1, -VALUE);\n-            test_srac_n(a0, a1);\n-            test_srav(a0, a1, -VALUE);\n-            test_sllc_o(a0, a1);\n-            test_sllv(a0, a1, SHIFT);\n-            test_srlc_o(a0, a1);\n-            test_srlv(a0, a1, SHIFT);\n-            test_srac_o(a0, a1);\n-            test_srav(a0, a1, SHIFT);\n-            test_sllc_on(a0, a1);\n-            test_sllv(a0, a1, -SHIFT);\n-            test_srlc_on(a0, a1);\n-            test_srlv(a0, a1, -SHIFT);\n-            test_srac_on(a0, a1);\n-            test_srav(a0, a1, -SHIFT);\n-            test_pack2(p2, a1);\n-            test_unpack2(a0, p2);\n-            test_pack2_swap(p2, a1);\n-            test_unpack2_swap(a0, p2);\n-        }\n-\n-        \/\/ Test and verify results\n-        System.out.println(\"Verification\");\n-        int errn = 0;\n-        {\n-            int sum = test_sum(a1);\n-            if (sum != gold_sum) {\n-                System.err.println(\"test_sum:  \" + sum + \" != \" + gold_sum);\n-                errn++;\n-            }\n-\n-            test_addc(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_addc: \", i, a0[i], (int)((int)(ADD_INIT+i)+VALUE));\n-            }\n-            test_addv(a0, a1, (int)VALUE);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_addv: \", i, a0[i], (int)((int)(ADD_INIT+i)+VALUE));\n-            }\n-            test_adda(a0, a1, a2);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_adda: \", i, a0[i], (int)((int)(ADD_INIT+i)+VALUE));\n-            }\n-\n-            test_subc(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_subc: \", i, a0[i], (int)((int)(ADD_INIT+i)-VALUE));\n-            }\n-            test_subv(a0, a1, (int)VALUE);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_subv: \", i, a0[i], (int)((int)(ADD_INIT+i)-VALUE));\n-            }\n-            test_suba(a0, a1, a2);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_suba: \", i, a0[i], (int)((int)(ADD_INIT+i)-VALUE));\n-            }\n-\n-            test_mulc(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_mulc: \", i, a0[i], (int)((int)(ADD_INIT+i)*VALUE));\n-            }\n-            test_mulv(a0, a1, (int)VALUE);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_mulv: \", i, a0[i], (int)((int)(ADD_INIT+i)*VALUE));\n-            }\n-            test_mula(a0, a1, a2);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_mula: \", i, a0[i], (int)((int)(ADD_INIT+i)*VALUE));\n-            }\n-\n-            test_divc(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_divc: \", i, a0[i], (int)((int)(ADD_INIT+i)\/VALUE));\n-            }\n-            test_divv(a0, a1, (int)VALUE);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_divv: \", i, a0[i], (int)((int)(ADD_INIT+i)\/VALUE));\n-            }\n-            test_diva(a0, a1, a2);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_diva: \", i, a0[i], (int)((int)(ADD_INIT+i)\/VALUE));\n-            }\n-\n-            test_mulc_n(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_mulc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)*(-VALUE)));\n-            }\n-            test_mulv(a0, a1, (int)-VALUE);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_mulv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)*(-VALUE)));\n-            }\n-            test_mula(a0, a1, a3);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_mula_n: \", i, a0[i], (int)((int)(ADD_INIT+i)*(-VALUE)));\n-            }\n-\n-            test_divc_n(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_divc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)\/(-VALUE)));\n-            }\n-            test_divv(a0, a1, (int)-VALUE);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_divv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)\/(-VALUE)));\n-            }\n-            test_diva(a0, a1, a3);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_diva_n: \", i, a0[i], (int)((int)(ADD_INIT+i)\/(-VALUE)));\n-            }\n-\n-            test_andc(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_andc: \", i, a0[i], (int)((int)(ADD_INIT+i)&BIT_MASK));\n-            }\n-            test_andv(a0, a1, (int)BIT_MASK);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_andv: \", i, a0[i], (int)((int)(ADD_INIT+i)&BIT_MASK));\n-            }\n-            test_anda(a0, a1, a4);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_anda: \", i, a0[i], (int)((int)(ADD_INIT+i)&BIT_MASK));\n-            }\n-\n-            test_orc(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_orc: \", i, a0[i], (int)((int)(ADD_INIT+i)|BIT_MASK));\n-            }\n-            test_orv(a0, a1, (int)BIT_MASK);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_orv: \", i, a0[i], (int)((int)(ADD_INIT+i)|BIT_MASK));\n-            }\n-            test_ora(a0, a1, a4);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_ora: \", i, a0[i], (int)((int)(ADD_INIT+i)|BIT_MASK));\n-            }\n-\n-            test_xorc(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_xorc: \", i, a0[i], (int)((int)(ADD_INIT+i)^BIT_MASK));\n-            }\n-            test_xorv(a0, a1, (int)BIT_MASK);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_xorv: \", i, a0[i], (int)((int)(ADD_INIT+i)^BIT_MASK));\n-            }\n-            test_xora(a0, a1, a4);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_xora: \", i, a0[i], (int)((int)(ADD_INIT+i)^BIT_MASK));\n-            }\n-\n-            test_sllc(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_sllc: \", i, a0[i], (int)((int)(ADD_INIT+i)<<VALUE));\n-            }\n-            test_sllv(a0, a1, VALUE);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_sllv: \", i, a0[i], (int)((int)(ADD_INIT+i)<<VALUE));\n-            }\n-\n-            test_srlc(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_srlc: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>VALUE));\n-            }\n-            test_srlv(a0, a1, VALUE);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_srlv: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>VALUE));\n-            }\n-\n-            test_srac(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_srac: \", i, a0[i], (int)((int)(ADD_INIT+i)>>VALUE));\n-            }\n-            test_srav(a0, a1, VALUE);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_srav: \", i, a0[i], (int)((int)(ADD_INIT+i)>>VALUE));\n-            }\n-\n-            test_sllc_n(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_sllc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-VALUE)));\n-            }\n-            test_sllv(a0, a1, -VALUE);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_sllv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-VALUE)));\n-            }\n-\n-            test_srlc_n(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_srlc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-VALUE)));\n-            }\n-            test_srlv(a0, a1, -VALUE);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_srlv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-VALUE)));\n-            }\n-\n-            test_srac_n(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_srac_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-VALUE)));\n-            }\n-            test_srav(a0, a1, -VALUE);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_srav_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-VALUE)));\n-            }\n-\n-            test_sllc_o(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_sllc_o: \", i, a0[i], (int)((int)(ADD_INIT+i)<<SHIFT));\n-            }\n-            test_sllv(a0, a1, SHIFT);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_sllv_o: \", i, a0[i], (int)((int)(ADD_INIT+i)<<SHIFT));\n-            }\n-\n-            test_srlc_o(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_srlc_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>SHIFT));\n-            }\n-            test_srlv(a0, a1, SHIFT);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_srlv_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>SHIFT));\n-            }\n-\n-            test_srac_o(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_srac_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>SHIFT));\n-            }\n-            test_srav(a0, a1, SHIFT);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_srav_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>SHIFT));\n-            }\n-\n-            test_sllc_on(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_sllc_on: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-SHIFT)));\n-            }\n-            test_sllv(a0, a1, -SHIFT);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_sllv_on: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-SHIFT)));\n-            }\n-\n-            test_srlc_on(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_srlc_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-SHIFT)));\n-            }\n-            test_srlv(a0, a1, -SHIFT);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_srlv_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-SHIFT)));\n-            }\n-\n-            test_srac_on(a0, a1);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_srac_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-SHIFT)));\n-            }\n-            test_srav(a0, a1, -SHIFT);\n-            for (int i=0; i<ARRLEN; i++) {\n-                errn += verify(\"test_srav_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-SHIFT)));\n-            }\n-\n-            test_pack2(p2, a1);\n-            for (int i=0; i<ARRLEN\/2; i++) {\n-                errn += verify(\"test_pack2: \", i, p2[i], ((long)(ADD_INIT+2*i) & 0xFFFFFFFFl) | ((long)(ADD_INIT+2*i+1) << 32));\n-            }\n-            for (int i=0; i<ARRLEN; i++) {\n-                a0[i] = -1;\n-            }\n-            test_unpack2(a0, p2);\n-            for (int i=0; i<(ARRLEN&(-2)); i++) {\n-                errn += verify(\"test_unpack2: \", i, a0[i], (ADD_INIT+i));\n-            }\n-\n-            test_pack2_swap(p2, a1);\n-            for (int i=0; i<ARRLEN\/2; i++) {\n-                errn += verify(\"test_pack2_swap: \", i, p2[i], ((long)(ADD_INIT+2*i+1) & 0xFFFFFFFFl) | ((long)(ADD_INIT+2*i) << 32));\n-            }\n-            for (int i=0; i<ARRLEN; i++) {\n-                a0[i] = -1;\n-            }\n-            test_unpack2_swap(a0, p2);\n-            for (int i=0; i<(ARRLEN&(-2)); i++) {\n-                errn += verify(\"test_unpack2_swap: \", i, a0[i], (ADD_INIT+i));\n-            }\n-\n-        }\n-\n-        if (errn > 0) {\n-            throw new Error(\"FAILED: \" + errn + \" errors\");\n-        }\n-        System.out.println(\"PASSED\");\n-\n-    }\n-\n-    \/\/ Not vectorized: simple addition not profitable, see JDK-8307516. NOTE:\n-    \/\/ This check does not document the _desired_ behavior of the system but\n-    \/\/ the current behavior (no vectorization)\n-    @Test\n-    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n-                   IRNode.STORE_VECTOR,  \"= 0\" })\n-    int test_sum(int[] a1) {\n-        int sum = 0;\n-        for (int i = 0; i < a1.length; i+=1) {\n-            sum += a1[i];\n-        }\n-        return sum;\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.ADD_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_addc(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]+VALUE);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.ADD_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_addv(int[] a0, int[] a1, int b) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]+b);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.ADD_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_adda(int[] a0, int[] a1, int[] a2) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]+a2[i]);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.ADD_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_subc(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]-VALUE);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.SUB_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_subv(int[] a0, int[] a1, int b) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]-b);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.SUB_VI, \"> 0\", },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_suba(int[] a0, int[] a1, int[] a2) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]-a2[i]);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.SUB_VI, \"> 0\", IRNode.LSHIFT_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_mulc(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]*VALUE);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.SUB_VI, \"> 0\", IRNode.LSHIFT_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_mulc_n(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]*(-VALUE));\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.MUL_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n-    void test_mulv(int[] a0, int[] a1, int b) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]*b);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.MUL_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"})\n-    void test_mula(int[] a0, int[] a1, int[] a2) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]*a2[i]);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.ADD_VI,\n-                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n-                   IRNode.RSHIFT_VI,\n-                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n-                   IRNode.SUB_VI,\n-                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\" },\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n-    \/\/ Not vectorized: On aarch64, vectorization for this example results in\n-    \/\/ MulVL nodes, which asimd does not support.\n-    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n-                   IRNode.STORE_VECTOR,  \"= 0\",\n-                   IRNode.MUL_L,         \"> 0\" },\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    void test_divc(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]\/VALUE);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.ADD_VI,\n-                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n-                   IRNode.RSHIFT_VI,\n-                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\",\n-                   IRNode.SUB_VI,\n-                   IRNode.VECTOR_SIZE + \"min(max_int, max_long)\", \"> 0\" },\n-        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"sve\", \"true\"})\n-    \/\/ Not vectorized: On aarch64, vectorization for this example results in\n-    \/\/ MulVL nodes, which asimd does not support.\n-    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n-                   IRNode.STORE_VECTOR,  \"= 0\",\n-                   IRNode.MUL_L,         \"> 0\" },\n-        applyIfCPUFeatureAnd = {\"asimd\", \"true\", \"sve\", \"false\"})\n-    void test_divc_n(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]\/(-VALUE));\n-        }\n-    }\n-\n-    \/\/ Not vectorized: no vector div. NOTE: This check does not document the\n-    \/\/ _desired_ behavior of the system but the current behavior (no\n-    \/\/ vectorization)\n-    @Test\n-    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n-                   IRNode.STORE_VECTOR,  \"= 0\" })\n-    void test_divv(int[] a0, int[] a1, int b) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]\/b);\n-        }\n-    }\n-\n-    \/\/ Not vectorized: no vector div. NOTE: This check does not document the\n-    \/\/ _desired_ behavior of the system but the current behavior (no\n-    \/\/ vectorization)\n-    @Test\n-    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n-                   IRNode.STORE_VECTOR,  \"= 0\" })\n-    void test_diva(int[] a0, int[] a1, int[] a2) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]\/a2[i]);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.AND_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_andc(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]&BIT_MASK);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.AND_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_andv(int[] a0, int[] a1, int b) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]&b);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.AND_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_anda(int[] a0, int[] a1, int[] a2) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]&a2[i]);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.OR_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_orc(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]|BIT_MASK);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.OR_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_orv(int[] a0, int[] a1, int b) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]|b);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.OR_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_ora(int[] a0, int[] a1, int[] a2) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]|a2[i]);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.XOR_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_xorc(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]^BIT_MASK);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.XOR_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_xorv(int[] a0, int[] a1, int b) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]^b);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.XOR_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_xora(int[] a0, int[] a1, int[] a2) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]^a2[i]);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.LSHIFT_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_sllc(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]<<VALUE);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.LSHIFT_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_sllc_n(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]<<(-VALUE));\n-        }\n-    }\n-\n-    \/\/ Vector shift not expected as shift is a NOP.\n-    @Test\n-    @IR(counts = { IRNode.LSHIFT_VI,     \"= 0\",\n-                   IRNode.LOAD_VECTOR_I, \"> 0\",\n-                   IRNode.STORE_VECTOR,  \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_sllc_o(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]<<SHIFT);\n-        }\n-    }\n-\n-    \/\/ Vector shift not expected as shift is a NOP.\n-    @Test\n-    @IR(counts = { IRNode.LSHIFT_VI,     \"= 0\",\n-                   IRNode.LOAD_VECTOR_I, \"> 0\",\n-                   IRNode.STORE_VECTOR,  \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_sllc_on(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]<<(-SHIFT));\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.LSHIFT_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_sllv(int[] a0, int[] a1, int b) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]<<b);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.URSHIFT_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_srlc(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]>>>VALUE);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.URSHIFT_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_srlc_n(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]>>>(-VALUE));\n-        }\n-    }\n-\n-    \/\/ Vector shift not expected as shift is a NOP.\n-    @Test\n-    @IR(counts = { IRNode.URSHIFT_VI,    \"= 0\",\n-                   IRNode.LOAD_VECTOR_I, \"> 0\",\n-                   IRNode.STORE_VECTOR,  \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_srlc_o(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]>>>SHIFT);\n-        }\n-    }\n-\n-    \/\/ Vector shift not expected as shift is a NOP.\n-    @Test\n-    @IR(counts = { IRNode.URSHIFT_VI,    \"= 0\",\n-                   IRNode.LOAD_VECTOR_I, \"> 0\",\n-                   IRNode.STORE_VECTOR,  \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_srlc_on(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]>>>(-SHIFT));\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.URSHIFT_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_srlv(int[] a0, int[] a1, int b) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]>>>b);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.RSHIFT_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_srac(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]>>VALUE);\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.RSHIFT_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_srac_n(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]>>(-VALUE));\n-        }\n-    }\n-\n-    \/\/ Vector shift not expected as shift is a NOP.\n-    @Test\n-    @IR(counts = { IRNode.RSHIFT_VI,     \"= 0\",\n-                   IRNode.LOAD_VECTOR_I, \"> 0\",\n-                   IRNode.STORE_VECTOR,  \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_srac_o(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]>>SHIFT);\n-        }\n-    }\n-\n-    \/\/ Vector shift not expected as shift is a NOP.\n-    @Test\n-    @IR(counts = { IRNode.RSHIFT_VI,     \"= 0\",\n-                   IRNode.LOAD_VECTOR_I, \"> 0\",\n-                   IRNode.STORE_VECTOR,  \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_srac_on(int[] a0, int[] a1) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]>>(-SHIFT));\n-        }\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.RSHIFT_VI, \"> 0\" },\n-        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n-    void test_srav(int[] a0, int[] a1, int b) {\n-        for (int i = 0; i < a0.length; i+=1) {\n-            a0[i] = (int)(a1[i]>>b);\n-        }\n-    }\n-\n-    \/\/ Not vectorized currently. NOTE: This check does not document the\n-    \/\/ _desired_ behavior of the system but the current behavior (no\n-    \/\/ vectorization)\n-    @Test\n-    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n-                   IRNode.STORE_VECTOR,  \"= 0\" })\n-    void test_pack2(long[] p2, int[] a1) {\n-        if (p2.length*2 > a1.length) return;\n-        for (int i = 0; i < p2.length; i+=1) {\n-            long l0 = (long)a1[i*2+0];\n-            long l1 = (long)a1[i*2+1];\n-            p2[i] = (l1 << 32) | (l0 & 0xFFFFFFFFl);\n-        }\n-    }\n-\n-    \/\/ Not vectorized currently. NOTE: This check does not document the\n-    \/\/ _desired_ behavior of the system but the current behavior (no\n-    \/\/ vectorization)\n-    @Test\n-    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n-                   IRNode.STORE_VECTOR,  \"= 0\" })\n-    void test_unpack2(int[] a0, long[] p2) {\n-        if (p2.length*2 > a0.length) return;\n-        for (int i = 0; i < p2.length; i+=1) {\n-            long l = p2[i];\n-            a0[i*2+0] = (int)(l & 0xFFFFFFFFl);\n-            a0[i*2+1] = (int)(l >> 32);\n-        }\n-    }\n-\n-    \/\/ Not vectorized currently. NOTE: This check does not document the\n-    \/\/ _desired_ behavior of the system but the current behavior (no\n-    \/\/ vectorization)\n-    @Test\n-    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n-                   IRNode.STORE_VECTOR,  \"= 0\" })\n-    void test_pack2_swap(long[] p2, int[] a1) {\n-        if (p2.length*2 > a1.length) return;\n-        for (int i = 0; i < p2.length; i+=1) {\n-            long l0 = (long)a1[i*2+0];\n-            long l1 = (long)a1[i*2+1];\n-            p2[i] = (l0 << 32) | (l1 & 0xFFFFFFFFl);\n-        }\n-    }\n-\n-    \/\/ Not vectorized currently. NOTE: This check does not document the\n-    \/\/ _desired_ behavior of the system but the current behavior (no\n-    \/\/ vectorization)\n-    @Test\n-    @IR(counts = { IRNode.LOAD_VECTOR_I, \"= 0\",\n-                   IRNode.STORE_VECTOR,  \"= 0\" })\n-    void test_unpack2_swap(int[] a0, long[] p2) {\n-        if (p2.length*2 > a0.length) return;\n-        for (int i = 0; i < p2.length; i+=1) {\n-            long l = p2[i];\n-            a0[i*2+0] = (int)(l >> 32);\n-            a0[i*2+1] = (int)(l & 0xFFFFFFFFl);\n-        }\n-    }\n-\n-    static int verify(String text, int i, int elem, int val) {\n-        if (elem != val) {\n-            System.err.println(text + \"[\" + i + \"] = \" + elem + \" != \" + val);\n-            return 1;\n-        }\n-        return 0;\n-    }\n-\n-    static int verify(String text, int i, long elem, long val) {\n-        if (elem != val) {\n-            System.err.println(text + \"[\" + i + \"] = \" + Long.toHexString(elem) + \" != \" + Long.toHexString(val));\n-            return 1;\n-        }\n-        return 0;\n+  private static final int ARRLEN = 997;\n+  private static final int ITERS  = 11000;\n+  private static final int ADD_INIT = Integer.MAX_VALUE-500;\n+  private static final int BIT_MASK = 0xEC80F731;\n+  private static final int VALUE = 15;\n+  private static final int SHIFT = 32;\n+\n+  public static void main(String args[]) {\n+    System.out.println(\"Testing Integer vectors\");\n+    int errn = test();\n+    if (errn > 0) {\n+      System.err.println(\"FAILED: \" + errn + \" errors\");\n+      System.exit(97);\n+    }\n+    System.out.println(\"PASSED\");\n+  }\n+\n+  static int test() {\n+    int[] a0 = new int[ARRLEN];\n+    int[] a1 = new int[ARRLEN];\n+    int[] a2 = new int[ARRLEN];\n+    int[] a3 = new int[ARRLEN];\n+    int[] a4 = new int[ARRLEN];\n+    long[] p2 = new long[ARRLEN\/2];\n+    \/\/ Initialize\n+    int gold_sum = 0;\n+    for (int i=0; i<ARRLEN; i++) {\n+      int val = (int)(ADD_INIT+i);\n+      gold_sum += val;\n+      a1[i] = val;\n+      a2[i] = (int)VALUE;\n+      a3[i] = (int)-VALUE;\n+      a4[i] = (int)BIT_MASK;\n+    }\n+    System.out.println(\"Warmup\");\n+    for (int i=0; i<ITERS; i++) {\n+      test_sum(a1);\n+      test_addc(a0, a1);\n+      test_addv(a0, a1, (int)VALUE);\n+      test_adda(a0, a1, a2);\n+      test_subc(a0, a1);\n+      test_subv(a0, a1, (int)VALUE);\n+      test_suba(a0, a1, a2);\n+      test_mulc(a0, a1);\n+      test_mulv(a0, a1, (int)VALUE);\n+      test_mula(a0, a1, a2);\n+      test_divc(a0, a1);\n+      test_divv(a0, a1, (int)VALUE);\n+      test_diva(a0, a1, a2);\n+      test_mulc_n(a0, a1);\n+      test_mulv(a0, a1, (int)-VALUE);\n+      test_mula(a0, a1, a3);\n+      test_divc_n(a0, a1);\n+      test_divv(a0, a1, (int)-VALUE);\n+      test_diva(a0, a1, a3);\n+      test_andc(a0, a1);\n+      test_andv(a0, a1, (int)BIT_MASK);\n+      test_anda(a0, a1, a4);\n+      test_orc(a0, a1);\n+      test_orv(a0, a1, (int)BIT_MASK);\n+      test_ora(a0, a1, a4);\n+      test_xorc(a0, a1);\n+      test_xorv(a0, a1, (int)BIT_MASK);\n+      test_xora(a0, a1, a4);\n+      test_sllc(a0, a1);\n+      test_sllv(a0, a1, VALUE);\n+      test_srlc(a0, a1);\n+      test_srlv(a0, a1, VALUE);\n+      test_srac(a0, a1);\n+      test_srav(a0, a1, VALUE);\n+      test_sllc_n(a0, a1);\n+      test_sllv(a0, a1, -VALUE);\n+      test_srlc_n(a0, a1);\n+      test_srlv(a0, a1, -VALUE);\n+      test_srac_n(a0, a1);\n+      test_srav(a0, a1, -VALUE);\n+      test_sllc_o(a0, a1);\n+      test_sllv(a0, a1, SHIFT);\n+      test_srlc_o(a0, a1);\n+      test_srlv(a0, a1, SHIFT);\n+      test_srac_o(a0, a1);\n+      test_srav(a0, a1, SHIFT);\n+      test_sllc_on(a0, a1);\n+      test_sllv(a0, a1, -SHIFT);\n+      test_srlc_on(a0, a1);\n+      test_srlv(a0, a1, -SHIFT);\n+      test_srac_on(a0, a1);\n+      test_srav(a0, a1, -SHIFT);\n+      test_pack2(p2, a1);\n+      test_unpack2(a0, p2);\n+      test_pack2_swap(p2, a1);\n+      test_unpack2_swap(a0, p2);\n+    }\n+    \/\/ Test and verify results\n+    System.out.println(\"Verification\");\n+    int errn = 0;\n+    {\n+      int sum = test_sum(a1);\n+      if (sum != gold_sum) {\n+        System.err.println(\"test_sum:  \" + sum + \" != \" + gold_sum);\n+        errn++;\n+      }\n+\n+      test_addc(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addc: \", i, a0[i], (int)((int)(ADD_INIT+i)+VALUE));\n+      }\n+      test_addv(a0, a1, (int)VALUE);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addv: \", i, a0[i], (int)((int)(ADD_INIT+i)+VALUE));\n+      }\n+      test_adda(a0, a1, a2);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_adda: \", i, a0[i], (int)((int)(ADD_INIT+i)+VALUE));\n+      }\n+\n+      test_subc(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subc: \", i, a0[i], (int)((int)(ADD_INIT+i)-VALUE));\n+      }\n+      test_subv(a0, a1, (int)VALUE);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subv: \", i, a0[i], (int)((int)(ADD_INIT+i)-VALUE));\n+      }\n+      test_suba(a0, a1, a2);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_suba: \", i, a0[i], (int)((int)(ADD_INIT+i)-VALUE));\n+      }\n+\n+      test_mulc(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_mulc: \", i, a0[i], (int)((int)(ADD_INIT+i)*VALUE));\n+      }\n+      test_mulv(a0, a1, (int)VALUE);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_mulv: \", i, a0[i], (int)((int)(ADD_INIT+i)*VALUE));\n+      }\n+      test_mula(a0, a1, a2);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_mula: \", i, a0[i], (int)((int)(ADD_INIT+i)*VALUE));\n+      }\n+\n+      test_divc(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_divc: \", i, a0[i], (int)((int)(ADD_INIT+i)\/VALUE));\n+      }\n+      test_divv(a0, a1, (int)VALUE);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_divv: \", i, a0[i], (int)((int)(ADD_INIT+i)\/VALUE));\n+      }\n+      test_diva(a0, a1, a2);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_diva: \", i, a0[i], (int)((int)(ADD_INIT+i)\/VALUE));\n+      }\n+\n+      test_mulc_n(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_mulc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)*(-VALUE)));\n+      }\n+      test_mulv(a0, a1, (int)-VALUE);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_mulv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)*(-VALUE)));\n+      }\n+      test_mula(a0, a1, a3);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_mula_n: \", i, a0[i], (int)((int)(ADD_INIT+i)*(-VALUE)));\n+      }\n+\n+      test_divc_n(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_divc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)\/(-VALUE)));\n+      }\n+      test_divv(a0, a1, (int)-VALUE);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_divv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)\/(-VALUE)));\n+      }\n+      test_diva(a0, a1, a3);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_diva_n: \", i, a0[i], (int)((int)(ADD_INIT+i)\/(-VALUE)));\n+      }\n+\n+      test_andc(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andc: \", i, a0[i], (int)((int)(ADD_INIT+i)&BIT_MASK));\n+      }\n+      test_andv(a0, a1, (int)BIT_MASK);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andv: \", i, a0[i], (int)((int)(ADD_INIT+i)&BIT_MASK));\n+      }\n+      test_anda(a0, a1, a4);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_anda: \", i, a0[i], (int)((int)(ADD_INIT+i)&BIT_MASK));\n+      }\n+\n+      test_orc(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_orc: \", i, a0[i], (int)((int)(ADD_INIT+i)|BIT_MASK));\n+      }\n+      test_orv(a0, a1, (int)BIT_MASK);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_orv: \", i, a0[i], (int)((int)(ADD_INIT+i)|BIT_MASK));\n+      }\n+      test_ora(a0, a1, a4);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_ora: \", i, a0[i], (int)((int)(ADD_INIT+i)|BIT_MASK));\n+      }\n+\n+      test_xorc(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xorc: \", i, a0[i], (int)((int)(ADD_INIT+i)^BIT_MASK));\n+      }\n+      test_xorv(a0, a1, (int)BIT_MASK);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xorv: \", i, a0[i], (int)((int)(ADD_INIT+i)^BIT_MASK));\n+      }\n+      test_xora(a0, a1, a4);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xora: \", i, a0[i], (int)((int)(ADD_INIT+i)^BIT_MASK));\n+      }\n+\n+      test_sllc(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_sllc: \", i, a0[i], (int)((int)(ADD_INIT+i)<<VALUE));\n+      }\n+      test_sllv(a0, a1, VALUE);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_sllv: \", i, a0[i], (int)((int)(ADD_INIT+i)<<VALUE));\n+      }\n+\n+      test_srlc(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_srlc: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>VALUE));\n+      }\n+      test_srlv(a0, a1, VALUE);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_srlv: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>VALUE));\n+      }\n+\n+      test_srac(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_srac: \", i, a0[i], (int)((int)(ADD_INIT+i)>>VALUE));\n+      }\n+      test_srav(a0, a1, VALUE);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_srav: \", i, a0[i], (int)((int)(ADD_INIT+i)>>VALUE));\n+      }\n+\n+      test_sllc_n(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_sllc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-VALUE)));\n+      }\n+      test_sllv(a0, a1, -VALUE);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_sllv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-VALUE)));\n+      }\n+\n+      test_srlc_n(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_srlc_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-VALUE)));\n+      }\n+      test_srlv(a0, a1, -VALUE);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_srlv_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-VALUE)));\n+      }\n+\n+      test_srac_n(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_srac_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-VALUE)));\n+      }\n+      test_srav(a0, a1, -VALUE);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_srav_n: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-VALUE)));\n+      }\n+\n+      test_sllc_o(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_sllc_o: \", i, a0[i], (int)((int)(ADD_INIT+i)<<SHIFT));\n+      }\n+      test_sllv(a0, a1, SHIFT);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_sllv_o: \", i, a0[i], (int)((int)(ADD_INIT+i)<<SHIFT));\n+      }\n+\n+      test_srlc_o(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_srlc_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>SHIFT));\n+      }\n+      test_srlv(a0, a1, SHIFT);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_srlv_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>SHIFT));\n+      }\n+\n+      test_srac_o(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_srac_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>SHIFT));\n+      }\n+      test_srav(a0, a1, SHIFT);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_srav_o: \", i, a0[i], (int)((int)(ADD_INIT+i)>>SHIFT));\n+      }\n+\n+      test_sllc_on(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_sllc_on: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-SHIFT)));\n+      }\n+      test_sllv(a0, a1, -SHIFT);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_sllv_on: \", i, a0[i], (int)((int)(ADD_INIT+i)<<(-SHIFT)));\n+      }\n+\n+      test_srlc_on(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_srlc_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-SHIFT)));\n+      }\n+      test_srlv(a0, a1, -SHIFT);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_srlv_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>>(-SHIFT)));\n+      }\n+\n+      test_srac_on(a0, a1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_srac_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-SHIFT)));\n+      }\n+      test_srav(a0, a1, -SHIFT);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_srav_on: \", i, a0[i], (int)((int)(ADD_INIT+i)>>(-SHIFT)));\n+      }\n+\n+      test_pack2(p2, a1);\n+      for (int i=0; i<ARRLEN\/2; i++) {\n+        errn += verify(\"test_pack2: \", i, p2[i], ((long)(ADD_INIT+2*i) & 0xFFFFFFFFl) | ((long)(ADD_INIT+2*i+1) << 32));\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        a0[i] = -1;\n+      }\n+      test_unpack2(a0, p2);\n+      for (int i=0; i<(ARRLEN&(-2)); i++) {\n+        errn += verify(\"test_unpack2: \", i, a0[i], (ADD_INIT+i));\n+      }\n+\n+      test_pack2_swap(p2, a1);\n+      for (int i=0; i<ARRLEN\/2; i++) {\n+        errn += verify(\"test_pack2_swap: \", i, p2[i], ((long)(ADD_INIT+2*i+1) & 0xFFFFFFFFl) | ((long)(ADD_INIT+2*i) << 32));\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        a0[i] = -1;\n+      }\n+      test_unpack2_swap(a0, p2);\n+      for (int i=0; i<(ARRLEN&(-2)); i++) {\n+        errn += verify(\"test_unpack2_swap: \", i, a0[i], (ADD_INIT+i));\n+      }\n+\n+    }\n+\n+    return errn;\n+  }\n+\n+  static int test_sum(int[] a1) {\n+    int sum = 0;\n+    for (int i = 0; i < a1.length; i+=1) {\n+      sum += a1[i];\n+    }\n+    return sum;\n+  }\n+\n+  static void test_addc(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]+VALUE);\n+    }\n+  }\n+  static void test_addv(int[] a0, int[] a1, int b) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]+b);\n+    }\n+  }\n+  static void test_adda(int[] a0, int[] a1, int[] a2) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]+a2[i]);\n+    }\n+  }\n+\n+  static void test_subc(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]-VALUE);\n+    }\n+  }\n+  static void test_subv(int[] a0, int[] a1, int b) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]-b);\n+    }\n+  }\n+  static void test_suba(int[] a0, int[] a1, int[] a2) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]-a2[i]);\n+    }\n+  }\n+\n+  static void test_mulc(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]*VALUE);\n+    }\n+  }\n+  static void test_mulc_n(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]*(-VALUE));\n+    }\n+  }\n+  static void test_mulv(int[] a0, int[] a1, int b) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]*b);\n+    }\n+  }\n+  static void test_mula(int[] a0, int[] a1, int[] a2) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]*a2[i]);\n+    }\n+  }\n+\n+  static void test_divc(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]\/VALUE);\n+    }\n+  }\n+  static void test_divc_n(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]\/(-VALUE));\n+    }\n+  }\n+  static void test_divv(int[] a0, int[] a1, int b) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]\/b);\n+    }\n+  }\n+  static void test_diva(int[] a0, int[] a1, int[] a2) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]\/a2[i]);\n+    }\n+  }\n+\n+  static void test_andc(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]&BIT_MASK);\n+    }\n+  }\n+  static void test_andv(int[] a0, int[] a1, int b) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]&b);\n+    }\n+  }\n+  static void test_anda(int[] a0, int[] a1, int[] a2) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]&a2[i]);\n@@ -890,0 +482,160 @@\n+  }\n+\n+  static void test_orc(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]|BIT_MASK);\n+    }\n+  }\n+  static void test_orv(int[] a0, int[] a1, int b) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]|b);\n+    }\n+  }\n+  static void test_ora(int[] a0, int[] a1, int[] a2) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]|a2[i]);\n+    }\n+  }\n+\n+  static void test_xorc(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]^BIT_MASK);\n+    }\n+  }\n+  static void test_xorv(int[] a0, int[] a1, int b) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]^b);\n+    }\n+  }\n+  static void test_xora(int[] a0, int[] a1, int[] a2) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]^a2[i]);\n+    }\n+  }\n+\n+  static void test_sllc(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]<<VALUE);\n+    }\n+  }\n+  static void test_sllc_n(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]<<(-VALUE));\n+    }\n+  }\n+  static void test_sllc_o(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]<<SHIFT);\n+    }\n+  }\n+  static void test_sllc_on(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]<<(-SHIFT));\n+    }\n+  }\n+  static void test_sllv(int[] a0, int[] a1, int b) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]<<b);\n+    }\n+  }\n+\n+  static void test_srlc(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]>>>VALUE);\n+    }\n+  }\n+  static void test_srlc_n(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]>>>(-VALUE));\n+    }\n+  }\n+  static void test_srlc_o(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]>>>SHIFT);\n+    }\n+  }\n+  static void test_srlc_on(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]>>>(-SHIFT));\n+    }\n+  }\n+  static void test_srlv(int[] a0, int[] a1, int b) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]>>>b);\n+    }\n+  }\n+\n+  static void test_srac(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]>>VALUE);\n+    }\n+  }\n+  static void test_srac_n(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]>>(-VALUE));\n+    }\n+  }\n+  static void test_srac_o(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]>>SHIFT);\n+    }\n+  }\n+  static void test_srac_on(int[] a0, int[] a1) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]>>(-SHIFT));\n+    }\n+  }\n+  static void test_srav(int[] a0, int[] a1, int b) {\n+    for (int i = 0; i < a0.length; i+=1) {\n+      a0[i] = (int)(a1[i]>>b);\n+    }\n+  }\n+\n+  static void test_pack2(long[] p2, int[] a1) {\n+    if (p2.length*2 > a1.length) return;\n+    for (int i = 0; i < p2.length; i+=1) {\n+      long l0 = (long)a1[i*2+0];\n+      long l1 = (long)a1[i*2+1];\n+      p2[i] = (l1 << 32) | (l0 & 0xFFFFFFFFl);\n+    }\n+  }\n+  static void test_unpack2(int[] a0, long[] p2) {\n+    if (p2.length*2 > a0.length) return;\n+    for (int i = 0; i < p2.length; i+=1) {\n+      long l = p2[i];\n+      a0[i*2+0] = (int)(l & 0xFFFFFFFFl);\n+      a0[i*2+1] = (int)(l >> 32);\n+    }\n+  }\n+  static void test_pack2_swap(long[] p2, int[] a1) {\n+    if (p2.length*2 > a1.length) return;\n+    for (int i = 0; i < p2.length; i+=1) {\n+      long l0 = (long)a1[i*2+0];\n+      long l1 = (long)a1[i*2+1];\n+      p2[i] = (l0 << 32) | (l1 & 0xFFFFFFFFl);\n+    }\n+  }\n+  static void test_unpack2_swap(int[] a0, long[] p2) {\n+    if (p2.length*2 > a0.length) return;\n+    for (int i = 0; i < p2.length; i+=1) {\n+      long l = p2[i];\n+      a0[i*2+0] = (int)(l >> 32);\n+      a0[i*2+1] = (int)(l & 0xFFFFFFFFl);\n+    }\n+  }\n+\n+  static int verify(String text, int i, int elem, int val) {\n+    if (elem != val) {\n+      System.err.println(text + \"[\" + i + \"] = \" + elem + \" != \" + val);\n+      return 1;\n+    }\n+    return 0;\n+  }\n+\n+  static int verify(String text, int i, long elem, long val) {\n+    if (elem != val) {\n+      System.err.println(text + \"[\" + i + \"] = \" + Long.toHexString(elem) + \" != \" + Long.toHexString(val));\n+      return 1;\n+    }\n+    return 0;\n+  }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr7200264\/TestIntVect.java","additions":614,"deletions":862,"binary":false,"changes":1476,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 7200264\n+ * @summary 7192963 changes disabled shift vectors\n+ * @requires vm.cpu.features ~= \".*sse2.*\" & vm.debug & vm.flavor == \"server\"\n+ * @requires !vm.emulatedClient & !vm.graal.enabled\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:StressLongCountedLoop=0\n+ *                   compiler.c2.cr7200264.TestSSE2IntVect\n+ *\/\n+\n+package compiler.c2.cr7200264;\n+\n+public class TestSSE2IntVect {\n+    public static void main(String[] args) throws Throwable {\n+        TestDriver test = new TestDriver();\n+        test.addExpectedVectorization(\"AddVI\", 4);\n+        test.addExpectedVectorization(\"SubVI\", 4);\n+        test.addExpectedVectorization(\"AndV\", 3);\n+        test.addExpectedVectorization(\"OrV\", 3);\n+        test.addExpectedVectorization(\"XorV\", 3);\n+        test.addExpectedVectorization(\"LShiftVI\", 5);\n+        test.addExpectedVectorization(\"RShiftVI\", 3);\n+        test.addExpectedVectorization(\"URShiftVI\", 3);\n+        test.run();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr7200264\/TestSSE2IntVect.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 7200264\n+ * @summary 7192963 changes disabled shift vectors\n+ * @requires vm.cpu.features ~= \".*sse4\\\\.1.*\" & vm.debug & vm.flavor == \"server\"\n+ * @requires !vm.emulatedClient & !vm.graal.enabled\n+ * @library \/test\/lib \/\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:StressLongCountedLoop=0\n+ *                   compiler.c2.cr7200264.TestSSE4IntVect\n+ *\/\n+\n+package compiler.c2.cr7200264;\n+\n+public class TestSSE4IntVect {\n+    public static void main(String[] args) throws Throwable {\n+        TestDriver test = new TestDriver();\n+        test.addExpectedVectorization(\"MulVI\", 2);\n+        test.run();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/cr7200264\/TestSSE4IntVect.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"}]}