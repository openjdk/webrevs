{"files":[{"patch":"@@ -540,1 +540,1 @@\n-static void adjust_check(Node* proj, Node* range, Node* index,\n+static void adjust_check(IfProjNode* proj, Node* range, Node* index,\n@@ -548,2 +548,2 @@\n-  DEBUG_ONLY( if( !bol->is_Bool() ) { proj->dump(3); fatal(\"Expect projection-->IfNode-->BoolNode\"); } )\n-  if( !bol->is_Bool() ) return;\n+  DEBUG_ONLY( if (!bol->is_Bool()) { proj->dump(3); fatal(\"Expect projection-->IfNode-->BoolNode\"); } )\n+  if (!bol->is_Bool()) return;\n@@ -554,2 +554,2 @@\n-  if( index ) {\n-    new_add = off_lo ? gvn->transform(new AddINode( index, new_add )) : index;\n+  if (index) {\n+    new_add = off_lo ? gvn->transform(new AddINode(index, new_add)) : index;\n@@ -558,2 +558,2 @@\n-    ? new CmpUNode( new_add, range )\n-    : new CmpUNode( range, new_add );\n+    ? new CmpUNode(new_add, range)\n+    : new CmpUNode(range, new_add);\n@@ -562,1 +562,1 @@\n-  if( new_cmp == cmp ) return;\n+  if (new_cmp == cmp) return;\n@@ -564,3 +564,9 @@\n-  Node *new_bol = gvn->transform( new BoolNode( new_cmp, bol->as_Bool()->_test._test ) );\n-  igvn->rehash_node_delayed( iff );\n-  iff->set_req_X( 1, new_bol, igvn );\n+  Node* new_bol = gvn->transform(new BoolNode(new_cmp, bol->as_Bool()->_test._test));\n+  igvn->rehash_node_delayed(iff);\n+  iff->set_req_X(1, new_bol, igvn);\n+  \/\/ As part of range check smearing, this range check is widened. Loads and range check Cast nodes that are control\n+  \/\/ dependent on this range check now depend on multiple dominating range checks. These control dependent nodes end up\n+  \/\/ at the lowest\/nearest dominating check in the graph. To ensure that these Loads\/Casts do not float above any of the\n+  \/\/ dominating checks (even when the lowest dominating check is later replaced by yet another dominating check), we\n+  \/\/ need to pin them at the lowest dominating check.\n+  proj->pin_array_access_nodes(igvn);\n@@ -1033,0 +1039,4 @@\n+    if (adjusted_val->is_top() || adjusted_lim->is_top()) {\n+      return false;\n+    }\n+\n@@ -1420,1 +1430,1 @@\n-  Node* ctl;\n+  IfProjNode* ctl;\n@@ -1488,1 +1498,1 @@\n-    return dominated_by(prev_dom, igvn);\n+    return dominated_by(prev_dom, igvn, false);\n@@ -1495,1 +1505,1 @@\n-Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN *igvn) {\n+Node* IfNode::dominated_by(Node* prev_dom, PhaseIterGVN* igvn, bool pin_array_access_nodes) {\n@@ -1508,9 +1518,0 @@\n-  \/\/ Loop predicates may have depending checks which should not\n-  \/\/ be skipped. For example, range check predicate has two checks\n-  \/\/ for lower and upper bounds.\n-  ProjNode* unc_proj = proj_out(1 - prev_dom->as_Proj()->_con)->as_Proj();\n-  if (unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_predicate) != nullptr ||\n-      unc_proj->is_uncommon_trap_proj(Deoptimization::Reason_profile_predicate) != nullptr) {\n-    prev_dom = idom;\n-  }\n-\n@@ -1539,0 +1540,13 @@\n+        if (pin_array_access_nodes && data_target != top) {\n+          \/\/ As a result of range check smearing, Loads and range check Cast nodes that are control dependent on this\n+          \/\/ range check (that is about to be removed) now depend on multiple dominating range checks. After the removal\n+          \/\/ of this range check, these control dependent nodes end up at the lowest\/nearest dominating check in the\n+          \/\/ graph. To ensure that these Loads\/Casts do not float above any of the dominating checks (even when the\n+          \/\/ lowest dominating check is later replaced by yet another dominating check), we need to pin them at the\n+          \/\/ lowest dominating check.\n+          Node* clone = s->pin_array_access_node();\n+          if (clone != nullptr) {\n+            clone = igvn->transform(clone);\n+            igvn->replace_node(s, clone);\n+          }\n+        }\n@@ -1746,0 +1760,16 @@\n+void IfProjNode::pin_array_access_nodes(PhaseIterGVN* igvn) {\n+  for (DUIterator i = outs(); has_out(i); i++) {\n+    Node* u = out(i);\n+    if (!u->depends_only_on_test()) {\n+      continue;\n+    }\n+    Node* clone = u->pin_array_access_node();\n+    if (clone != nullptr) {\n+      clone = igvn->transform(clone);\n+      assert(clone != u, \"shouldn't common\");\n+      igvn->replace_node(u, clone);\n+      --i;\n+    }\n+  }\n+}\n+\n@@ -1919,1 +1949,1 @@\n-            prev_checks[nb_checks % NRC].ctl = prev_dom;\n+            prev_checks[nb_checks % NRC].ctl = prev_dom->as_IfProj();\n@@ -1937,0 +1967,9 @@\n+      if (can_reshape && !phase->C->post_loop_opts_phase()) {\n+        \/\/ We are about to perform range check smearing (i.e. remove this RangeCheck if it is dominated by\n+        \/\/ a series of RangeChecks which have a range that covers this RangeCheck). This can cause array access nodes to\n+        \/\/ be pinned. We want to avoid that and first allow range check elimination a chance to remove the RangeChecks\n+        \/\/ from loops. Hence, we delay range check smearing until after loop opts.\n+        phase->C->record_for_post_loop_opts_igvn(this);\n+        return nullptr;\n+      }\n+\n@@ -2010,0 +2049,20 @@\n+      \/\/ The last RangeCheck is found to be redundant with a sequence of n (n >= 2) preceding RangeChecks.\n+      \/\/ If an array load is control dependent on the eliminated range check, the array load nodes (CastII and Load)\n+      \/\/ become control dependent on the last range check of the sequence, but they are really dependent on the entire\n+      \/\/ sequence of RangeChecks. If RangeCheck#n is later replaced by a dominating identical check, the array load\n+      \/\/ nodes must not float above the n-1 other RangeCheck in the sequence. We pin the array load nodes here to\n+      \/\/ guarantee it doesn't happen.\n+      \/\/\n+      \/\/ RangeCheck#1                 RangeCheck#1\n+      \/\/    |      \\                     |      \\\n+      \/\/    |      uncommon trap         |      uncommon trap\n+      \/\/    ..                           ..\n+      \/\/ RangeCheck#n              -> RangeCheck#n\n+      \/\/    |      \\                     |      \\\n+      \/\/    |      uncommon trap        CastII  uncommon trap\n+      \/\/ RangeCheck                     Load\n+      \/\/    |      \\\n+      \/\/   CastII  uncommon trap\n+      \/\/   Load\n+\n+      return dominated_by(prev_dom, igvn, true);\n@@ -2020,1 +2079,1 @@\n-  return dominated_by(prev_dom, igvn);\n+  return dominated_by(prev_dom, igvn, false);\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":84,"deletions":25,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2751,1 +2751,1 @@\n-        Node* in1 = first->in(1);\n+        Node* in1 = vector_opd(p, 1);\n@@ -4209,1 +4209,4 @@\n-  if (is_loop_member(adr)) {\n+  if (!invariant(adr)) {\n+    \/\/ The address must be invariant for the current loop. But if we are in a main-loop,\n+    \/\/ it must also be invariant of the pre-loop, otherwise we cannot use this address\n+    \/\/ for the pre-loop limit adjustment required for main-loop alignment.\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}