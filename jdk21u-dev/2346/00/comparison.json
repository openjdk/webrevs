{"files":[{"patch":"@@ -849,0 +849,7 @@\n+\n+        @Override\n+        public List<Runnable> shutdownNow() {\n+            List<Runnable> unexecuted = super.shutdownNow();\n+            cleanable.clean();  \/\/ unregisters the cleanable\n+            return unexecuted;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Executors.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 6399443 8302899\n+ * @bug 6399443 8302899 8362123\n@@ -29,0 +29,1 @@\n+ * @library \/test\/lib\/\n@@ -33,0 +34,3 @@\n+import java.lang.ref.PhantomReference;\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n@@ -37,0 +41,1 @@\n+import java.util.concurrent.ThreadFactory;\n@@ -39,0 +44,1 @@\n+import java.util.function.Consumer;\n@@ -43,0 +49,3 @@\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.util.ForceGC;\n+\n@@ -64,0 +73,7 @@\n+    private static Stream<Arguments> shutdownMethods() {\n+        return Stream.<Consumer<ExecutorService>>of(\n+                e -> e.shutdown(),\n+                e -> e.shutdownNow()\n+            ).map(Arguments::of);\n+    }\n+\n@@ -113,0 +129,22 @@\n+    @ParameterizedTest\n+    @MethodSource(\"shutdownMethods\")\n+    void testShutdownUnlinksCleaner(Consumer<ExecutorService> shutdown) throws Exception {\n+        ClassLoader classLoader =\n+            Utils.getTestClassPathURLClassLoader(ClassLoader.getPlatformClassLoader());\n+\n+        ReferenceQueue<?> queue = new ReferenceQueue<>();\n+        Reference<?> reference = new PhantomReference(classLoader, queue);\n+        try {\n+            Class<?> isolatedClass = classLoader.loadClass(\"AutoShutdown$IsolatedClass\");\n+            assertSame(isolatedClass.getClassLoader(), classLoader);\n+            isolatedClass.getDeclaredMethod(\"shutdown\", Consumer.class).invoke(null, shutdown);\n+\n+            isolatedClass = null;\n+            classLoader = null;\n+\n+            assertTrue(ForceGC.wait(() -> queue.poll() != null));\n+        } finally {\n+            Reference.reachabilityFence(reference);\n+        }\n+    }\n+\n@@ -135,1 +173,0 @@\n-}\n@@ -137,0 +174,18 @@\n+    public static class IsolatedClass {\n+\n+        private static final ExecutorService executor =\n+            Executors.newSingleThreadExecutor(new IsolatedThreadFactory());\n+\n+        public static void shutdown(Consumer<ExecutorService> shutdown) {\n+            shutdown.accept(executor);\n+        }\n+    }\n+\n+    public static class IsolatedThreadFactory implements ThreadFactory {\n+\n+        @Override\n+        public Thread newThread(Runnable r) {\n+            return new Thread(r);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/Executors\/AutoShutdown.java","additions":57,"deletions":2,"binary":false,"changes":59,"status":"modified"}]}