{"files":[{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"runtime\/os.hpp\"\n+#include \"nmt\/memMapPrinter.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include <limits.h>\n+\n+struct ProcMapsInfo {\n+  void* from = 0;\n+  void* to = 0;\n+  char prot[20 + 1];\n+  char offset[20 + 1];\n+  char dev[20 + 1];\n+  char inode[20 + 1];\n+  char filename[1024 + 1];\n+\n+  bool scan_proc_maps_line(const char* line) {\n+    prot[0] = offset[0] = dev[0] = inode[0] = filename[0] = '\\0';\n+    const int items_read = ::sscanf(line, \"%p-%p %20s %20s %20s %20s %1024s\",\n+        &from, &to, prot, offset, dev, inode, filename);\n+    return items_read >= 2; \/\/ need at least from and to\n+  }\n+};\n+\n+class LinuxMappingPrintInformation : public MappingPrintInformation {\n+  const ProcMapsInfo _info;\n+public:\n+\n+  LinuxMappingPrintInformation(const void* from, const void* to, const ProcMapsInfo* info) :\n+    MappingPrintInformation(from, to), _info(*info) {}\n+\n+  void print_OS_specific_details(outputStream* st) const override {\n+    st->print(\"%s %s \", _info.prot, _info.offset);\n+  }\n+\n+  const char* filename() const override { return _info.filename; }\n+};\n+\n+void MemMapPrinter::pd_print_header(outputStream* st) {\n+  st->print_cr(\"size          prot offset  What\");\n+}\n+\n+void MemMapPrinter::pd_iterate_all_mappings(MappingPrintClosure& closure) {\n+  FILE* f = os::fopen(\"\/proc\/self\/maps\", \"r\");\n+  if (f == nullptr) {\n+    return;\n+  }\n+  constexpr size_t linesize = sizeof(ProcMapsInfo);\n+  char line[linesize];\n+  while (fgets(line, sizeof(line), f) == line) {\n+    line[sizeof(line) - 1] = '\\0';\n+    ProcMapsInfo info;\n+    if (info.scan_proc_maps_line(line)) {\n+      LinuxMappingPrintInformation mapinfo(info.from, info.to, &info);\n+      closure.do_it(&mapinfo);\n+    }\n+  }\n+  ::fclose(f);\n+}\n","filename":"src\/hotspot\/os\/linux\/memMapPrinter_linux.cpp","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -175,1 +175,0 @@\n-  const char* name() const override { return \"AsyncLog Thread\"; }\n@@ -200,0 +199,2 @@\n+\n+  const char* name() const override { return \"AsyncLog Thread\"; }\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_NMT_MEMFLAGBITMAP_HPP\n+#define SHARE_NMT_MEMFLAGBITMAP_HPP\n+\n+#include \"memory\/allocation.hpp\" \/\/ for mt_number_of_types\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class MemFlagBitmap {\n+  uint32_t _v;\n+  STATIC_ASSERT(sizeof(_v) * BitsPerByte >= mt_number_of_types);\n+\n+public:\n+  MemFlagBitmap(uint32_t v = 0) : _v(v) {}\n+  MemFlagBitmap(const MemFlagBitmap& o) : _v(o._v) {}\n+\n+  uint32_t raw_value() const { return _v; }\n+\n+  void set_flag(MEMFLAGS f) {\n+    const int bitno = (int)f;\n+    _v |= nth_bit(bitno);\n+  }\n+\n+  bool has_flag(MEMFLAGS f) const {\n+    const int bitno = (int)f;\n+    return _v & nth_bit(bitno);\n+  }\n+\n+  bool has_any() const { return _v > 0; }\n+};\n+\n+#endif \/\/ SHARE_NMT_NMTUSAGE_HPP\n","filename":"src\/hotspot\/share\/nmt\/memFlagBitmap.hpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,309 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef LINUX\n+\n+#include \"logging\/logAsyncWriter.hpp\"\n+#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"runtime\/nonJavaThread.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"runtime\/threadSMR.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"nmt\/memFlagBitmap.hpp\"\n+#include \"nmt\/memMapPrinter.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"services\/virtualMemoryTracker.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+\/\/ Note: throughout this code we will use the term \"VMA\" for OS system level memory mapping\n+\n+\/\/\/ NMT mechanics\n+\n+\/\/ Short, clear, descriptive names for all possible markers. Note that we only expect to see\n+\/\/ those that have been used with mmap. Flags left out are printed with their nmt flag name.\n+#define NMT_FLAGS_DO(f) \\\n+  \/* flag, short, description *\/ \\\n+  f(mtGCCardSet,      \"CARDTBL\", \"GC Card table\") \\\n+  f(mtClassShared,    \"CDS\", \"CDS archives\") \\\n+  f(mtClass,          \"CLASS\", \"Class Space\") \\\n+  f(mtCode,           \"CODE\", \"Code Heap\") \\\n+  f(mtGC,             \"GC\", \"GC support data (e.g. bitmaps)\") \\\n+  f(mtInternal,       \"INTERN\", \"Internal\") \\\n+  f(mtJavaHeap,       \"JAVAHEAP\", \"Java Heap\") \\\n+  f(mtOther,          \"JDK\", \"allocated by JDK libraries other than VM\") \\\n+  f(mtMetaspace,      \"META\", \"Metaspace nodes (non-class)\") \\\n+  f(mtSafepoint,      \"POLL\", \"Polling pages\") \\\n+  f(mtThreadStack,    \"STACK\", \"(known) Thread Stack\") \\\n+  f(mtTest,           \"TEST\", \"JVM internal test mappings\")\n+  \/\/end\n+\n+static const char* get_shortname_for_nmt_flag(MEMFLAGS f) {\n+#define DO(flag, shortname, text) if (flag == f) return shortname;\n+  NMT_FLAGS_DO(DO)\n+#undef DO\n+  return NMTUtil::flag_to_enum_name(f);\n+}\n+\n+\/\/\/ NMT virtual memory\n+\n+static bool range_intersects(const void* from1, const void* to1, const void* from2, const void* to2) {\n+  return MAX2(from1, from2) < MIN2(to1, to2);\n+}\n+\n+\/\/ A Cache that correlates range with MEMFLAG, optimized to be iterated quickly\n+\/\/ (cache friendly).\n+class CachedNMTInformation : public VirtualMemoryWalker {\n+  struct Range { const void* from; const void* to; };\n+  \/\/ We keep ranges apart from flags since that prevents the padding a combined\n+  \/\/ structure would have, and it allows for faster iteration of ranges since more\n+  \/\/ of them fit into a cache line.\n+  Range* _ranges;\n+  MEMFLAGS* _flags;\n+  uintx _count, _capacity;\n+public:\n+  CachedNMTInformation() : _ranges(nullptr), _flags(nullptr), _count(0), _capacity(0) {}\n+\n+  ~CachedNMTInformation() {\n+    ALLOW_C_FUNCTION(free, ::free(_ranges);)\n+    ALLOW_C_FUNCTION(free, ::free(_flags);)\n+  }\n+\n+  bool add(const void* from, const void* to, MEMFLAGS f) {\n+    \/\/ We rely on NMT regions being sorted by base\n+    assert(_count == 0 || (from >= _ranges[_count - 1].to), \"NMT regions unordered?\");\n+    \/\/ we can just fold two regions if they are adjacent and have the same flag.\n+    if (_count > 0 && from == _ranges[_count - 1].to && f == _flags[_count - 1]) {\n+      _ranges[_count - 1].to = to;\n+      return true;\n+    }\n+    if (_count == _capacity) {\n+      \/\/ Enlarge if needed\n+      const uintx new_capacity = MAX2((uintx)4096, 2 * _capacity);\n+      \/\/ Unfortunately, we need to allocate manually, raw, since we must prevent NMT deadlocks (ThreadCritical).\n+      ALLOW_C_FUNCTION(realloc, _ranges = (Range*)::realloc(_ranges, new_capacity * sizeof(Range));)\n+      ALLOW_C_FUNCTION(realloc, _flags = (MEMFLAGS*)::realloc(_flags, new_capacity * sizeof(MEMFLAGS));)\n+      if (_ranges == nullptr || _flags == nullptr) {\n+        \/\/ In case of OOM lets make no fuzz. Just return.\n+        return false;\n+      }\n+      _capacity = new_capacity;\n+    }\n+    assert(_capacity > _count, \"Sanity\");\n+    _ranges[_count] = Range { from, to };\n+    _flags[_count] = f;\n+    _count++;\n+    return true;\n+  }\n+\n+  \/\/ Given a vma [from, to), find all regions that intersect with this vma and\n+  \/\/ return their collective flags.\n+  MemFlagBitmap lookup(const void* from, const void* to) const {\n+    MemFlagBitmap bm;\n+    for(uintx i = 0; i < _count; i++) {\n+      if (range_intersects(from, to, _ranges[i].from, _ranges[i].to)) {\n+        bm.set_flag(_flags[i]);\n+      } else if (from < _ranges[i].to) {\n+        break;\n+      }\n+    }\n+    return bm;\n+  }\n+\n+  bool do_allocation_site(const ReservedMemoryRegion* rgn) override {\n+    \/\/ Cancel iteration if we run out of memory (add returns false);\n+    return add(rgn->base(), rgn->end(), rgn->flag());\n+  }\n+\n+  \/\/ Iterate all NMT virtual memory regions and fill this cache.\n+  bool fill_from_nmt() {\n+    return VirtualMemoryTracker::walk_virtual_memory(this);\n+  }\n+};\n+\n+\/\/\/\/\/\/\/ Thread information \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Given a VMA [from, to) and a thread, check if vma intersects with thread stack\n+static bool vma_touches_thread_stack(const void* from, const void* to, const Thread* t) {\n+  \/\/ Java thread stacks (and sometimes also other threads) have guard pages. Therefore they typically occupy\n+  \/\/ at least two distinct neighboring VMAs. Therefore we typically have a 1:n relationshipt between thread\n+  \/\/ stack and vma.\n+  \/\/ Very rarely however is a VMA backing a thread stack folded together with another adjacent VMA by the\n+  \/\/ kernel. That can happen, e.g., for non-java threads that don't have guard pages.\n+  \/\/ Therefore we go for the simplest way here and check for intersection between VMA and thread stack.\n+  return range_intersects(from, to, (const void*)t->stack_end(), (const void*)t->stack_base());\n+}\n+\n+struct GCThreadClosure : public ThreadClosure {\n+  bool _found;\n+  uintx _tid;\n+  const void* const _from;\n+  const void* const _to;\n+  GCThreadClosure(const void* from, const void* to) : _found(false), _tid(0), _from(from), _to(to) {}\n+  void do_thread(Thread* t) override {\n+    if (_tid == 0 && t != nullptr && vma_touches_thread_stack(_from, _to, t)) {\n+      _found = true;\n+      _tid = t->osthread()->thread_id();\n+      \/\/ lemme stooop! No way to signal stop :(\n+    }\n+  }\n+};\n+\n+static void print_thread_details(uintx thread_id, const char* name, outputStream* st) {\n+  st->print(\"(\" UINTX_FORMAT \" \\\"%s\\\")\", (uintx)thread_id, name);\n+}\n+\n+\/\/ Given a region [from, to), if it intersects a known thread stack, print detail infos about that thread.\n+static void print_thread_details_for_supposed_stack_address(const void* from, const void* to, outputStream* st) {\n+\n+#define HANDLE_THREAD(T)                                                        \\\n+  if (T != nullptr && vma_touches_thread_stack(from, to, T)) {                  \\\n+    print_thread_details((uintx)(T->osthread()->thread_id()), T->name(), st);   \\\n+    return;                                                                     \\\n+  }\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread* t = jtiwh.next(); ) {\n+    HANDLE_THREAD(t);\n+  }\n+  HANDLE_THREAD(VMThread::vm_thread());\n+  HANDLE_THREAD(WatcherThread::watcher_thread());\n+  HANDLE_THREAD(AsyncLogWriter::instance());\n+#undef HANDLE_THREAD\n+\n+  if (Universe::heap() != nullptr) {\n+    GCThreadClosure cl(from, to);\n+    Universe::heap()->gc_threads_do(&cl);\n+    if (cl._found) {\n+      print_thread_details(cl._tid, \"GC Thread\", st);\n+    }\n+  }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+static void print_legend(outputStream* st) {\n+#define DO(flag, shortname, text) st->print_cr(\"%10s    %s\", shortname, text);\n+  NMT_FLAGS_DO(DO)\n+#undef DO\n+}\n+\n+MappingPrintClosure::MappingPrintClosure(outputStream* st, bool human_readable, const CachedNMTInformation& nmt_info) :\n+    _out(st), _human_readable(human_readable),\n+    _total_count(0), _total_vsize(0), _nmt_info(nmt_info)\n+{}\n+\n+void MappingPrintClosure::do_it(const MappingPrintInformation* info) {\n+\n+  _total_count++;\n+\n+  const void* const vma_from = info->from();\n+  const void* const vma_to = info->to();\n+\n+  \/\/ print from, to\n+  _out->print(PTR_FORMAT \" - \" PTR_FORMAT \" \", p2i(vma_from), p2i(vma_to));\n+  const size_t size = pointer_delta(vma_to, vma_from, 1);\n+  _total_vsize += size;\n+\n+  \/\/ print mapping size\n+  if (_human_readable) {\n+    _out->print(PROPERFMT \" \", PROPERFMTARGS(size));\n+  } else {\n+    _out->print(\"%11zu\", size);\n+  }\n+\n+  assert(info->from() <= info->to(), \"Invalid VMA\");\n+  _out->fill_to(53);\n+  info->print_OS_specific_details(_out);\n+  _out->fill_to(70);\n+\n+  \/\/ print NMT information, if available\n+  if (MemTracker::enabled()) {\n+    \/\/ Correlate vma region (from, to) with NMT region(s) we collected previously.\n+    const MemFlagBitmap flags = _nmt_info.lookup(vma_from, vma_to);\n+    if (flags.has_any()) {\n+      for (int i = 0; i < mt_number_of_types; i++) {\n+        const MEMFLAGS flag = (MEMFLAGS)i;\n+        if (flags.has_flag(flag)) {\n+          _out->print(\"%s\", get_shortname_for_nmt_flag(flag));\n+          if (flag == mtThreadStack) {\n+            print_thread_details_for_supposed_stack_address(vma_from, vma_to, _out);\n+          }\n+          _out->print(\" \");\n+        }\n+      }\n+    }\n+  }\n+\n+  \/\/ print file name, if available\n+  const char* f = info->filename();\n+  if (f != nullptr) {\n+    _out->print_raw(f);\n+  }\n+  _out->cr();\n+}\n+\n+void MemMapPrinter::print_header(outputStream* st) {\n+  st->print(\n+#ifdef _LP64\n+  \/\/   0x0000000000000000 - 0x0000000000000000\n+      \"from                 to                 \"\n+#else\n+  \/\/   0x00000000 - 0x00000000\n+      \"from         to         \"\n+#endif\n+  );\n+  \/\/ Print platform-specific columns\n+  pd_print_header(st);\n+}\n+\n+void MemMapPrinter::print_all_mappings(outputStream* st, bool human_readable) {\n+  \/\/ First collect all NMT information\n+  CachedNMTInformation nmt_info;\n+  nmt_info.fill_from_nmt();\n+\n+  st->print_cr(\"Memory mappings:\");\n+  if (!MemTracker::enabled()) {\n+    st->cr();\n+    st->print_cr(\" (NMT is disabled, will not annotate mappings).\");\n+  }\n+  st->cr();\n+\n+  print_legend(st);\n+  st->print_cr(\"(*) - Mapping contains data from multiple regions\");\n+  st->cr();\n+\n+  pd_print_header(st);\n+  MappingPrintClosure closure(st, human_readable, nmt_info);\n+  pd_iterate_all_mappings(closure);\n+  st->print_cr(\"Total: \" UINTX_FORMAT \" mappings with a total vsize of %zu (\" PROPERFMT \")\",\n+               closure.total_count(), closure.total_vsize(), PROPERFMTARGS(closure.total_vsize()));\n+}\n+\n+#endif \/\/ LINUX\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.cpp","additions":309,"deletions":0,"binary":false,"changes":309,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_MEMMAPPRINTER_HPP\n+#define SHARE_SERVICES_MEMMAPPRINTER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#ifdef LINUX\n+\n+class outputStream;\n+class CachedNMTInformation;\n+\n+class MappingPrintInformation {\n+  const void* const _from;\n+  const void* const _to;\n+public:\n+  MappingPrintInformation(const void* from, const void* to) : _from(from), _to(to) {}\n+  const void* from() const { return _from; }\n+  const void* to() const { return _to; }\n+  \/\/ Will be called for each mapping before VM annotations are printed.\n+  virtual void print_OS_specific_details(outputStream* st) const {}\n+  \/\/ If mapping is backed by a file, the name of that file\n+  virtual const char* filename() const { return nullptr; }\n+};\n+\n+class MappingPrintClosure {\n+  outputStream* const _out;\n+  const bool _human_readable;\n+  uintx _total_count;\n+  size_t _total_vsize;\n+  const CachedNMTInformation& _nmt_info;\n+public:\n+  MappingPrintClosure(outputStream* st, bool human_readable, const CachedNMTInformation& nmt_info);\n+  void do_it(const MappingPrintInformation* info); \/\/ returns false if timeout reached.\n+  uintx total_count() const { return _total_count; }\n+  size_t total_vsize() const { return _total_vsize; }\n+};\n+\n+class MemMapPrinter : public AllStatic {\n+  static void pd_print_header(outputStream* st);\n+  static void print_header(outputStream* st);\n+  static void pd_iterate_all_mappings(MappingPrintClosure& closure);\n+public:\n+  static void mark_page_malloced(const void* p, MEMFLAGS f);\n+  static void print_all_mappings(outputStream* st, bool human_readable);\n+};\n+\n+#endif \/\/ LINUX\n+\n+#endif \/\/ SHARE_SERVICES_MEMMAPPRINTER_HPP\n","filename":"src\/hotspot\/share\/nmt\/memMapPrinter.hpp","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"nmt\/memMapPrinter.hpp\"\n@@ -60,0 +61,1 @@\n+#include \"services\/memTracker.hpp\"\n@@ -67,0 +69,1 @@\n+#include \"os_posix.hpp\"\n@@ -69,0 +72,1 @@\n+#include <errno.h>\n@@ -133,0 +137,2 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<SystemMapDCmd>(full_export, true,false));\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<SystemDumpMapDCmd>(full_export, true,false));\n@@ -1119,0 +1125,42 @@\n+\n+#ifdef LINUX\n+\n+SystemMapDCmd::SystemMapDCmd(outputStream* output, bool heap) :\n+    DCmdWithParser(output, heap),\n+  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\") {\n+  _dcmdparser.add_dcmd_option(&_human_readable);\n+}\n+\n+void SystemMapDCmd::execute(DCmdSource source, TRAPS) {\n+  MemMapPrinter::print_all_mappings(output(), _human_readable.value());\n+}\n+\n+SystemDumpMapDCmd::SystemDumpMapDCmd(outputStream* output, bool heap) :\n+    DCmdWithParser(output, heap),\n+  _human_readable(\"-H\", \"Human readable format\", \"BOOLEAN\", false, \"false\"),\n+  _filename(\"-F\", \"file path (defaults: \\\"vm_memory_map_<pid>.txt\\\")\", \"STRING\", false) {\n+  _dcmdparser.add_dcmd_option(&_human_readable);\n+  _dcmdparser.add_dcmd_option(&_filename);\n+}\n+\n+void SystemDumpMapDCmd::execute(DCmdSource source, TRAPS) {\n+  stringStream default_name;\n+  default_name.print(\"vm_memory_map_%d.txt\", os::current_process_id());\n+  const char* name = _filename.is_set() ? _filename.value() : default_name.base();\n+  fileStream fs(name);\n+  if (fs.is_open()) {\n+    if (!MemTracker::enabled()) {\n+      output()->print_cr(\"(NMT is disabled, will not annotate mappings).\");\n+    }\n+    MemMapPrinter::print_all_mappings(&fs, _human_readable.value());\n+    \/\/ For the readers convenience, resolve path name.\n+    char tmp[JVM_MAXPATHLEN];\n+    const char* absname = os::Posix::realpath(name, tmp, sizeof(tmp));\n+    name = absname != nullptr ? absname : name;\n+    output()->print_cr(\"Memory map dumped to \\\"%s\\\".\", name);\n+  } else {\n+    output()->print_cr(\"Failed to open \\\"%s\\\" for writing (%s).\", name, os::strerror(errno));\n+  }\n+}\n+\n+#endif \/\/ LINUX\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -956,0 +956,41 @@\n+#ifdef LINUX\n+\n+class SystemMapDCmd : public DCmdWithParser {\n+  DCmdArgument<bool> _human_readable;\n+public:\n+  static int num_arguments() { return 1; }\n+  SystemMapDCmd(outputStream* output, bool heap);\n+  static const char* name() { return \"System.map\"; }\n+  static const char* description() {\n+    return \"Prints an annotated process memory map of the VM process (linux only).\";\n+  }\n+  static const char* impact() { return \"Low\"; }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"control\", nullptr};\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n+class SystemDumpMapDCmd : public DCmdWithParser {\n+  DCmdArgument<bool> _human_readable;\n+  DCmdArgument<char*> _filename;\n+public:\n+  static int num_arguments() { return 2; }\n+  SystemDumpMapDCmd(outputStream* output, bool heap);\n+  static const char* name() { return \"System.dump_map\"; }\n+  static const char* description() {\n+    return \"Dumps an annotated process memory map to an output file (linux only).\";\n+  }\n+  static const char* impact() { return \"Low\"; }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"control\", nullptr};\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n+#endif \/\/ LINUX\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import jdk.test.lib.dcmd.CommandExecutor;\n+import jdk.test.lib.dcmd.JMXExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.regex.Pattern;\n+\n+\/*\n+ * @test\n+ * @summary Test of diagnostic command System.map\n+ * @library \/test\/lib\n+ * @requires (os.family==\"linux\")\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.compiler\n+ *          java.management\n+ *          jdk.internal.jvmstat\/sun.jvmstat.monitor\n+ * @run testng SystemDumpMapTest\n+ *\/\n+public class SystemDumpMapTest {\n+\n+    private void run_test(CommandExecutor executor, boolean useDefaultFileName) {\n+\n+        String filenameOption = useDefaultFileName ? \"\" : \"-F=test-map.txt\";\n+\n+        OutputAnalyzer output = executor.execute(\"System.dump_map \" + filenameOption);\n+        output.reportDiagnosticSummary();\n+\n+        String filename = useDefaultFileName ?\n+            output.firstMatch(\"Memory map dumped to \\\"(\\\\S*vm_memory_map_\\\\d+\\\\.txt)\\\".*\", 1) :\n+            output.firstMatch(\"Memory map dumped to \\\"(\\\\S*test-map.txt)\\\".*\", 1);\n+\n+        if (filename == null) {\n+            throw new RuntimeException(\"Did not find dump file in output.\\n\");\n+        }\n+\n+        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {\n+            boolean NMTOff = output.getOutput().contains(\"NMT is disabled\");\n+            String regexBase = \".*0x\\\\p{XDigit}+ - 0x\\\\p{XDigit}+ +\\\\d+\";\n+            HashSet<Pattern> patterns = new HashSet<>();\n+            patterns.add(Pattern.compile(regexBase + \".*jvm.*\"));\n+            if (!NMTOff) { \/\/ expect VM annotations if NMT is on\n+                patterns.add(Pattern.compile(regexBase + \".*JAVAHEAP.*\"));\n+                patterns.add(Pattern.compile(regexBase + \".*META.*\"));\n+                patterns.add(Pattern.compile(regexBase + \".*CODE.*\"));\n+                patterns.add(Pattern.compile(regexBase + \".*STACK.*main.*\"));\n+            }\n+            do {\n+                String line = reader.readLine();\n+                if (line != null) {\n+                    for (Pattern pat : patterns) {\n+                        if (pat.matcher(line).matches()) {\n+                            patterns.remove(pat);\n+                            break;\n+                        }\n+                    }\n+                } else {\n+                    break;\n+                }\n+            } while (patterns.size() > 0);\n+\n+            if (patterns.size() > 0) {\n+                System.out.println(\"Missing patterns in dump:\");\n+                for (Pattern pat : patterns) {\n+                    System.out.println(pat);\n+                }\n+                throw new RuntimeException(\"Missing patterns\");\n+            }\n+\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+    }\n+\n+    public void run(CommandExecutor executor) {\n+        run_test(executor, false);\n+        run_test(executor, true);\n+    }\n+\n+    @Test\n+    public void jmx() {\n+        run(new JMXExecutor());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemDumpMapTest.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Red Hat, Inc. and\/or its affiliates.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import jdk.test.lib.dcmd.CommandExecutor;\n+import jdk.test.lib.dcmd.JMXExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.io.*;\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashSet;\n+import java.util.regex.Pattern;\n+\n+\/*\n+ * @test\n+ * @summary Test of diagnostic command System.map\n+ * @library \/test\/lib\n+ * @requires (os.family==\"linux\")\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.compiler\n+ *          java.management\n+ *          jdk.internal.jvmstat\/sun.jvmstat.monitor\n+ * @run testng SystemMapTest\n+ *\/\n+public class SystemMapTest {\n+    public void run(CommandExecutor executor) {\n+        OutputAnalyzer output = executor.execute(\"System.map\");\n+        output.reportDiagnosticSummary();\n+        boolean NMTOff = output.getOutput().contains(\"NMT is disabled\");\n+\n+        String regexBase = \".*0x\\\\p{XDigit}+ - 0x\\\\p{XDigit}+ +\\\\d+\";\n+        output.shouldMatch(regexBase + \".*jvm.*\");\n+        if (!NMTOff) { \/\/ expect VM annotations if NMT is on\n+            output.shouldMatch(regexBase + \".*JAVAHEAP.*\");\n+            output.shouldMatch(regexBase + \".*META.*\");\n+            output.shouldMatch(regexBase + \".*CODE.*\");\n+            output.shouldMatch(regexBase + \".*STACK.*main.*\");\n+        }\n+    }\n+\n+    @Test\n+    public void jmx() {\n+        run(new JMXExecutor());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SystemMapTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"}]}