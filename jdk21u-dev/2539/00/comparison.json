{"files":[{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1049,1 +1049,1 @@\n-      os::print_hex_dump(&lsh, base, top, unitsize, 32, requested_base);\n+      os::print_hex_dump(&lsh, base, top, unitsize, \/* print_ascii=*\/true, \/* bytes_per_line=*\/32, requested_base);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -933,3 +933,4 @@\n-ATTRIBUTE_NO_ASAN static bool read_safely_from(intptr_t* p, intptr_t* result) {\n-  const intptr_t errval = 0x1717;\n-  intptr_t i = SafeFetchN(p, errval);\n+ATTRIBUTE_NO_ASAN static bool read_safely_from(const uintptr_t* p, uintptr_t* result) {\n+  DEBUG_ONLY(*result = 0xAAAA;)\n+  const uintptr_t errval = 0x1717;\n+  uintptr_t i = (uintptr_t)SafeFetchN((intptr_t*)p, errval);\n@@ -937,1 +938,1 @@\n-    i = SafeFetchN(p, ~errval);\n+    i = (uintptr_t)SafeFetchN((intptr_t*)p, ~errval);\n@@ -942,1 +943,1 @@\n-  (*result) = i;\n+  (*result) = (uintptr_t)i;\n@@ -946,1 +947,15 @@\n-static void print_hex_location(outputStream* st, address p, int unitsize) {\n+\/\/ Helper for os::print_hex_dump\n+static void print_ascii_form(stringStream& ascii_form, uint64_t value, int unitsize) {\n+  union {\n+    uint64_t v;\n+    uint8_t c[sizeof(v)];\n+  } u = { value };\n+  for (int i = 0; i < unitsize; i++) {\n+    const int idx = LITTLE_ENDIAN_ONLY(i) BIG_ENDIAN_ONLY(sizeof(u.v) - unitsize + i);\n+    const uint8_t c = u.c[idx];\n+    ascii_form.put(isprint(c) && isascii(c) ? c : '.');\n+  }\n+}\n+\n+\/\/ Helper for os::print_hex_dump\n+static void print_hex_location(outputStream* st, const_address p, int unitsize, stringStream& ascii_form) {\n@@ -948,1 +963,1 @@\n-  address pa = align_down(p, sizeof(intptr_t));\n+  const uintptr_t* pa = (const uintptr_t*) align_down(p, sizeof(intptr_t));\n@@ -952,3 +967,3 @@\n-    intptr_t i1, i2;\n-    if (read_safely_from((intptr_t*)pa, &i1) &&\n-        read_safely_from((intptr_t*)pa + 1, &i2)) {\n+    uintptr_t i1 = 0, i2 = 0;\n+    if (read_safely_from(pa, &i1) &&\n+        read_safely_from(pa + 1, &i2)) {\n@@ -959,0 +974,1 @@\n+      print_ascii_form(ascii_form, value, unitsize);\n@@ -965,2 +981,2 @@\n-  intptr_t i = 0;\n-  if (read_safely_from((intptr_t*)pa, &i)) {\n+  uintptr_t i = 0;\n+  if (read_safely_from(pa, &i)) {\n@@ -971,1 +987,1 @@\n-    const int offset = (int)(p - (address)pa);\n+    const int offset = (int)(p - (const_address)pa);\n@@ -976,1 +992,1 @@\n-    intptr_t value = bitfield(i, bitoffset, bitfieldsize);\n+    uintptr_t value = bitfield(i, bitoffset, bitfieldsize);\n@@ -983,0 +999,1 @@\n+    print_ascii_form(ascii_form, value, unitsize);\n@@ -993,2 +1010,3 @@\n-void os::print_hex_dump(outputStream* st, address start, address end, int unitsize,\n-                        int bytes_per_line, address logical_start) {\n+void os::print_hex_dump(outputStream* st, const_address start, const_address end, int unitsize,\n+                        bool print_ascii, int bytes_per_line, const_address logical_start) {\n+  constexpr int max_bytes_per_line = 64;\n@@ -996,0 +1014,2 @@\n+  assert(bytes_per_line > 0 && bytes_per_line <= max_bytes_per_line &&\n+         is_power_of_2(bytes_per_line), \"invalid bytes_per_line\");\n@@ -1002,1 +1022,1 @@\n-  int cols_per_line = bytes_per_line \/ unitsize;\n+  const int cols_per_line = bytes_per_line \/ unitsize;\n@@ -1004,2 +1024,4 @@\n-  address p = start;\n-  address logical_p = logical_start;\n+  const_address p = start;\n+  const_address logical_p = logical_start;\n+\n+  stringStream ascii_form;\n@@ -1008,1 +1030,0 @@\n-  st->print(PTR_FORMAT \":   \", p2i(logical_p));\n@@ -1010,1 +1031,4 @@\n-    print_hex_location(st, p, unitsize);\n+    if (cols == 0) {\n+      st->print(PTR_FORMAT \":   \", p2i(logical_p));\n+    }\n+    print_hex_location(st, p, unitsize, ascii_form);\n@@ -1014,2 +1038,5 @@\n-    if (cols >= cols_per_line && p < end) {\n-       cols = 0;\n+    if (cols >= cols_per_line) {\n+       if (print_ascii && !ascii_form.is_empty()) {\n+         st->print(\"   %s\", ascii_form.base());\n+       }\n+       ascii_form.reset();\n@@ -1017,1 +1044,1 @@\n-       st->print(PTR_FORMAT \":   \", p2i(logical_p));\n+       cols = 0;\n@@ -1022,1 +1049,11 @@\n-  st->cr();\n+\n+  if (cols > 0) { \/\/ did not print a full line\n+    if (print_ascii) {\n+      \/\/ indent last ascii part to match that of full lines\n+      const int size_of_printed_unit = unitsize * 2;\n+      const int space_left = (cols_per_line - cols) * (size_of_printed_unit + 1);\n+      st->sp(space_left);\n+      st->print(\"  %s\", ascii_form.base());\n+    }\n+    st->cr();\n+  }\n@@ -1060,1 +1097,1 @@\n-  print_hex_dump(st, pc - 256, pc + 256, unitsize);\n+  print_hex_dump(st, pc - 256, pc + 256, unitsize, \/* print_ascii=*\/false);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":63,"deletions":26,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -845,4 +845,4 @@\n-  static void print_hex_dump(outputStream* st, address start, address end, int unitsize,\n-                             int bytes_per_line, address logical_start);\n-  static void print_hex_dump(outputStream* st, address start, address end, int unitsize) {\n-    print_hex_dump(st, start, end, unitsize, \/*bytes_per_line=*\/16, \/*logical_start=*\/start);\n+  static void print_hex_dump(outputStream* st, const_address start, const_address end, int unitsize, bool print_ascii,\n+                             int bytes_per_line, const_address logical_start);\n+  static void print_hex_dump(outputStream* st, const_address start, const_address end, int unitsize, bool print_ascii = true) {\n+    print_hex_dump(st, start, end, unitsize, print_ascii, \/*bytes_per_line=*\/16, \/*logical_start=*\/start);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -476,0 +476,2 @@\n+typedef const u_char* const_address;\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -229,0 +229,1 @@\n+  bool is_empty() const { return _buffer[0] == '\\0'; }\n","filename":"src\/hotspot\/share\/utilities\/ostream.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -169,2 +169,6 @@\n-static void do_test_print_hex_dump(address addr, size_t len, int unitsize, const char* expected) {\n-  char buf[256];\n+#ifndef AIX\n+\/\/ Test relies on the ability to protect memory allocated with os::reserve_memory. AIX may not be able\n+\/\/ to do that (mprotect won't work on System V shm).\n+static void do_test_print_hex_dump(const_address from, const_address to, int unitsize, int bytes_per_line,\n+                                   const_address logical_start, const char* expected) {\n+  char buf[2048];\n@@ -173,4 +177,2 @@\n-  os::print_hex_dump(&ss, addr, addr + len, unitsize);\n-  \/\/ tty->print_cr(\"expected: %s\", expected);\n-  \/\/ tty->print_cr(\"result: %s\", buf);\n-  EXPECT_THAT(buf, HasSubstr(expected));\n+  os::print_hex_dump(&ss, from, to, unitsize, \/* print_ascii=*\/true, bytes_per_line, logical_start);\n+  EXPECT_STREQ(buf, expected);\n@@ -180,6 +182,5 @@\n-  const char* pattern [4] = {\n-#ifdef VM_LITTLE_ENDIAN\n-    \"00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\",\n-    \"0100 0302 0504 0706 0908 0b0a 0d0c 0f0e\",\n-    \"03020100 07060504 0b0a0908 0f0e0d0c\",\n-    \"0706050403020100 0f0e0d0c0b0a0908\"\n+\n+#ifdef _LP64\n+#define ADDRESS1 \"0x0000aaaaaaaaaa00\"\n+#define ADDRESS2 \"0x0000aaaaaaaaaa20\"\n+#define ADDRESS3 \"0x0000aaaaaaaaaa40\"\n@@ -187,4 +188,3 @@\n-    \"00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f\",\n-    \"0001 0203 0405 0607 0809 0a0b 0c0d 0e0f\",\n-    \"00010203 04050607 08090a0b 0c0d0e0f\",\n-    \"0001020304050607 08090a0b0c0d0e0f\"\n+#define ADDRESS1 \"0xaaaaaa00\"\n+#define ADDRESS2 \"0xaaaaaa20\"\n+#define ADDRESS3 \"0xaaaaaa40\"\n@@ -192,1 +192,0 @@\n-  };\n@@ -194,6 +193,15 @@\n-  const char* pattern_not_readable [4] = {\n-    \"?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??\",\n-    \"???? ???? ???? ???? ???? ???? ???? ????\",\n-    \"???????? ???????? ???????? ????????\",\n-    \"???????????????? ????????????????\"\n-  };\n+#define ASCII_1  \"....#.jdk\/internal\/loader\/Native\"\n+#define ASCII_2  \"Libraries.......\"\n+\n+#define PAT_1 ADDRESS1 \":   ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??\\n\" \\\n+              ADDRESS2 \":   ff ff e0 dc 23 00 6a 64 6b 2f 69 6e 74 65 72 6e 61 6c 2f 6c 6f 61 64 65 72 2f 4e 61 74 69 76 65   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   4c 69 62 72 61 72 69 65 73 00 00 00 00 00 00 00                                                   \" ASCII_2 \"\\n\"\n+\n+#ifdef VM_LITTLE_ENDIAN\n+#define PAT_2 ADDRESS1 \":   ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ????\\n\" \\\n+              ADDRESS2 \":   ffff dce0 0023 646a 2f6b 6e69 6574 6e72 6c61 6c2f 616f 6564 2f72 614e 6974 6576   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   694c 7262 7261 6569 0073 0000 0000 0000                                           \" ASCII_2 \"\\n\"\n+\n+#define PAT_4 ADDRESS1 \":   ???????? ???????? ???????? ???????? ???????? ???????? ???????? ????????\\n\" \\\n+              ADDRESS2 \":   dce0ffff 646a0023 6e692f6b 6e726574 6c2f6c61 6564616f 614e2f72 65766974   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   7262694c 65697261 00000073 00000000                                       \" ASCII_2 \"\\n\"\n@@ -201,4 +209,3 @@\n-  \/\/ On AIX, zero page is readable.\n-  address unreadable =\n-#ifdef AIX\n-    (address) 0xFFFFFFFFFFFF0000ULL;\n+#define PAT_8 ADDRESS1 \":   ???????????????? ???????????????? ???????????????? ????????????????\\n\" \\\n+              ADDRESS2 \":   646a0023dce0ffff 6e7265746e692f6b 6564616f6c2f6c61 65766974614e2f72   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   656972617262694c 0000000000000073                                     \" ASCII_2 \"\\n\"\n@@ -206,3 +213,3 @@\n-    (address) 0\n-#endif\n-    ;\n+#define PAT_2 ADDRESS1 \":   ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ????\\n\" \\\n+              ADDRESS2 \":   ffff e0dc 2300 6a64 6b2f 696e 7465 726e 616c 2f6c 6f61 6465 722f 4e61 7469 7665   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   4c69 6272 6172 6965 7300 0000 0000 0000                                           \" ASCII_2 \"\\n\"\n@@ -210,14 +217,7 @@\n-  ResourceMark rm;\n-  char buf[64];\n-  stringStream ss(buf, sizeof(buf));\n-  outputStream* out = &ss;\n-\/\/  outputStream* out = tty; \/\/ enable for printout\n-\n-  \/\/ Test dumping unreadable memory\n-  \/\/ Exclude test for Windows for now, since it needs SEH handling to work which cannot be\n-  \/\/ guaranteed when we call directly into VM code. (see JDK-8220220)\n-#ifndef _WIN32\n-  do_test_print_hex_dump(unreadable, 100, 1, pattern_not_readable[0]);\n-  do_test_print_hex_dump(unreadable, 100, 2, pattern_not_readable[1]);\n-  do_test_print_hex_dump(unreadable, 100, 4, pattern_not_readable[2]);\n-  do_test_print_hex_dump(unreadable, 100, 8, pattern_not_readable[3]);\n+#define PAT_4 ADDRESS1 \":   ???????? ???????? ???????? ???????? ???????? ???????? ???????? ????????\\n\" \\\n+              ADDRESS2 \":   ffffe0dc 23006a64 6b2f696e 7465726e 616c2f6c 6f616465 722f4e61 74697665   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   4c696272 61726965 73000000 00000000                                       \" ASCII_2 \"\\n\"\n+\n+#define PAT_8 ADDRESS1 \":   ???????????????? ???????????????? ???????????????? ????????????????\\n\" \\\n+              ADDRESS2 \":   ffffe0dc23006a64 6b2f696e7465726e 616c2f6c6f616465 722f4e6174697665   \" ASCII_1 \"\\n\" \\\n+              ADDRESS3 \":   4c69627261726965 7300000000000000                                     \" ASCII_2 \"\\n\"\n@@ -226,5 +226,18 @@\n-  \/\/ Test dumping readable memory\n-  address arr = (address)os::malloc(100, mtInternal);\n-  for (int c = 0; c < 100; c++) {\n-    arr[c] = c;\n-  }\n+  constexpr uint8_t bytes[] = {\n+    0xff, 0xff, 0xe0, 0xdc, 0x23, 0x00, 0x6a, 0x64, 0x6b, 0x2f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e,\n+    0x61, 0x6c, 0x2f, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x72, 0x2f, 0x4e, 0x61, 0x74, 0x69, 0x76, 0x65,\n+    0x4c, 0x69, 0x62, 0x72, 0x61, 0x72, 0x69, 0x65, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n+  };\n+\n+  \/\/ two pages, first one protected.\n+  const size_t ps = os::vm_page_size();\n+  char* two_pages = os::reserve_memory(ps * 2, false, mtTest);\n+  os::commit_memory(two_pages, ps * 2, false);\n+  os::protect_memory(two_pages, ps, os::MEM_PROT_NONE, true);\n+\n+  memcpy(two_pages + ps, bytes, sizeof(bytes));\n+\n+  \/\/ print\n+  const const_address from = (const_address) two_pages + ps - 32;\n+  const const_address to = (const_address) from + 32 + sizeof(bytes);\n+  const const_address logical_start = (const_address) LP64_ONLY(0xAAAAAAAAAA00ULL) NOT_LP64(0xAAAAAA00ULL);\n@@ -232,5 +245,4 @@\n-  \/\/ properly aligned\n-  do_test_print_hex_dump(arr, 100, 1, pattern[0]);\n-  do_test_print_hex_dump(arr, 100, 2, pattern[1]);\n-  do_test_print_hex_dump(arr, 100, 4, pattern[2]);\n-  do_test_print_hex_dump(arr, 100, 8, pattern[3]);\n+  do_test_print_hex_dump(from, to, 1, 32, logical_start, PAT_1);\n+  do_test_print_hex_dump(from, to, 2, 32, logical_start, PAT_2);\n+  do_test_print_hex_dump(from, to, 4, 32, logical_start, PAT_4);\n+  do_test_print_hex_dump(from, to, 8, 32, logical_start, PAT_8);\n@@ -238,4 +250,4 @@\n-  \/\/ Not properly aligned. Should automatically down-align by unitsize\n-  do_test_print_hex_dump(arr + 1, 100, 2, pattern[1]);\n-  do_test_print_hex_dump(arr + 1, 100, 4, pattern[2]);\n-  do_test_print_hex_dump(arr + 1, 100, 8, pattern[3]);\n+  \/\/ unaligned printing, should align to next lower unitsize\n+  do_test_print_hex_dump(from + 1, to, 2, 32, logical_start, PAT_2);\n+  do_test_print_hex_dump(from + 1, to, 4, 32, logical_start, PAT_4);\n+  do_test_print_hex_dump(from + 1, to, 8, 32, logical_start, PAT_8);\n@@ -243,1 +255,1 @@\n-  os::free(arr);\n+  os::release_memory(two_pages, ps * 2);\n@@ -245,0 +257,1 @@\n+#endif \/\/ not AIX\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":72,"deletions":59,"binary":false,"changes":131,"status":"modified"}]}