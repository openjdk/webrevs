{"files":[{"patch":"@@ -127,4 +127,5 @@\n-  \/\/ Avoid crash during crash if pc broken.\n-  if (epc) {\n-    frame fr(sp, epc);\n-    return fr;\n+  if (epc == nullptr || !is_readable_pointer(epc)) {\n+    \/\/ Try to recover from calling into bad memory\n+    \/\/ Assume new frame has not been set up, the same as\n+    \/\/ compiled frame stack bang\n+    return fetch_compiled_frame_from_context(ucVoid);\n@@ -132,2 +133,1 @@\n-  frame fr(sp);\n-  return fr;\n+  return frame(sp, epc);\n@@ -453,23 +453,0 @@\n-void os::print_tos_pc(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n-\n-  const ucontext_t* uc = (const ucontext_t*)context;\n-\n-  address sp = (address)os::Aix::ucontext_get_sp(uc);\n-  print_tos(st, sp);\n-  st->cr();\n-\n-  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n-  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n-  \/\/ this at the end, and hope for the best.\n-  address pc = os::Posix::ucontext_get_pc(uc);\n-  print_instructions(st, pc);\n-  st->cr();\n-\n-  \/\/ Try to decode the instructions.\n-  st->print_cr(\"Decoded instructions: (pc=\" PTR_FORMAT \")\", pc);\n-  st->print(\"<TODO: PPC port - print_context>\");\n-  \/\/ TODO: PPC port Disassembler::decode(pc, 16, 16, st);\n-  st->cr();\n-}\n-\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":6,"deletions":29,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -163,0 +163,6 @@\n+  if (!is_readable_pointer(epc)) {\n+    \/\/ Try to recover from calling into bad memory\n+    \/\/ Assume new frame has not been set up, the same as\n+    \/\/ compiled frame stack bang\n+    return fetch_compiled_frame_from_context(ucVoid);\n+  }\n@@ -467,17 +473,0 @@\n-void os::print_tos_pc(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n-\n-  const ucontext_t* uc = (const ucontext_t*)context;\n-\n-  address sp = (address)os::Bsd::ucontext_get_sp(uc);\n-  print_tos(st, sp);\n-  st->cr();\n-\n-  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n-  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n-  \/\/ this at the end, and hope for the best.\n-  address pc = os::Posix::ucontext_get_pc(uc);\n-  print_instructions(st, pc);\n-  st->cr();\n-}\n-\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -337,0 +337,6 @@\n+  if (!is_readable_pointer(epc)) {\n+    \/\/ Try to recover from calling into bad memory\n+    \/\/ Assume new frame has not been set up, the same as\n+    \/\/ compiled frame stack bang\n+    return fetch_compiled_frame_from_context(ucVoid);\n+  }\n@@ -844,17 +850,0 @@\n-void os::print_tos_pc(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n-\n-  const ucontext_t* uc = (const ucontext_t*)context;\n-\n-  address sp = (address)os::Bsd::ucontext_get_sp(uc);\n-  print_tos(st, sp);\n-  st->cr();\n-\n-  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n-  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n-  \/\/ this at the end, and hope for the best.\n-  address pc = os::Posix::ucontext_get_pc(uc);\n-  print_instructions(st, pc);\n-  st->cr();\n-}\n-\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -252,4 +252,0 @@\n-void os::print_tos_pc(outputStream *st, const void *context) {\n-  ShouldNotCallThis();\n-}\n-\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/os_bsd_zero.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -360,17 +360,0 @@\n-void os::print_tos_pc(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n-\n-  const ucontext_t* uc = (const ucontext_t*)context;\n-\n-  address sp = (address)os::Linux::ucontext_get_sp(uc);\n-  print_tos(st, sp);\n-  st->cr();\n-\n-  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n-  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n-  \/\/ this at the end, and hope for the best.\n-  address pc = os::fetch_frame_from_context(uc).pc();\n-  print_instructions(st, pc);\n-  st->cr();\n-}\n-\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -192,0 +192,6 @@\n+  if (!is_readable_pointer(epc)) {\n+    \/\/ Try to recover from calling into bad memory\n+    \/\/ Assume new frame has not been set up, the same as\n+    \/\/ compiled frame stack bang\n+    return fetch_compiled_frame_from_context(ucVoid);\n+  }\n@@ -195,0 +201,12 @@\n+frame os::fetch_compiled_frame_from_context(const void* ucVoid) {\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  \/\/ In compiled code, the stack banging is performed before LR\n+  \/\/ has been saved in the frame.  LR is live, and SP and FP\n+  \/\/ belong to the caller.\n+  intptr_t* fp = os::Linux::ucontext_get_fp(uc);\n+  intptr_t* sp = os::Linux::ucontext_get_sp(uc);\n+  address pc = (address)(uc->uc_mcontext.arm_lr\n+                         - NativeInstruction::instruction_size);\n+  return frame(sp, fp, pc);\n+}\n+\n@@ -473,17 +491,0 @@\n-void os::print_tos_pc(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n-\n-  const ucontext_t* uc = (const ucontext_t*)context;\n-\n-  address sp = (address)os::Linux::ucontext_get_sp(uc);\n-  print_tos(st, sp);\n-  st->cr();\n-\n-  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n-  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n-  \/\/ this at the end, and hope for the best.\n-  address pc = os::Posix::ucontext_get_pc(uc);\n-  print_instructions(st, pc);\n-  st->cr();\n-}\n-\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -159,0 +159,6 @@\n+  if (!is_readable_pointer(epc)) {\n+    \/\/ Try to recover from calling into bad memory\n+    \/\/ Assume new frame has not been set up, the same as\n+    \/\/ compiled frame stack bang\n+    return fetch_compiled_frame_from_context(ucVoid);\n+  }\n@@ -467,17 +473,0 @@\n-void os::print_tos_pc(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n-\n-  const ucontext_t* uc = (const ucontext_t*)context;\n-\n-  address sp = (address)os::Linux::ucontext_get_sp(uc);\n-  print_tos(st, sp);\n-  st->cr();\n-\n-  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n-  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n-  \/\/ this at the end, and hope for the best.\n-  address pc = os::Posix::ucontext_get_pc(uc);\n-  print_instructions(st, pc);\n-  st->cr();\n-}\n-\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -357,17 +357,0 @@\n-void os::print_tos_pc(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n-\n-  const ucontext_t* uc = (const ucontext_t*)context;\n-\n-  address sp = (address)os::Linux::ucontext_get_sp(uc);\n-  print_tos(st, sp);\n-  st->cr();\n-\n-  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n-  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n-  \/\/ this at the end, and hope for the best.\n-  address pc = os::fetch_frame_from_context(uc).pc();\n-  print_instructions(st, pc);\n-  st->cr();\n-}\n-\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/os_linux_riscv.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -144,0 +144,6 @@\n+  if (!is_readable_pointer(epc)) {\n+    \/\/ Try to recover from calling into bad memory\n+    \/\/ Assume new frame has not been set up, the same as\n+    \/\/ compiled frame stack bang\n+    return fetch_compiled_frame_from_context(ucVoid);\n+  }\n@@ -446,17 +452,0 @@\n-void os::print_tos_pc(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n-\n-  const ucontext_t* uc = (const ucontext_t*)context;\n-\n-  address sp = (address)os::Linux::ucontext_get_sp(uc);\n-  print_tos(st, sp);\n-  st->cr();\n-\n-  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n-  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n-  \/\/ this at the end, and hope for the best.\n-  address pc = os::Posix::ucontext_get_pc(uc);\n-  print_instructions(st, pc);\n-  st->cr();\n-}\n-\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/os_linux_s390.cpp","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -561,17 +561,0 @@\n-void os::print_tos_pc(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n-\n-  const ucontext_t* uc = (const ucontext_t*)context;\n-\n-  address sp = (address)os::Linux::ucontext_get_sp(uc);\n-  print_tos(st, sp);\n-  st->cr();\n-\n-  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n-  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n-  \/\/ this at the end, and hope for the best.\n-  address pc = os::fetch_frame_from_context(uc).pc();\n-  print_instructions(st, pc);\n-  st->cr();\n-}\n-\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -401,15 +401,0 @@\n-void os::print_tos_pc(outputStream *st, const void* ucVoid) {\n-  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n-\n-  address sp = (address)os::Linux::ucontext_get_sp(uc);\n-  print_tos(st, sp);\n-  st->cr();\n-\n-  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n-  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n-  \/\/ this at the end, and hope for the best.\n-  address pc = os::Posix::ucontext_get_pc(uc);\n-  print_instructions(st, pc);\n-  st->cr();\n-}\n-\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -209,18 +209,0 @@\n-void os::print_tos_pc(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n-\n-  const CONTEXT* uc = (const CONTEXT*)context;\n-\n-  address sp = (address)uc->Sp;\n-  print_tos(st, sp);\n-  st->cr();\n-\n-  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n-  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n-  \/\/ this at the end, and hope for the best.\n-  address pc = (address)uc->Pc;\n-  st->print_cr(\"Instructions: (pc=\" PTR_FORMAT \")\", pc);\n-  print_hex_dump(st, pc - 32, pc + 32, sizeof(char));\n-  st->cr();\n-}\n-\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.cpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -454,17 +454,0 @@\n-void os::print_tos_pc(outputStream *st, const void *context) {\n-  if (context == nullptr) return;\n-\n-  const CONTEXT* uc = (const CONTEXT*)context;\n-\n-  address sp = (address)uc->REG_SP;\n-  print_tos(st, sp);\n-  st->cr();\n-\n-  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n-  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n-  \/\/ this at the end, and hope for the best.\n-  address pc = os::fetch_frame_from_context(uc).pc();\n-  print_instructions(st, pc);\n-  st->cr();\n-}\n-\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1032,0 +1032,20 @@\n+void os::print_tos_pc(outputStream* st, const void* context) {\n+  if (context == nullptr) return;\n+\n+  \/\/ First of all, carefully determine sp without inspecting memory near pc.\n+  \/\/ See comment below.\n+  intptr_t* sp = nullptr;\n+  fetch_frame_from_context(context, &sp, nullptr);\n+  print_tos(st, (address)sp);\n+  st->cr();\n+\n+  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n+  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n+  \/\/ this at the end, and hope for the best.\n+  \/\/ This version of fetch_frame_from_context finds the caller pc if the actual\n+  \/\/ one is bad.\n+  address pc = fetch_frame_from_context(context).pc();\n+  print_instructions(st, pc);\n+  st->cr();\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}