{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,4 +61,0 @@\n-    \/\/ this will be set to true only when the peer explicitly states (through a GOAWAY frame or\n-    \/\/ a relevant error code in reset frame) that the corresponding stream (id) wasn't processed\n-    private volatile boolean unprocessedByPeer;\n-\n@@ -271,9 +267,0 @@\n-\n-    final boolean isUnprocessedByPeer() {\n-        return this.unprocessedByPeer;\n-    }\n-\n-    \/\/ Marks the exchange as unprocessed by the peer\n-    final void markUnprocessedByPeer() {\n-        this.unprocessedByPeer = true;\n-    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ExchangeImpl.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-import java.util.concurrent.atomic.AtomicLong;\n@@ -400,1 +399,0 @@\n-    private final AtomicLong lastProcessedStreamInGoAway = new AtomicLong(-1);\n@@ -807,3 +805,1 @@\n-            \/\/ we send a GOAWAY frame only if the remote side hasn't already indicated\n-            \/\/ the intention to close the connection by previously sending a GOAWAY of its own\n-            if (connection.channel().isOpen() && !isMarked(closedState, HALF_CLOSED_REMOTE)) {\n+            if (connection.channel().isOpen()) {\n@@ -1361,40 +1357,7 @@\n-    private void handleGoAway(final GoAwayFrame frame) {\n-        final long lastProcessedStream = frame.getLastStream();\n-        assert lastProcessedStream >= 0 : \"unexpected last stream id: \"\n-                + lastProcessedStream + \" in GOAWAY frame\";\n-\n-        markHalfClosedRemote();\n-        setFinalStream(); \/\/ don't allow any new streams on this connection\n-        if (debug.on()) {\n-            debug.log(\"processing incoming GOAWAY with last processed stream id:%s in frame %s\",\n-                    lastProcessedStream, frame);\n-        }\n-        \/\/ see if this connection has previously received a GOAWAY from the peer and if yes\n-        \/\/ then check if this new last processed stream id is lesser than the previous\n-        \/\/ known last processed stream id. Only update the last processed stream id if the new\n-        \/\/ one is lesser than the previous one.\n-        long prevLastProcessed = lastProcessedStreamInGoAway.get();\n-        while (prevLastProcessed == -1 || lastProcessedStream < prevLastProcessed) {\n-            if (lastProcessedStreamInGoAway.compareAndSet(prevLastProcessed,\n-                    lastProcessedStream)) {\n-                break;\n-            }\n-            prevLastProcessed = lastProcessedStreamInGoAway.get();\n-        }\n-        handlePeerUnprocessedStreams(lastProcessedStreamInGoAway.get());\n-    }\n-\n-    private void handlePeerUnprocessedStreams(final long lastProcessedStream) {\n-        final AtomicInteger numClosed = new AtomicInteger(); \/\/ atomic merely to allow usage within lambda\n-        streams.forEach((id, exchange) -> {\n-            if (id > lastProcessedStream) {\n-                \/\/ any streams with an stream id higher than the last processed stream\n-                \/\/ can be retried (on a new connection). we close the exchange as unprocessed\n-                \/\/ to facilitate the retrying.\n-                client2.client().theExecutor().ensureExecutedAsync(exchange::closeAsUnprocessed);\n-                numClosed.incrementAndGet();\n-            }\n-        });\n-        if (debug.on()) {\n-            debug.log(numClosed.get() + \" stream(s), with id greater than \" + lastProcessedStream\n-                    + \", will be closed as unprocessed\");\n+    private void handleGoAway(GoAwayFrame frame)\n+        throws IOException\n+    {\n+        if (markHalfClosedLRemote()) {\n+            shutdown(new IOException(\n+                    connection.channel().getLocalAddress()\n+                            + \": GOAWAY received\"));\n@@ -1951,1 +1914,1 @@\n-    private boolean markHalfClosedRemote() {\n+    private boolean markHalfClosedLRemote() {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":9,"deletions":46,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-    static <T> CompletableFuture<T> registerPending(PendingRequest pending, CompletableFuture<T> res) {\n+    static void registerPending(PendingRequest pending) {\n@@ -288,1 +288,1 @@\n-        if (pending.cf.isDone()) return res;\n+        if (pending.cf.isDone()) return;\n@@ -295,2 +295,1 @@\n-        var ref = res.whenComplete((r,t) -> client.pendingRequests.remove(pending));\n-        pending.ref = ref;\n+        pending.ref = cf.whenComplete((r,t) -> client.pendingRequests.remove(pending));\n@@ -303,1 +302,0 @@\n-        return ref;\n@@ -936,1 +934,1 @@\n-            if (cf != null) {\n+            if (cf != null )\n@@ -938,1 +936,0 @@\n-            }\n@@ -1060,0 +1057,7 @@\n+            \/\/ makes sure that any dependent actions happen in the CF default\n+            \/\/ executor. This is only needed for sendAsync(...), when\n+            \/\/ exchangeExecutor is non-null.\n+            if (exchangeExecutor != null) {\n+                res = res.whenCompleteAsync((r, t) -> { \/* do nothing *\/}, ASYNC_POOL);\n+            }\n+\n@@ -1063,14 +1067,3 @@\n-            res = registerPending(pending, res);\n-\n-            if (exchangeExecutor != null) {\n-                \/\/ makes sure that any dependent actions happen in the CF default\n-                \/\/ executor. This is only needed for sendAsync(...), when\n-                \/\/ exchangeExecutor is non-null.\n-                return res.isDone() ? res\n-                        : res.whenCompleteAsync((r, t) -> { \/* do nothing *\/}, ASYNC_POOL);\n-            } else {\n-                \/\/ make a defensive copy that can be safely canceled\n-                \/\/ by the caller\n-                return res.isDone() ? res : res.copy();\n-            }\n-        } catch (Throwable t) {\n+            registerPending(pending);\n+            return res;\n+        } catch(Throwable t) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":14,"deletions":21,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,2 +93,2 @@\n-    volatile boolean retriedOnce;\n-    volatile HttpResponse<T> response;\n+    volatile boolean expiredOnce;\n+    volatile HttpResponse<T> response = null;\n@@ -282,1 +282,0 @@\n-        boolean firstCancel = false;\n@@ -285,1 +284,1 @@\n-                firstCancel = interrupted.compareAndSet(null,\n+                interrupted.compareAndSet(null,\n@@ -288,7 +287,0 @@\n-            if (debug.on()) {\n-                if (firstCancel) {\n-                    debug.log(\"multi exchange recording: \" + interrupted.get());\n-                } else {\n-                    debug.log(\"multi exchange recorded: \" + interrupted.get());\n-                }\n-            }\n@@ -376,16 +368,0 @@\n-    \/\/ returns a CancellationExcpetion that wraps the given cause\n-    \/\/ if cancel(boolean) was called, the given cause otherwise\n-    private Throwable wrapIfCancelled(Throwable cause) {\n-        CancellationException interrupt = interrupted.get();\n-        if (interrupt == null) return cause;\n-\n-        var cancel = new CancellationException(interrupt.getMessage());\n-        \/\/ preserve the stack trace of the original exception to\n-        \/\/ show where the call to cancel(boolean) came from\n-        cancel.setStackTrace(interrupt.getStackTrace());\n-        cancel.initCause(Utils.getCancelCause(cause));\n-        return cancel;\n-    }\n-\n-    \/\/ if the request failed because the multi exchange was cancelled,\n-    \/\/ make sure the reported exception is wrapped in CancellationException\n@@ -393,2 +369,5 @@\n-        var x = wrapIfCancelled(t);\n-        if (x instanceof CancellationException) {\n+        CancellationException x = interrupted.get();\n+        if (x != null) {\n+            \/\/ make sure to fail with CancellationException if cancel(true)\n+            \/\/ was called.\n+            t = x.initCause(Utils.getCancelCause(t));\n@@ -396,1 +375,1 @@\n-                debug.log(\"MultiExchange interrupted with: \" + x.getCause());\n+                debug.log(\"MultiExchange interrupted with: \" + t.getCause());\n@@ -399,1 +378,1 @@\n-        return MinimalFuture.failedFuture(x);\n+        return MinimalFuture.failedFuture(t);\n@@ -462,1 +441,1 @@\n-                                retriedOnce = false;\n+                                expiredOnce = false;\n@@ -475,1 +454,1 @@\n-                        CompletableFuture<Response> errorCF = getExceptionalCF(ex, exch.exchImpl);\n+                        CompletableFuture<Response> errorCF = getExceptionalCF(ex);\n@@ -547,1 +526,1 @@\n-    private CompletableFuture<Response> getExceptionalCF(Throwable t, ExchangeImpl<?> exchImpl) {\n+    private CompletableFuture<Response> getExceptionalCF(Throwable t) {\n@@ -553,1 +532,0 @@\n-        final boolean retryAsUnprocessed = exchImpl != null && exchImpl.isUnprocessedByPeer();\n@@ -558,1 +536,1 @@\n-        } else if (retryAsUnprocessed || retryOnFailure(t)) {\n+        } else if (retryOnFailure(t)) {\n@@ -565,4 +543,2 @@\n-                if (!retryAsUnprocessed && !canRetryRequest(currentreq)) {\n-                    \/\/ a (peer) processed request which cannot be retried, fail with\n-                    \/\/ the original cause\n-                    return failedFuture(cause);\n+                if (!canRetryRequest(currentreq)) {\n+                    return failedFuture(cause); \/\/ fails with original cause\n@@ -574,1 +550,1 @@\n-            if (!retriedOnce) {\n+            if (!expiredOnce) {\n@@ -576,3 +552,2 @@\n-                    debug.log(t.getClass().getSimpleName()\n-                            + \" (async): retrying \" + currentreq + \" due to: \", t);\n-                retriedOnce = true;\n+                    debug.log(t.getClass().getSimpleName() + \" (async): retrying...\", t);\n+                expiredOnce = true;\n@@ -589,1 +564,1 @@\n-                            + \" (async): already retried once \" + currentreq, t);\n+                            + \" (async): already retried once.\", t);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/MultiExchange.java","additions":21,"deletions":46,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -676,24 +676,6 @@\n-                final int error = frame.getErrorCode();\n-                \/\/ A REFUSED_STREAM error code implies that the stream wasn't processed by the\n-                \/\/ peer and the client is free to retry the request afresh.\n-                if (error == ErrorFrame.REFUSED_STREAM) {\n-                    \/\/ Here we arrange for the request to be retried. Note that we don't call\n-                    \/\/ closeAsUnprocessed() method here because the \"closed\" state is already set\n-                    \/\/ to true a few lines above and calling close() from within\n-                    \/\/ closeAsUnprocessed() will end up being a no-op. We instead do the additional\n-                    \/\/ bookkeeping here.\n-                    markUnprocessedByPeer();\n-                    errorRef.compareAndSet(null, new IOException(\"request not processed by peer\"));\n-                    if (debug.on()) {\n-                        debug.log(\"request unprocessed by peer (REFUSED_STREAM) \" + this.request);\n-                    }\n-                } else {\n-                    final String reason = ErrorFrame.stringForCode(error);\n-                    final IOException failureCause = new IOException(\"Received RST_STREAM: \" + reason);\n-                    if (debug.on()) {\n-                        debug.log(streamid + \" received RST_STREAM with code: \" + reason);\n-                    }\n-                    if (errorRef.compareAndSet(null, failureCause)) {\n-                        if (subscriber != null) {\n-                            subscriber.onError(failureCause);\n-                        }\n+                int error = frame.getErrorCode();\n+                IOException e = new IOException(\"Received RST_STREAM: \"\n+                        + ErrorFrame.stringForCode(error));\n+                if (errorRef.compareAndSet(null, e)) {\n+                    if (subscriber != null) {\n+                        subscriber.onError(e);\n@@ -702,2 +684,1 @@\n-                final Throwable failureCause = errorRef.get();\n-                completeResponseExceptionally(failureCause);\n+                completeResponseExceptionally(e);\n@@ -705,1 +686,1 @@\n-                    requestBodyCF.completeExceptionally(failureCause); \/\/ we may be sending the body..\n+                    requestBodyCF.completeExceptionally(errorRef.get()); \/\/ we may be sending the body..\n@@ -708,1 +689,1 @@\n-                    responseBodyCF.completeExceptionally(failureCause);\n+                    responseBodyCF.completeExceptionally(errorRef.get());\n@@ -1721,29 +1702,1 @@\n-        final int id = streamid;\n-        final String sid = id == 0 ? \"?\" : String.valueOf(id);\n-        return connection.dbgString() + \"\/Stream(\" + sid + \")\";\n-    }\n-\n-    \/**\n-     * An unprocessed exchange is one that hasn't been processed by a peer. The local end of the\n-     * connection would be notified about such exchanges when it receives a GOAWAY frame with\n-     * a stream id that tells which exchanges have been unprocessed.\n-     * This method is called on such unprocessed exchanges and the implementation of this method\n-     * will arrange for the request, corresponding to this exchange, to be retried afresh on a\n-     * new connection.\n-     *\/\n-    void closeAsUnprocessed() {\n-        try {\n-            \/\/ We arrange for the request to be retried on a new connection as allowed by the RFC-9113\n-            markUnprocessedByPeer();\n-            this.errorRef.compareAndSet(null, new IOException(\"request not processed by peer\"));\n-            if (debug.on()) {\n-                debug.log(\"closing \" + this.request + \" as unprocessed by peer\");\n-            }\n-            \/\/ close the exchange and complete the response CF exceptionally\n-            close();\n-            completeResponseExceptionally(this.errorRef.get());\n-        } finally {\n-            \/\/ decrementStreamsCount isn't really needed but we do it to make sure\n-            \/\/ the log messages, where these counts\/states get reported, show the accurate state.\n-            connection.decrementStreamsCount(streamid);\n-        }\n+        return connection.dbgString() + \"\/Stream(\"+streamid+\")\";\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":10,"deletions":57,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,6 +103,1 @@\n-            \/\/ A client initiated stream might be closed (as unprocessed, due to a\n-            \/\/ GOAWAY received on the connection) even before the stream is\n-            \/\/ registered with this WindowController instance (when sending out request headers).\n-            \/\/ Thus, for client initiated streams, we don't enforce the presence of the\n-            \/\/ stream in the registered \"streams\" map.\n-\n+            \/\/ Odd stream numbers (client streams) should have been registered.\n@@ -112,1 +107,3 @@\n-            if (old != null && !isClientStream) {\n+            if (old == null && isClientStream) {\n+                throw new InternalError(\"Expected entry for streamid: \" + streamid);\n+            } else if (old != null && !isClientStream) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/WindowController.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,3 +60,1 @@\n-        return super.toString()\n-                + \" lastStreamId=\" + lastStream\n-                + \", Debugdata: \" + new String(debugData, UTF_8);\n+        return super.toString() + \" Debugdata: \" + new String(debugData, UTF_8);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/frame\/GoAwayFrame.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,391 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.net.ServerSocket;\n-import java.net.URI;\n-import java.net.http.HttpClient;\n-import java.net.http.HttpClient.Version;\n-import java.net.http.HttpRequest;\n-import java.net.http.HttpResponse;\n-import java.time.Duration;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Executor;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ForkJoinPool;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.atomic.AtomicLong;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-import jdk.internal.net.http.common.OperationTrackers.Tracker;\n-import jdk.test.lib.net.SimpleSSLContext;\n-import jdk.test.lib.net.URIBuilder;\n-import org.junit.jupiter.api.AfterAll;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-\/*\n- * @test\n- * @bug 8316580\n- * @library \/test\/lib\n- * @run junit\/othervm -Djdk.tracePinnedThreads=full\n- *                   -DuseReferenceTracker=false\n- *                   HttpGetInCancelledFuture\n- * @run junit\/othervm -Djdk.tracePinnedThreads=full\n- *                   -DuseReferenceTracker=true\n- *                   HttpGetInCancelledFuture\n- * @summary This test verifies that cancelling a future that\n- * does an HTTP request using the HttpClient doesn't cause\n- * HttpClient::close to block forever.\n- *\/\n-public class HttpGetInCancelledFuture {\n-\n-    static final boolean useTracker = Boolean.getBoolean(\"useReferenceTracker\");\n-\n-    static final class TestException extends RuntimeException {\n-        public TestException(String message, Throwable cause) {\n-            super(message, cause);\n-        }\n-    }\n-\n-    static ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n-\n-    HttpClient makeClient(URI uri, Version version, Executor executor) {\n-        var builder = HttpClient.newBuilder();\n-        if (uri.getScheme().equalsIgnoreCase(\"https\")) {\n-            try {\n-                builder.sslContext(new SimpleSSLContext().get());\n-            } catch (IOException io) {\n-                throw new UncheckedIOException(io);\n-            }\n-        }\n-        return builder.connectTimeout(Duration.ofSeconds(1))\n-                .executor(executor)\n-                .version(version)\n-                .build();\n-    }\n-\n-    record TestCase(String url, int reqCount, Version version) {}\n-    \/\/ A server that doesn't accept\n-    static volatile ServerSocket NOT_ACCEPTING;\n-\n-    static List<TestCase> parameters() {\n-        ServerSocket ss = NOT_ACCEPTING;\n-        if (ss == null) {\n-            synchronized (HttpGetInCancelledFuture.class) {\n-                if ((ss = NOT_ACCEPTING) == null) {\n-                    try {\n-                        ss = new ServerSocket();\n-                        var loopback = InetAddress.getLoopbackAddress();\n-                        ss.bind(new InetSocketAddress(loopback, 0), 10);\n-                        NOT_ACCEPTING = ss;\n-                    } catch (IOException io) {\n-                        throw new UncheckedIOException(io);\n-                    }\n-                }\n-            }\n-        }\n-        URI http = URIBuilder.newBuilder()\n-                .loopback()\n-                .scheme(\"http\")\n-                .port(ss.getLocalPort())\n-                .path(\"\/not-accepting\/\")\n-                .buildUnchecked();\n-        URI https = URIBuilder.newBuilder()\n-                .loopback()\n-                .scheme(\"https\")\n-                .port(ss.getLocalPort())\n-                .path(\"\/not-accepting\/\")\n-                .buildUnchecked();\n-        \/\/ use all HTTP versions, without and with TLS\n-        return List.of(\n-                new TestCase(http.toString(), 200, Version.HTTP_2),\n-                new TestCase(http.toString(), 200, Version.HTTP_1_1),\n-                new TestCase(https.toString(), 200, Version.HTTP_2),\n-                new TestCase(https.toString(), 200, Version.HTTP_1_1)\n-                );\n-    }\n-\n-    @ParameterizedTest\n-    @MethodSource(\"parameters\")\n-    void runTest(TestCase test) {\n-        System.out.println(\"Testing with: \" + test);\n-        runTest(test.url, test.reqCount, test.version);\n-    }\n-\n-    static class TestTaskScope implements AutoCloseable {\n-        final ExecutorService pool = new ForkJoinPool();\n-        final Map<Task<?>, Future<?>> tasks = new ConcurrentHashMap<>();\n-        final AtomicReference<ExecutionException> failed = new AtomicReference<>();\n-\n-        class Task<T> implements Callable<T> {\n-            final Callable<T> task;\n-            final CompletableFuture<T> cf = new CompletableFuture<>();\n-            Task(Callable<T> task) {\n-                this.task = task;\n-            }\n-            @Override\n-            public T call() throws Exception {\n-                try {\n-                    var res = task.call();\n-                    cf.complete(res);\n-                    return res;\n-                } catch (Throwable t) {\n-                    cf.completeExceptionally(t);\n-                    throw t;\n-                }\n-            }\n-            CompletableFuture<T> cf() {\n-                return cf;\n-            }\n-        }\n-\n-\n-        static class ShutdownOnFailure extends TestTaskScope {\n-            public ShutdownOnFailure() {}\n-\n-            @Override\n-            protected <T> void completed(Task<T> task, T result, Throwable throwable) {\n-                super.completed(task, result, throwable);\n-                if (throwable != null) {\n-                    if (failed.get() == null) {\n-                        ExecutionException ex = throwable instanceof ExecutionException x\n-                                ? x : new ExecutionException(throwable);\n-                        failed.compareAndSet(null, ex);\n-                    }\n-                    tasks.entrySet().forEach(this::cancel);\n-                }\n-            }\n-\n-            void cancel(Map.Entry<Task<?>, Future<?>> entry) {\n-                entry.getValue().cancel(true);\n-                entry.getKey().cf().cancel(true);\n-                tasks.remove(entry.getKey(), entry.getValue());\n-            }\n-\n-            @Override\n-            public <T> CompletableFuture<T> fork(Callable<T> callable) {\n-                var ex = failed.get();\n-                if (ex == null) {\n-                    return super.fork(callable);\n-                } \/\/ otherwise do nothing\n-                return CompletableFuture.failedFuture(new RejectedExecutionException());\n-            }\n-        }\n-\n-        public <T> CompletableFuture<T> fork(Callable<T> callable) {\n-            var task = new Task<>(callable);\n-            var res = pool.submit(task);\n-            tasks.put(task, res);\n-            task.cf.whenComplete((r,t) -> completed(task, r, t));\n-            return task.cf;\n-        }\n-\n-        protected <T> void completed(Task<T> task, T result, Throwable throwable) {\n-            tasks.remove(task);\n-        }\n-\n-        public void join() throws InterruptedException {\n-            try {\n-                var cfs = tasks.keySet().stream()\n-                        .map(Task::cf).toArray(CompletableFuture[]::new);\n-                CompletableFuture.allOf(cfs).get();\n-            } catch (InterruptedException it) {\n-                throw it;\n-            } catch (ExecutionException ex) {\n-                failed.compareAndSet(null, ex);\n-            }\n-        }\n-\n-        public void throwIfFailed() throws ExecutionException {\n-            ExecutionException x = failed.get();\n-            if (x != null) throw x;\n-        }\n-\n-        public void close() {\n-            pool.close();\n-        }\n-    }\n-\n-    ExecutorService testExecutor() {\n-        return Executors.newCachedThreadPool();\n-    }\n-\n-    void runTest(String url, int reqCount, Version version) {\n-        final var dest = URI.create(url);\n-        try (final var executor = testExecutor()) {\n-            var httpClient = makeClient(dest, version, executor);\n-            TRACKER.track(httpClient);\n-            Tracker tracker = TRACKER.getTracker(httpClient);\n-            Throwable failed = null;\n-            try {\n-                try (final var scope = new TestTaskScope.ShutdownOnFailure()) {\n-                    launchAndProcessRequests(scope, httpClient, reqCount, dest);\n-                } finally {\n-                    System.out.printf(\"StructuredTaskScope closed: STARTED=%s, SUCCESS=%s, INTERRUPT=%s, FAILED=%s%n\",\n-                            STARTED.get(), SUCCESS.get(), INTERRUPT.get(), FAILED.get());\n-                }\n-                System.out.println(\"ERROR: Expected TestException not thrown\");\n-                throw new AssertionError(\"Expected TestException not thrown\");\n-            } catch (TestException x) {\n-                System.out.println(\"Got expected exception: \" + x);\n-            } catch (Throwable t) {\n-                System.out.println(\"ERROR: Unexpected exception: \" + t);\n-                failed = t;\n-                throw t;\n-            } finally {\n-                \/\/ we can either use the tracker or call HttpClient::close\n-                if (useTracker) {\n-                    \/\/ using the tracker depends on GC but will give us some diagnostic\n-                    \/\/ if some operations are not properly cancelled and prevent the client\n-                    \/\/ from terminating\n-                    httpClient = null;\n-                    System.gc();\n-                    System.out.println(TRACKER.diagnose(tracker));\n-                    var error = TRACKER.check(tracker, 10000);\n-                    if (error != null) {\n-                        if (failed != null) error.addSuppressed(failed);\n-                        EXCEPTIONS.forEach(x -> {\n-                            System.out.println(\"FAILED: \" + x);\n-                        });\n-                        EXCEPTIONS.forEach(x -> {\n-                            x.printStackTrace(System.out);\n-                        });\n-                        throw error;\n-                    }\n-                } else {\n-                    \/\/ if not all operations terminate, close() will block\n-                    \/\/ forever and the test will fail in jtreg timeout.\n-                    \/\/ there will be no diagnostic.\n-                    httpClient.close();\n-                }\n-                System.out.println(\"HttpClient closed\");\n-            }\n-        } finally {\n-            System.out.println(\"ThreadExecutor closed\");\n-        }\n-        \/\/ not all tasks may have been started before the scope was cancelled\n-        \/\/ due to the first connect\/timeout exception, but all tasks that started\n-        \/\/ must have either succeeded, be interrupted, or failed\n-        assertTrue(STARTED.get() > 0);\n-        assertEquals(STARTED.get(), SUCCESS.get() + INTERRUPT.get() + FAILED.get());\n-        if (SUCCESS.get() > 0) {\n-            \/\/ we don't expect any server to be listening and responding\n-            System.out.println(\"WARNING: got some unexpected successful responses from \"\n-                    + \"\\\"\" + NOT_ACCEPTING.getLocalSocketAddress() + \"\\\": \" + SUCCESS.get());\n-        }\n-    }\n-\n-    private void launchAndProcessRequests(\n-            TestTaskScope.ShutdownOnFailure scope,\n-            HttpClient httpClient,\n-            int reqCount,\n-            URI dest) {\n-        for (int counter = 0; counter < reqCount; counter++) {\n-            scope.fork(() ->\n-                    getAndCheck(httpClient, dest)\n-            );\n-        }\n-        try {\n-            scope.join();\n-        } catch (InterruptedException e) {\n-            throw new AssertionError(\"scope.join() was interrupted\", e);\n-        }\n-        try {\n-            scope.throwIfFailed();\n-        } catch (ExecutionException e) {\n-            throw new TestException(\"something threw an exception in StructuredTaskScope\", e);\n-        }\n-    }\n-\n-    final static AtomicLong ID = new AtomicLong();\n-    final AtomicLong SUCCESS = new AtomicLong();\n-    final AtomicLong INTERRUPT = new AtomicLong();\n-    final AtomicLong FAILED = new AtomicLong();\n-    final AtomicLong STARTED = new AtomicLong();\n-    final CopyOnWriteArrayList<Exception> EXCEPTIONS = new CopyOnWriteArrayList<>();\n-    private String getAndCheck(HttpClient httpClient, URI url) {\n-        STARTED.incrementAndGet();\n-        final var response = sendRequest(httpClient, url);\n-        String res = response.body();\n-        int statusCode = response.statusCode();\n-        assertEquals(200, statusCode);\n-        return res;\n-    }\n-\n-    private HttpResponse<String> sendRequest(HttpClient httpClient, URI url) {\n-        var id = ID.incrementAndGet();\n-        try {\n-            var request = HttpRequest.newBuilder(url).GET().build();\n-            var response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n-            \/\/ System.out.println(\"Got response for \" + id + \": \" + response);\n-            SUCCESS.incrementAndGet();\n-            return response;\n-        } catch (InterruptedException e) {\n-            INTERRUPT.incrementAndGet();\n-            \/\/ System.out.println(\"Got interrupted for \" + id + \": \" + e);\n-            throw new RuntimeException(e);\n-        } catch (Exception e) {\n-            FAILED.incrementAndGet();\n-            EXCEPTIONS.add(e);\n-            \/\/System.out.println(\"Got exception for \" + id + \": \" + e);\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    @AfterAll\n-    static void tearDown() {\n-        try {\n-            System.gc();\n-            var error = TRACKER.check(5000);\n-            if (error != null) throw error;\n-        } finally {\n-            ServerSocket ss;\n-            synchronized (HttpGetInCancelledFuture.class) {\n-                ss = NOT_ACCEPTING;\n-                NOT_ACCEPTING = null;\n-            }\n-            if (ss != null) {\n-                try {\n-                    ss.close();\n-                } catch (IOException io) {\n-                    throw new UncheckedIOException(io);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpGetInCancelledFuture.java","additions":0,"deletions":391,"binary":false,"changes":391,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -257,5 +257,0 @@\n-            if (i == 0 && waited == 0) {\n-                \/\/ we found nothing and didn't wait expecting success, but then found\n-                \/\/ something. Respin to make sure we wait.\n-                return check(tracker, graceDelayMs, hasOutstanding, description, printThreads);\n-            }\n@@ -318,5 +313,0 @@\n-            if (i == 0 && waited == 0) {\n-                \/\/ we found nothing and didn't wait expecting success, but then found\n-                \/\/ something. Respin to make sure we wait.\n-                return check(graceDelayMs, hasOutstanding, description, printThreads);\n-            }\n","filename":"test\/jdk\/java\/net\/httpclient\/ReferenceTracker.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,336 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.IOException;\n-import java.io.OutputStream;\n-import java.net.URI;\n-import java.net.http.HttpClient;\n-import java.net.http.HttpRequest;\n-import java.net.http.HttpResponse;\n-import java.net.http.HttpResponse.BodyHandlers;\n-import java.util.ArrayList;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Random;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import javax.net.ssl.SSLContext;\n-\n-import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestExchange;\n-import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestHandler;\n-import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n-import jdk.test.lib.net.SimpleSSLContext;\n-import jdk.test.lib.net.URIBuilder;\n-import org.junit.jupiter.api.AfterAll;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.Test;\n-import static java.net.http.HttpClient.Version.HTTP_2;\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertNotNull;\n-import static org.junit.jupiter.api.Assertions.fail;\n-\n-\/*\n- * @test\n- * @bug 8335181\n- * @summary verify that the HttpClient correctly handles incoming GOAWAY frames and\n- *          retries any unprocessed requests on a new connection\n- * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n- * @build jdk.httpclient.test.lib.common.HttpServerAdapters\n- *        jdk.test.lib.net.SimpleSSLContext\n- * @run junit H2GoAwayTest\n- *\/\n-public class H2GoAwayTest {\n-    private static final String REQ_PATH = \"\/test\";\n-    private static HttpTestServer server;\n-    private static String REQ_URI_BASE;\n-    private static SSLContext sslCtx;\n-\n-    @BeforeAll\n-    static void beforeAll() throws Exception {\n-        sslCtx = new SimpleSSLContext().get();\n-        assertNotNull(sslCtx, \"SSLContext couldn't be created\");\n-        server = HttpTestServer.create(HTTP_2, sslCtx);\n-        server.addHandler(new Handler(), REQ_PATH);\n-        server.start();\n-        System.out.println(\"Server started at \" + server.getAddress());\n-        REQ_URI_BASE = URIBuilder.newBuilder().scheme(\"https\")\n-                .loopback()\n-                .port(server.getAddress().getPort())\n-                .path(REQ_PATH)\n-                .build().toString();\n-    }\n-\n-    @AfterAll\n-    static void afterAll() {\n-        if (server != null) {\n-            System.out.println(\"Stopping server at \" + server.getAddress());\n-            server.stop();\n-        }\n-    }\n-\n-    \/**\n-     * Verifies that when several requests are sent using send() and the server\n-     * connection is configured to send a GOAWAY after processing only a few requests, then\n-     * the remaining requests are retried on a different connection\n-     *\/\n-    @Test\n-    public void testSequential() throws Exception {\n-        final LimitedPerConnRequestApprover reqApprover = new LimitedPerConnRequestApprover();\n-        server.setRequestApprover(reqApprover::allowNewRequest);\n-        try (final HttpClient client = HttpClient.newBuilder().version(HTTP_2)\n-                .sslContext(sslCtx).build()) {\n-            final String[] reqMethods = {\"HEAD\", \"GET\", \"POST\"};\n-            for (final String reqMethod : reqMethods) {\n-                final int numReqs = LimitedPerConnRequestApprover.MAX_REQS_PER_CONN + 3;\n-                final Set<String> connectionKeys = new LinkedHashSet<>();\n-                for (int i = 1; i <= numReqs; i++) {\n-                    final URI reqURI = new URI(REQ_URI_BASE + \"?seq&\" + reqMethod + \"=\" + i);\n-                    final HttpRequest req = HttpRequest.newBuilder()\n-                            .uri(reqURI)\n-                            .method(reqMethod, HttpRequest.BodyPublishers.noBody())\n-                            .build();\n-                    System.out.println(\"initiating request \" + req);\n-                    final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n-                    final String respBody = resp.body();\n-                    System.out.println(\"received response: \" + respBody);\n-                    assertEquals(200, resp.statusCode(),\n-                            \"unexpected status code for request \" + resp.request());\n-                    \/\/ response body is the logical key of the connection on which the\n-                    \/\/ request was handled\n-                    connectionKeys.add(respBody);\n-                }\n-                System.out.println(\"connections involved in handling the requests: \"\n-                        + connectionKeys);\n-                \/\/ all requests have finished, we now just do a basic check that\n-                \/\/ more than one connection was involved in processing these requests\n-                assertEquals(2, connectionKeys.size(),\n-                        \"unexpected number of connections \" + connectionKeys);\n-            }\n-        } finally {\n-            server.setRequestApprover(null); \/\/ reset\n-        }\n-    }\n-\n-    \/**\n-     * Verifies that when a server responds with a GOAWAY and then never processes the new retried\n-     * requests on a new connection too, then the application code receives the request failure.\n-     * This tests the send() API of the HttpClient.\n-     *\/\n-    @Test\n-    public void testUnprocessedRaisesException() throws Exception {\n-        try (final HttpClient client = HttpClient.newBuilder().version(HTTP_2)\n-                .sslContext(sslCtx).build()) {\n-            final Random random = new Random();\n-            final String[] reqMethods = {\"HEAD\", \"GET\", \"POST\"};\n-            for (final String reqMethod : reqMethods) {\n-                final int maxAllowedReqs = 2;\n-                final int numReqs = maxAllowedReqs + 3; \/\/ 3 more requests than max allowed\n-                \/\/ configure the approver\n-                final LimitedRequestApprover reqApprover = new LimitedRequestApprover(maxAllowedReqs);\n-                server.setRequestApprover(reqApprover::allowNewRequest);\n-                try {\n-                    int numSuccess = 0;\n-                    int numFailed = 0;\n-                    for (int i = 1; i <= numReqs; i++) {\n-                        final String reqQueryPart = \"?sync&\" + reqMethod + \"=\" + i;\n-                        final URI reqURI = new URI(REQ_URI_BASE + reqQueryPart);\n-                        final HttpRequest req = HttpRequest.newBuilder()\n-                                .uri(reqURI)\n-                                .method(reqMethod, HttpRequest.BodyPublishers.noBody())\n-                                .build();\n-                        System.out.println(\"initiating request \" + req);\n-                        if (i <= maxAllowedReqs) {\n-                            \/\/ expected to successfully complete\n-                            numSuccess++;\n-                            final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n-                            final String respBody = resp.body();\n-                            System.out.println(\"received response: \" + respBody);\n-                            assertEquals(200, resp.statusCode(),\n-                                    \"unexpected status code for request \" + resp.request());\n-                        } else {\n-                            \/\/ expected to fail as unprocessed\n-                            try {\n-                                final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n-                                fail(\"Request was expected to fail as unprocessed,\"\n-                                        + \" but got response: \" + resp.body() + \", status code: \"\n-                                        + resp.statusCode());\n-                            } catch (IOException ioe) {\n-                                \/\/ verify it failed for the right reason\n-                                if (ioe.getMessage() == null\n-                                        || !ioe.getMessage().contains(\"request not processed by peer\")) {\n-                                    \/\/ propagate the original failure\n-                                    throw ioe;\n-                                }\n-                                numFailed++; \/\/ failed due to right reason\n-                                System.out.println(\"received expected failure: \" + ioe\n-                                        + \", for request \" + reqURI);\n-                            }\n-                        }\n-                    }\n-                    \/\/ verify the correct number of requests succeeded\/failed\n-                    assertEquals(maxAllowedReqs, numSuccess, \"unexpected number of requests succeeded\");\n-                    assertEquals((numReqs - maxAllowedReqs), numFailed, \"unexpected number of requests failed\");\n-                } finally {\n-                    server.setRequestApprover(null); \/\/ reset\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Verifies that when a server responds with a GOAWAY and then never processes the new retried\n-     * requests on a new connection too, then the application code receives the request failure.\n-     * This tests the sendAsync() API of the HttpClient.\n-     *\/\n-    @Test\n-    public void testUnprocessedRaisesExceptionAsync() throws Throwable {\n-        try (final HttpClient client = HttpClient.newBuilder().version(HTTP_2)\n-                .sslContext(sslCtx).build()) {\n-            final Random random = new Random();\n-            final String[] reqMethods = {\"HEAD\", \"GET\", \"POST\"};\n-            for (final String reqMethod : reqMethods) {\n-                final int maxAllowedReqs = 2;\n-                final int numReqs = maxAllowedReqs + 3; \/\/ 3 more requests than max allowed\n-                \/\/ configure the approver\n-                final LimitedRequestApprover reqApprover = new LimitedRequestApprover(maxAllowedReqs);\n-                server.setRequestApprover(reqApprover::allowNewRequest);\n-                try {\n-                    final List<Future<HttpResponse<String>>> futures = new ArrayList<>();\n-                    for (int i = 1; i <= numReqs; i++) {\n-                        final URI reqURI = new URI(REQ_URI_BASE + \"?async&\" + reqMethod + \"=\" + i);\n-                        final HttpRequest req = HttpRequest.newBuilder()\n-                                .uri(reqURI)\n-                                .method(reqMethod, HttpRequest.BodyPublishers.noBody())\n-                                .build();\n-                        System.out.println(\"initiating request \" + req);\n-                        final Future<HttpResponse<String>> f = client.sendAsync(req, BodyHandlers.ofString());\n-                        futures.add(f);\n-                    }\n-                    \/\/ wait for responses\n-                    int numFailed = 0;\n-                    int numSuccess = 0;\n-                    for (int i = 1; i <= numReqs; i++) {\n-                        final String reqQueryPart = \"?async&\" + reqMethod + \"=\" + i;\n-                        try {\n-                            System.out.println(\"waiting response of request \"\n-                                    + REQ_URI_BASE + reqQueryPart);\n-                            final HttpResponse<String> resp = futures.get(i - 1).get();\n-                            numSuccess++;\n-                            final String respBody = resp.body();\n-                            System.out.println(\"request: \" + resp.request()\n-                                    + \", received response: \" + respBody);\n-                            assertEquals(200, resp.statusCode(),\n-                                    \"unexpected status code for request \" + resp.request());\n-                        } catch (ExecutionException ee) {\n-                            final Throwable cause = ee.getCause();\n-                            if (!(cause instanceof IOException ioe)) {\n-                                throw cause;\n-                            }\n-                            \/\/ verify it failed for the right reason\n-                            if (ioe.getMessage() == null\n-                                    || !ioe.getMessage().contains(\"request not processed by peer\")) {\n-                                \/\/ propagate the original failure\n-                                throw ioe;\n-                            }\n-                            numFailed++; \/\/ failed due to the right reason\n-                            System.out.println(\"received expected failure: \" + ioe\n-                                    + \", for request \" + REQ_URI_BASE + reqQueryPart);\n-                        }\n-                    }\n-                    \/\/ verify the correct number of requests succeeded\/failed\n-                    assertEquals(maxAllowedReqs, numSuccess, \"unexpected number of requests succeeded\");\n-                    assertEquals((numReqs - maxAllowedReqs), numFailed, \"unexpected number of requests failed\");\n-                } finally {\n-                    server.setRequestApprover(null); \/\/ reset\n-                }\n-            }\n-        }\n-    }\n-\n-    \/\/ only allows fixed number of requests, irrespective of which server connection handles\n-    \/\/ it. requests that are rejected will either be sent a GOAWAY on the connection\n-    \/\/ or a RST_FRAME with a REFUSED_STREAM on the stream\n-    private static final class LimitedRequestApprover {\n-        private final int maxAllowedReqs;\n-        private final AtomicInteger numApproved = new AtomicInteger();\n-\n-        private LimitedRequestApprover(final int maxAllowedReqs) {\n-            this.maxAllowedReqs = maxAllowedReqs;\n-        }\n-\n-        public boolean allowNewRequest(final String serverConnKey) {\n-            final int approved = numApproved.incrementAndGet();\n-            return approved <= maxAllowedReqs;\n-        }\n-    }\n-\n-    \/\/ allows a certain number of requests per server connection.\n-    \/\/ requests that are rejected will either be sent a GOAWAY on the connection\n-    \/\/ or a RST_FRAME with a REFUSED_STREAM on the stream\n-    private static final class LimitedPerConnRequestApprover {\n-        private static final int MAX_REQS_PER_CONN = 6;\n-        private final Map<String, AtomicInteger> numApproved =\n-                new ConcurrentHashMap<>();\n-        private final Map<String, AtomicInteger> numDisapproved =\n-                new ConcurrentHashMap<>();\n-\n-        public boolean allowNewRequest(final String serverConnKey) {\n-            final AtomicInteger approved = numApproved.computeIfAbsent(serverConnKey,\n-                    (k) -> new AtomicInteger());\n-            int curr = approved.get();\n-            while (curr < MAX_REQS_PER_CONN) {\n-                if (approved.compareAndSet(curr, curr + 1)) {\n-                    return true; \/\/ new request allowed\n-                }\n-                curr = approved.get();\n-            }\n-            final AtomicInteger disapproved = numDisapproved.computeIfAbsent(serverConnKey,\n-                    (k) -> new AtomicInteger());\n-            final int numUnprocessed = disapproved.incrementAndGet();\n-            System.out.println(approved.get() + \" processed, \"\n-                    + numUnprocessed + \" unprocessed requests on connection \" + serverConnKey);\n-            return false;\n-        }\n-    }\n-\n-    private static final class Handler implements HttpTestHandler {\n-\n-        @Override\n-        public void handle(final HttpTestExchange exchange) throws IOException {\n-            final String connectionKey = exchange.getConnectionKey();\n-            System.out.println(\"responding to request: \" + exchange.getRequestURI()\n-                    + \" on connection \" + connectionKey);\n-            final byte[] response = connectionKey.getBytes(UTF_8);\n-            exchange.sendResponseHeaders(200, response.length);\n-            try (final OutputStream os = exchange.getResponseBody()) {\n-                os.write(response);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/H2GoAwayTest.java","additions":0,"deletions":336,"binary":false,"changes":336,"status":"deleted"},{"patch":"@@ -61,1 +61,0 @@\n-import java.util.function.Predicate;\n@@ -244,1 +243,0 @@\n-        public abstract String getConnectionKey();\n@@ -259,1 +257,1 @@\n-            return new H2ExchangeImpl(exchange);\n+            return new Http2TestExchangeImpl(exchange);\n@@ -315,6 +313,0 @@\n-\n-            @Override\n-            public String getConnectionKey() {\n-                return exchange.getLocalAddress() + \"->\" + exchange.getRemoteAddress();\n-            }\n-\n@@ -327,1 +319,1 @@\n-        private static final class H2ExchangeImpl extends HttpTestExchange {\n+        private static final class Http2TestExchangeImpl extends HttpTestExchange {\n@@ -329,1 +321,1 @@\n-            H2ExchangeImpl(Http2TestExchange exch) {\n+            Http2TestExchangeImpl(Http2TestExchange exch) {\n@@ -382,5 +374,0 @@\n-            @Override\n-            public String getConnectionKey() {\n-                return exchange.getConnectionKey();\n-            }\n-\n@@ -732,1 +719,0 @@\n-        public abstract void setRequestApprover(final Predicate<String> approver);\n@@ -881,5 +867,0 @@\n-\n-            @Override\n-            public void setRequestApprover(final Predicate<String> approver) {\n-                throw new UnsupportedOperationException(\"not supported\");\n-            }\n@@ -937,5 +918,0 @@\n-\n-            @Override\n-            public void setRequestApprover(final Predicate<String> approver) {\n-                this.impl.setRequestApprover(approver);\n-            }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/common\/HttpServerAdapters.java","additions":3,"deletions":27,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,6 +87,0 @@\n-\n-    \/**\n-     * {@return the identification of the connection on which this exchange is being\n-     * processed}\n-     *\/\n-    String getConnectionKey();\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchange.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -230,5 +230,0 @@\n-    @Override\n-    public String getConnectionKey() {\n-        return conn.connectionKey();\n-    }\n-\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchangeImpl.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,0 @@\n-import java.util.function.Predicate;\n-\n@@ -64,2 +62,0 @@\n-    \/\/ request approver which takes the server connection key as the input\n-    private volatile Predicate<String> newRequestApprover;\n@@ -292,8 +288,0 @@\n-    public void setRequestApprover(final Predicate<String> approver) {\n-        this.newRequestApprover = approver;\n-    }\n-\n-    Predicate<String> getRequestApprover() {\n-        return this.newRequestApprover;\n-    }\n-\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServer.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-import java.util.Set;\n@@ -84,1 +83,0 @@\n-import java.util.concurrent.atomic.AtomicInteger;\n@@ -88,1 +86,0 @@\n-import java.util.function.Predicate;\n@@ -92,1 +89,0 @@\n-import static jdk.internal.net.http.frame.ErrorFrame.REFUSED_STREAM;\n@@ -122,4 +118,0 @@\n-    \/\/ the max stream id of a processed H2 request. -1 implies none were processed.\n-    private final AtomicInteger maxProcessedRequestStreamId = new AtomicInteger(-1);\n-    \/\/ the stream id that was sent in a GOAWAY frame. -1 implies no GOAWAY frame was sent.\n-    private final AtomicInteger goAwayRequestStreamId = new AtomicInteger(-1);\n@@ -250,23 +242,5 @@\n-    private void sendGoAway(final int error) throws IOException {\n-        int maxProcessedStreamId = maxProcessedRequestStreamId.get();\n-        if (maxProcessedStreamId == -1) {\n-            maxProcessedStreamId = 0;\n-        }\n-        boolean send = false;\n-        int currentGoAwayReqStrmId = goAwayRequestStreamId.get();\n-        \/\/ update the last processed stream id and send a goaway frame if the new last processed\n-        \/\/ stream id is lesser than the last processed stream id sent in\n-        \/\/ a previous goaway frame (if any)\n-        while (currentGoAwayReqStrmId == -1 || maxProcessedStreamId < currentGoAwayReqStrmId) {\n-            if (goAwayRequestStreamId.compareAndSet(currentGoAwayReqStrmId, maxProcessedStreamId)) {\n-                send = true;\n-                break;\n-            }\n-            currentGoAwayReqStrmId = goAwayRequestStreamId.get();\n-        }\n-        if (!send) {\n-            return;\n-        }\n-        final GoAwayFrame frame = new GoAwayFrame(maxProcessedStreamId, error);\n-        outputQ.put(frame);\n-        System.err.println(\"Sending GOAWAY frame \" + frame + \" from server connection \" + this);\n+    void goAway(int error) throws IOException {\n+        int laststream = nextstream >= 3 ? nextstream - 2 : 1;\n+\n+        GoAwayFrame go = new GoAwayFrame(laststream, error);\n+        outputQ.put(go);\n@@ -365,3 +339,2 @@\n-            if (error != -1) {\n-                sendGoAway(error);\n-            }\n+            if (error != -1)\n+                goAway(error);\n@@ -649,8 +622,0 @@\n-        \/\/ skip processing the request if configured to do so\n-        final String connKey = connectionKey();\n-        if (!shouldProcessNewHTTPRequest(connKey)) {\n-            System.err.println(\"Rejecting primordial stream 1 and sending GOAWAY\" +\n-                    \" on server connection \" + connKey + \", for request: \" + path);\n-            sendGoAway(ErrorFrame.NO_ERROR);\n-            return;\n-        }\n@@ -665,1 +630,0 @@\n-        maxProcessedRequestStreamId.set(1);\n@@ -671,12 +635,0 @@\n-    private boolean shouldProcessNewHTTPRequest(final String serverConnKey) {\n-        final Predicate<String> approver = this.server.getRequestApprover();\n-        if (approver == null) {\n-            return true; \/\/ process the request\n-        }\n-        return approver.test(serverConnKey);\n-    }\n-\n-    final String connectionKey() {\n-        return this.server.getAddress() + \"->\" + this.socket.getRemoteSocketAddress();\n-    }\n-\n@@ -690,1 +642,1 @@\n-            throw new IOException(\"unexpected stream id: \" + streamid);\n+            throw new IOException(\"unexpected stream id\");\n@@ -721,1 +673,1 @@\n-        if (disallowedHeader.isPresent()) {\n+        if (disallowedHeader.isPresent())\n@@ -723,1 +675,0 @@\n-        }\n@@ -725,10 +676,1 @@\n-        \/\/ skip processing the request if the server is configured to do so\n-        final String connKey = connectionKey();\n-        final String path = headers.firstValue(\":path\").orElse(\"\");\n-        if (!shouldProcessNewHTTPRequest(connKey)) {\n-            System.err.println(\"Rejecting stream \" + streamid\n-                    + \" and sending GOAWAY on server connection \"\n-                    + connKey + \", for request: \" + path);\n-            sendGoAway(ErrorFrame.NO_ERROR);\n-            return;\n-        }\n+\n@@ -737,8 +679,0 @@\n-        \/\/ keep track of the largest request id that we have processed\n-        int currentLargest = maxProcessedRequestStreamId.get();\n-        while (streamid > currentLargest) {\n-            if (maxProcessedRequestStreamId.compareAndSet(currentLargest, streamid)) {\n-                break;\n-            }\n-            currentLargest = maxProcessedRequestStreamId.get();\n-        }\n@@ -847,2 +781,0 @@\n-                    System.err.println(\"EOF reached on connection \" + connectionKey()\n-                            + \", will no longer accept incoming frames\");\n@@ -872,11 +804,0 @@\n-                            final int streamId = frame.streamid();\n-                            final int finalProcessedStreamId = goAwayRequestStreamId.get();\n-                            \/\/ if we already sent a goaway, then don't create new streams with\n-                            \/\/ higher stream ids.\n-                            if (finalProcessedStreamId != -1 && streamId > finalProcessedStreamId) {\n-                                System.err.println(connectionKey() + \" resetting stream \" + streamId\n-                                        + \" as REFUSED_STREAM\");\n-                                final ResetFrame rst = new ResetFrame(streamId, REFUSED_STREAM);\n-                                outputQ.put(rst);\n-                                continue;\n-                            }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":10,"deletions":89,"binary":false,"changes":99,"status":"modified"}]}