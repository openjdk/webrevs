{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,4 @@\n+    \/\/ this will be set to true only when the peer explicitly states (through a GOAWAY frame or\n+    \/\/ a relevant error code in reset frame) that the corresponding stream (id) wasn't processed\n+    private volatile boolean unprocessedByPeer;\n+\n@@ -267,0 +271,9 @@\n+\n+    final boolean isUnprocessedByPeer() {\n+        return this.unprocessedByPeer;\n+    }\n+\n+    \/\/ Marks the exchange as unprocessed by the peer\n+    final void markUnprocessedByPeer() {\n+        this.unprocessedByPeer = true;\n+    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ExchangeImpl.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -399,0 +400,1 @@\n+    private final AtomicLong lastProcessedStreamInGoAway = new AtomicLong(-1);\n@@ -805,1 +807,3 @@\n-            if (connection.channel().isOpen()) {\n+            \/\/ we send a GOAWAY frame only if the remote side hasn't already indicated\n+            \/\/ the intention to close the connection by previously sending a GOAWAY of its own\n+            if (connection.channel().isOpen() && !isMarked(closedState, HALF_CLOSED_REMOTE)) {\n@@ -1357,7 +1361,40 @@\n-    private void handleGoAway(GoAwayFrame frame)\n-        throws IOException\n-    {\n-        if (markHalfClosedLRemote()) {\n-            shutdown(new IOException(\n-                    connection.channel().getLocalAddress()\n-                            + \": GOAWAY received\"));\n+    private void handleGoAway(final GoAwayFrame frame) {\n+        final long lastProcessedStream = frame.getLastStream();\n+        assert lastProcessedStream >= 0 : \"unexpected last stream id: \"\n+                + lastProcessedStream + \" in GOAWAY frame\";\n+\n+        markHalfClosedRemote();\n+        setFinalStream(); \/\/ don't allow any new streams on this connection\n+        if (debug.on()) {\n+            debug.log(\"processing incoming GOAWAY with last processed stream id:%s in frame %s\",\n+                    lastProcessedStream, frame);\n+        }\n+        \/\/ see if this connection has previously received a GOAWAY from the peer and if yes\n+        \/\/ then check if this new last processed stream id is lesser than the previous\n+        \/\/ known last processed stream id. Only update the last processed stream id if the new\n+        \/\/ one is lesser than the previous one.\n+        long prevLastProcessed = lastProcessedStreamInGoAway.get();\n+        while (prevLastProcessed == -1 || lastProcessedStream < prevLastProcessed) {\n+            if (lastProcessedStreamInGoAway.compareAndSet(prevLastProcessed,\n+                    lastProcessedStream)) {\n+                break;\n+            }\n+            prevLastProcessed = lastProcessedStreamInGoAway.get();\n+        }\n+        handlePeerUnprocessedStreams(lastProcessedStreamInGoAway.get());\n+    }\n+\n+    private void handlePeerUnprocessedStreams(final long lastProcessedStream) {\n+        final AtomicInteger numClosed = new AtomicInteger(); \/\/ atomic merely to allow usage within lambda\n+        streams.forEach((id, exchange) -> {\n+            if (id > lastProcessedStream) {\n+                \/\/ any streams with an stream id higher than the last processed stream\n+                \/\/ can be retried (on a new connection). we close the exchange as unprocessed\n+                \/\/ to facilitate the retrying.\n+                client2.client().theExecutor().ensureExecutedAsync(exchange::closeAsUnprocessed);\n+                numClosed.incrementAndGet();\n+            }\n+        });\n+        if (debug.on()) {\n+            debug.log(numClosed.get() + \" stream(s), with id greater than \" + lastProcessedStream\n+                    + \", will be closed as unprocessed\");\n@@ -1914,1 +1951,1 @@\n-    private boolean markHalfClosedLRemote() {\n+    private boolean markHalfClosedRemote() {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":46,"deletions":9,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-    static void registerPending(PendingRequest pending) {\n+    static <T> CompletableFuture<T> registerPending(PendingRequest pending, CompletableFuture<T> res) {\n@@ -288,1 +288,1 @@\n-        if (pending.cf.isDone()) return;\n+        if (pending.cf.isDone()) return res;\n@@ -295,1 +295,2 @@\n-        pending.ref = cf.whenComplete((r,t) -> client.pendingRequests.remove(pending));\n+        var ref = res.whenComplete((r,t) -> client.pendingRequests.remove(pending));\n+        pending.ref = ref;\n@@ -302,0 +303,1 @@\n+        return ref;\n@@ -578,0 +580,1 @@\n+                        return true;\n@@ -579,1 +582,1 @@\n-                    return true;\n+                    return false;\n@@ -933,1 +936,1 @@\n-            if (cf != null )\n+            if (cf != null) {\n@@ -935,0 +938,1 @@\n+            }\n@@ -1056,7 +1060,0 @@\n-            \/\/ makes sure that any dependent actions happen in the CF default\n-            \/\/ executor. This is only needed for sendAsync(...), when\n-            \/\/ exchangeExecutor is non-null.\n-            if (exchangeExecutor != null) {\n-                res = res.whenCompleteAsync((r, t) -> { \/* do nothing *\/}, ASYNC_POOL);\n-            }\n-\n@@ -1066,3 +1063,14 @@\n-            registerPending(pending);\n-            return res;\n-        } catch(Throwable t) {\n+            res = registerPending(pending, res);\n+\n+            if (exchangeExecutor != null) {\n+                \/\/ makes sure that any dependent actions happen in the CF default\n+                \/\/ executor. This is only needed for sendAsync(...), when\n+                \/\/ exchangeExecutor is non-null.\n+                return res.isDone() ? res\n+                        : res.whenCompleteAsync((r, t) -> { \/* do nothing *\/}, ASYNC_POOL);\n+            } else {\n+                \/\/ make a defensive copy that can be safely canceled\n+                \/\/ by the caller\n+                return res.isDone() ? res : res.copy();\n+            }\n+        } catch (Throwable t) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpClientImpl.java","additions":23,"deletions":15,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,2 +93,2 @@\n-    volatile boolean expiredOnce;\n-    volatile HttpResponse<T> response = null;\n+    volatile boolean retriedOnce;\n+    volatile HttpResponse<T> response;\n@@ -282,0 +282,1 @@\n+        boolean firstCancel = false;\n@@ -284,1 +285,1 @@\n-                interrupted.compareAndSet(null,\n+                firstCancel = interrupted.compareAndSet(null,\n@@ -287,0 +288,7 @@\n+            if (debug.on()) {\n+                if (firstCancel) {\n+                    debug.log(\"multi exchange recording: \" + interrupted.get());\n+                } else {\n+                    debug.log(\"multi exchange recorded: \" + interrupted.get());\n+                }\n+            }\n@@ -368,0 +376,16 @@\n+    \/\/ returns a CancellationExcpetion that wraps the given cause\n+    \/\/ if cancel(boolean) was called, the given cause otherwise\n+    private Throwable wrapIfCancelled(Throwable cause) {\n+        CancellationException interrupt = interrupted.get();\n+        if (interrupt == null) return cause;\n+\n+        var cancel = new CancellationException(interrupt.getMessage());\n+        \/\/ preserve the stack trace of the original exception to\n+        \/\/ show where the call to cancel(boolean) came from\n+        cancel.setStackTrace(interrupt.getStackTrace());\n+        cancel.initCause(Utils.getCancelCause(cause));\n+        return cancel;\n+    }\n+\n+    \/\/ if the request failed because the multi exchange was cancelled,\n+    \/\/ make sure the reported exception is wrapped in CancellationException\n@@ -369,5 +393,2 @@\n-        CancellationException x = interrupted.get();\n-        if (x != null) {\n-            \/\/ make sure to fail with CancellationException if cancel(true)\n-            \/\/ was called.\n-            t = x.initCause(Utils.getCancelCause(t));\n+        var x = wrapIfCancelled(t);\n+        if (x instanceof CancellationException) {\n@@ -375,1 +396,1 @@\n-                debug.log(\"MultiExchange interrupted with: \" + t.getCause());\n+                debug.log(\"MultiExchange interrupted with: \" + x.getCause());\n@@ -378,1 +399,1 @@\n-        return MinimalFuture.failedFuture(t);\n+        return MinimalFuture.failedFuture(x);\n@@ -441,1 +462,1 @@\n-                                expiredOnce = false;\n+                                retriedOnce = false;\n@@ -454,1 +475,1 @@\n-                        CompletableFuture<Response> errorCF = getExceptionalCF(ex);\n+                        CompletableFuture<Response> errorCF = getExceptionalCF(ex, exch.exchImpl);\n@@ -526,1 +547,1 @@\n-    private CompletableFuture<Response> getExceptionalCF(Throwable t) {\n+    private CompletableFuture<Response> getExceptionalCF(Throwable t, ExchangeImpl<?> exchImpl) {\n@@ -532,0 +553,1 @@\n+        final boolean retryAsUnprocessed = exchImpl != null && exchImpl.isUnprocessedByPeer();\n@@ -536,1 +558,1 @@\n-        } else if (retryOnFailure(t)) {\n+        } else if (retryAsUnprocessed || retryOnFailure(t)) {\n@@ -543,2 +565,4 @@\n-                if (!canRetryRequest(currentreq)) {\n-                    return failedFuture(cause); \/\/ fails with original cause\n+                if (!retryAsUnprocessed && !canRetryRequest(currentreq)) {\n+                    \/\/ a (peer) processed request which cannot be retried, fail with\n+                    \/\/ the original cause\n+                    return failedFuture(cause);\n@@ -550,1 +574,1 @@\n-            if (!expiredOnce) {\n+            if (!retriedOnce) {\n@@ -552,2 +576,3 @@\n-                    debug.log(t.getClass().getSimpleName() + \" (async): retrying...\", t);\n-                expiredOnce = true;\n+                    debug.log(t.getClass().getSimpleName()\n+                            + \" (async): retrying \" + currentreq + \" due to: \", t);\n+                retriedOnce = true;\n@@ -564,1 +589,1 @@\n-                            + \" (async): already retried once.\", t);\n+                            + \" (async): already retried once \" + currentreq, t);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/MultiExchange.java","additions":46,"deletions":21,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -194,1 +194,1 @@\n-            while (!inputQ.isEmpty()) {\n+            while (!inputQ.isEmpty() && errorRef.get() == null) {\n@@ -428,0 +428,4 @@\n+        \/\/ ensure that the body subscriber will be subscribed and onError() is\n+        \/\/ invoked\n+        pendingResponseSubscriber = bodySubscriber;\n+\n@@ -438,3 +442,0 @@\n-        \/\/ ensure that the body subscriber will be subscribed and onError() is\n-        \/\/ invoked\n-        pendingResponseSubscriber = bodySubscriber;\n@@ -675,6 +676,24 @@\n-                int error = frame.getErrorCode();\n-                IOException e = new IOException(\"Received RST_STREAM: \"\n-                        + ErrorFrame.stringForCode(error));\n-                if (errorRef.compareAndSet(null, e)) {\n-                    if (subscriber != null) {\n-                        subscriber.onError(e);\n+                final int error = frame.getErrorCode();\n+                \/\/ A REFUSED_STREAM error code implies that the stream wasn't processed by the\n+                \/\/ peer and the client is free to retry the request afresh.\n+                if (error == ErrorFrame.REFUSED_STREAM) {\n+                    \/\/ Here we arrange for the request to be retried. Note that we don't call\n+                    \/\/ closeAsUnprocessed() method here because the \"closed\" state is already set\n+                    \/\/ to true a few lines above and calling close() from within\n+                    \/\/ closeAsUnprocessed() will end up being a no-op. We instead do the additional\n+                    \/\/ bookkeeping here.\n+                    markUnprocessedByPeer();\n+                    errorRef.compareAndSet(null, new IOException(\"request not processed by peer\"));\n+                    if (debug.on()) {\n+                        debug.log(\"request unprocessed by peer (REFUSED_STREAM) \" + this.request);\n+                    }\n+                } else {\n+                    final String reason = ErrorFrame.stringForCode(error);\n+                    final IOException failureCause = new IOException(\"Received RST_STREAM: \" + reason);\n+                    if (debug.on()) {\n+                        debug.log(streamid + \" received RST_STREAM with code: \" + reason);\n+                    }\n+                    if (errorRef.compareAndSet(null, failureCause)) {\n+                        if (subscriber != null) {\n+                            subscriber.onError(failureCause);\n+                        }\n@@ -683,1 +702,2 @@\n-                completeResponseExceptionally(e);\n+                final Throwable failureCause = errorRef.get();\n+                completeResponseExceptionally(failureCause);\n@@ -685,1 +705,1 @@\n-                    requestBodyCF.completeExceptionally(errorRef.get()); \/\/ we may be sending the body..\n+                    requestBodyCF.completeExceptionally(failureCause); \/\/ we may be sending the body..\n@@ -688,1 +708,1 @@\n-                    responseBodyCF.completeExceptionally(errorRef.get());\n+                    responseBodyCF.completeExceptionally(failureCause);\n@@ -1701,1 +1721,29 @@\n-        return connection.dbgString() + \"\/Stream(\"+streamid+\")\";\n+        final int id = streamid;\n+        final String sid = id == 0 ? \"?\" : String.valueOf(id);\n+        return connection.dbgString() + \"\/Stream(\" + sid + \")\";\n+    }\n+\n+    \/**\n+     * An unprocessed exchange is one that hasn't been processed by a peer. The local end of the\n+     * connection would be notified about such exchanges when it receives a GOAWAY frame with\n+     * a stream id that tells which exchanges have been unprocessed.\n+     * This method is called on such unprocessed exchanges and the implementation of this method\n+     * will arrange for the request, corresponding to this exchange, to be retried afresh on a\n+     * new connection.\n+     *\/\n+    void closeAsUnprocessed() {\n+        try {\n+            \/\/ We arrange for the request to be retried on a new connection as allowed by the RFC-9113\n+            markUnprocessedByPeer();\n+            this.errorRef.compareAndSet(null, new IOException(\"request not processed by peer\"));\n+            if (debug.on()) {\n+                debug.log(\"closing \" + this.request + \" as unprocessed by peer\");\n+            }\n+            \/\/ close the exchange and complete the response CF exceptionally\n+            close();\n+            completeResponseExceptionally(this.errorRef.get());\n+        } finally {\n+            \/\/ decrementStreamsCount isn't really needed but we do it to make sure\n+            \/\/ the log messages, where these counts\/states get reported, show the accurate state.\n+            connection.decrementStreamsCount(streamid);\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":62,"deletions":14,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,6 @@\n-            \/\/ Odd stream numbers (client streams) should have been registered.\n+            \/\/ A client initiated stream might be closed (as unprocessed, due to a\n+            \/\/ GOAWAY received on the connection) even before the stream is\n+            \/\/ registered with this WindowController instance (when sending out request headers).\n+            \/\/ Thus, for client initiated streams, we don't enforce the presence of the\n+            \/\/ stream in the registered \"streams\" map.\n+\n@@ -107,3 +112,1 @@\n-            if (old == null && isClientStream) {\n-                throw new InternalError(\"Expected entry for streamid: \" + streamid);\n-            } else if (old != null && !isClientStream) {\n+            if (old != null && !isClientStream) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/WindowController.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,3 @@\n-        return super.toString() + \" Debugdata: \" + new String(debugData, UTF_8);\n+        return super.toString()\n+                + \" lastStreamId=\" + lastStream\n+                + \", Debugdata: \" + new String(debugData, UTF_8);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/frame\/GoAwayFrame.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -477,0 +477,1 @@\n+            var tracker = TRACKER.getTracker(client);\n@@ -485,1 +486,0 @@\n-                var tracker = TRACKER.getTracker(client);\n@@ -494,0 +494,8 @@\n+            } else {\n+                System.out.println(now() + \"waiting for operation to finish: \" + tracker.getName());\n+                System.err.println(now() + \"waiting for operation to finish: \" + tracker.getName());\n+                var error = TRACKER.checkFinished(tracker, 10000);\n+                if (error != null) throw error;\n+                System.out.println(now() + \"operation finished normally: \" + tracker.getName());\n+                System.err.println(now() + \"operation finished normally: \" + tracker.getName());\n+\n@@ -803,1 +811,1 @@\n-        AssertionError fail = TRACKER.check(500);\n+        AssertionError fail = TRACKER.check(5000);\n","filename":"test\/jdk\/java\/net\/httpclient\/AbstractThrowingSubscribers.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,391 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpClient.Version;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import jdk.internal.net.http.common.OperationTrackers.Tracker;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8316580\n+ * @library \/test\/lib\n+ * @run junit\/othervm -Djdk.tracePinnedThreads=full\n+ *                   -DuseReferenceTracker=false\n+ *                   HttpGetInCancelledFuture\n+ * @run junit\/othervm -Djdk.tracePinnedThreads=full\n+ *                   -DuseReferenceTracker=true\n+ *                   HttpGetInCancelledFuture\n+ * @summary This test verifies that cancelling a future that\n+ * does an HTTP request using the HttpClient doesn't cause\n+ * HttpClient::close to block forever.\n+ *\/\n+public class HttpGetInCancelledFuture {\n+\n+    static final boolean useTracker = Boolean.getBoolean(\"useReferenceTracker\");\n+\n+    static final class TestException extends RuntimeException {\n+        public TestException(String message, Throwable cause) {\n+            super(message, cause);\n+        }\n+    }\n+\n+    static ReferenceTracker TRACKER = ReferenceTracker.INSTANCE;\n+\n+    HttpClient makeClient(URI uri, Version version, Executor executor) {\n+        var builder = HttpClient.newBuilder();\n+        if (uri.getScheme().equalsIgnoreCase(\"https\")) {\n+            try {\n+                builder.sslContext(new SimpleSSLContext().get());\n+            } catch (IOException io) {\n+                throw new UncheckedIOException(io);\n+            }\n+        }\n+        return builder.connectTimeout(Duration.ofSeconds(1))\n+                .executor(executor)\n+                .version(version)\n+                .build();\n+    }\n+\n+    record TestCase(String url, int reqCount, Version version) {}\n+    \/\/ A server that doesn't accept\n+    static volatile ServerSocket NOT_ACCEPTING;\n+\n+    static List<TestCase> parameters() {\n+        ServerSocket ss = NOT_ACCEPTING;\n+        if (ss == null) {\n+            synchronized (HttpGetInCancelledFuture.class) {\n+                if ((ss = NOT_ACCEPTING) == null) {\n+                    try {\n+                        ss = new ServerSocket();\n+                        var loopback = InetAddress.getLoopbackAddress();\n+                        ss.bind(new InetSocketAddress(loopback, 0), 10);\n+                        NOT_ACCEPTING = ss;\n+                    } catch (IOException io) {\n+                        throw new UncheckedIOException(io);\n+                    }\n+                }\n+            }\n+        }\n+        URI http = URIBuilder.newBuilder()\n+                .loopback()\n+                .scheme(\"http\")\n+                .port(ss.getLocalPort())\n+                .path(\"\/not-accepting\/\")\n+                .buildUnchecked();\n+        URI https = URIBuilder.newBuilder()\n+                .loopback()\n+                .scheme(\"https\")\n+                .port(ss.getLocalPort())\n+                .path(\"\/not-accepting\/\")\n+                .buildUnchecked();\n+        \/\/ use all HTTP versions, without and with TLS\n+        return List.of(\n+                new TestCase(http.toString(), 200, Version.HTTP_2),\n+                new TestCase(http.toString(), 200, Version.HTTP_1_1),\n+                new TestCase(https.toString(), 200, Version.HTTP_2),\n+                new TestCase(https.toString(), 200, Version.HTTP_1_1)\n+                );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"parameters\")\n+    void runTest(TestCase test) {\n+        System.out.println(\"Testing with: \" + test);\n+        runTest(test.url, test.reqCount, test.version);\n+    }\n+\n+    static class TestTaskScope implements AutoCloseable {\n+        final ExecutorService pool = new ForkJoinPool();\n+        final Map<Task<?>, Future<?>> tasks = new ConcurrentHashMap<>();\n+        final AtomicReference<ExecutionException> failed = new AtomicReference<>();\n+\n+        class Task<T> implements Callable<T> {\n+            final Callable<T> task;\n+            final CompletableFuture<T> cf = new CompletableFuture<>();\n+            Task(Callable<T> task) {\n+                this.task = task;\n+            }\n+            @Override\n+            public T call() throws Exception {\n+                try {\n+                    var res = task.call();\n+                    cf.complete(res);\n+                    return res;\n+                } catch (Throwable t) {\n+                    cf.completeExceptionally(t);\n+                    throw t;\n+                }\n+            }\n+            CompletableFuture<T> cf() {\n+                return cf;\n+            }\n+        }\n+\n+\n+        static class ShutdownOnFailure extends TestTaskScope {\n+            public ShutdownOnFailure() {}\n+\n+            @Override\n+            protected <T> void completed(Task<T> task, T result, Throwable throwable) {\n+                super.completed(task, result, throwable);\n+                if (throwable != null) {\n+                    if (failed.get() == null) {\n+                        ExecutionException ex = throwable instanceof ExecutionException x\n+                                ? x : new ExecutionException(throwable);\n+                        failed.compareAndSet(null, ex);\n+                    }\n+                    tasks.entrySet().forEach(this::cancel);\n+                }\n+            }\n+\n+            void cancel(Map.Entry<Task<?>, Future<?>> entry) {\n+                entry.getValue().cancel(true);\n+                entry.getKey().cf().cancel(true);\n+                tasks.remove(entry.getKey(), entry.getValue());\n+            }\n+\n+            @Override\n+            public <T> CompletableFuture<T> fork(Callable<T> callable) {\n+                var ex = failed.get();\n+                if (ex == null) {\n+                    return super.fork(callable);\n+                } \/\/ otherwise do nothing\n+                return CompletableFuture.failedFuture(new RejectedExecutionException());\n+            }\n+        }\n+\n+        public <T> CompletableFuture<T> fork(Callable<T> callable) {\n+            var task = new Task<>(callable);\n+            var res = pool.submit(task);\n+            tasks.put(task, res);\n+            task.cf.whenComplete((r,t) -> completed(task, r, t));\n+            return task.cf;\n+        }\n+\n+        protected <T> void completed(Task<T> task, T result, Throwable throwable) {\n+            tasks.remove(task);\n+        }\n+\n+        public void join() throws InterruptedException {\n+            try {\n+                var cfs = tasks.keySet().stream()\n+                        .map(Task::cf).toArray(CompletableFuture[]::new);\n+                CompletableFuture.allOf(cfs).get();\n+            } catch (InterruptedException it) {\n+                throw it;\n+            } catch (ExecutionException ex) {\n+                failed.compareAndSet(null, ex);\n+            }\n+        }\n+\n+        public void throwIfFailed() throws ExecutionException {\n+            ExecutionException x = failed.get();\n+            if (x != null) throw x;\n+        }\n+\n+        public void close() {\n+            pool.close();\n+        }\n+    }\n+\n+    ExecutorService testExecutor() {\n+        return Executors.newCachedThreadPool();\n+    }\n+\n+    void runTest(String url, int reqCount, Version version) {\n+        final var dest = URI.create(url);\n+        try (final var executor = testExecutor()) {\n+            var httpClient = makeClient(dest, version, executor);\n+            TRACKER.track(httpClient);\n+            Tracker tracker = TRACKER.getTracker(httpClient);\n+            Throwable failed = null;\n+            try {\n+                try (final var scope = new TestTaskScope.ShutdownOnFailure()) {\n+                    launchAndProcessRequests(scope, httpClient, reqCount, dest);\n+                } finally {\n+                    System.out.printf(\"StructuredTaskScope closed: STARTED=%s, SUCCESS=%s, INTERRUPT=%s, FAILED=%s%n\",\n+                            STARTED.get(), SUCCESS.get(), INTERRUPT.get(), FAILED.get());\n+                }\n+                System.out.println(\"ERROR: Expected TestException not thrown\");\n+                throw new AssertionError(\"Expected TestException not thrown\");\n+            } catch (TestException x) {\n+                System.out.println(\"Got expected exception: \" + x);\n+            } catch (Throwable t) {\n+                System.out.println(\"ERROR: Unexpected exception: \" + t);\n+                failed = t;\n+                throw t;\n+            } finally {\n+                \/\/ we can either use the tracker or call HttpClient::close\n+                if (useTracker) {\n+                    \/\/ using the tracker depends on GC but will give us some diagnostic\n+                    \/\/ if some operations are not properly cancelled and prevent the client\n+                    \/\/ from terminating\n+                    httpClient = null;\n+                    System.gc();\n+                    System.out.println(TRACKER.diagnose(tracker));\n+                    var error = TRACKER.check(tracker, 10000);\n+                    if (error != null) {\n+                        if (failed != null) error.addSuppressed(failed);\n+                        EXCEPTIONS.forEach(x -> {\n+                            System.out.println(\"FAILED: \" + x);\n+                        });\n+                        EXCEPTIONS.forEach(x -> {\n+                            x.printStackTrace(System.out);\n+                        });\n+                        throw error;\n+                    }\n+                } else {\n+                    \/\/ if not all operations terminate, close() will block\n+                    \/\/ forever and the test will fail in jtreg timeout.\n+                    \/\/ there will be no diagnostic.\n+                    httpClient.close();\n+                }\n+                System.out.println(\"HttpClient closed\");\n+            }\n+        } finally {\n+            System.out.println(\"ThreadExecutor closed\");\n+        }\n+        \/\/ not all tasks may have been started before the scope was cancelled\n+        \/\/ due to the first connect\/timeout exception, but all tasks that started\n+        \/\/ must have either succeeded, be interrupted, or failed\n+        assertTrue(STARTED.get() > 0);\n+        assertEquals(STARTED.get(), SUCCESS.get() + INTERRUPT.get() + FAILED.get());\n+        if (SUCCESS.get() > 0) {\n+            \/\/ we don't expect any server to be listening and responding\n+            System.out.println(\"WARNING: got some unexpected successful responses from \"\n+                    + \"\\\"\" + NOT_ACCEPTING.getLocalSocketAddress() + \"\\\": \" + SUCCESS.get());\n+        }\n+    }\n+\n+    private void launchAndProcessRequests(\n+            TestTaskScope.ShutdownOnFailure scope,\n+            HttpClient httpClient,\n+            int reqCount,\n+            URI dest) {\n+        for (int counter = 0; counter < reqCount; counter++) {\n+            scope.fork(() ->\n+                    getAndCheck(httpClient, dest)\n+            );\n+        }\n+        try {\n+            scope.join();\n+        } catch (InterruptedException e) {\n+            throw new AssertionError(\"scope.join() was interrupted\", e);\n+        }\n+        try {\n+            scope.throwIfFailed();\n+        } catch (ExecutionException e) {\n+            throw new TestException(\"something threw an exception in StructuredTaskScope\", e);\n+        }\n+    }\n+\n+    final static AtomicLong ID = new AtomicLong();\n+    final AtomicLong SUCCESS = new AtomicLong();\n+    final AtomicLong INTERRUPT = new AtomicLong();\n+    final AtomicLong FAILED = new AtomicLong();\n+    final AtomicLong STARTED = new AtomicLong();\n+    final CopyOnWriteArrayList<Exception> EXCEPTIONS = new CopyOnWriteArrayList<>();\n+    private String getAndCheck(HttpClient httpClient, URI url) {\n+        STARTED.incrementAndGet();\n+        final var response = sendRequest(httpClient, url);\n+        String res = response.body();\n+        int statusCode = response.statusCode();\n+        assertEquals(200, statusCode);\n+        return res;\n+    }\n+\n+    private HttpResponse<String> sendRequest(HttpClient httpClient, URI url) {\n+        var id = ID.incrementAndGet();\n+        try {\n+            var request = HttpRequest.newBuilder(url).GET().build();\n+            var response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());\n+            \/\/ System.out.println(\"Got response for \" + id + \": \" + response);\n+            SUCCESS.incrementAndGet();\n+            return response;\n+        } catch (InterruptedException e) {\n+            INTERRUPT.incrementAndGet();\n+            \/\/ System.out.println(\"Got interrupted for \" + id + \": \" + e);\n+            throw new RuntimeException(e);\n+        } catch (Exception e) {\n+            FAILED.incrementAndGet();\n+            EXCEPTIONS.add(e);\n+            \/\/System.out.println(\"Got exception for \" + id + \": \" + e);\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @AfterAll\n+    static void tearDown() {\n+        try {\n+            System.gc();\n+            var error = TRACKER.check(5000);\n+            if (error != null) throw error;\n+        } finally {\n+            ServerSocket ss;\n+            synchronized (HttpGetInCancelledFuture.class) {\n+                ss = NOT_ACCEPTING;\n+                NOT_ACCEPTING = null;\n+            }\n+            if (ss != null) {\n+                try {\n+                    ss.close();\n+                } catch (IOException io) {\n+                    throw new UncheckedIOException(io);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpGetInCancelledFuture.java","additions":391,"deletions":0,"binary":false,"changes":391,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,0 +118,8 @@\n+    public AssertionError checkFinished(Tracker tracker, long graceDelayMs) {\n+        Predicate<Tracker> hasOperations = (t) -> t.getOutstandingOperations() > 0;\n+        Predicate<Tracker> hasSubscribers = (t) -> t.getOutstandingSubscribers() > 0;\n+        return check(tracker, graceDelayMs,\n+                hasOperations.or(hasSubscribers),\n+                \"outstanding operations or unreleased resources\", false);\n+    }\n+\n@@ -249,0 +257,5 @@\n+            if (i == 0 && waited == 0) {\n+                \/\/ we found nothing and didn't wait expecting success, but then found\n+                \/\/ something. Respin to make sure we wait.\n+                return check(tracker, graceDelayMs, hasOutstanding, description, printThreads);\n+            }\n@@ -305,0 +318,5 @@\n+            if (i == 0 && waited == 0) {\n+                \/\/ we found nothing and didn't wait expecting success, but then found\n+                \/\/ something. Respin to make sure we wait.\n+                return check(graceDelayMs, hasOutstanding, description, printThreads);\n+            }\n","filename":"test\/jdk\/java\/net\/httpclient\/ReferenceTracker.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,336 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.util.ArrayList;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestExchange;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestHandler;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/*\n+ * @test\n+ * @bug 8335181\n+ * @summary verify that the HttpClient correctly handles incoming GOAWAY frames and\n+ *          retries any unprocessed requests on a new connection\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *        jdk.test.lib.net.SimpleSSLContext\n+ * @run junit H2GoAwayTest\n+ *\/\n+public class H2GoAwayTest {\n+    private static final String REQ_PATH = \"\/test\";\n+    private static HttpTestServer server;\n+    private static String REQ_URI_BASE;\n+    private static SSLContext sslCtx;\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        sslCtx = new SimpleSSLContext().get();\n+        assertNotNull(sslCtx, \"SSLContext couldn't be created\");\n+        server = HttpTestServer.create(HTTP_2, sslCtx);\n+        server.addHandler(new Handler(), REQ_PATH);\n+        server.start();\n+        System.out.println(\"Server started at \" + server.getAddress());\n+        REQ_URI_BASE = URIBuilder.newBuilder().scheme(\"https\")\n+                .loopback()\n+                .port(server.getAddress().getPort())\n+                .path(REQ_PATH)\n+                .build().toString();\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        if (server != null) {\n+            System.out.println(\"Stopping server at \" + server.getAddress());\n+            server.stop();\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that when several requests are sent using send() and the server\n+     * connection is configured to send a GOAWAY after processing only a few requests, then\n+     * the remaining requests are retried on a different connection\n+     *\/\n+    @Test\n+    public void testSequential() throws Exception {\n+        final LimitedPerConnRequestApprover reqApprover = new LimitedPerConnRequestApprover();\n+        server.setRequestApprover(reqApprover::allowNewRequest);\n+        try (final HttpClient client = HttpClient.newBuilder().version(HTTP_2)\n+                .sslContext(sslCtx).build()) {\n+            final String[] reqMethods = {\"HEAD\", \"GET\", \"POST\"};\n+            for (final String reqMethod : reqMethods) {\n+                final int numReqs = LimitedPerConnRequestApprover.MAX_REQS_PER_CONN + 3;\n+                final Set<String> connectionKeys = new LinkedHashSet<>();\n+                for (int i = 1; i <= numReqs; i++) {\n+                    final URI reqURI = new URI(REQ_URI_BASE + \"?seq&\" + reqMethod + \"=\" + i);\n+                    final HttpRequest req = HttpRequest.newBuilder()\n+                            .uri(reqURI)\n+                            .method(reqMethod, HttpRequest.BodyPublishers.noBody())\n+                            .build();\n+                    System.out.println(\"initiating request \" + req);\n+                    final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n+                    final String respBody = resp.body();\n+                    System.out.println(\"received response: \" + respBody);\n+                    assertEquals(200, resp.statusCode(),\n+                            \"unexpected status code for request \" + resp.request());\n+                    \/\/ response body is the logical key of the connection on which the\n+                    \/\/ request was handled\n+                    connectionKeys.add(respBody);\n+                }\n+                System.out.println(\"connections involved in handling the requests: \"\n+                        + connectionKeys);\n+                \/\/ all requests have finished, we now just do a basic check that\n+                \/\/ more than one connection was involved in processing these requests\n+                assertEquals(2, connectionKeys.size(),\n+                        \"unexpected number of connections \" + connectionKeys);\n+            }\n+        } finally {\n+            server.setRequestApprover(null); \/\/ reset\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that when a server responds with a GOAWAY and then never processes the new retried\n+     * requests on a new connection too, then the application code receives the request failure.\n+     * This tests the send() API of the HttpClient.\n+     *\/\n+    @Test\n+    public void testUnprocessedRaisesException() throws Exception {\n+        try (final HttpClient client = HttpClient.newBuilder().version(HTTP_2)\n+                .sslContext(sslCtx).build()) {\n+            final Random random = new Random();\n+            final String[] reqMethods = {\"HEAD\", \"GET\", \"POST\"};\n+            for (final String reqMethod : reqMethods) {\n+                final int maxAllowedReqs = 2;\n+                final int numReqs = maxAllowedReqs + 3; \/\/ 3 more requests than max allowed\n+                \/\/ configure the approver\n+                final LimitedRequestApprover reqApprover = new LimitedRequestApprover(maxAllowedReqs);\n+                server.setRequestApprover(reqApprover::allowNewRequest);\n+                try {\n+                    int numSuccess = 0;\n+                    int numFailed = 0;\n+                    for (int i = 1; i <= numReqs; i++) {\n+                        final String reqQueryPart = \"?sync&\" + reqMethod + \"=\" + i;\n+                        final URI reqURI = new URI(REQ_URI_BASE + reqQueryPart);\n+                        final HttpRequest req = HttpRequest.newBuilder()\n+                                .uri(reqURI)\n+                                .method(reqMethod, HttpRequest.BodyPublishers.noBody())\n+                                .build();\n+                        System.out.println(\"initiating request \" + req);\n+                        if (i <= maxAllowedReqs) {\n+                            \/\/ expected to successfully complete\n+                            numSuccess++;\n+                            final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n+                            final String respBody = resp.body();\n+                            System.out.println(\"received response: \" + respBody);\n+                            assertEquals(200, resp.statusCode(),\n+                                    \"unexpected status code for request \" + resp.request());\n+                        } else {\n+                            \/\/ expected to fail as unprocessed\n+                            try {\n+                                final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n+                                fail(\"Request was expected to fail as unprocessed,\"\n+                                        + \" but got response: \" + resp.body() + \", status code: \"\n+                                        + resp.statusCode());\n+                            } catch (IOException ioe) {\n+                                \/\/ verify it failed for the right reason\n+                                if (ioe.getMessage() == null\n+                                        || !ioe.getMessage().contains(\"request not processed by peer\")) {\n+                                    \/\/ propagate the original failure\n+                                    throw ioe;\n+                                }\n+                                numFailed++; \/\/ failed due to right reason\n+                                System.out.println(\"received expected failure: \" + ioe\n+                                        + \", for request \" + reqURI);\n+                            }\n+                        }\n+                    }\n+                    \/\/ verify the correct number of requests succeeded\/failed\n+                    assertEquals(maxAllowedReqs, numSuccess, \"unexpected number of requests succeeded\");\n+                    assertEquals((numReqs - maxAllowedReqs), numFailed, \"unexpected number of requests failed\");\n+                } finally {\n+                    server.setRequestApprover(null); \/\/ reset\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that when a server responds with a GOAWAY and then never processes the new retried\n+     * requests on a new connection too, then the application code receives the request failure.\n+     * This tests the sendAsync() API of the HttpClient.\n+     *\/\n+    @Test\n+    public void testUnprocessedRaisesExceptionAsync() throws Throwable {\n+        try (final HttpClient client = HttpClient.newBuilder().version(HTTP_2)\n+                .sslContext(sslCtx).build()) {\n+            final Random random = new Random();\n+            final String[] reqMethods = {\"HEAD\", \"GET\", \"POST\"};\n+            for (final String reqMethod : reqMethods) {\n+                final int maxAllowedReqs = 2;\n+                final int numReqs = maxAllowedReqs + 3; \/\/ 3 more requests than max allowed\n+                \/\/ configure the approver\n+                final LimitedRequestApprover reqApprover = new LimitedRequestApprover(maxAllowedReqs);\n+                server.setRequestApprover(reqApprover::allowNewRequest);\n+                try {\n+                    final List<Future<HttpResponse<String>>> futures = new ArrayList<>();\n+                    for (int i = 1; i <= numReqs; i++) {\n+                        final URI reqURI = new URI(REQ_URI_BASE + \"?async&\" + reqMethod + \"=\" + i);\n+                        final HttpRequest req = HttpRequest.newBuilder()\n+                                .uri(reqURI)\n+                                .method(reqMethod, HttpRequest.BodyPublishers.noBody())\n+                                .build();\n+                        System.out.println(\"initiating request \" + req);\n+                        final Future<HttpResponse<String>> f = client.sendAsync(req, BodyHandlers.ofString());\n+                        futures.add(f);\n+                    }\n+                    \/\/ wait for responses\n+                    int numFailed = 0;\n+                    int numSuccess = 0;\n+                    for (int i = 1; i <= numReqs; i++) {\n+                        final String reqQueryPart = \"?async&\" + reqMethod + \"=\" + i;\n+                        try {\n+                            System.out.println(\"waiting response of request \"\n+                                    + REQ_URI_BASE + reqQueryPart);\n+                            final HttpResponse<String> resp = futures.get(i - 1).get();\n+                            numSuccess++;\n+                            final String respBody = resp.body();\n+                            System.out.println(\"request: \" + resp.request()\n+                                    + \", received response: \" + respBody);\n+                            assertEquals(200, resp.statusCode(),\n+                                    \"unexpected status code for request \" + resp.request());\n+                        } catch (ExecutionException ee) {\n+                            final Throwable cause = ee.getCause();\n+                            if (!(cause instanceof IOException ioe)) {\n+                                throw cause;\n+                            }\n+                            \/\/ verify it failed for the right reason\n+                            if (ioe.getMessage() == null\n+                                    || !ioe.getMessage().contains(\"request not processed by peer\")) {\n+                                \/\/ propagate the original failure\n+                                throw ioe;\n+                            }\n+                            numFailed++; \/\/ failed due to the right reason\n+                            System.out.println(\"received expected failure: \" + ioe\n+                                    + \", for request \" + REQ_URI_BASE + reqQueryPart);\n+                        }\n+                    }\n+                    \/\/ verify the correct number of requests succeeded\/failed\n+                    assertEquals(maxAllowedReqs, numSuccess, \"unexpected number of requests succeeded\");\n+                    assertEquals((numReqs - maxAllowedReqs), numFailed, \"unexpected number of requests failed\");\n+                } finally {\n+                    server.setRequestApprover(null); \/\/ reset\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ only allows fixed number of requests, irrespective of which server connection handles\n+    \/\/ it. requests that are rejected will either be sent a GOAWAY on the connection\n+    \/\/ or a RST_FRAME with a REFUSED_STREAM on the stream\n+    private static final class LimitedRequestApprover {\n+        private final int maxAllowedReqs;\n+        private final AtomicInteger numApproved = new AtomicInteger();\n+\n+        private LimitedRequestApprover(final int maxAllowedReqs) {\n+            this.maxAllowedReqs = maxAllowedReqs;\n+        }\n+\n+        public boolean allowNewRequest(final String serverConnKey) {\n+            final int approved = numApproved.incrementAndGet();\n+            return approved <= maxAllowedReqs;\n+        }\n+    }\n+\n+    \/\/ allows a certain number of requests per server connection.\n+    \/\/ requests that are rejected will either be sent a GOAWAY on the connection\n+    \/\/ or a RST_FRAME with a REFUSED_STREAM on the stream\n+    private static final class LimitedPerConnRequestApprover {\n+        private static final int MAX_REQS_PER_CONN = 6;\n+        private final Map<String, AtomicInteger> numApproved =\n+                new ConcurrentHashMap<>();\n+        private final Map<String, AtomicInteger> numDisapproved =\n+                new ConcurrentHashMap<>();\n+\n+        public boolean allowNewRequest(final String serverConnKey) {\n+            final AtomicInteger approved = numApproved.computeIfAbsent(serverConnKey,\n+                    (k) -> new AtomicInteger());\n+            int curr = approved.get();\n+            while (curr < MAX_REQS_PER_CONN) {\n+                if (approved.compareAndSet(curr, curr + 1)) {\n+                    return true; \/\/ new request allowed\n+                }\n+                curr = approved.get();\n+            }\n+            final AtomicInteger disapproved = numDisapproved.computeIfAbsent(serverConnKey,\n+                    (k) -> new AtomicInteger());\n+            final int numUnprocessed = disapproved.incrementAndGet();\n+            System.out.println(approved.get() + \" processed, \"\n+                    + numUnprocessed + \" unprocessed requests on connection \" + serverConnKey);\n+            return false;\n+        }\n+    }\n+\n+    private static final class Handler implements HttpTestHandler {\n+\n+        @Override\n+        public void handle(final HttpTestExchange exchange) throws IOException {\n+            final String connectionKey = exchange.getConnectionKey();\n+            System.out.println(\"responding to request: \" + exchange.getRequestURI()\n+                    + \" on connection \" + connectionKey);\n+            final byte[] response = connectionKey.getBytes(UTF_8);\n+            exchange.sendResponseHeaders(200, response.length);\n+            try (final OutputStream os = exchange.getResponseBody()) {\n+                os.write(response);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/H2GoAwayTest.java","additions":336,"deletions":0,"binary":false,"changes":336,"status":"added"},{"patch":"@@ -61,0 +61,1 @@\n+import java.util.function.Predicate;\n@@ -243,0 +244,1 @@\n+        public abstract String getConnectionKey();\n@@ -257,1 +259,1 @@\n-            return new Http2TestExchangeImpl(exchange);\n+            return new H2ExchangeImpl(exchange);\n@@ -313,0 +315,6 @@\n+\n+            @Override\n+            public String getConnectionKey() {\n+                return exchange.getLocalAddress() + \"->\" + exchange.getRemoteAddress();\n+            }\n+\n@@ -319,1 +327,1 @@\n-        private static final class Http2TestExchangeImpl extends HttpTestExchange {\n+        private static final class H2ExchangeImpl extends HttpTestExchange {\n@@ -321,1 +329,1 @@\n-            Http2TestExchangeImpl(Http2TestExchange exch) {\n+            H2ExchangeImpl(Http2TestExchange exch) {\n@@ -374,0 +382,5 @@\n+            @Override\n+            public String getConnectionKey() {\n+                return exchange.getConnectionKey();\n+            }\n+\n@@ -719,0 +732,1 @@\n+        public abstract void setRequestApprover(final Predicate<String> approver);\n@@ -867,0 +881,5 @@\n+\n+            @Override\n+            public void setRequestApprover(final Predicate<String> approver) {\n+                throw new UnsupportedOperationException(\"not supported\");\n+            }\n@@ -918,0 +937,5 @@\n+\n+            @Override\n+            public void setRequestApprover(final Predicate<String> approver) {\n+                this.impl.setRequestApprover(approver);\n+            }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/common\/HttpServerAdapters.java","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,0 +87,6 @@\n+\n+    \/**\n+     * {@return the identification of the connection on which this exchange is being\n+     * processed}\n+     *\/\n+    String getConnectionKey();\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchange.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -230,0 +230,5 @@\n+    @Override\n+    public String getConnectionKey() {\n+        return conn.connectionKey();\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchangeImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import java.util.function.Predicate;\n+\n@@ -62,0 +64,2 @@\n+    \/\/ request approver which takes the server connection key as the input\n+    private volatile Predicate<String> newRequestApprover;\n@@ -288,0 +292,8 @@\n+    public void setRequestApprover(final Predicate<String> approver) {\n+        this.newRequestApprover = approver;\n+    }\n+\n+    Predicate<String> getRequestApprover() {\n+        return this.newRequestApprover;\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServer.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+import java.util.Set;\n@@ -83,0 +84,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -86,0 +88,1 @@\n+import java.util.function.Predicate;\n@@ -89,0 +92,1 @@\n+import static jdk.internal.net.http.frame.ErrorFrame.REFUSED_STREAM;\n@@ -118,0 +122,4 @@\n+    \/\/ the max stream id of a processed H2 request. -1 implies none were processed.\n+    private final AtomicInteger maxProcessedRequestStreamId = new AtomicInteger(-1);\n+    \/\/ the stream id that was sent in a GOAWAY frame. -1 implies no GOAWAY frame was sent.\n+    private final AtomicInteger goAwayRequestStreamId = new AtomicInteger(-1);\n@@ -242,5 +250,23 @@\n-    void goAway(int error) throws IOException {\n-        int laststream = nextstream >= 3 ? nextstream - 2 : 1;\n-\n-        GoAwayFrame go = new GoAwayFrame(laststream, error);\n-        outputQ.put(go);\n+    private void sendGoAway(final int error) throws IOException {\n+        int maxProcessedStreamId = maxProcessedRequestStreamId.get();\n+        if (maxProcessedStreamId == -1) {\n+            maxProcessedStreamId = 0;\n+        }\n+        boolean send = false;\n+        int currentGoAwayReqStrmId = goAwayRequestStreamId.get();\n+        \/\/ update the last processed stream id and send a goaway frame if the new last processed\n+        \/\/ stream id is lesser than the last processed stream id sent in\n+        \/\/ a previous goaway frame (if any)\n+        while (currentGoAwayReqStrmId == -1 || maxProcessedStreamId < currentGoAwayReqStrmId) {\n+            if (goAwayRequestStreamId.compareAndSet(currentGoAwayReqStrmId, maxProcessedStreamId)) {\n+                send = true;\n+                break;\n+            }\n+            currentGoAwayReqStrmId = goAwayRequestStreamId.get();\n+        }\n+        if (!send) {\n+            return;\n+        }\n+        final GoAwayFrame frame = new GoAwayFrame(maxProcessedStreamId, error);\n+        outputQ.put(frame);\n+        System.err.println(\"Sending GOAWAY frame \" + frame + \" from server connection \" + this);\n@@ -339,2 +365,3 @@\n-            if (error != -1)\n-                goAway(error);\n+            if (error != -1) {\n+                sendGoAway(error);\n+            }\n@@ -622,0 +649,8 @@\n+        \/\/ skip processing the request if configured to do so\n+        final String connKey = connectionKey();\n+        if (!shouldProcessNewHTTPRequest(connKey)) {\n+            System.err.println(\"Rejecting primordial stream 1 and sending GOAWAY\" +\n+                    \" on server connection \" + connKey + \", for request: \" + path);\n+            sendGoAway(ErrorFrame.NO_ERROR);\n+            return;\n+        }\n@@ -630,0 +665,1 @@\n+        maxProcessedRequestStreamId.set(1);\n@@ -635,0 +671,12 @@\n+    private boolean shouldProcessNewHTTPRequest(final String serverConnKey) {\n+        final Predicate<String> approver = this.server.getRequestApprover();\n+        if (approver == null) {\n+            return true; \/\/ process the request\n+        }\n+        return approver.test(serverConnKey);\n+    }\n+\n+    final String connectionKey() {\n+        return this.server.getAddress() + \"->\" + this.socket.getRemoteSocketAddress();\n+    }\n+\n@@ -642,1 +690,1 @@\n-            throw new IOException(\"unexpected stream id\");\n+            throw new IOException(\"unexpected stream id: \" + streamid);\n@@ -673,1 +721,1 @@\n-        if (disallowedHeader.isPresent())\n+        if (disallowedHeader.isPresent()) {\n@@ -675,0 +723,1 @@\n+        }\n@@ -676,1 +725,10 @@\n-\n+        \/\/ skip processing the request if the server is configured to do so\n+        final String connKey = connectionKey();\n+        final String path = headers.firstValue(\":path\").orElse(\"\");\n+        if (!shouldProcessNewHTTPRequest(connKey)) {\n+            System.err.println(\"Rejecting stream \" + streamid\n+                    + \" and sending GOAWAY on server connection \"\n+                    + connKey + \", for request: \" + path);\n+            sendGoAway(ErrorFrame.NO_ERROR);\n+            return;\n+        }\n@@ -679,0 +737,8 @@\n+        \/\/ keep track of the largest request id that we have processed\n+        int currentLargest = maxProcessedRequestStreamId.get();\n+        while (streamid > currentLargest) {\n+            if (maxProcessedRequestStreamId.compareAndSet(currentLargest, streamid)) {\n+                break;\n+            }\n+            currentLargest = maxProcessedRequestStreamId.get();\n+        }\n@@ -781,0 +847,2 @@\n+                    System.err.println(\"EOF reached on connection \" + connectionKey()\n+                            + \", will no longer accept incoming frames\");\n@@ -804,0 +872,11 @@\n+                            final int streamId = frame.streamid();\n+                            final int finalProcessedStreamId = goAwayRequestStreamId.get();\n+                            \/\/ if we already sent a goaway, then don't create new streams with\n+                            \/\/ higher stream ids.\n+                            if (finalProcessedStreamId != -1 && streamId > finalProcessedStreamId) {\n+                                System.err.println(connectionKey() + \" resetting stream \" + streamId\n+                                        + \" as REFUSED_STREAM\");\n+                                final ResetFrame rst = new ResetFrame(streamId, REFUSED_STREAM);\n+                                outputQ.put(rst);\n+                                continue;\n+                            }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":89,"deletions":10,"binary":false,"changes":99,"status":"modified"}]}