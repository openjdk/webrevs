{"files":[{"patch":"@@ -111,0 +111,21 @@\n+    \/**\n+     * Accepts a single pair composed of a platform string followed by a true\/false\n+     * value where a true value necessitates that we are currently testing on that platform and vice-versa.\n+     * IR checks are enforced only if the specified platform constraint is met.\n+     *\/\n+    String[] applyIfPlatform() default {};\n+\n+    \/**\n+     * Accepts a list of pairs where each pair is composed of a platform string followed by a true\/false\n+     * value where a true value necessitates that we are currently testing on that platform and vice-versa.\n+     * IR checks are enforced only if all the specified platform constraints are met.\n+     *\/\n+    String[] applyIfPlatformAnd() default {};\n+\n+    \/**\n+     * Accepts a list of pairs where each pair is composed of a platform string followed by a true\/false\n+     * value where a true value necessitates that we are currently testing on that platform and vice-versa.\n+     * IR checks are enforced if any of the specified platform constraints are met.\n+     *\/\n+    String[] applyIfPlatformOr() default {};\n+\n@@ -113,1 +134,1 @@\n-     * value where a true value necessities existence of CPU feature and vice-versa.\n+     * value where a true value necessitates existence of CPU feature and vice-versa.\n@@ -120,1 +141,1 @@\n-     * value where a true value necessities existence of target feature and vice-versa.\n+     * value where a true value necessitates existence of target feature and vice-versa.\n@@ -127,1 +148,1 @@\n-     * value where a true value necessities existence of target feature and vice-versa.\n+     * value where a true value necessitates existence of target feature and vice-versa.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IR.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -131,0 +131,5 @@\n+#### Disable\/Enable IR Rules based on Platform\n+`@IR` rules based on the platform can be specified using `applyIfPlatformXXX` in [@IR](.\/IR.java). A reference for using these attributes can be found in [TestPlatformChecks](..\/..\/..\/testlibrary_tests\/ir_framework\/tests\/TestPlatformChecks.java) (internal framework test).\n+\n+Platform attributes are evaluated as a logical conjunction, and take precedence over VM Flag attributes. An example with both `applyIfPlatformXXX` and `applyIfXXX` can be found in [TestPreconditions](..\/..\/..\/testlibrary_tests\/ir_framework\/tests\/TestPreconditions.java) (internal framework test).\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/README.md","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.test.lib.Platform;\n@@ -58,0 +59,21 @@\n+    \/\/ Platforms for use in IR preconditions. Please verify that e.g. there is\n+    \/\/ a corresponding use in a jtreg @requires annotation before adding new platforms,\n+    \/\/ as adding non-existent platforms can lead to skipped tests.\n+    private static final List<String> irTestingPlatforms = new ArrayList<String>(Arrays.asList(\n+        \/\/ os.family\n+        \"linux\",\n+        \"mac\",\n+        \"windows\",\n+        \/\/ vm.simpleArch\n+        \"aarch64\",\n+        \"arm\",\n+        \"ppc\",\n+        \"riscv64\",\n+        \"s390\",\n+        \"x64\",\n+        \"x86\",\n+        \/\/ corresponds to vm.bits\n+        \"32-bit\",\n+        \"64-bit\"\n+    ));\n+\n@@ -137,0 +159,9 @@\n+        } else if (irAnno.applyIfPlatform().length != 0 && !hasAllRequiredPlatform(irAnno.applyIfPlatform())) {\n+            printDisableReason(m, \"Constraint not met (applyIfPlatform)\", irAnno.applyIfPlatform(), ruleIndex, ruleMax);\n+            return false;\n+        } else if (irAnno.applyIfPlatformAnd().length != 0 && !hasAllRequiredPlatform(irAnno.applyIfPlatformAnd())) {\n+            printDisableReason(m, \"Not all constraints are met (applyIfPlatformAnd)\", irAnno.applyIfPlatformAnd(), ruleIndex, ruleMax);\n+            return false;\n+        } else if (irAnno.applyIfPlatformOr().length != 0 && !hasAnyRequiredPlatform(irAnno.applyIfPlatformOr())) {\n+            printDisableReason(m, \"None of the constraints are met (applyIfPlatformOr)\", irAnno.applyIfPlatformOr(), ruleIndex, ruleMax);\n+            return false;\n@@ -168,0 +199,1 @@\n+        int platformConstraints = 0;\n@@ -184,0 +216,15 @@\n+        if (irAnno.applyIfPlatform().length != 0) {\n+            platformConstraints++;\n+            TestFormat.checkNoThrow(irAnno.applyIfPlatform().length == 2,\n+                                    \"applyIfPlatform expects single platform pair\" + failAt());\n+        }\n+        if (irAnno.applyIfPlatformAnd().length != 0) {\n+            platformConstraints++;\n+            TestFormat.checkNoThrow(irAnno.applyIfPlatformAnd().length % 2 == 0,\n+                                    \"applyIfPlatformAnd expects more than one platform pair\" + failAt());\n+        }\n+        if (irAnno.applyIfPlatformOr().length != 0) {\n+            platformConstraints++;\n+            TestFormat.checkNoThrow(irAnno.applyIfPlatformOr().length % 2 == 0,\n+                                    \"applyIfPlatformOr expects more than one platform pair\" + failAt());\n+        }\n@@ -205,0 +252,1 @@\n+        TestFormat.checkNoThrow(platformConstraints <= 1, \"Can only specify one platform constraint\" + failAt());\n@@ -238,0 +286,76 @@\n+    private boolean hasAllRequiredPlatform(String[] andRules) {\n+        boolean returnValue = true;\n+        for (int i = 0; i < andRules.length; i++) {\n+            String platform = andRules[i].trim();\n+            i++;\n+            String value = andRules[i].trim();\n+            returnValue &= checkPlatform(platform, value);\n+        }\n+        return returnValue;\n+    }\n+\n+    private boolean hasAnyRequiredPlatform(String[] orRules) {\n+        boolean returnValue = false;\n+        for (int i = 0; i < orRules.length; i++) {\n+            String platform = orRules[i].trim();\n+            i++;\n+            String value = orRules[i].trim();\n+            returnValue |= checkPlatform(platform, value);\n+        }\n+        return returnValue;\n+    }\n+\n+    private boolean checkPlatform(String platform, String value) {\n+        if (platform.isEmpty()) {\n+            TestFormat.failNoThrow(\"Provided empty platform\" + failAt());\n+            return false;\n+        }\n+        if (value.isEmpty()) {\n+            TestFormat.failNoThrow(\"Provided empty value for platform \" + platform + failAt());\n+            return false;\n+        }\n+\n+        if (!irTestingPlatforms.contains(platform)) {\n+            TestFormat.failNoThrow(\"Provided platform is not in verified list: \" + platform + failAt());\n+            return false;\n+        }\n+\n+        boolean trueValue = value.contains(\"true\");\n+        boolean falseValue = value.contains(\"false\");\n+\n+        if (!trueValue && !falseValue) {\n+            TestFormat.failNoThrow(\"Provided incorrect value for platform \" + platform + failAt());\n+            return false;\n+        }\n+\n+        String os = \"\";\n+        if (Platform.isLinux()) {\n+            os = \"linux\";\n+        } else if (Platform.isOSX()) {\n+            os = \"mac\";\n+        } else if (Platform.isWindows()) {\n+            os = \"windows\";\n+        }\n+\n+        String arch = \"\";\n+        if (Platform.isAArch64()) {\n+            arch = \"aarch64\";\n+        } else if (Platform.isARM()) {\n+            arch = \"arm\";\n+        } else if (Platform.isPPC()) {\n+            arch = \"ppc\";\n+        } else if (Platform.isRISCV64()) {\n+            arch = \"riscv64\";\n+        } else if (Platform.isS390x()) {\n+            arch = \"s390\";\n+        } else if (Platform.isX64()) {\n+            arch = \"x64\";\n+        } else if (Platform.isX86()) {\n+            arch = \"x86\";\n+        }\n+\n+        String currentPlatform = os + \" \" + arch + \" \" + (Platform.is32bit() ? \"32-bit\" : \"64-bit\");\n+\n+        return (trueValue && currentPlatform.contains(platform)) || (falseValue && !currentPlatform.contains(platform));\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @requires vm.bits == \"64\"\n@@ -96,1 +95,2 @@\n-    @IR(applyIfCPUFeature = {\"avx2\", \"true\"},\n+    @IR(applyIfPlatform = {\"32-bit\", \"false\"},\n+        applyIfCPUFeature = {\"avx2\", \"true\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/SumRed_Long.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n+\n+\/*\n+ * @test 8280120\n+ * @summary Add attribute to IR to enable\/disable IR matching based on the architecture\n+ * @library \/test\/lib \/\n+ * @run driver ir_framework.tests.TestPlatformChecks\n+ *\/\n+\n+public class TestPlatformChecks {\n+    private static final int SIZE = 1000;\n+    private static int[] a = new int[SIZE];\n+    private static int[] b = new int[SIZE];\n+    private static int[] res = new int[SIZE];\n+\n+    public static void setup() {\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = i;\n+            b[i] = i;\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        setup();\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\"},\n+        applyIfPlatform = {\"x64\", \"true\"},\n+        applyIfCPUFeature = {\"sse4.1\", \"true\"})\n+    public static void test1() {\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] + b[i];\n+        }\n+    }\n+\n+    \/\/ IR rule is enforced if all the platform constraints hold\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\"},\n+        applyIfPlatformAnd = {\"x64\", \"true\", \"linux\", \"true\"},\n+        applyIfCPUFeatureAnd = {\"sse4.1\", \"true\", \"avx2\", \"true\"})\n+    public static void test2() {\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] + b[i];\n+        }\n+    }\n+\n+    \/\/ IR rule is enforced if any of the platform constraints hold\n+    @Test\n+    @IR(counts = {IRNode.ADD_VI, \"> 0\"},\n+        applyIfPlatformOr = {\"linux\", \"true\", \"mac\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"avx2\", \"true\"})\n+    public static void test3() {\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = a[i] + b[i];\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPlatformChecks.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -84,0 +84,44 @@\n+\n+    \/\/ The IR check should not be applied, since OS can not be both linux and mac.\n+    @Test\n+    @IR(applyIfPlatformAnd = {\"linux\", \"true\", \"mac\", \"true\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyBothOs() {}\n+\n+    \/\/ The IR check should not be applied, since we can't have both 32-bit and 64-bit data model.\n+    @Test\n+    @IR(applyIfPlatformAnd = {\"32-bit\", \"true\", \"64-bit\", \"true\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyBothDataModel() {}\n+\n+    \/\/ The IR check should not be applied, since the arch can't be both x64 and aarch64.\n+    @Test\n+    @IR(applyIfPlatformAnd = {\"x64\", \"true\", \"aarch64\", \"true\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyBothArch() {}\n+\n+    \/\/ Platform versions of testApplyBoth2\/3.\n+    @Test\n+    @IR(applyIfPlatform = {\"aarch64\", \"true\"},\n+        applyIfAnd = {\"UseSVE\", \"= 0\", \"LoopMaxUnroll\", \"= 0\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyPlatformSVE() {}\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"},\n+        applyIfAnd = {\"UseAVX\", \"= 2\", \"LoopMaxUnroll\", \"= 0\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyPlatformAVX() {}\n+\n+    @Test\n+    @IR(applyIfPlatformAnd = {\"x64\", \"true\", \"linux\", \"true\"},\n+        applyIfAnd = {\"UseAVX\", \"= 2\", \"LoopMaxUnroll\", \"= 0\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyPlatformAVXAnd() {}\n+\n+    @Test\n+    @IR(applyIfPlatformOr = {\"x64\", \"true\", \"x86\", \"true\"},\n+        applyIfAnd = {\"UseSSE\", \"= 4\", \"LoopMaxUnroll\", \"= 0\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyPlatformSSEOr() {}\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPreconditions.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"}]}