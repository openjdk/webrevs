{"files":[{"patch":"@@ -1724,2 +1724,2 @@\n-    st->print(\"ldr zr, [lr]\\n\\t\");\n-    st->print(\"pacia  lr, rfp\\n\\t\");\n+    st->print(\"ldr  zr, [lr]\\n\\t\");\n+    st->print(\"paciaz\\n\\t\");\n@@ -1854,2 +1854,2 @@\n-    st->print(\"autia lr, rfp\\n\\t\");\n-    st->print(\"ldr zr, [lr]\\n\\t\");\n+    st->print(\"autiaz\\n\\t\");\n+    st->print(\"ldr  zr, [lr]\\n\\t\");\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -388,1 +388,1 @@\n-    __ authenticate_return_address(exception_pc, rscratch1);\n+    __ authenticate_return_address(exception_pc);\n@@ -437,1 +437,1 @@\n-  __ protect_return_address(exception_pc, rscratch1);\n+  __ protect_return_address(exception_pc);\n@@ -453,1 +453,1 @@\n-  __ protect_return_address(r0, rscratch1);\n+  __ protect_return_address(r0);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  address sender_pc = (address) *(sender_sp-1);\n+  address sender_pc = ContinuationHelper::return_address_at(sender_sp - 1);\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,0 +71,11 @@\n+#define CPU_OVERRIDES_RETURN_ADDRESS_ACCESSORS\n+\n+inline address ContinuationHelper::return_address_at(intptr_t* sp) {\n+  return pauth_strip_verifiable(*(address*)sp);\n+}\n+\n+inline void ContinuationHelper::patch_return_address_at(intptr_t* sp,\n+                                                        address pc) {\n+  *(address*)sp = pauth_sign_return_address(pc);\n+}\n+\n@@ -83,1 +94,2 @@\n-  address pc = *(address*)(sp - frame::sender_sp_ret_address_offset());\n+  address pc = ContinuationHelper::return_address_at(\n+                 sp - frame::sender_sp_ret_address_offset());\n@@ -111,0 +123,1 @@\n+  \/\/ Always used in assertions. Just strip it.\n@@ -112,1 +125,1 @@\n-  return *pc_addr;\n+  return pauth_strip_pointer(*pc_addr);\n@@ -117,1 +130,1 @@\n-  *pc_addr = pc;\n+  *pc_addr = pauth_sign_return_address(pc);\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationHelper_aarch64.inline.hpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -142,2 +142,1 @@\n-      sender_pc = pauth_strip_verifiable((address) this->fp()[return_addr_offset], (address)saved_fp);\n-\n+      sender_pc = pauth_strip_verifiable((address) this->fp()[return_addr_offset]);\n@@ -161,1 +160,3 @@\n-      sender_pc = pauth_strip_verifiable((address) *(sender_sp-1), (address)saved_fp);\n+      \/\/ Note: PAC authentication may fail in case broken frame is passed in.\n+      \/\/ Just strip it for now.\n+      sender_pc = pauth_strip_pointer((address) *(sender_sp - 1));\n@@ -279,3 +280,2 @@\n-  address signing_sp = (((address*) sp())[-2]);\n-  address signed_pc = pauth_sign_return_address(pc, (address)signing_sp);\n-  address pc_old = pauth_strip_verifiable(*pc_addr, (address)signing_sp);\n+  address signed_pc = pauth_sign_return_address(pc);\n+  address pc_old = pauth_strip_verifiable(*pc_addr);\n@@ -475,2 +475,3 @@\n-  \/\/ For ROP protection, Interpreter will have signed the sender_pc, but there is no requirement to authenticate it here.\n-  address sender_pc = pauth_strip_verifiable(sender_pc_maybe_signed(), (address)link());\n+  \/\/ For ROP protection, Interpreter will have signed the sender_pc,\n+  \/\/ but there is no requirement to authenticate it here.\n+  address sender_pc = pauth_strip_verifiable(sender_pc_maybe_signed());\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -155,1 +155,4 @@\n-inline frame::frame(intptr_t* sp) : frame(sp, sp, *(intptr_t**)(sp - frame::sender_sp_offset), *(address*)(sp - 1)) {}\n+inline frame::frame(intptr_t* sp)\n+  : frame(sp, sp,\n+          *(intptr_t**)(sp - frame::sender_sp_offset),\n+          pauth_strip_verifiable(*(address*)(sp - 1))) {}\n@@ -419,3 +422,4 @@\n-  \/\/ the return_address is always the word on the stack\n-  \/\/ For ROP protection, C1\/C2 will have signed the sender_pc, but there is no requirement to authenticate it here.\n-  address sender_pc = pauth_strip_verifiable((address) *(l_sender_sp-1), (address) *(l_sender_sp-2));\n+  \/\/ The return_address is always the word on the stack.\n+  \/\/ For ROP protection, C1\/C2 will have signed the sender_pc,\n+  \/\/ but there is no requirement to authenticate it here.\n+  address sender_pc = pauth_strip_verifiable((address) *(l_sender_sp - 1));\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -5981,1 +5981,1 @@\n-\/\/ Uses the FP as the modifier.\n+\/\/ Uses value zero as the modifier.\n@@ -5986,4 +5986,1 @@\n-    \/\/ The standard convention for C code is to use paciasp, which uses SP as the modifier. This\n-    \/\/ works because in C code, FP and SP match on function entry. In the JDK, SP and FP may not\n-    \/\/ match, so instead explicitly use the FP.\n-    pacia(lr, rfp);\n+    paciaz();\n@@ -5995,2 +5992,1 @@\n-\/\/ Uses the FP from the start of the function as the modifier - which is stored at the address of\n-\/\/ the current FP.\n+\/\/ Uses value zero as the modifier.\n@@ -5998,1 +5994,1 @@\n-void MacroAssembler::protect_return_address(Register return_reg, Register temp_reg) {\n+void MacroAssembler::protect_return_address(Register return_reg) {\n@@ -6000,1 +5996,0 @@\n-    assert(PreserveFramePointer, \"PreserveFramePointer must be set for ROP protection\");\n@@ -6002,2 +5997,1 @@\n-    ldr(temp_reg, Address(rfp));\n-    pacia(return_reg, temp_reg);\n+    paciza(return_reg);\n@@ -6008,0 +6002,1 @@\n+\/\/ Uses value zero as the modifier.\n@@ -6009,1 +6004,1 @@\n-void MacroAssembler::authenticate_return_address(Register return_reg) {\n+void MacroAssembler::authenticate_return_address() {\n@@ -6011,2 +6006,2 @@\n-    autia(return_reg, rfp);\n-    check_return_address(return_reg);\n+    autiaz();\n+    check_return_address();\n@@ -6018,2 +6013,1 @@\n-\/\/ Uses the FP from the start of the function as the modifier - which is stored at the address of\n-\/\/ the current FP.\n+\/\/ Uses value zero as the modifier.\n@@ -6021,1 +6015,1 @@\n-void MacroAssembler::authenticate_return_address(Register return_reg, Register temp_reg) {\n+void MacroAssembler::authenticate_return_address(Register return_reg) {\n@@ -6023,3 +6017,1 @@\n-    assert(PreserveFramePointer, \"PreserveFramePointer must be set for ROP protection\");\n-    ldr(temp_reg, Address(rfp));\n-    autia(return_reg, temp_reg);\n+    autiza(return_reg);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -719,3 +719,3 @@\n-  void protect_return_address(Register return_reg, Register temp_reg);\n-  void authenticate_return_address(Register return_reg = lr);\n-  void authenticate_return_address(Register return_reg, Register temp_reg);\n+  void protect_return_address(Register return_reg);\n+  void authenticate_return_address();\n+  void authenticate_return_address(Register return_reg);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2023, Arm Limited. All rights reserved.\n@@ -80,1 +80,1 @@\n-inline address pauth_strip_verifiable(address ret_addr, address modifier) {\n+inline address pauth_strip_verifiable(address ret_addr) {\n@@ -82,1 +82,1 @@\n-    DEBUG_ONLY(ret_addr = pauth_authenticate_return_address(ret_addr, modifier);)\n+    DEBUG_ONLY(ret_addr = pauth_authenticate_return_address(ret_addr);)\n","filename":"src\/hotspot\/cpu\/aarch64\/pauth_aarch64.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -397,1 +397,1 @@\n-  __ authenticate_return_address(c_rarg1, rscratch1);\n+  __ authenticate_return_address(c_rarg1);\n@@ -1174,0 +1174,1 @@\n+      __ authenticate_return_address(c_rarg1);\n@@ -2340,1 +2341,1 @@\n-  __ protect_return_address(r3, rscratch1);\n+  __ protect_return_address(r3);\n@@ -2446,3 +2447,1 @@\n-  __ ldp(rfp, lr, __ post(sp, 2 * wordSize));\n-  __ authenticate_return_address();\n-  \/\/ LR should now be the return address to the caller (3)\n+  __ ldp(rfp, zr, __ post(sp, 2 * wordSize));\n@@ -2663,3 +2662,1 @@\n-  __ ldp(rfp, lr, __ post(sp, 2 * wordSize));\n-  __ authenticate_return_address();\n-  \/\/ LR should now be the return address to the caller (3) frame\n+  __ ldp(rfp, zr, __ post(sp, 2 * wordSize));\n@@ -2811,1 +2808,1 @@\n-    __ protect_return_address(r20, rscratch1);\n+    __ protect_return_address(r20);\n@@ -2852,1 +2849,1 @@\n-    __ authenticate_return_address(r20, rscratch1);\n+    __ authenticate_return_address(r20);\n@@ -2867,1 +2864,1 @@\n-    __ protect_return_address(r20, rscratch1);\n+    __ protect_return_address(r20);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"pauth_aarch64.hpp\"\n@@ -55,1 +56,2 @@\n-  return *(address*)(_sp - 1);\n+  \/\/ Just strip it for frames on the heap.\n+  return pauth_strip_pointer(*(address*)(_sp - 1));\n","filename":"src\/hotspot\/cpu\/aarch64\/stackChunkFrameStream_aarch64.inline.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7011,0 +7011,1 @@\n+      __ authenticate_return_address(c_rarg1);\n@@ -7012,1 +7013,2 @@\n-      __ mov(r19, r0); \/\/ save return value contaning the exception oop in callee-saved R19\n+      \/\/ save return value containing the exception oop in callee-saved R19\n+      __ mov(r19, r0);\n@@ -7022,1 +7024,1 @@\n-      __ mov(r0, r19); \/\/ restore return value contaning the exception oop\n+      __ mov(r0, r19); \/\/ restore return value containing the exception oop\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1826,1 +1826,1 @@\n-    __ authenticate_return_address(c_rarg1, rscratch1);\n+    __ authenticate_return_address(c_rarg1);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -467,3 +467,2 @@\n-    \/\/ 1) this code has been built with branch-protection,\n-    \/\/ 2) the CPU\/OS supports it, and\n-    \/\/ 3) incompatible VMContinuations isn't enabled.\n+    \/\/ 1) this code has been built with branch-protection and\n+    \/\/ 2) the CPU\/OS supports it\n@@ -474,3 +473,0 @@\n-    } else if (VMContinuations) {\n-      \/\/ Not currently compatible with continuation freeze\/thaw.\n-      warning(\"ROP-protection is incompatible with VMContinuations. Disabling ROP-protection.\");\n@@ -491,6 +487,0 @@\n-\n-    \/\/ The frame pointer must be preserved for ROP protection.\n-    if (FLAG_IS_DEFAULT(PreserveFramePointer) == false && PreserveFramePointer == false ) {\n-      vm_exit_during_initialization(err_msg(\"PreserveFramePointer cannot be disabled for ROP-protection\"));\n-    }\n-    PreserveFramePointer = true;\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2023, Arm Limited. All rights reserved.\n@@ -36,1 +36,1 @@\n-inline address pauth_sign_return_address(address ret_addr, address sp) {\n+inline address pauth_sign_return_address(address ret_addr) {\n@@ -41,1 +41,1 @@\n-inline address pauth_authenticate_return_address(address ret_addr, address sp) {\n+inline address pauth_authenticate_return_address(address ret_addr) {\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/pauth_bsd_aarch64.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2023, Arm Limited. All rights reserved.\n@@ -33,6 +33,5 @@\n-\/\/ Use only the PAC instructions in the NOP space. This ensures the binaries work on systems\n-\/\/ without PAC. Write these instructions using their alternate \"hint\" instructions to ensure older\n-\/\/ compilers can still be used.\n-#define XPACLRI   \"hint #0x7;\"\n-#define PACIA1716 \"hint #0x8;\"\n-#define AUTIA1716 \"hint #0xc;\"\n+\/\/ Write these instructions using their alternate \"hint\" instructions to\n+\/\/ ensure older compilers can still be used.\n+#define XPACLRI \"hint #0x7;\"\n+#define PACIAZ  \"hint #0x18;\"\n+#define AUTIAZ  \"hint #0x1c;\"\n@@ -40,2 +39,2 @@\n-\/\/ Strip an address. Use with caution - only if there is no guaranteed way of authenticating the\n-\/\/ value.\n+\/\/ Strip an address. Use with caution -\n+\/\/ only if there is no guaranteed way of authenticating the value.\n@@ -49,1 +48,1 @@\n-\/\/ Sign a return value, using the given modifier.\n+\/\/ Sign a return value, using value zero as the modifier.\n@@ -51,1 +50,1 @@\n-inline address pauth_sign_return_address(address ret_addr, address sp) {\n+inline address pauth_sign_return_address(address ret_addr) {\n@@ -55,4 +54,3 @@\n-    register address r17 __asm(\"r17\") = ret_addr;\n-    register address r16 __asm(\"r16\") = sp;\n-    asm (PACIA1716 : \"+r\"(r17) : \"r\"(r16));\n-    ret_addr = r17;\n+    register address reg30 __asm__(\"x30\") = ret_addr;\n+    asm (PACIAZ : \"+r\"(reg30));\n+    ret_addr = reg30;\n@@ -63,1 +61,1 @@\n-\/\/ Authenticate a return value, using the given modifier.\n+\/\/ Authenticate a return value, using value zero as the modifier.\n@@ -65,1 +63,1 @@\n-inline address pauth_authenticate_return_address(address ret_addr, address sp) {\n+inline address pauth_authenticate_return_address(address ret_addr) {\n@@ -67,4 +65,3 @@\n-    register address r17 __asm(\"r17\") = ret_addr;\n-    register address r16 __asm(\"r16\") = sp;\n-    asm (AUTIA1716 : \"+r\"(r17) : \"r\"(r16));\n-    ret_addr = r17;\n+    register address reg30 __asm__(\"x30\") = ret_addr;\n+    asm (AUTIAZ : \"+r\"(reg30));\n+    ret_addr = reg30;\n@@ -72,1 +69,2 @@\n-    guarantee(pauth_ptr_is_raw(ret_addr), \"Return address did not authenticate\");\n+    guarantee(pauth_ptr_is_raw(ret_addr),\n+              \"Return address did not authenticate\");\n@@ -78,2 +76,2 @@\n-#undef PACIA1716\n-#undef AUTIA1716\n+#undef PACIAZ\n+#undef AUTIAZ\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/pauth_linux_aarch64.inline.hpp","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2023, Arm Limited. All rights reserved.\n@@ -36,1 +36,1 @@\n-inline address pauth_sign_return_address(address ret_addr, address sp) {\n+inline address pauth_sign_return_address(address ret_addr) {\n@@ -41,1 +41,1 @@\n-inline address pauth_authenticate_return_address(address ret_addr, address sp) {\n+inline address pauth_authenticate_return_address(address ret_addr) {\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/pauth_windows_aarch64.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1566,4 +1566,1 @@\n-  \/\/ This needs authenticating, but to do that here requires the fp of the previous frame.\n-  \/\/ A better way of doing it would be authenticate in the caller by adding a\n-  \/\/ AuthPAuthNode and using it in GraphKit::gen_stub. For now, just strip it.\n-  AARCH64_PORT_ONLY(ret_pc = pauth_strip_pointer(ret_pc));\n+  AARCH64_PORT_ONLY(ret_pc = pauth_strip_verifiable(ret_pc));\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"runtime\/continuationHelper.inline.hpp\"\n@@ -137,1 +138,2 @@\n-  address pc = *(address*)(sp - frame::sender_sp_ret_address_offset());\n+  address pc = ContinuationHelper::return_address_at(\n+                 sp - frame::sender_sp_ret_address_offset());\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -302,1 +302,2 @@\n-  address pc = *(address*)(sp - frame::sender_sp_ret_address_offset());\n+  address pc = ContinuationHelper::return_address_at(\n+                 sp - frame::sender_sp_ret_address_offset());\n@@ -595,1 +596,8 @@\n-    assert(*(address*)(chunk->sp_address() - frame::sender_sp_ret_address_offset()) == chunk->pc(), \"\");\n+#ifdef ASSERT\n+    {\n+      intptr_t* retaddr_slot = (chunk->sp_address()\n+                                - frame::sender_sp_ret_address_offset());\n+      assert(ContinuationHelper::return_address_at(retaddr_slot) == chunk->pc(),\n+             \"unexpected saved return address\");\n+    }\n+#endif\n@@ -609,2 +617,9 @@\n-    assert(*(address*)(bottom_sp-frame::sender_sp_ret_address_offset()) == StubRoutines::cont_returnBarrier(),\n-           \"should be the continuation return barrier\");\n+#ifdef ASSERT\n+    {\n+      intptr_t* retaddr_slot = (bottom_sp\n+                                - frame::sender_sp_ret_address_offset());\n+      assert(ContinuationHelper::return_address_at(retaddr_slot)\n+             == StubRoutines::cont_returnBarrier(),\n+             \"should be the continuation return barrier\");\n+    }\n+#endif\n@@ -678,1 +693,8 @@\n-  assert(_empty || *(address*)(_orig_chunk_sp - frame::sender_sp_ret_address_offset()) == chunk->pc(), \"\");\n+#ifdef ASSERT\n+  if (!_empty) {\n+    intptr_t* retaddr_slot = (_orig_chunk_sp\n+                              - frame::sender_sp_ret_address_offset());\n+    assert(ContinuationHelper::return_address_at(retaddr_slot) == chunk->pc(),\n+           \"unexpected saved return address\");\n+  }\n+#endif\n@@ -687,4 +709,15 @@\n-  \/\/ patch return pc of the bottom-most frozen frame (now in the chunk) with the actual caller's return address\n-  intptr_t* chunk_bottom_sp = chunk_top + cont_size() - _cont.argsize() - frame::metadata_words_at_top;\n-  assert(_empty || *(address*)(chunk_bottom_sp-frame::sender_sp_ret_address_offset()) == StubRoutines::cont_returnBarrier(), \"\");\n-  *(address*)(chunk_bottom_sp - frame::sender_sp_ret_address_offset()) = chunk->pc();\n+  \/\/ patch return pc of the bottom-most frozen frame (now in the chunk)\n+  \/\/ with the actual caller's return address\n+  intptr_t* chunk_bottom_retaddr_slot = (chunk_top + cont_size()\n+                                         - _cont.argsize()\n+                                         - frame::metadata_words_at_top\n+                                         - frame::sender_sp_ret_address_offset());\n+#ifdef ASSERT\n+  if (!_empty) {\n+    assert(ContinuationHelper::return_address_at(chunk_bottom_retaddr_slot)\n+           == StubRoutines::cont_returnBarrier(),\n+           \"should be the continuation return barrier\");\n+  }\n+#endif\n+  ContinuationHelper::patch_return_address_at(chunk_bottom_retaddr_slot,\n+                                              chunk->pc());\n@@ -695,1 +728,2 @@\n-  chunk->set_pc(*(address*)(_cont_stack_top - frame::sender_sp_ret_address_offset()));\n+  chunk->set_pc(ContinuationHelper::return_address_at(\n+                  _cont_stack_top - frame::sender_sp_ret_address_offset()));\n@@ -1848,1 +1882,9 @@\n-    assert(f.pc() == *(address*)(chunk_sp + frame_size - frame::sender_sp_ret_address_offset()), \"unexpected pc\");\n+#ifdef ASSERT\n+    {\n+      intptr_t* retaddr_slot = (chunk_sp\n+                                + frame_size\n+                                - frame::sender_sp_ret_address_offset());\n+      assert(f.pc() == ContinuationHelper::return_address_at(retaddr_slot),\n+             \"unexpected pc\");\n+    }\n+#endif\n@@ -1868,1 +1910,3 @@\n-  *(address*)(sp - frame::sender_sp_ret_address_offset()) = pc;\n+  ContinuationHelper::patch_return_address_at(\n+    sp - frame::sender_sp_ret_address_offset(),\n+    pc);\n@@ -2419,1 +2463,0 @@\n-  address pc0 = *(address*)(sp - frame::sender_sp_ret_address_offset());\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":56,"deletions":13,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,3 @@\n+  static inline address return_address_at(intptr_t* sp);\n+  static inline void patch_return_address_at(intptr_t* sp, address pc);\n+\n@@ -71,1 +74,1 @@\n-  static address return_pc(const frame& f) { return *return_pc_address(f); }\n+  static address return_pc(const frame& f);\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,11 @@\n+#ifndef CPU_OVERRIDES_RETURN_ADDRESS_ACCESSORS\n+inline address ContinuationHelper::return_address_at(intptr_t* sp) {\n+  return *(address*)sp;\n+}\n+\n+inline void ContinuationHelper::patch_return_address_at(intptr_t* sp,\n+                                                        address pc) {\n+  *(address*)sp = pc;\n+}\n+#endif \/\/ !CPU_OVERRIDES_RETURN_ADDRESS_ACCESSORS\n+\n@@ -52,0 +63,4 @@\n+inline address ContinuationHelper::Frame::return_pc(const frame& f) {\n+  return return_address_at((intptr_t *)return_pc_address(f));\n+}\n+\n@@ -78,1 +93,1 @@\n-  return *return_pc_address(f);\n+  return return_address_at((intptr_t *)return_pc_address(f));\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.inline.hpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Arm Limited. All rights reserved.\n@@ -258,1 +258,2 @@\n-            code.emitInt(0xdac103be);  \/\/ pacia x30, x29\n+            code.emitInt(0xf94003df);  \/\/ ldr xzr, [x30]\n+            code.emitInt(0xd503231f);  \/\/ paciaz\n@@ -260,2 +261,2 @@\n-        code.emitInt(0xa9be7bfd);  \/\/ stp x29, x30, [sp, #-32]!\n-        code.emitInt(0x910003fd);  \/\/ mov x29, sp\n+        code.emitInt(0xa9bf7bfd);      \/\/ stp x29, x30, [sp, #-16]!\n+        code.emitInt(0x910003fd);      \/\/ mov x29, sp\n@@ -471,2 +472,2 @@\n-        code.emitInt(0x910003bf);  \/\/ mov sp, x29\n-        code.emitInt(0xa8c27bfd);  \/\/ ldp x29, x30, [sp], #32\n+        code.emitInt(0x910003bf);      \/\/ mov sp, x29\n+        code.emitInt(0xa8c17bfd);      \/\/ ldp x29, x30, [sp], #16\n@@ -474,1 +475,2 @@\n-            code.emitInt(0xdac113be);  \/\/ autia x30, x29\n+            code.emitInt(0xd503239f);  \/\/ autiaz\n+            code.emitInt(0xf94003df);  \/\/ ldr xzr, [x30]\n@@ -476,1 +478,1 @@\n-        code.emitInt(0xd65f03c0);  \/\/ ret\n+        code.emitInt(0xd65f03c0);      \/\/ ret\n@@ -482,2 +484,2 @@\n-        code.emitInt(0x910003bf);  \/\/ mov sp, x29\n-        code.emitInt(0xa8c27bfd);  \/\/ ldp x29, x30, [sp], #32\n+        code.emitInt(0x910003bf);      \/\/ mov sp, x29\n+        code.emitInt(0xa8c17bfd);      \/\/ ldp x29, x30, [sp], #16\n@@ -485,1 +487,2 @@\n-            code.emitInt(0xdac113be);  \/\/ autia x30, x29\n+            code.emitInt(0xd503239f);  \/\/ autiaz\n+            code.emitInt(0xf94003df);  \/\/ ldr xzr, [x30]\n@@ -487,1 +490,1 @@\n-        code.emitInt(0xd65f03c0);  \/\/ ret\n+        code.emitInt(0xd65f03c0);      \/\/ ret\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/aarch64\/AArch64TestAssembler.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"}]}