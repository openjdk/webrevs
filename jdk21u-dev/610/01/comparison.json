{"files":[{"patch":"@@ -133,3 +133,3 @@\n-  \/\/ Clean up old interpreter OopMap entries that were replaced\n-  \/\/ during the GC thread root traversal.\n-  OopMapCache::cleanup_old_entries();\n+  \/\/ GC thread root traversal likely used OopMapCache a lot, which\n+  \/\/ might have created lots of old entries. Trigger the cleanup now.\n+  OopMapCache::try_trigger_cleanup();\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,0 +45,3 @@\n+  \/\/ GC thread root traversal likely used OopMapCache a lot, which\n+  \/\/ might have created lots of old entries. Trigger the cleanup now.\n+  OopMapCache::try_trigger_cleanup();\n@@ -55,1 +58,0 @@\n-  OopMapCache::cleanup_old_entries();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"interpreter\/oopMapCache.hpp\"\n@@ -133,0 +134,4 @@\n+\n+    \/\/ GC thread root traversal likely used OopMapCache a lot, which\n+    \/\/ might have created lots of old entries. Trigger the cleanup now.\n+    OopMapCache::try_trigger_cleanup();\n","filename":"src\/hotspot\/share\/gc\/x\/xDriver.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"interpreter\/oopMapCache.hpp\"\n@@ -455,0 +456,4 @@\n+\n+    \/\/ GC thread root traversal likely used OopMapCache a lot, which\n+    \/\/ might have created lots of old entries. Trigger the cleanup now.\n+    OopMapCache::try_trigger_cleanup();\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/globalCounter.inline.hpp\"\n@@ -493,2 +494,1 @@\n-\/\/ Called by GC for thread root scan during a safepoint only.  The other interpreted frame oopmaps\n-\/\/ are generated locally and not cached.\n+\/\/ Lookup or compute\/cache the entry.\n@@ -498,1 +498,0 @@\n-  assert(SafepointSynchronize::is_at_safepoint(), \"called by GC in a safepoint\");\n@@ -500,2 +499,0 @@\n-  int i;\n-  OopMapCacheEntry* entry = nullptr;\n@@ -511,8 +508,12 @@\n-  \/\/ Search hashtable for match\n-  for(i = 0; i < _probe_depth; i++) {\n-    entry = entry_at(probe + i);\n-    if (entry != nullptr && !entry->is_empty() && entry->match(method, bci)) {\n-      entry_for->resource_copy(entry);\n-      assert(!entry_for->is_empty(), \"A non-empty oop map should be returned\");\n-      log_debug(interpreter, oopmap)(\"- found at hash %d\", probe + i);\n-      return;\n+  \/\/ Search hashtable for match.\n+  \/\/ Need a critical section to avoid race against concurrent reclamation.\n+  {\n+    GlobalCounter::CriticalSection cs(Thread::current());\n+    for (int i = 0; i < _probe_depth; i++) {\n+      OopMapCacheEntry *entry = entry_at(probe + i);\n+      if (entry != nullptr && !entry->is_empty() && entry->match(method, bci)) {\n+        entry_for->resource_copy(entry);\n+        assert(!entry_for->is_empty(), \"A non-empty oop map should be returned\");\n+        log_debug(interpreter, oopmap)(\"- found at hash %d\", probe + i);\n+        return;\n+      }\n@@ -540,2 +541,2 @@\n-  for(i = 0; i < _probe_depth; i++) {\n-    entry = entry_at(probe + i);\n+  for (int i = 0; i < _probe_depth; i++) {\n+    OopMapCacheEntry* entry = entry_at(probe + i);\n@@ -556,0 +557,4 @@\n+    \/\/ Cannot deallocate old entry on the spot: it can still be used by readers\n+    \/\/ that got a reference to it before we were able to replace it in the map.\n+    \/\/ Instead of synchronizing on GlobalCounter here and incurring heavy thread\n+    \/\/ walk, we do this clean up out of band.\n@@ -566,4 +571,2 @@\n-  bool success = false;\n-  OopMapCacheEntry* head;\n-  do {\n-    head = _old_entries;\n+  while (true) {\n+    OopMapCacheEntry* head = Atomic::load(&_old_entries);\n@@ -571,2 +574,5 @@\n-    success = Atomic::cmpxchg(&_old_entries, head, entry) == head;\n-  } while (!success);\n+    if (Atomic::cmpxchg(&_old_entries, head, entry) == head) {\n+      \/\/ Enqueued successfully.\n+      break;\n+    }\n+  }\n@@ -581,5 +587,25 @@\n-\/\/ This is called after GC threads are done and nothing is accessing the old_entries\n-\/\/ list, so no synchronization needed.\n-void OopMapCache::cleanup_old_entries() {\n-  OopMapCacheEntry* entry = _old_entries;\n-  _old_entries = nullptr;\n+bool OopMapCache::has_cleanup_work() {\n+  return Atomic::load(&_old_entries) != nullptr;\n+}\n+\n+void OopMapCache::try_trigger_cleanup() {\n+  \/\/ See we can take the lock for the notification without blocking.\n+  \/\/ This allows triggering the cleanup from GC paths, that can hold\n+  \/\/ the service lock for e.g. oop iteration in service thread.\n+  if (has_cleanup_work() && Service_lock->try_lock_without_rank_check()) {\n+    Service_lock->notify_all();\n+    Service_lock->unlock();\n+  }\n+}\n+\n+void OopMapCache::cleanup() {\n+  OopMapCacheEntry* entry = Atomic::xchg(&_old_entries, (OopMapCacheEntry*)nullptr);\n+  if (entry == nullptr) {\n+    \/\/ No work.\n+    return;\n+  }\n+\n+  \/\/ About to delete the entries than might still be accessed by other threads\n+  \/\/ on lookup path. Need to sync up with them before proceeding.\n+  GlobalCounter::write_synchronize();\n+\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":52,"deletions":26,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -178,1 +178,9 @@\n-  static void cleanup_old_entries();\n+\n+  \/\/ Check if we need to clean up old entries\n+  static bool has_cleanup_work();\n+\n+  \/\/ Request cleanup if work is needed and notification is currently possible\n+  static void try_trigger_cleanup();\n+\n+  \/\/ Clean up the old entries\n+  static void cleanup();\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -311,8 +311,1 @@\n-  \/\/ Only GC uses the OopMapCache during thread stack root scanning\n-  \/\/ any other uses generate an oopmap but do not save it in the cache.\n-  if (Universe::heap()->is_stw_gc_active()) {\n-    method_holder()->mask_for(h_this, bci, mask);\n-  } else {\n-    OopMapCache::compute_one_oop_map(h_this, bci, mask);\n-  }\n-  return;\n+  mask_for(h_this, bci, mask);\n@@ -321,0 +314,4 @@\n+void Method::mask_for(const methodHandle& this_mh, int bci, InterpreterOopMap* mask) {\n+  assert(this_mh() == this, \"Sanity\");\n+  method_holder()->mask_for(this_mh, bci, mask);\n+}\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -498,1 +498,2 @@\n-  \/\/ Interpreter oopmap support\n+  \/\/ Interpreter oopmap support.\n+  \/\/ If handle is already available, call with it for better performance.\n@@ -500,0 +501,1 @@\n+  void mask_for(const methodHandle& this_mh, int bci, InterpreterOopMap* mask);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -958,1 +958,1 @@\n-    m->mask_for(bci, &mask);\n+    m->mask_for(m, bci, &mask);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"interpreter\/oopMapCache.hpp\"\n@@ -613,0 +614,7 @@\n+    if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_REQUEST_OOPMAPCACHE_CLEANUP)) {\n+      if (OopMapCache::has_cleanup_work()) {\n+        Tracer t(\"triggering oopmap cache cleanup\");\n+        OopMapCache::try_trigger_cleanup();\n+      }\n+    }\n+\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+    SAFEPOINT_CLEANUP_REQUEST_OOPMAPCACHE_CLEANUP,\n","filename":"src\/hotspot\/share\/runtime\/safepoint.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"interpreter\/oopMapCache.hpp\"\n@@ -98,0 +99,1 @@\n+    bool oopmap_cache_work = false;\n@@ -127,1 +129,2 @@\n-              (jvmti_tagmap_work = JvmtiTagMap::has_object_free_events_and_reset())\n+              (jvmti_tagmap_work = JvmtiTagMap::has_object_free_events_and_reset()) |\n+              (oopmap_cache_work = OopMapCache::has_cleanup_work())\n@@ -198,0 +201,4 @@\n+\n+    if (oopmap_cache_work) {\n+      OopMapCache::cleanup();\n+    }\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}