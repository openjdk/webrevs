{"files":[{"patch":"@@ -1724,2 +1724,2 @@\n-    st->print(\"ldr zr, [lr]\\n\\t\");\n-    st->print(\"pacia  lr, rfp\\n\\t\");\n+    st->print(\"ldr  zr, [lr]\\n\\t\");\n+    st->print(\"paciaz\\n\\t\");\n@@ -1854,2 +1854,2 @@\n-    st->print(\"autia lr, rfp\\n\\t\");\n-    st->print(\"ldr zr, [lr]\\n\\t\");\n+    st->print(\"autiaz\\n\\t\");\n+    st->print(\"ldr  zr, [lr]\\n\\t\");\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -388,1 +388,1 @@\n-    __ authenticate_return_address(exception_pc, rscratch1);\n+    __ authenticate_return_address(exception_pc);\n@@ -437,1 +437,1 @@\n-  __ protect_return_address(exception_pc, rscratch1);\n+  __ protect_return_address(exception_pc);\n@@ -453,1 +453,1 @@\n-  __ protect_return_address(r0, rscratch1);\n+  __ protect_return_address(r0);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  address sender_pc = (address) *(sender_sp-1);\n+  address sender_pc = ContinuationHelper::return_address_at(sender_sp - 1);\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,0 +71,11 @@\n+#define CPU_OVERRIDES_RETURN_ADDRESS_ACCESSORS\n+\n+inline address ContinuationHelper::return_address_at(intptr_t* sp) {\n+  return pauth_strip_verifiable(*(address*)sp);\n+}\n+\n+inline void ContinuationHelper::patch_return_address_at(intptr_t* sp,\n+                                                        address pc) {\n+  *(address*)sp = pauth_sign_return_address(pc);\n+}\n+\n@@ -83,1 +94,2 @@\n-  address pc = *(address*)(sp - frame::sender_sp_ret_address_offset());\n+  address pc = ContinuationHelper::return_address_at(\n+                 sp - frame::sender_sp_ret_address_offset());\n@@ -111,0 +123,1 @@\n+  \/\/ Always used in assertions. Just strip it.\n@@ -112,1 +125,1 @@\n-  return *pc_addr;\n+  return pauth_strip_pointer(*pc_addr);\n@@ -117,1 +130,1 @@\n-  *pc_addr = pc;\n+  *pc_addr = pauth_sign_return_address(pc);\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationHelper_aarch64.inline.hpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -142,2 +142,1 @@\n-      sender_pc = pauth_strip_verifiable((address) this->fp()[return_addr_offset], (address)saved_fp);\n-\n+      sender_pc = pauth_strip_verifiable((address) this->fp()[return_addr_offset]);\n@@ -161,1 +160,3 @@\n-      sender_pc = pauth_strip_verifiable((address) *(sender_sp-1), (address)saved_fp);\n+      \/\/ Note: PAC authentication may fail in case broken frame is passed in.\n+      \/\/ Just strip it for now.\n+      sender_pc = pauth_strip_pointer((address) *(sender_sp - 1));\n@@ -279,3 +280,2 @@\n-  address signing_sp = (((address*) sp())[-2]);\n-  address signed_pc = pauth_sign_return_address(pc, (address)signing_sp);\n-  address pc_old = pauth_strip_verifiable(*pc_addr, (address)signing_sp);\n+  address signed_pc = pauth_sign_return_address(pc);\n+  address pc_old = pauth_strip_verifiable(*pc_addr);\n@@ -475,2 +475,3 @@\n-  \/\/ For ROP protection, Interpreter will have signed the sender_pc, but there is no requirement to authenticate it here.\n-  address sender_pc = pauth_strip_verifiable(sender_pc_maybe_signed(), (address)link());\n+  \/\/ For ROP protection, Interpreter will have signed the sender_pc,\n+  \/\/ but there is no requirement to authenticate it here.\n+  address sender_pc = pauth_strip_verifiable(sender_pc_maybe_signed());\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -155,1 +155,4 @@\n-inline frame::frame(intptr_t* sp) : frame(sp, sp, *(intptr_t**)(sp - frame::sender_sp_offset), *(address*)(sp - 1)) {}\n+inline frame::frame(intptr_t* sp)\n+  : frame(sp, sp,\n+          *(intptr_t**)(sp - frame::sender_sp_offset),\n+          pauth_strip_verifiable(*(address*)(sp - 1))) {}\n@@ -419,3 +422,4 @@\n-  \/\/ the return_address is always the word on the stack\n-  \/\/ For ROP protection, C1\/C2 will have signed the sender_pc, but there is no requirement to authenticate it here.\n-  address sender_pc = pauth_strip_verifiable((address) *(l_sender_sp-1), (address) *(l_sender_sp-2));\n+  \/\/ The return_address is always the word on the stack.\n+  \/\/ For ROP protection, C1\/C2 will have signed the sender_pc,\n+  \/\/ but there is no requirement to authenticate it here.\n+  address sender_pc = pauth_strip_verifiable((address) *(l_sender_sp - 1));\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -5981,1 +5981,1 @@\n-\/\/ Uses the FP as the modifier.\n+\/\/ Uses value zero as the modifier.\n@@ -5986,4 +5986,1 @@\n-    \/\/ The standard convention for C code is to use paciasp, which uses SP as the modifier. This\n-    \/\/ works because in C code, FP and SP match on function entry. In the JDK, SP and FP may not\n-    \/\/ match, so instead explicitly use the FP.\n-    pacia(lr, rfp);\n+    paciaz();\n@@ -5995,2 +5992,1 @@\n-\/\/ Uses the FP from the start of the function as the modifier - which is stored at the address of\n-\/\/ the current FP.\n+\/\/ Uses value zero as the modifier.\n@@ -5998,1 +5994,1 @@\n-void MacroAssembler::protect_return_address(Register return_reg, Register temp_reg) {\n+void MacroAssembler::protect_return_address(Register return_reg) {\n@@ -6000,1 +5996,0 @@\n-    assert(PreserveFramePointer, \"PreserveFramePointer must be set for ROP protection\");\n@@ -6002,2 +5997,1 @@\n-    ldr(temp_reg, Address(rfp));\n-    pacia(return_reg, temp_reg);\n+    paciza(return_reg);\n@@ -6008,0 +6002,1 @@\n+\/\/ Uses value zero as the modifier.\n@@ -6009,1 +6004,1 @@\n-void MacroAssembler::authenticate_return_address(Register return_reg) {\n+void MacroAssembler::authenticate_return_address() {\n@@ -6011,2 +6006,2 @@\n-    autia(return_reg, rfp);\n-    check_return_address(return_reg);\n+    autiaz();\n+    check_return_address();\n@@ -6018,2 +6013,1 @@\n-\/\/ Uses the FP from the start of the function as the modifier - which is stored at the address of\n-\/\/ the current FP.\n+\/\/ Uses value zero as the modifier.\n@@ -6021,1 +6015,1 @@\n-void MacroAssembler::authenticate_return_address(Register return_reg, Register temp_reg) {\n+void MacroAssembler::authenticate_return_address(Register return_reg) {\n@@ -6023,3 +6017,1 @@\n-    assert(PreserveFramePointer, \"PreserveFramePointer must be set for ROP protection\");\n-    ldr(temp_reg, Address(rfp));\n-    autia(return_reg, temp_reg);\n+    autiza(return_reg);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -719,3 +719,3 @@\n-  void protect_return_address(Register return_reg, Register temp_reg);\n-  void authenticate_return_address(Register return_reg = lr);\n-  void authenticate_return_address(Register return_reg, Register temp_reg);\n+  void protect_return_address(Register return_reg);\n+  void authenticate_return_address();\n+  void authenticate_return_address(Register return_reg);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2023, Arm Limited. All rights reserved.\n@@ -80,1 +80,1 @@\n-inline address pauth_strip_verifiable(address ret_addr, address modifier) {\n+inline address pauth_strip_verifiable(address ret_addr) {\n@@ -82,1 +82,1 @@\n-    DEBUG_ONLY(ret_addr = pauth_authenticate_return_address(ret_addr, modifier);)\n+    DEBUG_ONLY(ret_addr = pauth_authenticate_return_address(ret_addr);)\n","filename":"src\/hotspot\/cpu\/aarch64\/pauth_aarch64.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -397,1 +397,1 @@\n-  __ authenticate_return_address(c_rarg1, rscratch1);\n+  __ authenticate_return_address(c_rarg1);\n@@ -1174,0 +1174,1 @@\n+      __ authenticate_return_address(c_rarg1);\n@@ -2340,1 +2341,1 @@\n-  __ protect_return_address(r3, rscratch1);\n+  __ protect_return_address(r3);\n@@ -2446,3 +2447,1 @@\n-  __ ldp(rfp, lr, __ post(sp, 2 * wordSize));\n-  __ authenticate_return_address();\n-  \/\/ LR should now be the return address to the caller (3)\n+  __ ldp(rfp, zr, __ post(sp, 2 * wordSize));\n@@ -2663,3 +2662,1 @@\n-  __ ldp(rfp, lr, __ post(sp, 2 * wordSize));\n-  __ authenticate_return_address();\n-  \/\/ LR should now be the return address to the caller (3) frame\n+  __ ldp(rfp, zr, __ post(sp, 2 * wordSize));\n@@ -2811,1 +2808,1 @@\n-    __ protect_return_address(r20, rscratch1);\n+    __ protect_return_address(r20);\n@@ -2852,1 +2849,1 @@\n-    __ authenticate_return_address(r20, rscratch1);\n+    __ authenticate_return_address(r20);\n@@ -2867,1 +2864,1 @@\n-    __ protect_return_address(r20, rscratch1);\n+    __ protect_return_address(r20);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"pauth_aarch64.hpp\"\n@@ -55,1 +56,2 @@\n-  return *(address*)(_sp - 1);\n+  \/\/ Just strip it for frames on the heap.\n+  return pauth_strip_pointer(*(address*)(_sp - 1));\n","filename":"src\/hotspot\/cpu\/aarch64\/stackChunkFrameStream_aarch64.inline.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -7011,0 +7011,1 @@\n+      __ authenticate_return_address(c_rarg1);\n@@ -7012,1 +7013,2 @@\n-      __ mov(r19, r0); \/\/ save return value contaning the exception oop in callee-saved R19\n+      \/\/ save return value containing the exception oop in callee-saved R19\n+      __ mov(r19, r0);\n@@ -7022,1 +7024,1 @@\n-      __ mov(r0, r19); \/\/ restore return value contaning the exception oop\n+      __ mov(r0, r19); \/\/ restore return value containing the exception oop\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1826,1 +1826,1 @@\n-    __ authenticate_return_address(c_rarg1, rscratch1);\n+    __ authenticate_return_address(c_rarg1);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -467,3 +467,2 @@\n-    \/\/ 1) this code has been built with branch-protection,\n-    \/\/ 2) the CPU\/OS supports it, and\n-    \/\/ 3) incompatible VMContinuations isn't enabled.\n+    \/\/ 1) this code has been built with branch-protection and\n+    \/\/ 2) the CPU\/OS supports it\n@@ -474,3 +473,0 @@\n-    } else if (VMContinuations) {\n-      \/\/ Not currently compatible with continuation freeze\/thaw.\n-      warning(\"ROP-protection is incompatible with VMContinuations. Disabling ROP-protection.\");\n@@ -491,6 +487,0 @@\n-\n-    \/\/ The frame pointer must be preserved for ROP protection.\n-    if (FLAG_IS_DEFAULT(PreserveFramePointer) == false && PreserveFramePointer == false ) {\n-      vm_exit_during_initialization(err_msg(\"PreserveFramePointer cannot be disabled for ROP-protection\"));\n-    }\n-    PreserveFramePointer = true;\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2023, Arm Limited. All rights reserved.\n@@ -36,1 +36,1 @@\n-inline address pauth_sign_return_address(address ret_addr, address sp) {\n+inline address pauth_sign_return_address(address ret_addr) {\n@@ -41,1 +41,1 @@\n-inline address pauth_authenticate_return_address(address ret_addr, address sp) {\n+inline address pauth_authenticate_return_address(address ret_addr) {\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/pauth_bsd_aarch64.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2023, Arm Limited. All rights reserved.\n@@ -33,6 +33,5 @@\n-\/\/ Use only the PAC instructions in the NOP space. This ensures the binaries work on systems\n-\/\/ without PAC. Write these instructions using their alternate \"hint\" instructions to ensure older\n-\/\/ compilers can still be used.\n-#define XPACLRI   \"hint #0x7;\"\n-#define PACIA1716 \"hint #0x8;\"\n-#define AUTIA1716 \"hint #0xc;\"\n+\/\/ Write these instructions using their alternate \"hint\" instructions to\n+\/\/ ensure older compilers can still be used.\n+#define XPACLRI \"hint #0x7;\"\n+#define PACIAZ  \"hint #0x18;\"\n+#define AUTIAZ  \"hint #0x1c;\"\n@@ -40,2 +39,2 @@\n-\/\/ Strip an address. Use with caution - only if there is no guaranteed way of authenticating the\n-\/\/ value.\n+\/\/ Strip an address. Use with caution -\n+\/\/ only if there is no guaranteed way of authenticating the value.\n@@ -49,1 +48,1 @@\n-\/\/ Sign a return value, using the given modifier.\n+\/\/ Sign a return value, using value zero as the modifier.\n@@ -51,1 +50,1 @@\n-inline address pauth_sign_return_address(address ret_addr, address sp) {\n+inline address pauth_sign_return_address(address ret_addr) {\n@@ -55,4 +54,3 @@\n-    register address r17 __asm(\"r17\") = ret_addr;\n-    register address r16 __asm(\"r16\") = sp;\n-    asm (PACIA1716 : \"+r\"(r17) : \"r\"(r16));\n-    ret_addr = r17;\n+    register address reg30 __asm__(\"x30\") = ret_addr;\n+    asm (PACIAZ : \"+r\"(reg30));\n+    ret_addr = reg30;\n@@ -63,1 +61,1 @@\n-\/\/ Authenticate a return value, using the given modifier.\n+\/\/ Authenticate a return value, using value zero as the modifier.\n@@ -65,1 +63,1 @@\n-inline address pauth_authenticate_return_address(address ret_addr, address sp) {\n+inline address pauth_authenticate_return_address(address ret_addr) {\n@@ -67,4 +65,3 @@\n-    register address r17 __asm(\"r17\") = ret_addr;\n-    register address r16 __asm(\"r16\") = sp;\n-    asm (AUTIA1716 : \"+r\"(r17) : \"r\"(r16));\n-    ret_addr = r17;\n+    register address reg30 __asm__(\"x30\") = ret_addr;\n+    asm (AUTIAZ : \"+r\"(reg30));\n+    ret_addr = reg30;\n@@ -72,1 +69,2 @@\n-    guarantee(pauth_ptr_is_raw(ret_addr), \"Return address did not authenticate\");\n+    guarantee(pauth_ptr_is_raw(ret_addr),\n+              \"Return address did not authenticate\");\n@@ -78,2 +76,2 @@\n-#undef PACIA1716\n-#undef AUTIA1716\n+#undef PACIAZ\n+#undef AUTIAZ\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/pauth_linux_aarch64.inline.hpp","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2023, Arm Limited. All rights reserved.\n@@ -36,1 +36,1 @@\n-inline address pauth_sign_return_address(address ret_addr, address sp) {\n+inline address pauth_sign_return_address(address ret_addr) {\n@@ -41,1 +41,1 @@\n-inline address pauth_authenticate_return_address(address ret_addr, address sp) {\n+inline address pauth_authenticate_return_address(address ret_addr) {\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/pauth_windows_aarch64.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -430,1 +430,1 @@\n-  template(argsize_name,                              \"argsize\")                                  \\\n+  template(bottom_name,                               \"bottom\")                                   \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -247,2 +247,2 @@\n-  st->print_cr(\"       size: %d argsize: %d max_size: %d sp: %d pc: \" PTR_FORMAT,\n-               c->stack_size(), c->argsize(), c->max_thawing_size(), c->sp(), p2i(c->pc()));\n+  st->print_cr(\"       size: %d bottom: %d max_size: %d sp: %d pc: \" PTR_FORMAT,\n+               c->stack_size(), c->bottom(), c->max_thawing_size(), c->sp(), p2i(c->pc()));\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -210,0 +210,2 @@\n+  jint int_field_relaxed(int offset) const;\n+  void int_field_put_relaxed(int offset, jint contents);\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -241,0 +241,2 @@\n+inline jint oopDesc::int_field_relaxed(int offset) const            { return Atomic::load(field_addr<jint>(offset)); }\n+inline void oopDesc::int_field_put_relaxed(int offset, jint value)  { Atomic::store(field_addr<jint>(offset), value); }\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -538,1 +538,0 @@\n-  assert(argsize() >= 0, \"\");\n@@ -542,1 +541,0 @@\n-    assert(argsize() == 0, \"\");\n@@ -544,0 +542,2 @@\n+  } else {\n+    assert(argsize() >= 0, \"\");\n@@ -552,1 +552,1 @@\n-  int size = stack_size() - argsize() - sp();\n+  int size = bottom() - sp();\n@@ -575,6 +575,9 @@\n-    assert(closure._size <= size + argsize() + frame::metadata_words,\n-           \"size: %d argsize: %d closure.size: %d end sp: \" PTR_FORMAT \" start sp: %d chunk size: %d\",\n-           size, argsize(), closure._size, closure._sp - start_address(), sp(), stack_size());\n-    assert(argsize() == closure._argsize - (closure._num_frames > 0 ? frame::metadata_words_at_top : 0),\n-           \"argsize(): %d closure.argsize: %d closure.callee_interpreted: %d\",\n-           argsize(), closure._argsize, closure._callee_interpreted);\n+    assert(closure._size <= size + (stack_size() - bottom()),\n+           \"size: %d bottom: %d closure.size: %d end sp: \" PTR_FORMAT \" start sp: %d chunk size: %d\",\n+           size, bottom(), closure._size, closure._sp - start_address(), sp(), stack_size());\n+    if (closure._num_frames > 0) {\n+      assert(closure._argsize >= frame::metadata_words_at_top, \"should be set up\");\n+      assert(argsize() == closure._argsize - frame::metadata_words_at_top,\n+             \"argsize(): %d closure.argsize: %d closure.callee_interpreted: %d\",\n+             argsize(), closure._argsize, closure._callee_interpreted);\n+    }\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+  inline void set_bottom(int value);\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,0 +63,3 @@\n+inline int stackChunkOopDesc::bottom() const            { return jdk_internal_vm_StackChunk::bottom(as_oop()); }\n+inline void stackChunkOopDesc::set_bottom(int value)    { jdk_internal_vm_StackChunk::set_bottom(this, value); }\n+\n@@ -69,3 +72,0 @@\n-inline int stackChunkOopDesc::argsize() const           { return jdk_internal_vm_StackChunk::argsize(as_oop()); }\n-inline void stackChunkOopDesc::set_argsize(int value)   { jdk_internal_vm_StackChunk::set_argsize(as_oop(), value); }\n-\n@@ -111,1 +111,4 @@\n-inline int stackChunkOopDesc::bottom() const { return stack_size() - argsize() - frame::metadata_words_at_top; }\n+inline int stackChunkOopDesc::argsize() const {\n+  assert(!is_empty(), \"should not ask for argsize in empty chunk\");\n+  return stack_size() - bottom() - frame::metadata_words_at_top;\n+}\n@@ -135,4 +138,2 @@\n-  assert(sp() <= stack_size(), \"\");\n-  assert((sp() == stack_size()) == (sp() >= stack_size() - argsize() - frame::metadata_words_at_top),\n-    \"sp: %d size: %d argsize: %d\", sp(), stack_size(), argsize());\n-  return sp() == stack_size();\n+  assert(sp() <= bottom(), \"\");\n+  return sp() == bottom();\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1566,4 +1566,1 @@\n-  \/\/ This needs authenticating, but to do that here requires the fp of the previous frame.\n-  \/\/ A better way of doing it would be authenticate in the caller by adding a\n-  \/\/ AuthPAuthNode and using it in GraphKit::gen_stub. For now, just strip it.\n-  AARCH64_PORT_ONLY(ret_pc = pauth_strip_pointer(ret_pc));\n+  AARCH64_PORT_ONLY(ret_pc = pauth_strip_verifiable(ret_pc));\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"runtime\/continuationHelper.inline.hpp\"\n@@ -137,1 +138,2 @@\n-  address pc = *(address*)(sp - frame::sender_sp_ret_address_offset());\n+  address pc = ContinuationHelper::return_address_at(\n+                 sp - frame::sender_sp_ret_address_offset());\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -302,1 +302,2 @@\n-  address pc = *(address*)(sp - frame::sender_sp_ret_address_offset());\n+  address pc = ContinuationHelper::return_address_at(\n+                 sp - frame::sender_sp_ret_address_offset());\n@@ -405,1 +406,1 @@\n-  virtual stackChunkOop allocate_chunk_slow(size_t stack_size) = 0;\n+  virtual stackChunkOop allocate_chunk_slow(size_t stack_size, int argsize_md) = 0;\n@@ -440,8 +441,0 @@\n-\n-#ifdef ASSERT\n-  bool is_empty(stackChunkOop chunk) {\n-    \/\/ during freeze, the chunk is in an intermediate state (after setting the chunk's argsize but before setting its\n-    \/\/ ultimate sp) so we use this instead of stackChunkOopDesc::is_empty\n-    return chunk->sp() >= chunk->stack_size() - chunk->argsize() - frame::metadata_words_at_top;\n-  }\n-#endif\n@@ -453,1 +446,1 @@\n-  stackChunkOop allocate_chunk(size_t stack_size);\n+  stackChunkOop allocate_chunk(size_t stack_size, int argsize_md);\n@@ -462,1 +455,1 @@\n-  virtual stackChunkOop allocate_chunk_slow(size_t stack_size) override { return allocate_chunk(stack_size); }\n+  virtual stackChunkOop allocate_chunk_slow(size_t stack_size, int argsize_md) override { return allocate_chunk(stack_size, argsize_md); }\n@@ -545,1 +538,1 @@\n-  stackChunkOop chunk = allocate_chunk(cont_size() + frame::metadata_words);\n+  stackChunkOop chunk = allocate_chunk(cont_size() + frame::metadata_words, _cont.argsize() + frame::metadata_words_at_top);\n@@ -574,1 +567,1 @@\n-  if (chunk_sp < chunk->stack_size()) {\n+  if (!chunk->is_empty()) {\n@@ -587,1 +580,0 @@\n-  DEBUG_ONLY(_orig_chunk_sp = chunk->sp_address();)\n@@ -592,1 +584,1 @@\n-  if (chunk->sp() < chunk->stack_size()) { \/\/ we are copying into a non-empty chunk\n+  if (!chunk->is_empty()) { \/\/ we are copying into a non-empty chunk\n@@ -594,2 +586,9 @@\n-    assert(chunk->sp() < (chunk->stack_size() - chunk->argsize()), \"\");\n-    assert(*(address*)(chunk->sp_address() - frame::sender_sp_ret_address_offset()) == chunk->pc(), \"\");\n+    DEBUG_ONLY(_orig_chunk_sp = chunk->sp_address();)\n+#ifdef ASSERT\n+    {\n+      intptr_t* retaddr_slot = (chunk->sp_address()\n+                                - frame::sender_sp_ret_address_offset());\n+      assert(ContinuationHelper::return_address_at(retaddr_slot) == chunk->pc(),\n+             \"unexpected saved return address\");\n+    }\n+#endif\n@@ -609,2 +608,9 @@\n-    assert(*(address*)(bottom_sp-frame::sender_sp_ret_address_offset()) == StubRoutines::cont_returnBarrier(),\n-           \"should be the continuation return barrier\");\n+#ifdef ASSERT\n+    {\n+      intptr_t* retaddr_slot = (bottom_sp\n+                                - frame::sender_sp_ret_address_offset());\n+      assert(ContinuationHelper::return_address_at(retaddr_slot)\n+             == StubRoutines::cont_returnBarrier(),\n+             \"should be the continuation return barrier\");\n+    }\n+#endif\n@@ -618,2 +624,1 @@\n-    DEBUG_ONLY(_empty = true;)\n-    const int chunk_start_sp = chunk->sp();\n+    const int chunk_start_sp = chunk->stack_size();\n@@ -621,1 +626,2 @@\n-    assert(chunk_start_sp == chunk->stack_size(), \"\");\n+    DEBUG_ONLY(_empty = true;)\n+    DEBUG_ONLY(_orig_chunk_sp = chunk->start_address() + chunk_start_sp;)\n@@ -624,1 +630,2 @@\n-    chunk->set_argsize(_cont.argsize());\n+    chunk->set_bottom(chunk_start_sp - _cont.argsize() - frame::metadata_words_at_top);\n+    chunk->set_sp(chunk->bottom());\n@@ -642,1 +649,0 @@\n-  chunk->set_argsize(_cont.argsize());\n@@ -678,1 +684,8 @@\n-  assert(_empty || *(address*)(_orig_chunk_sp - frame::sender_sp_ret_address_offset()) == chunk->pc(), \"\");\n+#ifdef ASSERT\n+  if (!_empty) {\n+    intptr_t* retaddr_slot = (_orig_chunk_sp\n+                              - frame::sender_sp_ret_address_offset());\n+    assert(ContinuationHelper::return_address_at(retaddr_slot) == chunk->pc(),\n+           \"unexpected saved return address\");\n+  }\n+#endif\n@@ -687,4 +700,15 @@\n-  \/\/ patch return pc of the bottom-most frozen frame (now in the chunk) with the actual caller's return address\n-  intptr_t* chunk_bottom_sp = chunk_top + cont_size() - _cont.argsize() - frame::metadata_words_at_top;\n-  assert(_empty || *(address*)(chunk_bottom_sp-frame::sender_sp_ret_address_offset()) == StubRoutines::cont_returnBarrier(), \"\");\n-  *(address*)(chunk_bottom_sp - frame::sender_sp_ret_address_offset()) = chunk->pc();\n+  \/\/ patch return pc of the bottom-most frozen frame (now in the chunk)\n+  \/\/ with the actual caller's return address\n+  intptr_t* chunk_bottom_retaddr_slot = (chunk_top + cont_size()\n+                                         - _cont.argsize()\n+                                         - frame::metadata_words_at_top\n+                                         - frame::sender_sp_ret_address_offset());\n+#ifdef ASSERT\n+  if (!_empty) {\n+    assert(ContinuationHelper::return_address_at(chunk_bottom_retaddr_slot)\n+           == StubRoutines::cont_returnBarrier(),\n+           \"should be the continuation return barrier\");\n+  }\n+#endif\n+  ContinuationHelper::patch_return_address_at(chunk_bottom_retaddr_slot,\n+                                              chunk->pc());\n@@ -695,1 +719,2 @@\n-  chunk->set_pc(*(address*)(_cont_stack_top - frame::sender_sp_ret_address_offset()));\n+  chunk->set_pc(ContinuationHelper::return_address_at(\n+                  _cont_stack_top - frame::sender_sp_ret_address_offset()));\n@@ -900,1 +925,0 @@\n-    unextended_sp = chunk->sp();\n@@ -908,0 +932,2 @@\n+    } else {\n+      unextended_sp = chunk->stack_size() - frame::metadata_words_at_top;\n@@ -945,1 +971,1 @@\n-    chunk = allocate_chunk_slow(_freeze_size);\n+    chunk = allocate_chunk_slow(_freeze_size, argsize_md);\n@@ -952,5 +978,1 @@\n-\n-    int sp = chunk->stack_size() - argsize_md;\n-    chunk->set_sp(sp);\n-    chunk->set_argsize(argsize);\n-    assert(is_empty(chunk), \"\");\n+    assert(chunk->is_empty(), \"\");\n@@ -963,1 +985,1 @@\n-      chunk->set_argsize(argsize);\n+      chunk->set_bottom(sp);\n@@ -973,1 +995,1 @@\n-  assert(!_barriers || is_empty(chunk), \"\");\n+  assert(!_barriers || chunk->is_empty(), \"\");\n@@ -975,2 +997,2 @@\n-  assert(!is_empty(chunk) || StackChunkFrameStream<ChunkFrames::Mixed>(chunk).is_done(), \"\");\n-  assert(!is_empty(chunk) || StackChunkFrameStream<ChunkFrames::Mixed>(chunk).to_frame().is_empty(), \"\");\n+  assert(!chunk->is_empty() || StackChunkFrameStream<ChunkFrames::Mixed>(chunk).is_done(), \"\");\n+  assert(!chunk->is_empty() || StackChunkFrameStream<ChunkFrames::Mixed>(chunk).to_frame().is_empty(), \"\");\n@@ -1022,1 +1044,1 @@\n-    assert((last_pc == nullptr) == is_empty(_cont.tail()), \"\");\n+    assert((last_pc == nullptr) == _cont.tail()->is_empty(), \"\");\n@@ -1276,0 +1298,1 @@\n+  int                                          _argsize_md;\n@@ -1291,0 +1314,2 @@\n+    int bottom = (int)_stack_size - _argsize_md;\n+\n@@ -1292,1 +1317,2 @@\n-    jdk_internal_vm_StackChunk::set_sp(mem, (int)_stack_size);\n+    jdk_internal_vm_StackChunk::set_bottom(mem, bottom);\n+    jdk_internal_vm_StackChunk::set_sp(mem, bottom);\n@@ -1316,0 +1342,1 @@\n+                      int argsize_md,\n@@ -1320,0 +1347,1 @@\n+      _argsize_md(argsize_md),\n@@ -1353,1 +1381,1 @@\n-stackChunkOop Freeze<ConfigT>::allocate_chunk(size_t stack_size) {\n+stackChunkOop Freeze<ConfigT>::allocate_chunk(size_t stack_size, int argsize_md) {\n@@ -1375,1 +1403,1 @@\n-  StackChunkAllocator allocator(klass, size_in_words, current, stack_size, _cont, _jvmti_event_collector);\n+  StackChunkAllocator allocator(klass, size_in_words, current, stack_size, argsize_md, _cont, _jvmti_event_collector);\n@@ -1385,1 +1413,1 @@\n-  assert(chunk->sp() == chunk->stack_size(), \"\");\n+  assert(chunk->sp() == chunk->bottom(), \"\");\n@@ -1389,1 +1417,1 @@\n-  assert(chunk->argsize() == 0, \"\");\n+  assert(chunk->is_empty(), \"\");\n@@ -1822,2 +1850,1 @@\n-  chunk->set_sp(chunk->stack_size());\n-  chunk->set_argsize(0);\n+  chunk->set_sp(chunk->bottom());\n@@ -1827,1 +1854,1 @@\n- int ThawBase::remove_top_compiled_frame_from_chunk(stackChunkOop chunk, int &argsize) {\n+int ThawBase::remove_top_compiled_frame_from_chunk(stackChunkOop chunk, int &argsize) {\n@@ -1848,1 +1875,9 @@\n-    assert(f.pc() == *(address*)(chunk_sp + frame_size - frame::sender_sp_ret_address_offset()), \"unexpected pc\");\n+#ifdef ASSERT\n+    {\n+      intptr_t* retaddr_slot = (chunk_sp\n+                                + frame_size\n+                                - frame::sender_sp_ret_address_offset());\n+      assert(f.pc() == ContinuationHelper::return_address_at(retaddr_slot),\n+             \"unexpected pc\");\n+    }\n+#endif\n@@ -1868,1 +1903,3 @@\n-  *(address*)(sp - frame::sender_sp_ret_address_offset()) = pc;\n+  ContinuationHelper::patch_return_address_at(\n+    sp - frame::sender_sp_ret_address_offset(),\n+    pc);\n@@ -2064,2 +2101,1 @@\n-    chunk->set_argsize(0);\n-    chunk->set_sp(chunk->stack_size());\n+    chunk->set_sp(chunk->bottom());\n@@ -2337,1 +2373,0 @@\n-    assert(chunk->argsize() == 0, \"\");\n@@ -2419,1 +2454,0 @@\n-  address pc0 = *(address*)(sp - frame::sender_sp_ret_address_offset());\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":91,"deletions":57,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,3 @@\n+  static inline address return_address_at(intptr_t* sp);\n+  static inline void patch_return_address_at(intptr_t* sp, address pc);\n+\n@@ -71,1 +74,1 @@\n-  static address return_pc(const frame& f) { return *return_pc_address(f); }\n+  static address return_pc(const frame& f);\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,11 @@\n+#ifndef CPU_OVERRIDES_RETURN_ADDRESS_ACCESSORS\n+inline address ContinuationHelper::return_address_at(intptr_t* sp) {\n+  return *(address*)sp;\n+}\n+\n+inline void ContinuationHelper::patch_return_address_at(intptr_t* sp,\n+                                                        address pc) {\n+  *(address*)sp = pc;\n+}\n+#endif \/\/ !CPU_OVERRIDES_RETURN_ADDRESS_ACCESSORS\n+\n@@ -52,0 +63,4 @@\n+inline address ContinuationHelper::Frame::return_pc(const frame& f) {\n+  return return_address_at((intptr_t *)return_pc_address(f));\n+}\n+\n@@ -78,1 +93,1 @@\n-  return *return_pc_address(f);\n+  return return_address_at((intptr_t *)return_pc_address(f));\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.inline.hpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-int jdk_internal_vm_StackChunk::_argsize_offset;\n+int jdk_internal_vm_StackChunk::_bottom_offset;\n@@ -96,1 +96,1 @@\n-  macro(_argsize_offset, k, vmSymbols::argsize_name(), int_signature,        false);\n+  macro(_bottom_offset,  k, vmSymbols::bottom_name(),  int_signature,        false);\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  static int _argsize_offset;\n+  static int _bottom_offset;\n@@ -115,2 +115,3 @@\n-  static inline int argsize(oop chunk);\n-  static inline void set_argsize(oop chunk, int value);\n+  static inline int bottom(oop chunk);\n+  static inline void set_bottom(oop chunk, int value);\n+  static inline void set_bottom(HeapWord* chunk, int value);\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -118,0 +118,7 @@\n+inline void jdk_internal_vm_StackChunk::set_bottom(HeapWord* chunk, int value) {\n+  \/\/ Used by StackChunkAllocator before the Object has been finished,\n+  \/\/ so don't cast too oop and use int_field_put in this function.\n+  assert(_bottom_offset != 0, \"must be set\");\n+  *(int*)(((char*)chunk) + _bottom_offset) = (int)value;\n+}\n+\n@@ -119,1 +126,1 @@\n-  return chunk->int_field(_sp_offset);\n+  return chunk->int_field_relaxed(_sp_offset);\n@@ -123,1 +130,1 @@\n-  chunk->int_field_put(_sp_offset, value);\n+  chunk->int_field_put_relaxed(_sp_offset, value);\n@@ -141,2 +148,2 @@\n-inline int jdk_internal_vm_StackChunk::argsize(oop chunk) {\n-  return chunk->int_field(_argsize_offset);\n+inline int jdk_internal_vm_StackChunk::bottom(oop chunk) {\n+  return chunk->int_field(_bottom_offset);\n@@ -145,2 +152,2 @@\n-inline void jdk_internal_vm_StackChunk::set_argsize(oop chunk, int value) {\n-  chunk->int_field_put(_argsize_offset, value);\n+inline void jdk_internal_vm_StackChunk::set_bottom(oop chunk, int value) {\n+  chunk->int_field_put(_bottom_offset, value);\n","filename":"src\/hotspot\/share\/runtime\/continuationJavaClasses.inline.hpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    private int argsize; \/\/ bottom stack-passed arguments, in words\n+    private int bottom;  \/\/ in words\n@@ -39,1 +39,1 @@\n-    public boolean isEmpty()   { return sp >= (size - argsize); }\n+    public boolean isEmpty()   { return sp == bottom; }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/StackChunk.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2022, Arm Limited. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Arm Limited. All rights reserved.\n@@ -258,1 +258,2 @@\n-            code.emitInt(0xdac103be);  \/\/ pacia x30, x29\n+            code.emitInt(0xf94003df);  \/\/ ldr xzr, [x30]\n+            code.emitInt(0xd503231f);  \/\/ paciaz\n@@ -260,2 +261,2 @@\n-        code.emitInt(0xa9be7bfd);  \/\/ stp x29, x30, [sp, #-32]!\n-        code.emitInt(0x910003fd);  \/\/ mov x29, sp\n+        code.emitInt(0xa9bf7bfd);      \/\/ stp x29, x30, [sp, #-16]!\n+        code.emitInt(0x910003fd);      \/\/ mov x29, sp\n@@ -471,2 +472,2 @@\n-        code.emitInt(0x910003bf);  \/\/ mov sp, x29\n-        code.emitInt(0xa8c27bfd);  \/\/ ldp x29, x30, [sp], #32\n+        code.emitInt(0x910003bf);      \/\/ mov sp, x29\n+        code.emitInt(0xa8c17bfd);      \/\/ ldp x29, x30, [sp], #16\n@@ -474,1 +475,2 @@\n-            code.emitInt(0xdac113be);  \/\/ autia x30, x29\n+            code.emitInt(0xd503239f);  \/\/ autiaz\n+            code.emitInt(0xf94003df);  \/\/ ldr xzr, [x30]\n@@ -476,1 +478,1 @@\n-        code.emitInt(0xd65f03c0);  \/\/ ret\n+        code.emitInt(0xd65f03c0);      \/\/ ret\n@@ -482,2 +484,2 @@\n-        code.emitInt(0x910003bf);  \/\/ mov sp, x29\n-        code.emitInt(0xa8c27bfd);  \/\/ ldp x29, x30, [sp], #32\n+        code.emitInt(0x910003bf);      \/\/ mov sp, x29\n+        code.emitInt(0xa8c17bfd);      \/\/ ldp x29, x30, [sp], #16\n@@ -485,1 +487,2 @@\n-            code.emitInt(0xdac113be);  \/\/ autia x30, x29\n+            code.emitInt(0xd503239f);  \/\/ autiaz\n+            code.emitInt(0xf94003df);  \/\/ ldr xzr, [x30]\n@@ -487,1 +490,1 @@\n-        code.emitInt(0xd65f03c0);  \/\/ ret\n+        code.emitInt(0xd65f03c0);      \/\/ ret\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/aarch64\/AArch64TestAssembler.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"}]}