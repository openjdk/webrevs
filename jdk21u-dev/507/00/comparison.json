{"files":[{"patch":"@@ -38,1 +38,1 @@\n-#elif (__GNUC__ > 13) || ((__GNUC__ == 13) && (__GNUC_MINOR__ >= 2))\n+#elif (__GNUC__ > 13) || ((__GNUC__ == 13) && (__GNUC_MINOR__ > 2))\n@@ -117,0 +117,38 @@\n+#ifndef FULL_COMPILER_ATOMIC_SUPPORT\n+\/\/ The implementation of `__atomic_compare_exchange` lacks sign extensions\n+\/\/ in GCC 13.2 and lower when using with 32-bit unsigned integers on RV64,\n+\/\/ so we should implement it manually.\n+\/\/ GCC bug: https:\/\/gcc.gnu.org\/bugzilla\/show_bug.cgi?id=114130.\n+\/\/ See also JDK-8326936.\n+template<>\n+template<typename T>\n+inline T Atomic::PlatformCmpxchg<4>::operator()(T volatile* dest __attribute__((unused)),\n+                                                T compare_value,\n+                                                T exchange_value,\n+                                                atomic_memory_order order) const {\n+  STATIC_ASSERT(4 == sizeof(T));\n+\n+  int32_t old_value;\n+  uint64_t rc_temp;\n+\n+  if (order != memory_order_relaxed) {\n+    FULL_MEM_BARRIER;\n+  }\n+\n+  __asm__ __volatile__ (\n+    \"1:  lr.w      %0, %2      \\n\\t\"\n+    \"    bne       %0, %3, 2f  \\n\\t\"\n+    \"    sc.w      %1, %4, %2  \\n\\t\"\n+    \"    bnez      %1, 1b      \\n\\t\"\n+    \"2:                        \\n\\t\"\n+    : \/*%0*\/\"=&r\" (old_value), \/*%1*\/\"=&r\" (rc_temp), \/*%2*\/\"+A\" (*dest)\n+    : \/*%3*\/\"r\" ((int64_t)(int32_t)compare_value), \/*%4*\/\"r\" (exchange_value)\n+    : \"memory\" );\n+\n+  if (order != memory_order_relaxed) {\n+    FULL_MEM_BARRIER;\n+  }\n+  return (T)old_value;\n+}\n+#endif\n+\n@@ -151,1 +189,1 @@\n-  STATIC_ASSERT(byte_size >= 4);\n+  STATIC_ASSERT(byte_size > 4);\n@@ -155,1 +193,0 @@\n-  T value = compare_value;\n@@ -160,1 +197,1 @@\n-  __atomic_compare_exchange(dest, &value, &exchange_value, \/* weak *\/ false,\n+  __atomic_compare_exchange(dest, &compare_value, &exchange_value, \/* weak *\/ false,\n@@ -166,33 +203,1 @@\n-  return value;\n-}\n-\n-template<>\n-template<typename T>\n-inline T Atomic::PlatformCmpxchg<4>::operator()(T volatile* dest __attribute__((unused)),\n-                                                T compare_value,\n-                                                T exchange_value,\n-                                                atomic_memory_order order) const {\n-  STATIC_ASSERT(4 == sizeof(T));\n-\n-  T old_value;\n-  long rc;\n-\n-  if (order != memory_order_relaxed) {\n-    FULL_MEM_BARRIER;\n-  }\n-\n-  __asm__ __volatile__ (\n-    \"1:  sext.w    %1, %3      \\n\\t\" \/\/ sign-extend compare_value\n-    \"    lr.w      %0, %2      \\n\\t\"\n-    \"    bne       %0, %1, 2f  \\n\\t\"\n-    \"    sc.w      %1, %4, %2  \\n\\t\"\n-    \"    bnez      %1, 1b      \\n\\t\"\n-    \"2:                        \\n\\t\"\n-    : \/*%0*\/\"=&r\" (old_value), \/*%1*\/\"=&r\" (rc), \/*%2*\/\"+A\" (*dest)\n-    : \/*%3*\/\"r\" (compare_value), \/*%4*\/\"r\" (exchange_value)\n-    : \"memory\" );\n-\n-  if (order != memory_order_relaxed) {\n-    FULL_MEM_BARRIER;\n-  }\n-  return old_value;\n+  return compare_value;\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/atomic_linux_riscv.hpp","additions":42,"deletions":37,"binary":false,"changes":79,"status":"modified"}]}