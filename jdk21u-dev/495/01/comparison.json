{"files":[{"patch":"@@ -4203,0 +4203,19 @@\n+  \/\/ In the pointer analysis, and especially the AlignVector, analysis we assume that\n+  \/\/ stride and scale are not too large. For example, we multiply \"scale * stride\",\n+  \/\/ and assume that this does not overflow the int range. We also take \"abs(scale)\"\n+  \/\/ and \"abs(stride)\", which would overflow for min_int = -(2^31). Still, we want\n+  \/\/ to at least allow small and moderately large stride and scale. Therefore, we\n+  \/\/ allow values up to 2^30, which is only a factor 2 smaller than the max\/min int.\n+  \/\/ Normal performance relevant code will have much lower values. And the restriction\n+  \/\/ allows us to keep the rest of the autovectorization code much simpler, since we\n+  \/\/ do not have to deal with overflows.\n+  jlong long_scale  = _scale;\n+  jlong long_stride = slp->lp()->stride_is_con() ? slp->iv_stride() : 0;\n+  jlong max_val = 1 << 30;\n+  if (abs(long_scale) >= max_val ||\n+      abs(long_stride) >= max_val ||\n+      abs(long_scale * long_stride) >= max_val) {\n+    assert(!valid(), \"adr stride*scale is too large\");\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=vanilla\n+ * @bug 8328938\n+ * @summary Test autovectorization with large scale and stride\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run main compiler.loopopts.superword.TestLargeScaleAndStride\n+ *\/\n+\n+\/*\n+ * @test id=AlignVector\n+ * @bug 8328938\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -XX:+AlignVector compiler.loopopts.superword.TestLargeScaleAndStride\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+public class TestLargeScaleAndStride {\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    static int RANGE = 100_000;\n+\n+    public static void main(String[] args) {\n+        byte[] a = new byte[100];\n+        fill(a);\n+\n+        byte[] gold1a = a.clone();\n+        byte[] gold1b = a.clone();\n+        byte[] gold2a = a.clone();\n+        byte[] gold2b = a.clone();\n+        byte[] gold2c = a.clone();\n+        byte[] gold2d = a.clone();\n+        byte[] gold3  = a.clone();\n+        test1a(gold1a);\n+        test1b(gold1b);\n+        test2a(gold2a);\n+        test2b(gold2b);\n+        test2c(gold2c);\n+        test2d(gold2d);\n+        test3(gold3);\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test1a(c);\n+            verify(c, gold1a);\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test1b(c);\n+            verify(c, gold1b);\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test2a(c);\n+            verify(c, gold2a);\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test2b(c);\n+            verify(c, gold2b);\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test2c(c);\n+            verify(c, gold2c);\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test2d(c);\n+            verify(c, gold2d);\n+        }\n+\n+        for (int i = 0; i < 100; i++) {\n+            byte[] c = a.clone();\n+            test3(c);\n+            verify(c, gold3);\n+        }\n+    }\n+\n+    static void fill(byte[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+          a[i] = (byte)i;\n+        }\n+    }\n+\n+    static void verify(byte[] a, byte[] b) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] != b[i]) {\n+                throw new RuntimeException(\"wrong value: \" + i + \": \" + a[i] + \" != \" + b[i]);\n+            }\n+        }\n+    }\n+\n+    static void test1a(byte[] a) {\n+        int scale = 1 << 31;\n+        for (int i = 0; i < RANGE; i+=2) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            \/\/ i is a multiple of 2\n+            \/\/ 2 * (1 >> 31) -> overflow to zero\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+\n+    static void test1b(byte[] a) {\n+        int scale = 1 << 31;\n+        for (int i = RANGE-2; i >= 0; i-=2) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            \/\/ i is a multiple of 2\n+            \/\/ 2 * (1 >> 31) -> overflow to zero\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+\n+    static void test2a(byte[] a) {\n+        int scale = 1 << 30;\n+        for (int i = 0; i < RANGE; i+=4) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            \/\/ i is a multiple of 4\n+            \/\/ 4 * (1 >> 30) -> overflow to zero\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+\n+\n+    static void test2b(byte[] a) {\n+        int scale = 1 << 30;\n+        for (int i = RANGE-4; i >= 0; i-=4) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            \/\/ i is a multiple of 4\n+            \/\/ 4 * (1 >> 30) -> overflow to zero\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+\n+    static void test2c(byte[] a) {\n+        int scale = -(1 << 30);\n+        for (int i = 0; i < RANGE; i+=4) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            \/\/ i is a multiple of 4\n+            \/\/ 4 * (1 >> 30) -> overflow to zero\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+\n+    static void test2d(byte[] a) {\n+        int scale = -(1 << 30);\n+        for (int i = RANGE-4; i >= 0; i-=4) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            \/\/ i is a multiple of 4\n+            \/\/ 4 * (1 >> 30) -> overflow to zero\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+\n+    static void test3(byte[] a) {\n+        int scale =   1 << 28;\n+        int stride =  1 << 4;\n+        int start = -(1 << 30);\n+        int end =     1 << 30;\n+        for (int i = start; i < end; i+=stride) {\n+            long base = UNSAFE.ARRAY_BYTE_BASE_OFFSET;\n+            int j = scale * i; \/\/ always zero\n+            byte v0 = UNSAFE.getByte(a, base + (int)(j + 0));\n+            byte v1 = UNSAFE.getByte(a, base + (int)(j + 1));\n+            byte v2 = UNSAFE.getByte(a, base + (int)(j + 2));\n+            byte v3 = UNSAFE.getByte(a, base + (int)(j + 3));\n+            UNSAFE.putByte(a, base + (int)(j + 0), (byte)(v0 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 1), (byte)(v1 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 2), (byte)(v2 + 1));\n+            UNSAFE.putByte(a, base + (int)(j + 3), (byte)(v3 + 1));\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestLargeScaleAndStride.java","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"}]}