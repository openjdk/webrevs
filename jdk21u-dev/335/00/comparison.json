{"files":[{"patch":"@@ -1105,1 +1105,1 @@\n-void *os::dll_load(const char *filename, char *ebuf, int ebuflen) {\n+static void* dll_load_library(const char *filename, char *ebuf, int ebuflen) {\n@@ -1108,1 +1108,0 @@\n-\n@@ -1154,0 +1153,20 @@\n+\/\/ Load library named <filename>\n+\/\/ If filename matches <name>.so, and loading fails, repeat with <name>.a.\n+void *os::dll_load(const char *filename, char *ebuf, int ebuflen) {\n+  void* result = nullptr;\n+  char* const file_path = strdup(filename);\n+  char* const pointer_to_dot = strrchr(file_path, '.');\n+  const char old_extension[] = \".so\";\n+  const char new_extension[] = \".a\";\n+  STATIC_ASSERT(sizeof(old_extension) >= sizeof(new_extension));\n+  \/\/ First try to load the existing file.\n+  result = dll_load_library(filename, ebuf, ebuflen);\n+  \/\/ If the load fails,we try to reload by changing the extension to .a for .so files only.\n+  \/\/ Shared object in .so format dont have braces, hence they get removed for archives with members.\n+  if (result == nullptr && pointer_to_dot != nullptr && strcmp(pointer_to_dot, old_extension) == 0) {\n+    snprintf(pointer_to_dot, sizeof(old_extension), \"%s\", new_extension);\n+    result = dll_load_library(file_path, ebuf, ebuflen);\n+  }\n+  FREE_C_HEAP_ARRAY(char, file_path);\n+  return result;\n+}\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"}]}