{"files":[{"patch":"@@ -2726,0 +2726,1 @@\n+    assert_different_registers(obj, tmp, rscratch1, rscratch2, mdo_addr.base(), mdo_addr.index());\n@@ -2727,0 +2728,2 @@\n+  } else {\n+    assert_different_registers(obj, rscratch1, rscratch2, mdo_addr.base(), mdo_addr.index());\n@@ -2783,2 +2786,2 @@\n-          \/\/ There is a chance that the checks above (re-reading profiling\n-          \/\/ data from memory) fail if another thread has just set the\n+          \/\/ There is a chance that the checks above\n+          \/\/ fail if another thread has just set the\n@@ -2787,0 +2790,1 @@\n+          __ eor(tmp, tmp, rscratch2); \/\/ get back original value before XOR\n@@ -2811,0 +2815,4 @@\n+#ifdef ASSERT\n+        __ andr(tmp, tmp, TypeEntries::type_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n@@ -2842,0 +2850,4 @@\n+#ifdef ASSERT\n+        __ andr(tmp, tmp, TypeEntries::type_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1672,1 +1672,1 @@\n-  assert_different_registers(obj, rscratch1);\n+  assert_different_registers(obj, rscratch1, mdo_addr.base(), mdo_addr.index());\n@@ -1694,1 +1694,0 @@\n-  ldr(rscratch1, mdo_addr);\n@@ -1698,2 +1697,2 @@\n-  \/\/ There is a chance that the checks above (re-reading profiling\n-  \/\/ data from memory) fail if another thread has just set the\n+  \/\/ There is a chance that the checks above\n+  \/\/ fail if another thread has just set the\n@@ -1701,0 +1700,1 @@\n+  eor(obj, obj, rscratch1); \/\/ get back original value before XOR\n@@ -1713,0 +1713,4 @@\n+#ifdef ASSERT\n+  andr(obj, obj, TypeEntries::type_mask);\n+  verify_klass_ptr(obj);\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1651,2 +1651,2 @@\n-      \/\/ There is a chance that the checks above (re-reading profiling\n-      \/\/ data from memory) fail if another thread has just set the\n+      \/\/ There is a chance that the checks above\n+      \/\/ fail if another thread has just set the\n@@ -1655,0 +1655,1 @@\n+      __ xorr(tmp, tmp, t1); \/\/ get back original value before XOR\n@@ -1681,0 +1682,4 @@\n+#ifdef ASSERT\n+    __ andi(tmp, tmp, TypeEntries::type_mask);\n+    __ verify_klass_ptr(tmp);\n+#endif\n@@ -1715,0 +1720,4 @@\n+#ifdef ASSERT\n+    __ andi(tmp, tmp, TypeEntries::type_mask);\n+    __ verify_klass_ptr(tmp);\n+#endif\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1735,2 +1735,2 @@\n-  ld(t0, mdo_addr);\n-  xorr(obj, obj, t0);\n+  ld(tmp, mdo_addr);\n+  xorr(obj, obj, tmp);\n@@ -1746,6 +1746,5 @@\n-  ld(t0, mdo_addr);\n-  beqz(t0, none);\n-  mv(tmp, (u1)TypeEntries::null_seen);\n-  beq(t0, tmp, none);\n-  \/\/ There is a chance that the checks above (re-reading profiling\n-  \/\/ data from memory) fail if another thread has just set the\n+  beqz(tmp, none);\n+  mv(t0, (u1)TypeEntries::null_seen);\n+  beq(tmp, t0, none);\n+  \/\/ There is a chance that the checks above\n+  \/\/ fail if another thread has just set the\n@@ -1753,2 +1752,3 @@\n-  ld(t0, mdo_addr);\n-  xorr(obj, obj, t0);\n+  xorr(obj, obj, tmp); \/\/ get back original value before XOR\n+  ld(tmp, mdo_addr);\n+  xorr(obj, obj, tmp);\n@@ -1765,0 +1765,4 @@\n+#ifdef ASSERT\n+  andi(obj, obj, TypeEntries::type_mask);\n+  verify_klass_ptr(obj);\n+#endif\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -3643,2 +3643,13 @@\n-  if (tmp != obj) {\n-    __ mov(tmp, obj);\n+#ifdef ASSERT\n+  if (obj == tmp) {\n+#ifdef _LP64\n+    assert_different_registers(obj, rscratch1, mdo_addr.base(), mdo_addr.index());\n+#else\n+    assert_different_registers(obj, mdo_addr.base(), mdo_addr.index());\n+#endif\n+  } else {\n+#ifdef _LP64\n+    assert_different_registers(obj, tmp, rscratch1, mdo_addr.base(), mdo_addr.index());\n+#else\n+    assert_different_registers(obj, tmp, mdo_addr.base(), mdo_addr.index());\n+#endif\n@@ -3646,0 +3657,1 @@\n+#endif\n@@ -3647,1 +3659,1 @@\n-    __ testptr(tmp, tmp);\n+    __ testptr(obj, obj);\n@@ -3650,0 +3662,8 @@\n+      __ testptr(mdo_addr, TypeEntries::null_seen);\n+#ifndef ASSERT\n+      __ jccb(Assembler::notZero, next); \/\/ already set\n+#else\n+      __ jcc(Assembler::notZero, next); \/\/ already set\n+#endif\n+      \/\/ atomic update to prevent overwriting Klass* with 0\n+      __ lock();\n@@ -3660,1 +3680,1 @@\n-    __ testptr(tmp, tmp);\n+    __ testptr(obj, obj);\n@@ -3672,1 +3692,1 @@\n-      __ load_klass(tmp, tmp, tmp_load_klass);\n+      __ load_klass(tmp, obj, tmp_load_klass);\n@@ -3687,1 +3707,1 @@\n-          __ load_klass(tmp, tmp, tmp_load_klass);\n+          __ load_klass(tmp, obj, tmp_load_klass);\n@@ -3689,1 +3709,3 @@\n-\n+#ifdef _LP64\n+        __ mov(rscratch1, tmp); \/\/ save original value before XOR\n+#endif\n@@ -3700,4 +3722,3 @@\n-          __ cmpptr(mdo_addr, 0);\n-          __ jccb(Assembler::equal, none);\n-          __ cmpptr(mdo_addr, TypeEntries::null_seen);\n-          __ jccb(Assembler::equal, none);\n+          __ testptr(mdo_addr, TypeEntries::type_mask);\n+          __ jccb(Assembler::zero, none);\n+#ifdef _LP64\n@@ -3707,0 +3728,1 @@\n+          __ mov(tmp, rscratch1); \/\/ get back original value before XOR\n@@ -3710,0 +3732,1 @@\n+#endif\n@@ -3715,2 +3738,1 @@\n-        __ movptr(tmp, mdo_addr);\n-        __ testptr(tmp, TypeEntries::type_unknown);\n+        __ testptr(mdo_addr, TypeEntries::type_unknown);\n@@ -3729,0 +3751,4 @@\n+#ifdef ASSERT\n+        __ andptr(tmp, TypeEntries::type_klass_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n@@ -3743,4 +3769,2 @@\n-          __ cmpptr(mdo_addr, 0);\n-          __ jcc(Assembler::equal, ok);\n-          __ cmpptr(mdo_addr, TypeEntries::null_seen);\n-          __ jcc(Assembler::equal, ok);\n+          __ testptr(mdo_addr, TypeEntries::type_mask);\n+          __ jcc(Assembler::zero, ok);\n@@ -3762,0 +3786,4 @@\n+#ifdef ASSERT\n+        __ andptr(tmp, TypeEntries::type_klass_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n@@ -3766,2 +3794,1 @@\n-        __ movptr(tmp, mdo_addr);\n-        __ testptr(tmp, TypeEntries::type_unknown);\n+        __ testptr(mdo_addr, TypeEntries::type_unknown);\n@@ -3773,2 +3800,0 @@\n-\n-    __ bind(next);\n@@ -3776,0 +3801,1 @@\n+  __ bind(next);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":47,"deletions":21,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -54,0 +54,6 @@\n+#ifdef _LP64\n+  assert_different_registers(obj, rscratch1, mdo_addr.base(), mdo_addr.index());\n+#else\n+  assert_different_registers(obj, mdo_addr.base(), mdo_addr.index());\n+#endif\n+\n@@ -58,0 +64,4 @@\n+  testptr(mdo_addr, TypeEntries::null_seen);\n+  jccb(Assembler::notZero, next); \/\/ null already seen. Nothing to do anymore.\n+  \/\/ atomic update to prevent overwriting Klass* with 0\n+  lock();\n@@ -63,0 +73,3 @@\n+#ifdef _LP64\n+  mov(rscratch1, obj);\n+#endif\n@@ -77,0 +90,1 @@\n+#ifdef _LP64\n@@ -80,0 +94,1 @@\n+  mov(obj, rscratch1);\n@@ -83,0 +98,1 @@\n+#endif\n@@ -91,0 +107,4 @@\n+#ifdef ASSERT\n+  andptr(obj, TypeEntries::type_klass_mask);\n+  verify_klass_ptr(obj);\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -896,0 +896,1 @@\n+  void testptr(Address src, int32_t imm32) {  LP64_ONLY(testq(src, imm32)) NOT_LP64(testl(src, imm32)); }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}