{"files":[{"patch":"@@ -2421,0 +2421,7 @@\n+\/\/ Available cpus of the host machine, Linux only.\n+\/\/ Used in container testing.\n+WB_ENTRY(jint, WB_HostCPUs(JNIEnv* env, jobject o))\n+  LINUX_ONLY(return os::Linux::active_processor_count();)\n+  return -1; \/\/ Not used\/implemented on other platforms\n+WB_END\n+\n@@ -2827,0 +2834,1 @@\n+  {CC\"hostCPUs\",                  CC\"()I\",            (void*)&WB_HostCPUs },\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+    systemd.support \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class HelloSystemd {\n+    public static void main(String args[]) {\n+        System.out.println(\"Hello Systemd\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/systemd\/HelloSystemd.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.containers.systemd.SystemdRunOptions;\n+import jdk.test.lib.containers.systemd.SystemdTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.whitebox.WhiteBox;\n+import jtreg.SkippedException;\n+\n+\/*\n+ * @test\n+ * @bug 8322420 8217338\n+ * @summary Memory\/CPU awareness test for JDK-under-test inside a systemd slice.\n+ * @requires systemd.support\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.platform\n+ * @build HelloSystemd jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar whitebox.jar jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:whitebox.jar -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI SystemdMemoryAwarenessTest\n+ *\/\n+public class SystemdMemoryAwarenessTest {\n+\n+    private static final int MB = 1024 * 1024;\n+    private static final WhiteBox wb = WhiteBox.getWhiteBox();\n+    private static final String TEST_SLICE_NAME = SystemdMemoryAwarenessTest.class.getSimpleName() + \"HS\";\n+\n+    public static void main(String[] args) throws Exception {\n+       testHelloSystemd();\n+    }\n+\n+    private static void testHelloSystemd() throws Exception {\n+        SystemdRunOptions opts = SystemdTestUtils.newOpts(\"HelloSystemd\");\n+        \/\/ 1 GB memory, but the limit in the lower hierarchy is 512M\n+        opts.memoryLimit(\"1024M\");\n+        int expectedMemLimit = 512;\n+        \/\/ expected detected limit we test for, 512MB\n+        opts.sliceDMemoryLimit(String.format(\"%dM\", expectedMemLimit));\n+        int physicalCpus = wb.hostCPUs();\n+        if (physicalCpus < 2) {\n+           System.err.println(\"WARNING: host system only has \" + physicalCpus + \" cpus. Expected >= 2\");\n+           System.err.println(\"The active_processor_count assertion will trivially pass.\");\n+        }\n+        \/\/ Use a CPU core limit of 1 for best coverage\n+        int coreLimit = 1;\n+        System.out.println(\"DEBUG: Running test with a CPU limit of \" + coreLimit);\n+        opts.cpuLimit(String.format(\"%d%%\", coreLimit * 100));\n+        opts.sliceName(TEST_SLICE_NAME);\n+\n+        OutputAnalyzer out = SystemdTestUtils.buildAndRunSystemdJava(opts);\n+        out.shouldHaveExitValue(0)\n+           .shouldContain(\"Hello Systemd\")\n+           .shouldContain(String.format(\"Memory Limit is: %d\", (expectedMemLimit * MB)));\n+        try {\n+            out.shouldContain(\"OSContainer::active_processor_count: \" + coreLimit);\n+        } catch (RuntimeException e) {\n+            \/\/ CPU delegation needs to be enabled when run as user on cg v2\n+            if (SystemdTestUtils.RUN_AS_USER) {\n+                String hint = \"When run as user on cg v2 cpu delegation needs to be configured!\";\n+                throw new SkippedException(hint);\n+            }\n+            throw e;\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/systemd\/SystemdMemoryAwarenessTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/containers\/systemd\/TEST.properties","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/sa\/sadebugd\/TEST.properties","status":"copied"},{"patch":"@@ -103,0 +103,1 @@\n+    systemd.support \\\n","filename":"test\/jdk\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+        map.put(\"systemd.support\", this::systemdSupport);\n@@ -564,1 +565,1 @@\n-              isSupported = checkDockerSupport();\n+              isSupported = checkProgramSupport(\"checkDockerSupport()\", Container.ENGINE_COMMAND);\n@@ -574,0 +575,21 @@\n+    \/**\n+     * A simple check for systemd support\n+     *\n+     * @return true if systemd is supported in a given environment\n+     *\/\n+    protected String systemdSupport() {\n+        log(\"Entering systemdSupport()\");\n+\n+        boolean isSupported = Platform.isLinux();\n+        if (isSupported) {\n+           try {\n+              isSupported = checkProgramSupport(\"checkSystemdSupport()\", \"systemd-run\");\n+           } catch (Exception e) {\n+              isSupported = false;\n+           }\n+         }\n+\n+        log(\"systemdSupport(): returning isSupported = \" + isSupported);\n+        return \"\" + isSupported;\n+    }\n+\n@@ -608,3 +630,3 @@\n-    private boolean checkDockerSupport() throws IOException, InterruptedException {\n-        log(\"checkDockerSupport(): entering\");\n-        ProcessBuilder pb = new ProcessBuilder(\"which\", Container.ENGINE_COMMAND);\n+    private boolean checkProgramSupport(String logString, String cmd) throws IOException, InterruptedException {\n+        log(logString + \": entering\");\n+        ProcessBuilder pb = new ProcessBuilder(\"which\", cmd);\n@@ -612,2 +634,2 @@\n-            redirectOutputToLogFile(\"checkDockerSupport(): which <container-engine>\",\n-                                                      pb, \"which-container\");\n+            redirectOutputToLogFile(logString + \": which \" + cmd,\n+                                                      pb, \"which-cmd\");\n@@ -618,1 +640,1 @@\n-        log(String.format(\"checkDockerSupport(): exitValue = %s, pid = %s\", exitValue, p.pid()));\n+        log(String.format(\"%s: exitValue = %s, pid = %s\", logString, exitValue, p.pid()));\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":29,"deletions":7,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.systemd;\n+\n+import static jdk.test.lib.Asserts.assertNotNull;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+\n+\/\/ This class represents options for running java inside systemd slices\n+\/\/ in test environment.\n+public class SystemdRunOptions {\n+    public ArrayList<String> javaOpts = new ArrayList<>();\n+    public String classToRun;  \/\/ class or \"-version\"\n+    public ArrayList<String> classParams = new ArrayList<>();\n+    public String memoryLimit; \/\/ used in slice for MemoryLimit property\n+    public String cpuLimit;    \/\/ used in slice for CPUQuota property\n+    public String sliceName;   \/\/ name of the slice (nests CPU in memory)\n+    public String sliceDMemoryLimit; \/\/ used in jdk_internal.slice.d\n+    public String sliceDCpuLimit;    \/\/ used in jdk_internal.slice.d\n+\n+    \/**\n+     * Convenience constructor for most common use cases in testing.\n+     * @param classToRun  a class to run, or \"-version\"\n+     * @param javaOpts  java options to use\n+     *\n+     * @return Default docker run options\n+     *\/\n+    public SystemdRunOptions(String classToRun, String... javaOpts) {\n+        this.classToRun = classToRun;\n+        Collections.addAll(this.javaOpts, javaOpts);\n+        this.sliceName = defaultSliceName();\n+    }\n+\n+    private static String defaultSliceName() {\n+        \/\/ Create a unique name for a systemd slice\n+        \/\/ jtreg guarantees that test.name is unique among all concurrently executing\n+        \/\/ tests. For example, if you have two test roots:\n+        \/\/\n+        \/\/     $ find test -type f\n+        \/\/     test\/foo\/TEST.ROOT\n+        \/\/     test\/foo\/my\/TestCase.java\n+        \/\/     test\/bar\/TEST.ROOT\n+        \/\/     test\/bar\/my\/TestCase.java\n+        \/\/     $ jtreg -concur:2 test\/foo test\/bar\n+        \/\/\n+        \/\/ jtreg will first run all the tests under test\/foo. When they are all finished, then\n+        \/\/ jtreg will run all the tests under test\/bar. So you will never have two concurrent\n+        \/\/ test cases whose test.name is \"my\/TestCase.java\"\n+        String testname = System.getProperty(\"test.name\");\n+        assertNotNull(testname, \"must be set by jtreg\");\n+        testname = testname.replace(\".java\", \"\");\n+        testname = testname.replace(\"\/\", \"_\");\n+        testname = testname.replace(\"\\\\\", \"_\");\n+        testname = testname.replace(\"-\", \"_\");\n+\n+        \/\/ Example:\n+        \/\/  Memory: \"test_containers_systemd_TestMemoryAwareness\"\n+        \/\/  CPU:    \"test_containers_systemd_TestMemoryAwareness-cpu\" => derived\n+        return testname;\n+    }\n+\n+    \/**\n+     * The memory limit set with a .slice file in the systemd\n+     * config directory.\n+     *\n+     * @param memLimit The memory limit to set (e.g. 1000M).\n+     * @return The run options.\n+     *\/\n+    public SystemdRunOptions memoryLimit(String memLimit) {\n+        this.memoryLimit = memLimit;\n+        return this;\n+    }\n+\n+    \/**\n+     * The memory limit to set in the top-level jdk_internal.slice.d\n+     * systemd config directory.\n+     *\n+     * @param memoryLimit The memory limit to set.\n+     * @return The run options.\n+     *\/\n+    public SystemdRunOptions sliceDMemoryLimit(String memoryLimit) {\n+        this.sliceDMemoryLimit = memoryLimit;\n+        return this;\n+    }\n+\n+    \/**\n+     * The CPU limit set with a .slice file in the systemd\n+     * config directory.\n+     *\n+     * @param cpuLimit\n+     * @return The run options.\n+     *\/\n+    public SystemdRunOptions cpuLimit(String cpuLimit) {\n+        this.cpuLimit = cpuLimit;\n+        return this;\n+    }\n+\n+    \/**\n+     * The Cpu limit set in the top-level jdk_internal.slice.d\n+     * systemd config directory.\n+     *\n+     * @param cpuLimit The CPU limit to set to.\n+     * @return The run options.\n+     *\/\n+    public SystemdRunOptions sliceDCpuLimit(String cpuLimit) {\n+        this.sliceDCpuLimit = cpuLimit;\n+        return this;\n+    }\n+\n+    public SystemdRunOptions sliceName(String name) {\n+        this.sliceName = name;\n+        return this;\n+    }\n+\n+    public SystemdRunOptions addJavaOpts(String... opts) {\n+        Collections.addAll(javaOpts, opts);\n+        return this;\n+    }\n+\n+    public SystemdRunOptions addClassOptions(String... opts) {\n+        Collections.addAll(classParams,opts);\n+        return this;\n+    }\n+\n+    public boolean hasSliceDLimit() {\n+        return this.sliceDMemoryLimit != null ||\n+                this.sliceDCpuLimit != null;\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/systemd\/SystemdRunOptions.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,376 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.systemd;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.internal.platform.Metrics;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.util.FileUtils;\n+import jtreg.SkippedException;\n+\n+public class SystemdTestUtils {\n+\n+    private static final String CGROUPS_PROVIDER = Metrics.systemMetrics().getProvider();\n+    private static boolean CGROUPS_V2 = \"cgroupv2\".equals(CGROUPS_PROVIDER);\n+    public static boolean RUN_AS_USER = !Platform.isRoot() && CGROUPS_V2;\n+    private static final String SLICE_NAMESPACE_PREFIX = \"jdk_internal\";\n+    private static final String SLICE_D_MEM_CONFIG_FILE = \"memory-limit.conf\";\n+    private static final String SLICE_D_CPU_CONFIG_FILE = \"cpu-limit.conf\";\n+    private static final String USER_HOME = System.getProperty(\"user.home\");\n+    private static final Path SYSTEMD_CONFIG_HOME_ROOT = Path.of(\"\/\", \"etc\", \"systemd\", \"system\");\n+    private static final Path SYSTEMD_CONFIG_HOME_USER = Path.of(USER_HOME, \".config\", \"systemd\", \"user\");\n+    private static final Path SYSTEMD_CONFIG_HOME = Platform.isRoot() ? SYSTEMD_CONFIG_HOME_ROOT : SYSTEMD_CONFIG_HOME_USER;\n+\n+    \/\/ Specifies how many lines to copy from child STDOUT to main test output.\n+    \/\/ Having too many lines in the main test output will result\n+    \/\/ in JT harness trimming the output, and can lead to loss of useful\n+    \/\/ diagnostic information.\n+    private static final int MAX_LINES_TO_COPY_FOR_CHILD_STDOUT = 100;\n+\n+    public record ResultFiles(Path memory, Path cpu, Path sliceDotDDir) {}\n+\n+    \/**\n+     * Create commonly used options with the class to be launched inside the\n+     * systemd slice\n+     *\n+     * @param testClass The test class or {@code -version}\n+     * @return The basic options.\n+     *\/\n+    public static SystemdRunOptions newOpts(String testClass) {\n+        return new SystemdRunOptions(testClass,\n+                                     \"-Xlog:os+container=trace\",\n+                                     \"-cp\",\n+                                     Utils.TEST_CLASSES);\n+    }\n+\n+    \/**\n+     * Run Java inside a systemd slice with specified parameters and options.\n+     *\n+     * @param opts The systemd slice options when running java\n+     * @return An OutputAnalyzer of the output of the command than ran.\n+     * @throws Exception If something went wrong.\n+     * @throws SkippedException If the test cannot be run (i.e. non-root user\n+     *         on cgroups v1).\n+     *\/\n+    public static OutputAnalyzer buildAndRunSystemdJava(SystemdRunOptions opts) throws Exception, SkippedException {\n+        if (!Platform.isRoot() && !CGROUPS_V2) {\n+            throw new SkippedException(\"Systemd tests require root on cgroup v1. Test skipped!\");\n+        }\n+        ResultFiles files = SystemdTestUtils.buildSystemdSlices(opts);\n+\n+        try {\n+            return SystemdTestUtils.systemdRunJava(opts);\n+        } finally {\n+            cleanupFiles(files);\n+        }\n+    }\n+\n+    private static void cleanupFiles(ResultFiles files) throws IOException {\n+        try {\n+            if (files.memory() != null) {\n+                Files.delete(files.memory());\n+            }\n+            if (files.cpu() != null) {\n+                Files.delete(files.cpu());\n+            }\n+            if (files.sliceDotDDir() != null) {\n+                FileUtils.deleteFileTreeUnchecked(files.sliceDotDDir());\n+            }\n+        } catch (NoSuchFileException e) {\n+            \/\/ ignore\n+        }\n+    }\n+\n+    private static OutputAnalyzer systemdRunJava(SystemdRunOptions opts) throws Exception {\n+        return execute(buildJavaCommand(opts));\n+    }\n+\n+    \/**\n+     * Create systemd slice files under \/etc\/systemd\/system.\n+     *\n+     * The JDK will then run within that slice as provided by the SystemdRunOptions.\n+     *\n+     * @param runOpts The systemd slice options to use when running the test.\n+     * @return The systemd slice files (for cleanup-purposes later).\n+     * @throws Exception\n+     *\/\n+    private static ResultFiles buildSystemdSlices(SystemdRunOptions runOpts) throws Exception {\n+        String sliceName = sliceName(runOpts);\n+        String sliceNameCpu = sliceNameCpu(runOpts);\n+\n+        \/\/ Generate systemd slices for cpu\/memory\n+        String memorySliceContent = getMemorySlice(runOpts, sliceName);\n+        String cpuSliceContent = getCpuSlice(runOpts, sliceName);\n+\n+        \/\/ Ensure base directory exists\n+        Files.createDirectories(SYSTEMD_CONFIG_HOME);\n+        Path sliceDotDDir = null;\n+        if (runOpts.hasSliceDLimit()) {\n+            String dirName = String.format(\"%s.slice.d\", SLICE_NAMESPACE_PREFIX);\n+            sliceDotDDir = SYSTEMD_CONFIG_HOME.resolve(Path.of(dirName));\n+            \/\/ Using createDirectories since we only need to ensure the directory\n+            \/\/ exists. Ignore it if already existent.\n+            Files.createDirectories(sliceDotDDir);\n+\n+            if (runOpts.sliceDMemoryLimit != null) {\n+                Path memoryConfig = sliceDotDDir.resolve(Path.of(SLICE_D_MEM_CONFIG_FILE));\n+                Files.writeString(memoryConfig,\n+                                  getMemoryDSliceContent(runOpts),\n+                                  StandardOpenOption.TRUNCATE_EXISTING,\n+                                  StandardOpenOption.CREATE);\n+            }\n+            if (runOpts.sliceDCpuLimit != null) {\n+                Path cpuConfig = sliceDotDDir.resolve(Path.of(SLICE_D_CPU_CONFIG_FILE));\n+                Files.writeString(cpuConfig,\n+                                  getCPUDSliceContent(runOpts),\n+                                  StandardOpenOption.TRUNCATE_EXISTING,\n+                                  StandardOpenOption.CREATE);\n+            }\n+        }\n+\n+        Path memory, cpu;\n+        try {\n+            \/\/ memory slice\n+            memory = SYSTEMD_CONFIG_HOME.resolve(Path.of(sliceFileName(sliceName)));\n+            \/\/ cpu slice nested in memory\n+            cpu = SYSTEMD_CONFIG_HOME.resolve(Path.of(sliceFileName(sliceNameCpu)));\n+            Files.writeString(memory, memorySliceContent);\n+            Files.writeString(cpu, cpuSliceContent);\n+        } catch (IOException e) {\n+            throw new AssertionError(\"Failed to write systemd slice files\");\n+        }\n+\n+        systemdDaemonReload(cpu, memory, sliceDotDDir);\n+\n+        return new ResultFiles(memory, cpu, sliceDotDDir);\n+    }\n+\n+    private static String sliceName(SystemdRunOptions runOpts) {\n+        \/\/ Slice name may include '-' which is a hierarchical slice indicator.\n+        \/\/ Replace '-' with '_' to avoid side-effects.\n+        return SLICE_NAMESPACE_PREFIX + \"-\" + runOpts.sliceName.replace(\"-\", \"_\");\n+    }\n+\n+    private static String sliceNameCpu(SystemdRunOptions runOpts) {\n+        String slice = sliceName(runOpts);\n+        return String.format(\"%s-cpu\", slice);\n+    }\n+\n+    private static void systemdDaemonReload(Path cpu, Path memory, Path sliceDdir) throws Exception {\n+        List<String> daemonReload = systemCtl();\n+        daemonReload.add(\"daemon-reload\");\n+\n+        if (execute(daemonReload).getExitValue() != 0) {\n+            if (RUN_AS_USER) {\n+                cleanupFiles(new ResultFiles(cpu, memory, sliceDdir));\n+                \/\/ When run as user the systemd user manager needs to be\n+                \/\/ accessible and working. This is usually the case when\n+                \/\/ connected via SSH or user login, but may not work for\n+                \/\/ sessions set up via 'su <user>' or similar.\n+                \/\/ In that case, 'systemctl --user status' usually doesn't\n+                \/\/ work. There is no other option than skip the test.\n+                String msg = \"Service user@.service not properly configured. \" +\n+                             \"Skipping the test!\";\n+                throw new SkippedException(msg);\n+            } else {\n+                throw new AssertionError(\"Failed to reload systemd daemon\");\n+            }\n+        }\n+    }\n+\n+    private static List<String> systemCtl() {\n+        return commandWithUser(\"systemctl\");\n+    }\n+\n+    \/**\n+     * 'baseCommand' or 'baseCommand --user' as list, depending on the cgroups\n+     * version and running user.\n+     *\n+     * @return 'baseCommand' if we are the root user, 'systemctl --user' if\n+     *         the current user is non-root and we are on cgroups v2. Note:\n+     *         Cgroups v1 and non-root is not possible as tests are skipped then.\n+     *\/\n+    private static List<String> commandWithUser(String baseCommand) {\n+        List<String> command = new ArrayList<>();\n+        command.add(baseCommand);\n+        if (RUN_AS_USER) {\n+            command.add(\"--user\");\n+        }\n+        return command;\n+    }\n+\n+    private static String getCpuSlice(SystemdRunOptions runOpts, String sliceName) {\n+        String basicSliceFormat = getBasicSliceFormat();\n+        return String.format(basicSliceFormat, sliceName, getCPUSliceContent(runOpts));\n+    }\n+\n+    private static String getCPUSliceContent(SystemdRunOptions runOpts) {\n+        String format = basicCPUContentFormat();\n+         return String.format(format, runOpts.cpuLimit);\n+    }\n+\n+    private static String getMemorySlice(SystemdRunOptions runOpts, String sliceName) {\n+        String basicSliceFormat = getBasicSliceFormat();\n+        return String.format(basicSliceFormat, sliceName, getMemorySliceContent(runOpts));\n+    }\n+\n+    private static String getMemoryDSliceContent(SystemdRunOptions runOpts) {\n+        String format = \"[Slice]\\n\" + basicMemoryContentFormat();\n+        return String.format(format, runOpts.sliceDMemoryLimit);\n+    }\n+\n+    private static String getCPUDSliceContent(SystemdRunOptions runOpts) {\n+        String format = \"[Slice]\\n\" + basicCPUContentFormat();\n+        return String.format(format, runOpts.sliceDCpuLimit);\n+    }\n+\n+    private static String basicCPUContentFormat() {\n+        return \"\"\"\n+                CPUAccounting=true\n+                CPUQuota=%s\n+                \"\"\";\n+    }\n+\n+    private static String basicMemoryContentFormat() {\n+        return \"\"\"\n+                MemoryAccounting=true\n+                MemoryLimit=%s\n+                \"\"\";\n+    }\n+\n+    private static String getMemorySliceContent(SystemdRunOptions runOpts) {\n+        String format = basicMemoryContentFormat();\n+\n+        return String.format(format, runOpts.memoryLimit);\n+    }\n+\n+    private static String getBasicSliceFormat() {\n+        return \"\"\"\n+               [Unit]\n+               Description=OpenJDK Tests Slice for %s\n+               Before=slices.target\n+\n+               [Slice]\n+               %s\n+               \"\"\";\n+    }\n+\n+    private static String sliceFileName(String sliceName) {\n+        return String.format(\"%s.slice\", sliceName);\n+    }\n+\n+    \/**\n+     * Build the java command to run inside a systemd slice\n+     *\n+     * @param SystemdRunOptions options for running the systemd slice test\n+     *\n+     * @return command\n+     * @throws Exception\n+     *\/\n+    private static List<String> buildJavaCommand(SystemdRunOptions opts) throws Exception {\n+        \/\/ systemd-run [--user] --slice <slice-name>.slice --scope <java>\n+        List<String> javaCmd = systemdRun();\n+        javaCmd.add(\"--slice\");\n+        javaCmd.add(sliceFileName(sliceNameCpu(opts)));\n+        javaCmd.add(\"--scope\");\n+        javaCmd.add(Path.of(Utils.TEST_JDK, \"bin\", \"java\").toString());\n+        javaCmd.addAll(opts.javaOpts);\n+        javaCmd.add(opts.classToRun);\n+        javaCmd.addAll(opts.classParams);\n+        return javaCmd;\n+    }\n+\n+    private static List<String> systemdRun() {\n+        return commandWithUser(\"systemd-run\");\n+    }\n+\n+    \/**\n+     * Execute a specified command in a process, report diagnostic info.\n+     *\n+     * @param command to be executed\n+     * @return The output from the process\n+     * @throws Exception\n+     *\/\n+    private static OutputAnalyzer execute(List<String> command) throws Exception {\n+        return execute(command.toArray(String[]::new));\n+    }\n+\n+    \/**\n+     * Execute a specified command in a process, report diagnostic info.\n+     *\n+     * @param command to be executed\n+     * @return The output from the process\n+     * @throws Exception\n+     *\/\n+    private static OutputAnalyzer execute(String... command) throws Exception {\n+        ProcessBuilder pb = new ProcessBuilder(command);\n+        System.out.println(\"[COMMAND]\\n\" + Utils.getCommandLine(pb));\n+\n+        Process p = pb.start();\n+        long pid = p.pid();\n+        OutputAnalyzer output = new OutputAnalyzer(p);\n+\n+        int max = MAX_LINES_TO_COPY_FOR_CHILD_STDOUT;\n+        String stdout = output.getStdout();\n+        String stdoutLimited = limitLines(stdout, max);\n+        System.out.println(\"[STDERR]\\n\" + output.getStderr());\n+        System.out.println(\"[STDOUT]\\n\" + stdoutLimited);\n+        if (stdout != stdoutLimited) {\n+            System.out.printf(\"Child process STDOUT is limited to %d lines\\n\",\n+                              max);\n+        }\n+\n+        String stdoutLogFile = String.format(\"systemd-stdout-%d.log\", pid);\n+        writeOutputToFile(stdout, stdoutLogFile);\n+        System.out.println(\"Full child process STDOUT was saved to \" + stdoutLogFile);\n+\n+        return output;\n+    }\n+\n+    private static void writeOutputToFile(String output, String fileName) throws Exception {\n+        try (FileWriter fw = new FileWriter(fileName)) {\n+            fw.write(output, 0, output.length());\n+        }\n+    }\n+\n+    private static String limitLines(String buffer, int nrOfLines) {\n+        List<String> l = Arrays.asList(buffer.split(\"\\\\R\"));\n+        if (l.size() < nrOfLines) {\n+            return buffer;\n+        }\n+\n+        return String.join(\"\\n\", l.subList(0, nrOfLines));\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/systemd\/SystemdTestUtils.java","additions":376,"deletions":0,"binary":false,"changes":376,"status":"added"},{"patch":"@@ -732,0 +732,1 @@\n+  public native int hostCPUs();\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}