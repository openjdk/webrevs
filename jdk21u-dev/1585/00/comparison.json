{"files":[{"patch":"@@ -163,0 +163,4 @@\n+    \/\/ inputQ lock: methods that take from the inputQ\n+    \/\/      must not run concurrently.\n+    private final Lock inputQLock = new ReentrantLock();\n+\n@@ -183,0 +187,2 @@\n+        \/\/ prevents drainInputQueue() from running concurrently\n+        inputQLock.lock();\n@@ -197,1 +203,7 @@\n-                    handleReset(rf, subscriber);\n+                    if (endStreamReceived() && rf.getErrorCode() == ResetFrame.NO_ERROR) {\n+                        \/\/ If END_STREAM is already received, complete the requestBodyCF successfully\n+                        \/\/ and stop sending any request data.\n+                        requestBodyCF.complete(null);\n+                    } else {\n+                        handleReset(rf, subscriber);\n+                    }\n@@ -200,1 +212,1 @@\n-                DataFrame df = (DataFrame)frame;\n+                DataFrame df = (DataFrame) frame;\n@@ -250,0 +262,1 @@\n+            inputQLock.unlock();\n@@ -268,0 +281,1 @@\n+                \/\/ cancelImpl will eventually call drainInputQueue();\n@@ -269,1 +283,0 @@\n-                drainInputQueue();\n@@ -274,2 +287,3 @@\n-    \/\/ must only be called from the scheduler schedule() loop.\n-    \/\/ ensure that all received data frames are accounted for\n+    \/\/ Called from the scheduler schedule() loop,\n+    \/\/ or after resetting the stream.\n+    \/\/ Ensures that all received data frames are accounted for\n@@ -278,0 +292,2 @@\n+    \/\/ The inputQLock is used to prevent concurrently taking\n+    \/\/ from the queue.\n@@ -280,7 +296,12 @@\n-        while ((frame = inputQ.poll()) != null) {\n-            if (frame instanceof DataFrame df) {\n-                \/\/ Data frames that have been added to the inputQ\n-                \/\/ must be released using releaseUnconsumed() to\n-                \/\/ account for the amount of unprocessed bytes\n-                \/\/ tracked by the connection.windowUpdater.\n-                connection.releaseUnconsumed(df);\n+        \/\/ will wait until schedule() has finished taking\n+        \/\/ from the queue, if needed.\n+        inputQLock.lock();\n+        try {\n+            while ((frame = inputQ.poll()) != null) {\n+                if (frame instanceof DataFrame df) {\n+                    \/\/ Data frames that have been added to the inputQ\n+                    \/\/ must be released using releaseUnconsumed() to\n+                    \/\/ account for the amount of unprocessed bytes\n+                    \/\/ tracked by the connection.windowUpdater.\n+                    connection.releaseUnconsumed(df);\n+                }\n@@ -288,0 +309,2 @@\n+        } finally {\n+            inputQLock.unlock();\n@@ -399,1 +422,1 @@\n-            inputQ.add(df);\n+           pushDataFrame(len, df);\n@@ -405,0 +428,26 @@\n+    \/\/ Ensures that no data frame is pushed on the inputQ\n+    \/\/ after the stream is closed.\n+    \/\/ Changes to the `closed` boolean are guarded by the\n+    \/\/ stateLock. Contention should be low as only one\n+    \/\/ thread at a time adds to the inputQ, and\n+    \/\/ we can only contend when closing the stream.\n+    \/\/ Note that this method can run concurrently with\n+    \/\/ methods holding the inputQLock: that is OK.\n+    \/\/ The inputQLock is there to ensure that methods\n+    \/\/ taking from the queue are not running concurrently\n+    \/\/ with each others, but concurrently adding at the\n+    \/\/ end of the queue while peeking\/polling at the head\n+    \/\/ is OK.\n+    private void pushDataFrame(int len, DataFrame df) {\n+        boolean closed = false;\n+        stateLock.lock();\n+        try {\n+            if (!(closed = this.closed)) {\n+                inputQ.add(df);\n+            }\n+        } finally {\n+            stateLock.unlock();\n+        }\n+        if (closed && len > 0) connection.releaseUnconsumed(df);\n+    }\n+\n@@ -1513,0 +1562,2 @@\n+        } finally {\n+            drainInputQueue();\n@@ -1736,1 +1787,1 @@\n-                            .formatted(streamid)), ResetFrame.FLOW_CONTROL_ERROR);\n+                        .formatted(streamid)), ResetFrame.FLOW_CONTROL_ERROR);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":65,"deletions":14,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -174,1 +174,5 @@\n-                        assertEquals(ckey, label, \"Unexpected key for \" + query);\n+                        if (i < max - 1) {\n+                            \/\/ the connection window might be exceeded at i == max - 2, which\n+                            \/\/ means that the last request could go on a new connection.\n+                            assertEquals(ckey, label, \"Unexpected key for \" + query);\n+                        }\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/ConnectionFlowControlTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8342075\n+ * @bug 8342075 8343855\n@@ -43,1 +43,0 @@\n-import java.net.http.HttpRequest.BodyPublishers;\n@@ -56,0 +55,1 @@\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpHeadOrGetHandler;\n@@ -72,0 +72,1 @@\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n@@ -95,0 +96,13 @@\n+    static void sleep(long wait) throws InterruptedException {\n+        if (wait <= 0) return;\n+        long remaining = Utils.adjustTimeout(wait);\n+        long start = System.nanoTime();\n+        while (remaining > 0) {\n+            Thread.sleep(remaining);\n+            long end = System.nanoTime();\n+            remaining = remaining - NANOSECONDS.toMillis(end - start);\n+        }\n+        System.out.printf(\"Waited %s ms%n\",\n+                NANOSECONDS.toMillis(System.nanoTime() - start));\n+    }\n+\n@@ -118,1 +132,1 @@\n-                        .POST(BodyPublishers.ofString(\"Hello there!\"))\n+                        .GET()\n@@ -133,1 +147,1 @@\n-                    int wait = uri.startsWith(\"https:\/\/\") ? 500 : 350;\n+                    long wait = uri.startsWith(\"https:\/\/\") ? 800 : 350;\n@@ -135,1 +149,1 @@\n-                        Thread.sleep(Utils.adjustTimeout(wait));\n+                        sleep(wait);\n@@ -177,1 +191,1 @@\n-                        .POST(BodyPublishers.ofString(\"Hello there!\"))\n+                        .GET()\n@@ -191,1 +205,1 @@\n-                    int wait = uri.startsWith(\"https:\/\/\") ? 600 : 300;\n+                    long wait = uri.startsWith(\"https:\/\/\") ? 800 : 350;\n@@ -193,1 +207,1 @@\n-                        Thread.sleep(Utils.adjustTimeout(wait));\n+                        sleep(wait);\n@@ -255,0 +269,1 @@\n+        this.https2TestServer.addHandler(new HttpHeadOrGetHandler(), \"\/https2\/head\/\");\n@@ -256,0 +271,1 @@\n+        String h2Head = \"https:\/\/\" + this.https2TestServer.serverAuthority() + \"\/https2\/head\/z\";\n@@ -264,0 +280,7 @@\n+\n+        \/\/ warmup to eliminate delay due to SSL class loading and initialization.\n+        try (var client = HttpClient.newBuilder().sslContext(sslContext).build()) {\n+            var request = HttpRequest.newBuilder(URI.create(h2Head)).HEAD().build();\n+            var resp = client.send(request, BodyHandlers.discarding());\n+            assertEquals(resp.statusCode(), 200);\n+        }\n@@ -282,2 +305,7 @@\n-                System.out.println(\"Server \" + t.getLocalAddress() + \" received:\\n\"\n-                        + t.getRequestURI() + \": \" + new String(bytes, StandardCharsets.UTF_8));\n+                if (bytes.length != 0) {\n+                    System.out.println(\"Server \" + t.getLocalAddress() + \" received:\\n\"\n+                            + t.getRequestURI() + \": \" + new String(bytes, StandardCharsets.UTF_8));\n+                } else {\n+                    System.out.println(\"No request body for \" + t.getRequestMethod());\n+                }\n+\n@@ -286,1 +314,4 @@\n-                if (bytes.length == 0) bytes = \"no request body!\".getBytes(StandardCharsets.UTF_8);\n+                if (bytes.length == 0) {\n+                    bytes = \"no request body!\"\n+                            .repeat(100).getBytes(StandardCharsets.UTF_8);\n+                }\n@@ -310,1 +341,14 @@\n-                    ((BodyOutputStream) os).writeUncontrolled(resp, 0, resp.length);\n+                    try {\n+                        ((BodyOutputStream) os).writeUncontrolled(resp, 0, resp.length);\n+                    } catch (IOException x) {\n+                        if (t instanceof FCHttp2TestExchange fct) {\n+                            fct.conn.updateConnectionWindow(resp.length);\n+                        }\n+                    }\n+                }\n+            } finally {\n+                if (t instanceof FCHttp2TestExchange fct) {\n+                    fct.responseSent(query);\n+                } else {\n+                    fail(\"Exchange is not %s but %s\"\n+                            .formatted(FCHttp2TestExchange.class.getName(), t.getClass().getName()));\n@@ -313,4 +357,0 @@\n-            if (t instanceof FCHttp2TestExchange fct) {\n-                fct.responseSent(query);\n-            } else fail(\"Exchange is not %s but %s\"\n-                    .formatted(FCHttp2TestExchange.class.getName(), t.getClass().getName()));\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/StreamFlowControlTest.java","additions":56,"deletions":16,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -69,0 +70,3 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+\n@@ -271,1 +275,1 @@\n-            public Version getServerVersion() { return Version.HTTP_1_1; }\n+            public Version getServerVersion() { return HTTP_1_1; }\n@@ -273,1 +277,1 @@\n-            public Version getExchangeVersion() { return Version.HTTP_1_1; }\n+            public Version getExchangeVersion() { return HTTP_1_1; }\n@@ -333,1 +337,1 @@\n-            public Version getServerVersion() { return Version.HTTP_2; }\n+            public Version getServerVersion() { return HTTP_2; }\n@@ -335,1 +339,1 @@\n-            public Version getExchangeVersion() { return Version.HTTP_2; }\n+            public Version getExchangeVersion() { return HTTP_2; }\n@@ -424,0 +428,47 @@\n+    \/**\n+     * An {@link HttpTestHandler} that handles only HEAD and GET\n+     * requests. If another method is used 405 is returned with\n+     * an empty body.\n+     * The response is always returned with fixed length.\n+     *\/\n+    public static class HttpHeadOrGetHandler implements HttpTestHandler {\n+        final String responseBody;\n+        public HttpHeadOrGetHandler() {\n+            this(\"pâté de tête persillé\");\n+        }\n+        public HttpHeadOrGetHandler(String responseBody) {\n+            this.responseBody = Objects.requireNonNull(responseBody);\n+        }\n+\n+        @Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            try (var exchg = t) {\n+                exchg.getRequestBody().readAllBytes();\n+                String method = exchg.getRequestMethod();\n+                switch (method) {\n+                    case \"HEAD\" -> {\n+                        byte[] resp = responseBody.getBytes(StandardCharsets.UTF_8);\n+                        if (exchg.getExchangeVersion() != HTTP_1_1) {\n+                            \/\/ with HTTP\/2 or HTTP\/3 the server will not send content-length\n+                            exchg.getResponseHeaders()\n+                                    .addHeader(\"Content-Length\", String.valueOf(resp.length));\n+                        }\n+                        exchg.sendResponseHeaders(200, resp.length);\n+                        exchg.getResponseBody().close();\n+                    }\n+                    case \"GET\" -> {\n+                        byte[] resp = responseBody.getBytes(StandardCharsets.UTF_8);\n+                        exchg.sendResponseHeaders(200, resp.length);\n+                        try (var os = exchg.getResponseBody()) {\n+                            os.write(resp);\n+                        }\n+                    }\n+                    default -> {\n+                        exchg.sendResponseHeaders(405, 0);\n+                        exchg.getResponseBody().close();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n@@ -880,1 +931,1 @@\n-            public Version getVersion() { return Version.HTTP_1_1; }\n+            public Version getVersion() { return HTTP_1_1; }\n@@ -905,1 +956,1 @@\n-            @Override public Version getVersion() { return Version.HTTP_1_1; }\n+            @Override public Version getVersion() { return HTTP_1_1; }\n@@ -936,1 +987,1 @@\n-            public Version getVersion() { return Version.HTTP_2; }\n+            public Version getVersion() { return HTTP_2; }\n@@ -974,1 +1025,1 @@\n-            @Override public Version getVersion() { return Version.HTTP_2; }\n+            @Override public Version getVersion() { return HTTP_2; }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/common\/HttpServerAdapters.java","additions":59,"deletions":8,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -1387,1 +1387,1 @@\n-    void updateConnectionWindow(int amount) {\n+    public void updateConnectionWindow(int amount) {\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}