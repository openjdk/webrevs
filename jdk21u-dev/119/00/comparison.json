{"files":[{"patch":"@@ -4666,1 +4666,1 @@\n-    return this_one->_klass->is_subtype_of(other->_klass);\n+    return this_one->klass()->is_subtype_of(other->klass());\n@@ -5995,1 +5995,1 @@\n-  return this_one->_klass->is_subtype_of(other->_klass) && this_one->_interfaces->contains(other->_interfaces);\n+  return this_one->klass()->is_subtype_of(other->klass()) && this_one->_interfaces->contains(other->_interfaces);\n@@ -6010,1 +6010,1 @@\n-  return this_one->_klass->equals(other->_klass) && this_one->_interfaces->eq(other->_interfaces);\n+  return this_one->klass()->equals(other->klass()) && this_one->_interfaces->eq(other->_interfaces);\n@@ -6024,1 +6024,1 @@\n-    return !this_exact && this_one->_klass->equals(ciEnv::current()->Object_klass())  && other->_interfaces->contains(this_one->_interfaces);\n+    return !this_exact && this_one->klass()->equals(ciEnv::current()->Object_klass())  && other->_interfaces->contains(this_one->_interfaces);\n@@ -6033,1 +6033,1 @@\n-  if (!this_one->_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(this_one->_klass)) {\n+  if (!this_one->klass()->is_subtype_of(other->klass()) && !other->klass()->is_subtype_of(this_one->klass())) {\n@@ -6038,1 +6038,1 @@\n-    return this_one->_klass->is_subtype_of(other->_klass) && this_one->_interfaces->contains(other->_interfaces);\n+    return this_one->klass()->is_subtype_of(other->klass()) && this_one->_interfaces->contains(other->_interfaces);\n@@ -6118,1 +6118,1 @@\n-ciKlass* TypeAryPtr::compute_klass(DEBUG_ONLY(bool verify)) const {\n+ciKlass* TypeAryPtr::compute_klass() const {\n@@ -6139,22 +6139,1 @@\n-    \/\/ Cannot compute array klass directly from basic type,\n-    \/\/ since subtypes of TypeInt all have basic type T_INT.\n-#ifdef ASSERT\n-    if (verify && el->isa_int()) {\n-      \/\/ Check simple cases when verifying klass.\n-      BasicType bt = T_ILLEGAL;\n-      if (el == TypeInt::BYTE) {\n-        bt = T_BYTE;\n-      } else if (el == TypeInt::SHORT) {\n-        bt = T_SHORT;\n-      } else if (el == TypeInt::CHAR) {\n-        bt = T_CHAR;\n-      } else if (el == TypeInt::INT) {\n-        bt = T_INT;\n-      } else {\n-        return _klass; \/\/ just return specified klass\n-      }\n-      return ciTypeArrayKlass::make(bt);\n-    }\n-#endif\n-    assert(!el->isa_int(),\n-           \"integral arrays must be pre-equipped with a class\");\n+    assert(!el->isa_int(), \"integral arrays must be pre-equipped with a class\");\n@@ -6436,1 +6415,1 @@\n-    return this_one->_klass->is_subtype_of(other->_klass);\n+    return this_one->klass()->is_subtype_of(other->klass());\n@@ -6468,2 +6447,1 @@\n-    assert(this_one->_klass != nullptr && other->_klass != nullptr, \"\");\n-    return this_one->_klass->equals(other->_klass);\n+    return this_one->klass()->equals(other->klass());\n@@ -6489,1 +6467,1 @@\n-    return other->_klass->equals(ciEnv::current()->Object_klass()) && other->_interfaces->intersection_with(this_one->_interfaces)->eq(other->_interfaces);\n+    return other->klass()->equals(ciEnv::current()->Object_klass()) && other->_interfaces->intersection_with(this_one->_interfaces)->eq(other->_interfaces);\n@@ -6508,1 +6486,1 @@\n-    return this_one->_klass->is_subtype_of(other->_klass);\n+    return this_one->klass()->is_subtype_of(other->klass());\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":12,"deletions":34,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1416,1 +1416,1 @@\n-  ciKlass* compute_klass(DEBUG_ONLY(bool verify = false)) const;\n+  ciKlass* compute_klass() const;\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8321974\n+ * @summary Test that the TypeAryPtr::_klass field is properly initialized on use.\n+ * @comment This test only reproduces the issue with release builds of the JVM because\n+ *          verification code in debug builds leads to eager initialization of the field.\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=compileonly,TestUninitializedKlassField::test*\n+ *                   -XX:-TieredCompilation TestUninitializedKlassField\n+ *\/\n+\n+public class TestUninitializedKlassField {\n+    static void test(long array2[]) {\n+        long array1[] = new long[1];\n+        \/\/ Loop is needed to create a backedge phi that is processed only during IGVN.\n+        for (int i = 0; i < 1; i++) {\n+            \/\/ CmpPNode::sub will check if classes of array1 and array2 are unrelated\n+            \/\/ and the subtype checks will crash if the _klass field is not initialized.\n+            if (array2 != array1) {\n+                array1 = new long[2];\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 50_000; ++i) {\n+            test(null);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUninitializedKlassField.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"}]}