{"files":[{"patch":"@@ -1962,1 +1962,1 @@\n-    if (cgr != nullptr && cgr->not_global_escape(obj_node())) {\n+    if (cgr != nullptr && cgr->can_eliminate_lock(this)) {\n@@ -2125,0 +2125,1 @@\n+        box->set_nested();\n@@ -2158,1 +2159,1 @@\n-    if (cgr != nullptr && cgr->not_global_escape(obj_node())) {\n+    if (cgr != nullptr && cgr->can_eliminate_lock(this)) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"opto\/locknode.hpp\"\n@@ -4810,0 +4811,2 @@\n+    AbstractLockNode* alock = locks.at(0);\n+    BoxLockNode* box = alock->box_node()->as_BoxLock();\n@@ -4814,0 +4817,13 @@\n+      BoxLockNode* this_box = lock->box_node()->as_BoxLock();\n+      if (this_box != box) {\n+        \/\/ Locking regions (BoxLock) could be Unbalanced here:\n+        \/\/  - its coarsened locks were eliminated in earlier\n+        \/\/    macro nodes elimination followed by loop unroll\n+        \/\/ Preserve Unbalanced status in such cases.\n+        if (!this_box->is_unbalanced()) {\n+          this_box->set_coarsened();\n+        }\n+        if (!box->is_unbalanced()) {\n+          box->set_coarsened();\n+        }\n+      }\n@@ -4891,0 +4907,32 @@\n+\/\/ Mark locking regions (identified by BoxLockNode) as unbalanced if\n+\/\/ locks coarsening optimization removed Lock\/Unlock nodes from them.\n+\/\/ Such regions become unbalanced because coarsening only removes part\n+\/\/ of Lock\/Unlock nodes in region. As result we can't execute other\n+\/\/ locks elimination optimizations which assume all code paths have\n+\/\/ corresponding pair of Lock\/Unlock nodes - they are balanced.\n+void Compile::mark_unbalanced_boxes() const {\n+  int count = coarsened_count();\n+  for (int i = 0; i < count; i++) {\n+    Node_List* locks_list = _coarsened_locks.at(i);\n+    uint size = locks_list->size();\n+    if (size > 0) {\n+      AbstractLockNode* alock = locks_list->at(0)->as_AbstractLock();\n+      BoxLockNode* box = alock->box_node()->as_BoxLock();\n+      if (alock->is_coarsened()) {\n+        \/\/ coarsened_locks_consistent(), which is called before this method, verifies\n+        \/\/ that the rest of Lock\/Unlock nodes on locks_list are also coarsened.\n+        assert(!box->is_eliminated(), \"regions with coarsened locks should not be marked as eliminated\");\n+        for (uint j = 1; j < size; j++) {\n+          assert(locks_list->at(j)->as_AbstractLock()->is_coarsened(), \"only coarsened locks are expected here\");\n+          BoxLockNode* this_box = locks_list->at(j)->as_AbstractLock()->box_node()->as_BoxLock();\n+          if (box != this_box) {\n+            assert(!this_box->is_eliminated(), \"regions with coarsened locks should not be marked as eliminated\");\n+            box->set_unbalanced();\n+            this_box->set_unbalanced();\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -745,0 +745,1 @@\n+  void mark_unbalanced_boxes() const;\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"opto\/locknode.hpp\"\n@@ -2098,1 +2099,1 @@\n-          if (not_global_escape(alock->obj_node())) {\n+          if (can_eliminate_lock(alock)) {\n@@ -2431,0 +2432,15 @@\n+\/\/ Return true if locked object does not escape globally\n+\/\/ and locked code region (identified by BoxLockNode) is balanced:\n+\/\/ all compiled code paths have corresponding Lock\/Unlock pairs.\n+bool ConnectionGraph::can_eliminate_lock(AbstractLockNode* alock) {\n+  BoxLockNode* box = alock->box_node()->as_BoxLock();\n+  if (!box->is_unbalanced() && not_global_escape(alock->obj_node())) {\n+    if (EliminateNestedLocks) {\n+      \/\/ We can mark whole locking region as Local only when only\n+      \/\/ one object is used for locking.\n+      box->set_local();\n+    }\n+    return true;\n+  }\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+class  AbstractLockNode;\n@@ -610,0 +611,2 @@\n+  bool can_eliminate_lock(AbstractLockNode* alock);\n+\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-                                       _slot(slot), _is_eliminated(false) {\n+                                       _slot(slot), _kind(BoxLockNode::Regular) {\n@@ -50,1 +50,0 @@\n-\/\/-----------------------------hash--------------------------------------------\n@@ -52,1 +51,1 @@\n-  if (EliminateNestedLocks)\n+  if (EliminateNestedLocks) {\n@@ -54,1 +53,2 @@\n-  return Node::hash() + _slot + (_is_eliminated ? Compile::current()->fixed_slots() : 0);\n+  }\n+  return Node::hash() + _slot + (is_eliminated() ? Compile::current()->fixed_slots() : 0);\n@@ -57,1 +57,0 @@\n-\/\/------------------------------cmp--------------------------------------------\n@@ -59,1 +58,1 @@\n-  if (EliminateNestedLocks)\n+  if (EliminateNestedLocks) {\n@@ -61,0 +60,1 @@\n+  }\n@@ -62,1 +62,30 @@\n-  return bn._slot == _slot && bn._is_eliminated == _is_eliminated;\n+  return (bn._slot == _slot) && (bn.is_eliminated() == is_eliminated());\n+}\n+\n+Node* BoxLockNode::Identity(PhaseGVN* phase) {\n+  if (!EliminateNestedLocks && !this->is_eliminated()) {\n+    Node* n = phase->hash_find(this);\n+    if (n == nullptr || n == this) {\n+      return this;\n+    }\n+    BoxLockNode* old_box = n->as_BoxLock();\n+    \/\/ Set corresponding status (_kind) when commoning BoxLock nodes.\n+    if (this->_kind != old_box->_kind) {\n+      if (this->is_unbalanced()) {\n+        old_box->set_unbalanced();\n+      }\n+      if (!old_box->is_unbalanced()) {\n+        \/\/ Only Regular or Coarsened status should be here:\n+        \/\/ Nested and Local are set only when EliminateNestedLocks is on.\n+        if (old_box->is_regular()) {\n+          assert(this->is_coarsened(),\"unexpected kind: %s\", _kind_name[(int)this->_kind]);\n+          old_box->set_coarsened();\n+        } else {\n+          assert(this->is_regular(),\"unexpected kind: %s\", _kind_name[(int)this->_kind]);\n+          assert(old_box->is_coarsened(),\"unexpected kind: %s\", _kind_name[(int)old_box->_kind]);\n+        }\n+      }\n+    }\n+    return old_box;\n+  }\n+  return this;\n@@ -89,0 +118,3 @@\n+  if (is_unbalanced()) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":39,"deletions":7,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+private:\n@@ -38,1 +39,28 @@\n-  bool _is_eliminated; \/\/ Associated locks were safely eliminated\n+  enum {\n+    Regular = 0,       \/\/ Normal locking region\n+    Local,             \/\/ EA found that local not escaping object is used for locking\n+    Nested,            \/\/ This region is inside other region which use the same object\n+    Coarsened,         \/\/ Some lock\/unlock in region were marked as coarsened\n+    Unbalanced,        \/\/ This region become unbalanced after coarsened lock\/unlock were eliminated\n+                       \/\/ or it is locking region from OSR when locking is done in Interpreter\n+    Eliminated         \/\/ All lock\/unlock in region were eliminated\n+  } _kind;\n+\n+#ifdef ASSERT\n+  const char* _kind_name[6] = {\n+   \"Regular\",\n+   \"Local\",\n+   \"Nested\",\n+   \"Coarsened\",\n+   \"Unbalanced\",\n+   \"Eliminated\"\n+  };\n+#endif\n+\n+  \/\/ Allowed transitions of _kind:\n+  \/\/   Regular -> Local, Nested, Coarsened\n+  \/\/   Local   -> Eliminated\n+  \/\/   Nested  -> Eliminated\n+  \/\/   Coarsened -> Local, Nested, Unbalanced\n+  \/\/ EA and nested lock elimination can overwrite Coarsened kind.\n+  \/\/ Also allow transition to the same kind.\n@@ -52,0 +80,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n@@ -60,3 +89,32 @@\n-  bool is_eliminated() const { return _is_eliminated; }\n-  \/\/ mark lock as eliminated.\n-  void set_eliminated()      { _is_eliminated = true; }\n+  bool is_regular()    const { return _kind == Regular; }\n+  bool is_local()      const { return _kind == Local; }\n+  bool is_nested()     const { return _kind == Nested; }\n+  bool is_coarsened()  const { return _kind == Coarsened; }\n+  bool is_eliminated() const { return _kind == Eliminated; }\n+  bool is_unbalanced() const { return _kind == Unbalanced; }\n+\n+  void set_local()      {\n+    assert((_kind == Regular || _kind == Local || _kind == Coarsened),\n+           \"incorrect kind for Local transitioni: %s\", _kind_name[(int)_kind]);\n+    _kind = Local;\n+  }\n+  void set_nested()     {\n+    assert((_kind == Regular || _kind == Nested || _kind == Coarsened),\n+           \"incorrect kind for Nested transition: %s\", _kind_name[(int)_kind]);\n+    _kind = Nested;\n+  }\n+  void set_coarsened()  {\n+    assert((_kind == Regular || _kind == Coarsened),\n+           \"incorrect kind for Coarsened transition: %s\", _kind_name[(int)_kind]);\n+    _kind = Coarsened;\n+  }\n+  void set_eliminated() {\n+    assert((_kind == Local || _kind == Nested),\n+           \"incorrect kind for Eliminated transition: %s\", _kind_name[(int)_kind]);\n+    _kind = Eliminated;\n+  }\n+  void set_unbalanced() {\n+    assert((_kind == Coarsened || _kind == Unbalanced),\n+           \"incorrect kind for Unbalanced transition: %s\", _kind_name[(int)_kind]);\n+    _kind = Unbalanced;\n+  }\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":63,"deletions":5,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -1905,2 +1905,3 @@\n-void PhaseMacroExpand::mark_eliminated_box(Node* oldbox, Node* obj) {\n-  if (oldbox->as_BoxLock()->is_eliminated()) {\n+void PhaseMacroExpand::mark_eliminated_box(Node* box, Node* obj) {\n+  BoxLockNode* oldbox = box->as_BoxLock();\n+  if (oldbox->is_eliminated()) {\n@@ -1909,0 +1910,1 @@\n+  assert(!oldbox->is_unbalanced(), \"this should not be called for unbalanced region\");\n@@ -1916,0 +1918,1 @@\n+    oldbox->set_local();      \/\/ This verifies correct state of BoxLock\n@@ -1917,1 +1920,1 @@\n-    oldbox->as_BoxLock()->set_eliminated(); \/\/ This changes box's hash value\n+    oldbox->set_eliminated(); \/\/ This changes box's hash value\n@@ -1944,0 +1947,1 @@\n+  newbox->set_local(); \/\/ This verifies correct state of BoxLock\n@@ -1999,0 +2003,3 @@\n+  if (alock->box_node()->as_BoxLock()->is_unbalanced()) {\n+    return; \/\/ Can't do any more elimination for this locking region\n+  }\n@@ -2315,0 +2322,5 @@\n+  } else {\n+    \/\/ After coarsened locks are eliminated locking regions\n+    \/\/ become unbalanced. We should not execute any more\n+    \/\/ locks elimination optimizations on them.\n+    C->mark_unbalanced_boxes();\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8324969\n+ * @summary C2 incorrectly marks unbalanced (after coarsened locks were eliminated)\n+ *          nested locks for elimination.\n+ * @requires vm.compMode != \"Xint\"\n+ * @run main\/othervm -XX:-BackgroundCompilation TestCoarsenedAndNestedLocksElimination\n+ *\/\n+\n+public class TestCoarsenedAndNestedLocksElimination {\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 12000; ++i) {\n+            test1(-1);\n+            test2(-1);\n+        }\n+    }\n+\n+    static synchronized int methodA(int var) {\n+        return var;\n+    }\n+\n+    static synchronized int methodB(int var) {\n+        return var;\n+    }\n+\n+    static int varA = 0;\n+    static int varB = 0;\n+\n+    static void test1(int var) {\n+        synchronized (TestNestedLocksElimination.class) {\n+            for (int i2 = 0; i2 < 3; i2++) { \/\/ Fully unrolled\n+                 varA = methodA(i2);         \/\/ Nested synchronized methods also use\n+                 varB = i2 + methodB(var);   \/\/ TestNestedLocksElimination.class for lock\n+            }\n+        }\n+        TestNestedLocksElimination t = new TestNestedLocksElimination(); \/\/ Triggers EA\n+    }\n+\n+    static boolean test2(int var) {\n+        synchronized (TestNestedLocksElimination.class) {\n+            for (int i1 = 0; i1 < 100; i1++) {\n+                switch (42) {\n+                case 42:\n+                    short[] sArr = new short[256]; \/\/ Big enough to avoid scalarization checks\n+                case 50:\n+                    for (int i2 = 2; i2 < 8; i2 += 2) { \/\/ Fully unrolled\n+                        for (int i3 = 1;;) {\n+                            int var1 = methodA(i2);\n+                            int var2 = i2 + methodB(i3);\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        return var > 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/locks\/TestCoarsenedAndNestedLocksElimination.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"}]}