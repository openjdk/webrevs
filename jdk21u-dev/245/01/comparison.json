{"files":[{"patch":"@@ -1989,2 +1989,2 @@\n-  switch (state) {\n-    case NEW :\n+  switch (state & ~SUSPENDED) {\n+    case NEW:\n@@ -1993,6 +1993,7 @@\n-    case STARTED :\n-    case RUNNABLE :\n-    case RUNNABLE_SUSPENDED :\n-    case RUNNING :\n-    case PARKING :\n-    case YIELDING :\n+    case STARTED:\n+    case RUNNING:\n+    case PARKING:\n+    case TIMED_PARKING:\n+    case UNPARKED:\n+    case YIELDING:\n+    case YIELDED:\n@@ -2001,3 +2002,2 @@\n-    case PARKED :\n-    case PARKED_SUSPENDED :\n-    case PINNED :\n+    case PARKED:\n+    case PINNED:\n@@ -2006,1 +2006,5 @@\n-    case TERMINATED :\n+    case TIMED_PARKED:\n+    case TIMED_PINNED:\n+      status = JavaThreadStatus::PARKED_TIMED;\n+      break;\n+    case TERMINATED:\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -522,14 +522,16 @@\n-    NEW          = 0,\n-    STARTED      = 1,\n-    RUNNABLE     = 2,\n-    RUNNING      = 3,\n-    PARKING      = 4,\n-    PARKED       = 5,\n-    PINNED       = 6,\n-    YIELDING     = 7,\n-    TERMINATED   = 99,\n-\n-    \/\/ can be suspended from scheduling when unmounted\n-    SUSPENDED    = 1 << 8,\n-    RUNNABLE_SUSPENDED = (RUNNABLE | SUSPENDED),\n-    PARKED_SUSPENDED   = (PARKED | SUSPENDED)\n+    NEW           = 0,\n+    STARTED       = 1,\n+    RUNNING       = 2,\n+    PARKING       = 3,\n+    PARKED        = 4,\n+    PINNED        = 5,\n+    TIMED_PARKING = 6,\n+    TIMED_PARKED  = 7,\n+    TIMED_PINNED  = 8,\n+    UNPARKED      = 9,\n+    YIELDING      = 10,\n+    YIELDED       = 11,\n+    TERMINATED    = 99,\n+\n+    \/\/ additional state bits\n+    SUSPENDED    = 1 << 8,   \/\/ suspended when unmounted\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -141,0 +141,1 @@\n+  bool _vthread;\n@@ -143,1 +144,0 @@\n-  bool _vthread;\n@@ -168,2 +168,3 @@\n-    _cont_entry(JfrThreadLocal::is_vthread(jt) ? jt->last_continuation() : nullptr),\n-    _async_mode(async_mode), _vthread(JfrThreadLocal::is_vthread(jt)) {\n+    _vthread(JfrThreadLocal::is_vthread(jt)),\n+    _cont_entry(_vthread ? jt->last_continuation() : nullptr),\n+    _async_mode(async_mode) {\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -398,1 +398,1 @@\n-  if (!t->is_Java_thread() || !Atomic::load_acquire(&tl->_vthread)) {\n+  if (!t->is_Java_thread()) {\n@@ -401,1 +401,0 @@\n-  \/\/ virtual thread\n@@ -403,0 +402,4 @@\n+  if (!is_vthread(jt)) {\n+    return jvm_thread_id(t, tl);\n+  }\n+  \/\/ virtual thread\n@@ -459,1 +462,1 @@\n-  return Atomic::load_acquire(&jt->jfr_thread_local()->_vthread);\n+  return Atomic::load_acquire(&jt->jfr_thread_local()->_vthread) && jt->last_continuation() != nullptr;\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-     * Virtual thread state and transitions:\n+     * Virtual thread state transitions:\n@@ -91,1 +91,1 @@\n-     *      NEW -> STARTED         \/\/ Thread.start\n+     *      NEW -> STARTED         \/\/ Thread.start, schedule to run\n@@ -94,0 +94,1 @@\n+     *  RUNNING -> TERMINATED      \/\/ done\n@@ -95,6 +96,6 @@\n-     *  RUNNING -> PARKING         \/\/ Thread attempts to park\n-     *  PARKING -> PARKED          \/\/ cont.yield successful, thread is parked\n-     *  PARKING -> PINNED          \/\/ cont.yield failed, thread is pinned\n-     *\n-     *   PARKED -> RUNNABLE        \/\/ unpark or interrupted\n-     *   PINNED -> RUNNABLE        \/\/ unpark or interrupted\n+     *  RUNNING -> PARKING         \/\/ Thread parking with LockSupport.park\n+     *  PARKING -> PARKED          \/\/ cont.yield successful, parked indefinitely\n+     *  PARKING -> PINNED          \/\/ cont.yield failed, parked indefinitely on carrier\n+     *   PARKED -> UNPARKED        \/\/ unparked, may be scheduled to continue\n+     *   PINNED -> RUNNING         \/\/ unparked, continue execution on same carrier\n+     * UNPARKED -> RUNNING         \/\/ continue execution after park\n@@ -102,1 +103,5 @@\n-     * RUNNABLE -> RUNNING         \/\/ continue execution\n+     *       RUNNING -> TIMED_PARKING   \/\/ Thread parking with LockSupport.parkNanos\n+     * TIMED_PARKING -> TIMED_PARKED    \/\/ cont.yield successful, timed-parked\n+     * TIMED_PARKING -> TIMED_PINNED    \/\/ cont.yield failed, timed-parked on carrier\n+     *  TIMED_PARKED -> UNPARKED        \/\/ unparked, may be scheduled to continue\n+     *  TIMED_PINNED -> RUNNING         \/\/ unparked, continue execution on same carrier\n@@ -105,4 +110,3 @@\n-     * YIELDING -> RUNNABLE        \/\/ yield successful\n-     * YIELDING -> RUNNING         \/\/ yield failed\n-     *\n-     *  RUNNING -> TERMINATED      \/\/ done\n+     * YIELDING -> YIELDED         \/\/ cont.yield successful, may be scheduled to continue\n+     * YIELDING -> RUNNING         \/\/ cont.yield failed\n+     *  YIELDED -> RUNNING         \/\/ continue execution after Thread.yield\n@@ -112,6 +116,15 @@\n-    private static final int RUNNABLE = 2;     \/\/ runnable-unmounted\n-    private static final int RUNNING  = 3;     \/\/ runnable-mounted\n-    private static final int PARKING  = 4;\n-    private static final int PARKED   = 5;     \/\/ unmounted\n-    private static final int PINNED   = 6;     \/\/ mounted\n-    private static final int YIELDING = 7;     \/\/ Thread.yield\n+    private static final int RUNNING  = 2;     \/\/ runnable-mounted\n+\n+    \/\/ untimed and timed parking\n+    private static final int PARKING       = 3;\n+    private static final int PARKED        = 4;     \/\/ unmounted\n+    private static final int PINNED        = 5;     \/\/ mounted\n+    private static final int TIMED_PARKING = 6;\n+    private static final int TIMED_PARKED  = 7;     \/\/ unmounted\n+    private static final int TIMED_PINNED  = 8;     \/\/ mounted\n+    private static final int UNPARKED      = 9;     \/\/ unmounted but runnable\n+\n+    \/\/ Thread.yield\n+    private static final int YIELDING = 10;\n+    private static final int YIELDED  = 11;         \/\/ unmounted but runnable\n+\n@@ -122,2 +135,0 @@\n-    private static final int RUNNABLE_SUSPENDED = (RUNNABLE | SUSPENDED);\n-    private static final int PARKED_SUSPENDED   = (PARKED | SUSPENDED);\n@@ -197,1 +208,3 @@\n-     * Runs or continues execution of the continuation on the current thread.\n+     * Runs or continues execution on the current thread. The virtual thread is mounted\n+     * on the current thread before the task runs or continues. It unmounts when the\n+     * task completes or yields.\n@@ -199,0 +212,1 @@\n+    @ChangesCurrentThread\n@@ -207,5 +221,9 @@\n-        if (initialState == STARTED && compareAndSetState(STARTED, RUNNING)) {\n-            \/\/ first run\n-        } else if (initialState == RUNNABLE && compareAndSetState(RUNNABLE, RUNNING)) {\n-            \/\/ consume parking permit\n-            setParkPermit(false);\n+        if (initialState == STARTED || initialState == UNPARKED || initialState == YIELDED) {\n+            \/\/ newly started or continue after parking\/blocking\/Thread.yield\n+            if (!compareAndSetState(initialState, RUNNING)) {\n+                return;\n+            }\n+            \/\/ consume parking permit when continuing after parking\n+            if (initialState == UNPARKED) {\n+                setParkPermit(false);\n+            }\n@@ -217,3 +235,1 @@\n-        \/\/ notify JVMTI before mount\n-        notifyJvmtiMount(\/*hide*\/true);\n-\n+        mount();\n@@ -223,0 +239,1 @@\n+            unmount();\n@@ -224,1 +241,1 @@\n-                afterTerminate();\n+                afterDone();\n@@ -234,2 +251,1 @@\n-     * otherwise it will be pushed to a submission queue.\n-     *\n+     * otherwise it will be pushed to an external submission queue.\n@@ -248,1 +264,1 @@\n-     * Submits the runContinuation task to the scheduler with a lazy submit.\n+     * Submits the runContinuation task to given scheduler with a lazy submit.\n@@ -262,1 +278,1 @@\n-     * Submits the runContinuation task to the scheduler as an external submit.\n+     * Submits the runContinuation task to the given scheduler as an external submit.\n@@ -288,3 +304,1 @@\n-     * Runs a task in the context of this virtual thread. The virtual thread is\n-     * mounted on the current (carrier) thread before the task runs. It unmounts\n-     * from its carrier thread when the task completes.\n+     * Runs a task in the context of this virtual thread.\n@@ -292,1 +306,0 @@\n-    @ChangesCurrentThread\n@@ -294,1 +307,1 @@\n-        assert state == RUNNING;\n+        assert Thread.currentThread() == this && state == RUNNING;\n@@ -296,2 +309,1 @@\n-        \/\/ first mount\n-        mount();\n+        \/\/ notify JVMTI, may post VirtualThreadStart event\n@@ -325,1 +337,1 @@\n-                \/\/ last unmount\n+                \/\/ notify JVMTI, may post VirtualThreadEnd event\n@@ -327,4 +339,0 @@\n-                unmount();\n-\n-                \/\/ final state\n-                setState(TERMINATED);\n@@ -342,0 +350,3 @@\n+        \/\/ notify JVMTI before mount\n+        notifyJvmtiMount(\/*hide*\/true);\n+\n@@ -378,0 +389,3 @@\n+\n+        \/\/ notify JVMTI after unmount\n+        notifyJvmtiUnmount(\/*hide*\/false);\n@@ -420,3 +434,2 @@\n-     * Unmounts this virtual thread, invokes Continuation.yield, and re-mounts the\n-     * thread when continued. When enabled, JVMTI must be notified from this method.\n-     * @return true if the yield was successful\n+     * Invokes Continuation.yield, notifying JVMTI (if enabled) to hide frames until\n+     * the continuation continues.\n@@ -425,1 +438,0 @@\n-    @ChangesCurrentThread\n@@ -427,1 +439,0 @@\n-        \/\/ unmount\n@@ -429,1 +440,0 @@\n-        unmount();\n@@ -433,2 +443,0 @@\n-            \/\/ re-mount\n-            mount();\n@@ -445,2 +453,1 @@\n-        int s = state();\n-        assert (s == PARKING || s == YIELDING) && (carrierThread == null);\n+        assert carrierThread == null;\n@@ -448,2 +455,1 @@\n-        if (s == PARKING) {\n-            setState(PARKED);\n+        int s = state();\n@@ -451,2 +457,4 @@\n-            \/\/ notify JVMTI that unmount has completed, thread is parked\n-            notifyJvmtiUnmount(\/*hide*\/false);\n+        \/\/ LockSupport.park\/parkNanos\n+        if (s == PARKING || s == TIMED_PARKING) {\n+            int newState = (s == PARKING) ? PARKED : TIMED_PARKED;\n+            setState(newState);\n@@ -455,1 +463,1 @@\n-            if (parkPermit && compareAndSetState(PARKED, RUNNABLE)) {\n+            if (parkPermit && compareAndSetState(newState, UNPARKED)) {\n@@ -464,2 +472,2 @@\n-        } else if (s == YIELDING) {   \/\/ Thread.yield\n-            setState(RUNNABLE);\n+            return;\n+        }\n@@ -467,2 +475,3 @@\n-            \/\/ notify JVMTI that unmount has completed, thread is runnable\n-            notifyJvmtiUnmount(\/*hide*\/false);\n+        \/\/ Thread.yield\n+        if (s == YIELDING) {\n+            setState(YIELDED);\n@@ -476,0 +485,1 @@\n+            return;\n@@ -477,0 +487,2 @@\n+\n+        assert false;\n@@ -480,2 +492,1 @@\n-     * Invoked after the thread terminates execution. It notifies anyone\n-     * waiting for the thread to terminate.\n+     * Invoked after the continuation completes.\n@@ -483,2 +494,2 @@\n-    private void afterTerminate() {\n-        afterTerminate(true, true);\n+    private void afterDone() {\n+        afterDone(true);\n@@ -488,2 +499,2 @@\n-     * Invoked after the thread terminates (or start failed). This method\n-     * notifies anyone waiting for the thread to terminate.\n+     * Invoked after the continuation completes (or start failed). Sets the thread\n+     * state to TERMINATED and notifies anyone waiting for the thread to terminate.\n@@ -492,1 +503,0 @@\n-     * @param executed true if the thread executed, false if it failed to start\n@@ -494,6 +504,3 @@\n-    private void afterTerminate(boolean notifyContainer, boolean executed) {\n-        assert (state() == TERMINATED) && (carrierThread == null);\n-\n-        if (executed) {\n-            notifyJvmtiUnmount(\/*hide*\/false);\n-        }\n+    private void afterDone(boolean notifyContainer) {\n+        assert carrierThread == null;\n+        setState(TERMINATED);\n@@ -549,2 +556,1 @@\n-                setState(TERMINATED);\n-                afterTerminate(addedToContainer, \/*executed*\/false);\n+                afterDone(addedToContainer);\n@@ -618,2 +624,2 @@\n-            Future<?> unparker = scheduleUnpark(this::unpark, nanos);\n-            setState(PARKING);\n+            Future<?> unparker = scheduleUnpark(nanos);  \/\/ may throw OOME\n+            setState(TIMED_PARKING);\n@@ -625,1 +631,1 @@\n-                    assert state() == PARKING;\n+                    assert state() == TIMED_PARKING;\n@@ -657,1 +663,1 @@\n-        setState(PINNED);\n+        setState(timed ? TIMED_PINNED : PINNED);\n@@ -683,1 +689,1 @@\n-     * Schedule an unpark task to run after a given delay.\n+     * Schedule this virtual thread to be unparked after a given delay.\n@@ -686,1 +692,2 @@\n-    private Future<?> scheduleUnpark(Runnable unparker, long nanos) {\n+    private Future<?> scheduleUnpark(long nanos) {\n+        assert Thread.currentThread() == this;\n@@ -690,1 +697,1 @@\n-            return UNPARKER.schedule(unparker, nanos, NANOSECONDS);\n+            return UNPARKER.schedule(this::unpark, nanos, NANOSECONDS);\n@@ -725,1 +732,2 @@\n-            if (s == PARKED && compareAndSetState(PARKED, RUNNABLE)) {\n+            boolean parked = (s == PARKED) || (s == TIMED_PARKED);\n+            if (parked && compareAndSetState(s, UNPARKED)) {\n@@ -736,2 +744,2 @@\n-            } else if (s == PINNED) {\n-                \/\/ unpark carrier thread when pinned.\n+            } else if ((s == PINNED) || (s == TIMED_PINNED)) {\n+                \/\/ unpark carrier thread when pinned\n@@ -740,1 +748,1 @@\n-                    if (carrier != null && state() == PINNED) {\n+                    if (carrier != null && ((s = state()) == PINNED || s == TIMED_PINNED)) {\n@@ -877,1 +885,2 @@\n-        switch (state()) {\n+        int s = state();\n+        switch (s & ~SUSPENDED) {\n@@ -887,2 +896,2 @@\n-            case RUNNABLE:\n-            case RUNNABLE_SUSPENDED:\n+            case UNPARKED:\n+            case YIELDED:\n@@ -902,0 +911,1 @@\n+            case TIMED_PARKING:\n@@ -903,1 +913,1 @@\n-                \/\/ runnable, mounted, not yet waiting\n+                \/\/ runnable, in transition\n@@ -906,1 +916,0 @@\n-            case PARKED_SUSPENDED:\n@@ -908,1 +917,4 @@\n-                return Thread.State.WAITING;\n+                return State.WAITING;\n+            case TIMED_PARKED:\n+            case TIMED_PINNED:\n+                return State.TIMED_WAITING;\n@@ -943,1 +955,1 @@\n-     * Returns null if the thread is in another state.\n+     * Returns null if the thread is mounted or in transition.\n@@ -946,22 +958,10 @@\n-        int initialState = state();\n-        return switch (initialState) {\n-            case RUNNABLE, PARKED -> {\n-                int suspendedState = initialState | SUSPENDED;\n-                if (compareAndSetState(initialState, suspendedState)) {\n-                    try {\n-                        yield cont.getStackTrace();\n-                    } finally {\n-                        assert state == suspendedState;\n-                        setState(initialState);\n-\n-                        \/\/ re-submit if runnable\n-                        \/\/ re-submit if unparked while suspended\n-                        if (initialState == RUNNABLE\n-                            || (parkPermit && compareAndSetState(PARKED, RUNNABLE))) {\n-                            try {\n-                                submitRunContinuation();\n-                            } catch (RejectedExecutionException ignore) { }\n-                        }\n-                    }\n-                }\n-                yield null;\n+        int initialState = state() & ~SUSPENDED;\n+        switch (initialState) {\n+            case NEW, STARTED, TERMINATED -> {\n+                return new StackTraceElement[0];  \/\/ unmounted, empty stack\n+            }\n+            case RUNNING, PINNED, TIMED_PINNED -> {\n+                return null;   \/\/ mounted\n+            }\n+            case PARKED, TIMED_PARKED -> {\n+                \/\/ unmounted, not runnable\n@@ -969,2 +969,33 @@\n-            case NEW, STARTED, TERMINATED ->  new StackTraceElement[0];  \/\/ empty stack\n-            default -> null;\n+            case UNPARKED, YIELDED -> {\n+                \/\/ unmounted, runnable\n+            }\n+            case PARKING, TIMED_PARKING, YIELDING -> {\n+                return null;  \/\/ in transition\n+            }\n+            default -> throw new InternalError(\"\" + initialState);\n+        }\n+\n+        \/\/ thread is unmounted, prevent it from continuing\n+        int suspendedState = initialState | SUSPENDED;\n+        if (!compareAndSetState(initialState, suspendedState)) {\n+            return null;\n+        }\n+\n+        \/\/ get stack trace and restore state\n+        StackTraceElement[] stack;\n+        try {\n+            stack = cont.getStackTrace();\n+        } finally {\n+            assert state == suspendedState;\n+            setState(initialState);\n+        }\n+        boolean resubmit = switch (initialState) {\n+            case UNPARKED, YIELDED -> {\n+                \/\/ resubmit as task may have run while suspended\n+                yield true;\n+            }\n+            case PARKED, TIMED_PARKED -> {\n+                \/\/ resubmit if unparked while suspended\n+                yield parkPermit && compareAndSetState(initialState, UNPARKED);\n+            }\n+            default -> throw new InternalError();\n@@ -972,0 +1003,4 @@\n+        if (resubmit) {\n+            submitRunContinuation();\n+        }\n+        return stack;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":158,"deletions":123,"binary":false,"changes":281,"status":"modified"},{"patch":"@@ -0,0 +1,416 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @bug 8312498\n+ * @summary Basic test for JVMTI GetThreadState with virtual threads\n+ * @run junit\/othervm\/native GetThreadStateTest\n+ *\/\n+\n+\/*\n+ * @test id=no-vmcontinuations\n+ * @requires vm.continuations\n+ * @run junit\/othervm\/native -XX:+UnlockExperimentalVMOptions -XX:-VMContinuations GetThreadStateTest\n+ *\/\n+\n+import java.util.StringJoiner;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.locks.LockSupport;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class GetThreadStateTest {\n+\n+    @BeforeAll\n+    static void setup() {\n+        System.loadLibrary(\"GetThreadStateTest\");\n+        init();\n+    }\n+\n+    \/**\n+     * Test state of new\/unstarted thread.\n+     *\/\n+    @Test\n+    void testUnstarted() {\n+        var thread = Thread.ofVirtual().unstarted(() -> { });\n+        check(thread, \/*new*\/ 0);\n+    }\n+\n+    \/**\n+     * Test state of terminated thread.\n+     *\/\n+    @Test\n+    void testTerminated() throws Exception {\n+        var thread = Thread.ofVirtual().start(() -> { });\n+        thread.join();\n+        check(thread, JVMTI_THREAD_STATE_TERMINATED);\n+    }\n+\n+    \/**\n+     * Test state of runnable thread.\n+     *\/\n+    @Test\n+    void testRunnable() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            latch.countDown();\n+\n+            \/\/ spin until done\n+            while (!done.get()) {\n+                Thread.onSpinWait();\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to start execution\n+            latch.await();\n+\n+            \/\/ thread should be runnable\n+            int expected = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_RUNNABLE;\n+            check(thread, expected);\n+\n+            \/\/ re-test with interrupt status set\n+            thread.interrupt();\n+            check(thread, expected | JVMTI_THREAD_STATE_INTERRUPTED);\n+        } finally {\n+            done.set(true);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread waiting to enter a monitor.\n+     *\/\n+    @Test\n+    void testMonitorEnter() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        Object lock = new Object();\n+        var thread = Thread.ofVirtual().unstarted(() -> {\n+            latch.countDown();\n+            synchronized (lock) { }\n+        });\n+        try {\n+            synchronized (lock) {\n+                \/\/ start thread and wait for it to start execution\n+                thread.start();\n+                latch.await();\n+\n+                \/\/ thread should block on monitor enter\n+                int expected = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER;\n+                await(thread, expected);\n+\n+                \/\/ re-test with interrupt status set\n+                thread.interrupt();\n+                check(thread, expected | JVMTI_THREAD_STATE_INTERRUPTED);\n+            }\n+        } finally {\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread waiting in Object.wait().\n+     *\/\n+    @Test\n+    void testObjectWait() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        Object lock = new Object();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                latch.countDown();\n+                try {\n+                    lock.wait();\n+                } catch (InterruptedException e) { }\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to own monitor\n+            latch.await();\n+\n+            \/\/ thread should wait\n+            int expected = JVMTI_THREAD_STATE_ALIVE |\n+                    JVMTI_THREAD_STATE_WAITING |\n+                    JVMTI_THREAD_STATE_WAITING_INDEFINITELY |\n+                    JVMTI_THREAD_STATE_IN_OBJECT_WAIT;\n+            await(thread, expected);\n+\n+            \/\/ notify so thread waits to re-enter monitor\n+            synchronized (lock) {\n+                lock.notifyAll();\n+                expected = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER;\n+                check(thread, expected);\n+\n+                \/\/ re-test with interrupt status set\n+                thread.interrupt();\n+                check(thread, expected | JVMTI_THREAD_STATE_INTERRUPTED);\n+            }\n+        } finally {\n+            thread.interrupt();\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread waiting in Object.wait(millis).\n+     *\/\n+    @Test\n+    void testObjectWaitMillis() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        Object lock = new Object();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                latch.countDown();\n+                try {\n+                    lock.wait(Long.MAX_VALUE);\n+                } catch (InterruptedException e) { }\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to own monitor\n+            latch.await();\n+\n+            \/\/ thread should wait\n+            int expected = JVMTI_THREAD_STATE_ALIVE |\n+                    JVMTI_THREAD_STATE_WAITING |\n+                    JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT |\n+                    JVMTI_THREAD_STATE_IN_OBJECT_WAIT;\n+            await(thread, expected);\n+\n+            \/\/ notify so thread waits to re-enter monitor\n+            synchronized (lock) {\n+                lock.notifyAll();\n+                expected = JVMTI_THREAD_STATE_ALIVE | JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER;\n+                check(thread, expected);\n+\n+                \/\/ re-test with interrupt status set\n+                thread.interrupt();\n+                check(thread, expected | JVMTI_THREAD_STATE_INTERRUPTED);\n+            }\n+        } finally {\n+            thread.interrupt();\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread parked with LockSupport.park.\n+     *\/\n+    @Test\n+    void testPark() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            latch.countDown();\n+            while (!done.get()) {\n+                LockSupport.park();\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to start execution\n+            latch.await();\n+\n+            \/\/ thread should park\n+            int expected = JVMTI_THREAD_STATE_ALIVE |\n+                    JVMTI_THREAD_STATE_WAITING |\n+                    JVMTI_THREAD_STATE_WAITING_INDEFINITELY |\n+                    JVMTI_THREAD_STATE_PARKED;\n+            await(thread, expected);\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread parked with LockSupport.parkNanos.\n+     *\/\n+    @Test\n+    void testParkNanos() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            latch.countDown();\n+            while (!done.get()) {\n+                LockSupport.parkNanos(Long.MAX_VALUE);\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to start execution\n+            latch.await();\n+\n+            \/\/ thread should park\n+            int expected = JVMTI_THREAD_STATE_ALIVE |\n+                    JVMTI_THREAD_STATE_WAITING |\n+                    JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT |\n+                    JVMTI_THREAD_STATE_PARKED;\n+            await(thread, expected);\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread parked with LockSupport.park while holding a monitor.\n+     *\/\n+    @Test\n+    void testParkWhenPinned() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        Object lock = new Object();\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                latch.countDown();\n+                while (!done.get()) {\n+                    LockSupport.park();\n+                }\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to own monitor\n+            latch.await();\n+\n+            \/\/ thread should park\n+            int expected = JVMTI_THREAD_STATE_ALIVE |\n+                    JVMTI_THREAD_STATE_WAITING |\n+                    JVMTI_THREAD_STATE_WAITING_INDEFINITELY |\n+                    JVMTI_THREAD_STATE_PARKED;\n+            await(thread, expected);\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test state of thread parked with LockSupport.parkNanos while holding a monitor.\n+     *\/\n+    @Test\n+    void testParkNanosWhenPinned() throws Exception {\n+        var latch = new CountDownLatch(1);\n+        Object lock = new Object();\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                latch.countDown();\n+                while (!done.get()) {\n+                    LockSupport.parkNanos(Long.MAX_VALUE);\n+                }\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to own monitor\n+            latch.await();\n+\n+            \/\/ thread should park\n+            int expected = JVMTI_THREAD_STATE_ALIVE |\n+                    JVMTI_THREAD_STATE_WAITING |\n+                    JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT |\n+                    JVMTI_THREAD_STATE_PARKED;\n+            await(thread, expected);\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Asserts that the given thread has the expected JVMTI state.\n+     *\/\n+    private static void check(Thread thread, int expected) {\n+        System.err.format(\"  expect state=0x%x (%s) ...%n\", expected, jvmtiStateToString(expected));\n+        int state = jvmtiState(thread);\n+        System.err.format(\"  thread state=0x%x (%s)%n\", state, jvmtiStateToString(state));\n+        assertEquals(expected, state);\n+    }\n+\n+    \/**\n+     * Waits indefinitely for the given thread to get to the target JVMTI state.\n+     *\/\n+    private static void await(Thread thread, int targetState) throws Exception {\n+        System.err.format(\"  await state=0x%x (%s) ...%n\", targetState, jvmtiStateToString(targetState));\n+        int state = jvmtiState(thread);\n+        System.err.format(\"  thread state=0x%x (%s)%n\", state, jvmtiStateToString(state));\n+        while (state != targetState) {\n+            assertTrue(thread.isAlive(), \"Thread has terminated\");\n+            Thread.sleep(20);\n+            state = jvmtiState(thread);\n+            System.err.format(\"  thread state=0x%x (%s)%n\", state, jvmtiStateToString(state));\n+        }\n+    }\n+\n+    private static final int JVMTI_THREAD_STATE_ALIVE = 0x0001;\n+    private static final int JVMTI_THREAD_STATE_TERMINATED = 0x0002;\n+    private static final int JVMTI_THREAD_STATE_RUNNABLE = 0x0004;\n+    private static final int JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER = 0x0400;\n+    private static final int JVMTI_THREAD_STATE_WAITING = 0x0080;\n+    private static final int JVMTI_THREAD_STATE_WAITING_INDEFINITELY = 0x0010;\n+    private static final int JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT = 0x0020;\n+    private static final int JVMTI_THREAD_STATE_SLEEPING = 0x0040;\n+    private static final int JVMTI_THREAD_STATE_IN_OBJECT_WAIT = 0x0100;\n+    private static final int JVMTI_THREAD_STATE_PARKED = 0x0200;\n+    private static final int JVMTI_THREAD_STATE_SUSPENDED = 0x100000;\n+    private static final int JVMTI_THREAD_STATE_INTERRUPTED = 0x200000;\n+    private static final int JVMTI_THREAD_STATE_IN_NATIVE = 0x400000;\n+\n+    private static native void init();\n+    private static native int jvmtiState(Thread thread);\n+\n+    private static String jvmtiStateToString(int state) {\n+        StringJoiner sj = new StringJoiner(\" | \");\n+        if ((state & JVMTI_THREAD_STATE_ALIVE) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_ALIVE\");\n+        if ((state & JVMTI_THREAD_STATE_TERMINATED) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_TERMINATED\");\n+        if ((state & JVMTI_THREAD_STATE_RUNNABLE) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_RUNNABLE\");\n+        if ((state & JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER\");\n+        if ((state & JVMTI_THREAD_STATE_WAITING) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_WAITING\");\n+        if ((state & JVMTI_THREAD_STATE_WAITING_INDEFINITELY) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_WAITING_INDEFINITELY\");\n+        if ((state & JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT\");\n+        if ((state & JVMTI_THREAD_STATE_IN_OBJECT_WAIT) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_IN_OBJECT_WAIT\");\n+        if ((state & JVMTI_THREAD_STATE_PARKED) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_PARKED\");\n+        if ((state & JVMTI_THREAD_STATE_SUSPENDED) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_SUSPENDED\");\n+        if ((state & JVMTI_THREAD_STATE_INTERRUPTED) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_INTERRUPTED\");\n+        if ((state & JVMTI_THREAD_STATE_IN_NATIVE) != 0)\n+            sj.add(\"JVMTI_THREAD_STATE_IN_NATIVE\");\n+        String s = sj.toString();\n+        return s.isEmpty() ? \"<empty>\" : s;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/GetThreadState\/GetThreadStateTest.java","additions":416,"deletions":0,"binary":false,"changes":416,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jvmti.h\"\n+\n+static jvmtiEnv *jvmti;\n+\n+JNIEXPORT void JNICALL Java_GetThreadStateTest_init(JNIEnv *env, jclass clazz) {\n+    JavaVM* vm;\n+    jint res;\n+    res = (*env)->GetJavaVM(env, &vm);\n+    if (res != 0) {\n+        (*env)->FatalError(env, \"GetJavaVM failed\");\n+    } else {\n+        res = (*vm)->GetEnv(vm, (void**)&jvmti, JVMTI_VERSION);\n+        if (res != JNI_OK) {\n+            (*env)->FatalError(env, \"GetEnv failed\");\n+        }\n+    }\n+}\n+\n+JNIEXPORT jint JNICALL Java_GetThreadStateTest_jvmtiState(JNIEnv *env, jclass clazz, jobject thread) {\n+    jvmtiError err;\n+    jint state = 0;\n+    err = (*jvmti)->GetThreadState(jvmti, thread, &state);\n+    if (err != JVMTI_ERROR_NONE) {\n+        (*env)->FatalError(env, \"GetThreadState failed\");\n+    }\n+    return state;\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/GetThreadState\/libGetThreadStateTest.c","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -152,2 +152,2 @@\n-            await(ready1); \/\/ to guaranty state is not State.WAITING after await(mready) in test1()\n-            \/\/ wait for test1 threads to reach WAITING state in sleep()\n+            await(ready1); \/\/ to guarantee state is not State.TIMED_WAITING after await(mready) in test1()\n+            \/\/ wait for test1 threads to reach TIMED_WAITING state in sleep()\n@@ -157,1 +157,1 @@\n-                while (state != Thread.State.WAITING) {\n+                while (state != Thread.State.TIMED_WAITING) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/VThreadEventTest\/VThreadEventTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-    private static final Executor DEFAULT_SCHEDULER = defaultScheduler();\n@@ -219,14 +218,0 @@\n-    \/**\n-     * Returns the default scheduler.\n-     *\/\n-    private static Executor defaultScheduler() {\n-        try {\n-            Field defaultScheduler = Class.forName(\"java.lang.VirtualThread\")\n-                    .getDeclaredField(\"DEFAULT_SCHEDULER\");\n-            defaultScheduler.setAccessible(true);\n-            return (Executor) defaultScheduler.get(null);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/CustomScheduler.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8284161 8286788\n+ * @bug 8284161 8286788 8321270\n@@ -109,1 +109,1 @@\n-        awaitParked(thread);\n+        await(thread, Thread.State.WAITING);\n@@ -133,1 +133,1 @@\n-            awaitBlocked(thread);\n+            await(thread, Thread.State.BLOCKED);\n@@ -163,1 +163,1 @@\n-            awaitParked(thread);\n+            await(thread, Thread.State.WAITING);\n@@ -768,0 +768,1 @@\n+            thread.join();\n@@ -900,1 +901,1 @@\n-        awaitParked(thread);\n+        await(thread, Thread.State.TIMED_WAITING);\n@@ -920,1 +921,1 @@\n-        awaitParked(thread);\n+        await(thread, Thread.State.WAITING);\n@@ -1035,1 +1036,1 @@\n-            assertTrue(me.getPriority() == Thread.NORM_PRIORITY);\n+            assertEquals(Thread.NORM_PRIORITY, me.getPriority());\n@@ -1038,1 +1039,1 @@\n-            assertTrue(me.getPriority() == Thread.NORM_PRIORITY);\n+            assertEquals(Thread.NORM_PRIORITY, me.getPriority());\n@@ -1041,1 +1042,1 @@\n-            assertTrue(me.getPriority() == Thread.NORM_PRIORITY);\n+            assertEquals(Thread.NORM_PRIORITY, me.getPriority());\n@@ -1044,1 +1045,1 @@\n-            assertTrue(me.getPriority() == Thread.NORM_PRIORITY);\n+            assertEquals(Thread.NORM_PRIORITY, me.getPriority());\n@@ -1058,1 +1059,1 @@\n-        assertTrue(thread.getPriority() == Thread.NORM_PRIORITY);\n+        assertEquals(Thread.NORM_PRIORITY, thread.getPriority());\n@@ -1061,1 +1062,1 @@\n-        assertTrue(thread.getPriority() == Thread.NORM_PRIORITY);\n+        assertEquals(Thread.NORM_PRIORITY, thread.getPriority());\n@@ -1064,1 +1065,1 @@\n-        assertTrue(thread.getPriority() == Thread.NORM_PRIORITY);\n+        assertEquals(Thread.NORM_PRIORITY, thread.getPriority());\n@@ -1067,1 +1068,1 @@\n-        assertTrue(thread.getPriority() == Thread.NORM_PRIORITY);\n+        assertEquals(Thread.NORM_PRIORITY, thread.getPriority());\n@@ -1074,1 +1075,1 @@\n-            assertTrue(thread.getPriority() == Thread.NORM_PRIORITY);\n+            assertEquals(Thread.NORM_PRIORITY, thread.getPriority());\n@@ -1078,1 +1079,1 @@\n-            assertTrue(thread.getPriority() == Thread.NORM_PRIORITY);\n+            assertEquals(Thread.NORM_PRIORITY, thread.getPriority());\n@@ -1081,1 +1082,1 @@\n-            assertTrue(thread.getPriority() == Thread.NORM_PRIORITY);\n+            assertEquals(Thread.NORM_PRIORITY, thread.getPriority());\n@@ -1084,1 +1085,1 @@\n-            assertTrue(thread.getPriority() == Thread.NORM_PRIORITY);\n+            assertEquals(Thread.NORM_PRIORITY, thread.getPriority());\n@@ -1094,1 +1095,1 @@\n-        assertTrue(thread.getPriority() == Thread.NORM_PRIORITY);\n+        assertEquals(Thread.NORM_PRIORITY, thread.getPriority());\n@@ -1193,0 +1194,30 @@\n+    \/**\n+     * Test that Thread.yield does not consume the thread's parking permit.\n+     *\/\n+    @Test\n+    void testYield3() throws Exception {\n+        var thread = Thread.ofVirtual().start(() -> {\n+            LockSupport.unpark(Thread.currentThread());\n+            Thread.yield();\n+            LockSupport.park();  \/\/ should not park\n+        });\n+        thread.join();\n+    }\n+\n+    \/**\n+     * Test that Thread.yield does not make available the thread's parking permit.\n+     *\/\n+    @Test\n+    void testYield4() throws Exception {\n+        var thread = Thread.ofVirtual().start(() -> {\n+            Thread.yield();\n+            LockSupport.park();  \/\/ should park\n+        });\n+        try {\n+            await(thread, Thread.State.WAITING);\n+        } finally {\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n@@ -1653,1 +1684,1 @@\n-     * Test Thread::getState when thread is not started.\n+     * Test Thread::getState when thread is new\/unstarted.\n@@ -1658,1 +1689,1 @@\n-        assertTrue(thread.getState() == Thread.State.NEW);\n+        assertEquals(Thread.State.NEW, thread.getState());\n@@ -1662,1 +1693,1 @@\n-     * Test Thread::getState when thread is runnable (mounted).\n+     * Test Thread::getState when thread is terminated.\n@@ -1666,3 +1697,19 @@\n-        VThreadRunner.run(() -> {\n-            Thread.State state = Thread.currentThread().getState();\n-            assertTrue(state == Thread.State.RUNNABLE);\n+        var thread = Thread.ofVirtual().start(() -> { });\n+        thread.join();\n+        assertEquals(Thread.State.TERMINATED, thread.getState());\n+    }\n+\n+    \/**\n+     * Test Thread::getState when thread is runnable (mounted).\n+     *\/\n+    @Test\n+    void testGetState3() throws Exception {\n+        var started = new CountDownLatch(1);\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            started.countDown();\n+\n+            \/\/ spin until done\n+            while (!done.get()) {\n+                Thread.onSpinWait();\n+            }\n@@ -1670,0 +1717,10 @@\n+        try {\n+            \/\/ wait for thread to start\n+            started.await();\n+\n+            \/\/ thread should be runnable\n+            assertEquals(Thread.State.RUNNABLE, thread.getState());\n+        } finally {\n+            done.set(true);\n+            thread.join();\n+        }\n@@ -1676,1 +1733,1 @@\n-    void testGetState3() throws Exception {\n+    void testGetState4() throws Exception {\n@@ -1683,1 +1740,1 @@\n-                assertTrue(t2.getState() == Thread.State.NEW);\n+                assertEquals(Thread.State.NEW, t2.getState());\n@@ -1688,1 +1745,1 @@\n-                    assertTrue(t2.getState() == Thread.State.RUNNABLE);\n+                    assertEquals(Thread.State.RUNNABLE, t2.getState());\n@@ -1692,1 +1749,1 @@\n-                    assertTrue(t2.getState() == Thread.State.WAITING);\n+                    assertEquals(Thread.State.WAITING, t2.getState());\n@@ -1699,1 +1756,1 @@\n-                assertTrue(t2.getState() == Thread.State.RUNNABLE);\n+                assertEquals(Thread.State.RUNNABLE, t2.getState());\n@@ -1709,1 +1766,1 @@\n-     * Test Thread::getState when thread is parked.\n+     * Test Thread::getState when thread is waiting to enter a monitor.\n@@ -1712,4 +1769,12 @@\n-    void testGetState4() throws Exception {\n-        var thread = Thread.ofVirtual().start(LockSupport::park);\n-        while (thread.getState() != Thread.State.WAITING) {\n-            Thread.sleep(20);\n+    void testGetState5() throws Exception {\n+        var started = new CountDownLatch(1);\n+        var thread = Thread.ofVirtual().unstarted(() -> {\n+            started.countDown();\n+            synchronized (lock) { }\n+        });\n+        synchronized (lock) {\n+            thread.start();\n+            started.await();\n+\n+            \/\/ wait for thread to block\n+            await(thread, Thread.State.BLOCKED);\n@@ -1717,1 +1782,0 @@\n-        LockSupport.unpark(thread);\n@@ -1722,1 +1786,1 @@\n-     * Test Thread::getState when thread is parked while holding a monitor.\n+     * Test Thread::getState when thread is waiting in Object.wait.\n@@ -1725,1 +1789,1 @@\n-    void testGetState5() throws Exception {\n+    void testGetState6() throws Exception {\n@@ -1728,1 +1792,1 @@\n-                LockSupport.park();\n+                try { lock.wait(); } catch (InterruptedException e) { }\n@@ -1731,2 +1795,6 @@\n-        while (thread.getState() != Thread.State.WAITING) {\n-            Thread.sleep(20);\n+        try {\n+            \/\/ wait for thread to wait\n+            await(thread, Thread.State.WAITING);\n+        } finally {\n+            thread.interrupt();\n+            thread.join();\n@@ -1734,2 +1802,0 @@\n-        LockSupport.unpark(thread);\n-        thread.join();\n@@ -1739,1 +1805,1 @@\n-     * Test Thread::getState when thread is waiting for a monitor.\n+     * Test Thread::getState when thread is waiting in Object.wait(millis).\n@@ -1742,8 +1808,6 @@\n-    void testGetState6() throws Exception {\n-        var thread = Thread.ofVirtual().unstarted(() -> {\n-            synchronized (lock) { }\n-        });\n-        synchronized (lock) {\n-            thread.start();\n-            while (thread.getState() != Thread.State.BLOCKED) {\n-                Thread.sleep(20);\n+    void testGetState7() throws Exception {\n+        var thread = Thread.ofVirtual().start(() -> {\n+            synchronized (lock) {\n+                try {\n+                    lock.wait(Long.MAX_VALUE);\n+                } catch (InterruptedException e) { }\n@@ -1751,0 +1815,7 @@\n+        });\n+        try {\n+            \/\/ wait for thread to wait\n+            await(thread, Thread.State.TIMED_WAITING);\n+        } finally {\n+            thread.interrupt();\n+            thread.join();\n@@ -1752,1 +1823,0 @@\n-        thread.join();\n@@ -1756,1 +1826,1 @@\n-     * Test Thread::getState when thread is waiting in Object.wait.\n+     * Test Thread::getState when thread is parked.\n@@ -1759,1 +1829,31 @@\n-    void testGetState7() throws Exception {\n+    void testGetState8() throws Exception {\n+        var thread = Thread.ofVirtual().start(LockSupport::park);\n+        try {\n+            await(thread, Thread.State.WAITING);\n+        } finally {\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test Thread::getState when thread is timed parked.\n+     *\/\n+    @Test\n+    void testGetState9() throws Exception {\n+        var thread = Thread.ofVirtual().start(() -> LockSupport.parkNanos(Long.MAX_VALUE));\n+        try {\n+            await(thread, Thread.State.TIMED_WAITING);\n+        } finally {\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test Thread::getState when thread is parked while holding a monitor.\n+     *\/\n+    @Test\n+    void testGetState10() throws Exception {\n+        var started = new CountDownLatch(1);\n+        var done = new AtomicBoolean();\n@@ -1761,0 +1861,1 @@\n+            started.countDown();\n@@ -1762,1 +1863,3 @@\n-                try { lock.wait(); } catch (InterruptedException e) { }\n+                while (!done.get()) {\n+                    LockSupport.park();\n+                }\n@@ -1765,2 +1868,10 @@\n-        while (thread.getState() != Thread.State.WAITING) {\n-            Thread.sleep(20);\n+        try {\n+            \/\/ wait for thread to start\n+            started.await();\n+\n+            \/\/ wait for thread to park\n+            await(thread, Thread.State.WAITING);\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n@@ -1768,2 +1879,0 @@\n-        thread.interrupt();\n-        thread.join();\n@@ -1773,1 +1882,1 @@\n-     * Test Thread::getState when thread is terminated.\n+     * Test Thread::getState when thread is timed parked while holding a monitor.\n@@ -1776,4 +1885,22 @@\n-    void testGetState8() throws Exception {\n-        var thread = Thread.ofVirtual().start(() -> { });\n-        thread.join();\n-        assertTrue(thread.getState() == Thread.State.TERMINATED);\n+    void testGetState11() throws Exception {\n+        var started = new CountDownLatch(1);\n+        var done = new AtomicBoolean();\n+        var thread = Thread.ofVirtual().start(() -> {\n+            started.countDown();\n+            synchronized (lock) {\n+                while (!done.get()) {\n+                    LockSupport.parkNanos(Long.MAX_VALUE);\n+                }\n+            }\n+        });\n+        try {\n+            \/\/ wait for thread to start\n+            started.await();\n+\n+            \/\/ wait for thread to park\n+            await(thread, Thread.State.TIMED_WAITING);\n+        } finally {\n+            done.set(true);\n+            LockSupport.unpark(thread);\n+            thread.join();\n+        }\n@@ -1902,3 +2029,1 @@\n-            while (vthread.getState() != Thread.State.WAITING) {\n-                Thread.sleep(20);\n-            }\n+            await(vthread, Thread.State.WAITING);\n@@ -1931,6 +2056,1 @@\n-\n-        \/\/ wait for thread to park\n-        while (thread.getState() != Thread.State.WAITING) {\n-            Thread.sleep(20);\n-        }\n-\n+        await(thread, Thread.State.WAITING);\n@@ -1999,3 +2119,1 @@\n-            while (vthread.getState() != Thread.State.WAITING) {\n-                Thread.sleep(20);\n-            }\n+            await(vthread, Thread.State.WAITING);\n@@ -2037,1 +2155,1 @@\n-            assertTrue(thread.getThreadGroup() == vgroup);\n+            assertEquals(vgroup, thread.getThreadGroup());\n@@ -2054,1 +2172,1 @@\n-            assertTrue(group == vgroup);\n+            assertEquals(vgroup, group);\n@@ -2071,1 +2189,1 @@\n-        assertTrue(vgroup.getMaxPriority() == Thread.MAX_PRIORITY);\n+        assertEquals(Thread.MAX_PRIORITY, vgroup.getMaxPriority());\n@@ -2075,1 +2193,1 @@\n-        assertTrue(group.getMaxPriority() == Thread.MAX_PRIORITY);\n+        assertEquals(Thread.MAX_PRIORITY, group.getMaxPriority());\n@@ -2078,2 +2196,2 @@\n-        assertTrue(vgroup.getMaxPriority() == Thread.MAX_PRIORITY);\n-        assertTrue(group.getMaxPriority() == Thread.MAX_PRIORITY - 1);\n+        assertEquals(Thread.MAX_PRIORITY, vgroup.getMaxPriority());\n+        assertEquals(Thread.MAX_PRIORITY - 1, group.getMaxPriority());\n@@ -2082,2 +2200,2 @@\n-        assertTrue(vgroup.getMaxPriority() == Thread.MAX_PRIORITY);\n-        assertTrue(group.getMaxPriority() == Thread.MIN_PRIORITY);\n+        assertEquals(Thread.MAX_PRIORITY, vgroup.getMaxPriority());\n+        assertEquals(Thread.MIN_PRIORITY, group.getMaxPriority());\n@@ -2094,2 +2212,1 @@\n-\n-            assertTrue(vgroup.getMaxPriority() == Thread.MAX_PRIORITY);\n+            assertEquals(Thread.MAX_PRIORITY, vgroup.getMaxPriority());\n@@ -2098,2 +2215,2 @@\n-            assertTrue(group.getParent() == vgroup);\n-            assertTrue(group.getMaxPriority() == Thread.MAX_PRIORITY);\n+            assertEquals(vgroup, group.getParent());\n+            assertEquals(Thread.MAX_PRIORITY, group.getMaxPriority());\n@@ -2102,2 +2219,2 @@\n-            assertTrue(vgroup.getMaxPriority() == Thread.MAX_PRIORITY);\n-            assertTrue(group.getMaxPriority() == Thread.MAX_PRIORITY - 1);\n+            assertEquals(Thread.MAX_PRIORITY, vgroup.getMaxPriority());\n+            assertEquals(Thread.MAX_PRIORITY - 1, group.getMaxPriority());\n@@ -2106,2 +2223,2 @@\n-            assertTrue(vgroup.getMaxPriority() == Thread.MAX_PRIORITY);\n-            assertTrue(group.getMaxPriority() == Thread.MIN_PRIORITY);\n+            assertEquals(Thread.MAX_PRIORITY, vgroup.getMaxPriority());\n+            assertEquals(Thread.MIN_PRIORITY, group.getMaxPriority());\n@@ -2211,3 +2328,1 @@\n-        while (thread.getState() != Thread.State.WAITING) {\n-            Thread.sleep(10);\n-        }\n+        await(thread, Thread.State.WAITING);\n@@ -2236,13 +2351,1 @@\n-     * Waits for the given thread to park.\n-     *\/\n-    static void awaitParked(Thread thread) throws InterruptedException {\n-        Thread.State state = thread.getState();\n-        while (state != Thread.State.WAITING && state != Thread.State.TIMED_WAITING) {\n-            assertTrue(state != Thread.State.TERMINATED, \"Thread has terminated\");\n-            Thread.sleep(10);\n-            state = thread.getState();\n-        }\n-    }\n-\n-    \/**\n-     * Waits for the given thread to block waiting on a monitor.\n+     * Waits for the given thread to reach a given state.\n@@ -2250,1 +2353,1 @@\n-    static void awaitBlocked(Thread thread) throws InterruptedException {\n+    private void await(Thread thread, Thread.State expectedState) throws InterruptedException {\n@@ -2252,1 +2355,1 @@\n-        while (state != Thread.State.BLOCKED) {\n+        while (state != expectedState) {\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadAPI.java","additions":214,"deletions":111,"binary":false,"changes":325,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-        Thread.Builder.OfVirtual builder = Thread.ofVirtual();\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadBuilders.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8322818\n+ * @summary Stress test Thread.getStackTrace on a virtual thread that is pinned\n+ * @requires vm.debug != true\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run main\/othervm GetStackTraceALotWhenPinned 500000\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true\n+ * @modules java.base\/java.lang:+open\n+ * @library \/test\/lib\n+ * @run main\/othervm\/timeout=300 GetStackTraceALotWhenPinned 200000\n+ *\/\n+\n+import java.time.Instant;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.LockSupport;\n+import jdk.test.lib.thread.VThreadRunner;\n+\n+public class GetStackTraceALotWhenPinned {\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ need at least two carrier threads when main thread is a virtual thread\n+        if (Thread.currentThread().isVirtual()) {\n+            VThreadRunner.ensureParallelism(2);\n+        }\n+\n+        int iterations = Integer.parseInt(args[0]);\n+        var barrier = new Barrier(2);\n+\n+        \/\/ Start a virtual thread that loops doing Thread.yield and parking while pinned.\n+        \/\/ This loop creates the conditions for the main thread to sample the stack trace\n+        \/\/ as it transitions from being unmounted to parking while pinned.\n+        var thread = Thread.startVirtualThread(() -> {\n+            boolean timed = false;\n+            for (int i = 0; i < iterations; i++) {\n+                \/\/ wait for main thread to arrive\n+                barrier.await();\n+\n+                Thread.yield();\n+                synchronized (GetStackTraceALotWhenPinned.class) {\n+                    if (timed) {\n+                        LockSupport.parkNanos(Long.MAX_VALUE);\n+                    } else {\n+                        LockSupport.park();\n+                    }\n+                }\n+                timed = !timed;\n+            }\n+        });\n+\n+        long lastTimestamp = System.currentTimeMillis();\n+        for (int i = 0; i < iterations; i++) {\n+            \/\/ wait for virtual thread to arrive\n+            barrier.await();\n+\n+            thread.getStackTrace();\n+            LockSupport.unpark(thread);\n+\n+            long currentTime = System.currentTimeMillis();\n+            if ((currentTime - lastTimestamp) > 500) {\n+                System.out.format(\"%s %d remaining ...%n\", Instant.now(), (iterations - i));\n+                lastTimestamp = currentTime;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Alow threads wait for each other to reach a common barrier point. This class does\n+     * not park threads that are waiting for the barrier to trip, instead it spins. This\n+     * makes it suitable for tests that use LockSupport.park or Thread.yield.\n+     *\/\n+    private static class Barrier {\n+        private final int parties;\n+        private final AtomicInteger count;\n+        private volatile int generation;\n+\n+        Barrier(int parties) {\n+            this.parties = parties;\n+            this.count = new AtomicInteger(parties);\n+        }\n+\n+        void await() {\n+            int g = generation;\n+            if (count.decrementAndGet() == 0) {\n+                count.set(parties);\n+                generation = g + 1;\n+            } else {\n+                while (generation == g) {\n+                    Thread.onSpinWait();\n+                }\n+            }\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/GetStackTraceALotWhenPinned.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Stress test parking and unparking\n+ * @requires vm.debug != true\n+ * @run main\/othervm ParkALot 500000\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true\n+ * @run main\/othervm ParkALot 100000\n+ *\/\n+\n+import java.time.Instant;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.locks.LockSupport;\n+\n+public class ParkALot {\n+    private static final int ITERATIONS = 1_000_000;\n+\n+    public static void main(String[] args) {\n+        int iterations;\n+        if (args.length > 0) {\n+            iterations = Integer.parseInt(args[0]);\n+        } else {\n+            iterations = ITERATIONS;\n+        }\n+\n+        int maxThreads = Math.clamp(Runtime.getRuntime().availableProcessors() \/ 2, 1, 4);\n+        for (int nthreads = 1; nthreads <= maxThreads; nthreads++) {\n+            System.out.format(\"%s %d thread(s) ...%n\", Instant.now(), nthreads);\n+            ThreadFactory factory = Thread.ofPlatform().factory();\n+            try (var executor = Executors.newThreadPerTaskExecutor(factory)) {\n+                for (int i = 0; i < nthreads; i++) {\n+                    executor.submit(() -> parkALot(iterations));\n+                }\n+            }\n+            System.out.format(\"%s %d thread(s) done%n\", Instant.now(), nthreads);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a virtual thread that alternates between untimed and timed parking.\n+     * A platform thread spins unparking the virtual thread.\n+     *\/\n+    private static void parkALot(int iterations) {\n+        Thread vthread = Thread.ofVirtual().start(() -> {\n+            int i = 0;\n+            boolean timed = false;\n+            while (i < iterations) {\n+                if (timed) {\n+                    LockSupport.parkNanos(Long.MAX_VALUE);\n+                    timed = false;\n+                } else {\n+                    LockSupport.park();\n+                    timed = true;\n+                }\n+                i++;\n+            }\n+        });\n+\n+        Thread.State state;\n+        while ((state = vthread.getState()) != Thread.State.TERMINATED) {\n+            if (state == Thread.State.WAITING || state == Thread.State.TIMED_WAITING) {\n+                LockSupport.unpark(vthread);\n+            } else {\n+                Thread.yield();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/stress\/ParkALot.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"}]}