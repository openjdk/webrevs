{"files":[{"patch":"@@ -1406,0 +1406,1 @@\n+  if (s1->is_Bool() && s1->as_Bool()->_test._test != s2->as_Bool()->_test._test) return false;\n@@ -2802,0 +2803,8 @@\n+#ifdef ASSERT\n+        for (uint j = 0; j < p_bol->size(); j++) {\n+          Node* m = p_bol->at(j);\n+          assert(m->as_Bool()->_test._test == bol_test,\n+                 \"all bool nodes must have same test\");\n+        }\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @bug 8289422 8306088\n+ * @bug 8289422 8306088 8313720\n@@ -401,0 +401,52 @@\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveFLTforFConstH2(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] < b[i+0]) ? 0.1f : -0.1f;\n+            c[i+1] = (a[i+1] < b[i+1]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \">0\",\n+                  IRNode.VECTOR_BLEND_F, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveFLEforFConstH2(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1f : -0.1f;\n+            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"=0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \"=0\",\n+                  IRNode.VECTOR_BLEND_F, \"=0\",\n+                  IRNode.STORE_VECTOR, \"=0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveFYYforFConstH2(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1f : -0.1f;\n+            c[i+1] = (a[i+1] <  b[i+1]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_F, \"=0\",\n+                  IRNode.VECTOR_MASK_CMP_F, \"=0\",\n+                  IRNode.VECTOR_BLEND_F, \"=0\",\n+                  IRNode.STORE_VECTOR, \"=0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveFXXforFConstH2(float[] a, float[] b, float[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] <  b[i+0]) ? 0.1f : -0.1f;\n+            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1f : -0.1f;\n+        }\n+    }\n+\n@@ -473,0 +525,52 @@\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveDLTforDConstH2(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] < b[i+0]) ? 0.1 : -0.1;\n+            c[i+1] = (a[i+1] < b[i+1]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \">0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \">0\",\n+                  IRNode.VECTOR_BLEND_D, \">0\",\n+                  IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveDLEforDConstH2(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1 : -0.1;\n+            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"=0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \"=0\",\n+                  IRNode.VECTOR_BLEND_D, \"=0\",\n+                  IRNode.STORE_VECTOR, \"=0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveDYYforDConstH2(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] <= b[i+0]) ? 0.1 : -0.1;\n+            c[i+1] = (a[i+1] <  b[i+1]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR_D, \"=0\",\n+                  IRNode.VECTOR_MASK_CMP_D, \"=0\",\n+                  IRNode.VECTOR_BLEND_D, \"=0\",\n+                  IRNode.STORE_VECTOR, \"=0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveDXXforDConstH2(double[] a, double[] b, double[] c) {\n+        for (int i = 0; i < a.length; i+=2) {\n+            c[i+0] = (a[i+0] <  b[i+0]) ? 0.1 : -0.1;\n+            c[i+1] = (a[i+1] <= b[i+1]) ? 0.1 : -0.1;\n+        }\n+    }\n+\n@@ -722,1 +826,5 @@\n-                 \"testCMoveDLEforDConst\", \"testCMoveDEQforDConst\", \"testCMoveDNEQforDConst\"})\n+                 \"testCMoveDLEforDConst\", \"testCMoveDEQforDConst\", \"testCMoveDNEQforDConst\",\n+                 \"testCMoveFLTforFConstH2\", \"testCMoveFLEforFConstH2\",\n+                 \"testCMoveFYYforFConstH2\", \"testCMoveFXXforFConstH2\",\n+                 \"testCMoveDLTforDConstH2\", \"testCMoveDLEforDConstH2\",\n+                 \"testCMoveDYYforDConstH2\", \"testCMoveDXXforDConstH2\"})\n@@ -821,0 +929,33 @@\n+\n+        \/\/ Hand-unrolled (H2) examples:\n+        testCMoveFLTforFConstH2(floata, floatb, floatc);\n+        testCMoveDLTforDConstH2(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFLTforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDLTforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFLEforFConstH2(floata, floatb, floatc);\n+        testCMoveDLEforDConstH2(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(floatc[i], cmoveFLEforFConst(floata[i], floatb[i]));\n+            Asserts.assertEquals(doublec[i], cmoveDLEforDConst(doublea[i], doubleb[i]));\n+        }\n+\n+        testCMoveFYYforFConstH2(floata, floatb, floatc);\n+        testCMoveDYYforDConstH2(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i+=2) {\n+            Asserts.assertEquals(floatc[i+0], cmoveFLEforFConst(floata[i+0], floatb[i+0]));\n+            Asserts.assertEquals(doublec[i+0], cmoveDLEforDConst(doublea[i+0], doubleb[i+0]));\n+            Asserts.assertEquals(floatc[i+1], cmoveFLTforFConst(floata[i+1], floatb[i+1]));\n+            Asserts.assertEquals(doublec[i+1], cmoveDLTforDConst(doublea[i+1], doubleb[i+1]));\n+        }\n+\n+        testCMoveFXXforFConstH2(floata, floatb, floatc);\n+        testCMoveDXXforDConstH2(doublea, doubleb, doublec);\n+        for (int i = 0; i < SIZE; i+=2) {\n+            Asserts.assertEquals(floatc[i+0], cmoveFLTforFConst(floata[i+0], floatb[i+0]));\n+            Asserts.assertEquals(doublec[i+0], cmoveDLTforDConst(doublea[i+0], doubleb[i+0]));\n+            Asserts.assertEquals(floatc[i+1], cmoveFLEforFConst(floata[i+1], floatb[i+1]));\n+            Asserts.assertEquals(doublec[i+1], cmoveDLEforDConst(doublea[i+1], doubleb[i+1]));\n+        }\n@@ -987,4 +1128,11 @@\n-            a[i] = RANDOM.nextFloat();\n-            if (RANDOM.nextInt() % 20 == 0) {\n-                a[i] = Float.NaN;\n-            }\n+            a[i] = switch(RANDOM.nextInt() % 20) {\n+                case 0  -> Float.NaN;\n+                case 1  -> 0;\n+                case 2  -> 1;\n+                case 3  -> Float.POSITIVE_INFINITY;\n+                case 4  -> Float.NEGATIVE_INFINITY;\n+                case 5  -> Float.MAX_VALUE;\n+                case 6  -> Float.MIN_VALUE;\n+                case 7, 8, 9 -> RANDOM.nextFloat();\n+                default -> Float.intBitsToFloat(RANDOM.nextInt());\n+            };\n@@ -996,4 +1144,11 @@\n-            a[i] = RANDOM.nextDouble();\n-            if (RANDOM.nextInt() % 20 == 0) {\n-                a[i] = Double.NaN;\n-            }\n+            a[i] = switch(RANDOM.nextInt() % 20) {\n+                case 0  -> Double.NaN;\n+                case 1  -> 0;\n+                case 2  -> 1;\n+                case 3  -> Double.POSITIVE_INFINITY;\n+                case 4  -> Double.NEGATIVE_INFINITY;\n+                case 5  -> Double.MAX_VALUE;\n+                case 6  -> Double.MIN_VALUE;\n+                case 7, 8, 9 -> RANDOM.nextDouble();\n+                default -> Double.longBitsToDouble(RANDOM.nextLong());\n+            };\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java","additions":165,"deletions":10,"binary":false,"changes":175,"status":"modified"}]}