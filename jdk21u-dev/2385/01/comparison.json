{"files":[{"patch":"@@ -2441,210 +2441,0 @@\n-\/\/ Look at the method's handlers.  If the bci is in the handler's try block\n-\/\/ then check if the handler_pc is already on the stack.  If not, push it\n-\/\/ unless the handler has already been scanned.\n-void ClassVerifier::push_handlers(ExceptionTable* exhandlers,\n-                                  GrowableArray<u4>* handler_list,\n-                                  GrowableArray<u4>* handler_stack,\n-                                  u4 bci) {\n-  int exlength = exhandlers->length();\n-  for(int x = 0; x < exlength; x++) {\n-    if (bci >= exhandlers->start_pc(x) && bci < exhandlers->end_pc(x)) {\n-      u4 exhandler_pc = exhandlers->handler_pc(x);\n-      if (!handler_list->contains(exhandler_pc)) {\n-        handler_stack->append_if_missing(exhandler_pc);\n-        handler_list->append(exhandler_pc);\n-      }\n-    }\n-  }\n-}\n-\n-\/\/ Return TRUE if all code paths starting with start_bc_offset end in\n-\/\/ bytecode athrow or loop.\n-bool ClassVerifier::ends_in_athrow(u4 start_bc_offset) {\n-  ResourceMark rm;\n-  \/\/ Create bytecode stream.\n-  RawBytecodeStream bcs(method());\n-  u4 code_length = method()->code_size();\n-  bcs.set_start(start_bc_offset);\n-  u4 target;\n-  \/\/ Create stack for storing bytecode start offsets for if* and *switch.\n-  GrowableArray<u4>* bci_stack = new GrowableArray<u4>(30);\n-  \/\/ Create stack for handlers for try blocks containing this handler.\n-  GrowableArray<u4>* handler_stack = new GrowableArray<u4>(30);\n-  \/\/ Create list of handlers that have been pushed onto the handler_stack\n-  \/\/ so that handlers embedded inside of their own TRY blocks only get\n-  \/\/ scanned once.\n-  GrowableArray<u4>* handler_list = new GrowableArray<u4>(30);\n-  \/\/ Create list of visited branch opcodes (goto* and if*).\n-  GrowableArray<u4>* visited_branches = new GrowableArray<u4>(30);\n-  ExceptionTable exhandlers(_method());\n-\n-  while (true) {\n-    if (bcs.is_last_bytecode()) {\n-      \/\/ if no more starting offsets to parse or if at the end of the\n-      \/\/ method then return false.\n-      if ((bci_stack->is_empty()) || ((u4)bcs.end_bci() == code_length))\n-        return false;\n-      \/\/ Pop a bytecode starting offset and scan from there.\n-      bcs.set_start(bci_stack->pop());\n-    }\n-    Bytecodes::Code opcode = bcs.raw_next();\n-    u4 bci = bcs.bci();\n-\n-    \/\/ If the bytecode is in a TRY block, push its handlers so they\n-    \/\/ will get parsed.\n-    push_handlers(&exhandlers, handler_list, handler_stack, bci);\n-\n-    switch (opcode) {\n-      case Bytecodes::_if_icmpeq:\n-      case Bytecodes::_if_icmpne:\n-      case Bytecodes::_if_icmplt:\n-      case Bytecodes::_if_icmpge:\n-      case Bytecodes::_if_icmpgt:\n-      case Bytecodes::_if_icmple:\n-      case Bytecodes::_ifeq:\n-      case Bytecodes::_ifne:\n-      case Bytecodes::_iflt:\n-      case Bytecodes::_ifge:\n-      case Bytecodes::_ifgt:\n-      case Bytecodes::_ifle:\n-      case Bytecodes::_if_acmpeq:\n-      case Bytecodes::_if_acmpne:\n-      case Bytecodes::_ifnull:\n-      case Bytecodes::_ifnonnull:\n-        target = bcs.dest();\n-        if (visited_branches->contains(bci)) {\n-          if (bci_stack->is_empty()) {\n-            if (handler_stack->is_empty()) {\n-              return true;\n-            } else {\n-              \/\/ Parse the catch handlers for try blocks containing athrow.\n-              bcs.set_start(handler_stack->pop());\n-            }\n-          } else {\n-            \/\/ Pop a bytecode starting offset and scan from there.\n-            bcs.set_start(bci_stack->pop());\n-          }\n-        } else {\n-          if (target > bci) { \/\/ forward branch\n-            if (target >= code_length) return false;\n-            \/\/ Push the branch target onto the stack.\n-            bci_stack->push(target);\n-            \/\/ then, scan bytecodes starting with next.\n-            bcs.set_start(bcs.next_bci());\n-          } else { \/\/ backward branch\n-            \/\/ Push bytecode offset following backward branch onto the stack.\n-            bci_stack->push(bcs.next_bci());\n-            \/\/ Check bytecodes starting with branch target.\n-            bcs.set_start(target);\n-          }\n-          \/\/ Record target so we don't branch here again.\n-          visited_branches->append(bci);\n-        }\n-        break;\n-\n-      case Bytecodes::_goto:\n-      case Bytecodes::_goto_w: {\n-        int offset = (opcode == Bytecodes::_goto ? bcs.get_offset_s2() : bcs.get_offset_s4());\n-        int min_offset = -1 * max_method_code_size;\n-        \/\/ Check offset for overflow\n-        if (offset < min_offset || offset > max_method_code_size) return false;\n-\n-        target = bci + offset;\n-        if (visited_branches->contains(bci)) {\n-          if (bci_stack->is_empty()) {\n-            if (handler_stack->is_empty()) {\n-              return true;\n-            } else {\n-              \/\/ Parse the catch handlers for try blocks containing athrow.\n-              bcs.set_start(handler_stack->pop());\n-            }\n-          } else {\n-            \/\/ Been here before, pop new starting offset from stack.\n-            bcs.set_start(bci_stack->pop());\n-          }\n-        } else {\n-          if (target >= code_length) return false;\n-          \/\/ Continue scanning from the target onward.\n-          bcs.set_start(target);\n-          \/\/ Record target so we don't branch here again.\n-          visited_branches->append(bci);\n-        }\n-        break;\n-        }\n-\n-      \/\/ Check that all switch alternatives end in 'athrow' bytecodes. Since it\n-      \/\/ is  difficult to determine where each switch alternative ends, parse\n-      \/\/ each switch alternative until either hit a 'return', 'athrow', or reach\n-      \/\/ the end of the method's bytecodes.  This is gross but should be okay\n-      \/\/ because:\n-      \/\/ 1. tableswitch and lookupswitch byte codes in handlers for ctor explicit\n-      \/\/    constructor invocations should be rare.\n-      \/\/ 2. if each switch alternative ends in an athrow then the parsing should be\n-      \/\/    short.  If there is no athrow then it is bogus code, anyway.\n-      case Bytecodes::_lookupswitch:\n-      case Bytecodes::_tableswitch:\n-        {\n-          address aligned_bcp = align_up(bcs.bcp() + 1, jintSize);\n-          u4 default_offset = Bytes::get_Java_u4(aligned_bcp) + bci;\n-          int keys, delta;\n-          if (opcode == Bytecodes::_tableswitch) {\n-            jint low = (jint)Bytes::get_Java_u4(aligned_bcp + jintSize);\n-            jint high = (jint)Bytes::get_Java_u4(aligned_bcp + 2*jintSize);\n-            \/\/ This is invalid, but let the regular bytecode verifier\n-            \/\/ report this because the user will get a better error message.\n-            if (low > high) return true;\n-            keys = high - low + 1;\n-            delta = 1;\n-          } else {\n-            keys = (int)Bytes::get_Java_u4(aligned_bcp + jintSize);\n-            delta = 2;\n-          }\n-          \/\/ Invalid, let the regular bytecode verifier deal with it.\n-          if (keys < 0) return true;\n-\n-          \/\/ Push the offset of the next bytecode onto the stack.\n-          bci_stack->push(bcs.next_bci());\n-\n-          \/\/ Push the switch alternatives onto the stack.\n-          for (int i = 0; i < keys; i++) {\n-            int min_offset = -1 * max_method_code_size;\n-            int offset = (jint)Bytes::get_Java_u4(aligned_bcp+(3+i*delta)*jintSize);\n-            if (offset < min_offset || offset > max_method_code_size) return false;\n-            u4 target = bci + offset;\n-            if (target > code_length) return false;\n-            bci_stack->push(target);\n-          }\n-\n-          \/\/ Start bytecode parsing for the switch at the default alternative.\n-          if (default_offset > code_length) return false;\n-          bcs.set_start(default_offset);\n-          break;\n-        }\n-\n-      case Bytecodes::_return:\n-        return false;\n-\n-      case Bytecodes::_athrow:\n-        {\n-          if (bci_stack->is_empty()) {\n-            if (handler_stack->is_empty()) {\n-              return true;\n-            } else {\n-              \/\/ Parse the catch handlers for try blocks containing athrow.\n-              bcs.set_start(handler_stack->pop());\n-            }\n-          } else {\n-            \/\/ Pop a bytecode offset and starting scanning from there.\n-            bcs.set_start(bci_stack->pop());\n-          }\n-        }\n-        break;\n-\n-      default:\n-        ;\n-    } \/\/ end switch\n-  } \/\/ end while loop\n-\n-  return false;\n-}\n-\n@@ -2675,19 +2465,0 @@\n-      ExceptionTable exhandlers(_method());\n-      int exlength = exhandlers.length();\n-      for(int i = 0; i < exlength; i++) {\n-        u2 start_pc = exhandlers.start_pc(i);\n-        u2 end_pc = exhandlers.end_pc(i);\n-\n-        if (bci >= start_pc && bci < end_pc) {\n-          if (!ends_in_athrow(exhandlers.handler_pc(i))) {\n-            verify_error(ErrorContext::bad_code(bci),\n-              \"Bad <init> method call from after the start of a try block\");\n-            return;\n-          } else if (log_is_enabled(Debug, verification)) {\n-            ResourceMark rm(THREAD);\n-            log_debug(verification)(\"Survived call to ends_in_athrow(): %s\",\n-                                          current_class()->name()->as_C_string());\n-          }\n-        }\n-      }\n-\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":0,"deletions":229,"binary":false,"changes":229,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -338,11 +338,0 @@\n-  \/\/ Used by ends_in_athrow() to push all handlers that contain bci onto the\n-  \/\/ handler_stack, if the handler has not already been pushed on the stack.\n-  void push_handlers(ExceptionTable* exhandlers,\n-                     GrowableArray<u4>* handler_list,\n-                     GrowableArray<u4>* handler_stack,\n-                     u4 bci);\n-\n-  \/\/ Returns true if all paths starting with start_bc_offset end in athrow\n-  \/\/ bytecode or loop.\n-  bool ends_in_athrow(u4 start_bc_offset);\n-\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1504,7 +1504,0 @@\n-    \/\/ Return TRUE if all code paths starting with start_bc_offset end in\n-    \/\/ bytecode athrow or loop.\n-    boolean ends_in_athrow(int start_bc_offset) {\n-        log_info(\"unimplemented VerifierImpl.ends_in_athrow\");\n-        return true;\n-    }\n-\n@@ -1523,10 +1516,0 @@\n-                for(var exhandler : _method.exceptionTable()) {\n-                    int start_pc = exhandler[0];\n-                    int end_pc = exhandler[1];\n-\n-                    if (bci >= start_pc && bci < end_pc) {\n-                        if (!ends_in_athrow(exhandler[2])) {\n-                            verifyError(\"Bad <init> method call from after the start of a try block\");\n-                        }\n-                    }\n-                }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/VerifierImpl.java","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"}]}