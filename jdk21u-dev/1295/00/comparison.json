{"files":[{"patch":"@@ -517,0 +517,3 @@\n+    LFIWAX_OPCODE  = (31u << OPCODE_SHIFT |  855u << 1),\n+    LFIWZX_OPCODE  = (31u << OPCODE_SHIFT |  887u << 1),\n+\n@@ -524,0 +527,2 @@\n+    STFIWX_OPCODE  = (31u << OPCODE_SHIFT |  983u << 1),\n+\n@@ -566,0 +571,4 @@\n+    XVCVHPSP_OPCODE= (60u << OPCODE_SHIFT |  475u << 2 | 24u << 16), \/\/ XX2-FORM\n+    XVCVSPHP_OPCODE= (60u << OPCODE_SHIFT |  475u << 2 | 25u << 16), \/\/ XX2-FORM\n+    XSCVHPDP_OPCODE= (60u << OPCODE_SHIFT |  347u << 2 | 16u << 16), \/\/ XX2-FORM\n+    XSCVDPHP_OPCODE= (60u << OPCODE_SHIFT |  347u << 2 | 17u << 16), \/\/ XX2-FORM\n@@ -2122,0 +2131,3 @@\n+  inline void lfiwax(FloatRegister d, Register a, Register b);\n+  inline void lfiwzx(FloatRegister d, Register a, Register b);\n+\n@@ -2130,0 +2142,2 @@\n+  inline void stfiwx(FloatRegister s, Register a, Register b);\n+\n@@ -2394,0 +2408,4 @@\n+  inline void xvcvhpsp( VectorSRegister d, VectorSRegister b);\n+  inline void xvcvsphp( VectorSRegister d, VectorSRegister b);\n+  inline void xscvhpdp( VectorSRegister d, VectorSRegister b);\n+  inline void xscvdphp( VectorSRegister d, VectorSRegister b);\n@@ -2539,0 +2557,2 @@\n+  inline void lfiwax(FloatRegister d, Register b);\n+  inline void lfiwzx(FloatRegister d, Register b);\n@@ -2543,0 +2563,1 @@\n+  inline void stfiwx(FloatRegister s, Register b);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -709,0 +709,3 @@\n+inline void Assembler::lfiwax(FloatRegister d, Register a, Register b) { emit_int32( LFIWAX_OPCODE | frt(d) | ra0mem(a) |rb(b)); }\n+inline void Assembler::lfiwzx(FloatRegister d, Register a, Register b) { emit_int32( LFIWZX_OPCODE | frt(d) | ra0mem(a) |rb(b)); }\n+\n@@ -718,0 +721,2 @@\n+inline void Assembler::stfiwx(FloatRegister s, Register a, Register b) { emit_int32( STFIWX_OPCODE | frs(s) | ra0mem(a) |rb(b)); }\n+\n@@ -839,0 +844,4 @@\n+inline void Assembler::xvcvhpsp(VectorSRegister d, VectorSRegister b)                    { emit_int32( XVCVHPSP_OPCODE | vsrt(d) | vsrb(b) ); }\n+inline void Assembler::xvcvsphp(VectorSRegister d, VectorSRegister b)                    { emit_int32( XVCVSPHP_OPCODE | vsrt(d) | vsrb(b) ); }\n+inline void Assembler::xscvhpdp(VectorSRegister d, VectorSRegister b)                    { emit_int32( XSCVHPDP_OPCODE | vsrt(d) | vsrb(b) ); }\n+inline void Assembler::xscvdphp(VectorSRegister d, VectorSRegister b)                    { emit_int32( XSCVDPHP_OPCODE | vsrt(d) | vsrb(b) ); }\n@@ -1133,0 +1142,3 @@\n+inline void Assembler::lfiwax(FloatRegister d, Register b) { emit_int32( LFIWAX_OPCODE | frt(d) | rb(b)); }\n+inline void Assembler::lfiwzx(FloatRegister d, Register b) { emit_int32( LFIWZX_OPCODE | frt(d) | rb(b)); }\n+\n@@ -1139,0 +1151,2 @@\n+inline void Assembler::stfiwx(FloatRegister s, Register b) { emit_int32( STFIWX_OPCODE | frs(s) |rb(b)); }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1718,1 +1718,1 @@\n-void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr thread, LIR_Opr dest, LIR_Op* op) {\n+void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr tmp, LIR_Opr dest, LIR_Op* op) {\n@@ -1728,0 +1728,8 @@\n+    case lir_f2hf: {\n+      __ f2hf(dest.as_register(), value.as_float_reg(), tmp.as_float_reg());\n+      break;\n+    }\n+    case lir_hf2f: {\n+      __ hf2f(dest->as_float_reg(), value.as_register());\n+      break;\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -693,0 +693,19 @@\n+    case vmIntrinsics::_floatToFloat16: {\n+      assert(x->number_of_arguments() == 1, \"wrong type\");\n+      LIRItem value(x->argument_at(0), this);\n+      value.load_item();\n+      LIR_Opr dst = rlock_result(x);\n+      LIR_Opr tmp = new_register(T_FLOAT);\n+      \/\/ f2hf treats tmp as live_in. Workaround: initialize to some value.\n+      __ move(LIR_OprFact::floatConst(-0.0), tmp); \/\/ just to satisfy LinearScan\n+      __ f2hf(value.result(), dst, tmp);\n+      break;\n+    }\n+    case vmIntrinsics::_float16ToFloat: {\n+      assert(x->number_of_arguments() == 1, \"wrong type\");\n+      LIRItem value(x->argument_at(0), this);\n+      value.load_item();\n+      LIR_Opr dst = rlock_result(x);\n+      __ hf2f(value.result(), dst, LIR_OprFact::illegalOpr);\n+      break;\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -182,0 +182,3 @@\n+  \/\/ Convert between half precision float encoded into a short and a float in a FloatRegister.\n+  void inline f2hf(Register dst, FloatRegister src, FloatRegister tmp);\n+  void inline hf2f(FloatRegister dst, Register src);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -267,0 +267,14 @@\n+inline void MacroAssembler::f2hf(Register dst, FloatRegister src, FloatRegister tmp) {\n+  \/\/ Single precision values in FloatRegisters use double precision format on PPC64.\n+  xscvdphp(tmp->to_vsr(), src->to_vsr());\n+  mffprd(dst, tmp);\n+  \/\/ Make it a proper short (sign-extended).\n+  extsh(dst, dst);\n+}\n+\n+inline void MacroAssembler::hf2f(FloatRegister dst, Register src) {\n+  mtfprd(dst, src);\n+  \/\/ Single precision values in FloatRegisters use double precision format on PPC64.\n+  xscvhpdp(dst->to_vsr(), dst->to_vsr());\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.inline.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2128,0 +2128,3 @@\n+    case Op_ConvF2HF:\n+    case Op_ConvHF2F:\n+      return VM_Version::supports_float16();\n@@ -11348,0 +11351,28 @@\n+instruct convF2HF_reg_reg(iRegIdst dst, regF src, regF tmp) %{\n+  match(Set dst (ConvF2HF src));\n+  effect(TEMP tmp);\n+  ins_cost(3 * DEFAULT_COST);\n+  size(12);\n+  format %{ \"xscvdphp $tmp, $src\\t# convert to half precision\\n\\t\"\n+            \"mffprd $dst, $tmp\\t# move result from $tmp to $dst\\n\\t\"\n+            \"extsh $dst, $dst\\t# make it a proper short\"\n+  %}\n+  ins_encode %{\n+    __ f2hf($dst$$Register, $src$$FloatRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct convHF2F_reg_reg(regF dst, iRegIsrc src) %{\n+  match(Set dst (ConvHF2F src));\n+  ins_cost(2 * DEFAULT_COST);\n+  size(8);\n+  format %{ \"mtfprd $dst, $src\\t# move source from $src to $dst\\n\\t\"\n+            \"xscvhpdp $dst, $dst\\t# convert from half precision\"\n+  %}\n+  ins_encode %{\n+    __ hf2f($dst$$FloatRegister, $src$$Register);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -3560,0 +3560,18 @@\n+  address generate_floatToFloat16() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"floatToFloat16\");\n+    address start = __ function_entry();\n+    __ f2hf(R3_RET, F1_ARG1, F0);\n+    __ blr();\n+    return start;\n+  }\n+\n+  address generate_float16ToFloat() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"float16ToFloat\");\n+    address start = __ function_entry();\n+    __ hf2f(F1_RET, R3_ARG1);\n+    __ blr();\n+    return start;\n+  }\n+\n@@ -4758,0 +4776,6 @@\n+\n+    if (VM_Version::supports_float16()) {\n+      \/\/ For results consistency both intrinsics should be enabled.\n+      StubRoutines::_hf2f = generate_float16ToFloat();\n+      StubRoutines::_f2hf = generate_floatToFloat16();\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1159,0 +1159,38 @@\n+address TemplateInterpreterGenerator::generate_Float_floatToFloat16_entry() {\n+  if (!VM_Version::supports_float16()) return nullptr;\n+\n+  address entry = __ pc();\n+\n+  __ lfs(F1, Interpreter::stackElementSize, R15_esp);\n+  __ f2hf(R3_RET, F1, F0);\n+\n+  \/\/ Restore caller sp for c2i case (from compiled) and for resized sender frame (from interpreted).\n+  __ resize_frame_absolute(R21_sender_SP, R11_scratch1, R0);\n+  __ blr();\n+\n+  __ flush();\n+\n+  return entry;\n+}\n+\n+address TemplateInterpreterGenerator::generate_Float_float16ToFloat_entry() {\n+  if (!VM_Version::supports_float16()) return nullptr;\n+\n+  address entry = __ pc();\n+\n+  \/\/ Note: Could also use:\n+  \/\/__ li(R3, Interpreter::stackElementSize);\n+  \/\/__ lfiwax(F1_RET, R15_esp, R3); \/\/ short stored as 32 bit integer\n+  \/\/__ xscvhpdp(F1_RET->to_vsr(), F1_RET->to_vsr());\n+  __ lwa(R3, Interpreter::stackElementSize, R15_esp);\n+  __ hf2f(F1_RET, R3);\n+\n+  \/\/ Restore caller sp for c2i case (from compiled) and for resized sender frame (from interpreted).\n+  __ resize_frame_absolute(R21_sender_SP, R11_scratch1, R0);\n+  __ blr();\n+\n+  __ flush();\n+\n+  return entry;\n+}\n+\n@@ -1939,2 +1977,0 @@\n-address TemplateInterpreterGenerator::generate_Float_float16ToFloat_entry() { return nullptr; }\n-address TemplateInterpreterGenerator::generate_Float_floatToFloat16_entry() { return nullptr; }\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+  static bool supports_float16() { return PowerArchitecturePPC64 >= 9; }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *           | ((os.arch == \"ppc64\" | os.arch == \"ppc64le\") & vm.cpu.features ~= \".*darn.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/Binary16Conversion.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *           | ((os.arch == \"ppc64\" | os.arch == \"ppc64le\") & vm.cpu.features ~= \".*darn.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/Binary16ConversionNaN.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *           | ((os.arch == \"ppc64\" | os.arch == \"ppc64le\") & vm.cpu.features ~= \".*darn.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestAllFloat16ToFloat.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *           | ((os.arch == \"ppc64\" | os.arch == \"ppc64le\") & vm.cpu.features ~= \".*darn.*\")\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/float16\/TestConstFloat16ToFloat.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}