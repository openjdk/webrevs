{"files":[{"patch":"@@ -1912,0 +1912,16 @@\n+\/\/ Check that all locks\/unlocks associated with object come from balanced regions.\n+bool AbstractLockNode::is_balanced() {\n+  Node* obj = obj_node();\n+  for (uint j = 0; j < obj->outcnt(); j++) {\n+    Node* n = obj->raw_out(j);\n+    if (n->is_AbstractLock() &&\n+        n->as_AbstractLock()->obj_node()->eqv_uncast(obj)) {\n+      BoxLockNode* n_box = n->as_AbstractLock()->box_node()->as_BoxLock();\n+      if (n_box->is_unbalanced()) {\n+        return false;\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -2018,0 +2034,2 @@\n+            tty->print(\"Obj: \");\n+            obj_node()->dump();\n@@ -2026,0 +2044,2 @@\n+              tty->print(\"Box %d: \", i);\n+              box_node()->dump();\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1073,0 +1073,4 @@\n+  \/\/ Check that all locks\/unlocks associated with object come from balanced regions.\n+  \/\/ They can become unbalanced after coarsening optimization or on OSR entry.\n+  bool is_balanced();\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2436,2 +2436,1 @@\n-  BoxLockNode* box = alock->box_node()->as_BoxLock();\n-  if (!box->is_unbalanced() && not_global_escape(alock->obj_node())) {\n+  if (alock->is_balanced() && not_global_escape(alock->obj_node())) {\n@@ -2441,1 +2440,1 @@\n-      box->set_local();\n+      alock->box_node()->as_BoxLock()->set_local();\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-#ifdef ASSERT\n+#ifndef PRODUCT\n@@ -127,1 +127,3 @@\n-  virtual void dump_spec(outputStream *st) const { st->print(\"  Lock %d\",_slot); }\n+  virtual void dump_spec(outputStream *st) const {\n+    st->print(\"  Lock slot: %d, Kind: %s\", _slot, _kind_name[(int)_kind]);\n+  }\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2003,1 +2003,1 @@\n-  if (alock->box_node()->as_BoxLock()->is_unbalanced()) {\n+  if (!alock->is_balanced()) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8334421\n+ * @summary C2 incorrectly marks not-escaped locks for elimination after\n+ *          coarsened locks were eliminated and created unbalanced regions.\n+ * @requires vm.compMode != \"Xint\"\n+ * @run main\/othervm -XX:-TieredCompilation TestCoarsenedAndNotEscapedLocksElimination\n+ * @run main TestCoarsenedAndNotEscapedLocksElimination\n+ *\/\n+\n+import java.util.Vector;\n+\n+class TestVector extends Vector<Object> {\n+\n+    TestVector() {\n+        super();\n+    }\n+\n+    TestVector(int initialCapacity) {\n+        super(initialCapacity);\n+    }\n+\n+    TestVector(int initialCapacity, int capacityIncrement) {\n+        super(initialCapacity, capacityIncrement);\n+    }\n+\n+    Object[] getElementData () {\n+        return elementData; \/\/ access protected field\n+    }\n+}\n+\n+public class TestCoarsenedAndNotEscapedLocksElimination {\n+\n+    public static void main(String[] strArr) {\n+        TestCoarsenedAndNotEscapedLocksElimination tc = new TestCoarsenedAndNotEscapedLocksElimination();\n+        String result = null;\n+        for (int i = 0; i < 12000; ++i) {\n+            result = tc.test();\n+            if (result != null) break;\n+        }\n+        System.out.println(result == null? \"passed\" : result);\n+    }\n+\n+    int [][] vector_types = {\n+       {-1, -1},\n+       {0, -1},\n+       {1, -1},\n+       {2, -1},\n+       {1025, -1},\n+       {0, -2},\n+       {1, -2},\n+       {2, -2},\n+       {1025, -2},\n+       {0, 0},\n+       {1, 0},\n+       {2, 0},\n+       {1025, 0},\n+       {0, 1},\n+       {1, 1},\n+       {2, 1},\n+       {1025, 1},\n+       {0, 1025 },\n+       {1, 1025 },\n+       {2, 1025 },\n+       {1025, 1025 }\n+    };\n+\n+    Object [] elems = {\n+        null,\n+        new Object(),\n+        new Vector(),\n+        new Object[0]\n+    };\n+\n+    int cntr = 0, mode = 0;\n+\n+    void reset() {\n+        cntr = 0;\n+        mode = 0;\n+    }\n+\n+    TestVector nextVector() {\n+        if (cntr == vector_types.length) {\n+            return null;\n+        } else {\n+            TestVector vect;\n+            if (vector_types[cntr][0] < 0) {\n+                vect = new TestVector();\n+            } else if (vector_types[cntr][1] == -2) {\n+                vect = new TestVector(vector_types[cntr][0]);\n+            } else {\n+                vect = new TestVector(vector_types[cntr][0], vector_types[cntr][1]);\n+            }\n+            if (mode == 1) {\n+                vect.addElement(null);\n+                vect.addElement(new Object());\n+                vect.addElement(new Vector());\n+                vect.addElement(new Object[0]);\n+            } else if (mode == 2) {\n+                int cap = vect.capacity();\n+                vect.addElement(null);\n+                for (int i = 0; i < cap; i++) {\n+                    vect.addElement(new Object());\n+                }\n+            }\n+            if (++mode == 3) {\n+                mode = 0;\n+                cntr++;\n+            }\n+            return vect;\n+        }\n+    }\n+\n+    public String test() {\n+        reset();\n+        TestVector vect = (TestVector)nextVector();\n+        while (vect != null) {\n+            Object [] backup_array = new Object[vect.size()];\n+            System.arraycopy(vect.getElementData(),0,backup_array,0,vect.size());\n+\n+            int old_size = vect.size();\n+            vect.setSize(vect.size());\n+            if (vect.size() != old_size) {\n+                return \"Vector: \"+vect+\" size changed after setSize(size())\";\n+            }\n+            for (int i = 0; i < vect.size(); i++) {\n+                if (vect.elementAt(i) != backup_array[i]) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element changed after setSize(size())\";\n+                }\n+            }\n+\n+            old_size = vect.size();\n+            vect.setSize(vect.size()*2);\n+            if (vect.size() != old_size*2) {\n+                return \"Vector: \"+vect+\" size incorrectly changed after setSize(size()*2)\";\n+            }\n+            for (int i = 0; i < old_size; i++) {\n+                if (vect.elementAt(i) != backup_array[i]) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element changed after setSize(size()*2)\";\n+                }\n+            }\n+            for (int i = old_size; i < old_size*2; i++) {\n+                if (vect.elementAt(i) != null) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element not null after setSize(size()*2)\";\n+                }\n+            }\n+\n+            old_size = vect.size();\n+            int old_cap = vect.capacity();\n+            vect.setSize(vect.capacity()+1);\n+            if (vect.size() != old_cap+1) {\n+                return \"Vector: \"+vect+\" size incorrectly changed after setSize(capacity()+1)\";\n+            }\n+            for (int i = 0; i < old_size && i < backup_array.length; i++) {\n+                if (vect.elementAt(i) != backup_array[i]) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element changed after setSize(capacity()+1)\";\n+                }\n+            }\n+            for (int i = old_size; i < old_cap + 1; i++) {\n+                if (vect.elementAt(i) != null) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element not null after setSize(capacity()+1)\";\n+                }\n+            }\n+\n+            old_size = vect.size();\n+            vect.setSize(vect.size()\/2);\n+            if (vect.size() != old_size\/2) {\n+                return \"Vector: \"+vect+\" size incorrectly changed after setSize(size()\/2)\";\n+            }\n+            for (int i = 0; i < old_size\/2 && i < backup_array.length; i++) {\n+                if (vect.elementAt(i) != backup_array[i]) {\n+                    return \"Vector: \"+vect+\" : \"+i+\"th element changed after setSize(size()\/2)\";\n+                }\n+            }\n+\n+            vect = nextVector();\n+        }\n+        return null;\n+    }\n+\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/locks\/TestCoarsenedAndNotEscapedLocksElimination.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"}]}