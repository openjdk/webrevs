{"files":[{"patch":"@@ -0,0 +1,297 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8325506\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.util\n+ * @run main\/othervm Deterministic\n+ * @summary confirm the output of random calculations are determined\n+ *          by the SecureRandom parameters\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.SeededSecureRandom;\n+import sun.security.util.SignatureUtil;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.KEM;\n+import javax.crypto.KeyAgreement;\n+import javax.crypto.KeyGenerator;\n+import javax.crypto.spec.ChaCha20ParameterSpec;\n+import javax.crypto.spec.DHParameterSpec;\n+import javax.crypto.spec.GCMParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.nio.charset.StandardCharsets;\n+import java.security.*;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.spec.DSAParameterSpec;\n+import java.security.spec.PSSParameterSpec;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+public class Deterministic {\n+\n+    private static final long SEED = SeededSecureRandom.seed();\n+    private static int hash = 0;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        for (var p : Security.getProviders()) {\n+            var name = p.getName();\n+            if (name.equals(\"SunMSCAPI\") || name.startsWith(\"SunPKCS11\")) {\n+                System.out.println(\"Skipped native provider \" + name);\n+                continue;\n+            }\n+            for (var s : p.getServices()) {\n+                switch (s.getType()) {\n+                    case \"KeyPairGenerator\" -> testKeyPairGenerator(s);\n+                    case \"KeyGenerator\" -> testKeyGenerator(s);\n+                    case \"Signature\" -> testSignature(s);\n+                    case \"KEM\" -> testKEM(s);\n+                    case \"KeyAgreement\" -> testKeyAgreement(s);\n+                    case \"Cipher\" -> testCipher(s);\n+                    case \"AlgorithmParameterGenerator\" -> testAlgorithmParameterGenerator(s);\n+                }\n+            }\n+        }\n+        \/\/ Run twice and this value should be the same for the same SEED\n+        System.out.println(\"Final hash: \" + hash);\n+    }\n+\n+    static void testCipher(Provider.Service s) throws Exception {\n+        var alg = s.getAlgorithm();\n+        System.out.println(s.getProvider().getName()\n+                + \" \" + s.getType() + \".\" + alg);\n+        if (alg.contains(\"Wrap\") || alg.contains(\"KW\")) {\n+            System.out.println(\"    Ignored\");\n+            return;\n+        }\n+        Key key;\n+        AlgorithmParameterSpec spec;\n+        if (alg.startsWith(\"PBE\")) {\n+            key = new SecretKeySpec(\"isthisakey\".getBytes(StandardCharsets.UTF_8), \"PBE\");\n+            \/\/ Some cipher requires salt to be 8 byte long\n+            spec = new PBEParameterSpec(\"saltsalt\".getBytes(StandardCharsets.UTF_8), 100);\n+        } else {\n+            key = generateKey(alg.split(\"\/\")[0], s.getProvider());\n+            if (!alg.contains(\"\/\") || alg.contains(\"\/ECB\/\")) {\n+                spec = null;\n+            } else {\n+                if (alg.contains(\"\/GCM\/\")) {\n+                    spec = new GCMParameterSpec(128, new SeededSecureRandom(SEED + 1).generateSeed(16));\n+                } else if (alg.equals(\"ChaCha20\")) {\n+                    spec = new ChaCha20ParameterSpec(new SeededSecureRandom(SEED + 2).generateSeed(12), 128);\n+                } else if (alg.contains(\"ChaCha20\")) {\n+                    spec = new IvParameterSpec(new SeededSecureRandom(SEED + 3).generateSeed(12));\n+                } else {\n+                    spec = new IvParameterSpec(new SeededSecureRandom(SEED + 4).generateSeed(16));\n+                }\n+            }\n+        }\n+        var c = Cipher.getInstance(alg, s.getProvider());\n+        c.init(Cipher.ENCRYPT_MODE, key, spec, new SeededSecureRandom(SEED));\n+        \/\/ Some cipher requires plaintext to be 16 byte long\n+        var ct1 = c.doFinal(\"asimpleplaintext\".getBytes(StandardCharsets.UTF_8));\n+        \/\/ Some cipher requires IV to be different, so re-instantiate a cipher\n+        c = Cipher.getInstance(alg, s.getProvider());\n+        c.init(Cipher.ENCRYPT_MODE, key, spec, new SeededSecureRandom(SEED));\n+        var ct2 = c.doFinal(\"asimpleplaintext\".getBytes(StandardCharsets.UTF_8));\n+        Asserts.assertEqualsByteArray(ct1, ct2);\n+        hash = Objects.hash(hash, Arrays.hashCode(ct1));\n+        System.out.println(\"    Passed\");\n+    }\n+\n+    static void testAlgorithmParameterGenerator(Provider.Service s) throws Exception {\n+        System.out.println(s.getProvider().getName()\n+                + \" \" + s.getType() + \".\" + s.getAlgorithm());\n+        var apg = AlgorithmParameterGenerator.getInstance(s.getAlgorithm(), s.getProvider());\n+        apg.init(1024, new SeededSecureRandom(SEED));\n+        var p1 = apg.generateParameters().getParameterSpec(AlgorithmParameterSpec.class);\n+        apg.init(1024, new SeededSecureRandom(SEED));\n+        var p2 = apg.generateParameters().getParameterSpec(AlgorithmParameterSpec.class);\n+        if (p1 instanceof DSAParameterSpec d1 && p2 instanceof DSAParameterSpec d2) {\n+            Asserts.assertEQ(d1.getG(), d2.getG());\n+            Asserts.assertEQ(d1.getP(), d2.getP());\n+            Asserts.assertEQ(d1.getQ(), d2.getQ());\n+            hash = Objects.hash(hash, d1.getG(), d1.getP(), d1.getQ());\n+        } else if (p1 instanceof DHParameterSpec d1 && p2 instanceof DHParameterSpec d2){\n+            Asserts.assertEQ(d1.getG(), d2.getG());\n+            Asserts.assertEQ(d1.getP(), d2.getP());\n+            Asserts.assertEQ(d1.getL(), d2.getL());\n+            hash = Objects.hash(hash, d1.getG(), d1.getP(), d1.getL());\n+        } else {\n+            Asserts.assertEQ(p1, p2);\n+            hash = Objects.hash(hash, p1);\n+        }\n+        System.out.println(\"    Passed\");\n+    }\n+\n+    private static void testSignature(Provider.Service s) throws Exception {\n+        System.out.println(s.getProvider().getName()\n+                + \" \" + s.getType() + \".\" + s.getAlgorithm());\n+        String keyAlg = SignatureUtil.extractKeyAlgFromDwithE(s.getAlgorithm());\n+        \/\/ Later versions implement this in sun\/security\/util\/SignatureUtil.java\n+        if (keyAlg != null && keyAlg.endsWith(\"INP1363FORMAT\")) {\n+            keyAlg = keyAlg.substring(0, keyAlg.length() - 13);\n+            if (keyAlg.equalsIgnoreCase(\"ECDSA\")) {\n+                keyAlg = \"EC\";\n+            }\n+        }\n+        if (keyAlg == null) {\n+            if (s.getAlgorithm().equals(\"HSS\/LMS\")) {\n+                \/\/ We don't support HSS\/LMS key generation and signing\n+                System.out.println(\"    Ignored: HSS\/LMS\");\n+                return;\n+            } else {\n+                keyAlg = s.getAlgorithm(); \/\/ EdDSA etc\n+            }\n+        }\n+        var sk = generateKeyPair(keyAlg, 0).getPrivate();\n+        var sig = Signature.getInstance(s.getAlgorithm(), s.getProvider());\n+        try {\n+            if (keyAlg.equals(\"RSASSA-PSS\")) {\n+                sig.setParameter(PSSParameterSpec.DEFAULT);\n+            }\n+            sig.initSign(sk, new SeededSecureRandom(SEED));\n+            sig.update(new byte[20]);\n+            var s1 = sig.sign();\n+            sig.initSign(sk, new SeededSecureRandom(SEED));\n+            sig.update(new byte[20]);\n+            var s2 = sig.sign();\n+            Asserts.assertEqualsByteArray(s1, s2);\n+            hash = Objects.hash(hash, Arrays.hashCode(s1));\n+            System.out.println(\"    Passed\");\n+        } catch (InvalidKeyException ike) {\n+            System.out.println(\"    Ignored: \" + ike.getMessage());\n+        }\n+    }\n+\n+    static void testKeyPairGenerator(Provider.Service s) throws Exception {\n+        System.out.println(s.getProvider().getName()\n+                + \" \" + s.getType() + \".\" + s.getAlgorithm());\n+        var kp1 = generateKeyPair(s.getAlgorithm(), 0);\n+        var kp2 = generateKeyPair(s.getAlgorithm(), 0);\n+        Asserts.assertEqualsByteArray(\n+                kp1.getPrivate().getEncoded(), kp2.getPrivate().getEncoded());\n+        Asserts.assertEqualsByteArray(\n+                kp1.getPublic().getEncoded(), kp2.getPublic().getEncoded());\n+        hash = Objects.hash(hash,\n+                Arrays.hashCode(kp1.getPrivate().getEncoded()),\n+                Arrays.hashCode(kp1.getPublic().getEncoded()));\n+        System.out.println(\"    Passed\");\n+    }\n+\n+    static KeyPair generateKeyPair(String alg, int offset) throws Exception {\n+        var g = KeyPairGenerator.getInstance(alg);\n+        var size = switch (g.getAlgorithm()) {\n+            case \"RSA\", \"RSASSA-PSS\", \"DSA\", \"DiffieHellman\" -> 1024;\n+            case \"EC\" -> 256;\n+            case \"EdDSA\", \"Ed25519\", \"XDH\", \"X25519\" -> 255;\n+            case \"Ed448\", \"X448\" -> 448;\n+            default -> throw new UnsupportedOperationException(alg);\n+        };\n+        g.initialize(size, new SeededSecureRandom(SEED + offset));\n+        return g.generateKeyPair();\n+    }\n+\n+    static void testKeyGenerator(Provider.Service s) throws Exception {\n+        System.out.println(s.getProvider().getName()\n+                + \" \" + s.getType() + \".\" + s.getAlgorithm());\n+        if (s.getAlgorithm().startsWith(\"SunTls\")) {\n+            System.out.println(\"    Ignored\");\n+            return;\n+        }\n+        var k1 = generateKey(s.getAlgorithm(), s.getProvider());\n+        var k2 = generateKey(s.getAlgorithm(), s.getProvider());\n+        Asserts.assertEqualsByteArray(k1.getEncoded(), k2.getEncoded());\n+        hash = Objects.hash(hash,\n+                Arrays.hashCode(k1.getEncoded()));\n+        System.out.println(\"    Passed\");\n+    }\n+\n+    static Key generateKey(String s, Provider p) throws Exception {\n+        if (s.startsWith(\"AES_\")) {\n+            var g = KeyGenerator.getInstance(\"AES\", p);\n+            g.init(Integer.parseInt(s.substring(4)), new SeededSecureRandom(SEED + 1));\n+            return g.generateKey();\n+        } if (s.startsWith(\"ChaCha\")) {\n+            var g = KeyGenerator.getInstance(\"ChaCha20\", p);\n+            g.init(new SeededSecureRandom(SEED + 2));\n+            return g.generateKey();\n+        } if (s.equals(\"RSA\")) {\n+            return generateKeyPair(\"RSA\", 3).getPublic();\n+        } else {\n+            var g = KeyGenerator.getInstance(s, p);\n+            g.init(new SeededSecureRandom(SEED + 4));\n+            return g.generateKey();\n+        }\n+    }\n+\n+    static void testKEM(Provider.Service s) throws Exception {\n+        System.out.println(s.getProvider().getName()\n+                + \" \" + s.getType() + \".\" + s.getAlgorithm());\n+        String keyAlg = getKeyAlgFromKEM(s.getAlgorithm());\n+        var kp = generateKeyPair(keyAlg, 10);\n+        var kem = KEM.getInstance(s.getAlgorithm(), s.getProvider());\n+        var e1 = kem.newEncapsulator(kp.getPublic(), null, new SeededSecureRandom(SEED));\n+        var enc1 = e1.encapsulate();\n+        var e2 = kem.newEncapsulator(kp.getPublic(), null, new SeededSecureRandom(SEED));\n+        var enc2 = e2.encapsulate();\n+        Asserts.assertEqualsByteArray(enc1.encapsulation(), enc2.encapsulation());\n+        Asserts.assertEqualsByteArray(enc1.key().getEncoded(), enc2.key().getEncoded());\n+        hash = Objects.hash(hash, Arrays.hashCode(enc1.encapsulation()),\n+                Arrays.hashCode(enc1.key().getEncoded()));\n+        System.out.println(\"    Passed\");\n+    }\n+\n+    static void testKeyAgreement(Provider.Service s) throws Exception {\n+        System.out.println(s.getProvider().getName()\n+                + \" \" + s.getType() + \".\" + s.getAlgorithm());\n+        String keyAlg = getKeyAlgFromKEM(s.getAlgorithm());\n+        var kpS = generateKeyPair(keyAlg, 11);\n+        var kpR = generateKeyPair(keyAlg, 12);\n+        var ka = KeyAgreement.getInstance(s.getAlgorithm(), s.getProvider());\n+        ka.init(kpS.getPrivate(), new SeededSecureRandom(SEED));\n+        ka.doPhase(kpR.getPublic(), true);\n+        var sc1 = ka.generateSecret();\n+        ka.init(kpS.getPrivate(), new SeededSecureRandom(SEED));\n+        ka.doPhase(kpR.getPublic(), true);\n+        var sc2 = ka.generateSecret();\n+\n+        Asserts.assertEqualsByteArray(sc1, sc2);\n+        hash = Objects.hash(hash, Arrays.hashCode(sc1));\n+        System.out.println(\"    Passed\");\n+    }\n+\n+    static String getKeyAlgFromKEM(String algorithm) {\n+        return switch (algorithm) {\n+            case \"DHKEM\" -> \"X25519\";\n+            case \"ECDH\" -> \"EC\";\n+            default -> algorithm;\n+        };\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/provider\/all\/Deterministic.java","additions":297,"deletions":0,"binary":false,"changes":297,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,2 @@\n+import jdk.test.lib.Asserts;\n+\n@@ -25,0 +27,2 @@\n+import java.util.Arrays;\n+import java.util.HexFormat;\n@@ -52,0 +56,1 @@\n+        testEqualsByteArray();\n@@ -93,0 +98,20 @@\n+    private static void testEqualsByteArray() throws Exception {\n+        byte[] b1 = new byte[1];\n+        byte[] b11 = new byte[1];\n+        byte[] b2 = new byte[2];\n+\n+        expectPass(Assertion.EQBA, b1, b1);\n+        expectPass(Assertion.EQBA, b1, b11);\n+        expectPass(Assertion.EQBA, (byte[])null, (byte[])null);\n+        expectPass(Assertion.NEQBA, b1, b2);\n+        expectPass(Assertion.NEQBA, b1, (byte[])null);\n+        expectPass(Assertion.NEQBA, (byte[])null, b1);\n+\n+        expectFail(Assertion.EQBA, b1, b2);\n+        expectFail(Assertion.EQBA, (byte[])null, b1);\n+        expectFail(Assertion.EQBA, b1, (byte[])null);\n+        expectFail(Assertion.NEQBA, b1, b1);\n+        expectFail(Assertion.NEQBA, b1, b11);\n+        expectFail(Assertion.NEQBA, (byte[])null, (byte[])null);\n+    }\n+\n@@ -194,0 +219,37 @@\n+    private static void expectPass(Assertion assertion, byte[] b1, byte[] b2)\n+            throws Exception {\n+        if (assertion == Assertion.EQBA) {\n+            String msg = \"Expected \" + Assertion.asString(\"assertEqualsByteArray\",\n+                    Arrays.toString(b1), Arrays.toString(b2)) + \" to pass\";\n+            Asserts.assertEqualsByteArray(b1, b2, msg);\n+        } else {\n+            String msg = \"Expected \" + Assertion.asString(\"assertNotEqualsByteArray\",\n+                    Arrays.toString(b1), Arrays.toString(b2)) + \" to pass\";\n+            Asserts.assertNotEqualsByteArray(b1, b2, msg);\n+        }\n+    }\n+\n+    private static void expectFail(Assertion assertion, byte[] b1, byte[] b2)\n+            throws Exception {\n+        if (assertion == Assertion.EQBA) {\n+            try {\n+                Asserts.assertEqualsByteArray(b1, b2);\n+            } catch (RuntimeException e) {\n+                return;\n+            }\n+            throw new Exception(\"Expected \"\n+                    + Assertion.asString(\"assertEqualsByteArray\",\n+                    Arrays.toString(b1), Arrays.toString(b2))\n+                    + \" to throw a RuntimeException\");\n+        } else {\n+            try {\n+                Asserts.assertNotEqualsByteArray(b1, b2);\n+            } catch (RuntimeException e) {\n+                return;\n+            }\n+            throw new Exception(\"Expected \"\n+                    + Assertion.asString(\"assertNotEqualsByteArray\",\n+                    Arrays.toString(b1), Arrays.toString(b2))\n+                    + \" to throw a RuntimeException\");\n+        }\n+    }\n@@ -197,1 +259,1 @@\n-    LT, LTE, EQ, GTE, GT, NE, NULL, NOTNULL, FALSE, TRUE;\n+    LT, LTE, EQ, EQBA, NEQBA, GTE, GT, NE, NULL, NOTNULL, FALSE, TRUE;\n@@ -265,1 +327,1 @@\n-    private static String asString(String assertion, Object ... args) {\n+    public static String asString(String assertion, Object ... args) {\n","filename":"test\/lib-test\/jdk\/test\/lib\/AssertsTest.java","additions":65,"deletions":3,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.test.lib.security;\n+\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.test.lib.security.SeededSecureRandomTest\n+ *\/\n+public class SeededSecureRandomTest {\n+\n+    private static final String PROP = \"secure.random.seed\";\n+\n+    public static void main(String[] args) throws Exception {\n+        try {\n+            System.clearProperty(PROP);\n+            Asserts.assertNE(get(), get()); \/\/ random seed (different)\n+            Asserts.assertEQ(get(1L), get(1L)); \/\/ same seed\n+            Asserts.assertEQ(get(10L), get(10L)); \/\/ same seed\n+            Asserts.assertNE(get(1L), get(10L)); \/\/ different seed\n+\n+            System.setProperty(PROP, \"10\");\n+            Asserts.assertEQ(get(), get()); \/\/ seed set by system property\n+            Asserts.assertNE(get(), get(1L)); \/\/ seed set not system property\n+            Asserts.assertEQ(get(), get(10L)); \/\/ seed set same as system property\n+            Asserts.assertEQ(get(1L), get(1L)); \/\/ same seed\n+            Asserts.assertEQ(get(10L), get(10L)); \/\/ same seed\n+            Asserts.assertNE(get(1L), get(10L)); \/\/ different seed\n+        } finally {\n+            System.clearProperty(PROP);\n+        }\n+    }\n+\n+    static int get() {\n+        return new SeededSecureRandom(SeededSecureRandom.seed()).nextInt();\n+    }\n+\n+    static int get(long seed) {\n+        return new SeededSecureRandom(seed).nextInt();\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/security\/SeededSecureRandomTest.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import java.util.Arrays;\n+import java.util.HexFormat;\n@@ -237,0 +239,58 @@\n+    \/**\n+     * Asserts that {@code lhs} is the same byte array as {@code rhs}.\n+     *\n+     * @param lhs The left hand side of the comparison.\n+     * @param rhs The right hand side of the comparison.\n+     * @throws RuntimeException if the assertion is not true.\n+     * @see #assertEqualsByteArray(byte[], byte[], String)\n+     *\/\n+    public static void assertEqualsByteArray(byte[] lhs, byte[] rhs) {\n+        assertEqualsByteArray(lhs, rhs, null);\n+    }\n+\n+    \/**\n+     * Asserts that {@code lhs} is not the same byte array as {@code rhs}.\n+     *\n+     * @param lhs The left hand side of the comparison.\n+     * @param rhs The right hand side of the comparison.\n+     * @throws RuntimeException if the assertion is not true.\n+     * @see #assertNotEqualsByteArray(byte[], byte[], String)\n+     *\/\n+    public static void assertNotEqualsByteArray(byte[] lhs, byte[] rhs) {\n+        assertNotEqualsByteArray(lhs, rhs, null);\n+    }\n+\n+    \/**\n+     * Asserts that {@code lhs} is the same byte array as {@code rhs}.\n+     *\n+     * @param lhs The left hand side of the comparison.\n+     * @param rhs The right hand side of the comparison.\n+     * @param msg A description of the assumption; {@code null} for a default message.\n+     * @throws RuntimeException if the assertion is not true.\n+     *\/\n+    public static void assertEqualsByteArray(byte[] lhs, byte[] rhs, String msg) {\n+        if (!Arrays.equals(lhs, rhs)) {\n+            msg = Objects.toString(msg, \"assertEqualsByteArray\")\n+                    + \": expected \" + HexFormat.of().formatHex(lhs)\n+                    + \" to equal \" + HexFormat.of().formatHex(rhs);\n+            fail(msg);\n+        }\n+    }\n+\n+    \/**\n+     * Asserts that {@code lhs} is not the same byte array as {@code rhs}.\n+     *\n+     * @param lhs The left hand side of the comparison.\n+     * @param rhs The right hand side of the comparison.\n+     * @param msg A description of the assumption; {@code null} for a default message.\n+     * @throws RuntimeException if the assertion is not true.\n+     *\/\n+    public static void assertNotEqualsByteArray(byte[] lhs, byte[] rhs, String msg) {\n+        if (Arrays.equals(lhs, rhs)) {\n+            msg = Objects.toString(msg, \"assertNotEqualsByteArray\")\n+                    + \": expected \" + HexFormat.of().formatHex(lhs)\n+                    + \" to not equal \" + HexFormat.of().formatHex(rhs);\n+            fail(msg);\n+        }\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/Asserts.java","additions":61,"deletions":1,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.test.lib.security;\n+\n+import java.security.SecureRandom;\n+import java.util.Random;\n+\n+\/**\n+ * A deterministic SecureRandom with a seed.\n+ * <p>\n+ * Users can provide the seed with the system property \"secure.random.seed\".\n+ * Otherwise, it's a random value. Usually, a test runs without this system\n+ * property and the random seed is printed out. When it fails, set the\n+ * system property to this recorded seed to reproduce the failure.\n+ *\/\n+public class SeededSecureRandom extends SecureRandom {\n+\n+    private final Random rnd;\n+\n+    public static long seed() {\n+        String value = System.getProperty(\"secure.random.seed\");\n+        long seed = value != null\n+                ? Long.parseLong(value)\n+                : new Random().nextLong();\n+        System.out.println(\"SeededSecureRandom: seed = \" + seed);\n+        return seed;\n+    }\n+\n+    public SeededSecureRandom(long seed) {\n+        rnd = new Random(seed);\n+    }\n+\n+    public static SeededSecureRandom one() {\n+        return new SeededSecureRandom(seed());\n+    }\n+\n+    @Override\n+    public void nextBytes(byte[] bytes) {\n+        rnd.nextBytes(bytes);\n+    }\n+\n+    @Override\n+    public byte[] generateSeed(int numBytes) {\n+        var out = new byte[numBytes];\n+        rnd.nextBytes(out);\n+        return out;\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/security\/SeededSecureRandom.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"}]}