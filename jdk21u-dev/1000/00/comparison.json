{"files":[{"patch":"@@ -7431,1 +7431,1 @@\n-    state = get_state_from_digest_object(digestBase_obj, T_BYTE);\n+    state = get_state_from_digest_object(digestBase_obj, T_LONG);\n@@ -7531,1 +7531,1 @@\n-      elem_type = T_BYTE;\n+      elem_type = T_LONG;\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-    private final int blockSize;\n+    protected final int blockSize;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/DigestBase.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n@@ -33,2 +36,0 @@\n-import static sun.security.provider.ByteArrayAccess.b2lLittle;\n-import static sun.security.provider.ByteArrayAccess.l2bLittle;\n@@ -51,1 +52,1 @@\n-    private static final int DM = 5; \/\/ dimension of lanes\n+    private static final int DM = 5; \/\/ dimension of state matrix\n@@ -68,2 +69,5 @@\n-    private byte[] state = new byte[WIDTH];\n-    private long[] lanes = new long[DM*DM];\n+    private long[] state = new long[DM*DM];\n+\n+    static final VarHandle asLittleEndian\n+            = MethodHandles.byteArrayViewVarHandle(long[].class,\n+            ByteOrder.LITTLE_ENDIAN).withInvokeExactBehavior();\n@@ -94,4 +98,6 @@\n-       for (int i = 0; i < buffer.length; i++) {\n-           state[i] ^= b[ofs++];\n-       }\n-       keccak();\n+        for (int i = 0; i < blockSize \/ 8; i++) {\n+            state[i] ^= (long) asLittleEndian.get(b, ofs);\n+            ofs += 8;\n+        }\n+\n+        keccak();\n@@ -105,0 +111,1 @@\n+        byte[] byteState = new byte[8];\n@@ -106,1 +113,1 @@\n-            setPaddingBytes(suffix, buffer, (int)(bytesProcessed % buffer.length));\n+            setPaddingBytes(suffix, buffer, (int)(bytesProcessed % blockSize));\n@@ -111,1 +118,1 @@\n-        int availableBytes = buffer.length;\n+        int availableBytes = blockSize; \/\/ i.e. buffer.length\n@@ -114,1 +121,4 @@\n-            System.arraycopy(state, 0, out, ofs, availableBytes);\n+            for (int i = 0; i < availableBytes \/ 8 ; i++) {\n+                asLittleEndian.set(out, ofs, state[i]);\n+                ofs += 8;\n+            }\n@@ -116,1 +126,0 @@\n-            ofs += availableBytes;\n@@ -119,1 +128,13 @@\n-        System.arraycopy(state, 0, out, ofs, numBytes);\n+        int numLongs = (numBytes + 7) \/ 8;\n+\n+        for (int i = 0; i < numLongs - 1; i++) {\n+            asLittleEndian.set(out, ofs, state[i]);\n+            ofs += 8;\n+        }\n+        if (numBytes == numLongs * 8) {\n+            asLittleEndian.set(out, ofs, state[numLongs - 1]);\n+        } else {\n+            asLittleEndian.set(byteState, 0, state[numLongs - 1]);\n+            System.arraycopy(byteState, 0,\n+                    out, ofs, numBytes - (numLongs - 1) * 8);\n+        }\n@@ -126,2 +147,1 @@\n-        Arrays.fill(state, (byte)0);\n-        Arrays.fill(lanes, 0L);\n+        Arrays.fill(state, 0L);\n@@ -147,24 +167,0 @@\n-    \/**\n-     * Utility function for transforming the specified byte array 's'\n-     * into array of lanes 'm' as defined in section 3.1.2.\n-     *\/\n-    private static void bytes2Lanes(byte[] s, long[] m) {\n-        int sOfs = 0;\n-        \/\/ Conversion traverses along x-axis before y-axis\n-        for (int y = 0; y < DM; y++, sOfs += 40) {\n-            b2lLittle(s, sOfs, m, DM*y, 40);\n-        }\n-    }\n-\n-    \/**\n-     * Utility function for transforming the specified array of\n-     * lanes 'm' into a byte array 's' as defined in section 3.1.3.\n-     *\/\n-    private static void lanes2Bytes(long[] m, byte[] s) {\n-        int sOfs = 0;\n-        \/\/ Conversion traverses along x-axis before y-axis\n-        for (int y = 0; y < DM; y++, sOfs += 40) {\n-            l2bLittle(m, DM*y, s, sOfs, 40);\n-        }\n-    }\n-\n@@ -176,3 +172,0 @@\n-        \/\/ convert the 200-byte state into 25 lanes\n-        bytes2Lanes(state, lanes);\n-\n@@ -182,5 +175,5 @@\n-        a0 = lanes[0]; a1 = lanes[1]; a2 = lanes[2]; a3 = lanes[3]; a4 = lanes[4];\n-        a5 = lanes[5]; a6 = lanes[6]; a7 = lanes[7]; a8 = lanes[8]; a9 = lanes[9];\n-        a10 = lanes[10]; a11 = lanes[11]; a12 = lanes[12]; a13 = lanes[13]; a14 = lanes[14];\n-        a15 = lanes[15]; a16 = lanes[16]; a17 = lanes[17]; a18 = lanes[18]; a19 = lanes[19];\n-        a20 = lanes[20]; a21 = lanes[21]; a22 = lanes[22]; a23 = lanes[23]; a24 = lanes[24];\n+        a0 = state[0]; a1 = state[1]; a2 = state[2]; a3 = state[3]; a4 = state[4];\n+        a5 = state[5]; a6 = state[6]; a7 = state[7]; a8 = state[8]; a9 = state[9];\n+        a10 = state[10]; a11 = state[11]; a12 = state[12]; a13 = state[13]; a14 = state[14];\n+        a15 = state[15]; a16 = state[16]; a17 = state[17]; a18 = state[18]; a19 = state[19];\n+        a20 = state[20]; a21 = state[21]; a22 = state[22]; a23 = state[23]; a24 = state[24];\n@@ -290,8 +283,5 @@\n-        lanes[0] = a0; lanes[1] = a1; lanes[2] = a2; lanes[3] = a3; lanes[4] = a4;\n-        lanes[5] = a5; lanes[6] = a6; lanes[7] = a7; lanes[8] = a8; lanes[9] = a9;\n-        lanes[10] = a10; lanes[11] = a11; lanes[12] = a12; lanes[13] = a13; lanes[14] = a14;\n-        lanes[15] = a15; lanes[16] = a16; lanes[17] = a17; lanes[18] = a18; lanes[19] = a19;\n-        lanes[20] = a20; lanes[21] = a21; lanes[22] = a22; lanes[23] = a23; lanes[24] = a24;\n-\n-        \/\/ convert the resulting 25 lanes back into 200-byte state\n-        lanes2Bytes(lanes, state);\n+        state[0] = a0; state[1] = a1; state[2] = a2; state[3] = a3; state[4] = a4;\n+        state[5] = a5; state[6] = a6; state[7] = a7; state[8] = a8; state[9] = a9;\n+        state[10] = a10; state[11] = a11; state[12] = a12; state[13] = a13; state[14] = a14;\n+        state[15] = a15; state[16] = a16; state[17] = a17; state[18] = a18; state[19] = a19;\n+        state[20] = a20; state[21] = a21; state[22] = a22; state[23] = a23; state[24] = a24;\n@@ -303,1 +293,0 @@\n-        copy.lanes = new long[DM*DM];\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SHA3.java","additions":47,"deletions":58,"binary":false,"changes":105,"status":"modified"}]}