{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.ArrayList;\n@@ -29,1 +30,1 @@\n-import java.util.HashMap;\n+import java.util.List;\n@@ -35,0 +36,1 @@\n+import java.util.stream.Stream;\n@@ -38,3 +40,4 @@\n-    public String getValue(String section, String key) {\n-        Objects.requireNonNull(section);\n-        Objects.requireNonNull(key);\n+    public String getValue(String sectionName, String key) {\n+        var section = getSection(sectionName);\n+        TKit.assertTrue(section != null, String.format(\n+                \"Check section [%s] is found in [%s] cfg file\", sectionName, id));\n@@ -42,5 +45,1 @@\n-        Map<String, String> entries = data.get(section);\n-        TKit.assertTrue(entries != null, String.format(\n-                \"Check section [%s] is found in [%s] cfg file\", section, id));\n-\n-        String value = entries.get(key);\n+        String value = section.getValue(key);\n@@ -49,1 +48,1 @@\n-                section, id));\n+                sectionName, id));\n@@ -54,3 +53,21 @@\n-    public String getValueUnchecked(String section, String key) {\n-        Objects.requireNonNull(section);\n-        Objects.requireNonNull(key);\n+    public String getValueUnchecked(String sectionName, String key) {\n+        var section = getSection(sectionName);\n+        if (section != null) {\n+            return section.getValue(key);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public void addValue(String sectionName, String key, String value) {\n+        var section = getSection(sectionName);\n+        if (section == null) {\n+            section = new Section(sectionName, new ArrayList<>());\n+            data.add(section);\n+        }\n+        section.data.add(Map.entry(key, value));\n+    }\n+\n+    public CfgFile() {\n+        this(new ArrayList<>(), \"*\");\n+    }\n@@ -58,2 +75,10 @@\n-        return Optional.ofNullable(data.get(section)).map(v -> v.get(key)).orElse(\n-                null);\n+    public static CfgFile combine(CfgFile base, CfgFile mods) {\n+        var cfgFile = new CfgFile(new ArrayList<>(), \"*\");\n+        for (var src : List.of(base, mods)) {\n+            for (var section : src.data) {\n+                for (var kvp : section.data) {\n+                    cfgFile.addValue(section.name, kvp.getKey(), kvp.getValue());\n+                }\n+            }\n+        }\n+        return cfgFile;\n@@ -62,1 +87,1 @@\n-    private CfgFile(Map<String, Map<String, String>> data, String id) {\n+    private CfgFile(List<Section> data, String id) {\n@@ -67,1 +92,22 @@\n-    public static CfgFile readFromFile(Path path) throws IOException {\n+    public void save(Path path) {\n+        var lines = data.stream().flatMap(section -> {\n+            return Stream.concat(\n+                    Stream.of(String.format(\"[%s]\", section.name)),\n+                    section.data.stream().map(kvp -> {\n+                        return String.format(\"%s=%s\", kvp.getKey(), kvp.getValue());\n+                    }));\n+        });\n+        TKit.createTextFile(path, lines);\n+    }\n+\n+    private Section getSection(String name) {\n+        Objects.requireNonNull(name);\n+        for (var section : data.reversed()) {\n+            if (name.equals(section.name)) {\n+                return section;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public static CfgFile load(Path path) throws IOException {\n@@ -73,1 +119,1 @@\n-        Map<String, Map<String, String>> result = new HashMap<>();\n+        List<Section> sections = new ArrayList<>();\n@@ -76,1 +122,1 @@\n-        Map<String, String> currentSection = new HashMap<>();\n+        List<Map.Entry<String, String>> currentSection = new ArrayList<>();\n@@ -81,2 +127,3 @@\n-                    result.put(currentSectionName, Collections.unmodifiableMap(\n-                            new HashMap<>(currentSection)));\n+                    sections.add(new Section(currentSectionName,\n+                            Collections.unmodifiableList(new ArrayList<>(\n+                                    currentSection))));\n@@ -91,2 +138,1 @@\n-                currentSection.put(matcher.group(1), matcher.group(2));\n-                continue;\n+                currentSection.add(Map.entry(matcher.group(1), matcher.group(2)));\n@@ -97,2 +143,3 @@\n-            result.put(Optional.ofNullable(currentSectionName).orElse(\"\"),\n-                    Collections.unmodifiableMap(currentSection));\n+            sections.add(new Section(\n+                    Optional.ofNullable(currentSectionName).orElse(\"\"),\n+                    Collections.unmodifiableList(currentSection)));\n@@ -101,1 +148,13 @@\n-        return new CfgFile(Collections.unmodifiableMap(result), path.toString());\n+        return new CfgFile(sections, path.toString());\n+    }\n+\n+    private static record Section(String name, List<Map.Entry<String, String>> data) {\n+        String getValue(String key) {\n+            Objects.requireNonNull(key);\n+            for (var kvp : data.reversed()) {\n+                if (key.equals(kvp.getKey())) {\n+                    return kvp.getValue();\n+                }\n+            }\n+            return null;\n+        }\n@@ -104,1 +163,1 @@\n-    private final Map<String, Map<String, String>> data;\n+    private final List<Section> data;\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/CfgFile.java","additions":87,"deletions":28,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,0 @@\n-        removePath = false;\n@@ -94,2 +93,2 @@\n-    public Executor setRemovePath(boolean value) {\n-        removePath = value;\n+    public Executor removeEnvVar(String envVarName) {\n+        removeEnvVars.add(Objects.requireNonNull(envVarName));\n@@ -373,4 +372,6 @@\n-        if (removePath) {\n-            \/\/ run this with cleared Path in Environment\n-            TKit.trace(\"Clearing PATH in environment\");\n-            builder.environment().remove(\"PATH\");\n+       if (!removeEnvVars.isEmpty()) {\n+            final var envComm = Comm.compare(builder.environment().keySet(), removeEnvVars);\n+            builder.environment().keySet().removeAll(envComm.common());\n+            envComm.common().forEach(envVar -> {\n+                TKit.trace(String.format(\"Clearing %s in environment\", envVar));\n+            });\n@@ -515,1 +516,1 @@\n-    private boolean removePath;\n+    private Set<String> removeEnvVars = new HashSet<>();\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/Executor.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -467,1 +467,1 @@\n-            return new Executor()\n+            final var executor = new Executor()\n@@ -471,1 +471,0 @@\n-                    .setRemovePath(removePath)\n@@ -473,1 +472,3 @@\n-                    .addArguments(launcherArgs);\n+                    .addArguments(List.of(args));\n+\n+            return configureEnvironment(executor);\n@@ -490,0 +491,8 @@\n+    public static Executor configureEnvironment(Executor executor) {\n+        if (CLEAR_JAVA_ENV_VARS) {\n+            executor.removeEnvVar(\"JAVA_TOOL_OPTIONS\");\n+            executor.removeEnvVar(\"_JAVA_OPTIONS\");\n+        }\n+        return executor;\n+    }\n+\n@@ -499,0 +508,3 @@\n+\n+    private static final boolean CLEAR_JAVA_ENV_VARS = Optional.ofNullable(\n+            TKit.getConfigProperty(\"clear-app-launcher-java-env-vars\")).map(Boolean::parseBoolean).orElse(false);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/HelloApp.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -625,1 +625,10 @@\n-        Path runtimeDir = appRuntimeDirectory();\n+        if (isFakeRuntime()) {\n+            \/\/ Fake runtime\n+            Path runtimeDir = appRuntimeDirectory();\n+            TKit.trace(String.format(\n+                    \"%s because application runtime directory [%s] is incomplete\",\n+                    msg, runtimeDir));\n+            return true;\n+        }\n+        return false;\n+    }\n@@ -627,0 +636,1 @@\n+    private boolean isFakeRuntime() {\n@@ -638,10 +648,3 @@\n-        if (!criticalRuntimeFiles.stream().anyMatch(v -> {\n-            return runtimeDir.resolve(v).toFile().exists();\n-        })) {\n-            \/\/ Fake runtime\n-            TKit.trace(String.format(\n-                    \"%s because application runtime directory [%s] is incomplete\",\n-                    msg, runtimeDir));\n-            return true;\n-        }\n-        return false;\n+        Path runtimeDir = appRuntimeDirectory();\n+        return !criticalRuntimeFiles.stream().map(runtimeDir::resolve).allMatch(\n+                Files::exists);\n@@ -712,0 +715,7 @@\n+    public JPackageCommand ignoreFakeRuntime() {\n+        if (isFakeRuntime()) {\n+            ignoreDefaultRuntime(true);\n+        }\n+        return this;\n+    }\n+\n@@ -1003,1 +1013,1 @@\n-        return ThrowingFunction.toFunction(CfgFile::readFromFile).apply(\n+        return ThrowingFunction.toFunction(CfgFile::load).apply(\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":22,"deletions":12,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-    public final static class Builder {\n+    public static final class Builder {\n@@ -207,1 +207,1 @@\n-        var cfgFile = CfgFile.readFromFile(cmd.appLauncherCfgPath(launcherName));\n+        var cfgFile = CfgFile.load(cmd.appLauncherCfgPath(launcherName));\n@@ -341,1 +341,1 @@\n-    final static Set<PackageType> SUPPORTED_PACKAGES = Stream.of(LINUX, WINDOWS,\n+    static final Set<PackageType> SUPPORTED_PACKAGES = Stream.of(LINUX, WINDOWS,\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherAsServiceVerifier.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -34,0 +35,2 @@\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -191,0 +194,84 @@\n+    public static void killProcess(long pid) {\n+        Executor.of(\"taskkill\", \"\/F\", \"\/PID\", Long.toString(pid)).dumpOutput(true).execute();\n+    }\n+\n+    public static void killAppLauncherProcess(JPackageCommand cmd,\n+            String launcherName, int expectedCount) {\n+        var pids = findAppLauncherPIDs(cmd, launcherName);\n+        try {\n+            TKit.assertEquals(expectedCount, pids.length, String.format(\n+                    \"Check [%d] %s app launcher processes found running\",\n+                    expectedCount, Optional.ofNullable(launcherName).map(\n+                            str -> \"[\" + str + \"]\").orElse(\"<main>\")));\n+        } finally {\n+            if (pids.length != 0) {\n+                killProcess(pids[0]);\n+            }\n+        }\n+    }\n+\n+    private static long[] findAppLauncherPIDs(JPackageCommand cmd, String launcherName) {\n+        \/\/ Get the list of PIDs and PPIDs of app launcher processes.\n+        \/\/ wmic process where (name = \"foo.exe\") get ProcessID,ParentProcessID\n+        List<String> output = Executor.of(\"wmic\", \"process\", \"where\", \"(name\",\n+                \"=\",\n+                \"\\\"\" + cmd.appLauncherPath(launcherName).getFileName().toString() + \"\\\"\",\n+                \")\", \"get\", \"ProcessID,ParentProcessID\").dumpOutput(true).\n+                saveOutput().executeAndGetOutput();\n+\n+        if (\"No Instance(s) Available.\".equals(output.getFirst().trim())) {\n+            return new long[0];\n+        }\n+\n+        String[] headers = Stream.of(output.getFirst().split(\"\\\\s+\", 2)).map(\n+                String::trim).map(String::toLowerCase).toArray(String[]::new);\n+        Pattern pattern;\n+        if (headers[0].equals(\"parentprocessid\") && headers[1].equals(\n+                \"processid\")) {\n+            pattern = Pattern.compile(\"^(?<ppid>\\\\d+)\\\\s+(?<pid>\\\\d+)\\\\s+$\");\n+        } else if (headers[1].equals(\"parentprocessid\") && headers[0].equals(\n+                \"processid\")) {\n+            pattern = Pattern.compile(\"^(?<pid>\\\\d+)\\\\s+(?<ppid>\\\\d+)\\\\s+$\");\n+        } else {\n+            throw new RuntimeException(\n+                    \"Unrecognizable output of \\'wmic process\\' command\");\n+        }\n+\n+        List<long[]> processes = output.stream().skip(1).map(line -> {\n+            Matcher m = pattern.matcher(line);\n+            long[] pids = null;\n+            if (m.matches()) {\n+                pids = new long[]{Long.parseLong(m.group(\"pid\")), Long.\n+                    parseLong(m.group(\"ppid\"))};\n+            }\n+            return pids;\n+        }).filter(Objects::nonNull).toList();\n+\n+        switch (processes.size()) {\n+            case 2 -> {\n+                final long parentPID;\n+                final long childPID;\n+                if (processes.get(0)[0] == processes.get(1)[1]) {\n+                    parentPID = processes.get(0)[0];\n+                    childPID = processes.get(1)[0];\n+                } else if (processes.get(1)[0] == processes.get(0)[1]) {\n+                    parentPID = processes.get(1)[0];\n+                    childPID = processes.get(0)[0];\n+                } else {\n+                    TKit.assertUnexpected(\"App launcher processes unrelated\");\n+                    return null; \/\/ Unreachable\n+                }\n+                return new long[]{parentPID, childPID};\n+            }\n+            case 1 -> {\n+                return new long[]{processes.get(0)[0]};\n+            }\n+            default -> {\n+                TKit.assertUnexpected(String.format(\n+                        \"Unexpected number of running processes [%d]\",\n+                        processes.size()));\n+                return null; \/\/ Unreachable\n+            }\n+        }\n+    }\n+\n@@ -421,1 +508,1 @@\n-    private final static Path PROGRAM_FILES = Path.of(Optional.ofNullable(\n+    private static final Path PROGRAM_FILES = Path.of(Optional.ofNullable(\n@@ -424,1 +511,1 @@\n-    private final static Path USER_LOCAL = Path.of(System.getProperty(\n+    private static final Path USER_LOCAL = Path.of(System.getProperty(\n@@ -428,2 +515,2 @@\n-    private final static String SYSTEM_SHELL_FOLDERS_REGKEY = \"HKLM\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\";\n-    private final static String USER_SHELL_FOLDERS_REGKEY = \"HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\";\n+    private static final String SYSTEM_SHELL_FOLDERS_REGKEY = \"HKLM\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\";\n+    private static final String USER_SHELL_FOLDERS_REGKEY = \"HKCU\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\Shell Folders\";\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/WindowsHelper.java","additions":91,"deletions":4,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import static jdk.jpackage.test.HelloApp.configureEnvironment;\n@@ -56,0 +57,1 @@\n+                .ignoreFakeRuntime()\n@@ -65,1 +67,1 @@\n-        List<String> output = new Executor()\n+        List<String> output = configureEnvironment(new Executor())\n","filename":"test\/jdk\/tools\/jpackage\/share\/AppLauncherEnvTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-                .ignoreDefaultRuntime(true);\n+                .ignoreFakeRuntime();\n","filename":"test\/jdk\/tools\/jpackage\/share\/BasicTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @build WinChildProcessTest\n@@ -44,0 +43,1 @@\n+import static jdk.jpackage.test.HelloApp.configureEnvironment;\n@@ -47,0 +47,1 @@\n+import static jdk.jpackage.test.WindowsHelper.killProcess;\n@@ -53,1 +54,1 @@\n-    public static void test() throws Throwable {\n+    public static void test() {\n@@ -57,1 +58,2 @@\n-                    .helloAppImage(TEST_APP_JAVA + \"*Hello\");\n+                    .helloAppImage(TEST_APP_JAVA + \"*Hello\")\n+                    .ignoreFakeRuntime();\n@@ -64,1 +66,1 @@\n-            List<String> output = new Executor().saveOutput().dumpOutput()\n+            List<String> output = configureEnvironment(new Executor()).saveOutput().dumpOutput()\n@@ -79,1 +81,1 @@\n-            TKit.assertTrue(isAlive, \"Check is child process is alive\");\n+            TKit.assertTrue(isAlive, \"Check child process is alive\");\n@@ -81,2 +83,4 @@\n-            \/\/ Kill only a specific child instance\n-            Runtime.getRuntime().exec(\"taskkill \/F \/PID \" + childPid);\n+            if (childPid != 0) {\n+                \/\/ Kill only a specific child instance\n+                killProcess(childPid);\n+            }\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinChildProcessTest.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"}]}