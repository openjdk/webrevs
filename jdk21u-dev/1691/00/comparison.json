{"files":[{"patch":"@@ -257,7 +257,1 @@\n-  \/\/ But here we have to pay extra attention:\n-  \/\/ Do not narrow the type of range check dependent CastIINodes to\n-  \/\/ avoid corruption of the graph if a CastII is replaced by TOP but\n-  \/\/ the corresponding range check is not removed.\n-  if (!_range_check_dependency) {\n-    res = widen_type(phase, res, T_INT);\n-  }\n+  res = widen_type(phase, res, T_INT);\n@@ -283,1 +277,1 @@\n-  if (can_reshape && !_range_check_dependency && !phase->C->post_loop_opts_phase()) {\n+  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n@@ -287,1 +281,1 @@\n-  if (!_range_check_dependency) {\n+  if (!_type->is_int()->empty()) {\n@@ -298,7 +292,0 @@\n-  if (_range_check_dependency) {\n-    if (phase->C->post_loop_opts_phase()) {\n-      return this->in(1);\n-    } else {\n-      phase->C->record_for_post_loop_opts_igvn(this);\n-    }\n-  }\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -3435,0 +3435,4 @@\n+  case Op_CastII: {\n+    remove_range_check_cast(n->as_CastII());\n+  }\n+  break;\n@@ -3586,10 +3590,0 @@\n-#ifdef ASSERT\n-  case Op_CastII:\n-    \/\/ Verify that all range check dependent CastII nodes were removed.\n-    if (n->isa_CastII()->has_range_check()) {\n-      n->dump(3);\n-      assert(false, \"Range check dependent CastII node was not removed\");\n-    }\n-    break;\n-#endif\n-\n@@ -3604,0 +3598,2 @@\n+          divmod->add_prec_from(n);\n+          divmod->add_prec_from(d);\n@@ -3624,0 +3620,2 @@\n+          divmod->add_prec_from(n);\n+          divmod->add_prec_from(d);\n@@ -3644,0 +3642,2 @@\n+          divmod->add_prec_from(n);\n+          divmod->add_prec_from(d);\n@@ -3664,0 +3664,2 @@\n+          divmod->add_prec_from(n);\n+          divmod->add_prec_from(d);\n@@ -3840,0 +3842,28 @@\n+void Compile::remove_range_check_cast(CastIINode* cast) {\n+  if (cast->has_range_check()) {\n+    \/\/ Range check CastII nodes feed into an address computation subgraph. Remove them to let that subgraph float freely.\n+    \/\/ For memory access or integer divisions nodes that depend on the cast, record the dependency on the cast's control\n+    \/\/ as a precedence edge, so they can't float above the cast in case that cast's narrowed type helped eliminate a\n+    \/\/ range check or a null divisor check.\n+    assert(cast->in(0) != nullptr, \"All RangeCheck CastII must have a control dependency\");\n+    ResourceMark rm;\n+    Unique_Node_List wq;\n+    wq.push(cast);\n+    for (uint next = 0; next < wq.size(); ++next) {\n+      Node* m = wq.at(next);\n+      for (DUIterator_Fast imax, i = m->fast_outs(imax); i < imax; i++) {\n+        Node* use = m->fast_out(i);\n+        if (use->is_Mem() || use->is_div_or_mod(T_INT) || use->is_div_or_mod(T_LONG)) {\n+          use->ensure_control_or_add_prec(cast->in(0));\n+        } else if (!use->is_CFG() && !use->is_Phi()) {\n+          wq.push(use);\n+        }\n+      }\n+    }\n+    cast->subsume_by(cast->in(1), this);\n+    if (cast->outcnt() == 0) {\n+      cast->disconnect_inputs(this);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":40,"deletions":10,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+class CastIINode;\n@@ -1268,0 +1269,2 @@\n+\n+  void remove_range_check_cast(CastIINode* cast);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2874,0 +2874,9 @@\n+void Node::add_prec_from(Node* n) {\n+  for (uint i = n->req(); i < n->len(); i++) {\n+    Node* prec = n->in(i);\n+    if (prec != nullptr) {\n+      add_prec(prec);\n+    }\n+  }\n+}\n+\n@@ -2897,0 +2906,3 @@\n+bool Node::is_div_or_mod(BasicType bt) const { return Opcode() == Op_Div(bt) || Opcode() == Op_Mod(bt) ||\n+                                                      Opcode() == Op_UDiv(bt) || Opcode() == Op_UMod(bt); }\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1124,0 +1124,1 @@\n+  void add_prec_from(Node* n);\n@@ -1226,0 +1227,2 @@\n+  bool is_div_or_mod(BasicType bt) const;\n+\n@@ -1950,0 +1953,4 @@\n+Op_IL(Div)\n+Op_IL(Mod)\n+Op_IL(UDiv)\n+Op_IL(UMod)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,474 @@\n+\/*\n+ * Copyright (c) 2024, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8324517\n+ * @summary C2: out of bound array load because of dependency on removed range check CastIIs\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n+ *                   -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n+ *                   TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-UseOnStackReplacement -XX:-BackgroundCompilation\n+ *                   -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ * @run main\/othervm TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ * @run main\/othervm -XX:CompileCommand=dontinline,TestArrayAccessAboveRCAfterRCCastIIEliminated::notInlined\n+ *                   TestArrayAccessAboveRCAfterRCCastIIEliminated\n+ *\n+ *\/\n+\n+public class TestArrayAccessAboveRCAfterRCCastIIEliminated {\n+    private static int intField;\n+    private static long longField;\n+    private static volatile int volatileField;\n+\n+    public static void main(String[] args) {\n+        int[] array = new int[100];\n+        for (int i = 0; i < 20_000; i++) {\n+            test1(9, 10, 1, true);\n+            test1(9, 10, 1, false);\n+            test2(9, 10, 1, true);\n+            test2(9, 10, 1, false);\n+            test3(9, 10, 1, true);\n+            test3(9, 10, 1, false);\n+            test4(9, 10, 1, true);\n+            test4(9, 10, 1, false);\n+            test5(9, 10, 1, true);\n+            test5(9, 10, 1, false);\n+            test6(9, 10, 1, true);\n+            test6(9, 10, 1, false);\n+            test7(9, 10, 1, true);\n+            test7(9, 10, 1, false);\n+            test8(9, 10, 1, true);\n+            test8(9, 10, 1, false);\n+            test9(9, 10, 1, true);\n+            test9(9, 10, 1, false);\n+            test10(9, 10, 1, true);\n+            test10(9, 10, 1, false);\n+            test11(9, 10, 1, true);\n+            test11(9, 10, 1, false);\n+            test12(9, 10, 1, true);\n+            test12(9, 10, 1, false);\n+            test13(9, 10, 1, true);\n+            test13(9, 10, 1, false);\n+        }\n+        try {\n+            test1(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test2(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test3(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test4(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test5(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test6(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test7(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test8(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test9(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test10(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test11(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test12(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+        try {\n+            test13(-1, 10, 1, true);\n+        } catch (ArrayIndexOutOfBoundsException arrayIndexOutOfBoundsException) {\n+        }\n+    }\n+\n+    private static void test1(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = array[otherArray.length];\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test2(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test3(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test4(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test5(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test6(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1) + 1 \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = 1 % (otherArray.length + 1) + 1 \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test7(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1) + 1L \/ (otherArray.length + 1);\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = 1L % (otherArray.length + 1) + 1L \/ (otherArray.length + 1);\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+    private static void test8(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test9(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.divideUnsigned(1L, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.divideUnsigned(1L, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test10(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test11(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test12(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1)) +\n+                    Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            intField = Integer.divideUnsigned(1, (otherArray.length + 1)) +\n+                    Integer.remainderUnsigned(1, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void test13(int i, int j, int flag, boolean flag2) {\n+        i = Math.min(i, 9);\n+        int[] array = new int[10];\n+        notInlined(array);\n+        if (flag == 0) {\n+        }\n+        if (flag2) {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1)) +\n+                    Long.divideUnsigned(1L, (otherArray.length + 1));\n+        } else {\n+            float[] newArray = new float[j];\n+            newArray[i] = 42;\n+            float[] otherArray = new float[i];\n+            if (flag == 0) {\n+            }\n+            longField = Long.remainderUnsigned(1L, (otherArray.length + 1)) +\n+                    Long.divideUnsigned(1L, (otherArray.length + 1));\n+        }\n+        for (int k = 0; k < 10; k++) {\n+\n+        }\n+    }\n+\n+    private static void notInlined(int[] array) {\n+\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/rangechecks\/TestArrayAccessAboveRCAfterRCCastIIEliminated.java","additions":474,"deletions":0,"binary":false,"changes":474,"status":"added"}]}