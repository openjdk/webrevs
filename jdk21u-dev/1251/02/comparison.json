{"files":[{"patch":"@@ -39,0 +39,1 @@\n+import java.util.function.BiFunction;\n@@ -40,0 +41,1 @@\n+import java.util.function.Predicate;\n@@ -2258,0 +2260,1 @@\n+                addTypeAnnotationsToSymbol(sym, newList);\n@@ -2264,0 +2267,298 @@\n+    \/**\n+     * Rewrites types in the given symbol to include type annotations.\n+     *\n+     * <p>The list of type annotations includes annotations for all types in the signature of the\n+     * symbol. Associating the annotations with the correct type requires interpreting the JVMS\n+     * 4.7.20-A target_type to locate the correct type to rewrite, and then interpreting the JVMS\n+     * 4.7.20.2 type_path to associate the annotation with the correct contained type.\n+     *\/\n+    private static void addTypeAnnotationsToSymbol(\n+            Symbol s, List<Attribute.TypeCompound> attributes) {\n+        new TypeAnnotationSymbolVisitor(attributes).visit(s, null);\n+    }\n+\n+    private static class TypeAnnotationSymbolVisitor\n+            extends Types.DefaultSymbolVisitor<Void, Void> {\n+\n+        private final List<Attribute.TypeCompound> attributes;\n+\n+        private TypeAnnotationSymbolVisitor(List<Attribute.TypeCompound> attributes) {\n+            this.attributes = attributes;\n+        }\n+\n+        @Override\n+        public Void visitClassSymbol(Symbol.ClassSymbol s, Void unused) {\n+            ClassType t = (ClassType) s.type;\n+            int i = 0;\n+            ListBuffer<Type> interfaces = new ListBuffer<>();\n+            for (Type itf : t.interfaces_field) {\n+                interfaces.add(addTypeAnnotations(itf, classExtends(i++)));\n+            }\n+            t.interfaces_field = interfaces.toList();\n+            t.supertype_field = addTypeAnnotations(t.supertype_field, classExtends(65535));\n+            if (t.typarams_field != null) {\n+                t.typarams_field =\n+                        rewriteTypeParameters(\n+                                t.typarams_field, TargetType.CLASS_TYPE_PARAMETER_BOUND);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitMethodSymbol(Symbol.MethodSymbol s, Void unused) {\n+            Type t = s.type;\n+            if (t.hasTag(TypeTag.FORALL)) {\n+                Type.ForAll fa = (Type.ForAll) t;\n+                fa.tvars = rewriteTypeParameters(fa.tvars, TargetType.METHOD_TYPE_PARAMETER_BOUND);\n+                t = fa.qtype;\n+            }\n+            MethodType mt = (MethodType) t;\n+            ListBuffer<Type> argtypes = new ListBuffer<>();\n+            int i = 0;\n+            for (Symbol.VarSymbol param : s.params) {\n+                param.type = addTypeAnnotations(param.type, methodFormalParameter(i++));\n+                argtypes.add(param.type);\n+            }\n+            mt.argtypes = argtypes.toList();\n+            ListBuffer<Type> thrown = new ListBuffer<>();\n+            i = 0;\n+            for (Type thrownType : mt.thrown) {\n+                thrown.add(addTypeAnnotations(thrownType, thrownType(i++)));\n+            }\n+            mt.thrown = thrown.toList();\n+            mt.restype = addTypeAnnotations(mt.restype, TargetType.METHOD_RETURN);\n+            if (mt.recvtype != null) {\n+                mt.recvtype = addTypeAnnotations(mt.recvtype, TargetType.METHOD_RECEIVER);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitVarSymbol(Symbol.VarSymbol s, Void unused) {\n+            s.type = addTypeAnnotations(s.type, TargetType.FIELD);\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitSymbol(Symbol s, Void unused) {\n+            return null;\n+        }\n+\n+        private List<Type> rewriteTypeParameters(List<Type> tvars, TargetType boundType) {\n+            ListBuffer<Type> tvarbuf = new ListBuffer<>();\n+            int typeVariableIndex = 0;\n+            for (Type tvar : tvars) {\n+                Type bound = tvar.getUpperBound();\n+                if (bound.isCompound()) {\n+                    ClassType ct = (ClassType) bound;\n+                    int boundIndex = 0;\n+                    if (ct.supertype_field != null) {\n+                        ct.supertype_field =\n+                                addTypeAnnotations(\n+                                        ct.supertype_field,\n+                                        typeParameterBound(\n+                                                boundType, typeVariableIndex, boundIndex++));\n+                    }\n+                    ListBuffer<Type> itfbuf = new ListBuffer<>();\n+                    for (Type itf : ct.interfaces_field) {\n+                        itfbuf.add(\n+                                addTypeAnnotations(\n+                                        itf,\n+                                        typeParameterBound(\n+                                                boundType, typeVariableIndex, boundIndex++)));\n+                    }\n+                    ct.interfaces_field = itfbuf.toList();\n+                } else {\n+                    bound =\n+                            addTypeAnnotations(\n+                                    bound,\n+                                    typeParameterBound(\n+                                            boundType,\n+                                            typeVariableIndex,\n+                                            bound.isInterface() ? 1 : 0));\n+                }\n+                ((TypeVar) tvar).setUpperBound(bound);\n+                tvarbuf.add(tvar);\n+                typeVariableIndex++;\n+            }\n+            return tvarbuf.toList();\n+        }\n+\n+        private Type addTypeAnnotations(Type type, TargetType targetType) {\n+            return addTypeAnnotations(type, pos -> pos.type == targetType);\n+        }\n+\n+        private Type addTypeAnnotations(Type type, Predicate<TypeAnnotationPosition> filter) {\n+            Assert.checkNonNull(type);\n+\n+            \/\/ Find type annotations that match the given target type\n+            ListBuffer<Attribute.TypeCompound> filtered = new ListBuffer<>();\n+            for (Attribute.TypeCompound attribute : this.attributes) {\n+                if (filter.test(attribute.position)) {\n+                    filtered.add(attribute);\n+                }\n+            }\n+            if (filtered.isEmpty()) {\n+                return type;\n+            }\n+\n+            \/\/ Group the matching annotations by their type path. Each group of annotations will be\n+            \/\/ added to a type at that location.\n+            Map<List<TypeAnnotationPosition.TypePathEntry>, ListBuffer<Attribute.TypeCompound>>\n+                    attributesByPath = new HashMap<>();\n+            for (Attribute.TypeCompound attribute : filtered.toList()) {\n+                attributesByPath\n+                        .computeIfAbsent(attribute.position.location, k -> new ListBuffer<>())\n+                        .add(attribute);\n+            }\n+\n+            \/\/ Search the structure of the type to find the contained types at each type path\n+            Map<Type, List<Attribute.TypeCompound>> attributesByType = new HashMap<>();\n+            new TypeAnnotationLocator(attributesByPath, attributesByType).visit(type, List.nil());\n+\n+            \/\/ Rewrite the type and add the annotations\n+            type = new TypeAnnotationTypeMapping(attributesByType).visit(type, null);\n+            Assert.check(attributesByType.isEmpty(), \"Failed to apply annotations to types\");\n+\n+            return type;\n+        }\n+\n+        private static Predicate<TypeAnnotationPosition> typeParameterBound(\n+                TargetType targetType, int parameterIndex, int boundIndex) {\n+            return pos ->\n+                    pos.type == targetType\n+                            && pos.parameter_index == parameterIndex\n+                            && pos.bound_index == boundIndex;\n+        }\n+\n+        private static Predicate<TypeAnnotationPosition> methodFormalParameter(int index) {\n+            return pos ->\n+                    pos.type == TargetType.METHOD_FORMAL_PARAMETER && pos.parameter_index == index;\n+        }\n+\n+        private static Predicate<TypeAnnotationPosition> thrownType(int index) {\n+            return pos -> pos.type == TargetType.THROWS && pos.type_index == index;\n+        }\n+\n+        private static Predicate<TypeAnnotationPosition> classExtends(int index) {\n+            return pos -> pos.type == TargetType.CLASS_EXTENDS && pos.type_index == index;\n+        }\n+    }\n+\n+    \/**\n+     * Visit all contained types, assembling a type path to represent the current location, and\n+     * record the types at each type path that need to be annotated.\n+     *\/\n+    private static class TypeAnnotationLocator\n+            extends Types.DefaultTypeVisitor<Void, List<TypeAnnotationPosition.TypePathEntry>> {\n+        private final Map<List<TypeAnnotationPosition.TypePathEntry>,\n+                          ListBuffer<Attribute.TypeCompound>> attributesByPath;\n+        private final Map<Type, List<Attribute.TypeCompound>> attributesByType;\n+\n+        private TypeAnnotationLocator(\n+                Map<List<TypeAnnotationPosition.TypePathEntry>, ListBuffer<Attribute.TypeCompound>>\n+                        attributesByPath,\n+                Map<Type, List<Attribute.TypeCompound>> attributesByType) {\n+            this.attributesByPath = attributesByPath;\n+            this.attributesByType = attributesByType;\n+        }\n+\n+        @Override\n+        public Void visitClassType(ClassType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            \/\/ As described in JVMS 4.7.20.2, type annotations on nested types are located with\n+            \/\/ 'left-to-right' steps starting on 'the outermost part of the type for which a type\n+            \/\/ annotation is admissible'. So the current path represents the outermost containing\n+            \/\/ type of the type being visited, and we add type path steps for every contained nested\n+            \/\/ type.\n+            List<ClassType> enclosing = List.nil();\n+            for (Type curr = t;\n+                    curr != null && curr != Type.noType;\n+                    curr = curr.getEnclosingType()) {\n+                enclosing = enclosing.prepend((ClassType) curr);\n+            }\n+            for (ClassType te : enclosing) {\n+                if (te.typarams_field != null) {\n+                    int i = 0;\n+                    for (Type typaram : te.typarams_field) {\n+                        visit(typaram, path.append(new TypeAnnotationPosition.TypePathEntry(\n+                                TypeAnnotationPosition.TypePathEntryKind.TYPE_ARGUMENT, i++)));\n+                    }\n+                }\n+                visitType(te, path);\n+                path = path.append(TypeAnnotationPosition.TypePathEntry.INNER_TYPE);\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitWildcardType(\n+                WildcardType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            visit(t.type, path.append(TypeAnnotationPosition.TypePathEntry.WILDCARD));\n+            return super.visitWildcardType(t, path);\n+        }\n+\n+        @Override\n+        public Void visitArrayType(ArrayType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            visit(t.elemtype, path.append(TypeAnnotationPosition.TypePathEntry.ARRAY));\n+            return super.visitArrayType(t, path);\n+        }\n+\n+        @Override\n+        public Void visitType(Type t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            ListBuffer<Attribute.TypeCompound> attributes = attributesByPath.remove(path);\n+            if (attributes != null) {\n+                attributesByType.put(t, attributes.toList());\n+            }\n+            return null;\n+        }\n+    }\n+\n+    \/** A type mapping that rewrites the type to include type annotations. *\/\n+    private static class TypeAnnotationTypeMapping extends Type.StructuralTypeMapping<Void> {\n+\n+        private final Map<Type, List<Attribute.TypeCompound>> attributesByType;\n+\n+        private TypeAnnotationTypeMapping(\n+                Map<Type, List<Attribute.TypeCompound>> attributesByType) {\n+            this.attributesByType = attributesByType;\n+        }\n+\n+        private <T extends Type> Type reannotate(T t, BiFunction<T, Void, Type> f) {\n+            \/\/ We're relying on object identify of Type instances to record where the annotations\n+            \/\/ need to be added, so we have to retrieve the annotations for each type before\n+            \/\/ rewriting it, and then add them after its contained types have been rewritten.\n+            List<Attribute.TypeCompound> attributes = attributesByType.remove(t);\n+            Type mapped = f.apply(t, null);\n+            if (attributes == null) {\n+                return mapped;\n+            }\n+            \/\/ Runtime-visible and -invisible annotations are completed separately, so if the same\n+            \/\/ type has annotations from both it will get annotated twice.\n+            TypeMetadata.Annotations existing = mapped.getMetadata(TypeMetadata.Annotations.class);\n+            if (existing != null) {\n+                existing.annotationBuffer().addAll(attributes);\n+                return mapped;\n+            }\n+            return mapped.annotatedType(attributes);\n+        }\n+\n+        @Override\n+        public Type visitClassType(ClassType t, Void unused) {\n+            return reannotate(t, super::visitClassType);\n+        }\n+\n+        @Override\n+        public Type visitWildcardType(WildcardType t, Void unused) {\n+            return reannotate(t, super::visitWildcardType);\n+        }\n+\n+        @Override\n+        public Type visitArrayType(ArrayType t, Void unused) {\n+            return reannotate(t, super::visitArrayType);\n+        }\n+\n+        @Override\n+        public Type visitType(Type t, Void unused) {\n+            return reannotate(t, (x, u) -> x);\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":301,"deletions":0,"binary":false,"changes":301,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+ * @compile\/process -XDaccessInternalAPI -processor BasicAnnoTests -proc:only BasicAnnoTests\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/type\/BasicAnnoTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}