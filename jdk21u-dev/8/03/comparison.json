{"files":[{"patch":"@@ -886,1 +886,2 @@\n-\/\/ Support class with a collection of functions used when dumping the heap\n+class DumperClassCacheTable;\n+class DumperClassCacheTableEntry;\n@@ -888,0 +889,1 @@\n+\/\/ Support class with a collection of functions used when dumping the heap\n@@ -902,1 +904,1 @@\n-  static u4 instance_size(Klass* k);\n+  static u4 instance_size(InstanceKlass* ik, DumperClassCacheTableEntry* class_cache_entry = nullptr);\n@@ -915,1 +917,1 @@\n-  static void dump_instance_fields(AbstractDumpWriter* writer, oop o);\n+  static void dump_instance_fields(AbstractDumpWriter* writer, oop o, DumperClassCacheTableEntry* class_cache_entry);\n@@ -921,1 +923,1 @@\n-  static void dump_instance(AbstractDumpWriter* writer, oop o);\n+  static void dump_instance(AbstractDumpWriter* writer, oop o, DumperClassCacheTable* class_cache);\n@@ -951,0 +953,100 @@\n+\/\/ Hash table of klasses to the klass metadata. This should greatly improve the\n+\/\/ hash dumping performance. This hash table is supposed to be used by a single\n+\/\/ thread only.\n+\/\/\n+class DumperClassCacheTableEntry : public CHeapObj<mtServiceability> {\n+  friend class DumperClassCacheTable;\n+private:\n+  GrowableArray<char> _sigs_start;\n+  GrowableArray<int> _offsets;\n+  u4 _instance_size;\n+  int _entries;\n+\n+public:\n+  DumperClassCacheTableEntry() : _instance_size(0), _entries(0) {};\n+\n+  int field_count()             { return _entries; }\n+  char sig_start(int field_idx) { return _sigs_start.at(field_idx); }\n+  int offset(int field_idx)     { return _offsets.at(field_idx); }\n+  u4 instance_size()            { return _instance_size; }\n+};\n+\n+class DumperClassCacheTable {\n+private:\n+  \/\/ ResourceHashtable SIZE is specified at compile time so we\n+  \/\/ use 1031 which is the first prime after 1024.\n+  static constexpr size_t TABLE_SIZE = 1031;\n+\n+  \/\/ Maintain the cache for N classes. This limits memory footprint\n+  \/\/ impact, regardless of how many classes we have in the dump.\n+  \/\/ This also improves look up performance by keeping the statically\n+  \/\/ sized table from overloading.\n+  static constexpr int CACHE_TOP = 256;\n+\n+  typedef ResourceHashtable<InstanceKlass*, DumperClassCacheTableEntry*,\n+                            TABLE_SIZE, AnyObj::C_HEAP, mtServiceability> PtrTable;\n+  PtrTable* _ptrs;\n+\n+  \/\/ Single-slot cache to handle the major case of objects of the same\n+  \/\/ class back-to-back, e.g. from T[].\n+  InstanceKlass* _last_ik;\n+  DumperClassCacheTableEntry* _last_entry;\n+\n+  void unlink_all(PtrTable* table) {\n+    class CleanupEntry: StackObj {\n+    public:\n+      bool do_entry(InstanceKlass*& key, DumperClassCacheTableEntry*& entry) {\n+        delete entry;\n+        return true;\n+      }\n+    } cleanup;\n+    table->unlink(&cleanup);\n+  }\n+\n+public:\n+  DumperClassCacheTableEntry* lookup_or_create(InstanceKlass* ik) {\n+    if (_last_ik == ik) {\n+      return _last_entry;\n+    }\n+\n+    DumperClassCacheTableEntry* entry;\n+    DumperClassCacheTableEntry** from_cache = _ptrs->get(ik);\n+    if (from_cache == nullptr) {\n+      entry = new DumperClassCacheTableEntry();\n+      for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n+        if (!fld.access_flags().is_static()) {\n+          Symbol* sig = fld.signature();\n+          entry->_sigs_start.push(sig->char_at(0));\n+          entry->_offsets.push(fld.offset());\n+          entry->_entries++;\n+          entry->_instance_size += DumperSupport::sig2size(sig);\n+        }\n+      }\n+\n+      if (_ptrs->number_of_entries() >= CACHE_TOP) {\n+        \/\/ We do not track the individual hit rates for table entries.\n+        \/\/ Purge the entire table, and let the cache catch up with new\n+        \/\/ distribution.\n+        unlink_all(_ptrs);\n+      }\n+\n+      _ptrs->put(ik, entry);\n+    } else {\n+      entry = *from_cache;\n+    }\n+\n+    \/\/ Remember for single-slot cache.\n+    _last_ik = ik;\n+    _last_entry = entry;\n+\n+    return entry;\n+  }\n+\n+  DumperClassCacheTable() : _ptrs(new (mtServiceability) PtrTable), _last_ik(nullptr), _last_entry(nullptr) {}\n+\n+  ~DumperClassCacheTable() {\n+    unlink_all(_ptrs);\n+    delete _ptrs;\n+  }\n+};\n+\n@@ -1095,7 +1197,9 @@\n-u4 DumperSupport::instance_size(Klass* k) {\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n-  u4 size = 0;\n-\n-  for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n-    if (!fld.access_flags().is_static()) {\n-      size += sig2size(fld.signature());\n+u4 DumperSupport::instance_size(InstanceKlass* ik, DumperClassCacheTableEntry* class_cache_entry) {\n+  if (class_cache_entry != nullptr) {\n+    return class_cache_entry->instance_size();\n+  } else {\n+    u4 size = 0;\n+    for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n+      if (!fld.access_flags().is_static()) {\n+        size += sig2size(fld.signature());\n+      }\n@@ -1103,0 +1207,1 @@\n+    return size;\n@@ -1104,1 +1209,0 @@\n-  return size;\n@@ -1176,8 +1280,4 @@\n-void DumperSupport::dump_instance_fields(AbstractDumpWriter* writer, oop o) {\n-  InstanceKlass* ik = InstanceKlass::cast(o->klass());\n-\n-  for (HierarchicalFieldStream<JavaFieldStream> fld(ik); !fld.done(); fld.next()) {\n-    if (!fld.access_flags().is_static()) {\n-      Symbol* sig = fld.signature();\n-      dump_field_value(writer, sig->char_at(0), o, fld.offset());\n-    }\n+void DumperSupport::dump_instance_fields(AbstractDumpWriter* writer, oop o, DumperClassCacheTableEntry* class_cache_entry) {\n+  assert(class_cache_entry != nullptr, \"Pre-condition: must be provided\");\n+  for (int idx = 0; idx < class_cache_entry->field_count(); idx++) {\n+    dump_field_value(writer, class_cache_entry->sig_start(idx), o, class_cache_entry->offset(idx));\n@@ -1214,1 +1314,1 @@\n-void DumperSupport::dump_instance(AbstractDumpWriter* writer, oop o) {\n+void DumperSupport::dump_instance(AbstractDumpWriter* writer, oop o, DumperClassCacheTable* class_cache) {\n@@ -1216,1 +1316,4 @@\n-  u4 is = instance_size(ik);\n+\n+  DumperClassCacheTableEntry* cache_entry = class_cache->lookup_or_create(ik);\n+\n+  u4 is = instance_size(ik, cache_entry);\n@@ -1230,1 +1333,1 @@\n-  dump_instance_fields(writer, o);\n+  dump_instance_fields(writer, o, cache_entry);\n@@ -1693,0 +1796,3 @@\n+\n+  DumperClassCacheTable _class_cache;\n+\n@@ -1725,1 +1831,1 @@\n-    DumperSupport::dump_instance(writer(), o);\n+    DumperSupport::dump_instance(writer(), o, &_class_cache);\n@@ -2281,0 +2387,1 @@\n+    ResourceMark rm;\n@@ -2297,0 +2404,1 @@\n+         ResourceMark rm;\n@@ -2317,0 +2425,1 @@\n+  ResourceMark rm;\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":133,"deletions":24,"binary":false,"changes":157,"status":"modified"}]}