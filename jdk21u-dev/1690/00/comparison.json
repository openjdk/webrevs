{"files":[{"patch":"@@ -1564,0 +1564,1 @@\n+int java_lang_Thread::_interruptLock_offset;\n@@ -1577,0 +1578,1 @@\n+  macro(_interruptLock_offset, k, \"interruptLock\", object_signature, false); \\\n@@ -1659,0 +1661,3 @@\n+oop java_lang_Thread::interrupt_lock(oop java_thread) {\n+  return java_thread->obj_field(_interruptLock_offset);\n+}\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -363,0 +363,1 @@\n+  static int _interruptLock_offset;\n@@ -382,0 +383,2 @@\n+  \/\/ interruptLock\n+  static oop interrupt_lock(oop java_thread);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -254,1 +254,1 @@\n-      if (jt->is_interrupted(true)) {\n+      if (jt->get_and_clear_interrupted()) {\n@@ -265,1 +265,1 @@\n-      if (jt->is_interrupted(true)) {\n+      if (jt->get_and_clear_interrupted()) {\n@@ -404,1 +404,1 @@\n-    if (jt->is_interrupted(true)) {\n+    if (jt->get_and_clear_interrupted()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiRawMonitor.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -191,0 +191,10 @@\n+\/\/ If there is a virtual thread mounted then return vthread() oop.\n+\/\/ Otherwise, return threadObj().\n+oop JavaThread::vthread_or_thread() const {\n+  oop result = vthread();\n+  if (result == nullptr) {\n+    result = threadObj();\n+  }\n+  return result;\n+}\n+\n@@ -543,1 +553,0 @@\n-\n@@ -578,0 +587,2 @@\n+  return interrupted;\n+}\n@@ -579,0 +590,28 @@\n+\/\/ This is only for use by JVMTI RawMonitorWait. It emulates the actions of\n+\/\/ the Java code in Object::wait which are not present in RawMonitorWait.\n+bool JavaThread::get_and_clear_interrupted() {\n+  if (!is_interrupted(false)) {\n+    return false;\n+  }\n+  oop thread_oop = vthread_or_thread();\n+  bool is_virtual = java_lang_VirtualThread::is_instance(thread_oop);\n+\n+  if (!is_virtual) {\n+    return is_interrupted(true);\n+  }\n+  \/\/ Virtual thread: clear interrupt status for both virtual and\n+  \/\/ carrier threads under the interruptLock protection.\n+  JavaThread* current = JavaThread::current();\n+  HandleMark hm(current);\n+  Handle thread_h(current, thread_oop);\n+  ObjectLocker lock(Handle(current, java_lang_Thread::interrupt_lock(thread_h())), current);\n+\n+  \/\/ re-check the interrupt status under the interruptLock protection\n+  bool interrupted = java_lang_Thread::interrupted(thread_h());\n+\n+  if (interrupted) {\n+    assert(this == Thread::current(), \"only the current thread can clear\");\n+    java_lang_Thread::set_interrupted(thread_h(), false);  \/\/ clear for virtual\n+    java_lang_Thread::set_interrupted(threadObj(), false); \/\/ clear for carrier\n+    WINDOWS_ONLY(osthread()->set_interrupted(false);)\n+  }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -525,0 +525,1 @@\n+  oop vthread_or_thread() const;\n@@ -1141,0 +1142,4 @@\n+  \/\/ This is only for use by JVMTI RawMonitorWait. It emulates the actions of\n+  \/\/ the Java code in Object::wait which are not present in RawMonitorWait.\n+  bool get_and_clear_interrupted();\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @bug 8325187\n+ * @summary Verifies JVMTI InterruptThread works for virtual threads.\n+ * @run main\/othervm\/native -agentlib:InterruptRawMonitor InterruptRawMonitor\n+ *\n+ * @test id=virtual\n+ * @bug 8325187\n+ * @summary Verifies JVMTI InterruptThread works for virtual threads.\n+ * @run main\/othervm\/native -agentlib:InterruptRawMonitor InterruptRawMonitor -v\n+ *\/\n+\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class InterruptRawMonitor {\n+    private static final String AGENT_LIB = \"InterruptRawMonitor\";\n+    static native void test();\n+    static native void waitForCondition(Thread t);\n+\n+    public static void main(String[] args) throws Exception {\n+        Thread thread;\n+        if (args.length > 0 && \"-v\".equals(args[0])) {\n+            thread = Thread.ofVirtual().unstarted(InterruptRawMonitor::test);\n+        } else {\n+            thread = Thread.ofPlatform().unstarted(InterruptRawMonitor::test);\n+        }\n+        System.out.println(thread);\n+        thread.start();\n+        waitForCondition(thread);\n+        thread.interrupt();\n+        thread.join();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/InterruptRawMonitor\/InterruptRawMonitor.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+static jvmtiEnv *jvmti = nullptr;\n+static jrawMonitorID monitor = nullptr;\n+static bool is_waiting = false;\n+\n+static void check_thread_not_interrupted(JNIEnv *jni, int check_idx) {\n+  jint state = get_thread_state(jvmti, jni, nullptr);\n+\n+  LOG(\"\\ntest: check #%d: Thread State: (0x%x) %s\\n\",\n+      check_idx, state, TranslateState(state));\n+\n+  if ((state & JVMTI_THREAD_STATE_INTERRUPTED) != 0) {\n+    fatal(jni, \"Failed: JVMTI_THREAD_STATE_INTERRUPTED bit expected to be cleared\");\n+  }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_InterruptRawMonitor_waitForCondition(JNIEnv *jni, jclass clazz, jthread thread) {\n+  jint state = 0;\n+  RawMonitorLocker rml(jvmti, jni, monitor);\n+\n+  while (!is_waiting) {\n+    state = get_thread_state(jvmti, jni, thread);\n+    LOG(\"main: waitForCondition: target Thread State: (0x%x) %s\\n\",\n+        state, TranslateState(state));\n+    rml.wait(10);\n+  }\n+  state = get_thread_state(jvmti, jni, thread);\n+  LOG(\"main: waitForCondition: target Thread State: (0x%x) %s\\n\\n\",\n+      state, TranslateState(state));\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_InterruptRawMonitor_test(JNIEnv *jni, jclass clazz) {\n+  RawMonitorLocker rml(jvmti, jni, monitor);\n+\n+  check_thread_not_interrupted(jni, 0);\n+  is_waiting = true;\n+\n+  \/\/ expected to be interrupted\n+  jvmtiError err = jvmti->RawMonitorWait(monitor, 0);\n+  LOG(\"test: JVMTI RawMonitorWait returned expected error code: (%d) %s\\n\",\n+      err, TranslateError(err));\n+  if (err != JVMTI_ERROR_INTERRUPT) {\n+    fatal(jni, \"Failed: expected JVMTI_ERROR_INTERRUPT from RawMonitorWait\");\n+  }\n+\n+  check_thread_not_interrupted(jni, 1);\n+\n+  rml.wait(10); \/\/ expected to be non-interrupted\n+\n+  check_thread_not_interrupted(jni, 2);\n+}\n+\n+extern JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  LOG(\"Agent_OnLoad started\\n\");\n+  if (jvm->GetEnv((void **)(&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  monitor = create_raw_monitor(jvmti, \"Test Monitor\");\n+  LOG(\"test: JVMTI_THREAD_STATE_INTERRUPTED bit: 0x%x\\n\", JVMTI_THREAD_STATE_INTERRUPTED);\n+\n+  LOG(\"Agent_OnLoad finished\\n\");\n+  return JNI_OK;\n+}\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/InterruptRawMonitor\/libInterruptRawMonitor.cpp","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}