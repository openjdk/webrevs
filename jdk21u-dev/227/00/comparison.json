{"files":[{"patch":"@@ -34,129 +34,0 @@\n-#ifdef M68K\n-\n-\/*\n- * __m68k_cmpxchg\n- *\n- * Atomically store newval in *ptr if *ptr is equal to oldval for user space.\n- * Returns newval on success and oldval if no exchange happened.\n- * This implementation is processor specific and works on\n- * 68020 68030 68040 and 68060.\n- *\n- * It will not work on ColdFire, 68000 and 68010 since they lack the CAS\n- * instruction.\n- * Using a kernelhelper would be better for arch complete implementation.\n- *\n- *\/\n-\n-static inline int __m68k_cmpxchg(int oldval, int newval, volatile int *ptr) {\n-  int ret;\n-  __asm __volatile (\"cas%.l %0,%2,%1\"\n-                   : \"=d\" (ret), \"+m\" (*(ptr))\n-                   : \"d\" (newval), \"0\" (oldval));\n-  return ret;\n-}\n-\n-\/* Perform an atomic compare and swap: if the current value of `*PTR'\n-   is OLDVAL, then write NEWVAL into `*PTR'.  Return the contents of\n-   `*PTR' before the operation.*\/\n-static inline int m68k_compare_and_swap(int newval,\n-                                        volatile int *ptr,\n-                                        int oldval) {\n-  for (;;) {\n-      int prev = *ptr;\n-      if (prev != oldval)\n-        return prev;\n-\n-      if (__m68k_cmpxchg (prev, newval, ptr) == newval)\n-        \/\/ Success.\n-        return prev;\n-\n-      \/\/ We failed even though prev == oldval.  Try again.\n-    }\n-}\n-\n-\/* Atomically add an int to memory.  *\/\n-static inline int m68k_add_then_fetch(int add_value, volatile int *ptr) {\n-  for (;;) {\n-      \/\/ Loop until success.\n-\n-      int prev = *ptr;\n-\n-      if (__m68k_cmpxchg (prev, prev + add_value, ptr) == prev + add_value)\n-        return prev + add_value;\n-    }\n-}\n-\n-\/* Atomically write VALUE into `*PTR' and returns the previous\n-   contents of `*PTR'.  *\/\n-static inline int m68k_lock_test_and_set(int newval, volatile int *ptr) {\n-  for (;;) {\n-      \/\/ Loop until success.\n-      int prev = *ptr;\n-\n-      if (__m68k_cmpxchg (prev, newval, ptr) == prev)\n-        return prev;\n-    }\n-}\n-#endif \/\/ M68K\n-\n-#ifdef ARM\n-\n-\/*\n- * __kernel_cmpxchg\n- *\n- * Atomically store newval in *ptr if *ptr is equal to oldval for user space.\n- * Return zero if *ptr was changed or non-zero if no exchange happened.\n- * The C flag is also set if *ptr was changed to allow for assembly\n- * optimization in the calling code.\n- *\n- *\/\n-\n-typedef int (__kernel_cmpxchg_t)(int oldval, int newval, volatile int *ptr);\n-#define __kernel_cmpxchg (*(__kernel_cmpxchg_t *) 0xffff0fc0)\n-\n-\n-\n-\/* Perform an atomic compare and swap: if the current value of `*PTR'\n-   is OLDVAL, then write NEWVAL into `*PTR'.  Return the contents of\n-   `*PTR' before the operation.*\/\n-static inline int arm_compare_and_swap(int newval,\n-                                       volatile int *ptr,\n-                                       int oldval) {\n-  for (;;) {\n-      int prev = *ptr;\n-      if (prev != oldval)\n-        return prev;\n-\n-      if (__kernel_cmpxchg (prev, newval, ptr) == 0)\n-        \/\/ Success.\n-        return prev;\n-\n-      \/\/ We failed even though prev == oldval.  Try again.\n-    }\n-}\n-\n-\/* Atomically add an int to memory.  *\/\n-static inline int arm_add_then_fetch(int add_value, volatile int *ptr) {\n-  for (;;) {\n-      \/\/ Loop until a __kernel_cmpxchg succeeds.\n-\n-      int prev = *ptr;\n-\n-      if (__kernel_cmpxchg (prev, prev + add_value, ptr) == 0)\n-        return prev + add_value;\n-    }\n-}\n-\n-\/* Atomically write VALUE into `*PTR' and returns the previous\n-   contents of `*PTR'.  *\/\n-static inline int arm_lock_test_and_set(int newval, volatile int *ptr) {\n-  for (;;) {\n-      \/\/ Loop until a __kernel_cmpxchg succeeds.\n-      int prev = *ptr;\n-\n-      if (__kernel_cmpxchg (prev, newval, ptr) == 0)\n-        return prev;\n-    }\n-}\n-#endif \/\/ ARM\n-\n@@ -181,6 +52,0 @@\n-#ifdef ARM\n-  return add_using_helper<int>(arm_add_then_fetch, dest, add_value);\n-#else\n-#ifdef M68K\n-  return add_using_helper<int>(m68k_add_then_fetch, dest, add_value);\n-#else\n@@ -190,2 +55,0 @@\n-#endif \/\/ M68K\n-#endif \/\/ ARM\n@@ -212,17 +75,3 @@\n-#ifdef ARM\n-  return xchg_using_helper<int>(arm_lock_test_and_set, dest, exchange_value);\n-#else\n-#ifdef M68K\n-  return xchg_using_helper<int>(m68k_lock_test_and_set, dest, exchange_value);\n-#else\n-  \/\/ __sync_lock_test_and_set is a bizarrely named atomic exchange\n-  \/\/ operation.  Note that some platforms only support this with the\n-  \/\/ limitation that the only valid value to store is the immediate\n-  \/\/ constant 1.  There is a test for this in JNI_CreateJavaVM().\n-  T result = __sync_lock_test_and_set (dest, exchange_value);\n-  \/\/ All atomic operations are expected to be full memory barriers\n-  \/\/ (see atomic.hpp). However, __sync_lock_test_and_set is not\n-  \/\/ a full memory barrier, but an acquire barrier. Hence, this added\n-  \/\/ barrier. Some platforms (notably ARM) have peculiarities with\n-  \/\/ their barrier implementations, delegate it to OrderAccess.\n-  OrderAccess::fence();\n+  FULL_MEM_BARRIER;\n+  T result = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELAXED);\n+  FULL_MEM_BARRIER;\n@@ -230,2 +79,0 @@\n-#endif \/\/ M68K\n-#endif \/\/ ARM\n@@ -240,2 +87,3 @@\n-  T result = __sync_lock_test_and_set (dest, exchange_value);\n-  OrderAccess::fence();\n+  FULL_MEM_BARRIER;\n+  T result = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELAXED);\n+  FULL_MEM_BARRIER;\n@@ -256,6 +104,0 @@\n-#ifdef ARM\n-  return cmpxchg_using_helper<int>(arm_compare_and_swap, dest, compare_value, exchange_value);\n-#else\n-#ifdef M68K\n-  return cmpxchg_using_helper<int>(m68k_compare_and_swap, dest, compare_value, exchange_value);\n-#else\n@@ -268,2 +110,0 @@\n-#endif \/\/ M68K\n-#endif \/\/ ARM\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/atomic_bsd_zero.hpp","additions":6,"deletions":166,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -334,16 +334,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ Implementations of atomic operations not supported by processors.\n-\/\/  -- http:\/\/gcc.gnu.org\/onlinedocs\/gcc-4.2.1\/gcc\/Atomic-Builtins.html\n-\n-#ifndef _LP64\n-extern \"C\" {\n-  long long unsigned int __sync_val_compare_and_swap_8(\n-    volatile void *ptr,\n-    long long unsigned int oldval,\n-    long long unsigned int newval) {\n-    ShouldNotCallThis();\n-    return 0; \/\/ silence compiler warnings\n-  }\n-};\n-#endif \/\/ !_LP64\n-\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/os_bsd_zero.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -74,11 +74,3 @@\n-  \/\/ __sync_lock_test_and_set is a bizarrely named atomic exchange\n-  \/\/ operation.  Note that some platforms only support this with the\n-  \/\/ limitation that the only valid value to store is the immediate\n-  \/\/ constant 1.  There is a test for this in JNI_CreateJavaVM().\n-  T result = __sync_lock_test_and_set (dest, exchange_value);\n-  \/\/ All atomic operations are expected to be full memory barriers\n-  \/\/ (see atomic.hpp). However, __sync_lock_test_and_set is not\n-  \/\/ a full memory barrier, but an acquire barrier. Hence, this added\n-  \/\/ barrier. Some platforms (notably ARM) have peculiarities with\n-  \/\/ their barrier implementations, delegate it to OrderAccess.\n-  OrderAccess::fence();\n+  FULL_MEM_BARRIER;\n+  T result = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELAXED);\n+  FULL_MEM_BARRIER;\n@@ -94,2 +86,3 @@\n-  T result = __sync_lock_test_and_set (dest, exchange_value);\n-  OrderAccess::fence();\n+  FULL_MEM_BARRIER;\n+  T result = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELAXED);\n+  FULL_MEM_BARRIER;\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/atomic_linux_zero.hpp","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -495,16 +495,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ Implementations of atomic operations not supported by processors.\n-\/\/  -- http:\/\/gcc.gnu.org\/onlinedocs\/gcc-4.2.1\/gcc\/Atomic-Builtins.html\n-\n-#ifndef _LP64\n-extern \"C\" {\n-  long long unsigned int __sync_val_compare_and_swap_8(\n-    volatile void *ptr,\n-    long long unsigned int oldval,\n-    long long unsigned int newval) {\n-    ShouldNotCallThis();\n-    return 0; \/\/ silence compiler warnings\n-  }\n-};\n-#endif \/\/ !_LP64\n-\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/os_linux_zero.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"}]}