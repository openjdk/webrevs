{"files":[{"patch":"@@ -1515,1 +1515,1 @@\n-  BUILD_HOTSPOT_JTREG_EXCLUDE += libNativeException.c\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += libNativeException.c exeGetProcessorInfo.c\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+product(bool, UseAllWindowsProcessorGroups, false,                        \\\n+        \"Use all processor groups on supported Windows versions\")         \\\n+                                                                          \\\n","filename":"src\/hotspot\/os\/windows\/globals_windows.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+#include \"utilities\/population_count.hpp\"\n@@ -879,10 +880,61 @@\n-  DWORD_PTR lpProcessAffinityMask = 0;\n-  DWORD_PTR lpSystemAffinityMask = 0;\n-  int proc_count = processor_count();\n-  if (proc_count <= sizeof(UINT_PTR) * BitsPerByte &&\n-      GetProcessAffinityMask(GetCurrentProcess(), &lpProcessAffinityMask, &lpSystemAffinityMask)) {\n-    \/\/ Nof active processors is number of bits in process affinity mask\n-    int bitcount = 0;\n-    while (lpProcessAffinityMask != 0) {\n-      lpProcessAffinityMask = lpProcessAffinityMask & (lpProcessAffinityMask-1);\n-      bitcount++;\n+  bool schedules_all_processor_groups = win32::is_windows_11_or_greater() || win32::is_windows_server_2022_or_greater();\n+  if (UseAllWindowsProcessorGroups && !schedules_all_processor_groups && !win32::processor_group_warning_displayed()) {\n+    win32::set_processor_group_warning_displayed(true);\n+    FLAG_SET_DEFAULT(UseAllWindowsProcessorGroups, false);\n+    warning(\"The UseAllWindowsProcessorGroups flag is not supported on this Windows version and will be ignored.\");\n+  }\n+\n+  DWORD active_processor_groups = 0;\n+  DWORD processors_in_job_object = win32::active_processors_in_job_object(&active_processor_groups);\n+\n+  if (processors_in_job_object > 0) {\n+    if (schedules_all_processor_groups) {\n+      \/\/ If UseAllWindowsProcessorGroups is enabled then all the processors in the job object\n+      \/\/ can be used. Otherwise, we will fall through to inspecting the process affinity mask.\n+      \/\/ This will result in using only the subset of the processors in the default processor\n+      \/\/ group allowed by the job object i.e. only 1 processor group will be used and only\n+      \/\/ the processors in that group that are allowed by the job object will be used.\n+      \/\/ This preserves the behavior where older OpenJDK versions always used one processor\n+      \/\/ group regardless of whether they were launched in a job object.\n+      if (!UseAllWindowsProcessorGroups && active_processor_groups > 1) {\n+        if (!win32::job_object_processor_group_warning_displayed()) {\n+          win32::set_job_object_processor_group_warning_displayed(true);\n+          warning(\"The Windows job object has enabled multiple processor groups (%d) but the UseAllWindowsProcessorGroups flag is off. Some processors might not be used.\", active_processor_groups);\n+        }\n+      } else {\n+        return processors_in_job_object;\n+      }\n+    } else {\n+      if (active_processor_groups > 1 && !win32::job_object_processor_group_warning_displayed()) {\n+        win32::set_job_object_processor_group_warning_displayed(true);\n+        warning(\"The Windows job object has enabled multiple processor groups (%d) but only 1 is supported on this Windows version. Some processors might not be used.\", active_processor_groups);\n+      }\n+      return processors_in_job_object;\n+    }\n+  }\n+\n+  DWORD logical_processors = 0;\n+  SYSTEM_INFO si;\n+  GetSystemInfo(&si);\n+\n+  USHORT group_count = 0;\n+  bool use_process_affinity_mask = false;\n+  bool got_process_group_affinity = false;\n+\n+  if (GetProcessGroupAffinity(GetCurrentProcess(), &group_count, nullptr) == 0) {\n+    DWORD last_error = GetLastError();\n+    if (last_error == ERROR_INSUFFICIENT_BUFFER) {\n+      if (group_count > 0) {\n+        got_process_group_affinity = true;\n+\n+        if (group_count == 1) {\n+          use_process_affinity_mask = true;\n+        }\n+      } else {\n+        warning(\"Unexpected group count of 0 from GetProcessGroupAffinity.\");\n+        assert(false, \"Group count must not be 0.\");\n+      }\n+    } else {\n+      char buf[512];\n+      size_t buf_len = os::lasterror(buf, sizeof(buf));\n+      warning(\"Attempt to get process group affinity failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n@@ -890,1 +942,0 @@\n-    return bitcount;\n@@ -892,1 +943,7 @@\n-    return proc_count;\n+    warning(\"Unexpected GetProcessGroupAffinity success result.\");\n+    assert(false, \"Unexpected GetProcessGroupAffinity success result\");\n+  }\n+\n+  \/\/ Fall back to SYSTEM_INFO.dwNumberOfProcessors if the process group affinity could not be determined.\n+  if (!got_process_group_affinity) {\n+    return si.dwNumberOfProcessors;\n@@ -894,0 +951,42 @@\n+\n+  \/\/ If the process it not in a job and the process group affinity is exactly 1 group\n+  \/\/ then get the number of available logical processors from the process affinity mask\n+  if (use_process_affinity_mask) {\n+    DWORD_PTR lpProcessAffinityMask = 0;\n+    DWORD_PTR lpSystemAffinityMask = 0;\n+    if (GetProcessAffinityMask(GetCurrentProcess(), &lpProcessAffinityMask, &lpSystemAffinityMask) != 0) {\n+      \/\/ Number of active processors is number of bits in process affinity mask\n+      logical_processors = population_count(lpProcessAffinityMask);\n+\n+      if (logical_processors > 0) {\n+        return logical_processors;\n+      } else {\n+        \/\/ We only check the process affinity mask if GetProcessGroupAffinity determined that there was\n+        \/\/ only 1 active group. In this case, GetProcessAffinityMask will not set the affinity mask to 0.\n+        warning(\"Unexpected process affinity mask of 0 from GetProcessAffinityMask.\");\n+        assert(false, \"Found unexpected process affinity mask: 0\");\n+      }\n+    } else {\n+      char buf[512];\n+      size_t buf_len = os::lasterror(buf, sizeof(buf));\n+      warning(\"Attempt to get the process affinity mask failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+    }\n+\n+    \/\/ Fall back to SYSTEM_INFO.dwNumberOfProcessors if the process affinity mask could not be determined.\n+    return si.dwNumberOfProcessors;\n+  }\n+\n+  if (UseAllWindowsProcessorGroups) {\n+    \/\/ There are no processor affinity restrictions at this point so we can return\n+    \/\/ the overall processor count if the OS automatically schedules threads across\n+    \/\/ all processors on the system. Note that older operating systems can\n+    \/\/ correctly report processor count but will not schedule threads across\n+    \/\/ processor groups unless the application explicitly uses group affinity APIs\n+    \/\/ to assign threads to processor groups. On these older operating systems, we\n+    \/\/ will continue to use the dwNumberOfProcessors field.\n+    if (schedules_all_processor_groups) {\n+      logical_processors = processor_count();\n+    }\n+  }\n+\n+  return logical_processors == 0 ? si.dwNumberOfProcessors : logical_processors;\n@@ -1767,4 +1866,0 @@\n-  VS_FIXEDFILEINFO *file_info;\n-  TCHAR kernel32_path[MAX_PATH];\n-  UINT len, ret;\n-\n@@ -1773,38 +1868,4 @@\n-  \/\/ Get the full path to \\Windows\\System32\\kernel32.dll and use that for\n-  \/\/ determining what version of Windows we're running on.\n-  len = MAX_PATH - (UINT)strlen(\"\\\\kernel32.dll\") - 1;\n-  ret = GetSystemDirectory(kernel32_path, len);\n-  if (ret == 0 || ret > len) {\n-    st->print_cr(\"Call to GetSystemDirectory failed\");\n-    return;\n-  }\n-  strncat(kernel32_path, \"\\\\kernel32.dll\", MAX_PATH - ret);\n-\n-  DWORD version_size = GetFileVersionInfoSize(kernel32_path, nullptr);\n-  if (version_size == 0) {\n-    st->print_cr(\"Call to GetFileVersionInfoSize failed\");\n-    return;\n-  }\n-\n-  LPTSTR version_info = (LPTSTR)os::malloc(version_size, mtInternal);\n-  if (version_info == nullptr) {\n-    st->print_cr(\"Failed to allocate version_info\");\n-    return;\n-  }\n-\n-  if (!GetFileVersionInfo(kernel32_path, 0, version_size, version_info)) {\n-    os::free(version_info);\n-    st->print_cr(\"Call to GetFileVersionInfo failed\");\n-    return;\n-  }\n-\n-  if (!VerQueryValue(version_info, TEXT(\"\\\\\"), (LPVOID*)&file_info, &len)) {\n-    os::free(version_info);\n-    st->print_cr(\"Call to VerQueryValue failed\");\n-    return;\n-  }\n-\n-  int major_version = HIWORD(file_info->dwProductVersionMS);\n-  int minor_version = LOWORD(file_info->dwProductVersionMS);\n-  int build_number = HIWORD(file_info->dwProductVersionLS);\n-  int build_minor = LOWORD(file_info->dwProductVersionLS);\n+  int major_version = windows_major_version();\n+  int minor_version = windows_minor_version();\n+  int build_number = windows_build_number();\n+  int build_minor = windows_build_minor();\n@@ -1812,1 +1873,0 @@\n-  os::free(version_info);\n@@ -1908,0 +1968,6 @@\n+\n+    \/\/ This is the number of logical processors in the current processor group only and is therefore\n+    \/\/ at most 64. The GetLogicalProcessorInformation function is used to compute the total number\n+    \/\/ of processors. However, it requires memory to be allocated for the processor information buffer.\n+    \/\/ Since this method is used in paths where memory allocation should not be done (i.e. after a crash),\n+    \/\/ only the number of processors in the current group will be returned.\n@@ -1937,1 +2003,1 @@\n-      st->print_cr(\"Processor Information for all %d processors :\", proc_count);\n+      st->print_cr(\"Processor Information for the first %d processors :\", proc_count);\n@@ -3979,0 +4045,155 @@\n+int    os::win32::_major_version             = 0;\n+int    os::win32::_minor_version             = 0;\n+int    os::win32::_build_number              = 0;\n+int    os::win32::_build_minor               = 0;\n+\n+bool   os::win32::_processor_group_warning_displayed = false;\n+bool   os::win32::_job_object_processor_group_warning_displayed = false;\n+\n+void os::win32::initialize_windows_version() {\n+  assert(_major_version == 0, \"windows version already initialized.\");\n+\n+  VS_FIXEDFILEINFO *file_info;\n+  TCHAR kernel32_path[MAX_PATH];\n+  UINT len, ret;\n+  char error_msg_buffer[512];\n+\n+  \/\/ Get the full path to \\Windows\\System32\\kernel32.dll and use that for\n+  \/\/ determining what version of Windows we're running on.\n+  len = MAX_PATH - (UINT)strlen(\"\\\\kernel32.dll\") - 1;\n+  ret = GetSystemDirectory(kernel32_path, len);\n+  if (ret == 0 || ret > len) {\n+    size_t buf_len = os::lasterror(error_msg_buffer, sizeof(error_msg_buffer));\n+    warning(\"Attempt to determine system directory failed: %s\", buf_len != 0 ? error_msg_buffer : \"<unknown error>\");\n+    return;\n+  }\n+  strncat(kernel32_path, \"\\\\kernel32.dll\", MAX_PATH - ret);\n+\n+  DWORD version_size = GetFileVersionInfoSize(kernel32_path, nullptr);\n+  if (version_size == 0) {\n+    size_t buf_len = os::lasterror(error_msg_buffer, sizeof(error_msg_buffer));\n+    warning(\"Failed to determine whether the OS can retrieve version information from kernel32.dll: %s\", buf_len != 0 ? error_msg_buffer : \"<unknown error>\");\n+    return;\n+  }\n+\n+  LPTSTR version_info = (LPTSTR)os::malloc(version_size, mtInternal);\n+  if (version_info == nullptr) {\n+    warning(\"os::malloc() failed to allocate %ld bytes for GetFileVersionInfo buffer\", version_size);\n+    return;\n+  }\n+\n+  if (GetFileVersionInfo(kernel32_path, 0, version_size, version_info) == 0) {\n+    os::free(version_info);\n+    size_t buf_len = os::lasterror(error_msg_buffer, sizeof(error_msg_buffer));\n+    warning(\"Attempt to retrieve version information from kernel32.dll failed: %s\", buf_len != 0 ? error_msg_buffer : \"<unknown error>\");\n+    return;\n+  }\n+\n+  if (VerQueryValue(version_info, TEXT(\"\\\\\"), (LPVOID*)&file_info, &len) == 0) {\n+    os::free(version_info);\n+    size_t buf_len = os::lasterror(error_msg_buffer, sizeof(error_msg_buffer));\n+    warning(\"Attempt to determine Windows version from kernel32.dll failed: %s\", buf_len != 0 ? error_msg_buffer : \"<unknown error>\");\n+    return;\n+  }\n+\n+  _major_version = HIWORD(file_info->dwProductVersionMS);\n+  _minor_version = LOWORD(file_info->dwProductVersionMS);\n+  _build_number  = HIWORD(file_info->dwProductVersionLS);\n+  _build_minor   = LOWORD(file_info->dwProductVersionLS);\n+\n+  os::free(version_info);\n+}\n+\n+bool os::win32::is_windows_11_or_greater() {\n+  if (IsWindowsServer()) {\n+    return false;\n+  }\n+\n+  \/\/ Windows 11 starts at build 22000 (Version 21H2)\n+  return (windows_major_version() == 10 && windows_build_number() >= 22000) || (windows_major_version() > 10);\n+}\n+\n+bool os::win32::is_windows_server_2022_or_greater() {\n+  if (!IsWindowsServer()) {\n+    return false;\n+  }\n+\n+  \/\/ Windows Server 2022 starts at build 20348.169\n+  return (windows_major_version() == 10 && windows_build_number() >= 20348) || (windows_major_version() > 10);\n+}\n+\n+DWORD os::win32::active_processors_in_job_object(DWORD* active_processor_groups) {\n+  if (active_processor_groups != nullptr) {\n+    *active_processor_groups = 0;\n+  }\n+  BOOL is_in_job_object = false;\n+  if (IsProcessInJob(GetCurrentProcess(), nullptr, &is_in_job_object) == 0) {\n+    char buf[512];\n+    size_t buf_len = os::lasterror(buf, sizeof(buf));\n+    warning(\"Attempt to determine whether the process is running in a job failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+    return 0;\n+  }\n+\n+  if (!is_in_job_object) {\n+    return 0;\n+  }\n+\n+  DWORD processors = 0;\n+\n+  LPVOID job_object_information = nullptr;\n+  DWORD job_object_information_length = 0;\n+\n+  if (QueryInformationJobObject(nullptr, JobObjectGroupInformationEx, nullptr, 0, &job_object_information_length) != 0) {\n+    warning(\"Unexpected QueryInformationJobObject success result.\");\n+    assert(false, \"Unexpected QueryInformationJobObject success result\");\n+    return 0;\n+  }\n+\n+  DWORD last_error = GetLastError();\n+  if (last_error == ERROR_INSUFFICIENT_BUFFER) {\n+    DWORD group_count = job_object_information_length \/ sizeof(GROUP_AFFINITY);\n+\n+    job_object_information = os::malloc(job_object_information_length, mtInternal);\n+    if (job_object_information != nullptr) {\n+        if (QueryInformationJobObject(nullptr, JobObjectGroupInformationEx, job_object_information, job_object_information_length, &job_object_information_length) != 0) {\n+          DWORD groups_found = job_object_information_length \/ sizeof(GROUP_AFFINITY);\n+          if (groups_found != group_count) {\n+            warning(\"Unexpected processor group count: %ld. Expected %ld processor groups.\", groups_found, group_count);\n+            assert(false, \"Unexpected group count\");\n+          }\n+\n+          GROUP_AFFINITY* group_affinity_data = ((GROUP_AFFINITY*)job_object_information);\n+          for (DWORD i = 0; i < groups_found; i++, group_affinity_data++) {\n+            DWORD processors_in_group = population_count(group_affinity_data->Mask);\n+            processors += processors_in_group;\n+            if (active_processor_groups != nullptr && processors_in_group > 0) {\n+              (*active_processor_groups)++;\n+            }\n+          }\n+\n+          if (processors == 0) {\n+            warning(\"Could not determine processor count from the job object.\");\n+            assert(false, \"Must find at least 1 logical processor\");\n+          }\n+        } else {\n+          char buf[512];\n+          size_t buf_len = os::lasterror(buf, sizeof(buf));\n+          warning(\"Attempt to query job object information failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+        }\n+\n+        os::free(job_object_information);\n+    } else {\n+        warning(\"os::malloc() failed to allocate %ld bytes for QueryInformationJobObject\", job_object_information_length);\n+    }\n+  } else {\n+    char buf[512];\n+    size_t buf_len = os::lasterror(buf, sizeof(buf));\n+    warning(\"Attempt to query job object information failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+    assert(false, \"Unexpected QueryInformationJobObject error code\");\n+    return 0;\n+  }\n+\n+  log_debug(os)(\"Process is running in a job with %d active processors.\", processors);\n+  return processors;\n+}\n+\n@@ -3986,1 +4207,14 @@\n-  set_processor_count(si.dwNumberOfProcessors);\n+\n+  DWORD processors = 0;\n+  bool schedules_all_processor_groups = win32::is_windows_11_or_greater() || win32::is_windows_server_2022_or_greater();\n+  if (schedules_all_processor_groups) {\n+    processors = GetActiveProcessorCount(ALL_PROCESSOR_GROUPS);\n+    if (processors == 0) {\n+      char buf[512];\n+      size_t buf_len = os::lasterror(buf, sizeof(buf));\n+      warning(\"Attempt to determine the processor count from GetActiveProcessorCount() failed: %s\", buf_len != 0 ? buf : \"<unknown error>\");\n+      assert(false, \"Must find at least 1 logical processor\");\n+    }\n+  }\n+\n+  set_processor_count(processors > 0 ? processors : si.dwNumberOfProcessors);\n@@ -4295,0 +4529,1 @@\n+  win32::initialize_windows_version();\n@@ -4341,0 +4576,6 @@\n+  const char* auto_schedules_message = \"Host Windows OS automatically schedules threads across all processor groups.\";\n+  const char* no_auto_schedules_message = \"Host Windows OS does not automatically schedule threads across all processor groups.\";\n+\n+  bool schedules_all_processor_groups = win32::is_windows_11_or_greater() || win32::is_windows_server_2022_or_greater();\n+  log_debug(os)(schedules_all_processor_groups ? auto_schedules_message : no_auto_schedules_message);\n+  log_debug(os)(\"%d logical processors found.\", processor_count());\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":298,"deletions":57,"binary":false,"changes":355,"status":"modified"},{"patch":"@@ -46,0 +46,7 @@\n+  static bool   _processor_group_warning_displayed;\n+  static bool   _job_object_processor_group_warning_displayed;\n+\n+  static int    _major_version;\n+  static int    _minor_version;\n+  static int    _build_number;\n+  static int    _build_minor;\n@@ -59,0 +66,31 @@\n+  static bool   is_windows_11_or_greater();\n+  static bool   is_windows_server_2022_or_greater();\n+  static int windows_major_version() {\n+    assert(_major_version > 0, \"windows version not initialized.\");\n+    return _major_version;\n+  }\n+  static int windows_minor_version() {\n+    assert(_major_version > 0, \"windows version not initialized.\");\n+    return _minor_version;\n+  }\n+  static int windows_build_number() {\n+    assert(_major_version > 0, \"windows version not initialized.\");\n+    return _build_number;\n+  }\n+  static int windows_build_minor() {\n+    assert(_major_version > 0, \"windows version not initialized.\");\n+    return _build_minor;\n+  }\n+\n+  static void set_processor_group_warning_displayed(bool displayed)  {\n+    _processor_group_warning_displayed = displayed;\n+  }\n+  static bool processor_group_warning_displayed() {\n+    return _processor_group_warning_displayed;\n+  }\n+  static void set_job_object_processor_group_warning_displayed(bool displayed)  {\n+    _job_object_processor_group_warning_displayed = displayed;\n+  }\n+  static bool job_object_processor_group_warning_displayed() {\n+    return _job_object_processor_group_warning_displayed;\n+  }\n@@ -82,0 +120,2 @@\n+  static void initialize_windows_version();\n+  static DWORD active_processors_in_job_object(DWORD* active_processor_groups = nullptr);\n","filename":"src\/hotspot\/os\/windows\/os_windows.hpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -706,0 +706,19 @@\n+TEST_VM(os_windows, processor_count) {\n+  JVMFlag* flag = JVMFlag::find_flag(\"UseAllWindowsProcessorGroups\");\n+  EXPECT_NE(flag, nullptr) << \"Expected UseAllWindowsProcessorGroups product flag to be available\";\n+\n+  int processors = os::processor_count();\n+  EXPECT_GT(processors, 0) << \"Expected at least 1 processor\";\n+\n+  int active_processors = os::active_processor_count();\n+  EXPECT_GT(active_processors, 0) << \"Expected at least 1 active processor\";\n+\n+  bool schedules_all_processor_groups = os::win32::is_windows_11_or_greater() || os::win32::is_windows_server_2022_or_greater();\n+  if (schedules_all_processor_groups && UseAllWindowsProcessorGroups) {\n+    EXPECT_EQ(active_processors, processors) << \"Expected all processors to be active\";\n+  } else {\n+    \/\/ active_processors should be at most the number of processors in 1 Windows processor group.\n+    EXPECT_LE(active_processors, processors) << \"Expected active processors to not exceed available processors\";\n+  }\n+}\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_windows.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -155,0 +155,1 @@\n+  gtest\/WindowsProcessorGroups.java\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * This runs the os related gtests on Windows with all processor groups enabled.\n+ *\/\n+\n+\/* @test id=use-all-windows-processor-groups\n+ * @summary Run gtests with all Windows processor groups enabled\n+ * @library \/test\/lib\n+ * @requires os.family == \"windows\"\n+ * @run main\/native GTestWrapper --gtest_filter=os* -XX:+UseAllWindowsProcessorGroups\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/WindowsProcessorGroups.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+public class GetAvailableProcessors {\n+  public static void main(String[] args) {\n+    System.out.println(\"Runtime.availableProcessors: \" + Runtime.getRuntime().availableProcessors());\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/windows\/GetAvailableProcessors.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6942632\n+ * @requires os.family == \"windows\"\n+ * @summary This test verifies that OpenJDK can use all available\n+ *          processors on Windows 11\/Windows Server 2022 and later.\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @compile GetAvailableProcessors.java\n+ * @run testng TestAvailableProcessors\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+public class TestAvailableProcessors {\n+\n+    private static final String totalProcessorCountMessage = \"Active processor count across all processor groups: \";\n+    private static final String processorCountPerGroupMessage = \"Active processors per group: \";\n+    private static final String isWindowsServerMessage = \"IsWindowsServer: \";\n+\n+    private static final String runtimeAvailableProcessorsMessage = \"Runtime.availableProcessors: \";\n+    private static final String osVersionMessage = \"OS Version: \";\n+    private static final String unsupportedPlatformMessage = \"The UseAllWindowsProcessorGroups flag is not supported on this Windows version and will be ignored.\";\n+\n+    private static String getWindowsVersion() throws IOException {\n+        String systeminfoPath = \"systeminfo.exe\";\n+\n+        var processBuilder = new ProcessBuilder(systeminfoPath);\n+        OutputAnalyzer outputAnalyzer = new OutputAnalyzer(processBuilder.start());\n+        outputAnalyzer.shouldHaveExitValue(0);\n+        outputAnalyzer.shouldContain(osVersionMessage);\n+        List<String> lines = outputAnalyzer.stdoutAsLines();\n+\n+        String osVersion = null;\n+        for (var line: lines) {\n+            if (line.startsWith(osVersionMessage)) {\n+                osVersion = line.substring(osVersionMessage.length()).trim();\n+                break;\n+            }\n+        }\n+\n+        System.out.println(\"Found OS version: \" + osVersion);\n+        return osVersion;\n+    }\n+\n+    private static boolean getSchedulesAllProcessorGroups(boolean isWindowsServer) throws IOException {\n+        String windowsVer = getWindowsVersion();\n+        String[] parts = windowsVer.split(\" \");\n+        String[] versionParts = parts[0].split(\"\\\\.\");\n+\n+        if (versionParts.length != 3) {\n+            throw new RuntimeException(\"Unexpected Windows version format.\");\n+        }\n+\n+        int major = Integer.parseInt(versionParts[0]);\n+        int minor = Integer.parseInt(versionParts[1]);\n+        int build = Integer.parseInt(versionParts[2]);\n+\n+        if (major > 10) {\n+            return true;\n+        }\n+\n+        if (major < 10) {\n+            return false;\n+        }\n+\n+        if (minor > 0) {\n+            return true;\n+        }\n+\n+        if (isWindowsServer) {\n+            return build >= 20348;\n+        } else {\n+            return build >= 22000;\n+        }\n+    }\n+\n+    private static OutputAnalyzer getAvailableProcessorsOutput(boolean productFlagEnabled) throws IOException {\n+        String productFlag = productFlagEnabled ? \"-XX:+UseAllWindowsProcessorGroups\" : \"-XX:-UseAllWindowsProcessorGroups\";\n+\n+        ProcessBuilder processBuilder = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            new String[] {productFlag, \"GetAvailableProcessors\"}\n+        );\n+\n+        var output = new OutputAnalyzer(processBuilder.start());\n+        output.shouldHaveExitValue(0);\n+        output.shouldContain(runtimeAvailableProcessorsMessage);\n+\n+        return output;\n+    }\n+\n+    private static int getAvailableProcessors(OutputAnalyzer outputAnalyzer) {\n+        int runtimeAvailableProcs = 0;\n+        List<String> output = outputAnalyzer.stdoutAsLines();\n+\n+        for (var line: output) {\n+            if (line.startsWith(runtimeAvailableProcessorsMessage)) {\n+                String runtimeAvailableProcsStr = line.substring(runtimeAvailableProcessorsMessage.length());\n+                runtimeAvailableProcs = Integer.parseInt(runtimeAvailableProcsStr);\n+            }\n+        }\n+\n+        return runtimeAvailableProcs;\n+    }\n+\n+    private static int getAvailableProcessors(boolean productFlagEnabled) throws IOException {\n+        OutputAnalyzer outputAnalyzer = getAvailableProcessorsOutput(productFlagEnabled);\n+        return getAvailableProcessors(outputAnalyzer);\n+    }\n+\n+    private static void verifyAvailableProcessorsWithDisabledProductFlag(Set<Integer> processorGroupSizes) throws IOException {\n+        boolean productFlagEnabled = false;\n+        int runtimeAvailableProcs = getAvailableProcessors(productFlagEnabled);\n+\n+        String error = String.format(\"Runtime.availableProcessors (%d) is not a valid processor group size on this machine.\", runtimeAvailableProcs);\n+        Assert.assertTrue(processorGroupSizes.contains(runtimeAvailableProcs), error);\n+    }\n+\n+    private static void verifyAvailableProcessorsWithEnabledProductFlag(boolean schedulesAllProcessorGroups, int totalProcessorCount, Set<Integer> processorGroupSizes) throws IOException {\n+        boolean productFlagEnabled = true;\n+\n+        OutputAnalyzer outputAnalyzer = getAvailableProcessorsOutput(productFlagEnabled);\n+        int runtimeAvailableProcs = getAvailableProcessors(outputAnalyzer);\n+\n+        if (schedulesAllProcessorGroups) {\n+            String error = String.format(\"Runtime.availableProcessors (%d) is not equal to the expected total processor count (%d)\", runtimeAvailableProcs, totalProcessorCount);\n+            Assert.assertEquals(runtimeAvailableProcs, totalProcessorCount, error);\n+        } else {\n+            outputAnalyzer.shouldContain(unsupportedPlatformMessage);\n+\n+            String error = String.format(\"Runtime.availableProcessors (%d) is not a valid processor group size on this machine.\", runtimeAvailableProcs);\n+            Assert.assertTrue(processorGroupSizes.contains(runtimeAvailableProcs), error);\n+        }\n+    }\n+\n+    @Test\n+    private static void testProcessorAvailability() throws IOException {\n+        \/\/ Launch GetProcessorInfo.exe to gather processor counts\n+        Path nativeGetProcessorInfo = Paths.get(Utils.TEST_NATIVE_PATH)\n+            .resolve(\"GetProcessorInfo.exe\")\n+            .toAbsolutePath();\n+\n+        var processBuilder = new ProcessBuilder(nativeGetProcessorInfo.toString());\n+        var outputAnalyzer= new OutputAnalyzer(processBuilder.start());\n+        outputAnalyzer.shouldHaveExitValue(0);\n+        outputAnalyzer.shouldContain(totalProcessorCountMessage);\n+        outputAnalyzer.shouldContain(processorCountPerGroupMessage);\n+        outputAnalyzer.shouldContain(isWindowsServerMessage);\n+\n+        int totalProcessorCount = 0;\n+        boolean isWindowsServer = false;\n+        var processorGroupSizes = new HashSet<Integer>();\n+\n+        List<String> lines = outputAnalyzer.stdoutAsLines();\n+\n+        for (var line: lines) {\n+            if (line.startsWith(totalProcessorCountMessage)) {\n+                String totalProcessorCountStr = line.substring(totalProcessorCountMessage.length());\n+                totalProcessorCount = Integer.parseInt(totalProcessorCountStr);\n+            } else if (line.startsWith(processorCountPerGroupMessage)) {\n+                String processorCountPerGroupStr = line.substring(processorCountPerGroupMessage.length());\n+                String[] processorCountsPerGroup = processorCountPerGroupStr.split(\",\");\n+\n+                for (var processorCountStr: processorCountsPerGroup) {\n+                    int processorCount = Integer.parseInt(processorCountStr);\n+                    processorGroupSizes.add(processorCount);\n+                }\n+            } else if (line.startsWith(isWindowsServerMessage)) {\n+                String isWindowsServerStr = line.substring(isWindowsServerMessage.length());\n+                isWindowsServer = Integer.parseInt(isWindowsServerStr) > 0;\n+            }\n+        }\n+\n+        \/\/ Launch java without the start command and with the product flag disabled\n+        verifyAvailableProcessorsWithDisabledProductFlag(processorGroupSizes);\n+\n+        \/\/ Launch java without the start command and with the product flag enabled\n+        boolean schedulesAllProcessorGroups = getSchedulesAllProcessorGroups(isWindowsServer);\n+        verifyAvailableProcessorsWithEnabledProductFlag(schedulesAllProcessorGroups, totalProcessorCount, processorGroupSizes);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/windows\/TestAvailableProcessors.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <Windows.h>\n+#include <malloc.h>\n+#include <versionhelpers.h>\n+#include <stdio.h>\n+\n+int main()\n+{\n+  DWORD active_processor_count = GetActiveProcessorCount(ALL_PROCESSOR_GROUPS);\n+  if (active_processor_count == 0) {\n+    printf(\"GetActiveProcessorCount failed with error: %x\\n\", GetLastError());\n+    return 1;\n+  }\n+\n+  printf(\"IsWindowsServer: %d\\n\", IsWindowsServer() ? 1 : 0);\n+  printf(\"Active processor count across all processor groups: %d\\n\", active_processor_count);\n+\n+  USHORT group_count = 0;\n+\n+  if (GetProcessGroupAffinity(GetCurrentProcess(), &group_count, NULL) == 0) {\n+    DWORD last_error = GetLastError();\n+    if (last_error == ERROR_INSUFFICIENT_BUFFER) {\n+      if (group_count == 0) {\n+        printf(\"Unexpected group count of 0 from GetProcessGroupAffinity.\\n\");\n+        return 1;\n+      }\n+    } else {\n+      printf(\"GetActiveProcessorCount failed with error: %x\\n\", GetLastError());\n+      return 1;\n+    }\n+  } else {\n+    printf(\"Unexpected GetProcessGroupAffinity success result.\\n\");\n+    return 1;\n+  }\n+\n+  PUSHORT group_array = (PUSHORT)malloc(group_count * sizeof(USHORT));\n+  if (group_array == NULL) {\n+    printf(\"malloc failed.\\n\");\n+    return 1;\n+  }\n+\n+  printf(\"Active processors per group: \");\n+  for (USHORT i=0; i < group_count; i++) {\n+    DWORD active_processors_in_group = GetActiveProcessorCount(i);\n+    if (active_processors_in_group == 0) {\n+      printf(\"GetActiveProcessorCount(%d) failed with error: %x\\n\", i, GetLastError());\n+      return 1;\n+    }\n+\n+    printf(\"%d,\", active_processors_in_group);\n+  }\n+\n+  free(group_array);\n+  return 0;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/windows\/exeGetProcessorInfo.c","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"}]}