{"files":[{"patch":"@@ -280,0 +280,34 @@\n+    \/**\n+     * Repeatedly invokes acquire, if its execution throws an Error or a Runtime Exception,\n+     * using an Unsafe.park-based backoff\n+     * @param node which to reacquire\n+     * @param arg the acquire argument\n+     *\/\n+    private final void reacquire(Node node, long arg) {\n+        try {\n+            acquire(node, arg, false, false, false, 0L);\n+        } catch (Error | RuntimeException firstEx) {\n+            \/\/ While we currently do not emit an JFR events in this situation, mainly\n+            \/\/ because the conditions under which this happens are such that it\n+            \/\/ cannot be presumed to be possible to actually allocate an event, and\n+            \/\/ using a preconstructed one would have limited value in serviceability.\n+            \/\/ Having said that, the following place would be the more appropriate\n+            \/\/ place to put such logic:\n+            \/\/     emit JFR event\n+\n+            for (long nanos = 1L;;) {\n+                U.park(false, nanos); \/\/ must use Unsafe park to sleep\n+                if (nanos < 1L << 30)            \/\/ max about 1 second\n+                    nanos <<= 1;\n+\n+                try {\n+                    acquire(node, arg, false, false, false, 0L);\n+                } catch (Error | RuntimeException ignored) {\n+                    continue;\n+                }\n+\n+                throw firstEx;\n+            }\n+        }\n+    }\n+\n@@ -1297,1 +1331,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1344,1 +1378,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1387,1 +1421,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1431,1 +1465,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1476,1 +1510,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/AbstractQueuedLongSynchronizer.java","additions":39,"deletions":5,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -659,0 +659,34 @@\n+    \/**\n+     * Repeatedly invokes acquire, if its execution throws an Error or a Runtime Exception,\n+     * using an Unsafe.park-based backoff\n+     * @param node which to reacquire\n+     * @param arg the acquire argument\n+     *\/\n+    private final void reacquire(Node node, int arg) {\n+        try {\n+            acquire(node, arg, false, false, false, 0L);\n+        } catch (Error | RuntimeException firstEx) {\n+            \/\/ While we currently do not emit an JFR events in this situation, mainly\n+            \/\/ because the conditions under which this happens are such that it\n+            \/\/ cannot be presumed to be possible to actually allocate an event, and\n+            \/\/ using a preconstructed one would have limited value in serviceability.\n+            \/\/ Having said that, the following place would be the more appropriate\n+            \/\/ place to put such logic:\n+            \/\/     emit JFR event\n+\n+            for (long nanos = 1L;;) {\n+                U.park(false, nanos); \/\/ must use Unsafe park to sleep\n+                if (nanos < 1L << 30)            \/\/ max about 1 second\n+                    nanos <<= 1;\n+\n+                try {\n+                    acquire(node, arg, false, false, false, 0L);\n+                } catch (Error | RuntimeException ignored) {\n+                    continue;\n+                }\n+\n+                throw firstEx;\n+            }\n+        }\n+    }\n+\n@@ -1676,1 +1710,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1723,1 +1757,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1766,1 +1800,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1810,1 +1844,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1855,1 +1889,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/AbstractQueuedSynchronizer.java","additions":39,"deletions":5,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.util.function.Supplier;\n@@ -42,0 +43,3 @@\n+    private static final String KO_OVERFLOW = \"Some records have not been disposed!\";\n+    private static final String KO_UNDERFLOW = \"Disposed more records than were added!\";\n+\n@@ -43,2 +47,1 @@\n-        TestDisposerRace test = new TestDisposerRace();\n-        test.run();\n+        new TestDisposerRace().run();\n@@ -48,0 +51,1 @@\n+            System.err.println(KO_OVERFLOW); \/\/ In case the next line fails to allocate due to OOME\n@@ -52,0 +56,4 @@\n+    interface ThrowingRunnable<E extends Exception> {\n+        void run() throws E;\n+    }\n+\n@@ -59,3 +67,4 @@\n-            SwingUtilities.invokeAndWait(Disposer::pollRemove);\n-            if (i % 10 == 0) {\n-                \/\/ Adding records will race with the diposer trying to remove them\n+            retryOnOOME(() -> SwingUtilities.invokeAndWait(Disposer::pollRemove));\n+\n+            \/\/ Adding records will race with the diposer trying to remove them\n+            if (i % 10 == 0)\n@@ -63,1 +72,0 @@\n-            }\n@@ -66,1 +74,1 @@\n-        Disposer.addObjectRecord(new Object(), new FinalDisposerRecord());\n+        retryOnOOME(() -> Disposer.addObjectRecord(new Object(), new FinalDisposerRecord()));\n@@ -75,1 +83,26 @@\n-            throw new RuntimeException(\"Disposed more records than were added\");\n+            throw new RuntimeException(KO_UNDERFLOW);\n+        }\n+    }\n+\n+    private static <T> T retryOnOOME(Supplier<T> allocator) {\n+        for(;;) {\n+            try {\n+                return allocator.get();\n+            } catch (OutOfMemoryError ignored1) {\n+                try {\n+                    Thread.sleep(1); \/\/ Give GC a little chance to run\n+                } catch (InterruptedException ignored2) {}\n+            }\n+        }\n+    }\n+\n+    private static <E extends Exception> void retryOnOOME(ThrowingRunnable<E> tr) throws E {\n+        for(;;) {\n+            try {\n+                tr.run();\n+                break;\n+            } catch (OutOfMemoryError ignored1) {\n+                try {\n+                    Thread.sleep(1); \/\/ Give GC a little chance to run\n+                } catch (InterruptedException ignored2) {}\n+            }\n@@ -82,1 +115,1 @@\n-        recordsCount.addAndGet(count);\n+        MyDisposerRecord disposerRecord = retryOnOOME(MyDisposerRecord::new);\n@@ -84,3 +117,5 @@\n-        MyDisposerRecord disposerRecord = new MyDisposerRecord();\n-        for (int i = 0; i < count; i++) {\n-            Disposer.addObjectRecord(new Object(), disposerRecord);\n+        while(count > 0) {\n+            recordsCount.incrementAndGet(); \/\/ pre-add to make sure it doesn't go negative\n+            var o = retryOnOOME(Object::new);\n+            retryOnOOME(() -> Disposer.addObjectRecord(o, disposerRecord));\n+            --count;\n@@ -109,1 +144,0 @@\n-        final List<Object> leak = new LinkedList<>();\n@@ -111,0 +145,1 @@\n+            final List<Object> leak = new LinkedList<>();\n","filename":"test\/jdk\/sun\/java2d\/Disposer\/TestDisposerRace.java","additions":48,"deletions":13,"binary":false,"changes":61,"status":"modified"}]}