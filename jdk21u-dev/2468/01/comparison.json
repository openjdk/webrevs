{"files":[{"patch":"@@ -1684,1 +1684,1 @@\n-        if (isParseIntegerOnly()\n+        if (isParseIntegerOnly() && position < text.length()\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2004, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333456\n+ * @summary Make sure that CompactNumberFormat integer parsing doesn't fail\n+ * when there is no suffix.\n+ * @run junit Bug8333456\n+ *\/\n+import java.text.CompactNumberFormat;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.EnabledIfSystemProperty;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+public class Bug8333456 {\n+\n+    private static final CompactNumberFormat cmpctFmt =\n+            (CompactNumberFormat) NumberFormat.getCompactNumberInstance(Locale.US,\n+                    NumberFormat.Style.SHORT);\n+\n+    \/\/ No compact suffixes\n+    private static final Stream<Arguments> compactValidNoSuffixParseStrings() {\n+        return Stream.of(\n+            Arguments.of(\"5\", 5),\n+            Arguments.of(\"50\", 50),\n+            Arguments.of(\"50.\", 50),\n+            Arguments.of(\"5,000\", 5000),\n+            Arguments.of(\"5,000.\", 5000),\n+            Arguments.of(\"5,000.00\", 5000)\n+        );\n+    }\n+                    \n+    \/\/ 8333456: Parse values with no compact suffix -> which allows parsing to iterate\n+    \/\/ position to the same value as string length which throws\n+    \/\/ StringIndexOutOfBoundsException upon charAt invocation\n+    @ParameterizedTest\n+    @MethodSource(\"compactValidNoSuffixParseStrings\")\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtSuccessParseIntOnlyTest(String toParse, double expectedValue) {\n+        cmpctFmt.setParseIntegerOnly(true);\n+        cmpctFmt.setGroupingUsed(true);\n+        assertEquals(expectedValue, successParse(cmpctFmt, toParse, toParse.length()));\n+        cmpctFmt.setParseIntegerOnly(false);\n+    }\n+    \n+    \/\/ Method is used when a String should parse successfully. This does not indicate\n+    \/\/ that the entire String was used, however. The index and errorIndex values\n+    \/\/ should be as expected.\n+    private double successParse(NumberFormat fmt, String toParse, int expectedIndex) {\n+        Number parsedValue = assertDoesNotThrow(() -> fmt.parse(toParse));\n+        ParsePosition pp = new ParsePosition(0);\n+        assertDoesNotThrow(() -> fmt.parse(toParse, pp));\n+        assertEquals(-1, pp.getErrorIndex(),\n+                \"ParsePosition ErrorIndex is not in correct location\");\n+        assertEquals(expectedIndex, pp.getIndex(),\n+                \"ParsePosition Index is not in correct location\");\n+        return parsedValue.doubleValue();\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug8333456.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"}]}