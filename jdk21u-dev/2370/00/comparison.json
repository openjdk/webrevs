{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import java.net.*;\n@@ -32,3 +31,0 @@\n-import com.sun.net.httpserver.*;\n-import com.sun.net.httpserver.spi.*;\n-\n@@ -156,1 +152,1 @@\n-        WriteFinishedEvent e = new WriteFinishedEvent (t);\n+        Event e = new Event.WriteFinished(t);\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ChunkedOutputStream.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n-import com.sun.net.httpserver.*;\n-import com.sun.net.httpserver.spi.*;\n+import java.util.Objects;\n@@ -31,1 +30,1 @@\n-class Event {\n+abstract sealed class Event {\n@@ -33,1 +32,1 @@\n-    ExchangeImpl exchange;\n+    final ExchangeImpl exchange;\n@@ -35,1 +34,1 @@\n-    protected Event (ExchangeImpl t) {\n+    protected Event(ExchangeImpl t) {\n@@ -38,0 +37,22 @@\n+\n+    \/**\n+     * Stopping event for the http server.\n+     * The event applies to the whole server and is not tied to any particular\n+     * exchange.\n+     *\/\n+    static final class StopRequested extends Event {\n+        StopRequested() {\n+            super(null);\n+        }\n+    }\n+\n+    \/**\n+     * Event indicating that writing is finished for a given exchange.\n+     *\/\n+    static final class WriteFinished extends Event {\n+        WriteFinished(ExchangeImpl t) {\n+            super(Objects.requireNonNull(t));\n+            assert !t.writefinished;\n+            t.writefinished = true;\n+        }\n+    }\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/Event.java","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.net.*;\n@@ -32,3 +31,0 @@\n-import com.sun.net.httpserver.*;\n-import com.sun.net.httpserver.spi.*;\n-\n@@ -101,1 +97,1 @@\n-        WriteFinishedEvent e = new WriteFinishedEvent (t);\n+        Event e = new Event.WriteFinished(t);\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/FixedLengthOutputStream.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,0 +64,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -65,0 +66,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -97,1 +99,1 @@\n-    private volatile boolean finished = false;\n+    private final CountDownLatch finishedLatch = new CountDownLatch(1);\n@@ -183,1 +185,1 @@\n-        if (!bound || started || finished) {\n+        if (!bound || started || finished()) {\n@@ -226,0 +228,5 @@\n+    private final boolean finished(){\n+        \/\/ if the latch is 0, the server is finished\n+        return finishedLatch.getCount() == 0;\n+    }\n+\n@@ -227,1 +234,1 @@\n-        return finished;\n+        return finished();\n@@ -230,0 +237,9 @@\n+    \/**\n+     * This method stops the server by adding a stop request event and\n+     * waiting for the server until the event is triggered or until the maximum delay is triggered.\n+     * <p>\n+     * This ensures that the server is stopped immediately after all exchanges are complete. HttpConnections will be forcefully closed if active exchanges do not\n+     * complete within the imparted delay.\n+     *\n+     * @param delay maximum delay to wait for exchanges completion, in seconds\n+     *\/\n@@ -234,0 +250,4 @@\n+\n+        logger.log(Level.TRACE, \"stopping\");\n+        \/\/ posting a stop event, which will flip finished flag if it finishes\n+        \/\/ before the timeout in this method\n@@ -235,0 +255,3 @@\n+\n+        addEvent(new Event.StopRequested());\n+\n@@ -237,5 +260,17 @@\n-        long latest = System.currentTimeMillis() + delay * 1000;\n-        while (System.currentTimeMillis() < latest) {\n-            delay();\n-            if (finished) {\n-                break;\n+\n+        try {\n+            \/\/ waiting for the duration of the delay, unless released before\n+            finishedLatch.await(delay, TimeUnit.SECONDS);\n+\n+        } catch (InterruptedException e) {\n+            logger.log(Level.TRACE, \"Error in awaiting the delay\");\n+\n+        } finally {\n+\n+            logger.log(Level.TRACE, \"closing connections\");\n+            finishedLatch.countDown();\n+            selector.wakeup();\n+            synchronized (allConnections) {\n+                for (HttpConnection c : allConnections) {\n+                    c.close();\n+                }\n@@ -243,6 +278,6 @@\n-        }\n-        finished = true;\n-        selector.wakeup();\n-        synchronized (allConnections) {\n-            for (HttpConnection c : allConnections) {\n-                c.close();\n+            allConnections.clear();\n+            idleConnections.clear();\n+            newlyAcceptedConnections.clear();\n+            timer.cancel();\n+            if (reqRspTimeoutEnabled) {\n+                timer1.cancel();\n@@ -250,14 +285,10 @@\n-        }\n-        allConnections.clear();\n-        idleConnections.clear();\n-        newlyAcceptedConnections.clear();\n-        timer.cancel();\n-        if (reqRspTimeoutEnabled) {\n-            timer1.cancel();\n-        }\n-        if (dispatcherThread != null && dispatcherThread != Thread.currentThread()) {\n-            try {\n-                dispatcherThread.join();\n-            } catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-                logger.log (Level.TRACE, \"ServerImpl.stop: \", e);\n+            logger.log(Level.TRACE, \"connections closed\");\n+\n+            if (dispatcherThread != null && dispatcherThread != Thread.currentThread()) {\n+                logger.log(Level.TRACE, \"waiting for dispatcher thread\");\n+                try {\n+                    dispatcherThread.join();\n+                } catch (InterruptedException e) {\n+                    Thread.currentThread().interrupt();\n+                    logger.log(Level.TRACE, \"ServerImpl.stop: \", e);\n+                }\n@@ -265,0 +296,1 @@\n+            logger.log(Level.TRACE, \"server stopped\");\n@@ -394,0 +426,18 @@\n+\n+            \/\/ Stopping marking the state as finished if stop is requested,\n+            \/\/ termination is in progress and exchange count is 0\n+            if (r instanceof Event.StopRequested) {\n+                logger.log(Level.TRACE, \"Handling Stop Requested Event\");\n+\n+                \/\/ checking if terminating is set to true\n+                final boolean terminatingCopy = terminating;\n+                assert terminatingCopy;\n+\n+                if (getExchangeCount() == 0 && reqConnections.isEmpty()) {\n+                    finishedLatch.countDown();\n+                } else {\n+                    logger.log(Level.TRACE, \"Some requests are still pending\");\n+                }\n+                return;\n+            }\n+\n@@ -396,0 +446,1 @@\n+\n@@ -397,1 +448,1 @@\n-                if (r instanceof WriteFinishedEvent) {\n+                if (r instanceof Event.WriteFinished) {\n@@ -401,2 +452,2 @@\n-                    if (terminating && exchanges == 0) {\n-                        finished = true;\n+                    if (terminating && exchanges == 0 && reqConnections.isEmpty()) {\n+                        finishedLatch.countDown();\n@@ -452,1 +503,2 @@\n-            while (!finished) {\n+            \/\/ finished() will be true when there are no active exchange after terminating\n+             while (!finished()) {\n@@ -456,1 +508,1 @@\n-                        if (events.size() > 0) {\n+                        if (!events.isEmpty()) {\n@@ -603,12 +655,12 @@\n-        case REQUEST:\n-            reqConnections.remove(conn);\n-            break;\n-        case RESPONSE:\n-            rspConnections.remove(conn);\n-            break;\n-        case IDLE:\n-            idleConnections.remove(conn);\n-            break;\n-        case NEWLY_ACCEPTED:\n-            newlyAcceptedConnections.remove(conn);\n-            break;\n+            case REQUEST:\n+                reqConnections.remove(conn);\n+                break;\n+            case RESPONSE:\n+                rspConnections.remove(conn);\n+                break;\n+            case IDLE:\n+                idleConnections.remove(conn);\n+                break;\n+            case NEWLY_ACCEPTED:\n+                newlyAcceptedConnections.remove(conn);\n+                break;\n@@ -936,7 +988,0 @@\n-    void delay () {\n-        Thread.yield();\n-        try {\n-            Thread.sleep (200);\n-        } catch (InterruptedException e) {}\n-    }\n-\n@@ -949,0 +994,4 @@\n+    synchronized int getExchangeCount() {\n+        return exchangeCount;\n+    }\n+\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/ServerImpl.java","additions":102,"deletions":53,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.net.*;\n@@ -32,3 +31,0 @@\n-import com.sun.net.httpserver.*;\n-import com.sun.net.httpserver.spi.*;\n-\n@@ -82,1 +78,1 @@\n-        WriteFinishedEvent e = new WriteFinishedEvent (t);\n+        Event e = new Event.WriteFinished(t);\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/UndefLengthOutputStream.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.net.httpserver;\n-\n-class WriteFinishedEvent extends Event {\n-    WriteFinishedEvent (ExchangeImpl t) {\n-        super (t);\n-        assert !t.writefinished;\n-        t.writefinished = true;\n-    }\n-}\n","filename":"src\/jdk.httpserver\/share\/classes\/sun\/net\/httpserver\/WriteFinishedEvent.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"}]}