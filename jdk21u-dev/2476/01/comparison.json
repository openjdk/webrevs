{"files":[{"patch":"@@ -3553,2 +3553,17 @@\n-  \/\/ MAP_FIXED is intentionally left out, to leave existing mappings intact.\n-  const int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;\n+  \/\/ If a requested address was given:\n+  \/\/\n+  \/\/ The POSIX-conforming way is to *omit* MAP_FIXED. This will leave existing mappings intact.\n+  \/\/ If the requested mapping area is blocked by a pre-existing mapping, the kernel will map\n+  \/\/ somewhere else. On Linux, that alternative address appears to have no relation to the\n+  \/\/ requested address.\n+  \/\/ Unfortunately, this is not what we need - if we requested a specific address, we'd want\n+  \/\/ to map there and nowhere else. Therefore we will unmap the block again, which means we\n+  \/\/ just executed a needless mmap->munmap cycle.\n+  \/\/ Since Linux 4.17, the kernel offers MAP_FIXED_NOREPLACE. With this flag, if a pre-\n+  \/\/ existing mapping exists, the kernel will not map at an alternative point but instead\n+  \/\/ return an error. We can therefore save that unnecessary mmap-munmap cycle.\n+  \/\/\n+  \/\/ Backward compatibility: Older kernels will ignore the unknown flag; so mmap will behave\n+  \/\/ as in mode (a).\n+  const int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS |\n+                    ((requested_addr != nullptr) ? MAP_FIXED_NOREPLACE : 0);\n@@ -4323,0 +4338,1 @@\n+    log_trace(os, map)(\"Kernel rejected \" PTR_FORMAT \", offered \" PTR_FORMAT \".\", p2i(requested_addr), p2i(addr));\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -934,0 +934,21 @@\n+\n+TEST_VM(os, reserve_at_wish_address_shall_not_replace_mappings_smallpages) {\n+  char* p1 = os::reserve_memory(M, false, mtTest);\n+  ASSERT_NE(p1, nullptr);\n+  char* p2 = os::attempt_reserve_memory_at(p1, M);\n+  ASSERT_EQ(p2, nullptr); \/\/ should have failed\n+  os::release_memory(p1, M);\n+}\n+\n+TEST_VM(os, reserve_at_wish_address_shall_not_replace_mappings_largepages) {\n+  if (UseLargePages && !os::can_commit_large_page_memory()) { \/\/ aka special\n+    const size_t lpsz = os::large_page_size();\n+    char* p1 = os::reserve_memory_aligned(lpsz, lpsz, false);\n+    ASSERT_NE(p1, nullptr);\n+    char* p2 = os::reserve_memory_special(lpsz, lpsz, lpsz, p1, false);\n+    ASSERT_EQ(p2, nullptr); \/\/ should have failed\n+    os::release_memory(p1, M);\n+  } else {\n+    tty->print_cr(\"Skipped.\");\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"}]}