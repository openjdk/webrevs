{"files":[{"patch":"@@ -337,9 +337,7 @@\n-                final Type[] out = new Type[nonGenericParamTypes.length];\n-                final Parameter[] params = getParameters();\n-                int fromidx = 0;\n-                for (int i = 0; i < out.length; i++) {\n-                    final Parameter param = params[i];\n-                    if (param.isSynthetic() || param.isImplicit()) {\n-                        \/\/ If we hit a synthetic or mandated parameter,\n-                        \/\/ use the non generic parameter info.\n-                        out[i] = nonGenericParamTypes[i];\n+                if (getDeclaringClass().isRecord() && this instanceof Constructor) {\n+                    \/* we could be seeing a compact constructor of a record class\n+                     * its parameters are mandated but we should be able to retrieve\n+                     * its generic information if present\n+                     *\/\n+                    if (genericParamTypes.length == nonGenericParamTypes.length) {\n+                        return genericParamTypes;\n@@ -347,3 +345,1 @@\n-                        \/\/ Otherwise, use the generic parameter info.\n-                        out[i] = genericParamTypes[fromidx];\n-                        fromidx++;\n+                        return nonGenericParamTypes.clone();\n@@ -351,0 +347,17 @@\n+                } else {\n+                    final Type[] out = new Type[nonGenericParamTypes.length];\n+                    final Parameter[] params = getParameters();\n+                    int fromidx = 0;\n+                    for (int i = 0; i < out.length; i++) {\n+                        final Parameter param = params[i];\n+                        if (param.isSynthetic() || param.isImplicit()) {\n+                            \/\/ If we hit a synthetic or mandated parameter,\n+                            \/\/ use the non generic parameter info.\n+                            out[i] = nonGenericParamTypes[i];\n+                        } else {\n+                            \/\/ Otherwise, use the generic parameter info.\n+                            out[i] = genericParamTypes[fromidx];\n+                            fromidx++;\n+                        }\n+                    }\n+                    return out;\n@@ -352,1 +365,0 @@\n-                return out;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8235369 8235550 8247444\n+ * @bug 8235369 8235550 8247444 8320575\n@@ -28,0 +28,1 @@\n+ * @build R10\n@@ -60,0 +61,21 @@\n+    record R9(List<String> ls) {\n+        R9 {} \/\/ compact constructor, will contain a mandated parameter\n+    }\n+\n+    \/* record R10 is defined in an accompaning jcod file, defined as:\n+    record R10(List<String> ls) { \/\/ in this case there wasn't be any compact constructor and thus no mandated param\n+    }\n+    *\/\n+\n+    record R11(int i, List<String> ls) {\n+        R11 {} \/\/ compact constructor, will contain mandated parameters\n+    }\n+\n+    record R12(List<String> ls, int i) {\n+        R12 {} \/\/ compact constructor, will contain mandated parameters\n+    }\n+\n+    record R13(List<String> ls1, int i, List<String> ls2) {\n+        R13 {} \/\/ compact constructor, will contain mandated parameters\n+    }\n+\n@@ -69,2 +91,7 @@\n-                       R8.class)\n-                   .stream().map(c -> new Object[] {c}).toArray(Object[][]::new);\n+                       R8.class,\n+                       R9.class,\n+                       R10.class,\n+                       R11.class,\n+                       R12.class,\n+                       R13.class\n+        ).stream().map(c -> new Object[] {c}).toArray(Object[][]::new);\n@@ -127,0 +154,28 @@\n+            new Object[] { new R9(List.of(\"1\")),\n+                        1,\n+                        new Object[]{ List.of(\"1\") },\n+                        new String[]{ \"ls\" },\n+                        new String[]{ \"java.util.List<java.lang.String>\"} },\n+            \/* R10 has exactly the same definition as R9 but the parameter of the compact constructor doesn't have\n+             * the mandated flag, nevertheless we should be able to load the same generic information\n+             *\/\n+            new Object[] { new R10(List.of(\"1\")),\n+                        1,\n+                        new Object[]{ List.of(\"1\") },\n+                        new String[]{ \"ls\" },\n+                        new String[]{ \"java.util.List<java.lang.String>\"} },\n+            new Object[] { new R11(1, List.of(\"1\")),\n+                        2,\n+                        new Object[]{ 1, List.of(\"1\") },\n+                        new String[]{ \"i\", \"ls\" },\n+                        new String[]{ \"int\", \"java.util.List<java.lang.String>\"} },\n+            new Object[] { new R12(List.of(\"1\"), 1),\n+                        2,\n+                        new Object[]{ List.of(\"1\"), 1 },\n+                        new String[]{ \"ls\", \"i\" },\n+                        new String[]{ \"java.util.List<java.lang.String>\", \"int\"} },\n+            new Object[] { new R13(List.of(\"1\"), 1, List.of(\"2\")),\n+                        3,\n+                        new Object[]{ List.of(\"1\"), 1, List.of(\"2\") },\n+                        new String[]{ \"ls1\", \"i\", \"ls2\" },\n+                        new String[]{ \"java.util.List<java.lang.String>\", \"int\", \"java.util.List<java.lang.String>\"} },\n@@ -152,0 +207,17 @@\n+        \/\/ now let's check constructors\n+        var constructor = recordClass.getDeclaredConstructors()[0];\n+        i = 0;\n+        for (var p: constructor.getParameters()) {\n+            assertEquals(p.getParameterizedType().toString(), signatures[i],\n+                    String.format(\"signature of method \\\"%s\\\" different from expected signature \\\"%s\\\"\",\n+                            p.getType().toString(), signatures[i]));\n+            i++;\n+        }\n+        \/\/ similar as above but testing another API\n+        i = 0;\n+        for (var p : constructor.getGenericParameterTypes()) {\n+            assertEquals(p.toString(), signatures[i],\n+                    String.format(\"signature of method \\\"%s\\\" different from expected signature \\\"%s\\\"\",\n+                            p.toString(), signatures[i]));\n+            i++;\n+        }\n@@ -204,1 +276,0 @@\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/records\/RecordReflectionTest.java","additions":76,"deletions":5,"binary":false,"changes":81,"status":"modified"}]}