{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import sun.java2d.pipe.Region;\n@@ -31,0 +32,1 @@\n+import java.awt.GraphicsConfiguration;\n@@ -34,0 +36,1 @@\n+import java.awt.geom.AffineTransform;\n@@ -103,3 +106,14 @@\n-                .map(graphicsDevice ->\n-                        graphicsDevice.getDefaultConfiguration().getBounds()\n-                ).toList();\n+                .map(graphicsDevice -> {\n+                    GraphicsConfiguration gc =\n+                            graphicsDevice.getDefaultConfiguration();\n+                    Rectangle screen = gc.getBounds();\n+                    AffineTransform tx = gc.getDefaultTransform();\n+\n+                    return new Rectangle(\n+                            Region.clipRound(screen.x * tx.getScaleX()),\n+                            Region.clipRound(screen.y * tx.getScaleY()),\n+                            Region.clipRound(screen.width * tx.getScaleX()),\n+                            Region.clipRound(screen.height * tx.getScaleY())\n+                    );\n+                })\n+                .toList();\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/ScreencastHelper.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -368,0 +368,11 @@\n+        \/\/ 3. add tokens with the same or greater number of screens\n+        \/\/ This is useful if we once received a token with one screen resolution\n+        \/\/ and the same screen was later scaled in the system.\n+        \/\/ In that case, the token is still valid.\n+\n+        allTokenItems\n+                .stream()\n+                .filter(t ->\n+                        t.allowedScreensBounds.size() >= affectedScreenBounds.size())\n+                .forEach(result::add);\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/TokenStorage.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -322,0 +322,4 @@\n+        fp_gdk_pixbuf_new_from_data = dl_symbol(\"gdk_pixbuf_new_from_data\");\n+        fp_gdk_pixbuf_scale_simple = dl_symbol(\"gdk_pixbuf_scale_simple\");\n+        fp_gdk_pixbuf_copy_area = dl_symbol(\"gdk_pixbuf_copy_area\");\n+\n@@ -3121,0 +3125,6 @@\n+\n+    gtk->gdk_pixbuf_new = fp_gdk_pixbuf_new;\n+    gtk->gdk_pixbuf_new_from_data = fp_gdk_pixbuf_new_from_data;\n+    gtk->gdk_pixbuf_scale_simple = fp_gdk_pixbuf_scale_simple;\n+    gtk->gdk_pixbuf_get_pixels = fp_gdk_pixbuf_get_pixels;\n+    gtk->gdk_pixbuf_copy_area = fp_gdk_pixbuf_copy_area;\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk3_interface.c","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -531,0 +531,24 @@\n+\n+static GdkPixbuf *(*fp_gdk_pixbuf_new_from_data)(\n+        const guchar *data,\n+        GdkColorspace colorspace,\n+        gboolean has_alpha,\n+        int bits_per_sample,\n+        int width,\n+        int height,\n+        int rowstride,\n+        GdkPixbufDestroyNotify destroy_fn,\n+        gpointer destroy_fn_data\n+);\n+\n+static void (*fp_gdk_pixbuf_copy_area) (\n+        const GdkPixbuf* src_pixbuf,\n+        int src_x,\n+        int src_y,\n+        int width,\n+        int height,\n+        GdkPixbuf* dest_pixbuf,\n+        int dest_x,\n+        int dest_y\n+);\n+\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk3_interface.h","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -535,0 +535,2 @@\n+typedef void GdkPixbuf;\n+typedef void (* GdkPixbufDestroyNotify) (guchar *pixels, gpointer data);\n@@ -796,0 +798,40 @@\n+    GdkPixbuf *(*gdk_pixbuf_new)(GdkColorspace colorspace,\n+                                 gboolean has_alpha,\n+                                 int bits_per_sample,\n+                                 int width,\n+                                 int height);\n+\n+\n+    GdkPixbuf *(*gdk_pixbuf_new_from_data)(\n+            const guchar *data,\n+            GdkColorspace colorspace,\n+            gboolean has_alpha,\n+            int bits_per_sample,\n+            int width,\n+            int height,\n+            int rowstride,\n+            GdkPixbufDestroyNotify destroy_fn,\n+            gpointer destroy_fn_data\n+    );\n+\n+\n+    GdkPixbuf *(*gdk_pixbuf_scale_simple)(GdkPixbuf *src,\n+                                          int dest_width,\n+                                          int dest_heigh,\n+                                          GdkInterpType interp_type\n+    );\n+\n+    guchar* (*gdk_pixbuf_get_pixels) (const GdkPixbuf* pixbuf);\n+\n+\n+    void (*gdk_pixbuf_copy_area) (\n+            const GdkPixbuf* src_pixbuf,\n+            int src_x,\n+            int src_y,\n+            int width,\n+            int height,\n+            GdkPixbuf* dest_pixbuf,\n+            int dest_x,\n+            int dest_y\n+    );\n+\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk_interface.h","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -151,43 +151,0 @@\n-static inline void convertRGBxToBGRx(int* in) {\n-    char* o = (char*) in;\n-    char tmp = o[0];\n-    o[0] = o[2];\n-    o[2] = tmp;\n-}\n-\n-static gchar * cropTo(\n-        struct spa_data data,\n-        struct spa_video_info_raw raw,\n-        guint32 x,\n-        guint32 y,\n-        guint32 width,\n-        guint32 height\n-) {\n-    int srcW = raw.size.width;\n-    if (data.chunk->stride \/ 4 != srcW) {\n-        fprintf(stderr, \"%s:%i Unexpected stride \/ 4: %i srcW: %i\\n\",\n-                __func__, __LINE__, data.chunk->stride \/ 4, srcW);\n-    }\n-\n-    int* d = data.data;\n-\n-    int *outData = calloc(width * height, sizeof(int));\n-    if (!outData) {\n-        ERR(\"failed to allocate memory\\n\");\n-        return NULL;\n-    }\n-\n-    gboolean needConversion = raw.format != SPA_VIDEO_FORMAT_BGRx;\n-    for (guint32 j = y; j < y + height; ++j) {\n-        for (guint32 i = x; i < x + width; ++i) {\n-            int color = *(d + (j * srcW) + i);\n-            if (needConversion) {\n-                convertRGBxToBGRx(&color);\n-            }\n-            *(outData + ((j - y) * width) + (i - x)) = color;\n-        }\n-    }\n-\n-    return (gchar*) outData;\n-}\n-\n@@ -277,0 +234,3 @@\n+    gint streamWidth = data->rawFormat.size.width;\n+    gint streamHeight = data->rawFormat.size.height;\n+\n@@ -280,1 +240,1 @@\n-                        \"flags %d FD %li captureDataReady %i\\n\",\n+                        \"flags %d FD %li captureDataReady %i of stream %dx%d\\n\",\n@@ -286,1 +246,3 @@\n-                        screen->captureDataReady\n+                        screen->captureDataReady,\n+                        streamWidth,\n+                        streamHeight\n@@ -289,6 +251,58 @@\n-    data->screenProps->captureData = cropTo(\n-            spaData,\n-            data->rawFormat,\n-            screen->captureArea.x, screen->captureArea.y,\n-            screen->captureArea.width, screen->captureArea.height\n-    );\n+    GdkRectangle captureArea = screen->captureArea;\n+    GdkRectangle screenBounds = screen->bounds;\n+\n+    GdkPixbuf *pixbuf = gtk->gdk_pixbuf_new_from_data(spaData.data,\n+                                                      GDK_COLORSPACE_RGB,\n+                                                      TRUE,\n+                                                      8,\n+                                                      streamWidth,\n+                                                      streamHeight,\n+                                                      spaData.chunk->stride,\n+                                                      NULL,\n+                                                      NULL);\n+\n+    if (screen->bounds.width != streamWidth\n+        || screen->bounds.height != streamHeight) {\n+\n+        DEBUG_SCREEN_PREFIX(screen, \"scaling stream data %dx%d -> %dx%d\\n\",\n+                         streamWidth, streamHeight,\n+                         screen->bounds.width, screen->bounds.height\n+        );\n+\n+        GdkPixbuf *scaled = gtk->gdk_pixbuf_scale_simple(pixbuf,\n+                                                         screen->bounds.width,\n+                                                         screen->bounds.height,\n+                                                         GDK_INTERP_BILINEAR);\n+\n+        gtk->g_object_unref(pixbuf);\n+        pixbuf = scaled;\n+    }\n+\n+    GdkPixbuf *cropped = NULL;\n+    if (captureArea.width != screenBounds.width\n+        || captureArea.height != screenBounds.height) {\n+\n+        cropped = gtk->gdk_pixbuf_new(GDK_COLORSPACE_RGB,\n+                                      TRUE,\n+                                      8,\n+                                      captureArea.width,\n+                                      captureArea.height);\n+        if (cropped) {\n+            gtk->gdk_pixbuf_copy_area(pixbuf,\n+                                      captureArea.x,\n+                                      captureArea.y,\n+                                      captureArea.width,\n+                                      captureArea.height,\n+                                      cropped,\n+                                      0, 0);\n+        } else {\n+            ERR(\"Cannot create a new pixbuf.\\n\");\n+        }\n+\n+        gtk->g_object_unref(pixbuf);\n+        pixbuf = NULL;\n+\n+        data->screenProps->captureDataPixbuf = cropped;\n+    } else {\n+        data->screenProps->captureDataPixbuf = pixbuf;\n+    }\n@@ -342,5 +356,1 @@\n-            SPA_POD_CHOICE_ENUM_Id(\n-                    2,\n-                    SPA_VIDEO_FORMAT_RGBx,\n-                    SPA_VIDEO_FORMAT_BGRx\n-            ),\n+            SPA_POD_Id(SPA_VIDEO_FORMAT_BGRx),\n@@ -858,1 +868,1 @@\n-                                i, screenProps->captureData,\n+                                i, screenProps->captureDataPixbuf,\n@@ -872,1 +882,1 @@\n-            if (screenProps->captureData) {\n+            if (screenProps->captureDataPixbuf) {\n@@ -887,2 +897,4 @@\n-                            ((jint *) screenProps->captureData)\n-                                + (captureArea.width * y)\n+                            ((jint *) gtk->gdk_pixbuf_get_pixels(\n+                                    screenProps->captureDataPixbuf\n+                            ))\n+                            + (captureArea.width * y)\n@@ -893,2 +905,4 @@\n-            free(screenProps->captureData);\n-            screenProps->captureData = NULL;\n+            if (screenProps->captureDataPixbuf) {\n+                gtk->g_object_unref(screenProps->captureDataPixbuf);\n+                screenProps->captureDataPixbuf = NULL;\n+            }\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_pipewire.c","additions":76,"deletions":62,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-    gchar *captureData;\n+    GdkPixbuf *captureDataPixbuf;\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_pipewire.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import javax.swing.UIManager;\n@@ -57,0 +56,6 @@\n+        if (\"2\".equals(System.getProperty(\"jdk.gtk.version\"))\n+                && System.getenv(\"WAYLAND_DISPLAY\") != null) {\n+            \/\/ screen capture is not supported with gtk2 on Wayland\n+            return;\n+        }\n+\n","filename":"test\/jdk\/java\/awt\/Robot\/HiDPIScreenCapture\/ScreenCaptureGtkTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"}]}