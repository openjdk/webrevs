{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,5 @@\n- * @summary Confirm that DecimalFormat.parse() parses BigDecimal and BigInteger as expected.\n+ * @summary Confirm that DecimalFormat.parse() parses BigDecimal and BigInteger\n+ *          string values as expected. Specifically, ensure a ParseException is\n+ *          not thrown as well as the parsed value being numerically correct.\n+ *          Tests large String values with combinations of multipliers and exponents.\n+ * @run junit BigDecimalCompatibilityTest\n@@ -30,3 +34,15 @@\n-import java.math.*;\n-import java.text.*;\n-import java.util.*;\n+import java.math.BigDecimal;\n+import java.math.RoundingMode;\n+import java.text.DecimalFormat;\n+import java.util.ArrayList;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n@@ -36,1 +52,3 @@\n-    static boolean err = false;\n+    private static DecimalFormat df = new DecimalFormat();\n+    \/\/ Save JVM default Locale\n+    private static final Locale savedLocale = Locale.getDefault();\n@@ -38,10 +56,1 @@\n-    static final String[] input_data = {\n-        \"0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n-        \"1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890\"\n-    };\n-    static final String[] exponents = {\n-        \"E-100\", \"E100\", \"E-900\", \"E900\", \"\"\n-    };\n-    static final int[] multipliers = {\n-        -1, 1, -100, 100, -9999, 9999\n-    };\n+    \/\/ ---- Used for the test data (start) ----\n@@ -49,3 +58,3 @@\n-    public static void main(String[] args) throws Exception {\n-        Locale loc = Locale.getDefault();\n-        Locale.setDefault(Locale.US);\n+    \/\/ Both ArrayList composed of Arguments(String longString, int multiplier)\n+    private static final ArrayList<Arguments> bigIntegers = new ArrayList<Arguments>();\n+    private static final ArrayList<Arguments> bigDecimals = new ArrayList<Arguments>();\n@@ -53,2 +62,4 @@\n-        testBigDecimal();\n-        testBigInteger();\n+    \/\/ Long string data to generate combinations of test values\n+    private static final String[] inputData = {\n+            \"0\".repeat(400),\n+            \"1234567890\".repeat(40)};\n@@ -56,1 +67,4 @@\n-        Locale.setDefault(loc);\n+    \/\/ Variety of exponents to test parse() against\n+    private static final String[] exponents = {\n+            \"E-100\", \"E100\", \"E-900\", \"E900\", \"\"\n+    };\n@@ -58,4 +72,5 @@\n-        if (err) {\n-            throw new RuntimeException(\"Error: Unexpected value\");\n-        }\n-    }\n+    \/\/ Variety of multipliers that DecimalFormat can apply\n+    private static final int[] multipliers = {\n+            -1, 1, -100, 100, -9999, 9999\n+    };\n+    \/\/ ---- Used for the test data (end) ----\n@@ -63,4 +78,6 @@\n-    static private void testBigDecimal() {\n-        DecimalFormat df = new DecimalFormat();\n-        df.setParseBigDecimal(true);\n-        df.setMaximumFractionDigits(Integer.MAX_VALUE);\n+    \/\/ Set JVM default Locale to US and populate the test arrayLists\n+    @BeforeAll\n+    static void initAll() {\n+        Locale.setDefault(Locale.US);\n+        buildTestData();\n+    }\n@@ -68,11 +85,21 @@\n-        for (int i = 0; i < input_data.length; i++) {\n-            for (int j = 0; j < input_data.length; j++) {\n-                for (int k = 0; k < input_data.length; k++) {\n-                    for (int l = 0; l < input_data.length; l++) {\n-                        for (int m = 0; m < exponents.length; m++) {\n-                            String s = input_data[i] + input_data[j] + '.' +\n-                                       input_data[k] + input_data[l] +\n-                                       exponents[m];\n-                            for (int n = 0; n < multipliers.length; n++) {\n-                                test(df, s, multipliers[n]);\n-                                test(df, '-'+s, multipliers[n]);\n+    \/*\n+     * Uses inputData and exponents to build long string\n+     * decimal and integer values and populate bigDecimals and bigIntegers\n+     * accordingly. Attaches a multiplier value as well to the test data.\n+     *\/\n+    private static void buildTestData() {\n+        for (String longString1 : inputData) {\n+            for (String longString2 : inputData) {\n+                String bigInteger = longString1 + longString2;\n+                for (int multiplier : multipliers) {\n+                    bigIntegers.add(Arguments.of(bigInteger, multiplier));\n+                    bigIntegers.add(Arguments.of('-' + bigInteger, multiplier));\n+                }\n+                for (String longString3 : inputData) {\n+                    for (String longString4 : inputData) {\n+                        for (String exponent : exponents) {\n+                            String bigDecimal = longString1 + longString2 + '.'\n+                                    + longString3 + longString4 + exponent;\n+                            for (int multiplier : multipliers) {\n+                                bigDecimals.add(Arguments.of(bigDecimal, multiplier));\n+                                bigDecimals.add(Arguments.of('-' + bigDecimal, multiplier));\n@@ -87,4 +114,5 @@\n-    static private void testBigInteger() {\n-        DecimalFormat df = new DecimalFormat();\n-        df.setParseBigDecimal(true);\n-        df.setMaximumFractionDigits(Integer.MAX_VALUE);\n+    \/\/ Restore JVM default Locale\n+    @AfterAll\n+    static void tearDownAll() {\n+        Locale.setDefault(savedLocale);\n+    }\n@@ -92,9 +120,24 @@\n-        for (int i = 0; i < input_data.length; i++) {\n-            for (int j = 0; j < input_data.length; j++) {\n-                String s = input_data[i] + input_data[j];\n-                for (int k = 0; k < multipliers.length; k++) {\n-                    test(df, s, multipliers[k]);\n-                    test(df, '-'+s, multipliers[k]);\n-                }\n-            }\n-        }\n+    \/\/ Tests strings with length 1600+. See test() for specific details.\n+    @ParameterizedTest\n+    @MethodSource(\"bigDecimalProvider\")\n+    public void bigDecimalParseTest(String longString, int multiplier) {\n+        test(longString, multiplier);\n+    }\n+\n+    \/\/ Returns 960 arrangements of bigDecimal string values and multipliers\n+    \/\/ In the form of (String, int).\n+    private static Stream<Arguments> bigDecimalProvider() {\n+        return bigDecimals.stream();\n+    }\n+\n+    \/\/ Tests strings with length 800+. See test() for specific details.\n+    @ParameterizedTest\n+    @MethodSource(\"bigIntegerProvider\")\n+    public void bigIntegerParseTest(String longString, int multiplier) {\n+        test(longString, multiplier);\n+    }\n+\n+    \/\/ Returns 48 arrangements of bigInteger string values and multipliers\n+    \/\/ In the form of (String, int).\n+    private static Stream<Arguments> bigIntegerProvider() {\n+        return bigIntegers.stream();\n@@ -103,1 +146,12 @@\n-    static void test(DecimalFormat df, String s, int multiplier) {\n+    \/*\n+     * Tests that parsing a large BigDecimal\/BigInteger string value\n+     * will not throw a ParseException with setParseBigDecimal as true.\n+     * Parses with a variety of multiplier values. Then ensures that the parsed\n+     * value is the expected number.\n+     *\/\n+    private static void test(String longString, int multiplier) {\n+        \/\/ Reset DecimalFormat for a clean test\n+        df = new DecimalFormat();\n+        df.setParseBigDecimal(true);\n+        \/\/ wide enough to support the long string test data\n+        df.setMaximumFractionDigits(Integer.MAX_VALUE);\n@@ -106,9 +160,7 @@\n-        Number num = null;\n-        try {\n-            num = df.parse(s);\n-        }\n-        catch (ParseException e) {\n-            err = true;\n-            System.err.println(\"Failed: Exception occurred: \" + e.getMessage());\n-            return;\n-        }\n+        \/\/ Check parse and returned value. This was originally intended to ensure\n+        \/\/ a ParseException is not thrown\n+        Number parsedValue = assertDoesNotThrow(()-> df.parse(longString),\n+                \"Should not throw an Exception\");\n+        BigDecimal expectedValue = getExpected(longString, multiplier);\n+        assertEquals(expectedValue, parsedValue, \"With multiplier: \" + multiplier);\n+    }\n@@ -116,1 +168,4 @@\n-        BigDecimal bd = new BigDecimal(s);\n+    \/\/ Utility to get a numerically correct value of a long string.\n+    \/\/ Dependent on BigDecimal implementation\n+    private static BigDecimal getExpected(String longString, int multiplier) {\n+        BigDecimal expected = new BigDecimal(longString);\n@@ -118,1 +173,1 @@\n-           bd = bd.divide(new BigDecimal(multiplier));\n+            expected = expected.divide(new BigDecimal(multiplier));\n@@ -121,11 +176,1 @@\n-           bd = bd.divide(new BigDecimal(multiplier), RoundingMode.HALF_EVEN);\n-        }\n-        check(num, bd, multiplier);\n-    }\n-\n-    static void check(Number got, BigDecimal expected, int multiplier) {\n-        if (!got.equals(expected)) {\n-            err = true;\n-            System.err.println(\"Failed: got:\" + got +\n-                               \", expected: \" + expected +\n-                               \", multiplier=\" + multiplier);\n+            expected = expected.divide(new BigDecimal(multiplier), RoundingMode.HALF_EVEN);\n@@ -133,0 +178,1 @@\n+        return expected;\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/BigDecimalCompatibilityTest.java","additions":123,"deletions":77,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,3 @@\n- * @summary Confirm that the decimal separator is shown when explicitly requested.\n+ * @summary Confirm that the decimal separator is shown when explicitly requested\n+ *          (or not shown if not requested). Tests against double, long, BigDecimal,\n+ *          and BigInteger with a combination of different patterns.\n@@ -28,0 +30,1 @@\n+ * @run junit Bug4208135\n@@ -30,3 +33,5 @@\n-import java.math.*;\n-import java.text.*;\n-import java.util.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.text.DecimalFormat;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n@@ -34,1 +39,5 @@\n-public class Bug4208135 {\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -36,1 +45,1 @@\n-    static DecimalFormat df;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -38,1 +47,1 @@\n-    static boolean err = false;\n+public class Bug4208135 {\n@@ -40,1 +49,3 @@\n-    static public void main(String[] args){\n+    private static DecimalFormat df;\n+    \/\/ Save JVM default Locale\n+    private static final Locale savedLocale = Locale.getDefault();\n@@ -42,1 +53,3 @@\n-        Locale defaultLoc = Locale.getDefault();\n+    \/\/ Set JVM default locale to US\n+    @BeforeAll\n+    static void init() {\n@@ -44,0 +57,1 @@\n+    }\n@@ -45,1 +59,41 @@\n-        df = new DecimalFormat();\n+    \/\/ Restore JVM default locale\n+    @AfterAll\n+    static void tearDown() {\n+        Locale.setDefault(savedLocale);\n+    }\n+\n+    \/\/ Confirm that decimal separator shown when formatting a number\n+    @ParameterizedTest\n+    @MethodSource(\"fractionalDigitsWithSeparatorProvider\")\n+    public void fractionalDigitsWithSeparatorTest(Number num, String expected) {\n+        df = getDF(\"0.#E0\", true);\n+        String actualFormatted = df.format(num);\n+        assertEquals(expected, actualFormatted, getErrMsg(\"0.#E0\", true));\n+    }\n+\n+    \/\/ Combination of numbers and a fractional exponent pattern with a separator\n+    private static Stream<Arguments> fractionalDigitsWithSeparatorProvider() {\n+        return Stream.of(\n+                Arguments.of(0.0, \"0.E0\"),\n+                Arguments.of(10.0, \"1.E1\"),\n+                Arguments.of(1000.0, \"1.E3\"),\n+                Arguments.of(0L, \"0.E0\"),\n+                Arguments.of(10L, \"1.E1\"),\n+                Arguments.of(1000L, \"1.E3\"),\n+                Arguments.of(new BigDecimal(\"0.0\"), \"0.E0\"),\n+                Arguments.of(new BigDecimal(\"10.0\"), \"1.E1\"),\n+                Arguments.of(new BigDecimal(\"1000.0\"), \"1.E3\"),\n+                Arguments.of(new BigInteger(\"00\"), \"0.E0\"),\n+                Arguments.of(new BigInteger(\"10\"), \"1.E1\"),\n+                Arguments.of(new BigInteger(\"1000\"), \"1.E3\")\n+        );\n+    }\n+\n+    \/\/ Confirm that decimal separator not shown when formatting a number\n+    @ParameterizedTest\n+    @MethodSource(\"fractionalDigitsNoSeparatorProvider\")\n+    public void fractionalDigitsNoSeparatorTest(Number num, String expected) {\n+        df = getDF(\"0.#E0\", false);\n+        String actualFormatted = df.format(num);\n+        assertEquals(expected, actualFormatted, getErrMsg(\"0.#E0\", false));\n+    }\n@@ -47,65 +101,78 @@\n-        df.applyPattern(\"0.#E0\");\n-\n-        df.setDecimalSeparatorAlwaysShown(true);\n-        checkFormat(0.0, \"0.E0\");\n-        checkFormat(10.0, \"1.E1\");\n-        checkFormat(1000.0, \"1.E3\");\n-        checkFormat(0L, \"0.E0\");\n-        checkFormat(10L, \"1.E1\");\n-        checkFormat(1000L, \"1.E3\");\n-        checkFormat(new BigDecimal(\"0.0\"), \"0.E0\");\n-        checkFormat(new BigDecimal(\"10.0\"), \"1.E1\");\n-        checkFormat(new BigDecimal(\"1000.0\"), \"1.E3\");\n-        checkFormat(new BigInteger(\"00\"), \"0.E0\");\n-        checkFormat(new BigInteger(\"10\"), \"1.E1\");\n-        checkFormat(new BigInteger(\"1000\"), \"1.E3\");\n-\n-        df.setDecimalSeparatorAlwaysShown(false);\n-        checkFormat(0.0, \"0E0\");\n-        checkFormat(10.0, \"1E1\");\n-        checkFormat(1000.0, \"1E3\");\n-        checkFormat(0L, \"0E0\");\n-        checkFormat(10L, \"1E1\");\n-        checkFormat(1000L, \"1E3\");\n-        checkFormat(new BigDecimal(\"0.0\"), \"0E0\");\n-        checkFormat(new BigDecimal(\"10.0\"), \"1E1\");\n-        checkFormat(new BigDecimal(\"1000.0\"), \"1E3\");\n-        checkFormat(new BigInteger(\"0\"), \"0E0\");\n-        checkFormat(new BigInteger(\"10\"), \"1E1\");\n-        checkFormat(new BigInteger(\"1000\"), \"1E3\");\n-\n-        df.applyPattern(\"0.###\");\n-\n-        df.setDecimalSeparatorAlwaysShown(true);\n-        checkFormat(0.0, \"0.\");\n-        checkFormat(10.0, \"10.\");\n-        checkFormat(1000.0, \"1000.\");\n-        checkFormat(0L, \"0.\");\n-        checkFormat(10L, \"10.\");\n-        checkFormat(1000L, \"1000.\");\n-        checkFormat(new BigDecimal(\"0.0\"), \"0.\");\n-        checkFormat(new BigDecimal(\"10.0\"), \"10.\");\n-        checkFormat(new BigDecimal(\"1000.0\"), \"1000.\");\n-        checkFormat(new BigInteger(\"0\"), \"0.\");\n-        checkFormat(new BigInteger(\"10\"), \"10.\");\n-        checkFormat(new BigInteger(\"1000\"), \"1000.\");\n-\n-        df.setDecimalSeparatorAlwaysShown(false);\n-        checkFormat(0.0, \"0\");\n-        checkFormat(10.0, \"10\");\n-        checkFormat(1000.0, \"1000\");\n-        checkFormat(0L, \"0\");\n-        checkFormat(10L, \"10\");\n-        checkFormat(1000L, \"1000\");\n-        checkFormat(new BigDecimal(\"0.0\"), \"0\");\n-        checkFormat(new BigDecimal(\"10.0\"), \"10\");\n-        checkFormat(new BigDecimal(\"1000.0\"), \"1000\");\n-        checkFormat(new BigInteger(\"0\"), \"0\");\n-        checkFormat(new BigInteger(\"10\"), \"10\");\n-        checkFormat(new BigInteger(\"1000\"), \"1000\");\n-\n-        Locale.setDefault(defaultLoc);\n-\n-        if (err) {\n-            throw new RuntimeException(\"Wrong format\/parse with DecimalFormat\");\n-        }\n+    \/\/ Combination of numbers and a fractional exponent pattern with no separator\n+    private static Stream<Arguments> fractionalDigitsNoSeparatorProvider() {\n+        return Stream.of(\n+                Arguments.of(0.0, \"0E0\"),\n+                Arguments.of(10.0, \"1E1\"),\n+                Arguments.of(1000.0, \"1E3\"),\n+                Arguments.of(0L, \"0E0\"),\n+                Arguments.of(10L, \"1E1\"),\n+                Arguments.of(1000L, \"1E3\"),\n+                Arguments.of(new BigDecimal(\"0.0\"), \"0E0\"),\n+                Arguments.of(new BigDecimal(\"10.0\"), \"1E1\"),\n+                Arguments.of(new BigDecimal(\"1000.0\"), \"1E3\"),\n+                Arguments.of(new BigInteger(\"00\"), \"0E0\"),\n+                Arguments.of(new BigInteger(\"10\"), \"1E1\"),\n+                Arguments.of(new BigInteger(\"1000\"), \"1E3\")\n+        );\n+    }\n+\n+    \/\/ Confirm that decimal separator shown when formatting a number\n+    @ParameterizedTest\n+    @MethodSource(\"noFractionalDigitsWithSeparatorProvider\")\n+    public void noFractionalDigitsWithSeparatorTest(Number num, String expected) {\n+        df = getDF(\"0.###\", true);\n+        String actualFormatted = df.format(num);\n+        assertEquals(expected, actualFormatted, getErrMsg(\"0.###\", true));\n+    }\n+\n+    \/\/ Combination of numbers and a non-fractional exponent pattern with a separator\n+    private static Stream<Arguments> noFractionalDigitsWithSeparatorProvider() {\n+        return Stream.of(\n+                Arguments.of(0.0, \"0.\"),\n+                Arguments.of(10.0, \"10.\"),\n+                Arguments.of(1000.0, \"1000.\"),\n+                Arguments.of(0L, \"0.\"),\n+                Arguments.of(10L, \"10.\"),\n+                Arguments.of(1000L, \"1000.\"),\n+                Arguments.of(new BigDecimal(\"0.0\"), \"0.\"),\n+                Arguments.of(new BigDecimal(\"10.0\"), \"10.\"),\n+                Arguments.of(new BigDecimal(\"1000.0\"), \"1000.\"),\n+                Arguments.of(new BigInteger(\"00\"), \"0.\"),\n+                Arguments.of(new BigInteger(\"10\"), \"10.\"),\n+                Arguments.of(new BigInteger(\"1000\"), \"1000.\")\n+        );\n+    }\n+\n+    \/\/ Confirm that decimal separator not shown when formatting a number\n+    @ParameterizedTest\n+    @MethodSource(\"noFractionalDigitsNoSeparatorProvider\")\n+    public void noFractionalDigitsNoSeparatorTest(Number num, String expected) {\n+        df = getDF(\"0.###\", false);\n+        String actualFormatted = df.format(num);\n+        assertEquals(expected, actualFormatted, getErrMsg(\"0.###\", false));\n+    }\n+\n+    \/\/ Combination of numbers and a non-fractional exponent pattern with no separator\n+    private static Stream<Arguments> noFractionalDigitsNoSeparatorProvider() {\n+        return Stream.of(\n+                Arguments.of(0.0, \"0\"),\n+                Arguments.of(10.0, \"10\"),\n+                Arguments.of(1000.0, \"1000\"),\n+                Arguments.of(0L, \"0\"),\n+                Arguments.of(10L, \"10\"),\n+                Arguments.of(1000L, \"1000\"),\n+                Arguments.of(new BigDecimal(\"0.0\"), \"0\"),\n+                Arguments.of(new BigDecimal(\"10.0\"), \"10\"),\n+                Arguments.of(new BigDecimal(\"1000.0\"), \"1000\"),\n+                Arguments.of(new BigInteger(\"00\"), \"0\"),\n+                Arguments.of(new BigInteger(\"10\"), \"10\"),\n+                Arguments.of(new BigInteger(\"1000\"), \"1000\")\n+        );\n+    }\n+\n+    \/\/ Creates clean DF and sets the pattern and separatorShown value\n+    private static DecimalFormat getDF(String pattern, boolean separatorShown) {\n+        df = new DecimalFormat();\n+        df.applyPattern(pattern);\n+        df.setDecimalSeparatorAlwaysShown(separatorShown);\n+        return df;\n@@ -114,12 +181,4 @@\n-    static void checkFormat(Number num, String expected) {\n-        String got = df.format(num);\n-        if (!got.equals(expected)) {\n-            err = true;\n-            System.err.println(\"    DecimalFormat format(\" +\n-                               num.getClass().getName() +\n-                               \") error:\" +\n-                               \"\\n\\tnumber:           \" + num +\n-                               \"\\n\\tSeparatorShown? : \" + df.isDecimalSeparatorAlwaysShown() +\n-                               \"\\n\\tgot:              \" + got +\n-                               \"\\n\\texpected:         \" + expected);\n-        }\n+    \/\/ Utility to get a helpful error message when values are not as expected\n+    private static String getErrMsg(String pattern, boolean separatorShown) {\n+        return String.format(\"Fails with pattern= %s, with separatorShown = %s\",\n+                pattern, separatorShown);\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug4208135.java","additions":147,"deletions":88,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -27,1 +27,3 @@\n- * @summary Confirm that DecimalFormat can format a number with negative exponent number correctly.\n+ * @summary Confirm that DecimalFormat can format a number with a negative\n+ *          exponent number correctly. Tests also involve using a DecimalFormat\n+ *          with a custom pattern or a custom minus sign.\n@@ -31,3 +33,6 @@\n-import java.math.*;\n-import java.util.*;\n-import java.text.*;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n@@ -35,1 +40,5 @@\n-import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -37,0 +46,1 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -39,0 +49,10 @@\n+\/*\n+ * This bug is about exponential formatting. But I added test cases for:\n+ *   - Double and BigDecimal numbers which don't have exponent parts.\n+ *   - Long and BigInteger numbers which don't support exponential\n+ *     notation.\n+ * because there are few test cases for suffix and prefix.\n+ * And also, I added test cases to guarantee further formatting and\n+ * parsing using the same DecimalFormat instance will not change the\n+ * Number's value anymore.\n+ *\/\n@@ -41,3 +61,2 @@\n-    static DecimalFormat df;\n-    static DecimalFormatSymbols dfs;\n-    static boolean err = false;\n+    \/\/ Save JVM default Locale\n+    private static final Locale savedLocale = Locale.getDefault();\n@@ -45,2 +64,3 @@\n-    static public void main(String[] args) {\n-        Locale defaultLoc = Locale.getDefault();\n+    \/\/ Set JVM default Locale to US\n+    @BeforeAll\n+    static void init() {\n@@ -48,22 +68,0 @@\n-\n-        \/**\n-         * This bug is about exponential formatting. But I added test cases for:\n-         *   - Double and BigDecimal numbers which don't have exponent parts.\n-         *   - Long and BigInteger numbers which don't support exponential\n-         *     notation.\n-         * because there are few test cases for suffix and prefix.\n-         * And also, I added test cases to guarantee further formatting and\n-         * parsing using the same DecimalFormat instance will not change the\n-         * Number's value anymore.\n-         *\/\n-\n-        test_double();\n-        test_long();\n-        test_BigDecimal();\n-        test_BigInteger();\n-\n-        Locale.setDefault(defaultLoc);\n-\n-        if (err) {\n-            throw new RuntimeException(\"Wrong format with DecimalFormat\");\n-        }\n@@ -72,46 +70,4 @@\n-    static void test_double() {\n-        df = new DecimalFormat();\n-        dfs = df.getDecimalFormatSymbols();\n-\n-        \/* Test with default pattern *\/\n-        test(1234D,    \"1,234\");\n-        test(0.1234,  \"0.123\");     \/\/ rounded\n-        test(-1234D,   \"-1,234\");\n-        test(-0.1234, \"-0.123\");    \/\/ rounded\n-\n-        test(Double.POSITIVE_INFINITY, \"\\u221e\");\n-        test(Double.NEGATIVE_INFINITY, \"-\\u221e\");\n-        test(Double.NaN, \"\\ufffd\"); \/\/ without prefix and suffix\n-        test(0.0,  \"0\");\n-        test(-0.0, \"-0\");   \/\/ with the minus sign\n-\n-        \/* Specify a pattern and the minus sign. *\/\n-        prepareFormatter(\"<P>#.###E00<S>\", 'm');\n-        test(1234D,    \"<P>1.234E03<S>\");\n-        test(0.1234,  \"<P>1.234Em01<S>\");\n-        test(-1234D,   \"m<P>1.234E03<S>\");\n-        test(-0.1234, \"m<P>1.234Em01<S>\");\n-\n-        prepareFormatter(\"<P>#.###E00<S>;#.###E00\", 'm');\n-        test(1234D,    \"<P>1.234E03<S>\");\n-        test(0.1234,  \"<P>1.234Em01<S>\");\n-        test(-1234D,   \"1.234E03\");\n-        test(-0.1234, \"1.234Em01\");\n-\n-        prepareFormatter(\"#.###E00;<P>#.###E00<S>\", 'm');\n-        test(1234D,    \"1.234E03\");\n-        test(0.1234,  \"1.234Em01\");\n-        test(-1234D,   \"<P>1.234E03<S>\");\n-        test(-0.1234, \"<P>1.234Em01<S>\");\n-\n-        prepareFormatter(\"<P>#.###E00<S>;<p>-#.###E00<s>\", 'm');\n-        test(1234D,    \"<P>1.234E03<S>\");\n-        test(0.1234,  \"<P>1.234Em01<S>\");\n-        test(-1234D,   \"<p>m1.234E03<s>\");\n-        test(-0.1234, \"<p>m1.234Em01<s>\");\n-\n-        test(Double.POSITIVE_INFINITY, \"<P>\\u221e<S>\");\n-        test(Double.NEGATIVE_INFINITY, \"<p>m\\u221e<s>\");\n-        test(Double.NaN, \"\\ufffd\"); \/\/ without prefix and suffix\n-        test(0.0,  \"<P>0E00<S>\");\n-        test(-0.0, \"<p>m0E00<s>\");  \/\/ with the minus sign\n+    \/\/ Restore the original JVM default locale\n+    @AfterAll\n+    static void tearDown() {\n+        Locale.setDefault(savedLocale);\n@@ -120,30 +76,5 @@\n-    static void test_BigDecimal() {\n-        df = new DecimalFormat();\n-        dfs = df.getDecimalFormatSymbols();\n-\n-        \/* Test with default pattern *\/\n-        test(new BigDecimal(\"123456789012345678901234567890\"),\n-             \"123,456,789,012,345,678,901,234,567,890\");\n-        test(new BigDecimal(\"0.000000000123456789012345678901234567890\"),\n-             \"0\");\n-        test(new BigDecimal(\"-123456789012345678901234567890\"),\n-             \"-123,456,789,012,345,678,901,234,567,890\");\n-        test(new BigDecimal(\"-0.000000000123456789012345678901234567890\"),\n-              \"-0\");\n-\n-        test(new BigDecimal(\"0\"), \"0\");\n-        test(new BigDecimal(\"-0\"), \"0\");\n-\n-        \/* Specify a pattern and the minus sign. *\/\n-        prepareFormatter(\"<P>#.####################E00<S>;<p>-#.####################E00<s>\", 'm');\n-        test(new BigDecimal(\"123456789012345678901234567890\"),\n-             \"<P>1.23456789012345678901E29<S>\");\n-        test(new BigDecimal(\"0.000000000123456789012345678901234567890\"),\n-             \"<P>1.23456789012345678901Em10<S>\");\n-        test(new BigDecimal(\"-123456789012345678901234567890\"),\n-             \"<p>m1.23456789012345678901E29<s>\");\n-        test(new BigDecimal(\"-0.000000000123456789012345678901234567890\"),\n-              \"<p>m1.23456789012345678901Em10<s>\");\n-\n-        test(new BigDecimal(\"0\"), \"<P>0E00<S>\");\n-        test(new BigDecimal(\"-0\"), \"<P>0E00<S>\");\n+    \/\/ Check that negative exponent number recognized for doubles\n+    @ParameterizedTest\n+    @MethodSource(\"doubles\")\n+    public void doubleTest(Number num, String str, DecimalFormat df) {\n+        test(num, str, df);\n@@ -152,18 +83,43 @@\n-    static void test_long() {\n-        df = new DecimalFormat();\n-        dfs = df.getDecimalFormatSymbols();\n-\n-        \/* Test with default pattern *\/\n-        test(123456789L,  \"123,456,789\");\n-        test(-123456789L, \"-123,456,789\");\n-\n-        test(0L, \"0\");\n-        test(-0L, \"0\");\n-\n-        \/* Specify a pattern and the minus sign. *\/\n-        prepareFormatter(\"<P>#,###<S>;<p>-#,###<s>\", 'm');\n-        test(123456789L,  \"<P>123,456,789<S>\");\n-        test(-123456789L, \"<p>m123,456,789<s>\");\n-\n-        test(0L, \"<P>0<S>\");\n-        test(-0L, \"<P>0<S>\");\n+    \/\/ Provides a double to be formatted, which is compared to the expected String.\n+    \/\/ Additionally, provides a DecimalFormat to do the formatting (can have a custom\n+    \/\/ pattern and minus sign). Given in the form (double, String, DecimalFormat).\n+    private static Stream<Arguments> doubles() {\n+        DecimalFormat defaultDf = new DecimalFormat();\n+        DecimalFormat customDf1 = getDecimalFormat(\"<P>#.###E00<S>\", 'm');\n+        DecimalFormat customDf2 = getDecimalFormat(\"<P>#.###E00<S>;#.###E00\", 'm');\n+        DecimalFormat customDf3 = getDecimalFormat(\"#.###E00;<P>#.###E00<S>\", 'm');\n+        DecimalFormat customDf4 = getDecimalFormat(\"<P>#.###E00<S>;<p>-#.###E00<s>\", 'm');\n+        return Stream.of(\n+                \/\/ Test with default pattern\n+                Arguments.of(1234D,    \"1,234\", defaultDf),\n+                Arguments.of(0.1234,  \"0.123\", defaultDf),    \/\/ rounded\n+                Arguments.of(-1234D,   \"-1,234\", defaultDf),\n+                Arguments.of(-0.1234, \"-0.123\", defaultDf),    \/\/ rounded\n+                Arguments.of(Double.POSITIVE_INFINITY, \"\\u221e\", defaultDf),\n+                Arguments.of(Double.NEGATIVE_INFINITY, \"-\\u221e\", defaultDf),\n+                Arguments.of(Double.NaN, \"\\ufffd\", defaultDf), \/\/ without prefix and suffix\n+                Arguments.of(0.0,  \"0\", defaultDf),\n+                Arguments.of(-0.0, \"-0\", defaultDf),   \/\/ with the minus sign\n+                \/\/ Test with a pattern and the minus sign\n+                Arguments.of(1234D,    \"<P>1.234E03<S>\", customDf1),\n+                Arguments.of(0.1234,  \"<P>1.234Em01<S>\", customDf1),\n+                Arguments.of(-1234D,   \"m<P>1.234E03<S>\", customDf1),\n+                Arguments.of(-0.1234, \"m<P>1.234Em01<S>\", customDf1),\n+                Arguments.of(1234D,    \"<P>1.234E03<S>\", customDf2),\n+                Arguments.of(0.1234,  \"<P>1.234Em01<S>\", customDf2),\n+                Arguments.of(-1234D,   \"1.234E03\", customDf2),\n+                Arguments.of(-0.1234, \"1.234Em01\", customDf2),\n+                Arguments.of(1234D,    \"1.234E03\", customDf3),\n+                Arguments.of(0.1234,  \"1.234Em01\", customDf3),\n+                Arguments.of(-1234D,   \"<P>1.234E03<S>\", customDf3),\n+                Arguments.of(-0.1234, \"<P>1.234Em01<S>\", customDf3),\n+                Arguments.of(1234D,    \"<P>1.234E03<S>\", customDf4),\n+                Arguments.of(0.1234,  \"<P>1.234Em01<S>\", customDf4),\n+                Arguments.of(-1234D,   \"<p>m1.234E03<s>\", customDf4),\n+                Arguments.of(-0.1234, \"<p>m1.234Em01<s>\", customDf4),\n+                Arguments.of(Double.POSITIVE_INFINITY, \"<P>\\u221e<S>\", customDf4),\n+                Arguments.of(Double.NEGATIVE_INFINITY, \"<p>m\\u221e<s>\", customDf4),\n+                Arguments.of(Double.NaN, \"\\ufffd\", customDf4), \/\/ without prefix and suffix\n+                Arguments.of(0.0,  \"<P>0E00<S>\", customDf4),\n+                Arguments.of(-0.0, \"<p>m0E00<s>\", customDf4) \/\/ with the minus sign\n+        );\n@@ -172,3 +128,6 @@\n-    static void test_BigInteger() {\n-        df = new DecimalFormat();\n-        dfs = df.getDecimalFormatSymbols();\n+    \/\/ Check that negative exponent number recognized for longs\n+    @ParameterizedTest\n+    @MethodSource(\"longs\")\n+    public void longTest(Number num, String str, DecimalFormat df) {\n+        test(num, str, df);\n+    }\n@@ -176,5 +135,19 @@\n-        \/* Test with default pattern *\/\n-        test(new BigInteger(\"123456789012345678901234567890\"),\n-             \"123,456,789,012,345,678,901,234,567,890\");\n-        test(new BigInteger(\"-123456789012345678901234567890\"),\n-             \"-123,456,789,012,345,678,901,234,567,890\");\n+    \/\/ Same as doubles() data provider, but with long values\n+    \/\/ Given in the form (long, String, DecimalFormat).\n+    private static Stream<Arguments> longs() {\n+        DecimalFormat defaultDf = new DecimalFormat();\n+        DecimalFormat customDf = getDecimalFormat(\n+                \"<P>#,###<S>;<p>-#,###<s>\", 'm');\n+        return Stream.of(\n+                \/\/ Test with default pattern\n+                Arguments.of(123456789L,  \"123,456,789\", defaultDf),\n+                Arguments.of(-123456789L, \"-123,456,789\", defaultDf),\n+                Arguments.of(0L, \"0\", defaultDf),\n+                Arguments.of(-0L, \"0\", defaultDf),\n+                \/\/ Test with a pattern and the minus sign\n+                Arguments.of(123456789L,  \"<P>123,456,789<S>\", customDf),\n+                Arguments.of(-123456789L, \"<p>m123,456,789<s>\", customDf),\n+                Arguments.of(0L, \"<P>0<S>\", customDf),\n+                Arguments.of(-0L, \"<P>0<S>\", customDf)\n+        );\n+    }\n@@ -182,2 +155,6 @@\n-        test(new BigInteger(\"0\"), \"0\");\n-        test(new BigInteger(\"-0\"), \"0\");\n+    \/\/ Check that negative exponent number recognized for bigDecimals\n+    @ParameterizedTest\n+    @MethodSource(\"bigDecimals\")\n+    public void bigDecimalTest(Number num, String str, DecimalFormat df) {\n+        test(num, str, df);\n+    }\n@@ -185,6 +162,31 @@\n-        \/* Specify a pattern and the minus sign. *\/\n-        prepareFormatter(\"<P>#,###<S>;<p>-#,###<s>\", 'm');\n-        test(new BigInteger(\"123456789012345678901234567890\"),\n-             \"<P>123,456,789,012,345,678,901,234,567,890<S>\");\n-        test(new BigInteger(\"-123456789012345678901234567890\"),\n-             \"<p>m123,456,789,012,345,678,901,234,567,890<s>\");\n+    \/\/ Same as doubles() data provider, but with BigDecimal values\n+    \/\/ Given in the form (BigDecimal, String, DecimalFormat).\n+    private static Stream<Arguments> bigDecimals() {\n+        DecimalFormat defaultDf = new DecimalFormat();\n+        DecimalFormat customDf = getDecimalFormat(\n+                \"<P>#.####################E00<S>;<p>-#.####################E00<s>\", 'm');\n+        return Stream.of(\n+                \/\/ Test with default pattern\n+                Arguments.of(new BigDecimal(\"123456789012345678901234567890\"),\n+                        \"123,456,789,012,345,678,901,234,567,890\", defaultDf),\n+                Arguments.of(new BigDecimal(\"0.000000000123456789012345678901234567890\"),\n+                        \"0\", defaultDf),\n+                Arguments.of(new BigDecimal(\"-123456789012345678901234567890\"),\n+                        \"-123,456,789,012,345,678,901,234,567,890\", defaultDf),\n+                Arguments.of(new BigDecimal(\"-0.000000000123456789012345678901234567890\"),\n+                        \"-0\", defaultDf),\n+                Arguments.of(new BigDecimal(\"0\"), \"0\", defaultDf),\n+                Arguments.of(new BigDecimal(\"-0\"), \"0\", defaultDf),\n+                \/\/ Test with a pattern and the minus sign\n+                Arguments.of(new BigDecimal(\"123456789012345678901234567890\"),\n+                        \"<P>1.23456789012345678901E29<S>\", customDf),\n+                Arguments.of(new BigDecimal(\"0.000000000123456789012345678901234567890\"),\n+                        \"<P>1.23456789012345678901Em10<S>\", customDf),\n+                Arguments.of(new BigDecimal(\"-123456789012345678901234567890\"),\n+                        \"<p>m1.23456789012345678901E29<s>\", customDf),\n+                Arguments.of(new BigDecimal(\"-0.000000000123456789012345678901234567890\"),\n+                        \"<p>m1.23456789012345678901Em10<s>\", customDf),\n+                Arguments.of(new BigDecimal(\"0\"), \"<P>0E00<S>\", customDf),\n+                Arguments.of(new BigDecimal(\"-0\"), \"<P>0E00<S>\", customDf)\n+        );\n+    }\n@@ -192,2 +194,5 @@\n-        test(new BigInteger(\"0\"), \"<P>0<S>\");\n-        test(new BigInteger(\"-0\"), \"<P>0<S>\");\n+    \/\/ Check that negative exponent number recognized for bigIntegers\n+    @ParameterizedTest\n+    @MethodSource(\"bigIntegers\")\n+    public void bigIntegerTest(Number num, String str, DecimalFormat df) {\n+        test(num, str, df);\n@@ -196,5 +201,22 @@\n-    static void prepareFormatter(String pattern, char minusSign) {\n-        dfs = df.getDecimalFormatSymbols();\n-        df.applyPattern(pattern);\n-        dfs.setMinusSign(minusSign);\n-        df.setDecimalFormatSymbols(dfs);\n+    \/\/ Same as doubles() data provider, but with BigInteger values\n+    \/\/ Given in the form (BigInteger, String, DecimalFormat).\n+    private static Stream<Arguments> bigIntegers() {\n+        DecimalFormat defaultDf = new DecimalFormat();\n+        DecimalFormat customDf = getDecimalFormat(\n+                \"<P>#,###<S>;<p>-#,###<s>\", 'm');\n+        return Stream.of(\n+                \/\/ Test with default pattern\n+                Arguments.of(new BigInteger(\"123456789012345678901234567890\"),\n+                        \"123,456,789,012,345,678,901,234,567,890\", defaultDf),\n+                Arguments.of(new BigInteger(\"-123456789012345678901234567890\"),\n+                        \"-123,456,789,012,345,678,901,234,567,890\", defaultDf),\n+                Arguments.of(new BigInteger(\"0\"), \"0\", defaultDf),\n+                Arguments.of(new BigInteger(\"-0\"), \"0\", defaultDf),\n+                \/\/ Test with a pattern and the minus sign\n+                Arguments.of(new BigInteger(\"123456789012345678901234567890\"),\n+                        \"<P>123,456,789,012,345,678,901,234,567,890<S>\", customDf),\n+                Arguments.of(new BigInteger(\"-123456789012345678901234567890\"),\n+                        \"<p>m123,456,789,012,345,678,901,234,567,890<s>\", customDf),\n+                Arguments.of(new BigInteger(\"0\"), \"<P>0<S>\", customDf),\n+                Arguments.of(new BigInteger(\"-0\"), \"<P>0<S>\", customDf)\n+        );\n@@ -203,1 +225,3 @@\n-    static void test(Number num, String str) {\n+    \/\/ Check that the formatted value is correct and also check that\n+    \/\/ it can be round-tripped via parse() and format()\n+    private static void test(Number num, String str, DecimalFormat df) {\n@@ -205,10 +229,2 @@\n-        if (!formatted.equals(str)) {\n-            err = true;\n-            System.err.println(\"    DecimalFormat format(\" +\n-                               num.getClass().getName() +\n-                               \") error: \\n\\tnumber: \" + num +\n-                               \"\\n\\tminus sign: \" + dfs.getMinusSign() +\n-                               \"\\n\\tgot:        \" + formatted +\n-                               \"\\n\\texpected:   \" + str);\n-            return;\n-        }\n+        assertEquals(str, formatted, String.format(\"DecimalFormat format(%s) \" +\n+                \"Error: number: %s, minus sign: %s\", num.getClass().getName(), num, df.getDecimalFormatSymbols().getMinusSign()));\n@@ -219,0 +235,6 @@\n+        testRoundTrip(formatted, str, num, df);\n+    }\n+\n+    \/\/ Test that a parsed value can be round-tripped via format() and parse()\n+    private static void testRoundTrip(String formatted, String str,\n+                                      Number num, DecimalFormat df) {\n@@ -224,12 +246,11 @@\n-            if (!parsed1.equals(parsed2)) {\n-                err = true;\n-                System.err.println(\"    DecimalFormat roundtrip parse(\" +\n-                                   num.getClass().getName() +\n-                                   \") error: \\n\\toriginal number:  \" + str +\n-                                   \"\\n\\tparsed number:    \" + parsed1 +\n-                                   \"  (\" + parsed1.getClass().getName() + \")\" +\n-                                   \"\\n\\tformatted number: \" + formatted +\n-                                   \"\\n\\tre-parsed number: \" + parsed2 +\n-                                   \"  (\" + parsed2.getClass().getName() + \")\" +\n-                                   \"\\n\\tminus sign: \" + dfs.getMinusSign());\n-            }\n+            assertEquals(parsed2, parsed1, \"\"\"\n+                            DecimalFormat round trip parse(%s) error:\n+                                original number: %s\n+                                parsed number: %s\n+                                (%s)\n+                                formatted number: %s\n+                                re-parsed number: %s\n+                                (%s)\n+                                minus sign: %s\n+                            \"\"\".formatted(num.getClass().getName(), str, parsed1, parsed1.getClass().getName(),\n+                                    formatted, parsed2, parsed2.getClass().getName(), df.getDecimalFormatSymbols().getMinusSign()));\n@@ -238,11 +259,11 @@\n-            err = true;\n-            System.err.println(\"    DecimalFormat parse(\" +\n-                               num.getClass().getName() +\n-                               \") threw an Exception:  \" + e.getMessage() +\n-                               \"\\n\\toriginal number:  \" + str +\n-                               \"\\n\\tparsed number   : \" + parsed1 +\n-                               \"  (\" + parsed1.getClass().getName() + \")\" +\n-                               \"\\n\\tformatted number: \" + formatted +\n-                               \"\\n\\tre-parsed number: \" + parsed2 +\n-                               \"  (\" + parsed2.getClass().getName() + \")\" +\n-                               \"\\n\\tminus sign: \" + dfs.getMinusSign());\n+            fail(\"\"\"\n+                    DecimalFormat parse(%s) threw an Exception: %s\n+                        original number: %s\n+                        parsed number: %s\n+                        (%s)\n+                        formatted number: %s\n+                        re-parsed number: %s\n+                        (%s)\n+                        minus sign: %s\n+                    \"\"\".formatted(num.getClass().getName(), e.getMessage(), str, parsed1, parsed1.getClass().getName(),\n+                            formatted, parsed2, parsed2.getClass().getName(), df.getDecimalFormatSymbols().getMinusSign()));\n@@ -251,0 +272,10 @@\n+\n+    \/\/ Set up custom DecimalFormat with DecimalFormatSymbols\n+    private static DecimalFormat getDecimalFormat(String pattern, char minusSign) {\n+        DecimalFormat df = new DecimalFormat();\n+        DecimalFormatSymbols dfs = df.getDecimalFormatSymbols();\n+        df.applyPattern(pattern);\n+        dfs.setMinusSign(minusSign);\n+        df.setDecimalFormatSymbols(dfs);\n+        return df;\n+    }\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug4838107.java","additions":214,"deletions":183,"binary":false,"changes":397,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n- * and which are between Long.MIN_VALUE and Long.MAX_VALUE are returned as Long(not double).\n+ *          and which are between Long.MIN_VALUE and Long.MAX_VALUE are returned\n+ *          as Long(not double).\n+ * @run junit Bug4944439\n@@ -31,2 +33,0 @@\n-import java.math.BigDecimal;\n-import java.math.BigInteger;\n@@ -34,0 +34,1 @@\n+import java.util.ArrayList;\n@@ -35,0 +36,1 @@\n+import java.util.stream.Stream;\n@@ -36,4 +38,5 @@\n-public class Bug4944439 {\n-\n-    static boolean err = false;\n-    static DecimalFormat df;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n@@ -41,4 +44,3 @@\n-    public static void main(String[] args) throws Exception {\n-\n-        Locale defaultLoc = Locale.getDefault();\n-        Locale.setDefault(Locale.US);\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertInstanceOf;\n@@ -46,3 +48,1 @@\n-        df = new DecimalFormat();\n-        String s = \"-9223372036854775809\";      \/\/ Long.MIN_VALUE-1\n-        check_Double(s);\n+public class Bug4944439 {\n@@ -50,3 +50,3 @@\n-        test(Long.MIN_VALUE, Long.MIN_VALUE+10);\n-        test(-10, 10);\n-        test(Long.MAX_VALUE-10, Long.MAX_VALUE-1);\n+    \/\/ Save JVM default locale\n+    private static final Locale savedLocale = Locale.getDefault();\n+    private static final DecimalFormat df = new DecimalFormat();\n@@ -54,4 +54,5 @@\n-        s = \"9223372036854775807.00\";   \/\/ Long.MAX_VALUE\n-        check_Long(s);\n-        s = \"9223372036854775808\";      \/\/ Long.MAX_VALUE+1\n-        check_Double(s);\n+    \/\/ Set JVM default locale to US for testing\n+    @BeforeAll\n+    static void initAll() {\n+        Locale.setDefault(Locale.US);\n+    }\n@@ -59,4 +60,5 @@\n-        s = \"-0.0\";\n-        check_Double(s);\n-        s = \"0.0\";\n-        check_Long(s);\n+    \/\/ Restore JVM default locale\n+    @AfterAll\n+    static void tearDownAll() {\n+        Locale.setDefault(savedLocale);\n+    }\n@@ -64,1 +66,14 @@\n-        Locale.setDefault(defaultLoc);\n+    \/\/ Check return type and value returned by DecimalFormat.parse() for longs\n+    @ParameterizedTest\n+    @MethodSource(\"longs\")\n+    public void parseLongTest(String s) {\n+        \/\/ This was originally intended to ensure a ParseException is not thrown\n+        Number parsedNumber = assertDoesNotThrow(() -> df.parse(s),\n+                \"DecimalFormat.parse(\\\"%s\\\") should not throw an Exception\");\n+        assertInstanceOf(Long.class, parsedNumber,\n+                \"DecimalFormat.parse(\\\"%s\\\") did not return Long\");\n+        \/\/ Grab integer portion of value\n+        Long expectedVal = Long.valueOf(s.substring(0, s.indexOf('.')));\n+        assertEquals(parsedNumber, expectedVal,\n+                \"DecimalFormat.parse(\\\"%s\\\") returned numerically incorrect value\");\n+    }\n@@ -66,3 +81,9 @@\n-        if (err) {\n-            throw new RuntimeException(\"Wrong parsing with DecimalFormat\");\n-        }\n+    \/\/ Test some values between Long.MIN_VALUE and Long.MAX_VALUE\n+    private static Stream<String> longs() {\n+        ArrayList<String> longs = new ArrayList<>();\n+        addLongData(Long.MIN_VALUE, Long.MIN_VALUE+10, longs);\n+        addLongData(-10, 10, longs);\n+        addLongData(Long.MAX_VALUE-10, Long.MAX_VALUE-1, longs);\n+        longs.add(\"9223372036854775807.00\");\n+        longs.add(\"0.0\");\n+        return longs.stream();\n@@ -71,1 +92,2 @@\n-    private static void test(long from, long to) throws Exception {\n+    \/\/ Utility to add values between parameters(long, to) to testLongs ArrayList\n+    private static void addLongData(long from, long to, ArrayList<String> testLongs){\n@@ -73,1 +95,1 @@\n-            check_Long(Long.toString(l) + \".00\");\n+            testLongs.add(l + \".00\");\n@@ -77,16 +99,12 @@\n-    private static void check_Long(String s) throws Exception {\n-        Number number = df.parse(s);\n-        if (!(number instanceof Long)) {\n-            err = true;\n-            System.err.println(\"Failed: DecimalFormat.parse(\\\"\" + s +\n-                \"\\\") should return a Long, but returned a \" +\n-                number.getClass().getName());\n-        }\n-\n-        int index = s.indexOf('.');\n-        Long l = Long.valueOf(s.substring(0, index));\n-        if (!l.equals(number)) {\n-            err = true;\n-            System.err.println(\"Failed: DecimalFormat.parse(\" + s +\n-                \") should return a Long(\" + l + \"), but returned \" + number);\n-        }\n+    \/\/ Check return type and value returned by DecimalFormat.parse() for doubles\n+    @ParameterizedTest\n+    @MethodSource(\"doubles\")\n+    public void parseDoubleTest(String s) {\n+        \/\/ This was originally intended to ensure a ParseException is not thrown\n+        Number parsedNumber = assertDoesNotThrow(() -> df.parse(s),\n+                \"DecimalFormat.parse(\\\"%s\\\") should not throw an Exception\");\n+        assertInstanceOf(Double.class, parsedNumber,\n+                \"DecimalFormat.parse(\\\"%s\\\") did not return Double\");\n+        Double expectedVal = Double.valueOf(s);\n+        assertEquals(parsedNumber, expectedVal,\n+                \"DecimalFormat.parse(\\\"%s\\\") returned numerically incorrect value\");\n@@ -95,15 +113,7 @@\n-    private static void check_Double(String s) throws Exception {\n-        Number number = df.parse(s);\n-        if (!(number instanceof Double)) {\n-            err = true;\n-            System.err.println(\"Failed: DecimalFormat.parse(\\\"\" + s +\n-                \"\\\") should return a Double, but returned a \" +\n-                number.getClass().getName());\n-        }\n-\n-        Double d = Double.valueOf(s);\n-        if (!d.equals(number)) {\n-            err = true;\n-            System.err.println(\"Failed: DecimalFormat.parse(\" + s +\n-                \") should return a Double(\" + d + \"), but returned \" + number);\n-        }\n+    \/\/ Check values not between Long.MIN_VALUE and Long.MAX_VALUE\n+    private static Stream<String> doubles() {\n+        return Stream.of(\n+                \"-9223372036854775809\", \/\/ Long.MIN_VALUE-1\n+                \"9223372036854775808\", \/\/ Long.MAX_VALUE+1\n+                \"-0.0\"\n+        );\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug4944439.java","additions":73,"deletions":63,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -27,1 +27,3 @@\n- * @summary Make sure that any subclass of Number can be formatted using DecimalFormat.format().\n+ * @summary Make sure that any subclass of Number can be formatted using\n+ *          DecimalFormat.format() without throwing an exception.\n+ * @run junit Bug4990596\n@@ -32,0 +34,4 @@\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+\n@@ -34,2 +40,6 @@\n-    public static void main(String[] args) {\n-        new DecimalFormat().format(new MutableInteger(0));\n+    \/\/ Test that a custom subclass of Number can be formatted by\n+    \/\/ DecimalFormat without throwing an IllegalArgumentException\n+    @Test\n+    public void formatSubclassedNumberTest() {\n+        assertDoesNotThrow(() -> new DecimalFormat().format(new MutableInteger(0)),\n+                \"DecimalFormat.format() should support subclasses of Number\");\n@@ -38,0 +48,2 @@\n+    \/\/ A custom subclass of Number. Prior to this fix, if an instance of this\n+    \/\/ class was formatted by DecimalFormat, an exception would be thrown.\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug4990596.java","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+ *          That is, make sure they are not treated as a double when formatted\n+ *          anymore (which can result in the loss of precision).\n@@ -28,0 +30,1 @@\n+ * @run junit Bug6278616\n@@ -34,1 +37,5 @@\n-import java.util.Locale;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -38,3 +45,1 @@\n-    static final int[] ints = {\n-        Integer.MIN_VALUE, -1, 0, 1, Integer.MAX_VALUE\n-    };\n+    private static final NumberFormat nf = NumberFormat.getInstance();\n@@ -42,3 +47,10 @@\n-    static final long[] longs = {\n-        Long.MIN_VALUE, -1, 0, 1, Long.MAX_VALUE\n-    };\n+    \/\/ Test that NumberFormat formats numerically equivalent int\n+    \/\/ and AtomicInteger values the same\n+    @ParameterizedTest\n+    @MethodSource(\"ints\")\n+    public void formattedAtomicIntTest(int testInt) {\n+        String formattedInt = nf.format(testInt);\n+        String formattedAtomicInt = nf.format(new AtomicInteger(testInt));\n+        assertEquals(formattedAtomicInt, formattedInt, \"Formatting numerically\" +\n+                \" equivalent AtomicInteger and int should produce the same String value\");\n+    }\n@@ -46,2 +58,4 @@\n-    public static void main(String[] args) {\n-        NumberFormat nf = NumberFormat.getInstance();\n+    \/\/ Various int values\n+    private static int[] ints() {\n+        return new int[] { Integer.MIN_VALUE, -1, 0, 1, Integer.MAX_VALUE};\n+    }\n@@ -49,9 +63,10 @@\n-        for (int j = 0; j < ints.length; j++) {\n-            String s_i = nf.format(ints[j]);\n-            String s_ai = nf.format(new AtomicInteger(ints[j]));\n-            if (!s_i.equals(s_ai)) {\n-                throw new RuntimeException(\"format(AtomicInteger \" + s_ai +\n-                                           \") doesn't equal format(Integer \" +\n-                                           s_i + \")\");\n-            }\n-        }\n+    \/\/ Test that NumberFormat formats numerically equivalent long\n+    \/\/ and AtomicLong values the same\n+    @ParameterizedTest\n+    @MethodSource(\"longs\")\n+    public void formattedAtomicLongTest(long testLong) {\n+        String formattedLong = nf.format(testLong);\n+        String formattedAtomicLong = nf.format(new AtomicLong(testLong));\n+        assertEquals(formattedAtomicLong, formattedLong, \"Formatting numerically\" +\n+                \" equivalent AtomicLong and long should produce the same String value\");\n+    }\n@@ -59,9 +74,3 @@\n-        for (int j = 0; j < longs.length; j++) {\n-            String s_l = nf.format(longs[j]);\n-            String s_al = nf.format(new AtomicLong(longs[j]));\n-            if (!s_l.equals(s_al)) {\n-                throw new RuntimeException(\"format(AtomicLong \" + s_al +\n-                                           \") doesn't equal format(Long \" +\n-                                           s_l + \")\");\n-            }\n-        }\n+    \/\/ Various long values\n+    private static long[] longs() {\n+        return new long[] { Long.MIN_VALUE, -1, 0, 1, Long.MAX_VALUE};\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug6278616.java","additions":37,"deletions":28,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+ * @run junit Bug8132125\n@@ -31,2 +32,6 @@\n-import java.text.*;\n-import java.util.*;\n+import java.text.NumberFormat;\n+import java.util.Locale;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -35,1 +40,4 @@\n-    public static void main(String[] args) {\n+\n+    \/\/ Ensure the CLDRConverter does not omit the Swiss number elements\n+    @Test\n+    public void swissNumElementsTest() {\n@@ -39,1 +47,2 @@\n-        String expected = \"54\\u2019839\\u2019483.142\"; \/\/ i.e. \"\\u2019\" as decimal separator, \"\\u2019\" as grouping separator\n+        \/\/ \"\\u002E\" as decimal separator, \"\\u2019\" as grouping separator\n+        String expected = \"54\\u2019839\\u2019483.142\";\n@@ -41,3 +50,1 @@\n-        if (!actual.equals(expected)) {\n-            throw new RuntimeException(\"incorrect for de_CH: \" + expected + \" vs. actual \" + actual);\n-        }\n+        assertEquals(expected, actual, \"incorrect number elements for de_CH\");\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/Bug8132125.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ *          Tests both COMPAT and CLDR data.\n@@ -29,2 +30,2 @@\n- * @run main\/othervm -Djava.locale.providers=COMPAT CurrencyFormat COMPAT\n- * @run main\/othervm -Djava.locale.providers=CLDR CurrencyFormat CLDR\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT CurrencyFormat\n+ * @run junit\/othervm -Djava.locale.providers=CLDR CurrencyFormat\n@@ -35,0 +36,3 @@\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n@@ -43,0 +47,7 @@\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -46,1 +57,4 @@\n-    private static boolean isCompat;\n+    \/\/ Expected data is switched depending on COMPAT or CLDR\n+    \/\/ currencySymbolsTest() is only ran for COMPAT\n+    private static final boolean isCompat =\n+            \"COMPAT\".equals(System.getProperty(\"java.locale.providers\"));\n@@ -48,4 +62,15 @@\n-    public static void main(String[] args) throws Exception {\n-        isCompat = \"COMPAT\".equals(args[0]);\n-        testFormatting();\n-        testSymbols();\n+    \/\/ Tests the formatting of data for COMPAT + CLDR under various currencies\n+    \/\/ Using a NumberFormat generated by getCurrencyInstance()\n+    @ParameterizedTest\n+    @MethodSource(\"currencyFormatDataProvider\")\n+    public void currencyFormatTest(String expected, Currency currency,\n+                                   NumberFormat format, Locale locale) {\n+        if (currency != null) {\n+            format.setCurrency(currency);\n+            int digits = currency.getDefaultFractionDigits();\n+            format.setMinimumFractionDigits(digits);\n+            format.setMaximumFractionDigits(digits);\n+        }\n+        String result = format.format(1234.56);\n+        assertEquals(expected, result, String.format(\"Failed with locale: %s%s\",\n+                locale, (currency == null ? \", default currency\" : (\", currency: \" + currency))));\n@@ -54,2 +79,4 @@\n-    static void testFormatting() {\n-        boolean failed = false;\n+    \/\/ Generate a combination of expected data for 1234.56 formatted\n+    \/\/ under various currencies\/locale provider\/locale\n+    private static Stream<Arguments> currencyFormatDataProvider() {\n+        ArrayList<Arguments> data = new ArrayList<Arguments>();\n@@ -57,7 +84,7 @@\n-            Locale.US,\n-            Locale.JAPAN,\n-            Locale.GERMANY,\n-            Locale.ITALY,\n-            Locale.of(\"it\", \"IT\", \"EURO\"),\n-            Locale.forLanguageTag(\"de-AT\"),\n-            Locale.forLanguageTag(\"fr-CH\"),\n+                Locale.US,\n+                Locale.JAPAN,\n+                Locale.GERMANY,\n+                Locale.ITALY,\n+                Locale.of(\"it\", \"IT\", \"EURO\"),\n+                Locale.forLanguageTag(\"de-AT\"),\n+                Locale.forLanguageTag(\"fr-CH\"),\n@@ -66,5 +93,5 @@\n-            null,\n-            Currency.getInstance(\"USD\"),\n-            Currency.getInstance(\"JPY\"),\n-            Currency.getInstance(\"DEM\"),\n-            Currency.getInstance(\"EUR\"),\n+                null,\n+                Currency.getInstance(\"USD\"),\n+                Currency.getInstance(\"JPY\"),\n+                Currency.getInstance(\"DEM\"),\n+                Currency.getInstance(\"EUR\"),\n@@ -72,8 +99,8 @@\n-        String[][] expecteds = {\n-            {\"$1,234.56\", \"$1,234.56\", \"JPY1,235\", \"DEM1,234.56\", \"EUR1,234.56\"},\n-            {\"\\uFFE51,235\", \"USD1,234.56\", \"\\uFFE51,235\", \"DEM1,234.56\", \"EUR1,234.56\"},\n-            {\"1.234,56 \\u20AC\", \"1.234,56 USD\", \"1.235 JPY\", \"1.234,56 DM\", \"1.234,56 \\u20AC\"},\n-            {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n-            {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n-            {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n-            {\"SFr. 1'234.56\", \"USD 1'234.56\", \"JPY 1'235\", \"DEM 1'234.56\", \"EUR 1'234.56\"},\n+        String[][] expectedCOMPATData = {\n+                {\"$1,234.56\", \"$1,234.56\", \"JPY1,235\", \"DEM1,234.56\", \"EUR1,234.56\"},\n+                {\"\\uFFE51,235\", \"USD1,234.56\", \"\\uFFE51,235\", \"DEM1,234.56\", \"EUR1,234.56\"},\n+                {\"1.234,56 \\u20AC\", \"1.234,56 USD\", \"1.235 JPY\", \"1.234,56 DM\", \"1.234,56 \\u20AC\"},\n+                {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n+                {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n+                {\"\\u20AC 1.234,56\", \"USD 1.234,56\", \"JPY 1.235\", \"DEM 1.234,56\", \"\\u20AC 1.234,56\"},\n+                {\"SFr. 1'234.56\", \"USD 1'234.56\", \"JPY 1'235\", \"DEM 1'234.56\", \"EUR 1'234.56\"},\n@@ -81,8 +108,8 @@\n-        String[][] expecteds_cldr = {\n-            {\"$1,234.56\", \"$1,234.56\", \"\\u00a51,235\", \"DEM1,234.56\", \"\\u20ac1,234.56\"},\n-            {\"\\uFFE51,235\", \"$1,234.56\", \"\\uFFE51,235\", \"DEM1,234.56\", \"\\u20ac1,234.56\"},\n-            {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0$\", \"1.235\\u00a0\\u00a5\", \"1.234,56\\u00a0DM\", \"1.234,56\\u00a0\\u20ac\"},\n-            {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0USD\", \"1.235\\u00a0JPY\", \"1.234,56\\u00a0DEM\", \"1.234,56\\u00a0\\u20ac\"},\n-            {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0USD\", \"1.235\\u00a0JPY\", \"1.234,56\\u00a0DEM\", \"1.234,56\\u00a0\\u20ac\"},\n-            {\"\\u20ac\\u00a01.234,56\", \"$\\u00a01.234,56\", \"\\u00a5\\u00a01.235\", \"DM\\u00a01.234,56\", \"\\u20ac\\u00a01.234,56\"},\n-            {\"1\\u202f234.56\\u00a0CHF\", \"1\\u202f234.56\\u00a0$US\", \"1\\u202f235\\u00a0JPY\", \"1\\u202f234.56\\u00a0DEM\", \"1\\u202f234.56\\u00a0\\u20ac\"},\n+        String[][] expectedCLDRData = {\n+                {\"$1,234.56\", \"$1,234.56\", \"\\u00a51,235\", \"DEM1,234.56\", \"\\u20ac1,234.56\"},\n+                {\"\\uFFE51,235\", \"$1,234.56\", \"\\uFFE51,235\", \"DEM1,234.56\", \"\\u20ac1,234.56\"},\n+                {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0$\", \"1.235\\u00a0\\u00a5\", \"1.234,56\\u00a0DM\", \"1.234,56\\u00a0\\u20ac\"},\n+                {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0USD\", \"1.235\\u00a0JPY\", \"1.234,56\\u00a0DEM\", \"1.234,56\\u00a0\\u20ac\"},\n+                {\"1.234,56\\u00a0\\u20ac\", \"1.234,56\\u00a0USD\", \"1.235\\u00a0JPY\", \"1.234,56\\u00a0DEM\", \"1.234,56\\u00a0\\u20ac\"},\n+                {\"\\u20ac\\u00a01.234,56\", \"$\\u00a01.234,56\", \"\\u00a5\\u00a01.235\", \"DM\\u00a01.234,56\", \"\\u20ac\\u00a01.234,56\"},\n+                {\"1\\u202f234.56\\u00a0CHF\", \"1\\u202f234.56\\u00a0$US\", \"1\\u202f235\\u00a0JPY\", \"1\\u202f234.56\\u00a0DEM\", \"1\\u202f234.56\\u00a0\\u20ac\"},\n@@ -90,1 +117,0 @@\n-\n@@ -96,15 +122,2 @@\n-                String expected = isCompat ? expecteds[i][j] : expecteds_cldr[i][j];\n-                if (currency != null) {\n-                    format.setCurrency(currency);\n-                    int digits = currency.getDefaultFractionDigits();\n-                    format.setMinimumFractionDigits(digits);\n-                    format.setMaximumFractionDigits(digits);\n-                }\n-                String result = format.format(1234.56);\n-                if (!result.equals(expected)) {\n-                    failed = true;\n-                    System.out.println(\"FAIL: Locale \" + locale\n-                        + (currency == null ? \", default currency\" : (\", currency: \" + currency))\n-                        + \", expected: \" + expected\n-                        + \", actual: \" + result);\n-                }\n+                String expected = isCompat ? expectedCOMPATData[i][j] : expectedCLDRData[i][j];\n+                data.add(Arguments.of(expected, currency, format, locale));\n@@ -113,4 +126,1 @@\n-\n-        if (failed) {\n-            throw new RuntimeException();\n-        }\n+        return data.stream();\n@@ -119,1 +129,5 @@\n-    static void testSymbols() throws Exception {\n+    \/\/ Compares the expected currency symbol of a locale to the value returned by\n+    \/\/ DecimalFormatSymbols.getCurrencySymbol().\n+    @ParameterizedTest\n+    @MethodSource(\"currencySymbolsDataProvider\")\n+    public void currencySymbolsTest(String expected, Locale locale) throws ParseException {\n@@ -121,2 +135,1 @@\n-            \/\/ For COMPAT only.\n-            return;\n+            return; \/\/ For COMPAT only.\n@@ -124,0 +137,13 @@\n+        if (expected == null) {\n+            System.out.println(\"Warning: No expected currency symbol defined for locale \" + locale);\n+        } else {\n+            \/\/ Reserved for when a currency will change its symbol at a given time in the future\n+            if (expected.contains(\";\")) {\n+                expected = getFutureSymbol(expected);\n+            }\n+            DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n+            String result = symbols.getCurrencySymbol();\n+            assertEquals(expected, result, \"Wrong currency symbol for locale \" +\n+                        locale + \", expected: \" + expected + \", got: \" + result);\n+        }\n+    }\n@@ -125,1 +151,6 @@\n-        FileInputStream stream = new FileInputStream(new File(System.getProperty(\"test.src\", \".\"), \"CurrencySymbols.properties\"));\n+    \/\/ Grabs the custom CurrencySymbols.properties and loads the file into a Properties\n+    \/\/ instance. Building the data set, which consists of the currency symbol for the locale.\n+    private static Stream<Arguments> currencySymbolsDataProvider() throws IOException {\n+        ArrayList<Arguments> data = new ArrayList<Arguments>();\n+        FileInputStream stream = new FileInputStream(new File(\n+                System.getProperty(\"test.src\", \".\"), \"CurrencySymbols.properties\"));\n@@ -128,2 +159,0 @@\n-        SimpleDateFormat format = null;\n-\n@@ -131,4 +160,1 @@\n-        for (int i = 0; i < locales.length; i++) {\n-            Locale locale = locales[i];\n-            DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n-            String result = symbols.getCurrencySymbol();\n+        for (Locale locale : locales) {\n@@ -136,0 +162,4 @@\n+            data.add(Arguments.of(expected, locale));\n+        }\n+        return data.stream();\n+    }\n@@ -137,25 +167,11 @@\n-            if (expected == null) {\n-                System.out.println(\"Warning: No expected currency symbol defined for locale \" + locale);\n-            } else {\n-                    if (expected.contains(\";\")) {\n-                        StringTokenizer tokens = new StringTokenizer(expected, \";\");\n-                        int tokensCount = tokens.countTokens();\n-\n-                        if (tokensCount == 3) {\n-                            expected = tokens.nextToken();\n-                            if (format == null) {\n-                                format = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\", Locale.US);\n-                                format.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n-                                format.setLenient(false);\n-                            }\n-\n-                            if (format.parse(tokens.nextToken()).getTime() < System.currentTimeMillis()) {\n-                                expected = tokens.nextToken();\n-                            }\n-                        }\n-                    }\n-\n-                    if (!expected.equals(result)) {\n-                        throw new RuntimeException(\"Wrong currency symbol for locale \" +\n-                            locale + \", expected: \" + expected + \", got: \" + result);\n-                    }\n+    \/\/ Utility to grab the future symbol if in the right format and date cut-over allows\n+    private static String getFutureSymbol(String expected) throws ParseException {\n+        StringTokenizer tokens = new StringTokenizer(expected, \";\");\n+        int tokensCount = tokens.countTokens();\n+        if (tokensCount == 3) {\n+            expected = tokens.nextToken();\n+            SimpleDateFormat format = new SimpleDateFormat(\"yyyy-MM-dd-HH-mm-ss\", Locale.US);\n+            format.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+            format.setLenient(false);\n+            if (format.parse(tokens.nextToken()).getTime() < System.currentTimeMillis()) {\n+                expected = tokens.nextToken();\n@@ -164,0 +180,1 @@\n+        return expected;\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/CurrencyFormat.java","additions":109,"deletions":92,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/**\n+\/*\n@@ -27,1 +27,0 @@\n- * @summary Currency decimal marker incorrect for Peru.\n@@ -29,1 +28,2 @@\n- * @run main\/othervm -Djava.locale.providers=JRE TestPeruCurrencyFormat\n+ * @summary Currency decimal marker incorrect for Peru (COMPAT).\n+ * @run junit\/othervm -Djava.locale.providers=COMPAT TestPeruCurrencyFormat\n@@ -35,0 +35,4 @@\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n@@ -37,1 +41,3 @@\n-    public static void main(String[] args) {\n+    \/\/ Confirm correct decimal marker for Peru locale on COMPAT\n+    @Test\n+    public void peruDecimalMarketCOMPAT() {\n@@ -42,4 +48,2 @@\n-\n-        if (!s.equals(expected)) {\n-            throw new RuntimeException(\"Currency format for Peru failed, expected \" + expected + \", got \" + s);\n-        }\n+        assertEquals(expected, s,\n+                \"Currency format for Peru failed, expected \" + expected + \", got \" + s);\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/TestPeruCurrencyFormat.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"}]}