{"files":[{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +50,2 @@\n+    private static int init = 0;\n+    private static int limit = SIZE;\n@@ -104,0 +107,5 @@\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\"},\n+        counts = {IRNode.POPULATE_INDEX, \"=0\"})\n+    \/\/ The ConvI2L can be split through the AddI, creating a mix of\n+    \/\/ ConvI2L(AddI) and AddL(ConvI2L) cases, which do not vectorize.\n+    \/\/ See: JDK-8332878\n@@ -112,0 +120,59 @@\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\"},\n+        counts = {IRNode.POPULATE_INDEX, \">0\"})\n+    \/\/ The variable init\/limit has the consequence that we do not split\n+    \/\/ the ConvI2L through the AddI.\n+    public long[] fillLongArray2() {\n+        long[] res = new long[SIZE];\n+        for (int i = init; i < limit; i++) {\n+            res[i] = i;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\"},\n+        counts = {IRNode.POPULATE_INDEX, \"=0\"})\n+    \/\/ See: JDK-8332878\n+    public float[] fillFloatArray() {\n+        float[] res = new float[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = i;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\"},\n+        counts = {IRNode.POPULATE_INDEX, \">0\"})\n+    public float[] fillFloatArray2() {\n+        float[] res = new float[SIZE];\n+        for (int i = init; i < limit; i++) {\n+            res[i] = i;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\"},\n+        counts = {IRNode.POPULATE_INDEX, \"=0\"})\n+    \/\/ See: JDK-8332878\n+    public double[] fillDoubleArray() {\n+        double[] res = new double[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = i;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\"},\n+        counts = {IRNode.POPULATE_INDEX, \">0\"})\n+    public double[] fillDoubleArray2() {\n+        double[] res = new double[SIZE];\n+        for (int i = init; i < limit; i++) {\n+            res[i] = i;\n+        }\n+        return res;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayIndexFillTest.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +54,1 @@\n+    private static       int zero = 0;\n@@ -117,0 +119,30 @@\n+    @Test\n+    \/\/ Tests that we add a ConvI2L for size, when converting it to long for\n+    \/\/ the rotateRight rotation input.\n+    \/\/ However, it currently only seems to vectorize in OSR, so we cannot add IR rules.\n+    public long[] longExplicitRotateWithPopulateIndex() {\n+        long[] res = new long[SIZE];\n+        for (int i = 0; i < SIZE; i++) {\n+            res[i] = Long.rotateRight(i, \/* some rotation value*\/ size);\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\"},\n+        counts = {IRNode.STORE_VECTOR, \">0\"})\n+    @IR(applyIfCPUFeature = {\"avx512f\", \"true\"},\n+        counts = {IRNode.ROTATE_RIGHT_V, \">0\"})\n+    @IR(applyIfCPUFeatureOr = {\"sve\", \"true\", \"avx2\", \"true\"},\n+        counts = {IRNode.POPULATE_INDEX, \">0\"})\n+    \/\/ The unknown init\/limit values make sure that the rotation does fold badly\n+    \/\/ like in longExplicitRotateWithPopulateIndex.\n+    public long[] longExplicitRotateWithPopulateIndex2() {\n+        long[] res = new long[SIZE];\n+        for (int i = zero; i < size; i++) {\n+            res[i] = Long.rotateRight(i, \/* some rotation value*\/ size);\n+        }\n+        return res;\n+    }\n+\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/runner\/ArrayShiftOpTest.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"}]}