{"files":[{"patch":"@@ -4,1 +4,1 @@\n-version=21.0.5\n+version=21.0.6\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-DEFAULT_VERSION_UPDATE=5\n+DEFAULT_VERSION_UPDATE=6\n@@ -36,1 +36,1 @@\n-DEFAULT_VERSION_DATE=2024-10-15\n+DEFAULT_VERSION_DATE=2025-01-21\n","filename":"make\/conf\/version-numbers.conf","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -87,2 +87,2 @@\n-reg_def R2      ( NS,  SOE, Op_RegI, 2,  x2->as_VMReg()         ); \/\/ sp\n-reg_def R2_H    ( NS,  SOE, Op_RegI, 2,  x2->as_VMReg()->next() );\n+reg_def R2      ( NS,  NS,  Op_RegI, 2,  x2->as_VMReg()         ); \/\/ sp\n+reg_def R2_H    ( NS,  NS,  Op_RegI, 2,  x2->as_VMReg()->next() );\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3358,0 +3358,1 @@\n+  assert(aligned_base != nullptr, \"Did not manage to re-map after %d attempts (size %zu, alignment %zu, file descriptor %d)\", max_attempts, size, alignment, file_desc);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -83,2 +83,1 @@\n-  void print_action_queue(outputStream* st) {\n-    SeenThread* seen = this;\n+  static void print_action_queue(SeenThread* seen, outputStream* st) {\n@@ -330,1 +329,1 @@\n-  loadInstanceThreadQ()->print_action_queue(st);\n+  SeenThread::print_action_queue(loadInstanceThreadQ(), st);\n@@ -333,1 +332,1 @@\n-  superThreadQ()->print_action_queue(st);\n+  SeenThread::print_action_queue(superThreadQ(), st);\n@@ -336,1 +335,1 @@\n-  defineThreadQ()->print_action_queue(st);\n+  SeenThread::print_action_queue(defineThreadQ(), st);\n","filename":"src\/hotspot\/share\/classfile\/placeholders.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"sanitizers\/ub.hpp\"\n@@ -341,0 +342,1 @@\n+  ATTRIBUTE_NO_UBSAN\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n-* @summary Test x86_64 intrinsic for divideUnsigned() and remainderUnsigned() methods for Integer\n-* @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+* @summary Test intrinsic for divideUnsigned() and remainderUnsigned() methods for Integer\n+* @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n@@ -76,1 +76,1 @@\n-    @IR(counts = {IRNode.UDIV_I, \">= 1\"}) \/\/ Atleast one UDivI node is generated if intrinsic is used\n+    @IR(counts = {IRNode.UDIV_I, \">= 1\"}) \/\/ At least one UDivI node is generated if intrinsic is used\n@@ -90,1 +90,1 @@\n-    @IR(counts = {IRNode.UMOD_I, \">= 1\"}) \/\/ Atleast one UModI node is generated if intrinsic is used\n+    @IR(counts = {IRNode.UMOD_I, \">= 1\"}) \/\/ At least one UModI node is generated if intrinsic is used\n@@ -105,1 +105,2 @@\n-    @IR(counts = {IRNode.UDIV_MOD_I, \">= 1\"}) \/\/ Atleast one UDivModI node is generated if intrinsic is used\n+    @IR(applyIfPlatform = {\"x64\", \"true\"},\n+        counts = {IRNode.UDIV_MOD_I, \">= 1\"}) \/\/ At least one UDivModI node is generated if intrinsic is used\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestIntegerUnsignedDivMod.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n-* @summary Test x86_64 intrinsic for divideUnsigned() and remainderUnsigned() methods for Long\n-* @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+* @summary Test intrinsic for divideUnsigned() and remainderUnsigned() methods for Long\n+* @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n@@ -143,1 +143,2 @@\n-    @IR(counts = {IRNode.UDIV_MOD_L, \">= 1\"}) \/\/ Atleast one UDivModL node is generated if intrinsic is used\n+    @IR(applyIfPlatform = {\"x64\", \"true\"},\n+        counts = {IRNode.UDIV_MOD_L, \">= 1\"}) \/\/ At least one UDivModL node is generated if intrinsic is used\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/TestLongUnsignedDivMod.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @requires os.arch != \"ppc64le\"\n@@ -54,0 +55,1 @@\n+ * @requires os.arch != \"ppc64le\"\n@@ -66,0 +68,1 @@\n+ * @requires os.arch != \"ppc64le\"\n@@ -78,0 +81,1 @@\n+ * @requires os.arch != \"ppc64le\"\n@@ -90,0 +94,1 @@\n+ * @requires os.arch != \"ppc64le\"\n@@ -251,6 +256,0 @@\n-        \/\/ For similar reasons, we skip the test on ppc platforms, since there the smaps\n-        \/\/  format may follow a different logic.\n-        if (Platform.isPPC()) {\n-            throw new SkippedException(\"PPC - skipping this test.\");\n-        }\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTracePageSizes.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * Before this test set to manual, the original timeout\n+ * value if 180\n@@ -32,1 +34,1 @@\n- * @run main\/othervm\/manual\/timeout=180 -Djava.security.debug=certpath,ocsp\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp\n@@ -35,1 +37,1 @@\n- * @run main\/othervm\/manual\/timeout=180 -Djava.security.debug=certpath,ocsp\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CAInterop.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}