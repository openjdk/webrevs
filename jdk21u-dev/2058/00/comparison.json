{"files":[{"patch":"@@ -56,0 +56,1 @@\n+#include \"utilities\/globalCounter.inline.hpp\"\n@@ -831,3 +832,3 @@\n-    \/\/ This PerfData object can be used in parallel with a safepoint.\n-    \/\/ See the work around in PerfDataManager::destroy().\n-    OM_PERFDATA_OP(FutileWakeups, inc());\n+    \/\/ We are in safepoint safe state, so shutdown can remove the counter\n+    \/\/ under our feet. Make sure we make this access safely.\n+    OM_PERFDATA_SAFE_OP(FutileWakeups, inc());\n@@ -974,2 +975,0 @@\n-    \/\/ This PerfData object can be used in parallel with a safepoint.\n-    \/\/ See the work around in PerfDataManager::destroy().\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -200,2 +200,4 @@\n-  \/\/ objects which can happen at normal VM shutdown.\n-  \/\/\n+  \/\/ objects which can happen at normal VM shutdown. This operation is\n+  \/\/ only safe when thread is not in safepoint-safe code, i.e. PerfDataManager\n+  \/\/ could not reach the safepoint and free the counter while we are using it.\n+  \/\/ If this is not guaranteed, use OM_PERFDATA_SAFE_OP instead.\n@@ -204,3 +206,19 @@\n-      if (ObjectMonitor::_sync_ ## f != nullptr &&  \\\n-          PerfDataManager::has_PerfData()) {        \\\n-        ObjectMonitor::_sync_ ## f->op_str;         \\\n+      if (ObjectMonitor::_sync_ ## f != nullptr) {  \\\n+        if (PerfDataManager::has_PerfData()) {      \\\n+          ObjectMonitor::_sync_ ## f->op_str;       \\\n+        }                                           \\\n+      }                                             \\\n+    } while (0)\n+\n+  \/\/ Only perform a PerfData operation if the PerfData object has been\n+  \/\/ allocated and if the PerfDataManager has not freed the PerfData\n+  \/\/ objects which can happen at normal VM shutdown. Additionally, we\n+  \/\/ enter the critical section to resolve the race against PerfDataManager\n+  \/\/ entering the safepoint and deleting the counter during shutdown.\n+  #define OM_PERFDATA_SAFE_OP(f, op_str)            \\\n+    do {                                            \\\n+      if (ObjectMonitor::_sync_ ## f != nullptr) {  \\\n+        GlobalCounter::CriticalSection cs(Thread::current()); \\\n+        if (PerfDataManager::has_PerfData()) {      \\\n+          ObjectMonitor::_sync_ ## f->op_str;       \\\n+        }                                           \\\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"utilities\/globalCounter.inline.hpp\"\n@@ -254,9 +255,7 @@\n-  \/\/ Clear the flag before we free the PerfData counters. Thus begins\n-  \/\/ the race between this thread and another thread that has just\n-  \/\/ queried PerfDataManager::has_PerfData() and gotten back 'true'.\n-  \/\/ The hope is that the other thread will finish its PerfData\n-  \/\/ manipulation before we free the memory. The two alternatives are\n-  \/\/ 1) leak the PerfData memory or 2) do some form of synchronized\n-  \/\/ access or check before every PerfData operation.\n-  _has_PerfData = false;\n-  os::naked_short_sleep(1);  \/\/ 1ms sleep to let other thread(s) run\n+  \/\/ About to delete the counters than might still be accessed by other threads.\n+  \/\/ The shutdown is performed in two stages: a) clear the flag to notify future\n+  \/\/ counter users that we are at shutdown; b) sync up with current users, waiting\n+  \/\/ for them to finish with counters.\n+  \/\/\n+  Atomic::store(&_has_PerfData, false);\n+  GlobalCounter::write_synchronize();\n@@ -289,1 +288,1 @@\n-    _has_PerfData = true;\n+    Atomic::release_store(&_has_PerfData, true);\n","filename":"src\/hotspot\/share\/runtime\/perfData.cpp","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -244,0 +245,12 @@\n+ * There are possible shutdown races between counter uses and counter\n+ * destruction code. Normal shutdown happens with taking VM_Exit safepoint\n+ * operation, so in the vast majority of uses this is not an issue. On the\n+ * paths where a concurrent access can still happen when VM is at safepoint,\n+ * use the following pattern to coordinate with shutdown:\n+ *\n+ * {\n+ *   GlobalCounter::CriticalSection cs(Thread::current());\n+ *   if (PerfDataManager::has_PerfData()) {\n+ *     <update-counter>\n+ *   }\n+ * }\n@@ -788,1 +801,1 @@\n-    static bool has_PerfData() { return _has_PerfData; }\n+    static bool has_PerfData() { return Atomic::load_acquire(&_has_PerfData); }\n","filename":"src\/hotspot\/share\/runtime\/perfData.hpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"utilities\/globalCounter.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}