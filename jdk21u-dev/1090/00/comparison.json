{"files":[{"patch":"@@ -3,1 +3,1 @@\n-\/\/ Copyright (c) 2014, 2021, Red Hat, Inc. All rights reserved.\n+\/\/ Copyright (c) 2014, 2024, Red Hat, Inc. All rights reserved.\n@@ -16699,0 +16699,33 @@\n+instruct partialSubtypeCheckConstSuper(iRegP_R4 sub, iRegP_R0 super_reg, immP super_con, vRegD_V0 vtemp, iRegP_R5 result,\n+                                       iRegP_R1 tempR1, iRegP_R2 tempR2, iRegP_R3 tempR3,\n+                                       rFlagsReg cr)\n+%{\n+  match(Set result (PartialSubtypeCheck sub (Binary super_reg super_con)));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL cr, TEMP tempR1, TEMP tempR2, TEMP tempR3, TEMP vtemp);\n+\n+  ins_cost(700);  \/\/ smaller than the next version\n+  format %{ \"partialSubtypeCheck $result, $sub, super\" %}\n+\n+  ins_encode %{\n+    bool success = false;\n+    u1 super_klass_slot = ((Klass*)$super_con$$constant)->hash_slot();\n+    if (InlineSecondarySupersTest) {\n+      success = __ lookup_secondary_supers_table($sub$$Register, $super_reg$$Register,\n+                                                 $tempR1$$Register, $tempR2$$Register, $tempR3$$Register,\n+                                                 $vtemp$$FloatRegister,\n+                                                 $result$$Register,\n+                                                 super_klass_slot);\n+    } else {\n+      address call = __ trampoline_call(RuntimeAddress(StubRoutines::lookup_secondary_supers_table_stub(super_klass_slot)));\n+      success = (call != nullptr);\n+    }\n+    if (!success) {\n+      ciEnv::current()->record_failure(\"CodeCache is full\");\n+      return;\n+    }\n+  %}\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2634,0 +2634,1 @@\n+  \/\/ Advanced SIMD across lanes\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2024, Red Hat Inc. All rights reserved.\n@@ -1468,0 +1468,3 @@\n+  \/\/ NB! Callers may assume that, when temp2_reg is a valid register,\n+  \/\/ this code sets it to a nonzero value.\n+\n@@ -1543,0 +1546,235 @@\n+\/\/ Ensure that the inline code and the stub are using the same registers.\n+#define LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS                    \\\n+do {                                                               \\\n+  assert(r_super_klass  == r0                                   && \\\n+         r_array_base   == r1                                   && \\\n+         r_array_length == r2                                   && \\\n+         (r_array_index == r3        || r_array_index == noreg) && \\\n+         (r_sub_klass   == r4        || r_sub_klass   == noreg) && \\\n+         (r_bitmap      == rscratch2 || r_bitmap      == noreg) && \\\n+         (result        == r5        || result        == noreg), \"registers must match aarch64.ad\"); \\\n+} while(0)\n+\n+\/\/ Return true: we succeeded in generating this code\n+bool MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register temp1,\n+                                                   Register temp2,\n+                                                   Register temp3,\n+                                                   FloatRegister vtemp,\n+                                                   Register result,\n+                                                   u1 super_klass_slot,\n+                                                   bool stub_is_near) {\n+  assert_different_registers(r_sub_klass, temp1, temp2, temp3, result, rscratch1, rscratch2);\n+\n+  Label L_fallthrough;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table {\");\n+\n+  const Register\n+    r_array_base   = temp1, \/\/ r1\n+    r_array_length = temp2, \/\/ r2\n+    r_array_index  = temp3, \/\/ r3\n+    r_bitmap       = rscratch2;\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  u1 bit = super_klass_slot;\n+\n+  \/\/ Make sure that result is nonzero if the TBZ below misses.\n+  mov(result, 1);\n+\n+  \/\/ We're going to need the bitmap in a vector reg and in a core reg,\n+  \/\/ so load both now.\n+  ldr(r_bitmap, Address(r_sub_klass, Klass::bitmap_offset()));\n+  if (bit != 0) {\n+    ldrd(vtemp, Address(r_sub_klass, Klass::bitmap_offset()));\n+  }\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  tbz(r_bitmap, bit, L_fallthrough);\n+\n+  \/\/ Get the first array index that can contain super_klass into r_array_index.\n+  if (bit != 0) {\n+    shld(vtemp, vtemp, Klass::SECONDARY_SUPERS_TABLE_MASK - bit);\n+    cnt(vtemp, T8B, vtemp);\n+    addv(vtemp, T8B, vtemp);\n+    fmovd(r_array_index, vtemp);\n+  } else {\n+    mov(r_array_index, (u1)1);\n+  }\n+  \/\/ NB! r_array_index is off by 1. It is compensated by keeping r_array_base off by 1 word.\n+\n+  \/\/ We will consult the secondary-super array.\n+  ldr(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ The value i in r_array_index is >= 1, so even though r_array_base\n+  \/\/ points to the length, we don't need to adjust it to point to the\n+  \/\/ data.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+  assert(Array<Klass*>::length_offset_in_bytes() == 0, \"Adjust this code\");\n+\n+  ldr(result, Address(r_array_base, r_array_index, Address::lsl(LogBytesPerWord)));\n+  eor(result, result, r_super_klass);\n+  cbz(result, L_fallthrough); \/\/ Found a match\n+\n+  \/\/ Is there another entry to check? Consult the bitmap.\n+  tbz(r_bitmap, (bit + 1) & Klass::SECONDARY_SUPERS_TABLE_MASK, L_fallthrough);\n+\n+  \/\/ Linear probe.\n+  if (bit != 0) {\n+    ror(r_bitmap, r_bitmap, bit);\n+  }\n+\n+  \/\/ The slot we just inspected is at secondary_supers[r_array_index - 1].\n+  \/\/ The next slot to be inspected, by the stub we're about to call,\n+  \/\/ is secondary_supers[r_array_index]. Bits 0 and 1 in the bitmap\n+  \/\/ have been checked.\n+  Address stub = RuntimeAddress(StubRoutines::lookup_secondary_supers_table_slow_path_stub());\n+  if (stub_is_near) {\n+    bl(stub);\n+  } else {\n+    address call = trampoline_call(stub);\n+    if (call == nullptr) {\n+      return false; \/\/ trampoline allocation failed\n+    }\n+  }\n+\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table\");\n+\n+  bind(L_fallthrough);\n+\n+  if (VerifySecondarySupers) {\n+    verify_secondary_supers_table(r_sub_klass, r_super_klass, \/\/ r4, r0\n+                                  temp1, temp2, result);      \/\/ r1, r2, r5\n+  }\n+  return true;\n+}\n+\n+\/\/ Called by code generated by check_klass_subtype_slow_path\n+\/\/ above. This is called when there is a collision in the hashed\n+\/\/ lookup in the secondary supers array.\n+void MacroAssembler::lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                                             Register r_array_base,\n+                                                             Register r_array_index,\n+                                                             Register r_bitmap,\n+                                                             Register temp1,\n+                                                             Register result) {\n+  assert_different_registers(r_super_klass, r_array_base, r_array_index, r_bitmap, temp1, result, rscratch1);\n+\n+  const Register\n+    r_array_length = temp1,\n+    r_sub_klass    = noreg; \/\/ unused\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  Label L_fallthrough, L_huge;\n+\n+  \/\/ Load the array length.\n+  ldrw(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+  \/\/ And adjust the array base to point to the data.\n+  \/\/ NB! Effectively increments current slot index by 1.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"\");\n+  add(r_array_base, r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  \/\/ The bitmap is full to bursting.\n+  \/\/ Implicit invariant: BITMAP_FULL implies (length > 0)\n+  assert(Klass::SECONDARY_SUPERS_BITMAP_FULL == ~uintx(0), \"\");\n+  cmpw(r_array_length, (u1)(Klass::SECONDARY_SUPERS_TABLE_SIZE - 2));\n+  br(GT, L_huge);\n+\n+  \/\/ NB! Our caller has checked bits 0 and 1 in the bitmap. The\n+  \/\/ current slot (at secondary_supers[r_array_index]) has not yet\n+  \/\/ been inspected, and r_array_index may be out of bounds if we\n+  \/\/ wrapped around the end of the array.\n+\n+  { \/\/ This is conventional linear probing, but instead of terminating\n+    \/\/ when a null entry is found in the table, we maintain a bitmap\n+    \/\/ in which a 0 indicates missing entries.\n+    \/\/ The check above guarantees there are 0s in the bitmap, so the loop\n+    \/\/ eventually terminates.\n+    Label L_loop;\n+    bind(L_loop);\n+\n+    \/\/ Check for wraparound.\n+    cmp(r_array_index, r_array_length);\n+    csel(r_array_index, zr, r_array_index, GE);\n+\n+    ldr(rscratch1, Address(r_array_base, r_array_index, Address::lsl(LogBytesPerWord)));\n+    eor(result, rscratch1, r_super_klass);\n+    cbz(result, L_fallthrough);\n+\n+    tbz(r_bitmap, 2, L_fallthrough); \/\/ look-ahead check (Bit 2); result is non-zero\n+\n+    ror(r_bitmap, r_bitmap, 1);\n+    add(r_array_index, r_array_index, 1);\n+    b(L_loop);\n+  }\n+\n+  { \/\/ Degenerate case: more than 64 secondary supers.\n+    \/\/ FIXME: We could do something smarter here, maybe a vectorized\n+    \/\/ comparison or a binary search, but is that worth any added\n+    \/\/ complexity?\n+    bind(L_huge);\n+    cmp(sp, zr); \/\/ Clear Z flag; SP is never zero\n+    repne_scan(r_array_base, r_super_klass, r_array_length, rscratch1);\n+    cset(result, NE); \/\/ result == 0 iff we got a match.\n+  }\n+\n+  bind(L_fallthrough);\n+}\n+\n+\/\/ Make sure that the hashed lookup and a linear scan agree.\n+void MacroAssembler::verify_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register temp1,\n+                                                   Register temp2,\n+                                                   Register result) {\n+  assert_different_registers(r_sub_klass, r_super_klass, temp1, temp2, result, rscratch1);\n+\n+  const Register\n+    r_array_base   = temp1,\n+    r_array_length = temp2,\n+    r_array_index  = noreg, \/\/ unused\n+    r_bitmap       = noreg; \/\/ unused\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  BLOCK_COMMENT(\"verify_secondary_supers_table {\");\n+\n+  \/\/ We will consult the secondary-super array.\n+  ldr(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ Load the array length.\n+  ldrw(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+  \/\/ And adjust the array base to point to the data.\n+  add(r_array_base, r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  cmp(sp, zr); \/\/ Clear Z flag; SP is never zero\n+  \/\/ Scan R2 words at [R5] for an occurrence of R0.\n+  \/\/ Set NZ\/Z based on last compare.\n+  repne_scan(\/*addr*\/r_array_base, \/*value*\/r_super_klass, \/*count*\/r_array_length, rscratch2);\n+  \/\/ rscratch1 == 0 iff we got a match.\n+  cset(rscratch1, NE);\n+\n+  Label passed;\n+  cmp(result, zr);\n+  cset(result, NE); \/\/ normalize result to 0\/1 for comparison\n+\n+  cmp(rscratch1, result);\n+  br(EQ, passed);\n+  {\n+    mov(r0, r_super_klass);         \/\/ r0 <- r0\n+    mov(r1, r_sub_klass);           \/\/ r1 <- r4\n+    mov(r2, \/*expected*\/rscratch1); \/\/ r2 <- r8\n+    mov(r3, result);                \/\/ r3 <- r5\n+    mov(r4, (address)(\"mismatch\")); \/\/ r4 <- const\n+    rt_call(CAST_FROM_FN_PTR(address, Klass::on_secondary_supers_verification_failure), rscratch2);\n+    should_not_reach_here();\n+  }\n+  bind(passed);\n+\n+  BLOCK_COMMENT(\"} verify_secondary_supers_table\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":239,"deletions":1,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2024, Red Hat Inc. All rights reserved.\n@@ -1000,0 +1000,25 @@\n+  \/\/ As above, but with a constant super_klass.\n+  \/\/ The result is in Register result, not the condition codes.\n+  bool lookup_secondary_supers_table(Register r_sub_klass,\n+                                     Register r_super_klass,\n+                                     Register temp1,\n+                                     Register temp2,\n+                                     Register temp3,\n+                                     FloatRegister vtemp,\n+                                     Register result,\n+                                     u1 super_klass_slot,\n+                                     bool stub_is_near = false);\n+\n+  void verify_secondary_supers_table(Register r_sub_klass,\n+                                     Register r_super_klass,\n+                                     Register temp1,\n+                                     Register temp2,\n+                                     Register result);\n+\n+  void lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                               Register r_array_base,\n+                                               Register r_array_index,\n+                                               Register r_bitmap,\n+                                               Register temp1,\n+                                               Register result);\n+\n@@ -1214,0 +1239,1 @@\n+  \/\/ Clobbers: rscratch1\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, 2022, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2024, Red Hat Inc. All rights reserved.\n@@ -7060,0 +7060,46 @@\n+  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+\n+    address start = __ pc();\n+    const Register\n+      r_super_klass  = r0,\n+      r_array_base   = r1,\n+      r_array_length = r2,\n+      r_array_index  = r3,\n+      r_sub_klass    = r4,\n+      r_bitmap       = rscratch2,\n+      result         = r5;\n+    const FloatRegister\n+      vtemp          = v0;\n+\n+    Label L_success;\n+    __ enter();\n+    __ lookup_secondary_supers_table(r_sub_klass, r_super_klass,\n+                                     r_array_base, r_array_length, r_array_index,\n+                                     vtemp, result, super_klass_index,\n+                                     \/*stub_is_near*\/true);\n+    __ leave();\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n+  \/\/ Slow path implementation for UseSecondarySupersTable.\n+  address generate_lookup_secondary_supers_table_slow_path_stub() {\n+    StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table_slow_path\");\n+\n+    address start = __ pc();\n+    const Register\n+      r_super_klass  = r0,        \/\/ argument\n+      r_array_base   = r1,        \/\/ argument\n+      temp1          = r2,        \/\/ temp\n+      r_array_index  = r3,        \/\/ argument\n+      r_bitmap       = rscratch2, \/\/ argument\n+      result         = r5;        \/\/ argument\n+\n+    __ lookup_secondary_supers_table_slow_path(r_super_klass, r_array_base, r_array_index, r_bitmap, temp1, result);\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -8694,0 +8740,10 @@\n+    if (UseSecondarySupersTable) {\n+      StubRoutines::_lookup_secondary_supers_table_slow_path_stub = generate_lookup_secondary_supers_table_slow_path_stub();\n+      if (! InlineSecondarySupersTest) {\n+        for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+          StubRoutines::_lookup_secondary_supers_table_stubs[slot]\n+            = generate_lookup_secondary_supers_table_stub(slot);\n+        }\n+      }\n+    }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -174,0 +174,2 @@\n+  constexpr static bool supports_secondary_supers_table() { return true; }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -13445,0 +13445,9 @@\n+void Assembler::btq(Register src, int imm8) {\n+  assert(isByte(imm8), \"not a byte\");\n+  InstructionMark im(this);\n+  int encode = prefixq_and_encode(src->encoding());\n+  emit_int16(0x0f, 0xba);\n+  emit_int8(0xe0|encode);\n+  emit_int8(imm8);\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1720,0 +1720,1 @@\n+  void btq(Register src, int imm8);\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4655,0 +4655,333 @@\n+#ifdef _LP64\n+\n+\/\/ population_count variant for running without the POPCNT\n+\/\/ instruction, which was introduced with SSE4.2 in 2008.\n+void MacroAssembler::population_count(Register dst, Register src,\n+                                      Register scratch1, Register scratch2) {\n+  assert_different_registers(src, scratch1, scratch2);\n+  if (UsePopCountInstruction) {\n+    Assembler::popcntq(dst, src);\n+  } else {\n+    assert_different_registers(src, scratch1, scratch2);\n+    assert_different_registers(dst, scratch1, scratch2);\n+    Label loop, done;\n+\n+    mov(scratch1, src);\n+    \/\/ dst = 0;\n+    \/\/ while(scratch1 != 0) {\n+    \/\/   dst++;\n+    \/\/   scratch1 &= (scratch1 - 1);\n+    \/\/ }\n+    xorl(dst, dst);\n+    testq(scratch1, scratch1);\n+    jccb(Assembler::equal, done);\n+    {\n+      bind(loop);\n+      incq(dst);\n+      movq(scratch2, scratch1);\n+      decq(scratch2);\n+      andq(scratch1, scratch2);\n+      jccb(Assembler::notEqual, loop);\n+    }\n+    bind(done);\n+  }\n+}\n+\n+\/\/ Ensure that the inline code and the stub are using the same registers.\n+#define LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS                      \\\n+do {                                                                 \\\n+  assert(r_super_klass  == rax, \"mismatch\");                         \\\n+  assert(r_array_base   == rbx, \"mismatch\");                         \\\n+  assert(r_array_length == rcx, \"mismatch\");                         \\\n+  assert(r_array_index  == rdx, \"mismatch\");                         \\\n+  assert(r_sub_klass    == rsi || r_sub_klass == noreg, \"mismatch\"); \\\n+  assert(r_bitmap       == r11 || r_bitmap    == noreg, \"mismatch\"); \\\n+  assert(result         == rdi || result      == noreg, \"mismatch\"); \\\n+} while(0)\n+\n+void MacroAssembler::lookup_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register temp1,\n+                                                   Register temp2,\n+                                                   Register temp3,\n+                                                   Register temp4,\n+                                                   Register result,\n+                                                   u1 super_klass_slot) {\n+  assert_different_registers(r_sub_klass, r_super_klass, temp1, temp2, temp3, temp4, result);\n+\n+  Label L_fallthrough, L_success, L_failure;\n+\n+  BLOCK_COMMENT(\"lookup_secondary_supers_table {\");\n+\n+  const Register\n+    r_array_index  = temp1,\n+    r_array_length = temp2,\n+    r_array_base   = temp3,\n+    r_bitmap       = temp4;\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  xorq(result, result); \/\/ = 0\n+\n+  movq(r_bitmap, Address(r_sub_klass, Klass::bitmap_offset()));\n+  movq(r_array_index, r_bitmap);\n+\n+  \/\/ First check the bitmap to see if super_klass might be present. If\n+  \/\/ the bit is zero, we are certain that super_klass is not one of\n+  \/\/ the secondary supers.\n+  u1 bit = super_klass_slot;\n+  {\n+    \/\/ NB: If the count in a x86 shift instruction is 0, the flags are\n+    \/\/ not affected, so we do a testq instead.\n+    int shift_count = Klass::SECONDARY_SUPERS_TABLE_MASK - bit;\n+    if (shift_count != 0) {\n+      salq(r_array_index, shift_count);\n+    } else {\n+      testq(r_array_index, r_array_index);\n+    }\n+  }\n+  \/\/ We test the MSB of r_array_index, i.e. its sign bit\n+  jcc(Assembler::positive, L_failure);\n+\n+  \/\/ Get the first array index that can contain super_klass into r_array_index.\n+  if (bit != 0) {\n+    population_count(r_array_index, r_array_index, temp2, temp3);\n+  } else {\n+    movl(r_array_index, 1);\n+  }\n+  \/\/ NB! r_array_index is off by 1. It is compensated by keeping r_array_base off by 1 word.\n+\n+  \/\/ We will consult the secondary-super array.\n+  movptr(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+\n+  \/\/ We're asserting that the first word in an Array<Klass*> is the\n+  \/\/ length, and the second word is the first word of the data. If\n+  \/\/ that ever changes, r_array_base will have to be adjusted here.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"Adjust this code\");\n+  assert(Array<Klass*>::length_offset_in_bytes() == 0, \"Adjust this code\");\n+\n+  cmpq(r_super_klass, Address(r_array_base, r_array_index, Address::times_8));\n+  jccb(Assembler::equal, L_success);\n+\n+  \/\/ Is there another entry to check? Consult the bitmap.\n+  btq(r_bitmap, (bit + 1) & Klass::SECONDARY_SUPERS_TABLE_MASK);\n+  jccb(Assembler::carryClear, L_failure);\n+\n+  \/\/ Linear probe. Rotate the bitmap so that the next bit to test is\n+  \/\/ in Bit 1.\n+  if (bit != 0) {\n+    rorq(r_bitmap, bit);\n+  }\n+\n+  \/\/ Calls into the stub generated by lookup_secondary_supers_table_slow_path.\n+  \/\/ Arguments: r_super_klass, r_array_base, r_array_index, r_bitmap.\n+  \/\/ Kills: r_array_length.\n+  \/\/ Returns: result.\n+  call(RuntimeAddress(StubRoutines::lookup_secondary_supers_table_slow_path_stub()));\n+  \/\/ Result (0\/1) is in rdi\n+  jmpb(L_fallthrough);\n+\n+  bind(L_failure);\n+  incq(result); \/\/ 0 => 1\n+\n+  bind(L_success);\n+  \/\/ result = 0;\n+\n+  bind(L_fallthrough);\n+  BLOCK_COMMENT(\"} lookup_secondary_supers_table\");\n+\n+  if (VerifySecondarySupers) {\n+    verify_secondary_supers_table(r_sub_klass, r_super_klass, result,\n+                                  temp1, temp2, temp3);\n+  }\n+}\n+\n+void MacroAssembler::repne_scanq(Register addr, Register value, Register count, Register limit,\n+                                 Label* L_success, Label* L_failure) {\n+  Label L_loop, L_fallthrough;\n+  {\n+    int label_nulls = 0;\n+    if (L_success == nullptr) { L_success = &L_fallthrough; label_nulls++; }\n+    if (L_failure == nullptr) { L_failure = &L_fallthrough; label_nulls++; }\n+    assert(label_nulls <= 1, \"at most one null in the batch\");\n+  }\n+  bind(L_loop);\n+  cmpq(value, Address(addr, count, Address::times_8));\n+  jcc(Assembler::equal, *L_success);\n+  addl(count, 1);\n+  cmpl(count, limit);\n+  jcc(Assembler::less, L_loop);\n+\n+  if (&L_fallthrough != L_failure) {\n+    jmp(*L_failure);\n+  }\n+  bind(L_fallthrough);\n+}\n+\n+\/\/ Called by code generated by check_klass_subtype_slow_path\n+\/\/ above. This is called when there is a collision in the hashed\n+\/\/ lookup in the secondary supers array.\n+void MacroAssembler::lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                                             Register r_array_base,\n+                                                             Register r_array_index,\n+                                                             Register r_bitmap,\n+                                                             Register temp1,\n+                                                             Register temp2,\n+                                                             Label* L_success,\n+                                                             Label* L_failure) {\n+  assert_different_registers(r_super_klass, r_array_base, r_array_index, r_bitmap, temp1, temp2);\n+\n+  const Register\n+    r_array_length = temp1,\n+    r_sub_klass    = noreg,\n+    result         = noreg;\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  Label L_fallthrough;\n+  int label_nulls = 0;\n+  if (L_success == nullptr)   { L_success   = &L_fallthrough; label_nulls++; }\n+  if (L_failure == nullptr)   { L_failure   = &L_fallthrough; label_nulls++; }\n+  assert(label_nulls <= 1, \"at most one null in the batch\");\n+\n+  \/\/ Load the array length.\n+  movl(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+  \/\/ And adjust the array base to point to the data.\n+  \/\/ NB! Effectively increments current slot index by 1.\n+  assert(Array<Klass*>::base_offset_in_bytes() == wordSize, \"\");\n+  addptr(r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  \/\/ Linear probe\n+  Label L_huge;\n+\n+  \/\/ The bitmap is full to bursting.\n+  \/\/ Implicit invariant: BITMAP_FULL implies (length > 0)\n+  cmpl(r_array_length, (int32_t)Klass::SECONDARY_SUPERS_TABLE_SIZE - 2);\n+  jcc(Assembler::greater, L_huge);\n+\n+  \/\/ NB! Our caller has checked bits 0 and 1 in the bitmap. The\n+  \/\/ current slot (at secondary_supers[r_array_index]) has not yet\n+  \/\/ been inspected, and r_array_index may be out of bounds if we\n+  \/\/ wrapped around the end of the array.\n+\n+  { \/\/ This is conventional linear probing, but instead of terminating\n+    \/\/ when a null entry is found in the table, we maintain a bitmap\n+    \/\/ in which a 0 indicates missing entries.\n+    \/\/ The check above guarantees there are 0s in the bitmap, so the loop\n+    \/\/ eventually terminates.\n+\n+    xorl(temp2, temp2); \/\/ = 0;\n+\n+    Label L_again;\n+    bind(L_again);\n+\n+    \/\/ Check for array wraparound.\n+    cmpl(r_array_index, r_array_length);\n+    cmovl(Assembler::greaterEqual, r_array_index, temp2);\n+\n+    cmpq(r_super_klass, Address(r_array_base, r_array_index, Address::times_8));\n+    jcc(Assembler::equal, *L_success);\n+\n+    \/\/ If the next bit in bitmap is zero, we're done.\n+    btq(r_bitmap, 2); \/\/ look-ahead check (Bit 2); Bits 0 and 1 are tested by now\n+    jcc(Assembler::carryClear, *L_failure);\n+\n+    rorq(r_bitmap, 1); \/\/ Bits 1\/2 => 0\/1\n+    addl(r_array_index, 1);\n+\n+    jmp(L_again);\n+  }\n+\n+  { \/\/ Degenerate case: more than 64 secondary supers.\n+    \/\/ FIXME: We could do something smarter here, maybe a vectorized\n+    \/\/ comparison or a binary search, but is that worth any added\n+    \/\/ complexity?\n+    bind(L_huge);\n+    xorl(r_array_index, r_array_index); \/\/ = 0\n+    repne_scanq(r_array_base, r_super_klass, r_array_index, r_array_length,\n+                L_success,\n+                (&L_fallthrough != L_failure ? L_failure : nullptr));\n+\n+    bind(L_fallthrough);\n+  }\n+}\n+\n+struct VerifyHelperArguments {\n+  Klass* _super;\n+  Klass* _sub;\n+  intptr_t _linear_result;\n+  intptr_t _table_result;\n+};\n+\n+static void verify_secondary_supers_table_helper(const char* msg, VerifyHelperArguments* args) {\n+  Klass::on_secondary_supers_verification_failure(args->_super,\n+                                                  args->_sub,\n+                                                  args->_linear_result,\n+                                                  args->_table_result,\n+                                                  msg);\n+}\n+\n+\/\/ Make sure that the hashed lookup and a linear scan agree.\n+void MacroAssembler::verify_secondary_supers_table(Register r_sub_klass,\n+                                                   Register r_super_klass,\n+                                                   Register result,\n+                                                   Register temp1,\n+                                                   Register temp2,\n+                                                   Register temp3) {\n+  const Register\n+      r_array_index  = temp1,\n+      r_array_length = temp2,\n+      r_array_base   = temp3,\n+      r_bitmap       = noreg;\n+\n+  LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS;\n+\n+  BLOCK_COMMENT(\"verify_secondary_supers_table {\");\n+\n+  Label L_success, L_failure, L_check, L_done;\n+\n+  movptr(r_array_base, Address(r_sub_klass, in_bytes(Klass::secondary_supers_offset())));\n+  movl(r_array_length, Address(r_array_base, Array<Klass*>::length_offset_in_bytes()));\n+  \/\/ And adjust the array base to point to the data.\n+  addptr(r_array_base, Array<Klass*>::base_offset_in_bytes());\n+\n+  testl(r_array_length, r_array_length); \/\/ array_length == 0?\n+  jcc(Assembler::zero, L_failure);\n+\n+  movl(r_array_index, 0);\n+  repne_scanq(r_array_base, r_super_klass, r_array_index, r_array_length, &L_success);\n+  \/\/ fall through to L_failure\n+\n+  const Register linear_result = r_array_index; \/\/ reuse temp1\n+\n+  bind(L_failure); \/\/ not present\n+  movl(linear_result, 1);\n+  jmp(L_check);\n+\n+  bind(L_success); \/\/ present\n+  movl(linear_result, 0);\n+\n+  bind(L_check);\n+  cmpl(linear_result, result);\n+  jcc(Assembler::equal, L_done);\n+\n+  { \/\/ To avoid calling convention issues, build a record on the stack\n+    \/\/ and pass the pointer to that instead.\n+    push(result);\n+    push(linear_result);\n+    push(r_sub_klass);\n+    push(r_super_klass);\n+    movptr(c_rarg1, rsp);\n+    movptr(c_rarg0, (uintptr_t) \"mismatch\");\n+    call(RuntimeAddress(CAST_FROM_FN_PTR(address, verify_secondary_supers_table_helper)));\n+    should_not_reach_here();\n+  }\n+  bind(L_done);\n+\n+  BLOCK_COMMENT(\"} verify_secondary_supers_table\");\n+}\n+\n+#undef LOOKUP_SECONDARY_SUPERS_TABLE_REGISTERS\n+\n+#endif \/\/ LP64\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":333,"deletions":0,"binary":false,"changes":333,"status":"modified"},{"patch":"@@ -597,0 +597,2 @@\n+  void population_count(Register dst, Register src, Register scratch1, Register scratch2);\n+\n@@ -647,0 +649,7 @@\n+  void hashed_check_klass_subtype_slow_path(Register sub_klass,\n+                                     Register super_klass,\n+                                     Register temp_reg,\n+                                     Register temp2_reg,\n+                                     Label* L_success,\n+                                     Label* L_failure,\n+                                     bool set_cond_codes = false);\n@@ -648,1 +657,32 @@\n-  \/\/ Simplified, combined version, good for typical uses.\n+  \/\/ As above, but with a constant super_klass.\n+  \/\/ The result is in Register result, not the condition codes.\n+  void lookup_secondary_supers_table(Register sub_klass,\n+                                     Register super_klass,\n+                                     Register temp1,\n+                                     Register temp2,\n+                                     Register temp3,\n+                                     Register temp4,\n+                                     Register result,\n+                                     u1 super_klass_slot);\n+\n+  void lookup_secondary_supers_table_slow_path(Register r_super_klass,\n+                                               Register r_array_base,\n+                                               Register r_array_index,\n+                                               Register r_bitmap,\n+                                               Register temp1,\n+                                               Register temp2,\n+                                               Label* L_success,\n+                                               Label* L_failure = nullptr);\n+\n+  void verify_secondary_supers_table(Register r_sub_klass,\n+                                     Register r_super_klass,\n+                                     Register expected,\n+                                     Register temp1,\n+                                     Register temp2,\n+                                     Register temp3);\n+\n+  void repne_scanq(Register addr, Register value, Register count, Register limit,\n+                   Label* L_success,\n+                   Label* L_failure = nullptr);\n+\n+    \/\/ Simplified, combined version, good for typical uses.\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -3899,0 +3899,48 @@\n+address StubGenerator::generate_lookup_secondary_supers_table_stub(u1 super_klass_index) {\n+  StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+\n+  address start = __ pc();\n+\n+  const Register\n+      r_super_klass = rax,\n+      r_sub_klass   = rsi,\n+      result        = rdi;\n+\n+  __ lookup_secondary_supers_table(r_sub_klass, r_super_klass,\n+                                   rdx, rcx, rbx, r11, \/\/ temps\n+                                   result,\n+                                   super_klass_index);\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n+\/\/ Slow path implementation for UseSecondarySupersTable.\n+address StubGenerator::generate_lookup_secondary_supers_table_slow_path_stub() {\n+  StubCodeMark mark(this, \"StubRoutines\", \"lookup_secondary_supers_table\");\n+\n+  address start = __ pc();\n+\n+  const Register\n+      r_super_klass  = rax,\n+      r_array_base   = rbx,\n+      r_array_index  = rdx,\n+      r_sub_klass    = rsi,\n+      r_bitmap       = r11,\n+      result         = rdi;\n+\n+  Label L_success;\n+  __ lookup_secondary_supers_table_slow_path(r_super_klass, r_array_base, r_array_index, r_bitmap,\n+                                             rcx, rdi, \/\/ temps\n+                                             &L_success);\n+  \/\/ bind(L_failure);\n+  __ movl(result, 1);\n+  __ ret(0);\n+\n+  __ bind(L_success);\n+  __ movl(result, 0);\n+  __ ret(0);\n+\n+  return start;\n+}\n+\n@@ -4171,0 +4219,8 @@\n+  if (UseSecondarySupersTable) {\n+    StubRoutines::_lookup_secondary_supers_table_slow_path_stub = generate_lookup_secondary_supers_table_slow_path_stub();\n+    if (! InlineSecondarySupersTest) {\n+      for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+        StubRoutines::_lookup_secondary_supers_table_stubs[slot] = generate_lookup_secondary_supers_table_stub(slot);\n+      }\n+    }\n+  }\n@@ -4243,0 +4299,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -552,0 +552,6 @@\n+  \/\/ Specialized stub implementations for UseSecondarySupersTable.\n+  address generate_lookup_secondary_supers_table_stub(u1 super_klass_index);\n+\n+  \/\/ Slow path implementation for UseSecondarySupersTable.\n+  address generate_lookup_secondary_supers_table_slow_path_stub();\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -765,0 +765,5 @@\n+  \/\/ x86_64 supports secondary supers table\n+  constexpr static bool supports_secondary_supers_table() {\n+    return LP64_ONLY(true) NOT_LP64(false); \/\/ not implemented on x86_32\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -299,0 +299,3 @@\n+\/\/ Singleton class for R11 long register\n+reg_class long_r11_reg(R11, R11_H);\n+\n@@ -3727,0 +3730,10 @@\n+operand r11_RegL()\n+%{\n+  constraint(ALLOC_IN_RC(long_r11_reg));\n+  match(RegL);\n+  match(rRegL);\n+\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -13124,0 +13137,25 @@\n+instruct partialSubtypeCheckConstSuper(rsi_RegP sub, rax_RegP super_reg, immP super_con, rdi_RegP result,\n+                                       rdx_RegL temp1, rcx_RegL temp2, rbx_RegP temp3, r11_RegL temp4,\n+                                       rFlagsReg cr)\n+%{\n+  match(Set result (PartialSubtypeCheck sub (Binary super_reg super_con)));\n+  predicate(UseSecondarySupersTable);\n+  effect(KILL cr, TEMP temp1, TEMP temp2, TEMP temp3, TEMP temp4);\n+\n+  ins_cost(700);  \/\/ smaller than the next version\n+  format %{ \"partialSubtypeCheck $result, $sub, super\" %}\n+\n+  ins_encode %{\n+    u1 super_klass_slot = ((Klass*)$super_con$$constant)->hash_slot();\n+    if (InlineSecondarySupersTest) {\n+      __ lookup_secondary_supers_table($sub$$Register, $super_reg$$Register, $temp1$$Register, $temp2$$Register,\n+                                       $temp3$$Register, $temp4$$Register, $result$$Register,\n+                                       super_klass_slot);\n+    } else {\n+      __ call(RuntimeAddress(StubRoutines::lookup_secondary_supers_table_stub(super_klass_slot)));\n+    }\n+  %}\n+\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -224,0 +224,1 @@\n+  _use_secondary_supers_table = UseSecondarySupersTable;\n@@ -289,0 +290,1 @@\n+  st->print_cr(\"- use_secondary_supers_table:     %d\", _use_secondary_supers_table);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -195,0 +195,1 @@\n+  bool    _use_secondary_supers_table;            \/\/ save the flag UseSecondarySupersTable\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+PerfCounter*    ClassLoader::_perf_secondary_hash_time = nullptr;\n@@ -1388,0 +1389,1 @@\n+    NEWPERFTICKCOUNTER(_perf_secondary_hash_time, SUN_CLS, \"secondarySuperHashTime\");\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -184,0 +184,3 @@\n+  \/\/ Count the time taken to hash the scondary superclass arrays.\n+  static PerfCounter* _perf_secondary_hash_time;\n+\n@@ -292,0 +295,3 @@\n+  static PerfCounter* perf_secondary_hash_time() {\n+    return _perf_secondary_hash_time;\n+  }\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -147,0 +147,3 @@\n+uintx Universe::_the_array_interfaces_bitmap = 0;\n+uintx Universe::_the_empty_klass_bitmap      = 0;\n+\n@@ -379,0 +382,5 @@\n+    if (UseSecondarySupersTable) {\n+      Universe::_the_array_interfaces_bitmap = Klass::compute_secondary_supers_bitmap(_the_array_interfaces_array);\n+      Universe::_the_empty_klass_bitmap      = Klass::compute_secondary_supers_bitmap(_the_empty_klass_array);\n+    }\n+\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -131,0 +131,3 @@\n+  static uintx _the_array_interfaces_bitmap;\n+  static uintx _the_empty_klass_bitmap;\n+\n@@ -266,0 +269,2 @@\n+  static Array<Klass*>* the_array_interfaces_array()  { return _the_array_interfaces_array; }\n+  static uintx        the_array_interfaces_bitmap()   { return _the_array_interfaces_bitmap; }\n@@ -267,1 +272,0 @@\n-  static Array<Klass*>* the_array_interfaces_array()  { return _the_array_interfaces_array;   }\n@@ -301,0 +305,2 @@\n+  static uintx                   the_empty_klass_bitmap() { return _the_empty_klass_bitmap; }\n+\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -123,1 +123,2 @@\n-  set_secondary_supers(Universe::the_array_interfaces_array());\n+  set_secondary_supers(Universe::the_array_interfaces_array(),\n+                       Universe::the_array_interfaces_bitmap());\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1400,1 +1400,3 @@\n-  Array<InstanceKlass*>* interfaces = transitive_interfaces;\n+  \/\/ We need the cast because Array<Klass*> is NOT a supertype of Array<InstanceKlass*>,\n+  \/\/ (but it's safe to do here because we won't write into _secondary_supers from this point on).\n+  Array<Klass*>* interfaces = (Array<Klass*>*)(address)transitive_interfaces;\n@@ -1404,1 +1406,1 @@\n-    set_secondary_supers(Universe::the_empty_klass_array());\n+    set_secondary_supers(Universe::the_empty_klass_array(), Universe::the_empty_klass_bitmap());\n@@ -1410,10 +1412,9 @@\n-    \/\/ We need the cast because Array<Klass*> is NOT a supertype of Array<InstanceKlass*>,\n-    \/\/ (but it's safe to do here because we won't write into _secondary_supers from this point on).\n-    set_secondary_supers((Array<Klass*>*)(address)interfaces);\n-    return nullptr;\n-  } else {\n-    \/\/ Copy transitive interfaces to a temporary growable array to be constructed\n-    \/\/ into the secondary super list with extra slots.\n-    GrowableArray<Klass*>* secondaries = new GrowableArray<Klass*>(interfaces->length());\n-    for (int i = 0; i < interfaces->length(); i++) {\n-      secondaries->push(interfaces->at(i));\n+    if (!UseSecondarySupersTable) {\n+      set_secondary_supers(interfaces);\n+      return nullptr;\n+    } else if (num_extra_slots == 0 && interfaces->length() <= 1) {\n+      \/\/ We will reuse the transitive interfaces list if we're certain\n+      \/\/ it's in hash order.\n+      uintx bitmap = compute_secondary_supers_bitmap(interfaces);\n+      set_secondary_supers(interfaces, bitmap);\n+      return nullptr;\n@@ -1421,1 +1422,7 @@\n-    return secondaries;\n+    \/\/ ... fall through if that didn't work.\n+  }\n+  \/\/ Copy transitive interfaces to a temporary growable array to be constructed\n+  \/\/ into the secondary super list with extra slots.\n+  GrowableArray<Klass*>* secondaries = new GrowableArray<Klass*>(interfaces->length());\n+  for (int i = 0; i < interfaces->length(); i++) {\n+    secondaries->push(interfaces->at(i));\n@@ -1423,0 +1430,1 @@\n+  return secondaries;\n@@ -3562,1 +3570,1 @@\n-  st->print(BULLET\"methods:           \"); methods()->print_value_on(st);                  st->cr();\n+  st->print(BULLET\"methods:           \"); methods()->print_value_on(st);               st->cr();\n@@ -3582,0 +3590,23 @@\n+\n+  st->print(BULLET\"secondary supers: \"); secondary_supers()->print_value_on(st); st->cr();\n+  if (UseSecondarySupersTable) {\n+    st->print(BULLET\"hash_slot:         %d\", hash_slot()); st->cr();\n+    st->print(BULLET\"bitmap:            \" UINTX_FORMAT_X_0, _bitmap); st->cr();\n+  }\n+  if (secondary_supers() != nullptr) {\n+    if (Verbose) {\n+      bool is_hashed = UseSecondarySupersTable && (_bitmap != SECONDARY_SUPERS_BITMAP_FULL);\n+      st->print_cr(BULLET\"---- secondary supers (%d words):\", _secondary_supers->length());\n+      for (int i = 0; i < _secondary_supers->length(); i++) {\n+        ResourceMark rm; \/\/ for external_name()\n+        Klass* secondary_super = _secondary_supers->at(i);\n+        st->print(BULLET\"%2d:\", i);\n+        if (is_hashed) {\n+          int home_slot = compute_home_slot(secondary_super, _bitmap);\n+          int distance = (i - home_slot) & SECONDARY_SUPERS_TABLE_MASK;\n+          st->print(\" dist:%02d:\", distance);\n+        }\n+        st->print_cr(\" %p %s\", secondary_super, secondary_super->external_name());\n+      }\n+    }\n+  }\n@@ -3626,0 +3657,1 @@\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":46,"deletions":14,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"classfile\/classLoader.hpp\"\n@@ -54,0 +55,1 @@\n+#include \"runtime\/perfData.hpp\"\n@@ -56,0 +58,1 @@\n+#include \"utilities\/rotate_bits.hpp\"\n@@ -80,0 +83,41 @@\n+uint8_t Klass::compute_hash_slot(Symbol* n) {\n+  uint hash_code;\n+  \/\/ Special cases for the two superclasses of all Array instances.\n+  \/\/ Code elsewhere assumes, for all instances of ArrayKlass, that\n+  \/\/ these two interfaces will be in this order.\n+\n+  \/\/ We ensure there are some empty slots in the hash table between\n+  \/\/ these two very common interfaces because if they were adjacent\n+  \/\/ (e.g. Slots 0 and 1), then any other class which hashed to 0 or 1\n+  \/\/ would result in a probe length of 3.\n+  if (n == vmSymbols::java_lang_Cloneable()) {\n+    hash_code = 0;\n+  } else if (n == vmSymbols::java_io_Serializable()) {\n+    hash_code = SECONDARY_SUPERS_TABLE_SIZE \/ 2;\n+  } else {\n+    auto s = (const jbyte*) n->bytes();\n+    hash_code = java_lang_String::hash_code(s, n->utf8_length());\n+    \/\/ We use String::hash_code here (rather than e.g.\n+    \/\/ Symbol::identity_hash()) in order to have a hash code that\n+    \/\/ does not change from run to run. We want that because the\n+    \/\/ hash value for a secondary superclass appears in generated\n+    \/\/ code as a constant.\n+\n+    \/\/ This constant is magic: see Knuth, \"Fibonacci Hashing\".\n+    constexpr uint multiplier\n+      = 2654435769; \/\/ (uint)(((u8)1 << 32) \/ ((1 + sqrt(5)) \/ 2 ))\n+    constexpr uint hash_shift = sizeof(hash_code) * 8 - 6;\n+    \/\/ The leading bits of the least significant half of the product.\n+    hash_code = (hash_code * multiplier) >> hash_shift;\n+\n+    if (StressSecondarySupers) {\n+      \/\/ Generate many hash collisions in order to stress-test the\n+      \/\/ linear search fallback.\n+      hash_code = hash_code % 3;\n+      hash_code = hash_code * (SECONDARY_SUPERS_TABLE_SIZE \/ 3);\n+    }\n+  }\n+\n+  return (hash_code & SECONDARY_SUPERS_TABLE_MASK);\n+}\n+\n@@ -82,1 +126,0 @@\n-  if (_name != nullptr) _name->increment_refcount();\n@@ -84,1 +127,18 @@\n-  if (Arguments::is_dumping_archive() && is_instance_klass()) {\n+  if (_name != nullptr) {\n+    _name->increment_refcount();\n+  }\n+\n+  if (UseSecondarySupersTable) {\n+    elapsedTimer selftime;\n+    selftime.start();\n+\n+    _hash_slot = compute_hash_slot(n);\n+    assert(_hash_slot < SECONDARY_SUPERS_TABLE_SIZE, \"required\");\n+\n+    selftime.stop();\n+    if (UsePerfData) {\n+      ClassLoader::perf_secondary_hash_time()->inc(selftime.ticks());\n+    }\n+  }\n+\n+   if (Arguments::is_dumping_archive() && is_instance_klass()) {\n@@ -235,0 +295,171 @@\n+void Klass::set_secondary_supers(Array<Klass*>* secondaries) {\n+  assert(!UseSecondarySupersTable || secondaries == nullptr, \"\");\n+  set_secondary_supers(secondaries, SECONDARY_SUPERS_BITMAP_EMPTY);\n+}\n+\n+void Klass::set_secondary_supers(Array<Klass*>* secondaries, uintx bitmap) {\n+#ifdef ASSERT\n+  if (UseSecondarySupersTable && secondaries != nullptr) {\n+    uintx real_bitmap = compute_secondary_supers_bitmap(secondaries);\n+    assert(bitmap == real_bitmap, \"must be\");\n+    assert(secondaries->length() >= (int)population_count(bitmap), \"must be\");\n+  }\n+#endif\n+  _bitmap = bitmap;\n+  _secondary_supers = secondaries;\n+\n+  if (secondaries != nullptr) {\n+    LogMessage(class, load) msg;\n+    NonInterleavingLogStream log {LogLevel::Debug, msg};\n+    if (log.is_enabled()) {\n+      ResourceMark rm;\n+      log.print_cr(\"set_secondary_supers: hash_slot: %d; klass: %s\", hash_slot(), external_name());\n+      print_secondary_supers_on(&log);\n+    }\n+  }\n+}\n+\n+\/\/ Hashed secondary superclasses\n+\/\/\n+\/\/ We use a compressed 64-entry hash table with linear probing. We\n+\/\/ start by creating a hash table in the usual way, followed by a pass\n+\/\/ that removes all the null entries. To indicate which entries would\n+\/\/ have been null we use a bitmap that contains a 1 in each position\n+\/\/ where an entry is present, 0 otherwise. This bitmap also serves as\n+\/\/ a kind of Bloom filter, which in many cases allows us quickly to\n+\/\/ eliminate the possibility that something is a member of a set of\n+\/\/ secondaries.\n+uintx Klass::hash_secondary_supers(Array<Klass*>* secondaries, bool rewrite) {\n+  const int length = secondaries->length();\n+\n+  if (length == 0) {\n+    return SECONDARY_SUPERS_BITMAP_EMPTY;\n+  }\n+\n+  if (length == 1) {\n+    int hash_slot = secondaries->at(0)->hash_slot();\n+    return uintx(1) << hash_slot;\n+  }\n+\n+  \/\/ Invariant: _secondary_supers.length >= population_count(_secondary_supers_bitmap)\n+\n+  \/\/ Don't attempt to hash a table that's completely full, because in\n+  \/\/ the case of an absent interface linear probing would not\n+  \/\/ terminate.\n+  if (length >= SECONDARY_SUPERS_TABLE_SIZE) {\n+    return SECONDARY_SUPERS_BITMAP_FULL;\n+  }\n+\n+  {\n+    PerfTraceTime ptt(ClassLoader::perf_secondary_hash_time());\n+\n+    ResourceMark rm;\n+    uintx bitmap = SECONDARY_SUPERS_BITMAP_EMPTY;\n+    auto hashed_secondaries = new GrowableArray<Klass*>(SECONDARY_SUPERS_TABLE_SIZE,\n+                                                        SECONDARY_SUPERS_TABLE_SIZE, nullptr);\n+\n+    for (int j = 0; j < length; j++) {\n+      Klass* k = secondaries->at(j);\n+      hash_insert(k, hashed_secondaries, bitmap);\n+    }\n+\n+    \/\/ Pack the hashed secondaries array by copying it into the\n+    \/\/ secondaries array, sans nulls, if modification is allowed.\n+    \/\/ Otherwise, validate the order.\n+    int i = 0;\n+    for (int slot = 0; slot < SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+      bool has_element = ((bitmap >> slot) & 1) != 0;\n+      assert(has_element == (hashed_secondaries->at(slot) != nullptr), \"\");\n+      if (has_element) {\n+        Klass* k = hashed_secondaries->at(slot);\n+        if (rewrite) {\n+          secondaries->at_put(i, k);\n+        } else if (secondaries->at(i) != k) {\n+          assert(false, \"broken secondary supers hash table\");\n+          return SECONDARY_SUPERS_BITMAP_FULL;\n+        }\n+        i++;\n+      }\n+    }\n+    assert(i == secondaries->length(), \"mismatch\");\n+\n+    return bitmap;\n+  }\n+}\n+\n+void Klass::hash_insert(Klass* klass, GrowableArray<Klass*>* secondaries, uintx& bitmap) {\n+  assert(bitmap != SECONDARY_SUPERS_BITMAP_FULL, \"\");\n+\n+  int dist = 0;\n+  for (int slot = klass->hash_slot(); true; slot = (slot + 1) & SECONDARY_SUPERS_TABLE_MASK) {\n+    Klass* existing = secondaries->at(slot);\n+    assert(((bitmap >> slot) & 1) == (existing != nullptr), \"mismatch\");\n+    if (existing == nullptr) { \/\/ no conflict\n+      secondaries->at_put(slot, klass);\n+      bitmap |= uintx(1) << slot;\n+      assert(bitmap != SECONDARY_SUPERS_BITMAP_FULL, \"\");\n+      return;\n+    } else {\n+      \/\/ Use Robin Hood hashing to minimize the worst case search.\n+      \/\/ Also, every permutation of the insertion sequence produces\n+      \/\/ the same final Robin Hood hash table, provided that a\n+      \/\/ consistent tie breaker is used.\n+      int existing_dist = (slot - existing->hash_slot()) & SECONDARY_SUPERS_TABLE_MASK;\n+      if (existing_dist < dist\n+          \/\/ This tie breaker ensures that the hash order is maintained.\n+          || ((existing_dist == dist)\n+              && (uintptr_t(existing) < uintptr_t(klass)))) {\n+        Klass* tmp = secondaries->at(slot);\n+        secondaries->at_put(slot, klass);\n+        klass = tmp;\n+        dist = existing_dist;\n+      }\n+      ++dist;\n+    }\n+  }\n+}\n+\n+Array<Klass*>* Klass::pack_secondary_supers(ClassLoaderData* loader_data,\n+                                            GrowableArray<Klass*>* primaries,\n+                                            GrowableArray<Klass*>* secondaries,\n+                                            uintx& bitmap, TRAPS) {\n+  int new_length = primaries->length() + secondaries->length();\n+  Array<Klass*>* secondary_supers = MetadataFactory::new_array<Klass*>(loader_data, new_length, CHECK_NULL);\n+\n+  \/\/ Combine the two arrays into a metadata object to pack the array.\n+  \/\/ The primaries are added in the reverse order, then the secondaries.\n+  int fill_p = primaries->length();\n+  for (int j = 0; j < fill_p; j++) {\n+    secondary_supers->at_put(j, primaries->pop());  \/\/ add primaries in reverse order.\n+  }\n+  for( int j = 0; j < secondaries->length(); j++ ) {\n+    secondary_supers->at_put(j+fill_p, secondaries->at(j));  \/\/ add secondaries on the end.\n+  }\n+#ifdef ASSERT\n+  \/\/ We must not copy any null placeholders left over from bootstrap.\n+  for (int j = 0; j < secondary_supers->length(); j++) {\n+    assert(secondary_supers->at(j) != nullptr, \"correct bootstrapping order\");\n+  }\n+#endif\n+\n+  if (UseSecondarySupersTable) {\n+    bitmap = hash_secondary_supers(secondary_supers, \/*rewrite=*\/true); \/\/ rewrites freshly allocated array\n+  } else {\n+    bitmap = SECONDARY_SUPERS_BITMAP_EMPTY;\n+  }\n+  return secondary_supers;\n+}\n+\n+uintx Klass::compute_secondary_supers_bitmap(Array<Klass*>* secondary_supers) {\n+  return hash_secondary_supers(secondary_supers, \/*rewrite=*\/false); \/\/ no rewrites allowed\n+}\n+\n+uint8_t Klass::compute_home_slot(Klass* k, uintx bitmap) {\n+  uint8_t hash = k->hash_slot();\n+  if (hash > 0) {\n+    return population_count(bitmap << (SECONDARY_SUPERS_TABLE_SIZE - hash));\n+  }\n+  return 0;\n+}\n+\n+\n@@ -325,20 +556,3 @@\n-    \/\/ The primaries are added in the reverse order, then the secondaries.\n-    int new_length = primaries->length() + secondaries->length();\n-    Array<Klass*>* s2 = MetadataFactory::new_array<Klass*>(\n-                                       class_loader_data(), new_length, CHECK);\n-    int fill_p = primaries->length();\n-    for (int j = 0; j < fill_p; j++) {\n-      s2->at_put(j, primaries->pop());  \/\/ add primaries in reverse order.\n-    }\n-    for( int j = 0; j < secondaries->length(); j++ ) {\n-      s2->at_put(j+fill_p, secondaries->at(j));  \/\/ add secondaries on the end.\n-    }\n-\n-  #ifdef ASSERT\n-      \/\/ We must not copy any null placeholders left over from bootstrap.\n-    for (int j = 0; j < s2->length(); j++) {\n-      assert(s2->at(j) != nullptr, \"correct bootstrapping order\");\n-    }\n-  #endif\n-\n-    set_secondary_supers(s2);\n+    uintx bitmap = 0;\n+    Array<Klass*>* s2 = pack_secondary_supers(class_loader_data(), primaries, secondaries, bitmap, CHECK);\n+    set_secondary_supers(s2, bitmap);\n@@ -352,1 +566,1 @@\n-  set_secondary_supers(Universe::the_empty_klass_array());\n+  set_secondary_supers(Universe::the_empty_klass_array(), Universe::the_empty_klass_bitmap());\n@@ -551,0 +765,5 @@\n+\n+  \/\/ FIXME: validation in Klass::hash_secondary_supers() may fail for shared klasses.\n+  \/\/ Even though the bitmaps always match, the canonical order of elements in the table\n+  \/\/ is not guaranteed to stay the same (see tie breaker during Robin Hood hashing in Klass::hash_insert).\n+  \/\/assert(compute_secondary_supers_bitmap(secondary_supers()) == _bitmap, \"broken table\");\n@@ -566,0 +785,1 @@\n+  assert(secondary_supers()->length() >= (int)population_count(_bitmap), \"must be\");\n@@ -954,0 +1174,97 @@\n+\n+class LookupStats : StackObj {\n+ private:\n+  uint _no_of_samples;\n+  uint _worst;\n+  uint _worst_count;\n+  uint _average;\n+  uint _best;\n+  uint _best_count;\n+ public:\n+  LookupStats() : _no_of_samples(0), _worst(0), _worst_count(0), _average(0), _best(INT_MAX), _best_count(0) {}\n+\n+  ~LookupStats() {\n+    assert(_best <= _worst || _no_of_samples == 0, \"sanity\");\n+  }\n+\n+  void sample(uint value) {\n+    ++_no_of_samples;\n+    _average += value;\n+\n+    if (_worst < value) {\n+      _worst = value;\n+      _worst_count = 1;\n+    } else if (_worst == value) {\n+      ++_worst_count;\n+    }\n+\n+    if (_best > value) {\n+      _best = value;\n+      _best_count = 1;\n+    } else if (_best == value) {\n+      ++_best_count;\n+    }\n+  }\n+\n+  void print_on(outputStream* st) const {\n+    st->print(\"best: %2d (%4.1f%%)\", _best, (100.0 * _best_count) \/ _no_of_samples);\n+    if (_best_count < _no_of_samples) {\n+      st->print(\"; average: %4.1f; worst: %2d (%4.1f%%)\",\n+                (1.0 * _average) \/ _no_of_samples,\n+                _worst, (100.0 * _worst_count) \/ _no_of_samples);\n+    }\n+  }\n+};\n+\n+static void print_positive_lookup_stats(Array<Klass*>* secondary_supers, uintx bitmap, outputStream* st) {\n+  int num_of_supers = secondary_supers->length();\n+\n+  LookupStats s;\n+  for (int i = 0; i < num_of_supers; i++) {\n+    Klass* secondary_super = secondary_supers->at(i);\n+    int home_slot = Klass::compute_home_slot(secondary_super, bitmap);\n+    uint score = 1 + ((i - home_slot) & Klass::SECONDARY_SUPERS_TABLE_MASK);\n+    s.sample(score);\n+  }\n+  st->print(\"positive_lookup: \"); s.print_on(st);\n+}\n+\n+static uint compute_distance_to_nearest_zero(int slot, uintx bitmap) {\n+  assert(~bitmap != 0, \"no zeroes\");\n+  uintx start = rotate_right(bitmap, slot);\n+  return count_trailing_zeros(~start);\n+}\n+\n+static void print_negative_lookup_stats(uintx bitmap, outputStream* st) {\n+  LookupStats s;\n+  for (int slot = 0; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+    uint score = compute_distance_to_nearest_zero(slot, bitmap);\n+    s.sample(score);\n+  }\n+  st->print(\"negative_lookup: \"); s.print_on(st);\n+}\n+\n+void Klass::print_secondary_supers_on(outputStream* st) const {\n+  if (secondary_supers() != nullptr) {\n+    if (UseSecondarySupersTable) {\n+      st->print(\"  - \"); st->print(\"%d elements;\", _secondary_supers->length());\n+      st->print_cr(\" bitmap: \" UINTX_FORMAT_X_0 \";\", _bitmap);\n+      if (_bitmap != SECONDARY_SUPERS_BITMAP_EMPTY &&\n+          _bitmap != SECONDARY_SUPERS_BITMAP_FULL) {\n+        st->print(\"  - \"); print_positive_lookup_stats(secondary_supers(), _bitmap, st); st->cr();\n+        st->print(\"  - \"); print_negative_lookup_stats(_bitmap, st); st->cr();\n+      }\n+    }\n+  } else {\n+    st->print(\"null\");\n+  }\n+}\n+\n+void Klass::on_secondary_supers_verification_failure(Klass* super, Klass* sub, bool linear_result, bool table_result, const char* msg) {\n+  ResourceMark rm;\n+  super->print();\n+  sub->print();\n+  fatal(\"%s: %s implements %s: is_subtype_of: %d; linear_search: %d; table_lookup: %d\",\n+        msg, sub->external_name(), super->external_name(),\n+        sub->is_subtype_of(super), linear_result, table_result);\n+}\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":341,"deletions":24,"binary":false,"changes":365,"status":"modified"},{"patch":"@@ -162,0 +162,6 @@\n+  \/\/ Bitmap and hash code used by hashed secondary supers.\n+  uintx    _bitmap;\n+  uint8_t  _hash_slot;\n+\n+  static uint8_t compute_hash_slot(Symbol* s);\n+\n@@ -235,1 +241,4 @@\n-  void set_secondary_supers(Array<Klass*>* k) { _secondary_supers = k; }\n+  void set_secondary_supers(Array<Klass*>* k);\n+  void set_secondary_supers(Array<Klass*>* k, uintx bitmap);\n+\n+  uint8_t hash_slot() const { return _hash_slot; }\n@@ -386,0 +395,4 @@\n+ private:\n+  static void  hash_insert(Klass* klass, GrowableArray<Klass*>* secondaries, uintx& bitmap);\n+  static uintx hash_secondary_supers(Array<Klass*>* secondaries, bool rewrite);\n+\n@@ -387,0 +400,15 @@\n+  \/\/ Secondary supers table support\n+  static Array<Klass*>* pack_secondary_supers(ClassLoaderData* loader_data,\n+                                              GrowableArray<Klass*>* primaries,\n+                                              GrowableArray<Klass*>* secondaries,\n+                                              uintx& bitmap,\n+                                              TRAPS);\n+\n+  static uintx   compute_secondary_supers_bitmap(Array<Klass*>* secondary_supers);\n+  static uint8_t compute_home_slot(Klass* k, uintx bitmap);\n+\n+  static constexpr int SECONDARY_SUPERS_TABLE_SIZE = sizeof(_bitmap) * 8;\n+  static constexpr int SECONDARY_SUPERS_TABLE_MASK = SECONDARY_SUPERS_TABLE_SIZE - 1;\n+\n+  static constexpr uintx SECONDARY_SUPERS_BITMAP_EMPTY    = 0;\n+  static constexpr uintx SECONDARY_SUPERS_BITMAP_FULL     = ~(uintx)0;\n@@ -403,0 +431,1 @@\n+  static ByteSize bitmap_offset()                { return byte_offset_of(Klass, _bitmap); }\n@@ -715,0 +744,2 @@\n+  void print_secondary_supers_on(outputStream* st) const;\n+\n@@ -729,0 +760,2 @@\n+\n+  static void on_secondary_supers_verification_failure(Klass* super, Klass* sub, bool linear_result, bool table_result, const char* msg);\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -385,1 +385,2 @@\n-    set_secondary_supers(Universe::the_array_interfaces_array());\n+    set_secondary_supers(Universe::the_array_interfaces_array(),\n+                         Universe::the_array_interfaces_bitmap());\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -777,0 +777,3 @@\n+                                                                            \\\n+  product(bool, InlineSecondarySupersTest, true, DIAGNOSTIC,                \\\n+          \"Inline the secondary supers hash lookup.\")                       \\\n@@ -778,1 +781,1 @@\n-\/\/ end of C2_FLAGS\n+ \/\/ end of C2_FLAGS\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2502,0 +2502,8 @@\n+    case Op_PartialSubtypeCheck: {\n+      if (UseSecondarySupersTable && n->in(2)->is_Con()) {\n+        \/\/ PartialSubtypeCheck uses both constant and register operands for superclass input.\n+        n->set_req(2, new BinaryNode(n->in(2), n->in(2)));\n+        break;\n+      }\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2408,0 +2408,6 @@\n+  if (tkls != nullptr && !UseSecondarySupersCache\n+      && tkls->offset() == in_bytes(Klass::secondary_super_cache_offset()))  {\n+    \/\/ Treat Klass::_secondary_super_cache as a constant when the cache is disabled.\n+    return TypePtr::NULL_PTR;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -183,0 +183,3 @@\n+  \/\/ Does platform support secondary supers table lookup?\n+  constexpr static bool supports_secondary_supers_table() { return false; }\n+\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3998,0 +3998,11 @@\n+  if (FLAG_IS_DEFAULT(UseSecondarySupersTable)) {\n+    FLAG_SET_DEFAULT(UseSecondarySupersTable, VM_Version::supports_secondary_supers_table());\n+  } else if (UseSecondarySupersTable && !VM_Version::supports_secondary_supers_table()) {\n+    warning(\"UseSecondarySupersTable is not supported\");\n+    FLAG_SET_DEFAULT(UseSecondarySupersTable, false);\n+  }\n+  if (!UseSecondarySupersTable) {\n+    FLAG_SET_DEFAULT(StressSecondarySupers, false);\n+    FLAG_SET_DEFAULT(VerifySecondarySupers, false);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1992,0 +1992,13 @@\n+                                                                            \\\n+  product(bool, UseSecondarySupersCache, true, DIAGNOSTIC,                  \\\n+                \"Use secondary supers cache during subtype checks.\")        \\\n+                                                                            \\\n+  product(bool, UseSecondarySupersTable, false, DIAGNOSTIC,                 \\\n+                \"Use hash table to lookup secondary supers.\")               \\\n+                                                                            \\\n+  product(bool, VerifySecondarySupers, false, DIAGNOSTIC,                   \\\n+          \"Check that linear and hashed secondary lookups return the same result.\") \\\n+                                                                            \\\n+  product(bool, StressSecondarySupers, false, DIAGNOSTIC,                   \\\n+          \"Use a terrible hash function in order to generate many collisions.\") \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"oops\/klass.hpp\"\n@@ -187,0 +188,4 @@\n+address StubRoutines::_lookup_secondary_supers_table_slow_path_stub = nullptr;\n+address StubRoutines::_lookup_secondary_supers_table_stubs[Klass::SECONDARY_SUPERS_TABLE_SIZE] = { nullptr };\n+\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -269,0 +269,3 @@\n+  static address _lookup_secondary_supers_table_stubs[];\n+  static address _lookup_secondary_supers_table_slow_path_stub;\n+\n@@ -462,0 +465,11 @@\n+  static address lookup_secondary_supers_table_stub(u1 slot) {\n+    assert(slot < Klass::SECONDARY_SUPERS_TABLE_SIZE, \"out of bounds\");\n+    assert(_lookup_secondary_supers_table_stubs[slot] != nullptr, \"not implemented\");\n+    return _lookup_secondary_supers_table_stubs[slot];\n+  }\n+\n+  static address lookup_secondary_supers_table_slow_path_stub() {\n+    assert(_lookup_secondary_supers_table_slow_path_stub != nullptr, \"not implemented\");\n+    return _lookup_secondary_supers_table_slow_path_stub;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -153,0 +153,5 @@\n+#ifdef _LP64\n+#define UINTX_FORMAT_X_0         \"0x%016\"     PRIxPTR\n+#else\n+#define UINTX_FORMAT_X_0         \"0x%08\"      PRIxPTR\n+#endif\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_ROTATE_BITS_HPP\n+#define SHARE_UTILITIES_ROTATE_BITS_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+inline uint32_t rotate_right_32(uint32_t x, int distance) {\n+  distance = distance & 0x1F;\n+  if (distance > 0) {\n+    return (x >> distance) | (x << (32 - distance));\n+  } else {\n+    return x;\n+  }\n+}\n+\n+inline uint64_t rotate_right_64(uint64_t x, int distance) {\n+  distance = distance & 0x3F;\n+  if (distance > 0) {\n+    return (x >> distance) | (x << (64 - distance));\n+  } else {\n+    return x;\n+  }\n+}\n+\n+template<typename T,\n+    ENABLE_IF(std::is_integral<T>::value),\n+ENABLE_IF(sizeof(T) <= sizeof(uint64_t))>\n+inline T rotate_right(T x, int dist) {\n+  return (sizeof(x) <= sizeof(uint32_t)) ?\n+         rotate_right_32(static_cast<uint32_t>(x), dist) :\n+         rotate_right_64(static_cast<uint64_t>(x), dist);\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_ROTATE_BITS_HPP\n","filename":"src\/hotspot\/share\/utilities\/rotate_bits.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,310 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.lang;\n+\n+import org.openjdk.jmh.annotations.*;\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 1, time = 1)\n+@Measurement(iterations = 3, time = 1)\n+@Fork(value = 5)\n+public class SecondarySupersLookup {\n+    interface J  {}\n+    interface I01 {}\n+    interface I02 extends I01 {}\n+    interface I03 extends I02 {}\n+    interface I04 extends I03 {}\n+    interface I05 extends I04 {}\n+    interface I06 extends I05 {}\n+    interface I07 extends I06 {}\n+    interface I08 extends I07 {}\n+    interface I09 extends I08 {}\n+    interface I10 extends I09 {}\n+    interface I11 extends I10 {}\n+    interface I12 extends I11 {}\n+    interface I13 extends I12 {}\n+    interface I14 extends I13 {}\n+    interface I15 extends I14 {}\n+    interface I16 extends I15 {}\n+    interface I17 extends I16 {}\n+    interface I18 extends I17 {}\n+    interface I19 extends I18 {}\n+    interface I20 extends I19 {}\n+    interface I21 extends I20 {}\n+    interface I22 extends I21 {}\n+    interface I23 extends I22 {}\n+    interface I24 extends I23 {}\n+    interface I25 extends I24 {}\n+    interface I26 extends I25 {}\n+    interface I27 extends I26 {}\n+    interface I28 extends I27 {}\n+    interface I29 extends I28 {}\n+    interface I30 extends I29 {}\n+    interface I31 extends I30 {}\n+    interface I32 extends I31 {}\n+    interface I33 extends I32 {}\n+    interface I34 extends I33 {}\n+    interface I35 extends I34 {}\n+    interface I36 extends I35 {}\n+    interface I37 extends I36 {}\n+    interface I38 extends I37 {}\n+    interface I39 extends I38 {}\n+    interface I40 extends I39 {}\n+    interface I41 extends I40 {}\n+    interface I42 extends I41 {}\n+    interface I43 extends I42 {}\n+    interface I44 extends I43 {}\n+    interface I45 extends I44 {}\n+    interface I46 extends I45 {}\n+    interface I47 extends I46 {}\n+    interface I48 extends I47 {}\n+    interface I49 extends I48 {}\n+    interface I50 extends I49 {}\n+    interface I51 extends I50 {}\n+    interface I52 extends I51 {}\n+    interface I53 extends I52 {}\n+    interface I54 extends I53 {}\n+    interface I55 extends I54 {}\n+    interface I56 extends I55 {}\n+    interface I57 extends I56 {}\n+    interface I58 extends I57 {}\n+    interface I59 extends I58 {}\n+    interface I60 extends I59 {}\n+    interface I61 extends I60 {}\n+    interface I62 extends I61 {}\n+    interface I63 extends I62 {}\n+    interface I64 extends I63 {}\n+\n+    final Object obj00 = new Object();\n+    final Object obj01 = new I01() {};\n+    final Object obj02 = new I02() {};\n+    final Object obj03 = new I03() {};\n+    final Object obj04 = new I04() {};\n+    final Object obj05 = new I05() {};\n+    final Object obj06 = new I06() {};\n+    final Object obj07 = new I07() {};\n+    final Object obj08 = new I08() {};\n+    final Object obj09 = new I09() {};\n+    final Object obj10 = new I10() {};\n+    final Object obj16 = new I16() {};\n+    final Object obj20 = new I20() {};\n+    final Object obj30 = new I30() {};\n+    final Object obj32 = new I32() {};\n+    final Object obj40 = new I40() {};\n+    final Object obj50 = new I50() {};\n+    final Object obj55 = new I55() {};\n+    final Object obj56 = new I56() {};\n+    final Object obj57 = new I57() {};\n+    final Object obj58 = new I58() {};\n+    final Object obj59 = new I59() {};\n+    final Object obj60 = new I60() {};\n+    final Object obj61 = new I61() {};\n+    final Object obj62 = new I62() {};\n+    final Object obj63 = new I63() {};\n+    final Object obj64 = new I64() {};\n+\n+    static Class<?> getSuper(int idx) {\n+        int i = Math.abs(idx) % 10;\n+        switch (i) {\n+            case 0: return I01.class;\n+            case 1: return I02.class;\n+            case 2: return I03.class;\n+            case 3: return I04.class;\n+            case 4: return I05.class;\n+            case 5: return I06.class;\n+            case 6: return I07.class;\n+            case 7: return I08.class;\n+            case 8: return I09.class;\n+            case 9: return I10.class;\n+        }\n+        throw new InternalError(\"\" + i);\n+    }\n+\n+    @Setup\n+    public void warmup() {\n+        for (int i = 0; i < 20_000; i++) {\n+            Class<?> s = getSuper(i);\n+            test(obj01, s, s.isInstance(obj01));\n+            test(obj02, s, s.isInstance(obj02));\n+            test(obj03, s, s.isInstance(obj03));\n+            test(obj04, s, s.isInstance(obj04));\n+            test(obj05, s, s.isInstance(obj05));\n+            test(obj06, s, s.isInstance(obj06));\n+            test(obj07, s, s.isInstance(obj07));\n+            test(obj08, s, s.isInstance(obj08));\n+            test(obj09, s, s.isInstance(obj09));\n+        }\n+    }\n+\n+    private static void test(Object obj, Class<?> cls, boolean expected) {\n+        if (cls.isInstance(obj) != expected) {\n+            throw new InternalError(obj.getClass() + \" \" + cls + \" \" + expected);\n+        }\n+    }\n+    @Benchmark\n+    public void testPositive01() {\n+        test(obj01, I01.class, true);\n+    }\n+    @Benchmark public void testPositive02() {\n+        test(obj02, I02.class, true);\n+    }\n+    @Benchmark public void testPositive03() {\n+        test(obj03, I03.class, true);\n+    }\n+    @Benchmark public void testPositive04() {\n+        test(obj04, I04.class, true);\n+    }\n+    @Benchmark public void testPositive05() {\n+        test(obj05, I05.class, true);\n+    }\n+    @Benchmark public void testPositive06() {\n+        test(obj06, I06.class, true);\n+    }\n+    @Benchmark public void testPositive07() {\n+        test(obj07, I07.class, true);\n+    }\n+    @Benchmark public void testPositive08() {\n+        test(obj08, I08.class, true);\n+    }\n+    @Benchmark public void testPositive09() {\n+        test(obj09, I09.class, true);\n+    }\n+    @Benchmark public void testPositive10() {\n+        test(obj10, I10.class, true);\n+    }\n+    @Benchmark public void testPositive16() {\n+        test(obj16, I16.class, true);\n+    }\n+    @Benchmark public void testPositive20() {\n+        test(obj20, I20.class, true);\n+    }\n+    @Benchmark public void testPositive30() {\n+        test(obj30, I30.class, true);\n+    }\n+    @Benchmark public void testPositive32() {\n+        test(obj32, I32.class, true);\n+    }\n+    @Benchmark public void testPositive40() {\n+        test(obj40, I40.class, true);\n+    }\n+    @Benchmark public void testPositive50() {\n+        test(obj50, I50.class, true);\n+    }\n+    @Benchmark public void testPositive60() {\n+        test(obj60, I60.class, true);\n+    }\n+    @Benchmark public void testPositive63() {\n+        test(obj63, I63.class, true);\n+    }\n+    @Benchmark public void testPositive64() {\n+        test(obj64, I64.class, true);\n+    }\n+\n+    @Benchmark public void testNegative00() {\n+        test(obj00, J.class, false);\n+    }\n+    @Benchmark public void testNegative01() {\n+        test(obj01, J.class, false);\n+    }\n+    @Benchmark public void testNegative02() {\n+        test(obj02, J.class, false);\n+    }\n+    @Benchmark public void testNegative03() {\n+        test(obj03, J.class, false);\n+    }\n+    @Benchmark public void testNegative04() {\n+        test(obj04, J.class, false);\n+    }\n+    @Benchmark public void testNegative05() {\n+        test(obj05, J.class, false);\n+    }\n+    @Benchmark public void testNegative06() {\n+        test(obj06, J.class, false);\n+    }\n+    @Benchmark public void testNegative07() {\n+        test(obj07, J.class, false);\n+    }\n+    @Benchmark public void testNegative08() {\n+        test(obj08, J.class, false);\n+    }\n+    @Benchmark public void testNegative09() {\n+        test(obj09, J.class, false);\n+    }\n+    @Benchmark public void testNegative10() {\n+        test(obj10, J.class, false);\n+    }\n+    @Benchmark public void testNegative16() {\n+        test(obj16, J.class, false);\n+    }\n+    @Benchmark public void testNegative20() {\n+        test(obj20, J.class, false);\n+    }\n+    @Benchmark public void testNegative30() {\n+        test(obj30, J.class, false);\n+    }\n+    @Benchmark public void testNegative32() {\n+        test(obj32, J.class, false);\n+    }\n+    @Benchmark public void testNegative40() {\n+        test(obj40, J.class, false);\n+    }\n+    @Benchmark public void testNegative50() {\n+        test(obj50, J.class, false);\n+    }\n+    @Benchmark public void testNegative55() {\n+        test(obj55, J.class, false);\n+    }\n+    @Benchmark public void testNegative56() {\n+        test(obj56, J.class, false);\n+    }\n+    @Benchmark public void testNegative57() {\n+        test(obj57, J.class, false);\n+    }\n+    @Benchmark public void testNegative58() {\n+        test(obj58, J.class, false);\n+    }\n+    @Benchmark public void testNegative59() {\n+        test(obj59, J.class, false);\n+    }\n+    @Benchmark public void testNegative60() {\n+        test(obj60, J.class, false);\n+    }\n+    @Benchmark public void testNegative61() {\n+        test(obj61, J.class, false);\n+    }\n+    @Benchmark public void testNegative62() {\n+        test(obj62, J.class, false);\n+    }\n+    @Benchmark public void testNegative63() {\n+        test(obj63, J.class, false);\n+    }\n+\n+    @Benchmark public void testNegative64() {\n+        test(obj64, J.class, false);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/SecondarySupersLookup.java","additions":310,"deletions":0,"binary":false,"changes":310,"status":"added"}]}