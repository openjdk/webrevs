{"files":[{"patch":"@@ -64,0 +64,1 @@\n+    _caller_jvms->set_receiver_info(caller_jvms->receiver_info());\n@@ -443,1 +444,0 @@\n-    \/\/ count the current method and the callee\n@@ -445,5 +445,5 @@\n-    int inline_level = 0;\n-    if (!is_compiled_lambda_form) {\n-      if (method() == callee_method) {\n-        inline_level++;\n-      }\n+    const bool is_method_handle_invoker = is_compiled_lambda_form && !jvms->method()->is_compiled_lambda_form();\n+\n+    ciInstance* lform_callee_recv = nullptr;\n+    if (is_compiled_lambda_form && !is_method_handle_invoker) { \/\/ MH invokers don't have a receiver\n+      lform_callee_recv = jvms->compute_receiver_info(callee_method);\n@@ -451,3 +451,3 @@\n-    \/\/ count callers of current method and callee\n-    Node* callee_argument0 = is_compiled_lambda_form ? jvms->map()->argument(jvms, 0)->uncast() : nullptr;\n-    for (JVMState* j = jvms->caller(); j != nullptr && j->has_method(); j = j->caller()) {\n+\n+    int inline_level = 0;\n+    for (JVMState* j = jvms; j != nullptr && j->has_method(); j = j->caller()) {\n@@ -455,6 +455,9 @@\n-        if (is_compiled_lambda_form) {\n-          \/\/ Since compiled lambda forms are heavily reused we allow recursive inlining.  If it is truly\n-          \/\/ a recursion (using the same \"receiver\") we limit inlining otherwise we can easily blow the\n-          \/\/ compiler stack.\n-          Node* caller_argument0 = j->map()->argument(j, 0)->uncast();\n-          if (caller_argument0 == callee_argument0) {\n+        \/\/ Since compiled lambda forms are heavily reused we allow recursive inlining.  If it is truly\n+        \/\/ a recursion (using the same \"receiver\") we limit inlining otherwise we can easily blow the\n+        \/\/ compiler stack.\n+        if (lform_callee_recv != nullptr) {\n+          ciInstance* lform_caller_recv = j->receiver_info();\n+          assert(lform_caller_recv != nullptr || j->depth() == 1 ||\n+                 !j->caller()->method()->is_compiled_lambda_form(), \/\/ MH invoker\n+                 \"missing receiver info\");\n+          if (lform_caller_recv == lform_callee_recv || lform_caller_recv == nullptr) {\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -266,1 +266,2 @@\n-  _method(method) {\n+  _method(method),\n+  _receiver_info(nullptr) {\n@@ -282,1 +283,2 @@\n-  _method(nullptr) {\n+  _method(nullptr),\n+  _receiver_info(nullptr) {\n@@ -617,0 +619,1 @@\n+  n->set_receiver_info(_receiver_info);\n@@ -691,0 +694,14 @@\n+\/\/ Compute receiver info for a compiled lambda form at call site.\n+ciInstance* JVMState::compute_receiver_info(ciMethod* callee) const {\n+  assert(callee != nullptr && callee->is_compiled_lambda_form(), \"\");\n+  if (has_method() && method()->is_compiled_lambda_form()) { \/\/ callee is not a MH invoker\n+    Node* recv = map()->argument(this, 0);\n+    assert(recv != nullptr, \"\");\n+    const TypeOopPtr* recv_toop = recv->bottom_type()->isa_oopptr();\n+    if (recv_toop != nullptr && recv_toop->const_oop() != nullptr) {\n+      return recv_toop->const_oop()->as_instance();\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -1265,1 +1282,1 @@\n-void SafePointNode::set_local(JVMState* jvms, uint idx, Node *c) {\n+void SafePointNode::set_local(const JVMState* jvms, uint idx, Node *c) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":20,"deletions":3,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -210,0 +210,1 @@\n+  ciInstance*       _receiver_info; \/\/ Constant receiver instance for compiled lambda forms\n@@ -252,0 +253,1 @@\n+  ciInstance*    receiver_info() const { assert(has_method(), \"\"); return _receiver_info; }\n@@ -297,0 +299,1 @@\n+  void              set_receiver_info(ciInstance* recv) { assert(has_method() || recv == nullptr, \"\"); _receiver_info = recv; }\n@@ -304,0 +307,1 @@\n+  ciInstance* compute_receiver_info(ciMethod* callee) const;\n@@ -367,1 +371,1 @@\n-  void verify_input(JVMState* jvms, uint idx) const {\n+  void verify_input(const JVMState* jvms, uint idx) const {\n@@ -376,3 +380,5 @@\n-  Node *local(JVMState* jvms, uint idx) const {\n-    verify_input(jvms, jvms->locoff() + idx);\n-    return in(jvms->locoff() + idx);\n+  Node* local(const JVMState* jvms, uint idx) const {\n+    uint loc_idx = jvms->locoff() + idx;\n+    assert(jvms->is_loc(loc_idx), \"not a local slot\");\n+    verify_input(jvms, loc_idx);\n+    return in(loc_idx);\n@@ -380,3 +386,5 @@\n-  Node *stack(JVMState* jvms, uint idx) const {\n-    verify_input(jvms, jvms->stkoff() + idx);\n-    return in(jvms->stkoff() + idx);\n+  Node* stack(const JVMState* jvms, uint idx) const {\n+    uint stk_idx = jvms->stkoff() + idx;\n+    assert(jvms->is_stk(stk_idx), \"not a stack slot\");\n+    verify_input(jvms, stk_idx);\n+    return in(stk_idx);\n@@ -384,2 +392,4 @@\n-  Node *argument(JVMState* jvms, uint idx) const {\n-    verify_input(jvms, jvms->argoff() + idx);\n+  Node* argument(const JVMState* jvms, uint idx) const {\n+    uint arg_idx = jvms->argoff() + idx;\n+    assert(jvms->is_stk(arg_idx), \"not an argument slot\");\n+    verify_input(jvms, arg_idx);\n@@ -388,1 +398,1 @@\n-  Node *monitor_box(JVMState* jvms, uint idx) const {\n+  Node* monitor_box(const JVMState* jvms, uint idx) const {\n@@ -390,1 +400,3 @@\n-    return in(jvms->monitor_box_offset(idx));\n+    uint mon_box_idx = jvms->monitor_box_offset(idx);\n+    assert(jvms->is_monitor_box(mon_box_idx), \"not a monitor box offset\");\n+    return in(mon_box_idx);\n@@ -392,1 +404,1 @@\n-  Node *monitor_obj(JVMState* jvms, uint idx) const {\n+  Node* monitor_obj(const JVMState* jvms, uint idx) const {\n@@ -394,1 +406,3 @@\n-    return in(jvms->monitor_obj_offset(idx));\n+    uint mon_obj_idx = jvms->monitor_obj_offset(idx);\n+    assert(jvms->is_mon(mon_obj_idx) && !jvms->is_monitor_box(mon_obj_idx), \"not a monitor obj offset\");\n+    return in(mon_obj_idx);\n@@ -397,1 +411,1 @@\n-  void  set_local(JVMState* jvms, uint idx, Node *c);\n+  void  set_local(const JVMState* jvms, uint idx, Node *c);\n@@ -399,1 +413,1 @@\n-  void  set_stack(JVMState* jvms, uint idx, Node *c) {\n+  void  set_stack(const JVMState* jvms, uint idx, Node *c) {\n@@ -403,1 +417,1 @@\n-  void  set_argument(JVMState* jvms, uint idx, Node *c) {\n+  void  set_argument(const JVMState* jvms, uint idx, Node *c) {\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":30,"deletions":16,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1173,0 +1173,7 @@\n+\n+  \/\/ Capture receiver info for compiled lambda forms.\n+  if (method()->is_compiled_lambda_form()) {\n+    ciInstance* recv_info = _caller->compute_receiver_info(method());\n+    jvms->set_receiver_info(recv_info);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}