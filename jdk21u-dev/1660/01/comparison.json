{"files":[{"patch":"@@ -561,1 +561,145 @@\n-jlong CgroupSubsystem::limit_from_str(char* limit_str) {\n+bool CgroupController::read_string(const char* filename, char* buf, size_t buf_size) {\n+  assert(buf != nullptr, \"buffer must not be null\");\n+  assert(filename != nullptr, \"filename must be given\");\n+  char* s_path = subsystem_path();\n+  if (s_path == nullptr) {\n+    log_debug(os, container)(\"read_string: subsystem path is null\");\n+    return false;\n+  }\n+\n+  stringStream file_path;\n+  file_path.print_raw(s_path);\n+  file_path.print_raw(filename);\n+\n+  if (file_path.size() > MAXPATHLEN) {\n+    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n+    return false;\n+  }\n+  const char* absolute_path = file_path.freeze();\n+  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n+\n+  FILE* fp = os::fopen(absolute_path, \"r\");\n+  if (fp == nullptr) {\n+    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n+    return false;\n+  }\n+\n+  \/\/ Read a single line into the provided buffer.\n+  \/\/ At most buf_size - 1 characters.\n+  char* line = fgets(buf, buf_size, fp);\n+  fclose(fp);\n+  if (line == nullptr) {\n+    log_debug(os, container)(\"Empty file %s\", absolute_path);\n+    return false;\n+  }\n+  size_t len = strlen(line);\n+  assert(len <= buf_size - 1, \"At most buf_size - 1 bytes can be read\");\n+  if (line[len - 1] == '\\n') {\n+    line[len - 1] = '\\0'; \/\/ trim trailing new line\n+  }\n+  return true;\n+}\n+\n+bool CgroupController::read_number(const char* filename, julong* result) {\n+  char buf[1024];\n+  bool is_ok = read_string(filename, buf, 1024);\n+  if (!is_ok) {\n+    return false;\n+  }\n+  int matched = sscanf(buf, JULONG_FORMAT, result);\n+  if (matched == 1) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+bool CgroupController::read_number_handle_max(const char* filename, jlong* result) {\n+  char buf[1024];\n+  bool is_ok = read_string(filename, buf, 1024);\n+  if (!is_ok) {\n+    return false;\n+  }\n+  jlong val = limit_from_str(buf);\n+  if (val == OSCONTAINER_ERROR) {\n+    return false;\n+  }\n+  *result = val;\n+  return true;\n+}\n+\n+bool CgroupController::read_numerical_key_value(const char* filename, const char* key, julong* result) {\n+  assert(key != nullptr, \"key must be given\");\n+  assert(result != nullptr, \"result pointer must not be null\");\n+  assert(filename != nullptr, \"file to search in must be given\");\n+  char* s_path = subsystem_path();\n+  if (s_path == nullptr) {\n+    log_debug(os, container)(\"read_numerical_key_value: subsystem path is null\");\n+    return false;\n+  }\n+\n+  stringStream file_path;\n+  file_path.print_raw(s_path);\n+  file_path.print_raw(filename);\n+\n+  if (file_path.size() > MAXPATHLEN) {\n+    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n+    return false;\n+  }\n+  const char* absolute_path = file_path.freeze();\n+  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n+  FILE* fp = os::fopen(absolute_path, \"r\");\n+  if (fp == nullptr) {\n+    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n+    return false;\n+  }\n+\n+  const int buf_len = MAXPATHLEN+1;\n+  char buf[buf_len];\n+  char* line = fgets(buf, buf_len, fp);\n+  bool found_match = false;\n+  \/\/ File consists of multiple lines in a \"key value\"\n+  \/\/ fashion, we have to find the key.\n+  const size_t key_len = strlen(key);\n+  for (; line != nullptr; line = fgets(buf, buf_len, fp)) {\n+    char after_key = line[key_len];\n+    if (strncmp(line, key, key_len) == 0\n+          && isspace(after_key) != 0\n+          && after_key != '\\n') {\n+      \/\/ Skip key, skip space\n+      const char* value_substr = line + key_len + 1;\n+      int matched = sscanf(value_substr, JULONG_FORMAT, result);\n+      found_match = matched == 1;\n+      if (found_match) {\n+        break;\n+      }\n+    }\n+  }\n+  fclose(fp);\n+  if (found_match) {\n+    return true;\n+  }\n+  log_debug(os, container)(\"Type %s (key == %s) not found in file %s\", JULONG_FORMAT,\n+                           key, absolute_path);\n+  return false;\n+}\n+\n+bool CgroupController::read_numerical_tuple_value(const char* filename, bool use_first, jlong* result) {\n+  char buf[1024];\n+  bool is_ok = read_string(filename, buf, 1024);\n+  if (!is_ok) {\n+    return false;\n+  }\n+  char token[1024];\n+  const int matched = sscanf(buf, (use_first ? \"%1023s %*s\" : \"%*s %1023s\"), token);\n+  if (matched != 1) {\n+    return false;\n+  }\n+  jlong val = limit_from_str(token);\n+  if (val == OSCONTAINER_ERROR) {\n+    return false;\n+  }\n+  *result = val;\n+  return true;\n+}\n+\n+jlong CgroupController::limit_from_str(char* limit_str) {\n@@ -568,1 +712,0 @@\n-    os::free(limit_str);\n@@ -573,1 +716,0 @@\n-    os::free(limit_str);\n@@ -576,1 +718,0 @@\n-  os::free(limit_str);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":145,"deletions":4,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -72,87 +72,9 @@\n-typedef char * cptr;\n-\n-class CgroupController: public CHeapObj<mtInternal> {\n-  public:\n-    virtual char *subsystem_path() = 0;\n-};\n-\n-PRAGMA_DIAG_PUSH\n-PRAGMA_FORMAT_NONLITERAL_IGNORED\n-\/\/ Parses a subsystem's file, looking for a matching line.\n-\/\/ If key is null, then the first line will be matched with scan_fmt.\n-\/\/ If key isn't null, then each line will be matched, looking for something that matches \"$key $scan_fmt\".\n-\/\/ The matching value will be assigned to returnval.\n-\/\/ scan_fmt uses scanf() syntax.\n-\/\/ Return value: 0 on match, OSCONTAINER_ERROR on error.\n-template <typename T> int subsystem_file_line_contents(CgroupController* c,\n-                                              const char *filename,\n-                                              const char *key,\n-                                              const char *scan_fmt,\n-                                              T returnval) {\n-  if (c == nullptr) {\n-    log_debug(os, container)(\"subsystem_file_line_contents: CgroupController* is null\");\n-    return OSCONTAINER_ERROR;\n-  }\n-  if (c->subsystem_path() == nullptr) {\n-    log_debug(os, container)(\"subsystem_file_line_contents: subsystem path is null\");\n-    return OSCONTAINER_ERROR;\n-  }\n-\n-  stringStream file_path;\n-  file_path.print_raw(c->subsystem_path());\n-  file_path.print_raw(filename);\n-\n-  if (file_path.size() > (MAXPATHLEN-1)) {\n-    log_debug(os, container)(\"File path too long %s, %s\", file_path.base(), filename);\n-    return OSCONTAINER_ERROR;\n-  }\n-  const char* absolute_path = file_path.freeze();\n-  log_trace(os, container)(\"Path to %s is %s\", filename, absolute_path);\n-\n-  FILE* fp = os::fopen(absolute_path, \"r\");\n-  if (fp == nullptr) {\n-    log_debug(os, container)(\"Open of file %s failed, %s\", absolute_path, os::strerror(errno));\n-    return OSCONTAINER_ERROR;\n-  }\n-\n-  const int buf_len = MAXPATHLEN+1;\n-  char buf[buf_len];\n-  char* line = fgets(buf, buf_len, fp);\n-  if (line == nullptr) {\n-    log_debug(os, container)(\"Empty file %s\", absolute_path);\n-    fclose(fp);\n-    return OSCONTAINER_ERROR;\n-  }\n-\n-  bool found_match = false;\n-  if (key == nullptr) {\n-    \/\/ File consists of a single line according to caller, with only a value\n-    int matched = sscanf(line, scan_fmt, returnval);\n-    found_match = matched == 1;\n-  } else {\n-    \/\/ File consists of multiple lines in a \"key value\"\n-    \/\/ fashion, we have to find the key.\n-    const int key_len = (int)strlen(key);\n-    for (; line != nullptr; line = fgets(buf, buf_len, fp)) {\n-      char* key_substr = strstr(line, key);\n-      char after_key = line[key_len];\n-      if (key_substr == line\n-          && isspace(after_key) != 0\n-          && after_key != '\\n') {\n-        \/\/ Skip key, skip space\n-        const char* value_substr = line + key_len + 1;\n-        int matched = sscanf(value_substr, scan_fmt, returnval);\n-        found_match = matched == 1;\n-        if (found_match) {\n-          break;\n-        }\n-      }\n-    }\n-  }\n-  fclose(fp);\n-  if (found_match) {\n-    return 0;\n-  }\n-  log_debug(os, container)(\"Type %s (key == %s) not found in file %s\", scan_fmt,\n-                           (key == nullptr ? \"null\" : key), absolute_path);\n-  return OSCONTAINER_ERROR;\n+#define CONTAINER_READ_NUMBER_CHECKED(controller, filename, log_string, retval)       \\\n+{                                                                                     \\\n+  bool is_ok;                                                                         \\\n+  is_ok = controller->read_number(filename, &retval);                                 \\\n+  if (!is_ok) {                                                                       \\\n+    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);            \\\n+    return OSCONTAINER_ERROR;                                                         \\\n+  }                                                                                   \\\n+  log_trace(os, container)(log_string \" is: \" JULONG_FORMAT, retval);                 \\\n@@ -160,1 +82,0 @@\n-PRAGMA_DIAG_POP\n@@ -162,18 +83,9 @@\n-\/\/ log_fmt can be different than scan_fmt. For example\n-\/\/ cpu_period() for cgv2 uses log_fmt='%d' and scan_fmt='%*s %d'\n-#define GET_CONTAINER_INFO(return_type, subsystem, filename,              \\\n-                           logstring, log_fmt, scan_fmt, variable)        \\\n-  return_type variable;                                                   \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                     filename,                            \\\n-                                     nullptr,                             \\\n-                                     scan_fmt,                            \\\n-                                     &variable);                          \\\n-  if (err != 0) {                                                         \\\n-    log_trace(os, container)(logstring \"%d\", OSCONTAINER_ERROR);          \\\n-    return (return_type) OSCONTAINER_ERROR;                               \\\n-  }                                                                       \\\n-                                                                          \\\n-  log_trace(os, container)(logstring log_fmt, variable);                  \\\n+#define CONTAINER_READ_NUMBER_CHECKED_MAX(controller, filename, log_string, retval)   \\\n+{                                                                                     \\\n+  bool is_ok;                                                                         \\\n+  is_ok = controller->read_number_handle_max(filename, &retval);                      \\\n+  if (!is_ok) {                                                                       \\\n+    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);            \\\n+    return OSCONTAINER_ERROR;                                                         \\\n+  }                                                                                   \\\n+  log_trace(os, container)(log_string \" is: \" JLONG_FORMAT, retval);                  \\\n@@ -182,14 +94,9 @@\n-#define GET_CONTAINER_INFO_CPTR(return_type, subsystem, filename,         \\\n-                               logstring, scan_fmt, variable, bufsize)    \\\n-  char variable[bufsize];                                                 \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                     filename,                            \\\n-                                     nullptr,                             \\\n-                                     scan_fmt,                            \\\n-                                     variable);                           \\\n-  if (err != 0)                                                           \\\n-    return (return_type) nullptr;                                         \\\n-                                                                          \\\n-  log_trace(os, container)(logstring, variable);                          \\\n+#define CONTAINER_READ_STRING_CHECKED(controller, filename, log_string, retval, buf_size) \\\n+{                                                                                         \\\n+  bool is_ok;                                                                             \\\n+  is_ok = controller->read_string(filename, retval, buf_size);                            \\\n+  if (!is_ok) {                                                                           \\\n+    log_trace(os, container)(log_string \" failed: %d\", OSCONTAINER_ERROR);                \\\n+    return nullptr;                                                                       \\\n+  }                                                                                       \\\n+  log_trace(os, container)(log_string \" is: %s\", retval);                                 \\\n@@ -198,15 +105,48 @@\n-#define GET_CONTAINER_INFO_LINE(return_type, controller, filename,        \\\n-                           matchline, logstring, scan_fmt, variable)      \\\n-  return_type variable;                                                   \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(controller,                          \\\n-                                filename,                                 \\\n-                                matchline,                                \\\n-                                scan_fmt,                                 \\\n-                                &variable);                               \\\n-  if (err != 0)                                                           \\\n-    return (return_type) OSCONTAINER_ERROR;                               \\\n-                                                                          \\\n-  log_trace(os, container)(logstring, variable);                          \\\n-}\n+class CgroupController: public CHeapObj<mtInternal> {\n+  public:\n+    virtual char* subsystem_path() = 0;\n+\n+    \/* Read a numerical value as unsigned long\n+     *\n+     * returns: false if any error occurred. true otherwise and\n+     * the parsed value is set in the provided julong pointer.\n+     *\/\n+    bool read_number(const char* filename, julong* result);\n+\n+    \/* Convenience method to deal with numbers as well as the string 'max'\n+     * in interface files. Otherwise same as read_number().\n+     *\n+     * returns: false if any error occurred. true otherwise and\n+     * the parsed value (which might be negative) is being set in\n+     * the provided jlong pointer.\n+     *\/\n+    bool read_number_handle_max(const char* filename, jlong* result);\n+\n+    \/* Read a string of at most buf_size - 1 characters from the interface file.\n+     * The provided buffer must be at least buf_size in size so as to account\n+     * for the null terminating character. Callers must ensure that the buffer\n+     * is appropriately in-scope and of sufficient size.\n+     *\n+     * returns: false if any error occured. true otherwise and the passed\n+     * in buffer will contain the first buf_size - 1 characters of the string\n+     * or up to the first new line character ('\\n') whichever comes first.\n+     *\/\n+    bool read_string(const char* filename, char* buf, size_t buf_size);\n+\n+    \/* Read a tuple value as a number. Tuple is: '<first> <second>'.\n+     * Handles 'max' (for unlimited) for any tuple value. This is handy for\n+     * parsing interface files like cpu.max which contain such tuples.\n+     *\n+     * returns: false if any error occurred. true otherwise and the parsed\n+     * value of the appropriate tuple entry set in the provided jlong pointer.\n+     *\/\n+    bool read_numerical_tuple_value(const char* filename, bool use_first, jlong* result);\n+\n+    \/* Read a numerical value from a multi-line interface file. The matched line is\n+     * determined by the provided 'key'. The associated numerical value is being set\n+     * via the passed in julong pointer. Example interface file 'memory.stat'\n+     *\n+     * returns: false if any error occurred. true otherwise and the parsed value is\n+     * being set in the provided julong pointer.\n+     *\/\n+    bool read_numerical_key_value(const char* filename, const char* key, julong* result);\n@@ -214,0 +154,3 @@\n+  private:\n+    static jlong limit_from_str(char* limit_str);\n+};\n@@ -258,1 +201,0 @@\n-    jlong limit_from_str(char* limit_str);\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":78,"deletions":136,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -78,3 +78,3 @@\n-  GET_CONTAINER_INFO(jlong, this, \"\/memory.use_hierarchy\",\n-                    \"Use Hierarchy is: \", JLONG_FORMAT, JLONG_FORMAT, use_hierarchy);\n-  return use_hierarchy;\n+  julong use_hierarchy;\n+  CONTAINER_READ_NUMBER_CHECKED(this, \"\/memory.use_hierarchy\", \"Use Hierarchy\", use_hierarchy);\n+  return (jlong)use_hierarchy;\n@@ -92,3 +92,2 @@\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.limit_in_bytes\",\n-                     \"Memory Limit is: \", JULONG_FORMAT, JULONG_FORMAT, memlimit);\n-\n+  julong memlimit;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.limit_in_bytes\", \"Memory Limit\", memlimit);\n@@ -99,2 +98,8 @@\n-      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", \"hierarchical_memory_limit\",\n-                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, hier_memlimit)\n+      julong hier_memlimit;\n+      bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n+                                                                   \"hierarchical_memory_limit\",\n+                                                                   &hier_memlimit);\n+      if (!is_ok) {\n+        return OSCONTAINER_ERROR;\n+      }\n+      log_trace(os, container)(\"Hierarchical Memory Limit is: \" JULONG_FORMAT, hier_memlimit);\n@@ -128,2 +133,3 @@\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.memsw.limit_in_bytes\",\n-                     \"Memory and Swap Limit is: \", JULONG_FORMAT, JULONG_FORMAT, memswlimit);\n+  julong hier_memswlimit;\n+  julong memswlimit;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.memsw.limit_in_bytes\", \"Memory and Swap Limit\", memswlimit);\n@@ -136,2 +142,7 @@\n-      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", matchline,\n-                             \"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, JULONG_FORMAT, hier_memswlimit)\n+      bool is_ok = _memory->controller()->read_numerical_key_value(\"\/memory.stat\",\n+                                                                   matchline,\n+                                                                   &hier_memswlimit);\n+      if (!is_ok) {\n+        return OSCONTAINER_ERROR;\n+      }\n+      log_trace(os, container)(\"Hierarchical Memory and Swap Limit is: \" JULONG_FORMAT, hier_memswlimit);\n@@ -171,0 +182,7 @@\n+static inline\n+jlong memory_swap_usage_impl(CgroupController* ctrl) {\n+  julong memory_swap_usage;\n+  CONTAINER_READ_NUMBER_CHECKED(ctrl, \"\/memory.memsw.usage_in_bytes\", \"mem swap usage\", memory_swap_usage);\n+  return (jlong)memory_swap_usage;\n+}\n+\n@@ -172,3 +190,3 @@\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.swappiness\",\n-                     \"Swappiness is: \", JULONG_FORMAT, JULONG_FORMAT, swappiness);\n-  return swappiness;\n+  julong swappiness;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.swappiness\", \"Swappiness\", swappiness);\n+  return (jlong)swappiness;\n@@ -178,2 +196,2 @@\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.soft_limit_in_bytes\",\n-                     \"Memory Soft Limit is: \", JULONG_FORMAT, JULONG_FORMAT, memsoftlimit);\n+  julong memsoftlimit;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.soft_limit_in_bytes\", \"Memory Soft Limit\", memsoftlimit);\n@@ -198,3 +216,3 @@\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.usage_in_bytes\",\n-                     \"Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, memusage);\n-  return memusage;\n+  julong memusage;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.usage_in_bytes\", \"Memory Usage\", memusage);\n+  return (jlong)memusage;\n@@ -212,3 +230,3 @@\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.max_usage_in_bytes\",\n-                     \"Maximum Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, memmaxusage);\n-  return memmaxusage;\n+  julong memmaxusage;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.max_usage_in_bytes\", \"Maximum Memory Usage\", memmaxusage);\n+  return (jlong)memmaxusage;\n@@ -217,1 +235,0 @@\n-\n@@ -219,3 +236,3 @@\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.kmem.usage_in_bytes\",\n-                     \"Kernel Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, kmem_usage);\n-  return kmem_usage;\n+  julong kmem_usage;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.usage_in_bytes\", \"Kernel Memory Usage\", kmem_usage);\n+  return (jlong)kmem_usage;\n@@ -225,2 +242,2 @@\n-  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.kmem.limit_in_bytes\",\n-                     \"Kernel Memory Limit is: \", JULONG_FORMAT, JULONG_FORMAT, kmem_limit);\n+  julong kmem_limit;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.limit_in_bytes\", \"Kernel Memory Limit\", kmem_limit);\n@@ -234,3 +251,3 @@\n-  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.kmem.max_usage_in_bytes\",\n-                     \"Maximum Kernel Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, kmem_max_usage);\n-  return kmem_max_usage;\n+  julong kmem_max_usage;\n+  CONTAINER_READ_NUMBER_CHECKED(_memory->controller(), \"\/memory.kmem.max_usage_in_bytes\", \"Maximum Kernel Memory Usage\", kmem_max_usage);\n+  return (jlong)kmem_max_usage;\n@@ -249,3 +266,3 @@\n-char * CgroupV1Subsystem::cpu_cpuset_cpus() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.cpus\",\n-                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n+char* CgroupV1Subsystem::cpu_cpuset_cpus() {\n+  char cpus[1024];\n+  CONTAINER_READ_STRING_CHECKED(_cpuset, \"\/cpuset.cpus\", \"cpuset.cpus\", cpus, 1024);\n@@ -255,3 +272,3 @@\n-char * CgroupV1Subsystem::cpu_cpuset_memory_nodes() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.mems\",\n-                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n+char* CgroupV1Subsystem::cpu_cpuset_memory_nodes() {\n+  char mems[1024];\n+  CONTAINER_READ_STRING_CHECKED(_cpuset, \"\/cpuset.mems\", \"cpuset.mems\", mems, 1024);\n@@ -272,3 +289,12 @@\n-  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.cfs_quota_us\",\n-                     \"CPU Quota is: \", \"%d\", \"%d\", quota);\n-  return quota;\n+  julong quota;\n+  bool is_ok = _cpu->controller()->\n+                  read_number(\"\/cpu.cfs_quota_us\", &quota);\n+  if (!is_ok) {\n+    log_trace(os, container)(\"CPU Quota failed: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  \/\/ cast to int since the read value might be negative\n+  \/\/ and we want to avoid logging -1 as a large unsigned value.\n+  int quota_int = (int)quota;\n+  log_trace(os, container)(\"CPU Quota is: %d\", quota_int);\n+  return quota_int;\n@@ -278,3 +304,3 @@\n-  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.cfs_period_us\",\n-                     \"CPU Period is: \", \"%d\", \"%d\", period);\n-  return period;\n+  julong period;\n+  CONTAINER_READ_NUMBER_CHECKED(_cpu->controller(), \"\/cpu.cfs_period_us\", \"CPU Period\", period);\n+  return (int)period;\n@@ -294,2 +320,3 @@\n-  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.shares\",\n-                     \"CPU Shares is: \", \"%d\", \"%d\", shares);\n+  julong shares;\n+  CONTAINER_READ_NUMBER_CHECKED(_cpu->controller(), \"\/cpu.shares\", \"CPU Shares\", shares);\n+  int shares_int = (int)shares;\n@@ -297,5 +324,1 @@\n-  if (shares == 1024) return -1;\n-\n-  return shares;\n-}\n-\n+  if (shares_int == 1024) return -1;\n@@ -303,4 +326,1 @@\n-char* CgroupV1Subsystem::pids_max_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _pids, \"\/pids.max\",\n-                     \"Maximum number of tasks is: %s\", \"%1023s\", pidsmax, 1024);\n-  return os::strdup(pidsmax);\n+  return shares_int;\n@@ -320,2 +340,3 @@\n-  char * pidsmax_str = pids_max_val();\n-  return limit_from_str(pidsmax_str);\n+  jlong pids_max;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(_pids, \"\/pids.max\", \"Maximum number of tasks\", pids_max);\n+  return pids_max;\n@@ -334,3 +355,3 @@\n-  GET_CONTAINER_INFO(jlong, _pids, \"\/pids.current\",\n-                     \"Current number of tasks is: \", JLONG_FORMAT, JLONG_FORMAT, pids_current);\n-  return pids_current;\n+  julong pids_current;\n+  CONTAINER_READ_NUMBER_CHECKED(_pids, \"\/pids.current\", \"Current number of tasks\", pids_current);\n+  return (jlong)pids_current;\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":81,"deletions":60,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -114,2 +114,0 @@\n-    char * pids_max_val();\n-\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,2 +38,3 @@\n-  GET_CONTAINER_INFO(int, _unified, \"\/cpu.weight\",\n-                     \"Raw value for CPU Shares is: \", \"%d\", \"%d\", shares);\n+  julong shares;\n+  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/cpu.weight\", \"Raw value for CPU Shares\", shares);\n+  int shares_int = (int)shares;\n@@ -41,1 +42,1 @@\n-  if (shares == 100) {\n+  if (shares_int == 100) {\n@@ -53,1 +54,1 @@\n-  int x = 262142 * shares - 1;\n+  int x = 262142 * shares_int - 1;\n@@ -86,2 +87,6 @@\n-  char * cpu_quota_str = cpu_quota_val();\n-  int limit = (int)limit_from_str(cpu_quota_str);\n+  jlong quota_val;\n+  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", true \/* use_first *\/, &quota_val);\n+  if (!is_ok) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  int limit = (int)quota_val;\n@@ -92,3 +97,3 @@\n-char * CgroupV2Subsystem::cpu_cpuset_cpus() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.cpus\",\n-                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n+char* CgroupV2Subsystem::cpu_cpuset_cpus() {\n+  char cpus[1024];\n+  CONTAINER_READ_STRING_CHECKED(_unified, \"\/cpuset.cpus\", \"cpuset.cpus\", cpus, 1024);\n@@ -98,9 +103,3 @@\n-char* CgroupV2Subsystem::cpu_quota_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpu.max\",\n-                     \"Raw value for CPU quota is: %s\", \"%1023s %*d\", quota, 1024);\n-  return os::strdup(quota);\n-}\n-\n-char * CgroupV2Subsystem::cpu_cpuset_memory_nodes() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.mems\",\n-                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n+char* CgroupV2Subsystem::cpu_cpuset_memory_nodes() {\n+  char mems[1024];\n+  CONTAINER_READ_STRING_CHECKED(_unified, \"\/cpuset.mems\", \"cpuset.mems\", mems, 1024);\n@@ -111,2 +110,8 @@\n-  GET_CONTAINER_INFO(int, _unified, \"\/cpu.max\",\n-                     \"CPU Period is: \", \"%d\", \"%*s %d\", period);\n+  jlong period_val;\n+  bool is_ok = _unified->read_numerical_tuple_value(\"\/cpu.max\", false \/* use_first *\/, &period_val);\n+  if (!is_ok) {\n+    log_trace(os, container)(\"CPU Period failed: %d\", OSCONTAINER_ERROR);\n+    return OSCONTAINER_ERROR;\n+  }\n+  int period = (int)period_val;\n+  log_trace(os, container)(\"CPU Period is: %d\", period);\n@@ -126,3 +131,3 @@\n-  GET_CONTAINER_INFO(jlong, _unified, \"\/memory.current\",\n-                     \"Memory Usage is: \", JLONG_FORMAT, JLONG_FORMAT, memusage);\n-  return memusage;\n+  julong memusage;\n+  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/memory.current\", \"Memory Usage\", memusage);\n+  return (jlong)memusage;\n@@ -132,2 +137,3 @@\n-  char* mem_soft_limit_str = mem_soft_limit_val();\n-  return limit_from_str(mem_soft_limit_str);\n+  jlong mem_soft_limit;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.low\", \"Memory Soft Limit\", mem_soft_limit);\n+  return mem_soft_limit;\n@@ -142,6 +148,0 @@\n-char* CgroupV2Subsystem::mem_soft_limit_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.low\",\n-                         \"Memory Soft Limit is: %s\", \"%1023s\", mem_soft_limit_str, 1024);\n-  return os::strdup(mem_soft_limit_str);\n-}\n-\n@@ -154,2 +154,3 @@\n-  char* mem_swp_limit_str = mem_swp_limit_val();\n-  if (mem_swp_limit_str == nullptr) {\n+  jlong swap_limit;\n+  bool is_ok = _memory->controller()->read_number_handle_max(\"\/memory.swap.max\", &swap_limit);\n+  if (!is_ok) {\n@@ -157,1 +158,1 @@\n-    log_trace(os, container)(\"Memory and Swap Limit is: %d\", OSCONTAINER_ERROR);\n+    log_trace(os, container)(\"Swap Limit failed: %d\", OSCONTAINER_ERROR);\n@@ -161,1 +162,1 @@\n-  jlong swap_limit = limit_from_str(mem_swp_limit_str);\n+  log_trace(os, container)(\"Swap Limit is: \" JLONG_FORMAT, swap_limit);\n@@ -171,4 +172,4 @@\n-char* CgroupV2Subsystem::mem_swp_limit_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.swap.max\",\n-                         \"Memory and Swap Limit is: %s\", \"%1023s\", mem_swp_limit_str, 1024);\n-  return os::strdup(mem_swp_limit_str);\n+jlong CgroupV2Subsystem::mem_swp_limit_val() {\n+  jlong swap_limit;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.swap.max\", \"Swap Limit\", swap_limit);\n+  return swap_limit;\n@@ -178,4 +179,4 @@\n-char* CgroupV2Subsystem::mem_swp_current_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.swap.current\",\n-                         \"Swap currently used is: %s\", \"%1023s\", mem_swp_current_str, 1024);\n-  return os::strdup(mem_swp_current_str);\n+jlong CgroupV2Subsystem::mem_swp_current_val() {\n+  julong swap_current;\n+  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/memory.swap.current\", \"Swap currently used\", swap_current);\n+  return (jlong)swap_current;\n@@ -193,16 +194,3 @@\n-  char * mem_limit_str = mem_limit_val();\n-  jlong limit = limit_from_str(mem_limit_str);\n-  if (log_is_enabled(Trace, os, container)) {\n-    if (limit == -1) {\n-      log_trace(os, container)(\"Memory Limit is: Unlimited\");\n-    } else {\n-      log_trace(os, container)(\"Memory Limit is: \" JLONG_FORMAT, limit);\n-    }\n-  }\n-  return limit;\n-}\n-\n-char* CgroupV2Subsystem::mem_limit_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.max\",\n-                         \"Raw value for memory limit is: %s\", \"%1023s\", mem_limit_str, 1024);\n-  return os::strdup(mem_limit_str);\n+  jlong memory_limit;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/memory.max\", \"Memory Limit\", memory_limit);\n+  return memory_limit;\n@@ -212,5 +200,2 @@\n-  char* mem_swp_current_str = mem_swp_current_val();\n-  jlong swap_current = limit_from_str(mem_swp_current_str);\n-\n-  char* mem_swp_limit_str = mem_swp_limit_val();\n-  jlong swap_limit = limit_from_str(mem_swp_limit_str);\n+  jlong swap_current = mem_swp_current_val();\n+  jlong swap_limit = mem_swp_limit_val();\n@@ -231,6 +216,0 @@\n-char* CgroupV2Subsystem::pids_max_val() {\n-  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/pids.max\",\n-                     \"Maximum number of tasks is: %s\", \"%1023s\", pidsmax, 1024);\n-  return os::strdup(pidsmax);\n-}\n-\n@@ -247,2 +226,3 @@\n-  char * pidsmax_str = pids_max_val();\n-  return limit_from_str(pidsmax_str);\n+  jlong pids_max;\n+  CONTAINER_READ_NUMBER_CHECKED_MAX(_unified, \"\/pids.max\", \"Maximum number of tasks\", pids_max);\n+  return pids_max;\n@@ -260,2 +240,2 @@\n-  GET_CONTAINER_INFO(jlong, _unified, \"\/pids.current\",\n-                     \"Current number of tasks is: \", JLONG_FORMAT, JLONG_FORMAT, pids_current);\n+  julong pids_current;\n+  CONTAINER_READ_NUMBER_CHECKED(_unified, \"\/pids.current\", \"Current number of tasks\", pids_current);\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":54,"deletions":74,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -59,6 +59,2 @@\n-    char *mem_limit_val();\n-    char *mem_swp_limit_val();\n-    char *mem_swp_current_val();\n-    char *mem_soft_limit_val();\n-    char *cpu_quota_val();\n-    char *pids_max_val();\n+    jlong mem_swp_limit_val();\n+    jlong mem_swp_current_val();\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,204 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#ifdef LINUX\n-\n-#include \"runtime\/os.hpp\"\n-#include \"cgroupSubsystem_linux.hpp\"\n-#include \"unittest.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-#include <stdio.h>\n-\n-\n-\/\/ Utilities\n-bool file_exists(const char* filename) {\n-  struct stat st;\n-  return os::stat(filename, &st) == 0;\n-}\n-\n-char* temp_file(const char* prefix) {\n-  const testing::TestInfo* test_info = ::testing::UnitTest::GetInstance()->current_test_info();\n-  stringStream path;\n-  path.print_raw(os::get_temp_directory());\n-  path.print_raw(os::file_separator());\n-  path.print(\"%s-test-jdk.pid%d.%s.%s\", prefix, os::current_process_id(),\n-             test_info->test_case_name(), test_info->name());\n-  return path.as_string(true);\n-}\n-\n-void delete_file(const char* filename) {\n-  if (!file_exists(filename)) {\n-    return;\n-  }\n-  int ret = remove(filename);\n-  EXPECT_TRUE(ret == 0 || errno == ENOENT) << \"failed to remove file '\" << filename << \"': \"\n-      << os::strerror(errno) << \" (\" << errno << \")\";\n-}\n-\n-class TestController : public CgroupController {\n-public:\n-  char* subsystem_path() override {\n-    \/\/ The real subsystem is in \/tmp\/, generated by temp_file()\n-    return (char*)\"\/\";\n-  };\n-};\n-\n-void fill_file(const char* path, const char* content) {\n-  delete_file(path);\n-  FILE* fp = os::fopen(path, \"w\");\n-  if (fp == nullptr) {\n-    return;\n-  }\n-  if (content != nullptr) {\n-    fprintf(fp, \"%s\", content);\n-  }\n-  fclose(fp);\n-}\n-\n-TEST(cgroupTest, SubSystemFileLineContentsMultipleLinesErrorCases) {\n-  TestController my_controller{};\n-  const char* test_file = temp_file(\"cgroups\");\n-  int x = 0;\n-  char s[1024];\n-  int err = 0;\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo \");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_NE(err, 0) << \"Value must not be missing in key\/value case\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"faulty_start foo bar\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_NE(err, 0) << \"Key must be at start\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foof bar\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_NE(err, 0) << \"Key must be exact match\";\n-\n-  \/\/ Cleanup\n-  delete_file(test_file);\n-}\n-\n-TEST(cgroupTest, SubSystemFileLineContentsMultipleLinesSuccessCases) {\n-  TestController my_controller{};\n-  const char* test_file = temp_file(\"cgroups\");\n-  int x = 0;\n-  char s[1024];\n-  int err = 0;\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo bar\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"bar\") << \"Incorrect!\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo\\tbar\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"bar\") << \"Incorrect!\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foof bar\\nfoo car\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"car\");\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo\\ttest\\nfoot car\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"test\");\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"foo 1\\nfoo car\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, \"foo\", \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"1\");\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"max 10000\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s %*d\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"max\");\n-\n-  x = -3;\n-  fill_file(test_file, \"max 10001\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%*s %d\", &x);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(x, 10001);\n-\n-  \/\/ Cleanup\n-  delete_file(test_file);\n-}\n-\n-TEST(cgroupTest, SubSystemFileLineContentsSingleLine) {\n-  TestController my_controller{};\n-  const char* test_file = temp_file(\"cgroups\");\n-  int x = 0;\n-  char s[1024];\n-  int err = 0;\n-\n-  fill_file(test_file, \"foo\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"foo\");\n-\n-  fill_file(test_file, \"1337\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%d\", &x);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(x, 1337) << \"Wrong value for x\";\n-\n-  s[0] = '\\0';\n-  fill_file(test_file, \"1337\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%s\", &s);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_STREQ(s, \"1337\");\n-\n-  x = -1;\n-  fill_file(test_file, nullptr);\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, \"%d\", &x);\n-  EXPECT_NE(err, 0) << \"Empty file should've failed\";\n-  EXPECT_EQ(x, -1) << \"x was altered\";\n-\n-  jlong y;\n-  fill_file(test_file, \"1337\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, JLONG_FORMAT, &y);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(y, 1337) << \"Wrong value for y\";\n-  julong z;\n-  fill_file(test_file, \"1337\");\n-  err = subsystem_file_line_contents(&my_controller, test_file, nullptr, JULONG_FORMAT, &z);\n-  EXPECT_EQ(err, 0);\n-  EXPECT_EQ(z, (julong)1337) << \"Wrong value for z\";\n-\n-  \/\/ Cleanup\n-  delete_file(test_file);\n-}\n-\n-#endif \/\/ LINUX\n","filename":"test\/hotspot\/gtest\/os\/linux\/test_cgroupSubsystem_linux.cpp","additions":0,"deletions":204,"binary":false,"changes":204,"status":"deleted"},{"patch":"@@ -0,0 +1,468 @@\n+\/*\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#ifdef LINUX\n+\n+#include \"runtime\/os.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+#include \"cgroupV1Subsystem_linux.hpp\"\n+#include \"cgroupV2Subsystem_linux.hpp\"\n+#include \"unittest.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include <stdio.h>\n+\n+\/\/ for basename\n+#include <libgen.h>\n+\n+typedef struct {\n+  const char* mount_path;\n+  const char* root_path;\n+  const char* cgroup_path;\n+  const char* expected_path;\n+} TestCase;\n+\n+\/\/ Utilities\n+static bool file_exists(const char* filename) {\n+  struct stat st;\n+  return os::stat(filename, &st) == 0;\n+}\n+\n+\/\/ we rely on temp_file returning modifiable memory in resource area.\n+static char* temp_file(const char* prefix) {\n+  const testing::TestInfo* test_info = ::testing::UnitTest::GetInstance()->current_test_info();\n+  stringStream path;\n+  path.print_raw(os::get_temp_directory());\n+  path.print_raw(os::file_separator());\n+  path.print(\"%s-test-jdk.pid%d.%s.%s\", prefix, os::current_process_id(),\n+             test_info->test_case_name(), test_info->name());\n+  return path.as_string(true);\n+}\n+\n+static void delete_file(const char* filename) {\n+  if (!file_exists(filename)) {\n+    return;\n+  }\n+  int ret = remove(filename);\n+  EXPECT_TRUE(ret == 0 || errno == ENOENT) << \"failed to remove file '\" << filename << \"': \"\n+      << os::strerror(errno) << \" (\" << errno << \")\";\n+}\n+\n+class TestController : public CgroupController {\n+private:\n+  char* _path;\n+public:\n+  TestController(char* p): _path(p) {}\n+  char* subsystem_path() override {\n+    return _path;\n+  };\n+};\n+\n+static void fill_file(const char* path, const char* content) {\n+  delete_file(path);\n+  FILE* fp = os::fopen(path, \"w\");\n+  if (fp == nullptr) {\n+    return;\n+  }\n+  if (content != nullptr) {\n+    fprintf(fp, \"%s\", content);\n+  }\n+  fclose(fp);\n+}\n+\n+TEST(cgroupTest, read_numerical_key_value_failure_cases) {\n+  char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  constexpr julong bad = 0xBAD;\n+  julong x = bad;\n+\n+  fill_file(test_file, \"foo \");\n+  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"Value is missing in key\/value case, expecting false\";\n+  EXPECT_EQ(bad, x) << \"x must be unchanged\";\n+\n+  x = bad;\n+  fill_file(test_file, \"faulty_start foo 101\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"key must be at the start\";\n+  EXPECT_EQ(bad, x) << \"x must be unchanged\";\n+\n+  x = bad;\n+  fill_file(test_file, nullptr);\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"key not in empty file\";\n+  EXPECT_EQ(bad, x) << \"x must be unchanged\";\n+\n+  x = bad;\n+  fill_file(test_file, \"foo\\n\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"key must have a value\";\n+  EXPECT_EQ(bad, x) << \"x must be unchanged\";\n+\n+  x = bad;\n+  fill_file(test_file, \"foof 1002\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_FALSE(is_ok) << \"key must be exact match\";\n+  EXPECT_EQ(bad, x) << \"x must be unchanged\";\n+\n+  \/\/ Cleanup\n+  delete_file(test_file);\n+}\n+\n+TEST(cgroupTest, read_numerical_key_value_success_cases) {\n+  char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  constexpr julong bad = 0xBAD;\n+  julong x = bad;\n+\n+  fill_file(test_file, \"foo 100\");\n+  bool is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)100, x);\n+\n+  x = bad;\n+  fill_file(test_file, \"foo\\t111\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)111, x);\n+\n+  x = bad;\n+  fill_file(test_file, \"foo\\nbar 333\\nfoo\\t111\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)111, x);\n+\n+  x = bad;\n+  fill_file(test_file, \"foof 100\\nfoo 133\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)133, x);\n+\n+  x = bad;\n+  fill_file(test_file, \"foo\\t333\\nfoot 999\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)333, x);\n+\n+  x = bad;\n+  fill_file(test_file, \"foo 1\\nfoo car\");\n+  is_ok = controller->read_numerical_key_value(base_with_slash, \"foo\", &x);\n+  EXPECT_TRUE(is_ok);\n+  EXPECT_EQ((julong)1, x);\n+\n+  \/\/ Cleanup\n+  delete_file(test_file);\n+}\n+\n+TEST(cgroupTest, read_number_null) {\n+  TestController* null_path_controller = new TestController((char*)nullptr);\n+  const char* test_file_path = \"\/not-used\";\n+  constexpr julong bad = 0xBAD;\n+  julong a = bad;\n+  \/\/ null subsystem_path() case\n+  bool is_ok = null_path_controller->read_number(test_file_path, &a);\n+  EXPECT_FALSE(is_ok) << \"Null subsystem path should be an error\";\n+  EXPECT_EQ(bad, a) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, read_string_beyond_max_path) {\n+  char larger_than_max[MAXPATHLEN + 1];\n+  for (int i = 0; i < (MAXPATHLEN); i++) {\n+    larger_than_max[i] = 'A' + (i % 26);\n+  }\n+  larger_than_max[MAXPATHLEN] = '\\0';\n+  TestController* too_large_path_controller = new TestController(larger_than_max);\n+  const char* test_file_path = \"\/file-not-found\";\n+  char foo[1024];\n+  foo[0] = '\\0';\n+  bool is_ok = too_large_path_controller->read_string(test_file_path, foo, 1024);\n+  EXPECT_FALSE(is_ok) << \"Too long path should be an error\";\n+  EXPECT_STREQ(\"\", foo) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, read_number_file_not_exist) {\n+  TestController* unknown_path_ctrl = new TestController((char*)\"\/do\/not\/exist\");\n+  const char* test_file_path = \"\/file-not-found\";\n+  constexpr julong bad = 0xBAD;\n+  julong result = bad;\n+  bool is_ok = unknown_path_ctrl->read_number(test_file_path, &result);\n+  EXPECT_FALSE(is_ok) << \"File not found should be an error\";\n+  EXPECT_EQ(bad, result) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, read_numerical_key_value_null) {\n+  TestController* null_path_controller = new TestController((char*)nullptr);\n+  const char* test_file_path = \"\/not-used\";\n+  const char* key = \"something\";\n+  constexpr julong bad = 0xBAD;\n+  julong a = bad;\n+  \/\/ null subsystem_path() case\n+  bool is_ok = null_path_controller->read_numerical_key_value(test_file_path, key, &a);\n+  EXPECT_FALSE(is_ok) << \"Null subsystem path should be an error\";\n+  EXPECT_EQ(bad, a) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, read_number_tests) {\n+  char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  constexpr julong bad = 0xBAD;\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+  fill_file(test_file, \"8888\");\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  julong foo = bad;\n+  bool ok = controller->read_number(base_with_slash, &foo);\n+  EXPECT_TRUE(ok) << \"Number parsing should have been successful\";\n+  EXPECT_EQ((julong)8888, foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n+\n+  \/\/ Some interface files might have negative values, ensure we can read\n+  \/\/ them and manually cast them as needed.\n+  fill_file(test_file, \"-1\");\n+  foo = bad;\n+  ok = controller->read_number(base_with_slash, &foo);\n+  EXPECT_TRUE(ok) << \"Number parsing should have been successful\";\n+  EXPECT_EQ((jlong)-1, (jlong)foo) << \"Wrong value for 'foo' (NOTE: 0xBAD == \" << 0xBAD << \")\";\n+\n+  foo = bad;\n+  fill_file(test_file, nullptr);\n+  ok = controller->read_number(base_with_slash, &foo);\n+  EXPECT_FALSE(ok) << \"Empty file should have failed\";\n+  EXPECT_EQ(bad, foo) << \"foo was altered\";\n+\n+  \/\/ Some interface files have numbers as well as the string\n+  \/\/ 'max', which means unlimited.\n+  jlong result = -10;\n+  fill_file(test_file, \"max\\n\");\n+  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  EXPECT_TRUE(ok) << \"Number parsing for 'max' string should have been successful\";\n+  EXPECT_EQ((jlong)-1, result) << \"'max' means unlimited (-1)\";\n+\n+  result = -10;\n+  fill_file(test_file, \"11114\\n\");\n+  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  EXPECT_TRUE(ok) << \"Number parsing for should have been successful\";\n+  EXPECT_EQ((jlong)11114, result) << \"Incorrect result\";\n+\n+  result = -10;\n+  fill_file(test_file, \"-51114\\n\");\n+  ok = controller->read_number_handle_max(base_with_slash, &result);\n+  EXPECT_TRUE(ok) << \"Number parsing for should have been successful\";\n+  EXPECT_EQ((jlong)-51114, result) << \"Incorrect result\";\n+\n+  delete_file(test_file);\n+}\n+\n+TEST(cgroupTest, read_string_tests) {\n+  char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+  fill_file(test_file, \"foo-bar\");\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  char result[1024];\n+  bool ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_STREQ(\"foo-bar\", result);\n+\n+  result[0] = '\\0';\n+  fill_file(test_file, \"1234\");\n+  ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_STREQ(\"1234\", result);\n+\n+  \/\/ values with a space\n+  result[0] = '\\0';\n+  fill_file(test_file, \"abc def\");\n+  ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_STREQ(\"abc def\", result);\n+\n+  result[0] = '\\0';\n+  fill_file(test_file, \"  \\na\");\n+  ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_STREQ(\"  \", result);\n+\n+  \/\/ only the first line are being returned\n+  result[0] = '\\0';\n+  fill_file(test_file, \"test\\nabc\");\n+  ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_STREQ(\"test\", result);\n+\n+  result[0] = '\\0';\n+  fill_file(test_file, nullptr);\n+  ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_FALSE(ok) << \"Empty file should have failed\";\n+  EXPECT_STREQ(\"\", result) << \"Expected untouched result\";\n+  delete_file(test_file);\n+\n+  \/\/ File contents larger than 1K\n+  \/\/ We only read in the first 1K - 1 bytes\n+  const size_t large_len = 2 * 1024;\n+  char too_large[large_len];\n+  for (size_t i = 0; i < large_len; i++) {\n+    too_large[i] = 'A' + (i % 26);\n+  }\n+  too_large[large_len - 1] = '\\0';\n+  result[0] = '\\0';\n+  fill_file(test_file, too_large);\n+  ok = controller->read_string(base_with_slash, result, 1024);\n+  EXPECT_TRUE(ok) << \"String parsing should have been successful\";\n+  EXPECT_TRUE(1023 == strlen(result)) << \"Expected only the first 1023 chars to be read in\";\n+  EXPECT_EQ(0, strncmp(too_large, result, 1023));\n+  EXPECT_EQ(result[1023], '\\0') << \"The last character must be the null character\";\n+}\n+\n+TEST(cgroupTest, read_number_tuple_test) {\n+  char* test_file = temp_file(\"cgroups\");\n+  const char* b = basename(test_file);\n+  EXPECT_TRUE(b != nullptr) << \"basename was null\";\n+  stringStream path;\n+  path.print_raw(os::file_separator());\n+  path.print_raw(b);\n+  const char* base_with_slash = path.as_string(true);\n+  fill_file(test_file, \"max 10000\");\n+\n+  TestController* controller = new TestController((char*)os::get_temp_directory());\n+  jlong result = -10;\n+  bool ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, &result);\n+  EXPECT_TRUE(ok) << \"Should be OK to read value\";\n+  EXPECT_EQ((jlong)-1, result) << \"max should be unlimited (-1)\";\n+\n+  result = -10;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, false \/* use_first *\/, &result);\n+  EXPECT_TRUE(ok) << \"Should be OK to read the value\";\n+  EXPECT_EQ((jlong)10000, result);\n+\n+  \/\/ non-max strings\n+  fill_file(test_file, \"abc 10000\");\n+  result = -10;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, &result);\n+  EXPECT_FALSE(ok) << \"abc should not be parsable\";\n+  EXPECT_EQ((jlong)-10, result) << \"result value should be unchanged\";\n+\n+  fill_file(test_file, nullptr);\n+  result = -10;\n+  ok = controller->read_numerical_tuple_value(base_with_slash, true \/* use_first *\/, &result);\n+  EXPECT_FALSE(ok) << \"Empty file should be an error\";\n+  EXPECT_EQ((jlong)-10, result) << \"result value should be unchanged\";\n+}\n+\n+TEST(cgroupTest, read_numerical_key_beyond_max_path) {\n+  char larger_than_max[MAXPATHLEN + 1];\n+  for (int i = 0; i < (MAXPATHLEN); i++) {\n+    larger_than_max[i] = 'A' + (i % 26);\n+  }\n+  larger_than_max[MAXPATHLEN] = '\\0';\n+  TestController* too_large_path_controller = new TestController(larger_than_max);\n+  const char* test_file_path = \"\/file-not-found\";\n+  const char* key = \"something\";\n+  julong a = 0xBAD;\n+  bool is_ok = too_large_path_controller->read_numerical_key_value(test_file_path, key, &a);\n+  EXPECT_FALSE(is_ok) << \"Too long path should be an error\";\n+  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, read_numerical_key_file_not_exist) {\n+  TestController* unknown_path_ctrl = new TestController((char*)\"\/do\/not\/exist\");\n+  const char* test_file_path = \"\/file-not-found\";\n+  const char* key = \"something\";\n+  julong a = 0xBAD;\n+  bool is_ok = unknown_path_ctrl->read_numerical_key_value(test_file_path, key, &a);\n+  EXPECT_FALSE(is_ok) << \"File not found should be an error\";\n+  EXPECT_EQ((julong)0xBAD, a) << \"Expected untouched scan value\";\n+}\n+\n+TEST(cgroupTest, set_cgroupv1_subsystem_path) {\n+  TestCase host = {\n+    \"\/sys\/fs\/cgroup\/memory\",                                             \/\/ mount_path\n+    \"\/\",                                                                 \/\/ root_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\",                     \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/memory\/user.slice\/user-1000.slice\/user@1000.service\" \/\/ expected_path\n+  };\n+  TestCase container_engine = {\n+    \"\/sys\/fs\/cgroup\/mem\",                            \/\/ mount_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ root_path\n+    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/mem\"                             \/\/ expected_path\n+  };\n+  int length = 2;\n+  TestCase* testCases[] = { &host,\n+                            &container_engine };\n+  for (int i = 0; i < length; i++) {\n+    CgroupV1Controller* ctrl = new CgroupV1Controller( (char*)testCases[i]->root_path,\n+                                                       (char*)testCases[i]->mount_path);\n+    ctrl->set_subsystem_path((char*)testCases[i]->cgroup_path);\n+    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n+  }\n+}\n+\n+TEST(cgroupTest, set_cgroupv2_subsystem_path) {\n+  TestCase at_mount_root = {\n+    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n+    nullptr,                \/\/ root_path, ignored\n+    \"\/\",                    \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\"        \/\/ expected_path\n+  };\n+  TestCase sub_path = {\n+    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n+    nullptr,                \/\/ root_path, ignored\n+    \"\/foobar\",              \/\/ cgroup_path\n+    \"\/sys\/fs\/cgroup\/foobar\" \/\/ expected_path\n+  };\n+  int length = 2;\n+  TestCase* testCases[] = { &at_mount_root,\n+                            &sub_path };\n+  for (int i = 0; i < length; i++) {\n+    CgroupV2Controller* ctrl = new CgroupV2Controller( (char*)testCases[i]->mount_path,\n+                                                       (char*)testCases[i]->cgroup_path);\n+    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n+  }\n+}\n+\n+#endif \/\/ LINUX\n","filename":"test\/hotspot\/gtest\/runtime\/test_cgroupSubsystem_linux.cpp","additions":468,"deletions":0,"binary":false,"changes":468,"status":"added"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-\n-#ifdef LINUX\n-\n-#include \"cgroupV1Subsystem_linux.hpp\"\n-#include \"cgroupV2Subsystem_linux.hpp\"\n-#include \"unittest.hpp\"\n-\n-typedef struct {\n-  const char* mount_path;\n-  const char* root_path;\n-  const char* cgroup_path;\n-  const char* expected_path;\n-} TestCase;\n-\n-TEST(cgroupTest, set_cgroupv1_subsystem_path) {\n-  TestCase host = {\n-    \"\/sys\/fs\/cgroup\/memory\",                                             \/\/ mount_path\n-    \"\/\",                                                                 \/\/ root_path\n-    \"\/user.slice\/user-1000.slice\/user@1000.service\",                     \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\/memory\/user.slice\/user-1000.slice\/user@1000.service\" \/\/ expected_path\n-  };\n-  TestCase container_engine = {\n-    \"\/sys\/fs\/cgroup\/mem\",                            \/\/ mount_path\n-    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ root_path\n-    \"\/user.slice\/user-1000.slice\/user@1000.service\", \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\/mem\"                             \/\/ expected_path\n-  };\n-  int length = 2;\n-  TestCase* testCases[] = { &host,\n-                            &container_engine };\n-  for (int i = 0; i < length; i++) {\n-    CgroupV1Controller* ctrl = new CgroupV1Controller( (char*)testCases[i]->root_path,\n-                                                       (char*)testCases[i]->mount_path);\n-    ctrl->set_subsystem_path((char*)testCases[i]->cgroup_path);\n-    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n-  }\n-}\n-\n-TEST(cgroupTest, set_cgroupv2_subsystem_path) {\n-  TestCase at_mount_root = {\n-    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n-    nullptr,                \/\/ root_path, ignored\n-    \"\/\",                    \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\"        \/\/ expected_path\n-  };\n-  TestCase sub_path = {\n-    \"\/sys\/fs\/cgroup\",       \/\/ mount_path\n-    nullptr,                \/\/ root_path, ignored\n-    \"\/foobar\",              \/\/ cgroup_path\n-    \"\/sys\/fs\/cgroup\/foobar\" \/\/ expected_path\n-  };\n-  int length = 2;\n-  TestCase* testCases[] = { &at_mount_root,\n-                            &sub_path };\n-  for (int i = 0; i < length; i++) {\n-    CgroupV2Controller* ctrl = new CgroupV2Controller( (char*)testCases[i]->mount_path,\n-                                                       (char*)testCases[i]->cgroup_path);\n-    ASSERT_STREQ(testCases[i]->expected_path, ctrl->subsystem_path());\n-  }\n-}\n-\n-#endif\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux_cgroups.cpp","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -203,2 +203,2 @@\n-            .shouldMatch(\"Memory and Swap Limit is:.*(\" + expectedTraceValue + \"|-2|0)\")\n-            .shouldNotMatch(\"Memory and Swap Limit is:.*\" + neg2InUnsignedLong);\n+            .shouldMatch(\"(Memory and )?Swap Limit is:.*(\" + expectedTraceValue + \"|-2|0)\")\n+            .shouldNotMatch(\"(Memory and )?Swap Limit is:.*\" + neg2InUnsignedLong);\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMemoryAwareness.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}