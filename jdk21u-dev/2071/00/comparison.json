{"files":[{"patch":"@@ -34,1 +34,0 @@\n-import jdk.test.lib.cds.CDSTestUtils;\n@@ -36,0 +35,1 @@\n+import jdk.test.lib.util.FileUtils;\n@@ -62,1 +62,1 @@\n-        CDSTestUtils.clone(new File(JDK_HOME), new File(TEMP_JDK_HOME.toString()));\n+        FileUtils.copyDirectory(Path.of(JDK_HOME), TEMP_JDK_HOME);\n","filename":"test\/jdk\/javax\/crypto\/CryptoPermissions\/InconsistentEntries.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.nio.file.StandardCopyOption;\n@@ -51,0 +52,2 @@\n+import java.util.stream.Stream;\n+\n@@ -367,0 +370,24 @@\n+    \/**\n+     * Copies a directory and all entries in the directory to a destination path.\n+     * Makes the access permission of the destination entries writable.\n+     *\n+     * @param src the path of the source directory\n+     * @param dst the path of the destination directory\n+     * @throws IOException      if an I\/O error occurs while walking the file tree\n+     * @throws RuntimeException if an I\/O error occurs during the copy operation\n+     *                          or if the source or destination paths are invalid\n+     *\/\n+    public static void copyDirectory(Path src, Path dst) throws IOException {\n+        try (Stream<Path> stream = Files.walk(src)) {\n+            stream.forEach(sourcePath -> {\n+                try {\n+                    Path destPath = dst.resolve(src.relativize(sourcePath));\n+                    Files.copy(sourcePath, destPath, StandardCopyOption.REPLACE_EXISTING);\n+                    destPath.toFile().setWritable(true);\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+        }\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/util\/FileUtils.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"}]}