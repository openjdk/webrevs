{"files":[{"patch":"@@ -2883,6 +2883,7 @@\n-\/\/------------------------------ insert_cmpi_loop_exit -------------------------------------\n-\/\/ Clone a signed compare loop exit from an unsigned compare and\n-\/\/ insert it before the unsigned cmp on the stay-in-loop path.\n-\/\/ All new nodes inserted in the dominator tree between the original\n-\/\/ if and it's projections.  The original if test is replaced with\n-\/\/ a constant to force the stay-in-loop path.\n+\/\/ Idea\n+\/\/ ----\n+\/\/ Partial Peeling tries to rotate the loop in such a way that it can later be turned into a counted loop. Counted loops\n+\/\/ require a signed loop exit test. When calling this method, we've only found a suitable unsigned test to partial peel\n+\/\/ with. Therefore, we try to split off a signed loop exit test from the unsigned test such that it can be used as new\n+\/\/ loop exit while keeping the unsigned test unchanged and preserving the same behavior as if we've used the unsigned\n+\/\/ test alone instead:\n@@ -2890,4 +2891,8 @@\n-\/\/ This is done to make sure that the original if and it's projections\n-\/\/ still dominate the same set of control nodes, that the ctrl() relation\n-\/\/ from data nodes to them is preserved, and that their loop nesting is\n-\/\/ preserved.\n+\/\/ Before Partial Peeling:\n+\/\/   Loop:\n+\/\/     <peeled section>\n+\/\/     Split off signed loop exit test\n+\/\/     <-- CUT HERE -->\n+\/\/     Unchanged unsigned loop exit test\n+\/\/     <rest of unpeeled section>\n+\/\/     goto Loop\n@@ -2895,2 +2900,14 @@\n-\/\/ before\n-\/\/          if(i <u limit)    unsigned compare loop exit\n+\/\/ After Partial Peeling:\n+\/\/   <cloned peeled section>\n+\/\/   Cloned split off signed loop exit test\n+\/\/   Loop:\n+\/\/     Unchanged unsigned loop exit test\n+\/\/     <rest of unpeeled section>\n+\/\/     <peeled section>\n+\/\/     Split off signed loop exit test\n+\/\/     goto Loop\n+\/\/\n+\/\/ Details\n+\/\/ -------\n+\/\/ Before:\n+\/\/          if (i <u limit)    Unsigned loop exit condition\n@@ -2901,5 +2918,6 @@\n-\/\/ after\n-\/\/          if(stay-in-loop-const)  original if\n-\/\/         \/       |\n-\/\/        \/        v\n-\/\/       \/  if(i <  limit)    new signed test\n+\/\/ Split off a signed loop exit test (i.e. with CmpI) from an unsigned loop exit test (i.e. with CmpU) and insert it\n+\/\/ before the CmpU on the stay-in-loop path and keep both tests:\n+\/\/\n+\/\/          if (i <u limit)    Signed loop exit test\n+\/\/        \/        |\n+\/\/       \/  if (i <u limit)    Unsigned loop exit test\n@@ -2907,10 +2925,28 @@\n-\/\/     \/  \/        v\n-\/\/    \/  \/  if(i <u limit)    new cloned unsigned test\n-\/\/   \/  \/   \/      |\n-\/\/   v  v  v       |\n-\/\/    region       |\n-\/\/        |        |\n-\/\/      dum-if     |\n-\/\/     \/  |        |\n-\/\/ ether  |        |\n-\/\/        v        v\n+\/\/     v  v        v\n+\/\/  exit-region  stay-in-loop-proj\n+\/\/\n+\/\/ Implementation\n+\/\/ --------------\n+\/\/ We need to make sure that the new signed loop exit test is properly inserted into the graph such that the unsigned\n+\/\/ loop exit test still dominates the same set of control nodes, the ctrl() relation from data nodes to both loop\n+\/\/ exit tests is preserved, and their loop nesting is correct.\n+\/\/\n+\/\/ To achieve that, we clone the unsigned loop exit test completely (leave it unchanged), insert the signed loop exit\n+\/\/ test above it and kill the original unsigned loop exit test by setting it's condition to a constant\n+\/\/ (i.e. stay-in-loop-const in graph below) such that IGVN can fold it later:\n+\/\/\n+\/\/           if (stay-in-loop-const)  Killed original unsigned loop exit test\n+\/\/          \/       |\n+\/\/         \/        v\n+\/\/        \/  if (i <  limit)          Split off signed loop exit test\n+\/\/       \/  \/       |\n+\/\/      \/  \/        v\n+\/\/     \/  \/  if (i <u limit)          Cloned unsigned loop exit test\n+\/\/    \/  \/   \/      |\n+\/\/   v  v  v        |\n+\/\/  exit-region     |\n+\/\/        |         |\n+\/\/    dummy-if      |\n+\/\/     \/  |         |\n+\/\/ dead   |         |\n+\/\/        v         v\n@@ -2919,1 +2955,9 @@\n-IfNode* PhaseIdealLoop::insert_cmpi_loop_exit(IfNode* if_cmpu, IdealLoopTree *loop) {\n+\/\/ Note: The dummy-if is inserted to create a region to merge the loop exits between the original to be killed unsigned\n+\/\/       loop exit test and its exit projection while keeping the exit projection (also see insert_region_before_proj()).\n+\/\/\n+\/\/ Requirements\n+\/\/ ------------\n+\/\/ Note that we can only split off a signed loop exit test from the unsigned loop exit test when the behavior is exactly\n+\/\/ the same as before with only a single unsigned test. This is only possible if certain requirements are met.\n+\/\/ Otherwise, we need to bail out (see comments in the code below).\n+IfNode* PhaseIdealLoop::insert_cmpi_loop_exit(IfNode* if_cmpu, IdealLoopTree* loop) {\n@@ -2924,1 +2968,3 @@\n-  if (bol->_test._test != BoolTest::lt) return nullptr;\n+  if (bol->_test._test != BoolTest::lt) {\n+    return nullptr;\n+  }\n@@ -2926,1 +2972,2 @@\n-  if (cmpu->Opcode() != Op_CmpU) return nullptr;\n+  assert(cmpu->Opcode() == Op_CmpU, \"must be unsigned comparison\");\n+\n@@ -2928,1 +2975,3 @@\n-  if (stride == 0) return nullptr;\n+  if (stride == 0) {\n+    return nullptr;\n+  }\n@@ -2940,3 +2989,82 @@\n-  \/\/ The loop exit condition is !(i <u limit) ==> (i < 0 || i >= limit).\n-  \/\/ Split out the exit condition (i < 0) for stride < 0 or (i >= limit) for stride > 0.\n-  Node* limit = nullptr;\n+  \/\/ The unsigned loop exit condition is\n+  \/\/   !(i <u  limit)\n+  \/\/ =   i >=u limit\n+  \/\/\n+  \/\/ First, we note that for any x for which\n+  \/\/   0 <= x <= INT_MAX\n+  \/\/ we can convert x to an unsigned int and still get the same guarantee:\n+  \/\/   0 <=  (uint) x <=  INT_MAX = (uint) INT_MAX\n+  \/\/   0 <=u (uint) x <=u INT_MAX = (uint) INT_MAX   (LEMMA)\n+  \/\/\n+  \/\/ With that in mind, if\n+  \/\/   limit >= 0             (COND)\n+  \/\/ then the unsigned loop exit condition\n+  \/\/   i >=u limit            (ULE)\n+  \/\/ is equivalent to\n+  \/\/   i < 0 || i >= limit    (SLE-full)\n+  \/\/ because either i is negative and therefore always greater than MAX_INT when converting to unsigned\n+  \/\/   (uint) i >=u MAX_INT >= limit >= 0\n+  \/\/ or otherwise\n+  \/\/   i >= limit >= 0\n+  \/\/ holds due to (LEMMA).\n+  \/\/\n+  \/\/ For completeness, a counterexample with limit < 0:\n+  \/\/ Assume i = -3 and limit = -2:\n+  \/\/   i  < 0\n+  \/\/   -2 < 0\n+  \/\/ is true and thus also \"i < 0 || i >= limit\". But\n+  \/\/   i  >=u limit\n+  \/\/   -3 >=u -2\n+  \/\/ is false.\n+  Node* limit = cmpu->in(2);\n+  const TypeInt* type_limit = _igvn.type(limit)->is_int();\n+  if (type_limit->_lo < 0) {\n+    return nullptr;\n+  }\n+\n+  \/\/ We prove below that we can extract a single signed loop exit condition from (SLE-full), depending on the stride:\n+  \/\/   stride < 0:\n+  \/\/     i < 0        (SLE = SLE-negative)\n+  \/\/   stride > 0:\n+  \/\/     i >= limit   (SLE = SLE-positive)\n+  \/\/ such that we have the following graph before Partial Peeling with stride > 0 (similar for stride < 0):\n+  \/\/\n+  \/\/ Loop:\n+  \/\/   <peeled section>\n+  \/\/   i >= limit    (SLE-positive)\n+  \/\/   <-- CUT HERE -->\n+  \/\/   i >=u limit   (ULE)\n+  \/\/   <rest of unpeeled section>\n+  \/\/   goto Loop\n+  \/\/\n+  \/\/ We exit the loop if:\n+  \/\/   (SLE) is true OR (ULE) is true\n+  \/\/ However, if (SLE) is true then (ULE) also needs to be true to ensure the exact same behavior. Otherwise, we wrongly\n+  \/\/ exit a loop that should not have been exited if we did not apply Partial Peeling. More formally, we need to ensure:\n+  \/\/   (SLE) IMPLIES (ULE)\n+  \/\/ This indeed holds when (COND) is given:\n+  \/\/ - stride > 0:\n+  \/\/       i >=  limit             \/\/ (SLE = SLE-positive)\n+  \/\/       i >=  limit >= 0        \/\/ (COND)\n+  \/\/       i >=u limit >= 0        \/\/ (LEMMA)\n+  \/\/     which is the unsigned loop exit condition (ULE).\n+  \/\/ - stride < 0:\n+  \/\/       i        <  0           \/\/ (SLE = SLE-negative)\n+  \/\/       (uint) i >u MAX_INT     \/\/ (NEG) all negative values are greater than MAX_INT when converted to unsigned\n+  \/\/       MAX_INT >= limit >= 0   \/\/ (COND)\n+  \/\/       MAX_INT >=u limit >= 0  \/\/ (LEMMA)\n+  \/\/     and thus from (NEG) and (LEMMA):\n+  \/\/       i >=u limit\n+  \/\/     which is the unsigned loop exit condition (ULE).\n+  \/\/\n+  \/\/\n+  \/\/ After Partial Peeling, we have the following structure for stride > 0 (similar for stride < 0):\n+  \/\/   <cloned peeled section>\n+  \/\/   i >= limit (SLE-positive)\n+  \/\/   Loop:\n+  \/\/     i >=u limit (ULE)\n+  \/\/     <rest of unpeeled section>\n+  \/\/     <peeled section>\n+  \/\/     i >= limit (SLE-positive)\n+  \/\/     goto Loop\n+  Node* rhs_cmpi;\n@@ -2944,1 +3072,1 @@\n-    limit = cmpu->in(2);\n+    rhs_cmpi = limit; \/\/ For i >= limit\n@@ -2946,2 +3074,2 @@\n-    limit = _igvn.makecon(TypeInt::ZERO);\n-    set_ctrl(limit, C->root());\n+    rhs_cmpi = _igvn.makecon(TypeInt::ZERO); \/\/ For i < 0\n+    set_ctrl(rhs_cmpi, C->root());\n@@ -2955,1 +3083,1 @@\n-  ProjNode* cmpi_exit = insert_if_before_proj(cmpu->in(1), Signed, rel_i, limit, lp_continue);\n+  ProjNode* cmpi_exit = insert_if_before_proj(cmpu->in(1), Signed, rel_i, rhs_cmpi, lp_continue);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":166,"deletions":38,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -0,0 +1,327 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=Xbatch\n+ * @bug 8332920\n+ * @summary Tests partial peeling at unsigned tests with limit being negative in exit tests \"i >u limit\".\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ *                   -XX:CompileOnly=*TestPartialPeel*::original*,*TestPartialPeel*::test*\n+ *                   compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n+ *\/\n+\n+\/*\n+ * @test id=Xcomp-run-inline\n+ * @bug 8332920\n+ * @summary Tests partial peeling at unsigned tests with limit being negative in exit tests \"i >u limit\".\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *                   -XX:CompileOnly=*TestPartialPeel*::original*,*TestPartialPeel*::run*,*TestPartialPeel*::test*\n+ *                   -XX:CompileCommand=inline,*TestPartialPeelAtUnsignedTestsNegativeLimit::test*\n+ *                   -XX:CompileCommand=dontinline,*TestPartialPeelAtUnsignedTestsNegativeLimit::check\n+ *                   compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n+ *\/\n+\n+\/*\n+ * @test id=Xcomp-compile-test\n+ * @bug 8332920\n+ * @summary Tests partial peeling at unsigned tests with limit being negative in exit tests \"i >u limit\".\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=*TestPartialPeel*::original*,*TestPartialPeel*::test*\n+ *                   compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n+ *\/\n+\n+\/*\n+ * @test id=vanilla\n+ * @bug 8332920\n+ * @requires vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+ * @summary Tests partial peeling at unsigned tests with limit being negative in exit tests \"i >u limit\".\n+ *          Only run this test with C2 since it is time-consuming and only tests a C2 issue.\n+ * @run main compiler.loopopts.TestPartialPeelAtUnsignedTestsNegativeLimit\n+ *\/\n+\n+package compiler.loopopts;\n+\n+import java.util.Random;\n+\n+import static java.lang.Integer.*;\n+\n+public class TestPartialPeelAtUnsignedTestsNegativeLimit {\n+    static int iFld = 10000;\n+    static int iterations = 0;\n+    static int iFld2;\n+    static boolean flag;\n+    final static Random RANDOM = new Random();\n+\n+    public static void main(String[] args) {\n+        compareUnsigned(3, 3); \/\/ Load Integer class for -Xcomp\n+        for (int i = 0; i < 2; i++) {\n+            if (!originalTest()) {\n+                throw new RuntimeException(\"originalTest() failed\");\n+            }\n+        }\n+\n+        for (int i = 0; i < 2000; i++) {\n+            \/\/ For profiling\n+            iFld = -1;\n+            originalTestVariation1();\n+\n+            \/\/ Actual run\n+            iFld = MAX_VALUE - 100_000;\n+            if (!originalTestVariation1()) {\n+                throw new RuntimeException(\"originalTestVariation1() failed\");\n+            }\n+        }\n+\n+        for (int i = 0; i < 2000; ++i) {\n+            \/\/ For profiling\n+            iFld = MAX_VALUE;\n+            originalTestVariation2();\n+\n+            \/\/ Actual run\n+            iFld = MIN_VALUE + 100000;\n+            if (!originalTestVariation2()) {\n+                throw new RuntimeException(\"originalTestVariation2() failed\");\n+            }\n+        }\n+\n+        runWhileLTIncr();\n+        runWhileLTDecr();\n+    }\n+\n+    \/\/ Originally reported simplified regression test with 2 variations (see below).\n+    public static boolean originalTest() {\n+        for (int i = MAX_VALUE - 50_000; compareUnsigned(i, -1) < 0; i++) {\n+            if (compareUnsigned(MIN_VALUE, i) < 0) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public static boolean originalTestVariation1() {\n+        int a = 0;\n+        for (int i = iFld; compareUnsigned(i, -1) < 0; ++i) { \/\/ i <u -1\n+\n+            if (i >= Integer.MIN_VALUE + 1 && i <= 100) { \/\/ Transformed to unsigned test.\n+                return true;\n+            }\n+            a *= 23;\n+        }\n+        return false;\n+    }\n+\n+    public static boolean originalTestVariation2() {\n+        int a = 0;\n+        for (int i = iFld; compareUnsigned(i, -1000) < 0; i--) { \/\/ i <u -1\n+            if (compareUnsigned(MAX_VALUE - 20, i) > 0) {\n+                return true;\n+            }\n+            a = i;\n+        }\n+        System.out.println(a);\n+        return false;\n+    }\n+\n+\n+    public static void testWhileLTIncr(int init, int limit) {\n+        int i = init;\n+        while (true) {\n+            \/\/ <Peeled Section>\n+\n+            \/\/ Found as loop head in ciTypeFlow, but both paths inside loop -> head not cloned.\n+            \/\/ As a result, this head has the safepoint as backedge instead of the loop exit test\n+            \/\/ and we cannot create a counted loop (yet). We first need to partial peel.\n+            if (flag) {\n+            }\n+\n+            iFld2++;\n+\n+            \/\/ Loop exit test i >=u limit (i.e. \"while (i <u limit)\") to partial peel with.\n+            \/\/ insert_cmpi_loop_exit() changes this exit condition into a signed and an unsigned test:\n+            \/\/   i >= limit && i >=u limit\n+            \/\/ where the signed condition can be used as proper loop exit condition for a counted loop\n+            \/\/ (we cannot use an unsigned counted loop exit condition).\n+            \/\/\n+            \/\/ After Partial Peeling, we have:\n+            \/\/   if (i >= limit) goto Exit\n+            \/\/ Loop:\n+            \/\/   if (i >=u limit) goto Exit\n+            \/\/   ...\n+            \/\/   i++;\n+            \/\/   if (i >= limit) goto Exit\n+            \/\/   goto Loop\n+            \/\/ Exit:\n+            \/\/   ...\n+            \/\/\n+            \/\/ If init = MAX_VALUE and limit = MIN_VALUE:\n+            \/\/   i >= limit\n+            \/\/   MAX_VALUE >= MIN_VALUE\n+            \/\/ which is true where\n+            \/\/   i >=u limit\n+            \/\/   MAX_VALUE >=u MIN_VALUE\n+            \/\/   MAX_VALUE >=u (uint)(MAX_INT + 1)\n+            \/\/ is false and we wrongly never enter the loop even though we should have.\n+            \/\/ This results in a wrong execution.\n+            if (compareUnsigned(i, limit) >= 0) {\n+                return;\n+            }\n+            \/\/ <-- Partial Peeling CUT -->\n+            \/\/ Safepoint\n+            \/\/ <Unpeeled Section>\n+            iterations++;\n+            i++;\n+        }\n+    }\n+\n+    \/\/ Same as testWhileLTIncr() but with decrement instead.\n+    public static void testWhileLTDecr(int init, int limit) {\n+        int i = init;\n+        while (true) {\n+            if (flag) {\n+            }\n+\n+            \/\/ Loop exit test.\n+            if (compareUnsigned(i, limit) >= 0) { \/\/ While (i <u limit)\n+                return;\n+            }\n+\n+            iterations++;\n+            i--;\n+        }\n+    }\n+\n+    public static void runWhileLTIncr() {\n+        \/\/ Currently works:\n+        testWhileLTIncr(MAX_VALUE, -1);\n+        check(MIN_VALUE); \/\/ MAX_VALUE + 1 iterations\n+        testWhileLTIncr(-1, 1);\n+        check(0);\n+        testWhileLTIncr(0, 0);\n+        check(0);\n+        checkIncrWithRandom(0, 0); \/\/ Sanity check this method.\n+        flag = !flag; \/\/ Change profiling\n+        testWhileLTIncr(MAX_VALUE - 2000, MAX_VALUE);\n+        check(2000);\n+        testWhileLTIncr(MAX_VALUE - 1990, MAX_VALUE);\n+        check(1990);\n+        testWhileLTIncr(MAX_VALUE - 1, MAX_VALUE);\n+        check(1);\n+        testWhileLTIncr(MIN_VALUE, MIN_VALUE + 2000);\n+        check(2000);\n+        testWhileLTIncr(MIN_VALUE, MIN_VALUE + 1990);\n+        check(1990);\n+        testWhileLTIncr(MIN_VALUE, MIN_VALUE + 1);\n+        check(1);\n+\n+        flag = !flag;\n+        \/\/ Overflow currently does not work with negative limit and is fixed with patch:\n+        testWhileLTIncr(MAX_VALUE, MIN_VALUE);\n+        check(1);\n+        testWhileLTIncr(MAX_VALUE - 2000, MIN_VALUE);\n+        check(2001);\n+        testWhileLTIncr(MAX_VALUE, MIN_VALUE + 2000);\n+        check(2001);\n+        testWhileLTIncr(MAX_VALUE - 2000, MIN_VALUE + 2000);\n+        check(4001);\n+\n+        \/\/ Random values\n+        int init = RANDOM.nextInt(0, MAX_VALUE);\n+        int limit = RANDOM.nextInt(MIN_VALUE, 0);\n+        testWhileLTIncr(init, limit);\n+        checkIncrWithRandom(init, limit);\n+    }\n+\n+    public static void runWhileLTDecr() {\n+        \/\/ Currently works:\n+        testWhileLTDecr(1, -1);\n+        check(2);\n+        testWhileLTDecr(-1, 1);\n+        check(0);\n+        testWhileLTDecr(0, 0);\n+        check(0);\n+        checkDecrWithRandom(0, 0); \/\/ Sanity check this method.\n+        flag = !flag;\n+        testWhileLTDecr(MAX_VALUE, MIN_VALUE);\n+        check(MIN_VALUE); \/\/ MAX_VALUE + 1 iterations\n+        testWhileLTDecr(MAX_VALUE, -1);\n+        check(MIN_VALUE); \/\/ MAX_VALUE + 1 iterations\n+        testWhileLTDecr(MAX_VALUE, MIN_VALUE);\n+        check(MIN_VALUE); \/\/ MAX_VALUE + 1 iterations\n+        testWhileLTDecr(MIN_VALUE, 0);\n+        check(0);\n+        testWhileLTDecr(MIN_VALUE, 1);\n+        check(0);\n+        flag = !flag;\n+\n+        \/\/ Underflow currently does not work with negative limit and is fixed with patch:\n+        testWhileLTDecr(MIN_VALUE, -1);\n+        check(MIN_VALUE + 1); \/\/ MAX_VALUE + 2 iterations\n+        testWhileLTDecr(MIN_VALUE, -2000);\n+        check(MIN_VALUE + 1); \/\/ MAX_VALUE + 2 iterations\n+        testWhileLTDecr(MIN_VALUE, MIN_VALUE + 1);\n+        check(MIN_VALUE + 1); \/\/ MAX_VALUE + 2 iterations\n+        testWhileLTDecr(MIN_VALUE + 2000, -1);\n+        check(MIN_VALUE + 2001); \/\/ MAX_VALUE + 2002 iterations\n+        testWhileLTDecr(MIN_VALUE + 2000, -2000);\n+        check(MIN_VALUE + 2001); \/\/ MAX_VALUE + 2002 iterations\n+        testWhileLTDecr(MIN_VALUE + 2000, MIN_VALUE + 2001);\n+        check(MIN_VALUE + 2001); \/\/ MAX_VALUE + 2002 iterations\n+\n+        \/\/ Random values\n+        int r1 = RANDOM.nextInt(MIN_VALUE, 0);\n+        int r2 = RANDOM.nextInt(MIN_VALUE, 0);\n+        int init = Math.min(r1, r2);\n+        int limit = Math.max(r1, r2);\n+        testWhileLTDecr(init, limit);\n+        checkDecrWithRandom(init, limit);\n+    }\n+\n+    static void check(int expectedIterations) {\n+        if (expectedIterations != iterations) {\n+            throw new RuntimeException(\"Expected \" + expectedIterations + \" iterations but only got \" + iterations);\n+        }\n+        iterations = 0; \/\/ Reset\n+    }\n+\n+    static void checkIncrWithRandom(long init, long limit) {\n+        long expectedIterations = ((long)(MAX_VALUE) - init) + (limit - (long)MIN_VALUE) + 1;\n+        if ((int)expectedIterations != iterations) {\n+            String error = \"Expected %d iterations but only got %d, init: %d, limit: %d\"\n+                            .formatted(expectedIterations, iterations, init, limit);\n+            throw new RuntimeException(error);\n+        }\n+        iterations = 0; \/\/ Reset\n+    }\n+\n+    static void checkDecrWithRandom(long init, long limit) {\n+        long expectedIterations = init + MIN_VALUE + MAX_VALUE + 2;\n+        if (init == limit) {\n+            expectedIterations = 0;\n+        }\n+        if ((int)expectedIterations != iterations) {\n+            String error = \"Expected %d iterations but only got %d, init: %d, limit: %d\"\n+                    .formatted(expectedIterations, iterations, init, limit);\n+            throw new RuntimeException(error);\n+        }\n+        iterations = 0; \/\/ Reset\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestPartialPeelAtUnsignedTestsNegativeLimit.java","additions":327,"deletions":0,"binary":false,"changes":327,"status":"added"}]}