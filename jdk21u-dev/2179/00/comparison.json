{"files":[{"patch":"@@ -30,1 +30,2 @@\n-void* GuardedMemory::wrap_copy(const void* ptr, const size_t len, const void* tag) {\n+void* GuardedMemory::wrap_copy(const void* ptr, const size_t len,\n+                               const void* tag, const void* tag2) {\n@@ -34,1 +35,1 @@\n-    GuardedMemory guarded(outerp, len, tag);\n+    GuardedMemory guarded(outerp, len, tag, tag2);\n@@ -63,2 +64,2 @@\n-      \" tag=\" PTR_FORMAT \" user_size=\" SIZE_FORMAT \" user_data=\" PTR_FORMAT,\n-      p2i(this), p2i(_base_addr), p2i(get_tag()), get_user_size(), p2i(get_user_ptr()));\n+      \" tag=\" PTR_FORMAT \"tag2=\" PTR_FORMAT \" user_size=\" SIZE_FORMAT \" user_data=\" PTR_FORMAT,\n+      p2i(this), p2i(_base_addr), p2i(get_tag()), p2i(get_tag2()), get_user_size(), p2i(get_user_ptr()));\n","filename":"src\/hotspot\/share\/memory\/guardedMemory.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -46,0 +47,1 @@\n+ * |+sizeof(uintptr_t) | <tag2>               | Tag word       |\n@@ -52,1 +54,1 @@\n- *  - tag word is general purpose\n+ *  - tag word and tag2 word are general purpose\n@@ -114,0 +116,4 @@\n+      \/\/ We may not be able to dereference directly.\n+      if (!os::is_readable_range((const void*) _guard, (const void*) (_guard + GUARD_SIZE))) {\n+        return false;\n+      }\n@@ -140,0 +146,1 @@\n+    void* _tag2;\n@@ -147,0 +154,2 @@\n+    void set_tag2(const void* tag2) { _tag2 = (void*) tag2; }\n+    void* get_tag2() const { return _tag2; }\n@@ -165,0 +174,1 @@\n+   * @param tag2      optional second general purpose tag.\n@@ -166,2 +176,3 @@\n-  GuardedMemory(void* base_ptr, const size_t user_size, const void* tag = nullptr) {\n-    wrap_with_guards(base_ptr, user_size, tag);\n+  GuardedMemory(void* base_ptr, const size_t user_size,\n+                const void* tag = nullptr, const void* tag2 = nullptr) {\n+    wrap_with_guards(base_ptr, user_size, tag, tag2);\n@@ -192,0 +203,1 @@\n+   * @param tag2      optional second general purpose tag.\n@@ -195,1 +207,2 @@\n-  void* wrap_with_guards(void* base_ptr, size_t user_size, const void* tag = nullptr) {\n+  void* wrap_with_guards(void* base_ptr, size_t user_size,\n+                         const void* tag = nullptr, const void* tag2 = nullptr) {\n@@ -202,0 +215,1 @@\n+    set_tag2(tag2);\n@@ -233,0 +247,14 @@\n+  \/**\n+   * Set the second general purpose tag.\n+   *\n+   * @param tag general purpose tag.\n+   *\/\n+  void set_tag2(const void* tag) { get_head_guard()->set_tag2(tag); }\n+\n+  \/**\n+   * Return the second general purpose tag.\n+   *\n+   * @return the second general purpose tag, defaults to null.\n+   *\/\n+  void* get_tag2() const { return get_head_guard()->get_tag2(); }\n+\n@@ -305,0 +333,1 @@\n+   * @param tag2 optional general purpose tag (see GuardedMemory::get_tag2())\n@@ -308,1 +337,2 @@\n-  static void* wrap_copy(const void* p, const size_t len, const void* tag = nullptr);\n+  static void* wrap_copy(const void* p, const size_t len,\n+                         const void* tag = nullptr, const void* tag2 = nullptr);\n","filename":"src\/hotspot\/share\/memory\/guardedMemory.hpp","additions":36,"deletions":6,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -354,0 +354,9 @@\n+\/\/ Arbitrary (but well-known) tag for GetStringChars\n+const void* STRING_TAG = (void*)0x47114711;\n+\n+\/\/ Arbitrary (but well-known) tag for GetStringUTFChars\n+const void* STRING_UTF_TAG = (void*) 0x48124812;\n+\n+\/\/ Arbitrary (but well-known) tag for GetPrimitiveArrayCritical\n+const void* CRITICAL_TAG = (void*)0x49134913;\n+\n@@ -359,1 +368,1 @@\n-    void* orig_elements) {\n+                                       void* orig_elements, jboolean is_critical = JNI_FALSE) {\n@@ -365,1 +374,1 @@\n-    result = GuardedMemory::wrap_copy(orig_elements, len, orig_elements);\n+    result = GuardedMemory::wrap_copy(orig_elements, len, orig_elements, is_critical ? CRITICAL_TAG : nullptr);\n@@ -371,1 +380,1 @@\n-    void* obj, void* carray, size_t* rsz) {\n+                                 void* obj, void* carray, size_t* rsz, jboolean is_critical) {\n@@ -390,0 +399,23 @@\n+  if (orig_result == STRING_TAG || orig_result == STRING_UTF_TAG) {\n+    bool was_utf = orig_result == STRING_UTF_TAG;\n+    tty->print_cr(\"%s: called on something allocated by %s\",\n+                  fn_name, was_utf ? \"GetStringUTFChars\" : \"GetStringChars\");\n+    DEBUG_ONLY(guarded.print_on(tty);) \/\/ This may crash.\n+    NativeReportJNIFatalError(thr, err_msg(\"%s called on something allocated by %s\",\n+                                           fn_name, was_utf ? \"GetStringUTFChars\" : \"GetStringChars\"));\n+  }\n+\n+  if (is_critical && (guarded.get_tag2() != CRITICAL_TAG)) {\n+    tty->print_cr(\"%s: called on something not allocated by GetPrimitiveArrayCritical\", fn_name);\n+    DEBUG_ONLY(guarded.print_on(tty);) \/\/ This may crash.\n+    NativeReportJNIFatalError(thr, err_msg(\"%s called on something not allocated by GetPrimitiveArrayCritical\",\n+                                           fn_name));\n+  }\n+\n+  if (!is_critical && (guarded.get_tag2() == CRITICAL_TAG)) {\n+    tty->print_cr(\"%s: called on something allocated by GetPrimitiveArrayCritical\", fn_name);\n+    DEBUG_ONLY(guarded.print_on(tty);) \/\/ This may crash.\n+    NativeReportJNIFatalError(thr, err_msg(\"%s called on something allocated by GetPrimitiveArrayCritical\",\n+                                           fn_name));\n+  }\n+\n@@ -399,1 +431,1 @@\n-  void* orig_result = check_wrapped_array(thr, fn_name, obj, carray, &sz);\n+  void* orig_result = check_wrapped_array(thr, fn_name, obj, carray, &sz, is_critical);\n@@ -1434,3 +1466,0 @@\n-\/\/ Arbitrary (but well-known) tag\n-const void* STRING_TAG = (void*)0x47114711;\n-\n@@ -1518,3 +1547,0 @@\n-\/\/ Arbitrary (but well-known) tag - different than GetStringChars\n-const void* STRING_UTF_TAG = (void*) 0x48124812;\n-\n@@ -1842,1 +1868,1 @@\n-      result = check_jni_wrap_copy_array(thr, array, result);\n+      result = check_jni_wrap_copy_array(thr, array, result, JNI_TRUE);\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":37,"deletions":11,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-TEST(GuardedMemory, basic) {\n+TEST_VM(GuardedMemory, basic) {\n@@ -82,1 +82,1 @@\n-TEST(GuardedMemory, odd_sizes) {\n+TEST_VM(GuardedMemory, odd_sizes) {\n@@ -103,1 +103,1 @@\n-TEST(GuardedMemory, buffer_overrun_head) {\n+TEST_VM(GuardedMemory, buffer_overrun_head) {\n@@ -115,1 +115,1 @@\n-TEST(GuardedMemory, buffer_overrun_tail) {\n+TEST_VM(GuardedMemory, buffer_overrun_tail) {\n@@ -132,1 +132,1 @@\n-TEST(GuardedMemory, wrap) {\n+TEST_VM(GuardedMemory, wrap) {\n@@ -150,0 +150,7 @@\n+\n+\/\/ Test passing back a bogus GuardedMemory region\n+TEST_VM(GuardedMemory, unmapped) {\n+  char* unmapped_base = (char*) (GuardedMemoryTest::get_guard_header_size() + 0x1000 + 1); \/\/ Avoids assert in constructor\n+  GuardedMemory guarded(unmapped_base);\n+  EXPECT_FALSE(guarded.verify_guards()) << \"Guard was not broken as expected\";\n+}\n","filename":"test\/hotspot\/gtest\/memory\/test_guardedMemory.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"}]}