{"files":[{"patch":"@@ -2436,1 +2436,0 @@\n-            boolean sawExponent = false;\n@@ -2438,1 +2437,5 @@\n-            int exponent = 0; \/\/ Set to the exponent value, if any\n+            \/\/ Storing as long allows us to maintain accuracy of exponent\n+            \/\/ when the exponent value as well as the decimalAt nears\n+            \/\/ Integer.MAX\/MIN value. However, the final expressed value is an int\n+            long exponent = 0;\n+            boolean[] expStat = new boolean[STATUS_LENGTH];\n@@ -2508,2 +2511,2 @@\n-                } else if (checkExponent && !isExponent && text.regionMatches(position, exponentString, 0, exponentString.length())\n-                        && !sawExponent) {\n+                } else if (checkExponent && !isExponent\n+                        && text.regionMatches(position, exponentString, 0, exponentString.length())) {\n@@ -2512,1 +2515,0 @@\n-                    boolean[] stat = new boolean[STATUS_LENGTH];\n@@ -2515,6 +2517,13 @@\n-                    if (subparse(text, pos, \"\", symbols.getMinusSignText(), exponentDigits, true, stat) &&\n-                            exponentDigits.fitsIntoLong(stat[STATUS_POSITIVE], true)) {\n-                        position = pos.index; \/\/ Advance past the exponent\n-                        exponent = (int)exponentDigits.getLong();\n-                        if (!stat[STATUS_POSITIVE]) {\n-                            exponent = -exponent;\n+                    if (subparse(text, pos, \"\", symbols.getMinusSignText(), exponentDigits, true, expStat)) {\n+                        \/\/ We parse the exponent with isExponent == true, thus fitsIntoLong()\n+                        \/\/ only returns false here if the exponent DigitList value exceeds\n+                        \/\/ Long.MAX_VALUE. We do not need to worry about false being\n+                        \/\/ returned for faulty values as they are ignored by DigitList.\n+                        if (exponentDigits.fitsIntoLong(expStat[STATUS_POSITIVE], true)) {\n+                            exponent = exponentDigits.getLong();\n+                            if (!expStat[STATUS_POSITIVE]) {\n+                                exponent = -exponent;\n+                            }\n+                        } else {\n+                            exponent = expStat[STATUS_POSITIVE] ?\n+                                    Long.MAX_VALUE : Long.MIN_VALUE;\n@@ -2522,1 +2531,1 @@\n-                        sawExponent = true;\n+                        position = pos.index; \/\/ Advance past the exponent\n@@ -2540,1 +2549,3 @@\n-            digits.decimalAt += exponent;\n+            if (exponent != 0) {\n+                digits.decimalAt = shiftDecimalAt(digits.decimalAt, exponent);\n+            }\n@@ -2551,0 +2562,1 @@\n+    }\n@@ -2552,0 +2564,44 @@\n+    \/\/ Calculate the final decimal position based off the exponent value\n+    \/\/ and the existing decimalAt position. If overflow\/underflow, the value\n+    \/\/ should be set as either Integer.MAX\/MIN\n+    private int shiftDecimalAt(int decimalAt, long exponent) {\n+        try {\n+            exponent = Math.addExact(decimalAt, exponent);\n+        } catch (ArithmeticException ex) {\n+            \/\/ If we under\/overflow a Long do not bother with the decimalAt\n+            \/\/ As it can only shift up to Integer.MAX\/MIN which has no affect\n+            if (exponent > 0 && decimalAt > 0) {\n+                return Integer.MAX_VALUE;\n+            } else {\n+                return Integer.MIN_VALUE;\n+            }\n+        }\n+        try {\n+            decimalAt = Math.toIntExact(exponent);\n+        } catch (ArithmeticException ex) {\n+            decimalAt = exponent > 0 ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n+        }\n+        return decimalAt;\n+    }\n+\n+    \/\/ Checks to make sure grouping size is not violated. Used when strict.\n+    private boolean isGroupingViolation(int pos, int prevGroupingPos) {\n+        return isGroupingUsed() && \/\/ Only violates if using grouping\n+                \/\/ Checks if a previous grouping symbol was seen.\n+                prevGroupingPos != -groupingSize &&\n+                \/\/ The check itself, - 1 to account for grouping\/decimal symbol\n+                pos - 1 != prevGroupingPos + groupingSize;\n+    }\n+\n+    \/\/ Calculates the index that violated the grouping size\n+    \/\/ Violation can be over or under the grouping size\n+    \/\/ under - Current group has a grouping size of less than the expected\n+    \/\/ over - Current group has a grouping size of more than the expected\n+    private int groupingViolationIndex(int pos, int prevGroupingPos) {\n+        \/\/ Both examples assume grouping size of 3 and 0 indexed\n+        \/\/ under ex: \"1,23,4\". (4) OR \"1,,2\". (2) When under, violating char is grouping symbol\n+        \/\/ over ex: \"1,2345,6. (5) When over, violating char is the excess digit\n+        \/\/ This method is only evaluated when a grouping symbol is found, thus\n+        \/\/ we can take the minimum of either the current pos, or where we expect\n+        \/\/ the current group to have ended\n+        return Math.min(pos, prevGroupingPos + groupingSize + 1);\n@@ -2569,1 +2625,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":69,"deletions":14,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331485\n+ * @summary Ensure correctness when parsing large (+\/-) exponent values that\n+ *          exceed Integer.MAX_VALUE and Long.MAX_VALUE.\n+ * @run junit\/othervm --add-opens java.base\/java.text=ALL-UNNAMED LargeExponentsTest\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\/\/ We prevent odd results when parsing large exponent values by ensuring\n+\/\/ that we properly handle overflow in the implementation of DigitList\n+public class LargeExponentsTest {\n+\n+    \/\/ Exponent symbol is 'E'\n+    private static final NumberFormat FMT = NumberFormat.getInstance(Locale.US);\n+\n+    \/\/ Check that the parsed value and parse position index are both equal to the expected values.\n+    \/\/ We are mainly checking that an exponent > Integer.MAX_VALUE no longer\n+    \/\/ parses to 0 and that an exponent > Long.MAX_VALUE no longer parses to the mantissa.\n+    @ParameterizedTest\n+    @MethodSource({\"largeExponentValues\", \"smallExponentValues\", \"bugReportValues\", \"edgeCases\"})\n+    public void overflowTest(String parseString, Double expectedValue) throws ParseException {\n+        checkParse(parseString, expectedValue);\n+        checkParseWithPP(parseString, expectedValue);\n+    }\n+\n+    \/\/ A separate white-box test to avoid the memory consumption of testing cases\n+    \/\/ when the String is near Integer.MAX_LENGTH\n+    @ParameterizedTest\n+    @MethodSource\n+    public void largeDecimalAtExponentTest(int expected, int decimalAt, long expVal)\n+            throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n+        DecimalFormat df = new DecimalFormat();\n+        Method m = df.getClass().getDeclaredMethod(\n+                \"shiftDecimalAt\", int.class, long.class);\n+        m.setAccessible(true);\n+        assertEquals(expected, m.invoke(df, decimalAt, expVal));\n+    }\n+\n+    \/\/ Cases where we can test behavior when the String is near Integer.MAX_LENGTH\n+    private static Stream<Arguments> largeDecimalAtExponentTest() {\n+        return Stream.of(\n+                \/\/ Equivalent to testing Arguments.of(\"0.\"+\"0\".repeat(Integer.MAX_VALUE-20)+\"1\"+\"E2147483650\", 1.0E22)\n+                \/\/ This is an absurdly long decimal string with length close to Integer.MAX_VALUE\n+                \/\/ where the decimal position correctly negates the exponent value, even if it exceeds Integer.MAX_VALUE\n+                Arguments.of(23, -(Integer.MAX_VALUE-20), 3L+Integer.MAX_VALUE),\n+                Arguments.of(-23, Integer.MAX_VALUE-20, -(3L+Integer.MAX_VALUE)),\n+                Arguments.of(Integer.MIN_VALUE, -(Integer.MAX_VALUE-20), -(3L+Integer.MAX_VALUE)),\n+                Arguments.of(Integer.MAX_VALUE, Integer.MAX_VALUE-20, 3L+Integer.MAX_VALUE),\n+                Arguments.of(Integer.MAX_VALUE, -(Integer.MAX_VALUE-20), Long.MAX_VALUE),\n+                Arguments.of(Integer.MIN_VALUE, Integer.MAX_VALUE-20, Long.MIN_VALUE)\n+        );\n+    }\n+\n+    \/\/ Checks the parse(String, ParsePosition) method\n+    public void checkParse(String parseString, Double expectedValue) {\n+        ParsePosition pp = new ParsePosition(0);\n+        Number actualValue = FMT.parse(parseString, pp);\n+        assertEquals(expectedValue, (double)actualValue);\n+        assertEquals(parseString.length(), pp.getIndex());\n+    }\n+\n+    \/\/ Checks the parse(String) method\n+    public void checkParseWithPP(String parseString, Double expectedValue)\n+            throws ParseException {\n+        Number actualValue = FMT.parse(parseString);\n+        assertEquals(expectedValue, (double)actualValue);\n+    }\n+\n+    \/\/ Generate large enough exponents that should all be parsed as infinity\n+    \/\/ when positive. This includes exponents that exceed Long.MAX_VALUE\n+    private static List<Arguments> largeExponentValues() {\n+        return createExponentValues(false);\n+    }\n+\n+    \/\/ Same as previous provider but for negative exponent values, so expecting\n+    \/\/ a parsed value of 0.\n+    private static List<Arguments> smallExponentValues() {\n+        return createExponentValues(true);\n+    }\n+\n+    \/\/ Programmatically generate some large parse values that are expected\n+    \/\/ to be parsed as infinity or 0\n+    private static List<Arguments> createExponentValues(boolean negative) {\n+        List<Arguments> args = new ArrayList<>();\n+        \/\/ Start with a base value that should be parsed as infinity\n+        String baseValue = \"12234.123E1100\";\n+        \/\/ Continuously add to the String until we trigger the overflow condition\n+        for (int i = 0; i < 100; i++) {\n+            StringBuilder bldr = new StringBuilder();\n+            \/\/ Add to exponent\n+            bldr.append(baseValue).append(\"1\".repeat(i));\n+            \/\/ Add to mantissa\n+            bldr.insert(0, \"1\".repeat(i));\n+            args.add(Arguments.of(\n+                    \/\/ Prepend \"-\" to exponent if negative\n+                    negative ? bldr.insert(bldr.indexOf(\"E\")+1, \"-\").toString() : bldr.toString(),\n+                    \/\/ Expect 0 if negative, else infinity\n+                    negative ? 0.0 : Double.POSITIVE_INFINITY));\n+        }\n+        return args;\n+    }\n+\n+    \/\/ The provided values are all from the JBS issue\n+    \/\/ These contain exponents that exceed Integer.MAX_VALUE, but not Long.MAX_VALUE\n+    private static Stream<Arguments> bugReportValues() {\n+        return Stream.of(\n+                Arguments.of(\"0.123E1\", 1.23),\n+                Arguments.of(\"0.123E309\", 1.23E308),\n+                Arguments.of(\"0.123E310\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"0.123E2147483647\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"0.123E2147483648\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"0.0123E2147483648\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"0.0123E2147483649\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"1.23E2147483646\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"1.23E2147483647\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"0.123E4294967296\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"0.123E-322\", 9.9E-324),\n+                Arguments.of(\"0.123E-323\", 0.0),\n+                Arguments.of(\"0.123E-2147483647\", 0.0),\n+                Arguments.of(\"0.123E-2147483648\", 0.0),\n+                Arguments.of(\"0.123E-2147483649\", 0.0)\n+        );\n+    }\n+\n+    \/\/ Some other edge case values to ensure parse correctness\n+    private static Stream<Arguments> edgeCases() {\n+        return Stream.of(\n+                \/\/ Exponent itself does not cause underflow, but decimalAt adjustment\n+                \/\/ based off mantissa should. decimalAt(-1) + exponent(Integer.MIN_VALUE) = underflow\n+                Arguments.of(\"0.0123E-2147483648\", 0.0),\n+                \/\/ 0 exponent\n+                Arguments.of(\"1.23E0\", 1.23),\n+                \/\/ Leading zeroes\n+                Arguments.of(\"1.23E0000123\", 1.23E123),\n+                \/\/ Leading zeroes - Past Long.MAX_VALUE length\n+                Arguments.of(\"1.23E00000000000000000000000000000000000000000123\", 1.23E123),\n+                \/\/ Trailing zeroes\n+                Arguments.of(\"1.23E100\", 1.23E100),\n+                \/\/ Long.MAX_VALUE length\n+                Arguments.of(\"1.23E1234567891234567800\", Double.POSITIVE_INFINITY),\n+                \/\/ Long.MAX_VALUE with trailing zeroes\n+                Arguments.of(\"1.23E9223372036854775807000\", Double.POSITIVE_INFINITY),\n+                \/\/ Long.MIN_VALUE\n+                Arguments.of(\"1.23E-9223372036854775808\", 0.0),\n+                \/\/ Exponent value smaller than Long.MIN_VALUE\n+                Arguments.of(\"1.23E-9223372036854775809\", 0.0),\n+                \/\/ Exponent value equal to Long.MAX_VALUE\n+                Arguments.of(\"1.23E9223372036854775807\", Double.POSITIVE_INFINITY),\n+                \/\/ Exponent value larger than Long.MAX_VALUE\n+                Arguments.of(\"1.23E9223372036854775808\", Double.POSITIVE_INFINITY)\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/LargeExponentsTest.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -0,0 +1,430 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8327640 8331485\n+ * @summary Test suite for NumberFormat parsing when lenient.\n+ * @run junit\/othervm -Duser.language=en -Duser.country=US LenientParseTest\n+ * @run junit\/othervm -Duser.language=ja -Duser.country=JP LenientParseTest\n+ * @run junit\/othervm -Duser.language=zh -Duser.country=CN LenientParseTest\n+ * @run junit\/othervm -Duser.language=tr -Duser.country=TR LenientParseTest\n+ * @run junit\/othervm -Duser.language=de -Duser.country=DE LenientParseTest\n+ * @run junit\/othervm -Duser.language=fr -Duser.country=FR LenientParseTest\n+ * @run junit\/othervm -Duser.language=ar -Duser.country=AR LenientParseTest\n+ *\/\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.condition.EnabledIfSystemProperty;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.text.CompactNumberFormat;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+\/\/ Tests lenient parsing, this is done by testing the NumberFormat factory instances\n+\/\/ against a number of locales with different formatting conventions. The locales\n+\/\/ used all use a grouping size of 3. When lenient, parsing only fails\n+\/\/ if the prefix and\/or suffix are not found, or the first character after the\n+\/\/ prefix is un-parseable. The tested locales all use groupingSize of 3.\n+public class LenientParseTest {\n+\n+    \/\/ Used to retrieve the locale's expected symbols\n+    private static final DecimalFormatSymbols dfs =\n+            new DecimalFormatSymbols(Locale.getDefault());\n+    private static final DecimalFormat dFmt = (DecimalFormat)\n+            NumberFormat.getNumberInstance(Locale.getDefault());\n+    private static final DecimalFormat cFmt =\n+            (DecimalFormat) NumberFormat.getCurrencyInstance(Locale.getDefault());\n+    private static final DecimalFormat pFmt =\n+            (DecimalFormat) NumberFormat.getPercentInstance(Locale.getDefault());\n+    private static final CompactNumberFormat cmpctFmt =\n+            (CompactNumberFormat) NumberFormat.getCompactNumberInstance(Locale.getDefault(),\n+                    NumberFormat.Style.SHORT);\n+\n+    \/\/ All NumberFormats should parse leniently (which is the default)\n+    static {\n+        \/\/ To effectively test compactNumberFormat, these should be set accordingly\n+        cmpctFmt.setParseIntegerOnly(false);\n+        cmpctFmt.setGroupingUsed(true);\n+    }\n+\n+    \/\/ ---- NumberFormat tests ----\n+    \/\/ Test prefix\/suffix behavior with a predefined DecimalFormat\n+    \/\/ Non-localized, only run once\n+    @ParameterizedTest\n+    @MethodSource(\"badParseStrings\")\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void numFmtFailParseTest(String toParse, int expectedErrorIndex) {\n+        \/\/ Format with grouping size = 3, prefix = a, suffix = b\n+        DecimalFormat nonLocalizedDFmt = new DecimalFormat(\"a#,#00.00b\");\n+        failParse(nonLocalizedDFmt, toParse, expectedErrorIndex);\n+    }\n+\n+    \/\/ All input Strings should parse fully and return the expected value.\n+    \/\/ Expected index should be the length of the parse string, since it parses fully\n+    @ParameterizedTest\n+    @MethodSource(\"validFullParseStrings\")\n+    public void numFmtSuccessFullParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(dFmt, toParse, toParse.length()));\n+    }\n+\n+    \/\/ All input Strings should parse partially and return expected value\n+    \/\/ with the expected final index\n+    @ParameterizedTest\n+    @MethodSource(\"validPartialParseStrings\")\n+    public void numFmtSuccessPartialParseTest(String toParse, double expectedValue,\n+                                              int expectedIndex) {\n+        assertEquals(expectedValue, successParse(dFmt, toParse, expectedIndex));\n+    }\n+\n+    \/\/ Parse partially due to no grouping\n+    @ParameterizedTest\n+    @MethodSource(\"noGroupingParseStrings\")\n+    public void numFmtStrictGroupingNotUsed(String toParse, double expectedValue, int expectedIndex) {\n+        dFmt.setGroupingUsed(false);\n+        assertEquals(expectedValue, successParse(dFmt, toParse, expectedIndex));\n+        dFmt.setGroupingUsed(true);\n+    }\n+\n+    \/\/ Parse partially due to integer only\n+    @ParameterizedTest\n+    @MethodSource(\"integerOnlyParseStrings\")\n+    public void numFmtStrictIntegerOnlyUsed(String toParse, int expectedValue, int expectedIndex) {\n+        dFmt.setParseIntegerOnly(true);\n+        assertEquals(expectedValue, successParse(dFmt, toParse, expectedIndex));\n+        dFmt.setParseIntegerOnly(false);\n+    }\n+\n+    @Test \/\/ Non-localized, only run once\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void badExponentParseNumberFormatTest() {\n+        \/\/ Some fmt, with an \"E\" exponent string\n+        DecimalFormat fmt = (DecimalFormat) NumberFormat.getNumberInstance(Locale.US);\n+        \/\/ Upon non-numeric in exponent, parse will still successfully complete\n+        \/\/ but index should end on the last valid char in exponent\n+        assertEquals(1.23E45, successParse(fmt, \"1.23E45.123\", 7));\n+        assertEquals(1.23E45, successParse(fmt, \"1.23E45.\", 7));\n+        assertEquals(1.23E45, successParse(fmt, \"1.23E45FOO3222\", 7));\n+    }\n+\n+    \/\/ ---- CurrencyFormat tests ----\n+    \/\/ All input Strings should pass and return expected value.\n+    @ParameterizedTest\n+    @MethodSource(\"currencyValidFullParseStrings\")\n+    public void currFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(cFmt, toParse, toParse.length()));\n+    }\n+\n+    \/\/ Strings may parse partially or fail. This is because the mapped\n+    \/\/ data may cause the error to occur before the suffix can be found, (if the locale\n+    \/\/ uses a suffix).\n+    @ParameterizedTest\n+    @MethodSource(\"currencyValidPartialParseStrings\")\n+    public void currFmtParseTest(String toParse, double expectedValue,\n+                                 int expectedIndex) {\n+        if (cFmt.getPositiveSuffix().length() > 0) {\n+            \/\/ Since the error will occur before suffix is found, exception is thrown.\n+            failParse(cFmt, toParse, expectedIndex);\n+        } else {\n+            \/\/ Empty suffix, thus even if the error occurs, we have already found the\n+            \/\/ prefix, and simply parse partially\n+            assertEquals(expectedValue, successParse(cFmt, toParse, expectedIndex));\n+        }\n+    }\n+\n+    \/\/ ---- PercentFormat tests ----\n+    \/\/ All input Strings should pass and return expected value.\n+    @ParameterizedTest\n+    @MethodSource(\"percentValidFullParseStrings\")\n+    public void percentFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(pFmt, toParse, toParse.length()));\n+    }\n+\n+    \/\/ Strings may parse partially or fail. This is because the mapped\n+    \/\/ data may cause the error to occur before the suffix can be found, (if the locale\n+    \/\/ uses a suffix).\n+    @ParameterizedTest\n+    @MethodSource(\"percentValidPartialParseStrings\")\n+    public void percentFmtParseTest(String toParse, double expectedValue,\n+                                 int expectedIndex) {\n+        if (pFmt.getPositiveSuffix().length() > 0) {\n+            \/\/ Since the error will occur before suffix is found, exception is thrown.\n+            failParse(pFmt, toParse, expectedIndex);\n+        } else {\n+            \/\/ Empty suffix, thus even if the error occurs, we have already found the\n+            \/\/ prefix, and simply parse partially\n+            assertEquals(expectedValue, successParse(pFmt, toParse, expectedIndex));\n+        }\n+    }\n+\n+    \/\/ ---- CompactNumberFormat tests ----\n+    \/\/ Can match to both the decimalFormat patterns and the compact patterns\n+    \/\/ Unlike the other tests, this test is only ran against the US Locale and\n+    \/\/ tests against data built with the thousands format (K).\n+    @ParameterizedTest\n+    @MethodSource(\"compactValidPartialParseStrings\")\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtFailParseTest(String toParse, double expectedValue, int expectedErrorIndex) {\n+        assertEquals(expectedValue, successParse(cmpctFmt, toParse, expectedErrorIndex));\n+    }\n+\n+\n+    @ParameterizedTest\n+    @MethodSource(\"compactValidFullParseStrings\")\n+    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n+    public void compactFmtSuccessParseTest(String toParse, double expectedValue) {\n+        assertEquals(expectedValue, successParse(cmpctFmt, toParse, toParse.length()));\n+    }\n+\n+    \/\/ ---- Helper test methods ----\n+\n+    \/\/ Method is used when a String should parse successfully. This does not indicate\n+    \/\/ that the entire String was used, however. The index and errorIndex values\n+    \/\/ should be as expected.\n+    private double successParse(NumberFormat fmt, String toParse, int expectedIndex) {\n+        Number parsedValue = assertDoesNotThrow(() -> fmt.parse(toParse));\n+        ParsePosition pp = new ParsePosition(0);\n+        assertDoesNotThrow(() -> fmt.parse(toParse, pp));\n+        assertEquals(-1, pp.getErrorIndex(),\n+                \"ParsePosition ErrorIndex is not in correct location\");\n+        assertEquals(expectedIndex, pp.getIndex(),\n+                \"ParsePosition Index is not in correct location\");\n+        return parsedValue.doubleValue();\n+    }\n+\n+    \/\/ Method is used when a String should fail parsing. Indicated by either a thrown\n+    \/\/ ParseException, or null is returned depending on which parse method is invoked.\n+    \/\/ errorIndex should be as expected.\n+    private void failParse(NumberFormat fmt, String toParse, int expectedErrorIndex) {\n+        ParsePosition pp = new ParsePosition(0);\n+        assertThrows(ParseException.class, () -> fmt.parse(toParse));\n+        assertNull(fmt.parse(toParse, pp));\n+        assertEquals(expectedErrorIndex, pp.getErrorIndex());\n+    }\n+\n+    \/\/ ---- Data Providers ----\n+\n+    \/\/ Strings that should fail when parsed leniently.\n+    \/\/ Given as Arguments<String, expectedErrorIndex>\n+    \/\/ Non-localized data. For reference, the pattern of nonLocalizedDFmt is\n+    \/\/ \"a#,#00.00b\"\n+    private static Stream<Arguments> badParseStrings() {\n+        return Stream.of(\n+                \/\/ No prefix\n+                Arguments.of(\"1,1b\", 0),\n+                \/\/ No suffix\n+                Arguments.of(\"a1,11\", 5),\n+                \/\/ Digit does not follow the last grouping separator\n+                \/\/ Current behavior fails on the grouping separator\n+                Arguments.of(\"a1,11,z\", 5),\n+                \/\/ No suffix after grouping\n+                Arguments.of(\"a1,11,\", 5),\n+                \/\/ No prefix and suffix\n+                Arguments.of(\"1,11\", 0),\n+                \/\/ First character after prefix is un-parseable\n+                \/\/ Behavior is to expect error index at 0, not 1\n+                Arguments.of(\"ac1,11\", 0));\n+    }\n+\n+    \/\/ These data providers use US locale grouping and decimal separators\n+    \/\/ for readability, however, the data is tested against multiple locales\n+    \/\/ and is converted appropriately at runtime.\n+\n+    \/\/ Strings that should parse successfully, and consume the entire String\n+    \/\/ Form of Arguments(parseString, expectedParsedNumber)\n+    private static Stream<Arguments> validFullParseStrings() {\n+        return Stream.of(\n+                \/\/ Many subsequent grouping symbols\n+                Arguments.of(\"1,,,1\", 11d),\n+                Arguments.of(\"11,,,11,,,11\", 111111d),\n+                \/\/ Bad grouping size (with decimal)\n+                Arguments.of(\"1,1.\", 11d),\n+                Arguments.of(\"11,111,11.\", 1111111d),\n+                \/\/ Improper grouping size (with decimal and digits after)\n+                Arguments.of(\"1,1.1\", 11.1d),\n+                Arguments.of(\"1,11.1\", 111.1d),\n+                Arguments.of(\"1,1111.1\", 11111.1d),\n+                Arguments.of(\"11,111,11.1\", 1111111.1d),\n+                \/\/ Starts with grouping symbol\n+                Arguments.of(\",111,,1,1\", 11111d),\n+                Arguments.of(\",1\", 1d),\n+                Arguments.of(\",,1\", 1d),\n+                \/\/ Leading Zeros (not digits)\n+                Arguments.of(\"000,1,1\", 11d),\n+                Arguments.of(\"000,111,11,,1\", 111111d),\n+                Arguments.of(\"0,000,1,,1,1\", 111d),\n+                Arguments.of(\"1,234.00\", 1234d),\n+                Arguments.of(\"1,234.0\", 1234d),\n+                Arguments.of(\"1,234.\", 1234d),\n+                Arguments.of(\"1,234.00123\", 1234.00123d),\n+                Arguments.of(\"1,234.012\", 1234.012d),\n+                Arguments.of(\"1,234.224\", 1234.224d),\n+                Arguments.of(\"1\", 1d),\n+                Arguments.of(\"10\", 10d),\n+                Arguments.of(\"100\", 100d),\n+                Arguments.of(\"1000\", 1000d),\n+                Arguments.of(\"1,000\", 1000d),\n+                Arguments.of(\"10,000\", 10000d),\n+                Arguments.of(\"10000\", 10000d),\n+                Arguments.of(\"100,000\", 100000d),\n+                Arguments.of(\"1,000,000\", 1000000d),\n+                Arguments.of(\"10,000,000\", 10000000d))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1]));\n+    }\n+\n+    \/\/ Strings that should parse successfully, but do not use the entire String\n+    \/\/ Form of Arguments(parseString, expectedParsedNumber, expectedIndex)\n+    private static Stream<Arguments> validPartialParseStrings() {\n+        return Stream.of(\n+                \/\/ End with grouping symbol\n+                Arguments.of(\"11,\", 11d, 2),\n+                Arguments.of(\"11,,\", 11d, 3),\n+                Arguments.of(\"11,,,\", 11d, 4),\n+                \/\/ Random chars that aren't the expected symbols\n+                Arguments.of(\"1,1P111\", 11d, 3),\n+                Arguments.of(\"1.1P111\", 1.1d, 3),\n+                Arguments.of(\"1P,1111\", 1d, 1),\n+                Arguments.of(\"1P.1111\", 1d, 1),\n+                Arguments.of(\"1,1111P\", 11111d, 6),\n+                \/\/ Grouping occurs after decimal separator)\n+                Arguments.of(\"1.11,11\", 1.11d, 4),\n+                Arguments.of(\"1.,11,11\", 1d, 2))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1], args.get()[2]));\n+    }\n+\n+    \/\/ Test data input for when parse integer only is true\n+    \/\/ Form of Arguments(parseString, expectedParsedNumber, expectedIndex)\n+    private static Stream<Arguments> integerOnlyParseStrings() {\n+        return Stream.of(\n+                Arguments.of(\"1234.1234\", 1234, 4),\n+                Arguments.of(\"1234.12\", 1234, 4),\n+                Arguments.of(\"1234.1a\", 1234, 4),\n+                Arguments.of(\"1234.\", 1234, 4))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1], args.get()[2]));\n+    }\n+\n+    \/\/ Test data input for when no grouping is true\n+    \/\/ Form of Arguments(parseString, expectedParsedNumber, expectedIndex)\n+    private static Stream<Arguments> noGroupingParseStrings() {\n+        return Stream.of(\n+                Arguments.of(\"12,34\", 12d, 2),\n+                Arguments.of(\"1234,\", 1234d, 4),\n+                Arguments.of(\"123,456.789\", 123d, 3))\n+                .map(args -> Arguments.of(\n+                        localizeText(String.valueOf(args.get()[0])), args.get()[1], args.get()[2]));\n+    }\n+\n+    \/\/ Mappers for respective data providers to adjust values accordingly\n+    \/\/ Localized percent prefix\/suffix is added, with appropriate expected values\n+    \/\/ adjusted. Expected parsed number should be divided by 100.\n+    private static Stream<Arguments> percentValidPartialParseStrings() {\n+        return validPartialParseStrings().map(args ->\n+                Arguments.of(pFmt.getPositivePrefix() + args.get()[0] + pFmt.getPositiveSuffix(),\n+                        (double) args.get()[1] \/ 100, (int) args.get()[2] + pFmt.getPositivePrefix().length())\n+        );\n+    }\n+\n+    private static Stream<Arguments> percentValidFullParseStrings() {\n+        return validFullParseStrings().map(args -> Arguments.of(\n+                pFmt.getPositivePrefix() + args.get()[0] + pFmt.getPositiveSuffix(),\n+                (double) args.get()[1] \/ 100)\n+        );\n+    }\n+\n+    \/\/ Mappers for respective data providers to adjust values accordingly\n+    \/\/ Localized percent prefix\/suffix is added, with appropriate expected values\n+    \/\/ adjusted. Separators replaced for monetary versions.\n+    private static Stream<Arguments> currencyValidPartialParseStrings() {\n+        return validPartialParseStrings().map(args -> Arguments.of(\n+                cFmt.getPositivePrefix() + String.valueOf(args.get()[0])\n+                        .replace(dfs.getGroupingSeparator(), dfs.getMonetaryGroupingSeparator())\n+                        .replace(dfs.getDecimalSeparator(), dfs.getMonetaryDecimalSeparator())\n+                        + cFmt.getPositiveSuffix(),\n+                args.get()[1], (int) args.get()[2] + cFmt.getPositivePrefix().length())\n+        );\n+    }\n+\n+    private static Stream<Arguments> currencyValidFullParseStrings() {\n+        return validFullParseStrings().map(args -> Arguments.of(\n+                cFmt.getPositivePrefix() + String.valueOf(args.get()[0])\n+                        .replace(dfs.getGroupingSeparator(), dfs.getMonetaryGroupingSeparator())\n+                        .replace(dfs.getDecimalSeparator(), dfs.getMonetaryDecimalSeparator())\n+                        + cFmt.getPositiveSuffix(),\n+                args.get()[1])\n+        );\n+    }\n+\n+    \/\/ Compact Pattern Data Provider provides test input for both DecimalFormat patterns\n+    \/\/ and the compact patterns. As there is no method to retrieve compact patterns,\n+    \/\/ thus test only against US English locale, and use a hard coded K - 1000\n+    private static Stream<Arguments> compactValidPartialParseStrings() {\n+        return Stream.concat(validPartialParseStrings().map(args -> Arguments.of(args.get()[0],\n+                args.get()[1], args.get()[2])), validPartialParseStrings().map(args -> Arguments.of(args.get()[0] + \"K\",\n+                args.get()[1], args.get()[2]))\n+        );\n+    }\n+\n+    private static Stream<Arguments> compactValidFullParseStrings() {\n+        return Stream.concat(validFullParseStrings().map(args -> Arguments.of(args.get()[0],\n+                args.get()[1])), validFullParseStrings().map(args -> Arguments.of(args.get()[0] + \"K\",\n+                (double)args.get()[1] * 1000.0))\n+        );\n+    }\n+\n+    \/\/ Replace the grouping and decimal separators with localized variants\n+    \/\/ Used during localization of data\n+    private static String localizeText(String text) {\n+        \/\/ As this is a single pass conversion, this is safe for multiple replacement,\n+        \/\/ even if a ',' could be a decimal separator for a locale.\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < text.length(); i++) {\n+            char c = text.charAt(i);\n+            if (c == ',') {\n+                sb.append(dfs.getGroupingSeparator());\n+            } else if (c == '.') {\n+                sb.append(dfs.getDecimalSeparator());\n+            } else if (c == '0') {\n+                sb.append(dfs.getZeroDigit());\n+            } else {\n+                sb.append(c);\n+            }\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/LenientParseTest.java","additions":430,"deletions":0,"binary":false,"changes":430,"status":"added"}]}