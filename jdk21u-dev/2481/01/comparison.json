{"files":[{"patch":"@@ -2436,1 +2436,0 @@\n-            boolean sawExponent = false;\n@@ -2438,1 +2437,5 @@\n-            int exponent = 0; \/\/ Set to the exponent value, if any\n+            \/\/ Storing as long allows us to maintain accuracy of exponent\n+            \/\/ when the exponent value as well as the decimalAt nears\n+            \/\/ Integer.MAX\/MIN value. However, the final expressed value is an int\n+            long exponent = 0;\n+            boolean[] expStat = new boolean[STATUS_LENGTH];\n@@ -2508,2 +2511,2 @@\n-                } else if (checkExponent && !isExponent && text.regionMatches(position, exponentString, 0, exponentString.length())\n-                        && !sawExponent) {\n+                } else if (checkExponent && !isExponent\n+                        && text.regionMatches(position, exponentString, 0, exponentString.length())) {\n@@ -2512,1 +2515,0 @@\n-                    boolean[] stat = new boolean[STATUS_LENGTH];\n@@ -2515,6 +2517,13 @@\n-                    if (subparse(text, pos, \"\", symbols.getMinusSignText(), exponentDigits, true, stat) &&\n-                            exponentDigits.fitsIntoLong(stat[STATUS_POSITIVE], true)) {\n-                        position = pos.index; \/\/ Advance past the exponent\n-                        exponent = (int)exponentDigits.getLong();\n-                        if (!stat[STATUS_POSITIVE]) {\n-                            exponent = -exponent;\n+                    if (subparse(text, pos, \"\", symbols.getMinusSignText(), exponentDigits, true, expStat)) {\n+                        \/\/ We parse the exponent with isExponent == true, thus fitsIntoLong()\n+                        \/\/ only returns false here if the exponent DigitList value exceeds\n+                        \/\/ Long.MAX_VALUE. We do not need to worry about false being\n+                        \/\/ returned for faulty values as they are ignored by DigitList.\n+                        if (exponentDigits.fitsIntoLong(expStat[STATUS_POSITIVE], true)) {\n+                            exponent = exponentDigits.getLong();\n+                            if (!expStat[STATUS_POSITIVE]) {\n+                                exponent = -exponent;\n+                            }\n+                        } else {\n+                            exponent = expStat[STATUS_POSITIVE] ?\n+                                    Long.MAX_VALUE : Long.MIN_VALUE;\n@@ -2522,1 +2531,1 @@\n-                        sawExponent = true;\n+                        position = pos.index; \/\/ Advance past the exponent\n@@ -2540,1 +2549,3 @@\n-            digits.decimalAt += exponent;\n+            if (exponent != 0) {\n+                digits.decimalAt = shiftDecimalAt(digits.decimalAt, exponent);\n+            }\n@@ -2551,0 +2562,1 @@\n+    }\n@@ -2552,0 +2564,44 @@\n+    \/\/ Calculate the final decimal position based off the exponent value\n+    \/\/ and the existing decimalAt position. If overflow\/underflow, the value\n+    \/\/ should be set as either Integer.MAX\/MIN\n+    private int shiftDecimalAt(int decimalAt, long exponent) {\n+        try {\n+            exponent = Math.addExact(decimalAt, exponent);\n+        } catch (ArithmeticException ex) {\n+            \/\/ If we under\/overflow a Long do not bother with the decimalAt\n+            \/\/ As it can only shift up to Integer.MAX\/MIN which has no affect\n+            if (exponent > 0 && decimalAt > 0) {\n+                return Integer.MAX_VALUE;\n+            } else {\n+                return Integer.MIN_VALUE;\n+            }\n+        }\n+        try {\n+            decimalAt = Math.toIntExact(exponent);\n+        } catch (ArithmeticException ex) {\n+            decimalAt = exponent > 0 ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n+        }\n+        return decimalAt;\n+    }\n+\n+    \/\/ Checks to make sure grouping size is not violated. Used when strict.\n+    private boolean isGroupingViolation(int pos, int prevGroupingPos) {\n+        return isGroupingUsed() && \/\/ Only violates if using grouping\n+                \/\/ Checks if a previous grouping symbol was seen.\n+                prevGroupingPos != -groupingSize &&\n+                \/\/ The check itself, - 1 to account for grouping\/decimal symbol\n+                pos - 1 != prevGroupingPos + groupingSize;\n+    }\n+\n+    \/\/ Calculates the index that violated the grouping size\n+    \/\/ Violation can be over or under the grouping size\n+    \/\/ under - Current group has a grouping size of less than the expected\n+    \/\/ over - Current group has a grouping size of more than the expected\n+    private int groupingViolationIndex(int pos, int prevGroupingPos) {\n+        \/\/ Both examples assume grouping size of 3 and 0 indexed\n+        \/\/ under ex: \"1,23,4\". (4) OR \"1,,2\". (2) When under, violating char is grouping symbol\n+        \/\/ over ex: \"1,2345,6. (5) When over, violating char is the excess digit\n+        \/\/ This method is only evaluated when a grouping symbol is found, thus\n+        \/\/ we can take the minimum of either the current pos, or where we expect\n+        \/\/ the current group to have ended\n+        return Math.min(pos, prevGroupingPos + groupingSize + 1);\n@@ -2569,1 +2625,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":69,"deletions":14,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8331485\n+ * @summary Ensure correctness when parsing large (+\/-) exponent values that\n+ *          exceed Integer.MAX_VALUE and Long.MAX_VALUE.\n+ * @run junit\/othervm --add-opens java.base\/java.text=ALL-UNNAMED LargeExponentsTest\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.text.DecimalFormat;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\/\/ We prevent odd results when parsing large exponent values by ensuring\n+\/\/ that we properly handle overflow in the implementation of DigitList\n+public class LargeExponentsTest {\n+\n+    \/\/ Exponent symbol is 'E'\n+    private static final NumberFormat FMT = NumberFormat.getInstance(Locale.US);\n+\n+    \/\/ Check that the parsed value and parse position index are both equal to the expected values.\n+    \/\/ We are mainly checking that an exponent > Integer.MAX_VALUE no longer\n+    \/\/ parses to 0 and that an exponent > Long.MAX_VALUE no longer parses to the mantissa.\n+    @ParameterizedTest\n+    @MethodSource({\"largeExponentValues\", \"smallExponentValues\", \"bugReportValues\", \"edgeCases\"})\n+    public void overflowTest(String parseString, Double expectedValue) throws ParseException {\n+        checkParse(parseString, expectedValue);\n+        checkParseWithPP(parseString, expectedValue);\n+    }\n+\n+    \/\/ A separate white-box test to avoid the memory consumption of testing cases\n+    \/\/ when the String is near Integer.MAX_LENGTH\n+    @ParameterizedTest\n+    @MethodSource\n+    public void largeDecimalAtExponentTest(int expected, int decimalAt, long expVal)\n+            throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n+        DecimalFormat df = new DecimalFormat();\n+        Method m = df.getClass().getDeclaredMethod(\n+                \"shiftDecimalAt\", int.class, long.class);\n+        m.setAccessible(true);\n+        assertEquals(expected, m.invoke(df, decimalAt, expVal));\n+    }\n+\n+    \/\/ Cases where we can test behavior when the String is near Integer.MAX_LENGTH\n+    private static Stream<Arguments> largeDecimalAtExponentTest() {\n+        return Stream.of(\n+                \/\/ Equivalent to testing Arguments.of(\"0.\"+\"0\".repeat(Integer.MAX_VALUE-20)+\"1\"+\"E2147483650\", 1.0E22)\n+                \/\/ This is an absurdly long decimal string with length close to Integer.MAX_VALUE\n+                \/\/ where the decimal position correctly negates the exponent value, even if it exceeds Integer.MAX_VALUE\n+                Arguments.of(23, -(Integer.MAX_VALUE-20), 3L+Integer.MAX_VALUE),\n+                Arguments.of(-23, Integer.MAX_VALUE-20, -(3L+Integer.MAX_VALUE)),\n+                Arguments.of(Integer.MIN_VALUE, -(Integer.MAX_VALUE-20), -(3L+Integer.MAX_VALUE)),\n+                Arguments.of(Integer.MAX_VALUE, Integer.MAX_VALUE-20, 3L+Integer.MAX_VALUE),\n+                Arguments.of(Integer.MAX_VALUE, -(Integer.MAX_VALUE-20), Long.MAX_VALUE),\n+                Arguments.of(Integer.MIN_VALUE, Integer.MAX_VALUE-20, Long.MIN_VALUE)\n+        );\n+    }\n+\n+    \/\/ Checks the parse(String, ParsePosition) method\n+    public void checkParse(String parseString, Double expectedValue) {\n+        ParsePosition pp = new ParsePosition(0);\n+        Number actualValue = FMT.parse(parseString, pp);\n+        assertEquals(expectedValue, (double)actualValue);\n+        assertEquals(parseString.length(), pp.getIndex());\n+    }\n+\n+    \/\/ Checks the parse(String) method\n+    public void checkParseWithPP(String parseString, Double expectedValue)\n+            throws ParseException {\n+        Number actualValue = FMT.parse(parseString);\n+        assertEquals(expectedValue, (double)actualValue);\n+    }\n+\n+    \/\/ Generate large enough exponents that should all be parsed as infinity\n+    \/\/ when positive. This includes exponents that exceed Long.MAX_VALUE\n+    private static List<Arguments> largeExponentValues() {\n+        return createExponentValues(false);\n+    }\n+\n+    \/\/ Same as previous provider but for negative exponent values, so expecting\n+    \/\/ a parsed value of 0.\n+    private static List<Arguments> smallExponentValues() {\n+        return createExponentValues(true);\n+    }\n+\n+    \/\/ Programmatically generate some large parse values that are expected\n+    \/\/ to be parsed as infinity or 0\n+    private static List<Arguments> createExponentValues(boolean negative) {\n+        List<Arguments> args = new ArrayList<>();\n+        \/\/ Start with a base value that should be parsed as infinity\n+        String baseValue = \"12234.123E1100\";\n+        \/\/ Continuously add to the String until we trigger the overflow condition\n+        for (int i = 0; i < 100; i++) {\n+            StringBuilder bldr = new StringBuilder();\n+            \/\/ Add to exponent\n+            bldr.append(baseValue).append(\"1\".repeat(i));\n+            \/\/ Add to mantissa\n+            bldr.insert(0, \"1\".repeat(i));\n+            args.add(Arguments.of(\n+                    \/\/ Prepend \"-\" to exponent if negative\n+                    negative ? bldr.insert(bldr.indexOf(\"E\")+1, \"-\").toString() : bldr.toString(),\n+                    \/\/ Expect 0 if negative, else infinity\n+                    negative ? 0.0 : Double.POSITIVE_INFINITY));\n+        }\n+        return args;\n+    }\n+\n+    \/\/ The provided values are all from the JBS issue\n+    \/\/ These contain exponents that exceed Integer.MAX_VALUE, but not Long.MAX_VALUE\n+    private static Stream<Arguments> bugReportValues() {\n+        return Stream.of(\n+                Arguments.of(\"0.123E1\", 1.23),\n+                Arguments.of(\"0.123E309\", 1.23E308),\n+                Arguments.of(\"0.123E310\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"0.123E2147483647\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"0.123E2147483648\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"0.0123E2147483648\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"0.0123E2147483649\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"1.23E2147483646\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"1.23E2147483647\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"0.123E4294967296\", Double.POSITIVE_INFINITY),\n+                Arguments.of(\"0.123E-322\", 9.9E-324),\n+                Arguments.of(\"0.123E-323\", 0.0),\n+                Arguments.of(\"0.123E-2147483647\", 0.0),\n+                Arguments.of(\"0.123E-2147483648\", 0.0),\n+                Arguments.of(\"0.123E-2147483649\", 0.0)\n+        );\n+    }\n+\n+    \/\/ Some other edge case values to ensure parse correctness\n+    private static Stream<Arguments> edgeCases() {\n+        return Stream.of(\n+                \/\/ Exponent itself does not cause underflow, but decimalAt adjustment\n+                \/\/ based off mantissa should. decimalAt(-1) + exponent(Integer.MIN_VALUE) = underflow\n+                Arguments.of(\"0.0123E-2147483648\", 0.0),\n+                \/\/ 0 exponent\n+                Arguments.of(\"1.23E0\", 1.23),\n+                \/\/ Leading zeroes\n+                Arguments.of(\"1.23E0000123\", 1.23E123),\n+                \/\/ Leading zeroes - Past Long.MAX_VALUE length\n+                Arguments.of(\"1.23E00000000000000000000000000000000000000000123\", 1.23E123),\n+                \/\/ Trailing zeroes\n+                Arguments.of(\"1.23E100\", 1.23E100),\n+                \/\/ Long.MAX_VALUE length\n+                Arguments.of(\"1.23E1234567891234567800\", Double.POSITIVE_INFINITY),\n+                \/\/ Long.MAX_VALUE with trailing zeroes\n+                Arguments.of(\"1.23E9223372036854775807000\", Double.POSITIVE_INFINITY),\n+                \/\/ Long.MIN_VALUE\n+                Arguments.of(\"1.23E-9223372036854775808\", 0.0),\n+                \/\/ Exponent value smaller than Long.MIN_VALUE\n+                Arguments.of(\"1.23E-9223372036854775809\", 0.0),\n+                \/\/ Exponent value equal to Long.MAX_VALUE\n+                Arguments.of(\"1.23E9223372036854775807\", Double.POSITIVE_INFINITY),\n+                \/\/ Exponent value larger than Long.MAX_VALUE\n+                Arguments.of(\"1.23E9223372036854775808\", Double.POSITIVE_INFINITY)\n+        );\n+    }\n+}\n","filename":"test\/jdk\/java\/text\/Format\/DecimalFormat\/LargeExponentsTest.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"}]}