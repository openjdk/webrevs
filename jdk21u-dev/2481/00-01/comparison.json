{"files":[{"patch":"@@ -1,430 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8327640 8331485\n- * @summary Test suite for NumberFormat parsing when lenient.\n- * @run junit\/othervm -Duser.language=en -Duser.country=US LenientParseTest\n- * @run junit\/othervm -Duser.language=ja -Duser.country=JP LenientParseTest\n- * @run junit\/othervm -Duser.language=zh -Duser.country=CN LenientParseTest\n- * @run junit\/othervm -Duser.language=tr -Duser.country=TR LenientParseTest\n- * @run junit\/othervm -Duser.language=de -Duser.country=DE LenientParseTest\n- * @run junit\/othervm -Duser.language=fr -Duser.country=FR LenientParseTest\n- * @run junit\/othervm -Duser.language=ar -Duser.country=AR LenientParseTest\n- *\/\n-\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.condition.EnabledIfSystemProperty;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-\n-import java.text.CompactNumberFormat;\n-import java.text.DecimalFormat;\n-import java.text.DecimalFormatSymbols;\n-import java.text.NumberFormat;\n-import java.text.ParseException;\n-import java.text.ParsePosition;\n-import java.util.Locale;\n-import java.util.stream.Stream;\n-\n-import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertNull;\n-import static org.junit.jupiter.api.Assertions.assertThrows;\n-\n-\/\/ Tests lenient parsing, this is done by testing the NumberFormat factory instances\n-\/\/ against a number of locales with different formatting conventions. The locales\n-\/\/ used all use a grouping size of 3. When lenient, parsing only fails\n-\/\/ if the prefix and\/or suffix are not found, or the first character after the\n-\/\/ prefix is un-parseable. The tested locales all use groupingSize of 3.\n-public class LenientParseTest {\n-\n-    \/\/ Used to retrieve the locale's expected symbols\n-    private static final DecimalFormatSymbols dfs =\n-            new DecimalFormatSymbols(Locale.getDefault());\n-    private static final DecimalFormat dFmt = (DecimalFormat)\n-            NumberFormat.getNumberInstance(Locale.getDefault());\n-    private static final DecimalFormat cFmt =\n-            (DecimalFormat) NumberFormat.getCurrencyInstance(Locale.getDefault());\n-    private static final DecimalFormat pFmt =\n-            (DecimalFormat) NumberFormat.getPercentInstance(Locale.getDefault());\n-    private static final CompactNumberFormat cmpctFmt =\n-            (CompactNumberFormat) NumberFormat.getCompactNumberInstance(Locale.getDefault(),\n-                    NumberFormat.Style.SHORT);\n-\n-    \/\/ All NumberFormats should parse leniently (which is the default)\n-    static {\n-        \/\/ To effectively test compactNumberFormat, these should be set accordingly\n-        cmpctFmt.setParseIntegerOnly(false);\n-        cmpctFmt.setGroupingUsed(true);\n-    }\n-\n-    \/\/ ---- NumberFormat tests ----\n-    \/\/ Test prefix\/suffix behavior with a predefined DecimalFormat\n-    \/\/ Non-localized, only run once\n-    @ParameterizedTest\n-    @MethodSource(\"badParseStrings\")\n-    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n-    public void numFmtFailParseTest(String toParse, int expectedErrorIndex) {\n-        \/\/ Format with grouping size = 3, prefix = a, suffix = b\n-        DecimalFormat nonLocalizedDFmt = new DecimalFormat(\"a#,#00.00b\");\n-        failParse(nonLocalizedDFmt, toParse, expectedErrorIndex);\n-    }\n-\n-    \/\/ All input Strings should parse fully and return the expected value.\n-    \/\/ Expected index should be the length of the parse string, since it parses fully\n-    @ParameterizedTest\n-    @MethodSource(\"validFullParseStrings\")\n-    public void numFmtSuccessFullParseTest(String toParse, double expectedValue) {\n-        assertEquals(expectedValue, successParse(dFmt, toParse, toParse.length()));\n-    }\n-\n-    \/\/ All input Strings should parse partially and return expected value\n-    \/\/ with the expected final index\n-    @ParameterizedTest\n-    @MethodSource(\"validPartialParseStrings\")\n-    public void numFmtSuccessPartialParseTest(String toParse, double expectedValue,\n-                                              int expectedIndex) {\n-        assertEquals(expectedValue, successParse(dFmt, toParse, expectedIndex));\n-    }\n-\n-    \/\/ Parse partially due to no grouping\n-    @ParameterizedTest\n-    @MethodSource(\"noGroupingParseStrings\")\n-    public void numFmtStrictGroupingNotUsed(String toParse, double expectedValue, int expectedIndex) {\n-        dFmt.setGroupingUsed(false);\n-        assertEquals(expectedValue, successParse(dFmt, toParse, expectedIndex));\n-        dFmt.setGroupingUsed(true);\n-    }\n-\n-    \/\/ Parse partially due to integer only\n-    @ParameterizedTest\n-    @MethodSource(\"integerOnlyParseStrings\")\n-    public void numFmtStrictIntegerOnlyUsed(String toParse, int expectedValue, int expectedIndex) {\n-        dFmt.setParseIntegerOnly(true);\n-        assertEquals(expectedValue, successParse(dFmt, toParse, expectedIndex));\n-        dFmt.setParseIntegerOnly(false);\n-    }\n-\n-    @Test \/\/ Non-localized, only run once\n-    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n-    public void badExponentParseNumberFormatTest() {\n-        \/\/ Some fmt, with an \"E\" exponent string\n-        DecimalFormat fmt = (DecimalFormat) NumberFormat.getNumberInstance(Locale.US);\n-        \/\/ Upon non-numeric in exponent, parse will still successfully complete\n-        \/\/ but index should end on the last valid char in exponent\n-        assertEquals(1.23E45, successParse(fmt, \"1.23E45.123\", 7));\n-        assertEquals(1.23E45, successParse(fmt, \"1.23E45.\", 7));\n-        assertEquals(1.23E45, successParse(fmt, \"1.23E45FOO3222\", 7));\n-    }\n-\n-    \/\/ ---- CurrencyFormat tests ----\n-    \/\/ All input Strings should pass and return expected value.\n-    @ParameterizedTest\n-    @MethodSource(\"currencyValidFullParseStrings\")\n-    public void currFmtSuccessParseTest(String toParse, double expectedValue) {\n-        assertEquals(expectedValue, successParse(cFmt, toParse, toParse.length()));\n-    }\n-\n-    \/\/ Strings may parse partially or fail. This is because the mapped\n-    \/\/ data may cause the error to occur before the suffix can be found, (if the locale\n-    \/\/ uses a suffix).\n-    @ParameterizedTest\n-    @MethodSource(\"currencyValidPartialParseStrings\")\n-    public void currFmtParseTest(String toParse, double expectedValue,\n-                                 int expectedIndex) {\n-        if (cFmt.getPositiveSuffix().length() > 0) {\n-            \/\/ Since the error will occur before suffix is found, exception is thrown.\n-            failParse(cFmt, toParse, expectedIndex);\n-        } else {\n-            \/\/ Empty suffix, thus even if the error occurs, we have already found the\n-            \/\/ prefix, and simply parse partially\n-            assertEquals(expectedValue, successParse(cFmt, toParse, expectedIndex));\n-        }\n-    }\n-\n-    \/\/ ---- PercentFormat tests ----\n-    \/\/ All input Strings should pass and return expected value.\n-    @ParameterizedTest\n-    @MethodSource(\"percentValidFullParseStrings\")\n-    public void percentFmtSuccessParseTest(String toParse, double expectedValue) {\n-        assertEquals(expectedValue, successParse(pFmt, toParse, toParse.length()));\n-    }\n-\n-    \/\/ Strings may parse partially or fail. This is because the mapped\n-    \/\/ data may cause the error to occur before the suffix can be found, (if the locale\n-    \/\/ uses a suffix).\n-    @ParameterizedTest\n-    @MethodSource(\"percentValidPartialParseStrings\")\n-    public void percentFmtParseTest(String toParse, double expectedValue,\n-                                 int expectedIndex) {\n-        if (pFmt.getPositiveSuffix().length() > 0) {\n-            \/\/ Since the error will occur before suffix is found, exception is thrown.\n-            failParse(pFmt, toParse, expectedIndex);\n-        } else {\n-            \/\/ Empty suffix, thus even if the error occurs, we have already found the\n-            \/\/ prefix, and simply parse partially\n-            assertEquals(expectedValue, successParse(pFmt, toParse, expectedIndex));\n-        }\n-    }\n-\n-    \/\/ ---- CompactNumberFormat tests ----\n-    \/\/ Can match to both the decimalFormat patterns and the compact patterns\n-    \/\/ Unlike the other tests, this test is only ran against the US Locale and\n-    \/\/ tests against data built with the thousands format (K).\n-    @ParameterizedTest\n-    @MethodSource(\"compactValidPartialParseStrings\")\n-    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n-    public void compactFmtFailParseTest(String toParse, double expectedValue, int expectedErrorIndex) {\n-        assertEquals(expectedValue, successParse(cmpctFmt, toParse, expectedErrorIndex));\n-    }\n-\n-\n-    @ParameterizedTest\n-    @MethodSource(\"compactValidFullParseStrings\")\n-    @EnabledIfSystemProperty(named = \"user.language\", matches = \"en\")\n-    public void compactFmtSuccessParseTest(String toParse, double expectedValue) {\n-        assertEquals(expectedValue, successParse(cmpctFmt, toParse, toParse.length()));\n-    }\n-\n-    \/\/ ---- Helper test methods ----\n-\n-    \/\/ Method is used when a String should parse successfully. This does not indicate\n-    \/\/ that the entire String was used, however. The index and errorIndex values\n-    \/\/ should be as expected.\n-    private double successParse(NumberFormat fmt, String toParse, int expectedIndex) {\n-        Number parsedValue = assertDoesNotThrow(() -> fmt.parse(toParse));\n-        ParsePosition pp = new ParsePosition(0);\n-        assertDoesNotThrow(() -> fmt.parse(toParse, pp));\n-        assertEquals(-1, pp.getErrorIndex(),\n-                \"ParsePosition ErrorIndex is not in correct location\");\n-        assertEquals(expectedIndex, pp.getIndex(),\n-                \"ParsePosition Index is not in correct location\");\n-        return parsedValue.doubleValue();\n-    }\n-\n-    \/\/ Method is used when a String should fail parsing. Indicated by either a thrown\n-    \/\/ ParseException, or null is returned depending on which parse method is invoked.\n-    \/\/ errorIndex should be as expected.\n-    private void failParse(NumberFormat fmt, String toParse, int expectedErrorIndex) {\n-        ParsePosition pp = new ParsePosition(0);\n-        assertThrows(ParseException.class, () -> fmt.parse(toParse));\n-        assertNull(fmt.parse(toParse, pp));\n-        assertEquals(expectedErrorIndex, pp.getErrorIndex());\n-    }\n-\n-    \/\/ ---- Data Providers ----\n-\n-    \/\/ Strings that should fail when parsed leniently.\n-    \/\/ Given as Arguments<String, expectedErrorIndex>\n-    \/\/ Non-localized data. For reference, the pattern of nonLocalizedDFmt is\n-    \/\/ \"a#,#00.00b\"\n-    private static Stream<Arguments> badParseStrings() {\n-        return Stream.of(\n-                \/\/ No prefix\n-                Arguments.of(\"1,1b\", 0),\n-                \/\/ No suffix\n-                Arguments.of(\"a1,11\", 5),\n-                \/\/ Digit does not follow the last grouping separator\n-                \/\/ Current behavior fails on the grouping separator\n-                Arguments.of(\"a1,11,z\", 5),\n-                \/\/ No suffix after grouping\n-                Arguments.of(\"a1,11,\", 5),\n-                \/\/ No prefix and suffix\n-                Arguments.of(\"1,11\", 0),\n-                \/\/ First character after prefix is un-parseable\n-                \/\/ Behavior is to expect error index at 0, not 1\n-                Arguments.of(\"ac1,11\", 0));\n-    }\n-\n-    \/\/ These data providers use US locale grouping and decimal separators\n-    \/\/ for readability, however, the data is tested against multiple locales\n-    \/\/ and is converted appropriately at runtime.\n-\n-    \/\/ Strings that should parse successfully, and consume the entire String\n-    \/\/ Form of Arguments(parseString, expectedParsedNumber)\n-    private static Stream<Arguments> validFullParseStrings() {\n-        return Stream.of(\n-                \/\/ Many subsequent grouping symbols\n-                Arguments.of(\"1,,,1\", 11d),\n-                Arguments.of(\"11,,,11,,,11\", 111111d),\n-                \/\/ Bad grouping size (with decimal)\n-                Arguments.of(\"1,1.\", 11d),\n-                Arguments.of(\"11,111,11.\", 1111111d),\n-                \/\/ Improper grouping size (with decimal and digits after)\n-                Arguments.of(\"1,1.1\", 11.1d),\n-                Arguments.of(\"1,11.1\", 111.1d),\n-                Arguments.of(\"1,1111.1\", 11111.1d),\n-                Arguments.of(\"11,111,11.1\", 1111111.1d),\n-                \/\/ Starts with grouping symbol\n-                Arguments.of(\",111,,1,1\", 11111d),\n-                Arguments.of(\",1\", 1d),\n-                Arguments.of(\",,1\", 1d),\n-                \/\/ Leading Zeros (not digits)\n-                Arguments.of(\"000,1,1\", 11d),\n-                Arguments.of(\"000,111,11,,1\", 111111d),\n-                Arguments.of(\"0,000,1,,1,1\", 111d),\n-                Arguments.of(\"1,234.00\", 1234d),\n-                Arguments.of(\"1,234.0\", 1234d),\n-                Arguments.of(\"1,234.\", 1234d),\n-                Arguments.of(\"1,234.00123\", 1234.00123d),\n-                Arguments.of(\"1,234.012\", 1234.012d),\n-                Arguments.of(\"1,234.224\", 1234.224d),\n-                Arguments.of(\"1\", 1d),\n-                Arguments.of(\"10\", 10d),\n-                Arguments.of(\"100\", 100d),\n-                Arguments.of(\"1000\", 1000d),\n-                Arguments.of(\"1,000\", 1000d),\n-                Arguments.of(\"10,000\", 10000d),\n-                Arguments.of(\"10000\", 10000d),\n-                Arguments.of(\"100,000\", 100000d),\n-                Arguments.of(\"1,000,000\", 1000000d),\n-                Arguments.of(\"10,000,000\", 10000000d))\n-                .map(args -> Arguments.of(\n-                        localizeText(String.valueOf(args.get()[0])), args.get()[1]));\n-    }\n-\n-    \/\/ Strings that should parse successfully, but do not use the entire String\n-    \/\/ Form of Arguments(parseString, expectedParsedNumber, expectedIndex)\n-    private static Stream<Arguments> validPartialParseStrings() {\n-        return Stream.of(\n-                \/\/ End with grouping symbol\n-                Arguments.of(\"11,\", 11d, 2),\n-                Arguments.of(\"11,,\", 11d, 3),\n-                Arguments.of(\"11,,,\", 11d, 4),\n-                \/\/ Random chars that aren't the expected symbols\n-                Arguments.of(\"1,1P111\", 11d, 3),\n-                Arguments.of(\"1.1P111\", 1.1d, 3),\n-                Arguments.of(\"1P,1111\", 1d, 1),\n-                Arguments.of(\"1P.1111\", 1d, 1),\n-                Arguments.of(\"1,1111P\", 11111d, 6),\n-                \/\/ Grouping occurs after decimal separator)\n-                Arguments.of(\"1.11,11\", 1.11d, 4),\n-                Arguments.of(\"1.,11,11\", 1d, 2))\n-                .map(args -> Arguments.of(\n-                        localizeText(String.valueOf(args.get()[0])), args.get()[1], args.get()[2]));\n-    }\n-\n-    \/\/ Test data input for when parse integer only is true\n-    \/\/ Form of Arguments(parseString, expectedParsedNumber, expectedIndex)\n-    private static Stream<Arguments> integerOnlyParseStrings() {\n-        return Stream.of(\n-                Arguments.of(\"1234.1234\", 1234, 4),\n-                Arguments.of(\"1234.12\", 1234, 4),\n-                Arguments.of(\"1234.1a\", 1234, 4),\n-                Arguments.of(\"1234.\", 1234, 4))\n-                .map(args -> Arguments.of(\n-                        localizeText(String.valueOf(args.get()[0])), args.get()[1], args.get()[2]));\n-    }\n-\n-    \/\/ Test data input for when no grouping is true\n-    \/\/ Form of Arguments(parseString, expectedParsedNumber, expectedIndex)\n-    private static Stream<Arguments> noGroupingParseStrings() {\n-        return Stream.of(\n-                Arguments.of(\"12,34\", 12d, 2),\n-                Arguments.of(\"1234,\", 1234d, 4),\n-                Arguments.of(\"123,456.789\", 123d, 3))\n-                .map(args -> Arguments.of(\n-                        localizeText(String.valueOf(args.get()[0])), args.get()[1], args.get()[2]));\n-    }\n-\n-    \/\/ Mappers for respective data providers to adjust values accordingly\n-    \/\/ Localized percent prefix\/suffix is added, with appropriate expected values\n-    \/\/ adjusted. Expected parsed number should be divided by 100.\n-    private static Stream<Arguments> percentValidPartialParseStrings() {\n-        return validPartialParseStrings().map(args ->\n-                Arguments.of(pFmt.getPositivePrefix() + args.get()[0] + pFmt.getPositiveSuffix(),\n-                        (double) args.get()[1] \/ 100, (int) args.get()[2] + pFmt.getPositivePrefix().length())\n-        );\n-    }\n-\n-    private static Stream<Arguments> percentValidFullParseStrings() {\n-        return validFullParseStrings().map(args -> Arguments.of(\n-                pFmt.getPositivePrefix() + args.get()[0] + pFmt.getPositiveSuffix(),\n-                (double) args.get()[1] \/ 100)\n-        );\n-    }\n-\n-    \/\/ Mappers for respective data providers to adjust values accordingly\n-    \/\/ Localized percent prefix\/suffix is added, with appropriate expected values\n-    \/\/ adjusted. Separators replaced for monetary versions.\n-    private static Stream<Arguments> currencyValidPartialParseStrings() {\n-        return validPartialParseStrings().map(args -> Arguments.of(\n-                cFmt.getPositivePrefix() + String.valueOf(args.get()[0])\n-                        .replace(dfs.getGroupingSeparator(), dfs.getMonetaryGroupingSeparator())\n-                        .replace(dfs.getDecimalSeparator(), dfs.getMonetaryDecimalSeparator())\n-                        + cFmt.getPositiveSuffix(),\n-                args.get()[1], (int) args.get()[2] + cFmt.getPositivePrefix().length())\n-        );\n-    }\n-\n-    private static Stream<Arguments> currencyValidFullParseStrings() {\n-        return validFullParseStrings().map(args -> Arguments.of(\n-                cFmt.getPositivePrefix() + String.valueOf(args.get()[0])\n-                        .replace(dfs.getGroupingSeparator(), dfs.getMonetaryGroupingSeparator())\n-                        .replace(dfs.getDecimalSeparator(), dfs.getMonetaryDecimalSeparator())\n-                        + cFmt.getPositiveSuffix(),\n-                args.get()[1])\n-        );\n-    }\n-\n-    \/\/ Compact Pattern Data Provider provides test input for both DecimalFormat patterns\n-    \/\/ and the compact patterns. As there is no method to retrieve compact patterns,\n-    \/\/ thus test only against US English locale, and use a hard coded K - 1000\n-    private static Stream<Arguments> compactValidPartialParseStrings() {\n-        return Stream.concat(validPartialParseStrings().map(args -> Arguments.of(args.get()[0],\n-                args.get()[1], args.get()[2])), validPartialParseStrings().map(args -> Arguments.of(args.get()[0] + \"K\",\n-                args.get()[1], args.get()[2]))\n-        );\n-    }\n-\n-    private static Stream<Arguments> compactValidFullParseStrings() {\n-        return Stream.concat(validFullParseStrings().map(args -> Arguments.of(args.get()[0],\n-                args.get()[1])), validFullParseStrings().map(args -> Arguments.of(args.get()[0] + \"K\",\n-                (double)args.get()[1] * 1000.0))\n-        );\n-    }\n-\n-    \/\/ Replace the grouping and decimal separators with localized variants\n-    \/\/ Used during localization of data\n-    private static String localizeText(String text) {\n-        \/\/ As this is a single pass conversion, this is safe for multiple replacement,\n-        \/\/ even if a ',' could be a decimal separator for a locale.\n-        StringBuilder sb = new StringBuilder();\n-        for (int i = 0; i < text.length(); i++) {\n-            char c = text.charAt(i);\n-            if (c == ',') {\n-                sb.append(dfs.getGroupingSeparator());\n-            } else if (c == '.') {\n-                sb.append(dfs.getDecimalSeparator());\n-            } else if (c == '0') {\n-                sb.append(dfs.getZeroDigit());\n-            } else {\n-                sb.append(c);\n-            }\n-        }\n-        return sb.toString();\n-    }\n-}\n","filename":"test\/jdk\/java\/text\/Format\/NumberFormat\/LenientParseTest.java","additions":0,"deletions":430,"binary":false,"changes":430,"status":"deleted"}]}