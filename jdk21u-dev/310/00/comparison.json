{"files":[{"patch":"@@ -30,0 +30,1 @@\n+import java.util.ArrayList;\n@@ -1303,1 +1304,1 @@\n-        public List<Symbol> permitted;\n+        private java.util.List<PermittedClassWithPos> permitted;\n@@ -1307,0 +1308,2 @@\n+        private record PermittedClassWithPos(Symbol permittedClass, int pos) {}\n+\n@@ -1315,1 +1318,1 @@\n-            this.permitted = List.nil();\n+            this.permitted = new ArrayList<>();\n@@ -1327,0 +1330,31 @@\n+        public void addPermittedSubclass(ClassSymbol csym, int pos) {\n+            Assert.check(!isPermittedExplicit);\n+            \/\/ we need to insert at the right pos\n+            PermittedClassWithPos element = new PermittedClassWithPos(csym, pos);\n+            int index = Collections.binarySearch(permitted, element, java.util.Comparator.comparing(PermittedClassWithPos::pos));\n+            if (index < 0) {\n+                index = -index - 1;\n+            }\n+            permitted.add(index, element);\n+        }\n+\n+        public boolean isPermittedSubclass(Symbol csym) {\n+            for (PermittedClassWithPos permittedClassWithPos : permitted) {\n+                if (permittedClassWithPos.permittedClass.equals(csym)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        public void clearPermittedSubclasses() {\n+            permitted.clear();\n+        }\n+\n+        public void setPermittedSubclasses(List<Symbol> permittedSubs) {\n+            permitted.clear();\n+            for (Symbol csym : permittedSubs) {\n+                permitted.add(new PermittedClassWithPos(csym, 0));\n+            }\n+        }\n+\n@@ -1643,1 +1677,1 @@\n-            return permitted.map(s -> s.type);\n+            return permitted.stream().map(s -> s.permittedClass().type).collect(List.collector());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":37,"deletions":3,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1696,1 +1696,1 @@\n-                return sealedOne.permitted.stream().allMatch(sym -> areDisjoint((ClassSymbol)sym, other));\n+                return sealedOne.getPermittedSubclasses().stream().allMatch(type -> areDisjoint((ClassSymbol)type.tsym, other));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5409,1 +5409,1 @@\n-                    c.permitted.isEmpty()) {\n+                    c.getPermittedSubclasses().isEmpty()) {\n@@ -5416,1 +5416,1 @@\n-                for (Symbol subTypeSym : c.permitted) {\n+                for (Type subType : c.getPermittedSubclasses()) {\n@@ -5418,1 +5418,1 @@\n-                    if (subTypeSym.type.getTag() == TYPEVAR) {\n+                    if (subType.getTag() == TYPEVAR) {\n@@ -5420,2 +5420,2 @@\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n-                                Errors.InvalidPermitsClause(Fragments.IsATypeVariable(subTypeSym.type)));\n+                        log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n+                                Errors.InvalidPermitsClause(Fragments.IsATypeVariable(subType)));\n@@ -5423,2 +5423,2 @@\n-                    if (subTypeSym.isAnonymous() && !c.isEnum()) {\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),  Errors.LocalClassesCantExtendSealed(Fragments.Anonymous));\n+                    if (subType.tsym.isAnonymous() && !c.isEnum()) {\n+                        log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),  Errors.LocalClassesCantExtendSealed(Fragments.Anonymous));\n@@ -5426,1 +5426,1 @@\n-                    if (permittedTypes.contains(subTypeSym)) {\n+                    if (permittedTypes.contains(subType.tsym)) {\n@@ -5429,1 +5429,1 @@\n-                                        .filter(permittedExpr -> TreeInfo.diagnosticPositionFor(subTypeSym, permittedExpr, true) != null)\n+                                        .filter(permittedExpr -> TreeInfo.diagnosticPositionFor(subType.tsym, permittedExpr, true) != null)\n@@ -5431,1 +5431,1 @@\n-                        log.error(pos, Errors.InvalidPermitsClause(Fragments.IsDuplicated(subTypeSym.type)));\n+                        log.error(pos, Errors.InvalidPermitsClause(Fragments.IsDuplicated(subType)));\n@@ -5433,1 +5433,1 @@\n-                        permittedTypes.add(subTypeSym);\n+                        permittedTypes.add(subType.tsym);\n@@ -5436,2 +5436,2 @@\n-                        if (subTypeSym.packge() != c.packge()) {\n-                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                        if (subType.tsym.packge() != c.packge()) {\n+                            log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n@@ -5441,2 +5441,2 @@\n-                    } else if (subTypeSym.packge().modle != c.packge().modle) {\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n+                    } else if (subType.tsym.packge().modle != c.packge().modle) {\n+                        log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n@@ -5446,2 +5446,2 @@\n-                    if (subTypeSym == c.type.tsym || types.isSuperType(subTypeSym.type, c.type)) {\n-                        log.error(TreeInfo.diagnosticPositionFor(subTypeSym, ((JCClassDecl)env.tree).permitting),\n+                    if (subType.tsym == c.type.tsym || types.isSuperType(subType, c.type)) {\n+                        log.error(TreeInfo.diagnosticPositionFor(subType.tsym, ((JCClassDecl)env.tree).permitting),\n@@ -5449,1 +5449,1 @@\n-                                        subTypeSym == c.type.tsym ?\n+                                        subType.tsym == c.type.tsym ?\n@@ -5451,1 +5451,1 @@\n-                                                Fragments.MustNotBeSupertype(subTypeSym.type)\n+                                                Fragments.MustNotBeSupertype(subType)\n@@ -5455,1 +5455,1 @@\n-                        boolean thisIsASuper = types.directSupertypes(subTypeSym.type)\n+                        boolean thisIsASuper = types.directSupertypes(subType)\n@@ -5459,2 +5459,2 @@\n-                            log.error(TreeInfo.diagnosticPositionFor(subTypeSym, env.tree),\n-                                    Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subTypeSym.type)));\n+                            log.error(TreeInfo.diagnosticPositionFor(subType.tsym, env.tree),\n+                                    Errors.InvalidPermitsClause(Fragments.DoesntExtendSealed(subType)));\n@@ -5495,1 +5495,1 @@\n-                        if (!supertypeSym.permitted.contains(c.type.tsym)) {\n+                       if (!supertypeSym.isPermittedSubclass(c.type.tsym)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -923,2 +923,2 @@\n-                    for (Symbol sym : current.permitted) {\n-                        ClassSymbol csym = (ClassSymbol) sym;\n+                    for (Type t : current.getPermittedSubclasses()) {\n+                        ClassSymbol csym = (ClassSymbol) t.tsym;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -923,1 +923,1 @@\n-                            supClass.permitted = supClass.permitted.append(sym);\n+                            supClass.addPermittedSubclass(sym, tree.pos);\n@@ -936,1 +936,1 @@\n-                sym.permitted = permittedSubtypeSymbols.toList();\n+                sym.setPermittedSubclasses(permittedSubtypeSymbols.toList());\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1299,1 +1299,1 @@\n-                        ((ClassSymbol)sym).permitted = subtypes.toList();\n+                        ((ClassSymbol)sym).setPermittedSubclasses(subtypes.toList());\n@@ -2616,1 +2616,1 @@\n-        if (c.permitted != null && !c.permitted.isEmpty()) {\n+        if (!c.getPermittedSubclasses().isEmpty()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -925,1 +925,1 @@\n-        if (csym.permitted.nonEmpty()) {\n+        if (csym.getPermittedSubclasses().nonEmpty()) {\n@@ -927,3 +927,3 @@\n-            databuf.appendChar(csym.permitted.size());\n-            for (Symbol c : csym.permitted) {\n-                databuf.appendChar(poolWriter.putClass((ClassSymbol) c));\n+            databuf.appendChar(csym.getPermittedSubclasses().size());\n+            for (Type t : csym.getPermittedSubclasses()) {\n+                databuf.appendChar(poolWriter.putClass((ClassSymbol) t.tsym));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1646,1 +1646,1 @@\n-                    node.sym.permitted = List.nil();\n+                    node.sym.clearPermittedSubclasses();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -143,1 +143,0 @@\n-        subtypeNames.sort((s1, s2) -> s1.compareTo(s2));\n@@ -696,0 +695,34 @@\n+\n+    @Test\n+    public void testClientSwapsPermittedSubclassesOrder(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        Path foo = src.resolve(\"Foo.java\");\n+        Path fooUser = src.resolve(\"FooUser.java\");\n+\n+        tb.writeFile(foo,\n+                \"\"\"\n+                public sealed interface Foo {\n+                    record R1() implements Foo {}\n+                    record R2() implements Foo {}\n+                }\n+                \"\"\");\n+\n+        tb.writeFile(fooUser,\n+                \"\"\"\n+                public class FooUser {\n+                    \/\/ see that the order of arguments differ from the order of subclasses of Foo in the source above\n+                    \/\/ we need to check that the order of permitted subclasses of Foo in the class file corresponds to the\n+                    \/\/ original order in the source code\n+                    public void blah(Foo.R2 a, Foo.R1 b) {}\n+                }\n+                \"\"\");\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        new JavacTask(tb)\n+                .outdir(out)\n+                .files(fooUser, foo)\n+                .run();\n+        checkSealedClassFile(out, \"Foo.class\", List.of(\"Foo$R1\", \"Foo$R2\"));\n+    }\n","filename":"test\/langtools\/tools\/javac\/sealed\/SealedDiffConfigurationsTest.java","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"}]}