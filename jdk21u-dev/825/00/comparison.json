{"files":[{"patch":"@@ -1874,0 +1874,4 @@\n+size_t os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  return page_size;\n+}\n+\n@@ -3009,1 +3013,0 @@\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1576,0 +1576,4 @@\n+size_t os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  return page_size;\n+}\n+\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -101,1 +101,3 @@\n-\n+  product(bool, UseMadvPopulateWrite, true, DIAGNOSTIC,                 \\\n+          \"Use MADV_POPULATE_WRITE in os::pd_pretouch_memory.\")         \\\n+                                                                        \\\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2833,0 +2833,9 @@\n+\/\/ Define MADV_POPULATE_WRITE here so we can build HotSpot on old systems.\n+#define MADV_POPULATE_WRITE_value 23\n+#ifndef MADV_POPULATE_WRITE\n+  #define MADV_POPULATE_WRITE MADV_POPULATE_WRITE_value\n+#else\n+  \/\/ Sanity-check our assumed default value if we build with a new enough libc.\n+  static_assert(MADV_POPULATE_WRITE == MADV_POPULATE_WRITE_value);\n+#endif\n+\n@@ -2878,0 +2887,25 @@\n+size_t os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  const size_t len = pointer_delta(last, first, sizeof(char)) + page_size;\n+  \/\/ Use madvise to pretouch on Linux when THP is used, and fallback to the\n+  \/\/ common method if unsupported. THP can form right after madvise rather than\n+  \/\/ being assembled later.\n+  if (HugePages::thp_mode() == THPMode::always || UseTransparentHugePages) {\n+    int err = 0;\n+    if (UseMadvPopulateWrite &&\n+        ::madvise(first, len, MADV_POPULATE_WRITE) == -1) {\n+      err = errno;\n+    }\n+    if (!UseMadvPopulateWrite || err == EINVAL) { \/\/ Not to use or not supported\n+      \/\/ When using THP we need to always pre-touch using small pages as the\n+      \/\/ OS will initially always use small pages.\n+      return os::vm_page_size();\n+    } else if (err != 0) {\n+      log_info(gc, os)(\"::madvise(\" PTR_FORMAT \", \" SIZE_FORMAT \", %d) failed; \"\n+                       \"error='%s' (errno=%d)\", p2i(first), len,\n+                       MADV_POPULATE_WRITE, os::strerror(err), err);\n+    }\n+    return 0;\n+  }\n+  return page_size;\n+}\n+\n@@ -4444,0 +4478,3 @@\n+  \/\/ Check the availability of MADV_POPULATE_WRITE.\n+  FLAG_SET_DEFAULT(UseMadvPopulateWrite, (::madvise(0, 0, MADV_POPULATE_WRITE) == 0));\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -3788,0 +3788,5 @@\n+\n+size_t os::pd_pretouch_memory(void* first, void* last, size_t page_size) {\n+  return page_size;\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -71,6 +71,0 @@\n-#ifdef LINUX\n-  \/\/ When using THP we need to always pre-touch using small pages as the OS will\n-  \/\/ initially always use small pages.\n-  page_size = UseTransparentHugePages ? (size_t)os::vm_page_size() : page_size;\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1873,1 +1873,1 @@\n-    char* cur = static_cast<char*>(align_down(start, page_size));\n+    void* first = align_down(start, page_size);\n@@ -1875,6 +1875,10 @@\n-    assert(cur <= last, \"invariant\");\n-    \/\/ Iterate from first page through last (inclusive), being careful to\n-    \/\/ avoid overflow if the last page abuts the end of the address range.\n-    for ( ; true; cur += page_size) {\n-      Atomic::add(reinterpret_cast<int*>(cur), 0, memory_order_relaxed);\n-      if (cur >= last) break;\n+    assert(first <= last, \"invariant\");\n+    const size_t pd_page_size = pd_pretouch_memory(first, last, page_size);\n+    if (pd_page_size > 0) {\n+      \/\/ Iterate from first page through last (inclusive), being careful to\n+      \/\/ avoid overflow if the last page abuts the end of the address range.\n+      last = align_down(static_cast<char*>(end) - 1, pd_page_size);\n+      for (char* cur = static_cast<char*>(first); \/* break *\/; cur += pd_page_size) {\n+        Atomic::add(reinterpret_cast<int*>(cur), 0, memory_order_relaxed);\n+        if (cur >= last) break;\n+      }\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -222,0 +222,4 @@\n+  \/\/ Returns 0 if pretouch is done via platform dependent method, or otherwise\n+  \/\/ returns page_size that should be used for the common method.\n+  static size_t pd_pretouch_memory(void* first, void* last, size_t page_size);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -430,0 +430,34 @@\n+TEST_VM(os_linux, pretouch_thp_and_use_concurrent) {\n+  \/\/ Explicitly enable thp to test cocurrent system calls.\n+  const size_t size = 1 * G;\n+  const bool useThp = UseTransparentHugePages;\n+  UseTransparentHugePages = true;\n+  char* const heap = os::reserve_memory(size, false, mtInternal);\n+  EXPECT_NE(heap, nullptr);\n+  EXPECT_TRUE(os::commit_memory(heap, size, false));\n+\n+  {\n+    auto pretouch = [heap, size](Thread*, int) {\n+      os::pretouch_memory(heap, heap + size, os::vm_page_size());\n+    };\n+    auto useMemory = [heap, size](Thread*, int) {\n+      int* iptr = reinterpret_cast<int*>(heap);\n+      for (int i = 0; i < 1000; i++) *iptr++ = i;\n+    };\n+    TestThreadGroup<decltype(pretouch)> pretouchThreads{pretouch, 4};\n+    TestThreadGroup<decltype(useMemory)> useMemoryThreads{useMemory, 4};\n+    useMemoryThreads.doit();\n+    pretouchThreads.doit();\n+    useMemoryThreads.join();\n+    pretouchThreads.join();\n+  }\n+\n+  int* iptr = reinterpret_cast<int*>(heap);\n+  for (int i = 0; i < 1000; i++)\n+    EXPECT_EQ(*iptr++, i);\n+\n+  EXPECT_TRUE(os::uncommit_memory(heap, size, false));\n+  EXPECT_TRUE(os::release_memory(heap, size));\n+  UseTransparentHugePages = useThp;\n+}\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_os_linux.cpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @run main\/othervm -Xmx1g -Xms1g -XX:+UseParallelGC -XX:+AlwaysPreTouch gc.parallel.TestAlwaysPreTouchBehavior\n+ * @run main\/othervm -Xmx1g -Xms1g -XX:+UseParallelGC -XX:+AlwaysPreTouch -XX:+UnlockDiagnosticVMOptions -XX:-UseMadvPopulateWrite gc.parallel.TestAlwaysPreTouchBehavior\n@@ -80,1 +80,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/gc\/parallel\/TestAlwaysPreTouchBehavior.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Collections;\n@@ -92,2 +93,2 @@\n-\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+            ArrayList<String> vmArgs = new ArrayList<>();\n+            Collections.addAll(vmArgs,\n@@ -97,3 +98,6 @@\n-                    \"-XX:NativeMemoryTracking=summary\", \"-XX:+PrintNMTStatistics\",\n-                    \"TestAlwaysPreTouchStacks\",\n-                    \"test\");\n+                    \"-XX:NativeMemoryTracking=summary\", \"-XX:+PrintNMTStatistics\");\n+            if (System.getProperty(\"os.name\").contains(\"Linux\")) {\n+                vmArgs.add(\"-XX:-UseMadvPopulateWrite\");\n+            }\n+            Collections.addAll(vmArgs, \"TestAlwaysPreTouchStacks\", \"test\");\n+            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(vmArgs);\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestAlwaysPreTouchStacks.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"}]}