{"files":[{"patch":"@@ -40,0 +40,2 @@\n+import java.util.Set;\n+import java.util.List;\n@@ -125,4 +127,3 @@\n-        ClassUnloadCommon.triggerUnloading();  \/\/ should unload these classes\n-        for (String className : classNames) {\n-          ClassUnloadCommon.failIf(wb.isClassAlive(className), \"should be unloaded\");\n-        }\n+\n+        Set<String> aliveClasses = ClassUnloadCommon.triggerUnloading(List.of(classNames));\n+        ClassUnloadCommon.failIf(!aliveClasses.isEmpty(), \"should be unloaded: \" + aliveClasses);\n","filename":"test\/hotspot\/jtreg\/runtime\/ClassInitErrors\/InitExceptionUnloadTest.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n@@ -74,0 +77,35 @@\n+    \/**\n+     * Calls triggerUnloading() in a retry loop for 2 seconds or until WhiteBox.isClassAlive\n+     * determines that no classes named in classNames are alive.\n+     *\n+     * This variant of triggerUnloading() accommodates the inherent raciness\n+     * of class unloading. For example, it's possible for a JIT compilation to hold\n+     * strong roots to types (e.g. in virtual call or instanceof profiles) that\n+     * are not released or converted to weak roots until the compilation completes.\n+     *\n+     * @param classNames the set of classes that are expected to be unloaded\n+     * @return the set of classes that have not been unloaded after exiting the retry loop\n+     *\/\n+    public static Set<String> triggerUnloading(List<String> classNames) {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        Set<String> aliveClasses = new HashSet<>(classNames);\n+        int attempt = 0;\n+        while (!aliveClasses.isEmpty() && attempt < 20) {\n+            ClassUnloadCommon.triggerUnloading();\n+            for (String className : classNames) {\n+                if (aliveClasses.contains(className)) {\n+                    if (wb.isClassAlive(className)) {\n+                        try {\n+                            Thread.sleep(100);\n+                        } catch (InterruptedException ex) {\n+                        }\n+                    } else {\n+                        aliveClasses.remove(className);\n+                    }\n+                }\n+            }\n+            attempt++;\n+        }\n+        return aliveClasses;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/classloader\/ClassUnloadCommon.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"}]}