{"files":[{"patch":"@@ -1150,1 +1150,3 @@\n-            NewSessionTicket.t13PosthandshakeProducer.produce(shc);\n+            if (SSLConfiguration.serverNewSessionTicketCount > 0) {\n+                NewSessionTicket.t13PosthandshakeProducer.produce(shc);\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Finished.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.math.BigInteger;\n@@ -33,0 +32,1 @@\n+import java.util.Arrays;\n@@ -121,5 +121,0 @@\n-        @Override\n-        public SSLHandshake handshakeType() {\n-            return NEW_SESSION_TICKET;\n-        }\n-\n@@ -224,5 +219,0 @@\n-        @Override\n-        public SSLHandshake handshakeType() {\n-            return NEW_SESSION_TICKET;\n-        }\n-\n@@ -304,1 +294,1 @@\n-        } catch  (GeneralSecurityException gse) {\n+        } catch (GeneralSecurityException gse) {\n@@ -335,2 +325,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -354,2 +343,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -366,2 +354,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -378,6 +365,2 @@\n-            SessionId newId = new SessionId(true,\n-                hc.sslContext.getSecureRandom());\n-\n-            SecretKey resumptionMasterSecret =\n-                hc.handshakeSession.getResumptionMasterSecret();\n-            if (resumptionMasterSecret == null) {\n+            int sessionTimeoutSeconds = sessionCache.getSessionTimeout();\n+            if (sessionTimeoutSeconds > MAX_TICKET_LIFETIME) {\n@@ -385,3 +368,2 @@\n-                    SSLLogger.fine(\n-                            \"No session ticket produced: \" +\n-                            \"no resumption secret\");\n+                    SSLLogger.fine(\"No session ticket produced: \" +\n+                            \"session timeout is too long\");\n@@ -393,13 +375,11 @@\n-            \/\/ construct the PSK and handshake message\n-            BigInteger nonce = hc.handshakeSession.incrTicketNonceCounter();\n-            byte[] nonceArr = nonce.toByteArray();\n-            SecretKey psk = derivePreSharedKey(\n-                    hc.negotiatedCipherSuite.hashAlg,\n-                    resumptionMasterSecret, nonceArr);\n-\n-            int sessionTimeoutSeconds = sessionCache.getSessionTimeout();\n-            if (sessionTimeoutSeconds > MAX_TICKET_LIFETIME) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                    SSLLogger.fine(\n-                            \"No session ticket produced: \" +\n-                            \"session timeout\");\n+            \/\/ Send NewSessionTickets to the client based\n+            if (SSLConfiguration.serverNewSessionTicketCount > 0) {\n+                int i = 0;\n+                NewSessionTicketMessage nstm;\n+                while (i < SSLConfiguration.serverNewSessionTicketCount) {\n+                    nstm = generateNST(hc, sessionCache);\n+                    if (nstm == null) {\n+                        break;\n+                    }\n+                    nstm.write(hc.handshakeOutput);\n+                    i++;\n@@ -408,1 +388,28 @@\n-                return null;\n+                hc.handshakeOutput.flush();\n+            }\n+            \/*\n+             * With large NST counts, a client that quickly closes after\n+             * TLS Finished completes can cause SocketExceptions such as:\n+             * Windows servers read-side throwing SocketException:\n+             *   \"An established connection was aborted by the software in\n+             *    your host machine\", which relates to error WSAECONNABORTED.\n+             * A SocketException caused by a \"broken pipe\" has been observed on\n+             * other systems.\n+             * These are very unlikely situations when client and server are on\n+             * different machines.\n+             *\n+             * RFC 8446 does not put requirements when an NST needs to be\n+             * sent, but it should be sent very soon after TLS Finished for\n+             * clients that will quickly resume to create more sessions.\n+             * TLS 1.3 is different from TLS 1.2, there is more data the client\n+             * should be aware of\n+             *\/\n+\n+            \/\/ See note on TransportContext.needHandshakeFinishedStatus.\n+            \/\/\n+            \/\/ Reset the needHandshakeFinishedStatus flag.  The delivery\n+            \/\/ of this post-handshake message will indicate the FINISHED\n+            \/\/ handshake status.  It is not needed to have a follow-on\n+            \/\/ SSLEngine.wrap() any longer.\n+            if (hc.conContext.needHandshakeFinishedStatus) {\n+                hc.conContext.needHandshakeFinishedStatus = false;\n@@ -411,1 +418,16 @@\n-            NewSessionTicketMessage nstm = null;\n+            \/\/ clean the post handshake context\n+            hc.conContext.finishPostHandshake();\n+\n+            \/\/ The message has been delivered.\n+            return null;\n+        }\n+\n+        private NewSessionTicketMessage generateNST(HandshakeContext hc,\n+            SSLSessionContextImpl sessionCache) throws IOException {\n+\n+            NewSessionTicketMessage nstm;\n+            SessionId newId = new SessionId(true,\n+                hc.sslContext.getSecureRandom());\n+\n+            \/\/ construct the PSK and handshake message\n+            byte[] nonce = hc.handshakeSession.incrTicketNonceCounter();\n@@ -414,2 +436,4 @@\n-                    new SSLSessionImpl(hc.handshakeSession, newId);\n-            sessionCopy.setPreSharedKey(psk);\n+                new SSLSessionImpl(hc.handshakeSession, newId);\n+            sessionCopy.setPreSharedKey(derivePreSharedKey(\n+                hc.negotiatedCipherSuite.hashAlg,\n+                hc.handshakeSession.getResumptionMasterSecret(), nonce));\n@@ -422,1 +446,1 @@\n-                        sessionTimeoutSeconds,\n+                        sessionCache.getSessionTimeout(),\n@@ -424,1 +448,1 @@\n-                        nonceArr,\n+                        nonce,\n@@ -431,2 +455,1 @@\n-                        SSLLogger.fine(\n-                            \"Produced NewSessionTicket stateless \" +\n+                        SSLLogger.fine(\"Produced NewSessionTicket stateless \" +\n@@ -436,0 +459,1 @@\n+                return nstm;\n@@ -441,3 +465,4 @@\n-                nstm = new T13NewSessionTicketMessage(hc, sessionTimeoutSeconds,\n-                        hc.sslContext.getSecureRandom(), nonceArr,\n-                        newId.getId());\n+                nstm = new T13NewSessionTicketMessage(hc,\n+                    sessionCache.getSessionTimeout(),\n+                    hc.sslContext.getSecureRandom(), nonce,\n+                    newId.getId());\n@@ -445,3 +470,2 @@\n-                    SSLLogger.fine(\n-                            \"Produced NewSessionTicket post-handshake message\",\n-                            nstm);\n+                    SSLLogger.fine(\"Produced NewSessionTicket \" +\n+                        \"post-handshake message\", nstm);\n@@ -456,0 +480,1 @@\n+                return nstm;\n@@ -458,15 +483,2 @@\n-            \/\/ Output the handshake message.\n-            if (nstm != null) {\n-                \/\/ should never be null\n-                nstm.write(hc.handshakeOutput);\n-                hc.handshakeOutput.flush();\n-\n-                \/\/ See note on TransportContext.needHandshakeFinishedStatus.\n-                \/\/\n-                \/\/ Reset the needHandshakeFinishedStatus flag.  The delivery\n-                \/\/ of this post-handshake message will indicate the FINISHED\n-                \/\/ handshake status.  It is not needed to have a follow-on\n-                \/\/ SSLEngine.wrap() any longer.\n-                if (hc.conContext.needHandshakeFinishedStatus) {\n-                    hc.conContext.needHandshakeFinishedStatus = false;\n-                }\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"No NewSessionTicket created\");\n@@ -475,4 +487,0 @@\n-            \/\/ clean the post handshake context\n-            hc.conContext.finishPostHandshake();\n-\n-            \/\/ The message has been delivered.\n@@ -500,2 +508,3 @@\n-            \/\/ Is this session resumable?\n-            if (!shc.handshakeSession.isRejoinable()) {\n+            \/\/ Are new tickets allowed?  If so, is this session resumable?\n+            if (SSLConfiguration.serverNewSessionTicketCount == 0 ||\n+                !shc.handshakeSession.isRejoinable()) {\n@@ -581,1 +590,0 @@\n-                sessionCache.remove(hc.handshakeSession.getSessionId());\n@@ -622,1 +630,6 @@\n-            sessionCache.put(sessionCopy);\n+            sessionCache.put(sessionCopy, sessionCopy.isPSK());\n+\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"MultiNST PSK (Server): \" +\n+                    Utilities.toHexString(Arrays.copyOf(nstm.ticket, 16)));\n+            }\n@@ -629,0 +642,1 @@\n+    \/* TLS 1.2 spec does not specify multiple NST behavior.*\/\n@@ -677,2 +691,1 @@\n-                SSLLogger.fine(\"Consuming NewSessionTicket\\n\" +\n-                        nstm.toString());\n+                SSLLogger.fine(\"Consuming NewSessionTicket\\n\" + nstm);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/NewSessionTicket.java","additions":93,"deletions":80,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -697,1 +697,1 @@\n-            sessionCache.remove(chc.resumingSession.getSessionId());\n+            sessionCache.remove(chc.resumingSession.getSessionId(), true);\n@@ -702,0 +702,2 @@\n+                SSLLogger.fine(\n+                    \"MultiNST PSK (Client): \" + Utilities.toHexString(Arrays.copyOf(chc.pskIdentity, 16)));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PreSharedKeyExtension.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,0 +122,5 @@\n+    \/\/ Number of NewSessionTickets that will be sent by the server.\n+    static final int serverNewSessionTicketCount;\n+    \/\/ Default for NewSessionTickets\n+    static final int SERVER_NST_DEFAULT = 1;\n+\n@@ -134,0 +139,27 @@\n+\n+        \/*\n+         * jdk.tls.server.newSessionTicketCount system property\n+         * Sets the number of NewSessionTickets sent to a TLS 1.3 resumption\n+         * client.  The value must be between 0 and 10.  Default is defined by\n+         * SERVER_NST_DEFAULT.\n+         *\/\n+        Integer nstServerCount = GetIntegerAction.privilegedGetProperty(\n+            \"jdk.tls.server.newSessionTicketCount\");\n+        if (nstServerCount == null || nstServerCount < 0 ||\n+            nstServerCount > 10) {\n+            serverNewSessionTicketCount = SERVER_NST_DEFAULT;\n+            if (nstServerCount != null && SSLLogger.isOn &&\n+                SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\n+                    \"jdk.tls.server.newSessionTicketCount defaults to \" +\n+                        SERVER_NST_DEFAULT + \" as the property was not \" +\n+                        \"between 0 and 10\");\n+            }\n+        } else {\n+            serverNewSessionTicketCount = nstServerCount;\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\n+                    \"jdk.tls.server.newSessionTicketCount set to \" +\n+                        serverNewSessionTicketCount);\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -419,5 +419,6 @@\n-        if ((conContext.handshakeContext == null) &&\n-                conContext.protocolVersion.useTLS13PlusSpec() &&\n-                !conContext.isOutboundClosed() &&\n-                !conContext.isInboundClosed() &&\n-                !conContext.isBroken) {\n+        if (SSLConfiguration.serverNewSessionTicketCount > 0 &&\n+            conContext.handshakeContext == null &&\n+            conContext.protocolVersion.useTLS13PlusSpec() &&\n+            !conContext.isOutboundClosed() &&\n+            !conContext.isInboundClosed() &&\n+            !conContext.isBroken) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLEngineImpl.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,1 @@\n+    private static final int DEFAULT_MAX_QUEUE_SIZE = 10;\n@@ -90,2 +91,0 @@\n-        sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n-        sessionHostPortCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n@@ -93,0 +92,2 @@\n+            sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n+            sessionHostPortCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n@@ -95,1 +96,1 @@\n-            \/\/ but doesn't necessarily has to be a true random number.\n+            \/\/ but doesn't necessarily have to be a true random number.\n@@ -98,0 +99,3 @@\n+            sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n+            sessionHostPortCache = Cache.newSoftMemoryQueue(cacheLimit, timeout,\n+                DEFAULT_MAX_QUEUE_SIZE);\n@@ -280,0 +284,10 @@\n+        put(s, false);\n+    }\n+\n+    \/**\n+     * Put an entry in the cache\n+     * @param s SSLSessionImpl entry to be stored\n+     * @param canQueue True if multiple entries may exist under one\n+     *                 session entry.\n+     *\/\n+    void put(SSLSessionImpl s, boolean canQueue) {\n@@ -285,1 +299,1 @@\n-                getKey(s.getPeerHost(), s.getPeerPort()), s);\n+                getKey(s.getPeerHost(), s.getPeerPort()), s, canQueue);\n@@ -293,0 +307,3 @@\n+        remove(key, false);\n+    }\n+    void remove(SessionId key, boolean isClient) {\n@@ -296,1 +313,3 @@\n-            sessionHostPortCache.remove(\n+            \/\/ A client keeps the cache entry for queued NST resumption.\n+            if (!isClient) {\n+                sessionHostPortCache.remove(\n@@ -298,0 +317,1 @@\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionContextImpl.java","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.Enumeration;\n@@ -136,1 +135,5 @@\n-    private BigInteger ticketNonceCounter = BigInteger.ONE;\n+    private byte ticketNonceCounter = 1;\n+\n+    \/\/ This boolean is true when a new set of NewSessionTickets are needed after\n+    \/\/ the initial ones sent after the handshake.\n+    boolean updateNST = false;\n@@ -474,1 +477,6 @@\n-                this.pskIdentity = Record.getBytes8(buf);\n+                i = Record.getInt8(buf);\n+                if (i > 0) {\n+                    this.pskIdentity = Record.getBytes8(buf);\n+                } else {\n+                    this.pskIdentity = null;\n+                }\n@@ -688,4 +696,2 @@\n-    BigInteger incrTicketNonceCounter() {\n-        BigInteger result = ticketNonceCounter;\n-        ticketNonceCounter = ticketNonceCounter.add(BigInteger.ONE);\n-        return result;\n+    byte[] incrTicketNonceCounter() {\n+        return new byte[] {ticketNonceCounter++};\n@@ -695,1 +701,1 @@\n-        return (ticketNonceCounter.compareTo(BigInteger.ZERO) > 0);\n+        return (ticketNonceCounter > 0);\n@@ -754,0 +760,4 @@\n+    public boolean isPSK() {\n+        return (pskIdentity != null && pskIdentity.length > 0);\n+    }\n+\n@@ -1206,1 +1216,0 @@\n-    boolean updateNST;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1322,1 +1322,0 @@\n-                conContext.conSession.updateNST = false;\n@@ -1558,6 +1557,7 @@\n-        if (!conContext.sslConfig.isClientMode &&\n-                conContext.protocolVersion.useTLS13PlusSpec() &&\n-                conContext.handshakeContext == null &&\n-                !conContext.isOutboundClosed() &&\n-                !conContext.isInboundClosed() &&\n-                !conContext.isBroken) {\n+        if (SSLConfiguration.serverNewSessionTicketCount > 0 &&\n+            !conContext.sslConfig.isClientMode &&\n+            conContext.protocolVersion.useTLS13PlusSpec() &&\n+            conContext.handshakeContext == null &&\n+            !conContext.isOutboundClosed() &&\n+            !conContext.isInboundClosed() &&\n+            !conContext.isBroken) {\n@@ -1567,0 +1567,1 @@\n+            conContext.conSession.updateNST = false;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketImpl.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import javax.net.ssl.SSLSession;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n@@ -29,1 +32,2 @@\n-import java.lang.ref.*;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -93,0 +97,9 @@\n+    \/**\n+     * Add V to the cache with the option to use a QueueCacheEntry if the\n+     * cache is configured for it.  If the cache is not configured for a queue,\n+     * V will silently add the entry directly.\n+     *\/\n+    public void put(K key, V value, boolean canQueue) {\n+        put(key, value);\n+    }\n+\n@@ -140,0 +153,5 @@\n+    public static <K,V> Cache<K,V> newSoftMemoryQueue(int size, int timeout,\n+        int maxQueueSize) {\n+        return new MemoryCache<>(true, size, timeout, maxQueueSize);\n+    }\n+\n@@ -251,3 +269,1 @@\n-    private static final float LOAD_FACTOR = 0.75f;\n-\n-    \/\/ XXXX\n+    \/\/ Debugging\n@@ -258,0 +274,1 @@\n+    final private int maxQueueSize;\n@@ -266,1 +283,1 @@\n-        this(soft, maxSize, 0);\n+        this(soft, maxSize, 0, 0);\n@@ -270,0 +287,4 @@\n+        this(soft, maxSize, lifetime, 0);\n+    }\n+\n+    public MemoryCache(boolean soft, int maxSize, int lifetime, int qSize) {\n@@ -271,0 +292,1 @@\n+        this.maxQueueSize = qSize;\n@@ -272,1 +294,1 @@\n-        if (soft)\n+        if (soft) {\n@@ -274,1 +296,1 @@\n-        else\n+        } else {\n@@ -276,2 +298,4 @@\n-\n-        cacheMap = new LinkedHashMap<>(1, LOAD_FACTOR, true);\n+        }\n+        \/\/ LinkedHashMap is needed for its access order.  0.75f load factor is\n+        \/\/ default.\n+        cacheMap = new LinkedHashMap<>(1, 0.75f, true);\n@@ -341,0 +365,4 @@\n+                \/\/ If this is a queue, check for some expired entries\n+                if (entry instanceof QueueCacheEntry<K,V> qe) {\n+                    qe.getQueue().removeIf(e -> !e.isValid(time));\n+                }\n@@ -370,1 +398,20 @@\n-    public synchronized void put(K key, V value) {\n+    public void put(K key, V value) {\n+        put(key, value, false);\n+    }\n+\n+    \/**\n+     * This puts an entry into the cacheMap.\n+     *\n+     * If canQueue is true, V will be added using a QueueCacheEntry which\n+     * is added to cacheMap.  If false, V is added to the cacheMap directly.\n+     * The caller must keep a consistent canQueue value, mixing them can\n+     * result in a queue being replaced with a single entry.\n+     *\n+     * This method is synchronized to avoid multiple QueueCacheEntry\n+     * overwriting the same key.\n+     *\n+     * @param key key to the cacheMap\n+     * @param value value to be stored\n+     * @param canQueue can the value be put into a QueueCacheEntry\n+     *\/\n+    public synchronized void put(K key, V value, boolean canQueue) {\n@@ -372,2 +419,2 @@\n-        long expirationTime = (lifetime == 0) ? 0 :\n-                                        System.currentTimeMillis() + lifetime;\n+        long expirationTime =\n+            (lifetime == 0) ? 0 : System.currentTimeMillis() + lifetime;\n@@ -378,4 +425,27 @@\n-        CacheEntry<K,V> oldEntry = cacheMap.put(key, newEntry);\n-        if (oldEntry != null) {\n-            oldEntry.invalidate();\n-            return;\n+        if (maxQueueSize == 0 || !canQueue) {\n+            CacheEntry<K,V> oldEntry = cacheMap.put(key, newEntry);\n+            if (oldEntry != null) {\n+                oldEntry.invalidate();\n+            }\n+        } else {\n+            CacheEntry<K, V> entry = cacheMap.get(key);\n+            switch (entry) {\n+                case QueueCacheEntry<K, V> qe -> {\n+                    qe.putValue(newEntry);\n+                    if (DEBUG) {\n+                        System.out.println(\"QueueCacheEntry= \" + qe);\n+                        final AtomicInteger i = new AtomicInteger(1);\n+                        qe.queue.stream().forEach(e ->\n+                            System.out.println(i.getAndIncrement() + \"= \" + e));\n+                    }\n+                }\n+                case null, default ->\n+                    cacheMap.put(key, new QueueCacheEntry<>(key, newEntry,\n+                        expirationTime, maxQueueSize));\n+            }\n+\n+            if (DEBUG) {\n+                System.out.println(\"Cache entry added: key=\" +\n+                    key.toString() + \", class=\" +\n+                    (entry != null ? entry.getClass().getName() : null));\n+            }\n@@ -404,2 +474,3 @@\n-        long time = (lifetime == 0) ? 0 : System.currentTimeMillis();\n-        if (!entry.isValid(time)) {\n+\n+        if (lifetime > 0 && !entry.isValid(System.currentTimeMillis())) {\n+            cacheMap.remove(key);\n@@ -409,1 +480,0 @@\n-            cacheMap.remove(key);\n@@ -412,0 +482,9 @@\n+\n+        \/\/ If the value is a queue, return a queue entry.\n+        if (entry instanceof QueueCacheEntry<K, V> qe) {\n+            V result = qe.getValue(lifetime);\n+            if (qe.isEmpty()) {\n+                removeImpl(key);\n+            }\n+            return result;\n+        }\n@@ -417,0 +496,4 @@\n+        removeImpl(key);\n+    }\n+\n+    private void removeImpl(Object key) {\n@@ -422,1 +505,0 @@\n-\n@@ -553,3 +635,2 @@\n-    private static class SoftCacheEntry<K,V>\n-            extends SoftReference<V>\n-            implements CacheEntry<K,V> {\n+    private static class SoftCacheEntry<K,V> extends SoftReference<V>\n+        implements CacheEntry<K,V> {\n@@ -592,0 +673,7 @@\n+\n+        @Override\n+        public String toString() {\n+            if (get() instanceof SSLSession se)\n+                return HexFormat.of().formatHex(se.getId());\n+            return super.toString();\n+        }\n@@ -594,1 +682,104 @@\n-}\n+    \/**\n+     * This CacheEntry<K,V> type allows multiple V entries to be stored in\n+     * one key in the cacheMap.\n+     *\n+     * This implementation is need for TLS clients that receive multiple\n+     * PSKs or NewSessionTickets for server resumption.\n+     *\/\n+    private static class QueueCacheEntry<K,V> implements CacheEntry<K,V> {\n+\n+        \/\/ Limit the number of queue entries.\n+        private final int MAXQUEUESIZE;\n+\n+        final boolean DEBUG = false;\n+        private K key;\n+        private long expirationTime;\n+        final Queue<CacheEntry<K,V>> queue = new ConcurrentLinkedQueue<>();\n+\n+        QueueCacheEntry(K key, CacheEntry<K,V> entry, long expirationTime,\n+            int maxSize) {\n+            this.key = key;\n+            this.expirationTime = expirationTime;\n+            this.MAXQUEUESIZE = maxSize;\n+            queue.add(entry);\n+        }\n+\n+        public K getKey() {\n+            return key;\n+        }\n+\n+        public V getValue() {\n+            return getValue(0);\n+        }\n+\n+        public V getValue(long lifetime) {\n+            long time = (lifetime == 0) ? 0 : System.currentTimeMillis();\n+            do {\n+                var entry = queue.poll();\n+                if (entry == null) {\n+                    return null;\n+                }\n+                if (entry.isValid(time)) {\n+                    return entry.getValue();\n+                }\n+                entry.invalidate();\n+            } while (!queue.isEmpty());\n+\n+            return null;\n+        }\n+\n+        public long getExpirationTime() {\n+            return expirationTime;\n+        }\n+\n+        public void setExpirationTime(long time) {\n+            expirationTime = time;\n+        }\n+\n+        public void putValue(CacheEntry<K,V> entry) {\n+            if (DEBUG) {\n+                System.out.println(\"Added to queue (size=\" + queue.size() +\n+                    \"): \" + entry.getKey().toString() + \",  \" + entry);\n+            }\n+            \/\/ Update the cache entry's expiration time to the latest entry.\n+            \/\/ The getValue() calls will remove expired tickets.\n+            expirationTime = entry.getExpirationTime();\n+            \/\/ Limit the number of queue entries, removing the oldest.\n+            if (queue.size() >= MAXQUEUESIZE) {\n+                queue.remove();\n+            }\n+            queue.add(entry);\n+        }\n+\n+        public boolean isValid(long currentTime) {\n+            boolean valid = (currentTime <= expirationTime) && !queue.isEmpty();\n+            if (!valid) {\n+                invalidate();\n+            }\n+            return valid;\n+        }\n+\n+        public boolean isValid() {\n+            return isValid(System.currentTimeMillis());\n+        }\n+\n+        public void invalidate() {\n+            clear();\n+            key = null;\n+            expirationTime = -1;\n+        }\n+\n+        public void clear() {\n+            queue.forEach(CacheEntry::invalidate);\n+            queue.clear();\n+        }\n+\n+        public boolean isEmpty() {\n+            return queue.isEmpty();\n+        }\n+\n+        public Queue<CacheEntry<K,V>> getQueue() {\n+            return queue;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Cache.java","additions":216,"deletions":25,"binary":false,"changes":241,"status":"modified"},{"patch":"@@ -42,1 +42,2 @@\n-        TLSBase.Client client1 = new TLSBase.Client(true, false);\n+        TLSBase.Client client = new TLSBase.Client(true, false);\n+        client.connect();\n@@ -44,2 +45,3 @@\n-        server.getSession(client1).getSessionContext();\n-        server.done();\n+        \/\/ Close must be called to gather all the exceptions thrown\n+        client.close();\n+        server.close();\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSession\/CertMsgCheck.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+        client1.connect();\n@@ -69,0 +70,1 @@\n+        client2.connect();\n@@ -76,1 +78,0 @@\n-        server.done();\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSession\/CheckSessionContext.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -32,1 +33,0 @@\n-import java.util.Arrays;\n@@ -35,0 +35,3 @@\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n@@ -42,1 +45,1 @@\n- * Server.done() must be called or the server will never exit and hang the test.\n+ * Server.close() must be called so the server will exit and end threading.\n@@ -55,1 +58,1 @@\n-    static String pathToStores = \"..\/etc\";\n+    static String pathToStores = \"javax\/net\/ssl\/etc\";\n@@ -60,0 +63,3 @@\n+    static final String TESTROOT =\n+        System.getProperty(\"test.root\", \"..\/..\/..\/..\");\n+\n@@ -64,1 +70,1 @@\n-    String name;\n+    public String name;\n@@ -67,6 +73,4 @@\n-        String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-        String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n+\n+        String keyFilename = TESTROOT +  \"\/\" + pathToStores + \"\/\" + keyStoreFile;\n+        String trustFilename = TESTROOT + \"\/\" + pathToStores + \"\/\" +\n+            trustStoreFile;\n@@ -81,5 +85,4 @@\n-        BufferedReader reader = new BufferedReader(\n-            new InputStreamReader(sock.getInputStream()));\n-        String s = reader.readLine();\n-        System.err.println(\"(read) \" + name + \": \" + s);\n-        return s.getBytes();\n+        BufferedInputStream is = new BufferedInputStream(sock.getInputStream());\n+        byte[] b = is.readNBytes(5);\n+        System.err.println(\"(read) \" + Thread.currentThread().getName() + \": \" + new String(b));\n+        return b;\n@@ -90,5 +93,2 @@\n-        PrintWriter out = new PrintWriter(\n-            new OutputStreamWriter(sock.getOutputStream()));\n-        out.println(new String(data));\n-        out.flush();\n-        System.err.println(\"(write)\" + name + \": \" + new String(data));\n+        sock.getOutputStream().write(data);\n+        System.err.println(\"(write)\" + Thread.currentThread().getName() + \": \" + new String(data));\n@@ -100,1 +100,1 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") +\n+            fis = new FileInputStream(System.getProperty(\"test.root\", \".\/\") +\n@@ -116,1 +116,1 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") +\n+            fis = new FileInputStream(System.getProperty(\"test.root\", \".\/\") +\n@@ -153,0 +153,5 @@\n+        ExecutorService threadPool = Executors.newFixedThreadPool(1,\n+            r -> {\n+                Thread t = Executors.defaultThreadFactory().newThread(r);\n+                return t;\n+            });\n@@ -163,0 +168,1 @@\n+                ssock.setReuseAddress(true);\n@@ -165,0 +171,1 @@\n+                System.out.println(\"Server Port: \" + serverPort);\n@@ -174,11 +181,2 @@\n-                        System.err.println(\"Server ready on port \" +\n-                            serverPort);\n-                        SSLSocket c = (SSLSocket)ssock.accept();\n-                        clientMap.put(c.getPort(), c);\n-                        try {\n-                            write(c, read(c));\n-                        } catch (Exception e) {\n-                            System.out.println(\"Caught \" + e.getMessage());\n-                            e.printStackTrace();\n-                            exceptionList.add(e);\n-                        }\n+                        SSLSocket sock = (SSLSocket)ssock.accept();\n+                        threadPool.submit(new ServerThread(sock));\n@@ -189,0 +187,2 @@\n+                } finally {\n+                    threadPool.close();\n@@ -194,3 +194,2 @@\n-        Server() {\n-            this(new ServerBuilder());\n-        }\n+        class ServerThread extends Thread {\n+            SSLSocket sock;\n@@ -198,42 +197,4 @@\n-        \/**\n-         * @param km - true for an empty key manager\n-         * @param tm - true for an empty trust manager\n-         *\/\n-        Server(boolean km, boolean tm) {\n-            super();\n-            name = \"server\";\n-            try {\n-                sslContext = SSLContext.getInstance(\"TLS\");\n-                sslContext.init(TLSBase.getKeyManager(km),\n-                    TLSBase.getTrustManager(tm), null);\n-                fac = sslContext.getServerSocketFactory();\n-                ssock = (SSLServerSocket) fac.createServerSocket(0);\n-                ssock.setNeedClientAuth(true);\n-                serverPort = ssock.getLocalPort();\n-            } catch (Exception e) {\n-                System.err.println(\"Failure during server initialization\");\n-                e.printStackTrace();\n-            }\n-\n-                \/\/ Thread to allow multiple clients to connect\n-                t = new Thread(() -> {\n-                    try {\n-                        while (true) {\n-                            System.err.println(\"Server ready on port \" +\n-                                serverPort);\n-                            SSLSocket c = (SSLSocket)ssock.accept();\n-                            clientMap.put(c.getPort(), c);\n-                            try {\n-                                write(c, read(c));\n-                            } catch (Exception e) {\n-                                System.out.println(\"Caught \" + e.getMessage());\n-                                e.printStackTrace();\n-                                exceptionList.add(e);\n-                            }\n-                        }\n-                    } catch (Exception ex) {\n-                        System.err.println(\"Server Down\");\n-                        ex.printStackTrace();\n-                    }\n-                });\n-                t.start();\n+            ServerThread(SSLSocket s) {\n+                this.sock = s;\n+                System.err.println(\"ServerThread(\"+sock.getPort()+\")\");\n+                clientMap.put(sock.getPort(), sock);\n@@ -242,17 +203,8 @@\n-        \/\/ Exit test to quit the test.  This must be called at the end of the\n-        \/\/ test or the test will never end.\n-        void done() {\n-            try {\n-                t.join(5000);\n-                ssock.close();\n-            } catch (Exception e) {\n-                System.err.println(e.getMessage());\n-                e.printStackTrace();\n-            }\n-        }\n-\n-        \/\/ Read from the client\n-        byte[] read(Client client) throws Exception {\n-            SSLSocket s = clientMap.get(Integer.valueOf(client.getPort()));\n-            if (s == null) {\n-                System.err.println(\"No socket found, port \" + client.getPort());\n+            public void run() {\n+                try {\n+                    write(sock, read(sock));\n+                } catch (Exception e) {\n+                    System.out.println(\"Caught \" + e.getMessage());\n+                    e.printStackTrace();\n+                    exceptionList.add(e);\n+                }\n@@ -260,1 +212,0 @@\n-            return read(s);\n@@ -263,3 +214,2 @@\n-        \/\/ Write to the client\n-        void write(Client client, byte[] data) throws Exception {\n-            write(clientMap.get(client.getPort()), data);\n+        Server() {\n+            this(new ServerBuilder());\n@@ -268,5 +218,7 @@\n-        \/\/ Server writes to the client, then reads from the client.\n-        \/\/ Return true if the read & write data match, false if not.\n-        boolean writeRead(Client client, String s) throws Exception{\n-            write(client, s.getBytes());\n-            return (Arrays.compare(s.getBytes(), client.read()) == 0);\n+        public SSLSession getSession(Client client) throws Exception {\n+            System.err.println(\"getSession(\"+client.getPort()+\")\");\n+            SSLSocket clientSocket = clientMap.get(client.getPort());\n+            if (clientSocket == null) {\n+                throw new Exception(\"Server can't find client socket\");\n+            }\n+            return clientSocket.getSession();\n@@ -275,4 +227,7 @@\n-        \/\/ Get the SSLSession from the server side socket\n-        SSLSession getSession(Client c) {\n-            SSLSocket s = clientMap.get(Integer.valueOf(c.getPort()));\n-            return s.getSession();\n+        void close(Client client) {\n+            try {\n+                System.err.println(\"close(\"+client.getPort()+\")\");\n+                clientMap.remove(client.getPort()).close();\n+            } catch (Exception e) {\n+                ;\n+            }\n@@ -280,5 +235,7 @@\n-\n-        \/\/ Close client socket\n-        void close(Client c) throws IOException {\n-            SSLSocket s = clientMap.get(Integer.valueOf(c.getPort()));\n-            s.close();\n+        void close() throws InterruptedException {\n+            clientMap.values().stream().forEach(s -> {\n+                try {\n+                    s.close();\n+                } catch (IOException e) {}\n+            });\n+            threadPool.awaitTermination(500, TimeUnit.MILLISECONDS);\n@@ -315,1 +272,1 @@\n-     * Client side will establish a connection from the constructor and wait.\n+     * Client side will establish a SSLContext instance.\n@@ -319,1 +276,1 @@\n-        SSLSocket sock;\n+        public SSLSocket socket;\n@@ -333,5 +290,0 @@\n-            connect();\n-        }\n-\n-        \/\/ Connect to server.  Maybe runnable in the future\n-        public SSLSocket connect() {\n@@ -341,7 +293,1 @@\n-                sock = (SSLSocket)sslContext.getSocketFactory().createSocket();\n-                sock.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), serverPort));\n-                System.err.println(\"Client connected using port \" +\n-                        sock.getLocalPort());\n-                name = \"client(\" + sock.toString() + \")\";\n-                write(\"Hello\");\n-                read();\n+                socket = createSocket();\n@@ -351,1 +297,0 @@\n-            return sock;\n@@ -354,3 +299,3 @@\n-        \/\/ Read from the client socket\n-        byte[] read() throws Exception {\n-            return read(sock);\n+        Client(Client cl) {\n+            sslContext = cl.sslContext;\n+            socket = createSocket();\n@@ -359,3 +304,7 @@\n-        \/\/ Write to the client socket\n-        void write(byte[] data) throws Exception {\n-            write(sock, data);\n+        public SSLSocket createSocket() {\n+            try {\n+                return (SSLSocket) sslContext.getSocketFactory().createSocket();\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n+            return null;\n@@ -363,2 +312,12 @@\n-        void write(String s) throws Exception {\n-            write(sock, s.getBytes());\n+\n+        public SSLSocket connect() {\n+            try {\n+                socket.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), serverPort));\n+                System.err.println(\"Client (\" + Thread.currentThread().getName() + \") connected using port \" +\n+                    socket.getLocalPort() + \" to \" + socket.getPort());\n+                writeRead();\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+                return null;\n+            }\n+            return socket;\n@@ -367,5 +326,9 @@\n-        \/\/ Client writes to the server, then reads from the server.\n-        \/\/ Return true if the read & write data match, false if not.\n-        boolean writeRead(Server server, String s) throws Exception {\n-            write(s.getBytes());\n-            return (Arrays.compare(s.getBytes(), server.read(this)) == 0);\n+        public SSLSession getSession() {\n+            return socket.getSession();\n+        }\n+        public void close() {\n+            try {\n+                socket.close();\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n@@ -374,3 +337,2 @@\n-        \/\/ Get port from the socket\n-        int getPort() {\n-            return sock.getLocalPort();\n+        public int getPort() {\n+            return socket.getLocalPort();\n@@ -379,3 +341,8 @@\n-        \/\/ Close socket\n-        void close() throws IOException {\n-            sock.close();\n+        private SSLSocket writeRead() {\n+            try {\n+                write(socket, \"Hello\".getBytes(StandardCharsets.ISO_8859_1));\n+                read(socket);\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n+            return socket;\n@@ -383,0 +350,1 @@\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/TLSBase.java","additions":115,"deletions":147,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies multiple PSKs are used by JSSE\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=1\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=3\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=10\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=true\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=false -Djdk.tls.client.enableSessionTicketExtension=true\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=false\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=false -Djdk.tls.client.enableSessionTicketExtension=false\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.2 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=true\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.List;\n+\n+\/**\n+ * This test verifies that multiple NSTs and PSKs are sent by a JSSE server.\n+ * Then JSSE client is able to store them all and resume the connection.  It\n+ * requires specific text in the TLS debugging to verify the success.\n+ *\/\n+\n+public class MultiNSTClient {\n+\n+    static HexFormat hex = HexFormat.of();\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            StringBuilder sb = new StringBuilder();\n+            Arrays.stream(args).forEach(a -> {\n+                sb.append(a);\n+                sb.append(\" \");\n+            });\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" + params\n+                );\n+\n+            boolean TLS13 = args[0].contains(\"1.3\");\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTClient\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            System.out.println(\"I'm here\");\n+            boolean pass = true;\n+            try {\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").\n+                    asLines().stream().filter(s ->\n+                        s.contains(\"MultiNST PSK\")).toList();\n+                List<String> serverPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> clientPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Client)\")).toList();\n+                System.out.println(\"found list: \" + list.size());\n+                System.out.println(\"found server: \" + serverPSK.size());\n+                serverPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                System.out.println(\"found client: \" + clientPSK.size());\n+                clientPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                for (int i = 0; i < 2; i++) {\n+                    String svr = serverPSK.getFirst();\n+                    String cli = clientPSK.getFirst();\n+                    if (svr.regionMatches(svr.length() - 16, cli, cli.length() - 16, 16)) {\n+                        System.out.println(\"entry \" + (i + 1) + \" match.\");\n+                    } else {\n+                        System.out.println(\"entry \" + (i + 1) + \" server and client PSK didn't match:\");\n+                        System.out.println(\"  server: \" + svr);\n+                        System.out.println(\"  client: \" + cli);\n+                        pass = false;\n+                    }\n+                }\n+            } catch (RuntimeException e) {\n+                System.out.println(\"No MultiNST PSK found.\");\n+                pass = false;\n+            }\n+\n+            if (TLS13) {\n+                if (!pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            } else {\n+                if (pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            }\n+            System.out.println(\"Test Passed\");\n+            return;\n+        }\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Start connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+        SSLSession initialSession = initial.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(initialSession.getId()));\n+        System.out.println(\"session = \" + initialSession);\n+\n+        System.out.println(\"------  getNewSession from original client\");\n+        TLSBase.Client resumClient = new TLSBase.Client(initial);\n+        SSLSession resumption = resumClient.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(resumption.getId()));\n+        System.out.println(\"session = \" + resumption);\n+        if (!initialSession.toString().equalsIgnoreCase(resumption.toString())) {\n+            throw new Exception(\"Resumed session did not match\");\n+        }\n+\n+        System.out.println(\"------  Second getNewSession from original client\");\n+        TLSBase.Client resumClient2 = new TLSBase.Client(initial);\n+        resumption = resumClient2.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(resumption.getId()));\n+        System.out.println(\"session = \" + resumption);\n+        if (!initialSession.toString().equalsIgnoreCase(resumption.toString())) {\n+            throw new Exception(\"Resumed session did not match\");\n+        }\n+\n+        System.out.println(\"------  New client connection\");\n+        TLSBase.Client newConnection = new TLSBase.Client();\n+        SSLSession newSession = newConnection.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(newSession.getId()));\n+        System.out.println(\"session = \" + newSession);\n+        if (initialSession.toString().equalsIgnoreCase(newSession.toString())) {\n+            throw new Exception(\"new session is the same as the initial.\");\n+        }\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        resumClient.close();\n+        resumClient2.close();\n+        newConnection.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTClient.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies resumption fails with 0 NSTs and session creation off\n+ * @run main\/othervm MultiNSTNoSessionCreation -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=0\n+ * @run main\/othervm MultiNSTNoSessionCreation -Djdk.tls.client.protocols=TLSv1.2 -Djdk.tls.server.newSessionTicketCount=0\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.Arrays;\n+\n+\/**\n+ * With no NSTs sent by the server, try to resume the session with\n+ * setEnabledSessionCreation(false).  The test should get an exception and\n+ * fail to connect.\n+ *\/\n+\n+public class MultiNSTNoSessionCreation {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            StringBuilder sb = new StringBuilder();\n+            Arrays.stream(args).forEach(a -> sb.append(a).append(\" \"));\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" + params);\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTNoSessionCreation\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            try {\n+                if (output.stderrContains(\n+                    \"(PROTOCOL_VERSION): New session creation is disabled\")) {\n+                    return;\n+                }\n+            } catch (RuntimeException e) {\n+                throw new Exception(\"Error collecting data\", e);\n+            }\n+            throw new Exception(\"Disabled creation msg not found\");\n+        }\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Initial connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+        initial.connect();\n+        System.out.println(\n+            \"------  Resume client w\/ setEnableSessionCreation set to false\");\n+        TLSBase.Client resumClient = new TLSBase.Client(initial);\n+        resumClient.socket.setEnableSessionCreation(false);\n+        resumClient.connect();\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        resumClient.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTNoSessionCreation.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies multiple PSKs are used by TLSv1.3\n+ * @run main\/othervm MultiNSTParallel 10 -Djdk.tls.client.protocols=TLSv1.3\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.ArrayList;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * This test verifies that parallel resumption connections successfully get\n+ * a PSK entry and not initiate a full handshake.\n+ *\n+ * Note:  THe first argument after 'MultiNSTParallel' is the ticket count\n+ * The test will set 'jdk.tls.server.NewSessionTicketCount` to that number and\n+ * will start the same number of resumption client attempts. The ticket count\n+ * must be the same or larger than resumption attempts otherwise the queue runs\n+ * empty and the test will fail.\n+ *\n+ * Because this test runs parallel connections, the thread order finish is not\n+ * guaranteed.  Each client NST id is checked with all server NSTs ids until\n+ * a match is found.  When a match is found, it is removed from the list to\n+ * verify no NST was used more than once.\n+ *\n+ * TLS 1.2 spec does not specify multiple NST behavior.\n+ *\/\n+\n+public class MultiNSTParallel {\n+\n+    static HexFormat hex = HexFormat.of();\n+    final static CountDownLatch wait = new CountDownLatch(1);\n+\n+    static class ClientThread extends Thread {\n+        TLSBase.Client client;\n+\n+        ClientThread(TLSBase.Client c) {\n+            client = c;\n+        }\n+\n+        public void run() {\n+            String name = Thread.currentThread().getName();\n+            SSLSession r;\n+            System.err.println(\"waiting \" + Thread.currentThread().getName());\n+            try {\n+                wait.await();\n+                r = new TLSBase.Client(client).connect().getSession();\n+            } catch (Exception e) {\n+                throw new RuntimeException(name + \": \" +e);\n+            }\n+            StringBuffer sb = new StringBuffer(100);\n+            sb.append(\"(\").append(name).append(\") id = \");\n+            sb.append(hex.formatHex(r.getId()));\n+            sb.append(\"\\n(\").append(name).append(\") session = \").append(r);\n+            if (!client.getSession().toString().equalsIgnoreCase(r.toString())) {\n+                throw new RuntimeException(\"(\" + name +\n+                    \") Resumed session did not match\");\n+            }\n+        }\n+    }\n+\n+    static boolean pass = true;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            int ticketCount = Integer.parseInt(args[0]);\n+            StringBuilder sb = new StringBuilder();\n+            for (int i = 1; i < args.length; i++) {\n+                sb.append(\" \").append(args[i]);\n+            }\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" +\n+                    \" -Djdk.tls.server.newSessionTicketCount=\" + ticketCount +\n+                    params);\n+\n+            boolean TLS13 = args[1].contains(\"1.3\");\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTParallel\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            try {\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").\n+                    asLines().stream().filter(s ->\n+                        s.contains(\"MultiNST PSK\")).toList();\n+                List<String> sp = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> serverPSK = new ArrayList<>(sp.stream().toList());\n+                List<String> clientPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Client)\")).toList();\n+                System.out.println(\"found list: \" + list.size());\n+                System.out.println(\"found server: \" + serverPSK.size());\n+                serverPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                System.out.println(\"found client: \" + clientPSK.size());\n+                clientPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+\n+                \/\/ Must search all results as order is not guaranteed.\n+                clientPSK.stream().forEach(cli -> {\n+                    for (int i = 0; i < serverPSK.size(); i++) {\n+                        String svr = serverPSK.get(i);\n+                        if (svr.regionMatches(svr.length() - 16, cli,\n+                            cli.length() - 16, 16)) {\n+                            System.out.println(\"entry \" + (i + 1) + \" match.\");\n+                            serverPSK.remove(i);\n+                            return;\n+                        }\n+                    }\n+                    System.out.println(\"client entry (\" + cli.substring(0, 16) +\n+                        \") not found in server list\");\n+                    pass = false;\n+                });\n+            } catch (RuntimeException e) {\n+                System.out.println(\"Error looking at PSK results.\");\n+                throw new Exception(e);\n+            }\n+\n+            if (TLS13) {\n+                if (!pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            } else {\n+                if (pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            }\n+            System.out.println(\"Test Passed\");\n+            return;\n+        }\n+\n+        int ticketCount = Integer.parseInt(\n+            System.getProperty(\"jdk.tls.server.newSessionTicketCount\"));\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Start connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+        SSLSession initialSession = initial.getSession();\n+        System.out.println(\"id = \" + hex.formatHex(initialSession.getId()));\n+        System.out.println(\"session = \" + initialSession);\n+\n+        System.out.println(\"------  getNewSession from original client\");\n+\n+        ArrayList<Thread> slist = new ArrayList<>(ticketCount);\n+\n+        System.out.println(\"tx \" + ticketCount);\n+        for (int i = 0; ticketCount > i; i++) {\n+            Thread t = new ClientThread(initial);\n+            t.setName(\"Iteration \" + i);\n+            slist.add(t);\n+            t.start();\n+        }\n+\n+        wait.countDown();\n+        for (Thread t : slist) {\n+            t.join(1000);\n+            System.err.println(\"released: \" + t.getName());\n+        }\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTParallel.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies sequence of used NST entries from the cache queue.\n+ * @run main\/othervm MultiNSTSequence -Djdk.tls.server.newSessionTicketCount=2\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.List;\n+\n+\/**\n+ * This test verifies that multiple NSTs take the oldest PSK from the\n+ * QueueCacheEntry stored in the TLS Session Cache.\n+ *\n+ * Note: Beyond 9 iterations the PSK id verification code becomes complicated\n+ * with a QueueCacheEntry limit set to retain only the 10 newest entries.\n+ *\n+ * TLS 1.2 spec does not specify multiple NST behavior.\n+ *\/\n+\n+public class MultiNSTSequence {\n+\n+    static HexFormat hex = HexFormat.of();\n+    static final int ITERATIONS = 9;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            StringBuilder sb = new StringBuilder();\n+            Arrays.stream(args).forEach(a -> sb.append(a).append(\" \"));\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" + params\n+                              );\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTSequence\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            boolean pass = true;\n+            try {\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").\n+                    asLines().stream().filter(s ->\n+                        s.contains(\"MultiNST PSK\")).toList();\n+                List<String> serverPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> clientPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Client)\")).toList();\n+                System.out.println(\"found list: \" + list.size());\n+                System.out.println(\"found server: \" + serverPSK.size());\n+                serverPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                System.out.println(\"found client: \" + clientPSK.size());\n+                clientPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                int i;\n+                for (i = 0; i < ITERATIONS; i++) {\n+                    String svr = serverPSK.get(i);\n+                    String cli = clientPSK.get(i);\n+                    if (svr.regionMatches(svr.length() - 16, cli, cli.length() - 16, 16)) {\n+                        System.out.println(\"entry \" + (i + 1) + \" match.\");\n+                    } else {\n+                        System.out.println(\"entry \" + (i + 1) + \" server and client PSK didn't match:\");\n+                        System.out.println(\"  server: \" + svr);\n+                        System.out.println(\"  client: \" + cli);\n+                        pass = false;\n+                    }\n+                }\n+            } catch (RuntimeException e) {\n+                System.out.println(\"Server and Client PSK usage order is not\" +\n+                    \" the same.\");\n+                pass = false;\n+            }\n+\n+            if (!pass) {\n+                throw new Exception(\"Test failed: \" + params);\n+            }\n+            System.out.println(\"Test Passed\");\n+            return;\n+        }\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Initial connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+\n+        SSLSession initialSession = initial.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(initialSession.getId()));\n+        System.out.println(\"session = \" + initialSession);\n+\n+        System.out.println(\"------  Resume client\");\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            SSLSession r = new TLSBase.Client(initial).connect().getSession();\n+            StringBuilder sb = new StringBuilder(100);\n+            sb.append(\"Iteration: \").append(i);\n+            sb.append(\"\\tid = \").append(hex.formatHex(r.getId()));\n+            sb.append(\"\\tsession = \").append(r);\n+            System.out.println(sb);\n+            if (!initialSession.toString().equalsIgnoreCase(r.toString())) {\n+                throw new Exception(\"Resumed session did not match\");\n+            }\n+        }\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTSequence.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -227,0 +227,14 @@\n+    \/**\n+     * Returns true if stderr contains the given string\n+     *\/\n+    public boolean stderrContains(String expectedString) {\n+        return getStderr().contains(expectedString);\n+    }\n+\n+    \/**\n+     * Returns true if either stdout or stderr contains the given string\n+     *\/\n+    public boolean contains(String expectedString) {\n+        return stdoutContains(expectedString) || stderrContains(expectedString);\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/process\/OutputAnalyzer.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"}]}