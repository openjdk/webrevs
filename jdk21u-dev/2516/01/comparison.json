{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -359,0 +359,4 @@\n+        byte coder = this.coder;\n+        byte[] value = this.value;\n+        \/\/ Ensure count is less than or equal to capacity (racy reads and writes can produce inconsistent values)\n+        int count = Math.min(this.count, value.length >> coder);\n@@ -360,1 +364,1 @@\n-        if (isLatin1()) {\n+        if (coder == LATIN1) {\n@@ -419,0 +423,1 @@\n+        byte[] value = this.value;\n@@ -1723,1 +1728,1 @@\n-                    StringUTF16.putChar(this.value, j++, c);\n+                    StringUTF16.putCharSB(this.value, j++, c);\n@@ -1813,1 +1818,1 @@\n-                    StringUTF16.putChar(this.value, j++, c);\n+                    StringUTF16.putCharSB(this.value, j++, c);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,303 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test multi-threaded use of StringBuilder\n+ * @compile --release 8 RacingSBThreads.java\n+ * @run main\/othervm -esa RacingSBThreads read\n+ * @run main\/othervm -esa RacingSBThreads insert\n+ * @run main\/othervm -esa RacingSBThreads append\n+ * @run main\/othervm -Xcomp RacingSBThreads\n+ *\/\n+\n+import java.nio.CharBuffer;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.Locale;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiConsumer;\n+\n+\/**\n+ * Test racing accesses in StringBuilder.\n+ * Test source code should be compatible with JDK 8 to allow testing on older versions.\n+ *\/\n+public class RacingSBThreads {\n+\n+    private static final int TIMEOUT_SEC = 1;   \/\/ Duration to run each test case\n+    private static final int N = 10_000_000;    \/\/ static number of iterations for writes and modifies\n+    private static final int LEN = 100_000;     \/\/ Length of initial SB\n+\n+    \/\/ Strings available to be used as the initial contents of a StringBuilder\n+    private static final String UTF16_CHARS = initString('\\u1000', LEN);\n+    private static final String LATIN1_CHARS = initString('a', LEN);\n+\n+    \/\/ Cache jtreg timeout factor to allow test to be run as a standalone main()\n+    private static final double TIMEOUT_FACTOR = Double.parseDouble(System.getProperty(\"test.timeout.factor\", \"1.0\"));\n+\n+    \/\/ Constant arguments available to be passed to StringBuilder operations\n+    private static final StringBuilder otherSB = new StringBuilder(\"ab\\uFF21\\uFF22\");\n+    private static final StringBuilder otherLongerSB = new StringBuilder(\"abcde\\uFF21\\uFF22\\uFF23\\uFF24\\uFF25\");\n+\n+    \/\/ Create a String with a repeated character\n+    private static String initString(char c, int len) {\n+        char[] chars = new char[len];\n+        Arrays.fill(chars, c);\n+        return new String(chars);\n+    }\n+\n+    \/\/ Plain unsynchronized reference to a StringBuilder\n+    \/\/ Updated by the writer thread\n+    \/\/ Read by the reader thread\n+    private StringBuilder buf;\n+\n+    \/\/ The current stress test case\n+    private final StressKind stressKind;\n+\n+    \/\/ Count of faults, zero if no faults found\n+    private final AtomicInteger faultCount = new AtomicInteger(0);\n+\n+    \/**\n+     * Run the stress cases indicated by command line arguments or run all cases.\n+     * Running each for TIMEOUT_SEC seconds or until a failure.\n+     * The timeout\/test duration can be scaled by setting System property\n+     * `test.timeout.factor` to a double value, for example, `-Dtest.timeout.factor=2.0`\n+     * @param args command line arguments\n+     *\/\n+    public static void main(String[] args) {\n+        Duration duration = Duration.ofSeconds((long)(TIMEOUT_SEC * TIMEOUT_FACTOR));\n+\n+        StressKind[] kinds = StressKind.values();\n+        if (args.length > 0) {\n+            \/\/ Parse explicitly supplied StressKind arguments\n+            try {\n+                 kinds = Arrays.stream(args)\n+                         .map((s) -> StressKind.valueOf(s.toUpperCase(Locale.ROOT)))\n+                         .toArray(StressKind[]::new);\n+            } catch (Exception ex) {\n+                System.out.println(\"Invalid StressKind arguments: \" + Arrays.toString(args));\n+                return;\n+            }\n+        }\n+\n+        \/\/ Run each kind for the duration\n+        int totalFaults = 0;\n+        for (StressKind sk : kinds) {\n+            Instant end = Instant.now().plus(duration); \/\/ note clock time, not runtime\n+            while (Instant.now().isBefore(end)) {\n+                int faultCount = new RacingSBThreads(sk).stress();\n+                if (faultCount > 0) {\n+                    System.out.printf(\"ERROR: Test case %s, %d faults%n\", sk, faultCount);\n+                }\n+                totalFaults += faultCount;\n+            }\n+        }\n+        if (totalFaults > 0) {\n+            throw new AssertionError(\"Total faults: \" + totalFaults);\n+        }\n+    }\n+\n+    \/\/ Enum of the various test cases with a lambda to invoke for each\n+    enum StressKind {\n+        \/**\n+         * Reading characters should always be one of the known values being written to the destination\n+         *\/\n+        READ(LATIN1_CHARS, (sb,  chr) -> {\n+            char ch = sb.charAt(LEN * 4 \/ 5);\n+            if (ch != chr & ch != (chr & 0xff) & ch != chr >> 8) {\n+                throw new AssertionError(\"Unexpected characters in buffer: 0x\" + Integer.toHexString(ch));\n+            }\n+        }),\n+        \/**\n+         * Insert another StringBuilder; in the face of racy changes to the destination\n+         *\/\n+        INSERT(LATIN1_CHARS, (sb, C) -> {\n+            sb.insert(sb.length() - 1, otherLongerSB, 0, otherLongerSB.length());\n+        }),\n+        \/**\n+         * Appending a StringBuilder in the face of racy changes to the destination\n+         *\/\n+        APPEND(LATIN1_CHARS, (sb, C) -> {\n+            sb.append(otherSB, 0, otherSB.length());\n+        }),\n+        ;\n+\n+        private final BiConsumer<StringBuilder,Character> func;\n+        private final String sbInitString;\n+\n+        \/**\n+         * Defines a test case.\n+         * @param sbInitString the initial contents of the StringBuilder; chooses the coder\n+         * @param func the test BiConsumer to apply to the StringBuilder\n+         *\/\n+        private StressKind(String sbInitString, BiConsumer<StringBuilder,Character> func) {\n+            this.func = func;\n+            this.sbInitString = sbInitString;\n+        }\n+    }\n+\n+    public RacingSBThreads(StressKind stressKind) {\n+        this.stressKind = stressKind;\n+    }\n+\n+    \/**\n+     * Run the stress case.\n+     * One thread continuously creates a StringBuilder and fills it before trimming it to zero.\n+     * The other thread performs the test case on the same StringBuilder (without any synchronization)\n+     * @return the count of faults\n+     *\/\n+    private int stress() {\n+        PokeBuilder r = new PokeBuilder(this, N);\n+        Writer w = new Writer(this, N);\n+\n+        Thread writer = new Thread(w::createShrink);\n+        Thread reader = new Thread(r::readModify);\n+        writer.start();\n+        reader.start();\n+        join(reader);\n+        System.out.println(r);\n+        writer.interrupt();\n+        join(writer);\n+        System.out.println(w);\n+        return r.racing.faultCount.get();\n+    }\n+\n+    \/**\n+     * Wait for a thread to terminate.\n+     * @param thread a thread to wait for\n+     *\/\n+    private void join(Thread thread) {\n+        do {\n+            try {\n+                thread.join();\n+                break;\n+            } catch (InterruptedException ie) {\n+                \/\/ ignore and retry\n+            }\n+        } while (true);\n+    }\n+\n+    \/**\n+     * Run a StressKind case in a loop keeping track of exceptions.\n+     * The StringBuilder under test is shared with the writer task without benefit of synchronization.\n+     *\/\n+    private static class PokeBuilder {\n+        private final RacingSBThreads racing;\n+        private final int iterations;\n+        private int nulls;\n+        private int bounds;\n+        private int pokeCycles;\n+        private int bufChanges;\n+\n+        public PokeBuilder(RacingSBThreads racing, int iterations) {\n+            this.racing = racing;\n+            this.iterations = iterations;\n+            nulls = 0;\n+            bounds = 0;\n+            pokeCycles = 0;\n+            bufChanges = 0;\n+        }\n+\n+        \/\/ Repeatedly change the racy StringBuilder, ignoring and counting exceptions\n+        private void readModify() {\n+            System.out.println(\"Starting \" + racing.stressKind);\n+            sleep(100);\n+            for (int i = 0; i < iterations; ++i) {\n+                pokeCycles++;\n+                StringBuilder sb = racing.buf;  \/\/ read once\n+                try {\n+                    if (sb.length() > Integer.MAX_VALUE \/ 4) {\n+                        sb.setLength(Integer.MAX_VALUE \/ 4);\n+                    }\n+                    \/\/ Invoke the test case\n+                    racing.stressKind.func.accept(sb, racing.stressKind.sbInitString.charAt(0));\n+                    if (sb != racing.buf) {\n+                        bufChanges++;\n+                    }\n+                } catch (NullPointerException e) {\n+                    ++nulls;\n+                } catch (IndexOutOfBoundsException e) {\n+                    ++bounds;\n+                } catch (AssertionError ae) {\n+                    racing.faultCount.incrementAndGet();\n+                    throw ae;\n+                }\n+            }\n+        }\n+\n+        private static void sleep(int i) {\n+            try {\n+                Thread.sleep(i);\n+            } catch (InterruptedException ignored) {\n+            }\n+        }\n+\n+        public String toString() {\n+            return String.format(\"pokeCycles:%d, bounds:%d, bufChanges:%d, nulls=%d\",\n+                    pokeCycles, bounds, bufChanges, nulls);\n+        }\n+    }\n+\n+    \/**\n+     * Repeatedly create and append strings to a StringBuilder shared through fields of RacingSBThreads.\n+     * The StringBuilder is created new on each iteration and truncated at the end of each iteration.\n+     * Exceptions are counted and reported.\n+     *\/\n+    private static class Writer {\n+        private final RacingSBThreads racing;\n+        private final int iterations;\n+        private int sumWriter;\n+        private int writeCycles;\n+        private int putBounds;\n+\n+        public Writer(RacingSBThreads racing, int iterations) {\n+            this.racing = racing;\n+            this.iterations = iterations;\n+        }\n+\n+        private void createShrink() {\n+            for (int i = 0; i < iterations; ++i) {\n+                if (i % 100_000 == 0) {\n+                    if (Thread.interrupted()) {\n+                        break;\n+                    }\n+                }\n+                try {\n+                    ++writeCycles;\n+                    racing.buf = new StringBuilder(racing.stressKind.sbInitString);\n+                    racing.buf.append(UTF16_CHARS);\n+                    sumWriter += racing.buf.length();\n+                    racing.buf.setLength(0);\n+                    racing.buf.trimToSize();\n+                } catch (Exception ex) {\n+                    ++putBounds;\n+                }\n+            }\n+        }\n+\n+        public String toString() {\n+            return String.format(\"writeCycles:%d, bounds:%d, sumWriter=%d\", writeCycles, putBounds, sumWriter);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/StringBuilder\/RacingSBThreads.java","additions":303,"deletions":0,"binary":false,"changes":303,"status":"added"}]}