{"files":[{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"oops\/symbolHandle.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+Symbol* volatile TempSymbolCleanupDelayer::_queue[QueueSize] = {};\n+volatile uint TempSymbolCleanupDelayer::_index = 0;\n+\n+\/\/ Keep this symbol alive for some time to allow for reuse.\n+\/\/ Temp symbols for the same string can often be created in quick succession,\n+\/\/ and this queue allows them to be reused instead of churning.\n+void TempSymbolCleanupDelayer::delay_cleanup(Symbol* sym) {\n+  assert(sym != nullptr, \"precondition\");\n+  sym->increment_refcount();\n+  uint i = Atomic::add(&_index, 1u) % QueueSize;\n+  Symbol* old = Atomic::xchg(&_queue[i], sym);\n+  Symbol::maybe_decrement_refcount(old);\n+}\n+\n+void TempSymbolCleanupDelayer::drain_queue() {\n+  for (uint i = 0; i < QueueSize; i++) {\n+    Symbol* sym = Atomic::xchg(&_queue[i], (Symbol*) nullptr);\n+    Symbol::maybe_decrement_refcount(sym);\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/symbolHandle.cpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -31,0 +31,10 @@\n+class TempSymbolCleanupDelayer : AllStatic {\n+  static Symbol* volatile _queue[];\n+  static volatile uint _index;\n+\n+public:\n+  static const uint QueueSize = 128;\n+  static void delay_cleanup(Symbol* s);\n+  static void drain_queue();\n+};\n+\n@@ -52,1 +62,0 @@\n-  \/\/ Does not increment the current reference count if temporary.\n@@ -56,0 +65,8 @@\n+      return;\n+    }\n+\n+    \/\/ Delay cleanup for temp symbols. Refcount is incremented while in\n+    \/\/ queue. But don't requeue existing entries, or entries that are held\n+    \/\/ elsewhere - it's a waste of effort.\n+    if (s != nullptr && s->refcount() == 1) {\n+      TempSymbolCleanupDelayer::delay_cleanup(s);\n","filename":"src\/hotspot\/share\/oops\/symbolHandle.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-  TempNewSymbol A = SymbolTable::new_symbol(\"abc2_8_2023_class\");\n-  TempNewSymbol D = SymbolTable::new_symbol(\"def2_8_2023_class\");\n+  Symbol* A = SymbolTable::new_symbol(\"abc2_8_2023_class\");\n+  Symbol* D = SymbolTable::new_symbol(\"def2_8_2023_class\");\n@@ -45,1 +45,1 @@\n-  TempNewSymbol interf = SymbolTable::new_symbol(\"interface2_8_2023_supername\");\n+  Symbol* interf = SymbolTable::new_symbol(\"interface2_8_2023_supername\");\n@@ -113,0 +113,5 @@\n+\n+  \/\/ clean up temporary symbols\n+  A->decrement_refcount();\n+  D->decrement_refcount();\n+  interf->decrement_refcount();\n","filename":"test\/hotspot\/gtest\/classfile\/test_placeholders.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,0 +30,8 @@\n+\/\/ Helper to avoid interference from the cleanup delay queue by draining it\n+\/\/ immediately after creation.\n+TempNewSymbol stable_temp_symbol(Symbol* sym) {\n+  TempNewSymbol t = sym;\n+  TempSymbolCleanupDelayer::drain_queue();\n+  return t;\n+}\n+\n@@ -39,1 +47,1 @@\n-  TempNewSymbol ss = abc;\n+  TempNewSymbol ss = stable_temp_symbol(abc);\n@@ -48,2 +56,2 @@\n-  TempNewSymbol s1 = efg;\n-  TempNewSymbol s2 = hij;\n+  TempNewSymbol s1 = stable_temp_symbol(efg);\n+  TempNewSymbol s2 = stable_temp_symbol(hij);\n@@ -68,1 +76,1 @@\n-  s3 = klm; \/\/ assignment\n+  s3 = stable_temp_symbol(klm); \/\/ assignment\n@@ -74,1 +82,1 @@\n-    TempNewSymbol s_inner = xyz;\n+    TempNewSymbol s_inner = stable_temp_symbol(xyz);\n@@ -142,0 +150,47 @@\n+\n+TEST_VM(SymbolTable, test_cleanup_delay) {\n+  \/\/ Check that new temp symbols have an extra refcount increment, which is then\n+  \/\/ decremented when the queue spills over.\n+\n+  TempNewSymbol s1 = SymbolTable::new_symbol(\"temp-s1\");\n+  ASSERT_EQ(s1->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n+\n+  \/\/ Fill up the queue\n+  constexpr int symbol_name_length = 30;\n+  char symbol_name[symbol_name_length];\n+  for (uint i = 1; i < TempSymbolCleanupDelayer::QueueSize; i++) {\n+    os::snprintf(symbol_name, symbol_name_length, \"temp-filler-%d\", i);\n+    TempNewSymbol s = SymbolTable::new_symbol(symbol_name);\n+    ASSERT_EQ(s->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n+  }\n+\n+  \/\/ Add one more\n+  TempNewSymbol spillover = SymbolTable::new_symbol(\"temp-spillover\");\n+  ASSERT_EQ(spillover->refcount(), 2) << \"TempNewSymbol refcount just created is 2\";\n+\n+  \/\/ The first symbol should have been removed from the queue and decremented\n+  ASSERT_EQ(s1->refcount(), 1) << \"TempNewSymbol off queue refcount is 1\";\n+}\n+\n+TEST_VM(SymbolTable, test_cleanup_delay_drain) {\n+  \/\/ Fill up the queue\n+  constexpr int symbol_name_length = 30;\n+  char symbol_name[symbol_name_length];\n+  TempNewSymbol symbols[TempSymbolCleanupDelayer::QueueSize] = {};\n+  for (uint i = 0; i < TempSymbolCleanupDelayer::QueueSize; i++) {\n+    os::snprintf(symbol_name, symbol_name_length, \"temp-%d\", i);\n+    TempNewSymbol s = SymbolTable::new_symbol(symbol_name);\n+    symbols[i] = s;\n+  }\n+\n+  \/\/ While in the queue refcounts are incremented\n+  for (uint i = 0; i < TempSymbolCleanupDelayer::QueueSize; i++) {\n+    ASSERT_EQ(symbols[i]->refcount(), 2) << \"TempNewSymbol refcount in queue is 2\";\n+  }\n+\n+  \/\/ Draining the queue should decrement the refcounts\n+  TempSymbolCleanupDelayer::drain_queue();\n+  for (uint i = 0; i < TempSymbolCleanupDelayer::QueueSize; i++) {\n+    ASSERT_EQ(symbols[i]->refcount(), 1) << \"TempNewSymbol refcount after drain is 1\";\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/classfile\/test_symbolTable.cpp","additions":60,"deletions":5,"binary":false,"changes":65,"status":"modified"}]}