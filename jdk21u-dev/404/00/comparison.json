{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -691,4 +691,0 @@\n-        if (dstImpl == srcImpl) {\n-            srcImpl.checkValidState();\n-            return -1;\n-        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- *  Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n@@ -27,0 +27,1 @@\n+ * @bug 8323552\n@@ -48,1 +49,1 @@\n-    \/\/ stores a increasing sequence of values into the memory of the given segment\n+    \/\/ stores an increasing sequence of values into the memory of the given segment\n@@ -282,0 +283,26 @@\n+    @Test\n+    public void testSameSegment() {\n+        var segment = MemorySegment.ofArray(new byte[]{\n+                1,2,3,4,  1,2,3,4,  1,4});\n+\n+        long match = MemorySegment.mismatch(\n+                segment, 0L, 4L,\n+                segment, 4L, 8L);\n+        assertEquals(match, -1);\n+\n+        long noMatch = MemorySegment.mismatch(\n+                segment, 0L, 4L,\n+                segment, 1L, 5L);\n+        assertEquals(noMatch, 0);\n+\n+        long noMatchEnd = MemorySegment.mismatch(\n+                segment, 0L, 2L,\n+                segment, 8L, 10L);\n+        assertEquals(noMatchEnd, 1);\n+\n+        long same = MemorySegment.mismatch(\n+                segment, 0L, 8L,\n+                segment, 0L, 8L);\n+        assertEquals(same, -1);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"}]}