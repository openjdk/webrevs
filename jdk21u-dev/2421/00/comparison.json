{"files":[{"patch":"@@ -2524,0 +2524,2 @@\n+          \/\/ locals are preserved\n+          \/\/ stack will be truncated\n@@ -2573,5 +2575,1 @@\n-      if (_compilation->env()->should_retain_local_variables()) {\n-        cur_state = cur_state->copy(ValueStack::ExceptionState, cur_state->bci());\n-      } else {\n-        cur_state = cur_state->copy(ValueStack::EmptyExceptionState, cur_state->bci());\n-      }\n+      \/\/ Stack and locals are invalidated but not truncated in caller state.\n@@ -2579,0 +2577,4 @@\n+        assert(instruction->exception_state() != nullptr, \"missed set?\");\n+        ValueStack::Kind exc_kind = ValueStack::empty_exception_kind(true \/* caller *\/);\n+        cur_state = cur_state->copy(exc_kind, cur_state->bci());\n+        \/\/ reset caller exception state\n@@ -2580,2 +2582,6 @@\n-      }\n-      if (instruction->exception_state() == nullptr) {\n+      } else {\n+        assert(instruction->exception_state() == nullptr, \"already set\");\n+        \/\/ set instruction exception state\n+        \/\/ truncate stack\n+        ValueStack::Kind exc_kind = ValueStack::empty_exception_kind();\n+        cur_state = cur_state->copy(exc_kind, cur_state->bci());\n@@ -3494,5 +3500,3 @@\n-    if (_compilation->env()->should_retain_local_variables()) {\n-      s = state()->copy(ValueStack::ExceptionState, bci);\n-    } else {\n-      s = state()->copy(ValueStack::EmptyExceptionState, bci);\n-    }\n+    \/\/ no handler, no need to retain locals\n+    ValueStack::Kind exc_kind = ValueStack::empty_exception_kind();\n+    s = state()->copy(exc_kind, bci);\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -405,2 +405,14 @@\n-    if (s->kind() == ValueStack::EmptyExceptionState) {\n-      assert(s->stack_size() == 0 && s->locals_size() == 0 && (s->locks_size() == 0 || s->locks_size() == 1), \"state must be empty\");\n+    if (s->kind() == ValueStack::EmptyExceptionState ||\n+        s->kind() == ValueStack::CallerEmptyExceptionState)\n+    {\n+#ifdef ASSERT\n+      int index;\n+      Value value;\n+      for_each_stack_value(s, index, value) {\n+        fatal(\"state must be empty\");\n+      }\n+      for_each_local_value(s, index, value) {\n+        fatal(\"state must be empty\");\n+      }\n+#endif\n+      assert(s->locks_size() == 0 || s->locks_size() == 1, \"state must be empty\");\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2924,9 +2924,1 @@\n-    assert(locals->length() == cur_scope->method()->max_locals(), \"wrong number of locals\");\n-    assert(locals->length() == cur_state->locals_size(), \"wrong number of locals\");\n-  } else if (cur_scope->method()->max_locals() > 0) {\n-    assert(cur_state->kind() == ValueStack::EmptyExceptionState, \"should be\");\n-    nof_locals = cur_scope->method()->max_locals();\n-    locals = new GrowableArray<ScopeValue*>(nof_locals);\n-    for(int i = 0; i < nof_locals; i++) {\n-      locals->append(_illegal_value);\n-    }\n+    assert(locals->length() == nof_locals, \"wrong number of locals\");\n@@ -2934,0 +2926,2 @@\n+  assert(nof_locals == cur_scope->method()->max_locals(), \"wrong number of locals\");\n+  assert(nof_locals == cur_state->locals_size(), \"wrong number of locals\");\n@@ -2942,2 +2936,2 @@\n-      Value expression = cur_state->stack_at_inc(pos);\n-      append_scope_value(op_id, expression, expressions);\n+      Value expression = cur_state->stack_at(pos);\n+      pos += append_scope_value(op_id, expression, expressions);\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -54,2 +54,10 @@\n-  assert(kind != EmptyExceptionState || !Compilation::current()->env()->should_retain_local_variables(), \"need locals\");\n-  if (kind != EmptyExceptionState) {\n+  switch (kind) {\n+  case EmptyExceptionState:\n+  case CallerEmptyExceptionState:\n+    assert(!Compilation::current()->env()->should_retain_local_variables(), \"need locals\");\n+    \/\/ set to all nulls, like clear_locals()\n+    for (int i = 0; i < copy_from->locals_size(); ++i) {\n+      _locals.append(nullptr);\n+    }\n+    break;\n+  default:\n@@ -59,1 +67,13 @@\n-  if (kind != ExceptionState && kind != EmptyExceptionState) {\n+  switch (kind) {\n+  case ExceptionState:\n+  case EmptyExceptionState:\n+    assert(stack_size() == 0, \"fix stack_size_for_copy\");\n+    break;\n+  case CallerExceptionState:\n+  case CallerEmptyExceptionState:\n+    \/\/ set to all nulls\n+    for (int i = 0; i < copy_from->stack_size(); ++i) {\n+      _stack.append(nullptr);\n+    }\n+    break;\n+  default:\n@@ -71,4 +91,1 @@\n-  if (kind != EmptyExceptionState) {\n-    return locals_size();\n-  }\n-  return 0;\n+  return locals_size();\n@@ -224,0 +241,1 @@\n+      tty->print(\"stack %d \", i);\n@@ -225,3 +243,7 @@\n-      tty->print(\"%2d  \", i);\n-      tty->print(\"%c%d \", t->type()->tchar(), t->id());\n-      ip.print_instr(t);\n+      if (t == nullptr) {\n+        tty->print(\"null\");\n+      } else {\n+        tty->print(\"%2d  \", i);\n+        tty->print(\"%c%d \", t->type()->tchar(), t->id());\n+        ip.print_instr(t);\n+      }\n@@ -287,1 +309,3 @@\n-    if (v == nullptr) {\n+    if (kind() == empty_exception_kind(true \/* caller *\/)) {\n+      assert(v == nullptr, \"should be empty\");\n+    } else if (v == nullptr) {\n@@ -296,1 +320,3 @@\n-    if (v != nullptr && v->type()->is_double_word()) {\n+    if (kind() == EmptyExceptionState) {\n+      assert(v == nullptr, \"should be empty\");\n+    } else if (v != nullptr && v->type()->is_double_word()) {\n","filename":"src\/hotspot\/share\/c1\/c1_ValueStack.cpp","additions":38,"deletions":12,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -37,2 +37,12 @@\n-    ExceptionState,      \/\/ Exception handling of instruction\n-    EmptyExceptionState, \/\/ Exception handling of instructions not covered by an xhandler\n+    \/\/ Exception states for an instruction.\n+    \/\/ Dead stack items or locals may be invalidated or cleared\/removed.\n+    \/\/ Locals are retained if needed for JVMTI.\n+    \/\/ \"empty\" exception states are used when there is no handler,\n+    \/\/ and invalidate the locals.\n+    \/\/ \"leaf\" exception states clear the stack.\n+    \/\/ \"caller\" exception states are used for the parent\/caller,\n+    \/\/ and invalidate the stack.\n+    ExceptionState,      \/\/ Exception state for leaf with handler, stack cleared\n+    EmptyExceptionState, \/\/ Exception state for leaf w\/o handler, stack cleared, locals invalidated\n+    CallerExceptionState, \/\/ Exception state for parent with handler, stack invalidated\n+    CallerEmptyExceptionState, \/\/ Exception state for parent w\/o handler, stack+locals invalidated\n@@ -78,0 +88,7 @@\n+  \/\/ Used when no exception handler is found\n+  static Kind empty_exception_kind(bool caller = false) {\n+    return Compilation::current()->env()->should_retain_local_variables() ?\n+      (caller ? CallerExceptionState : ExceptionState) : \/\/ retain locals\n+      (caller ? CallerEmptyExceptionState : EmptyExceptionState);   \/\/ clear locals\n+  }\n+\n@@ -79,3 +96,2 @@\n-    assert(kind() == EmptyExceptionState ||\n-           (Compilation::current()->env()->should_retain_local_variables() && kind() == ExceptionState),\n-           \"only EmptyExceptionStates can be modified\");\n+    assert(kind() == empty_exception_kind(false) || kind() == empty_exception_kind(true),\n+           \"only empty exception states can be modified\");\n@@ -136,1 +152,1 @@\n-    assert(!x->type()->is_double_word() ||\n+    assert(x == nullptr || !x->type()->is_double_word() ||\n@@ -143,1 +159,1 @@\n-    i += x->type()->size();\n+    i += ((x == nullptr) ? 1 : x->type()->size());\n@@ -263,1 +279,2 @@\n-       index += value->type()->size())\n+       index += (value == nullptr ? 1 : value->type()->size()))                                \\\n+    if (value != nullptr)\n","filename":"src\/hotspot\/share\/c1\/c1_ValueStack.hpp","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8316422\n+* @summary Test exception state used for deoptimization.\n+* @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+VerifyStack -XX:+DeoptimizeALot\n+*      -Xcomp -XX:TieredStopAtLevel=1 -XX:CompileOnly=compiler.exceptions.TestDeoptExceptionState::test\n+*      compiler.exceptions.TestDeoptExceptionState\n+*\/\n+\n+package compiler.exceptions;\n+\n+public class TestDeoptExceptionState {\n+    private static int res = 0;\n+\n+    public static void main(String args[]) {\n+        int x = 42;\n+        int y = 1 + test();\n+        System.out.println(\"Foo \" + x + \" \" + y);\n+    }\n+\n+    public static int test() {\n+      int x = 42;\n+      int y = 1 + test1();\n+      return x + y;\n+    }\n+\n+    public static int test1() {\n+        for (int i = 0; i < 100; i++) {\n+            try {\n+                divZero();\n+            } catch (ArithmeticException ea) {\n+                \/\/ Expected\n+            }\n+        }\n+        return 1;\n+    }\n+\n+    public static void divZero() {\n+        res += div(0, 0);\n+    }\n+\n+    public static long div(long dividend, long divisor) {\n+        return dividend \/ divisor;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/exceptions\/TestDeoptExceptionState.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"}]}