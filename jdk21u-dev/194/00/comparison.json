{"files":[{"patch":"@@ -533,1 +533,1 @@\n-    return BarrierSetC2::load_at_resolved(access, val_type);;\n+    return BarrierSetC2::load_at_resolved(access, val_type);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -357,4 +357,0 @@\n-double ShenandoahAllocationRate::instantaneous_rate(size_t allocated) const {\n-  return instantaneous_rate(os::elapsedTime(), allocated);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-  double instantaneous_rate(size_t allocated) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHCLOSURES_HPP\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHCLOSURES_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,64 +39,0 @@\n-ShenandoahParallelCodeCacheIterator::ShenandoahParallelCodeCacheIterator(const GrowableArray<CodeHeap*>* heaps) {\n-  _length = heaps->length();\n-  _iters = NEW_C_HEAP_ARRAY(ShenandoahParallelCodeHeapIterator, _length, mtGC);\n-  for (int h = 0; h < _length; h++) {\n-    _iters[h] = ShenandoahParallelCodeHeapIterator(heaps->at(h));\n-  }\n-}\n-\n-ShenandoahParallelCodeCacheIterator::~ShenandoahParallelCodeCacheIterator() {\n-  FREE_C_HEAP_ARRAY(ParallelCodeHeapIterator, _iters);\n-}\n-\n-void ShenandoahParallelCodeCacheIterator::parallel_blobs_do(CodeBlobClosure* f) {\n-  for (int c = 0; c < _length; c++) {\n-    _iters[c].parallel_blobs_do(f);\n-  }\n-}\n-\n-ShenandoahParallelCodeHeapIterator::ShenandoahParallelCodeHeapIterator(CodeHeap* heap) :\n-        _heap(heap), _claimed_idx(0), _finished(false) {\n-}\n-\n-void ShenandoahParallelCodeHeapIterator::parallel_blobs_do(CodeBlobClosure* f) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Must be at safepoint\");\n-\n-  \/*\n-   * Parallel code heap walk.\n-   *\n-   * This code makes all threads scan all code heaps, but only one thread would execute the\n-   * closure on given blob. This is achieved by recording the \"claimed\" blocks: if a thread\n-   * had claimed the block, it can process all blobs in it. Others have to fast-forward to\n-   * next attempt without processing.\n-   *\n-   * Late threads would return immediately if iterator is finished.\n-   *\/\n-\n-  if (_finished) {\n-    return;\n-  }\n-\n-  int stride = 256; \/\/ educated guess\n-  int stride_mask = stride - 1;\n-  assert (is_power_of_2(stride), \"sanity\");\n-\n-  int count = 0;\n-  bool process_block = true;\n-\n-  for (CodeBlob *cb = CodeCache::first_blob(_heap); cb != nullptr; cb = CodeCache::next_blob(_heap, cb)) {\n-    int current = count++;\n-    if ((current & stride_mask) == 0) {\n-      process_block = (current >= _claimed_idx) &&\n-                      (Atomic::cmpxchg(&_claimed_idx, current, current + stride, memory_order_relaxed) == current);\n-    }\n-    if (process_block) {\n-      f->do_code_blob(cb);\n-#ifdef ASSERT\n-      if (cb->is_nmethod())\n-        Universe::heap()->verify_nmethod((nmethod*)cb);\n-#endif\n-    }\n-  }\n-\n-  _finished = true;\n-}\n@@ -306,1 +242,0 @@\n-        _par_iterator(CodeCache::heaps()),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":0,"deletions":65,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -42,27 +42,0 @@\n-class ShenandoahParallelCodeHeapIterator {\n-  friend class CodeCache;\n-private:\n-  CodeHeap*     _heap;\n-  shenandoah_padding(0);\n-  volatile int  _claimed_idx;\n-  volatile bool _finished;\n-  shenandoah_padding(1);\n-public:\n-  ShenandoahParallelCodeHeapIterator(CodeHeap* heap);\n-  void parallel_blobs_do(CodeBlobClosure* f);\n-};\n-\n-class ShenandoahParallelCodeCacheIterator {\n-  friend class CodeCache;\n-private:\n-  ShenandoahParallelCodeHeapIterator* _iters;\n-  int                       _length;\n-\n-  NONCOPYABLE(ShenandoahParallelCodeCacheIterator);\n-\n-public:\n-  ShenandoahParallelCodeCacheIterator(const GrowableArray<CodeHeap*>* heaps);\n-  ~ShenandoahParallelCodeCacheIterator();\n-  void parallel_blobs_do(CodeBlobClosure* f);\n-};\n-\n@@ -72,2 +45,0 @@\n-  ShenandoahParallelCodeCacheIterator _par_iterator;\n-  ShenandoahSharedFlag _seq_claimed;\n@@ -91,1 +62,0 @@\n-  static void flush_nmethod(nmethod* nm);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.hpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-    ShenandoahObjToScanQueue* q = _cm->get_queue(worker_id);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -282,1 +282,1 @@\n-  };\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-    ShenandoahHeap* heap = ShenandoahHeap::heap();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGC.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1856,8 +1856,0 @@\n-address ShenandoahHeap::cancelled_gc_addr() {\n-  return (address) ShenandoahHeap::heap()->_cancelled_gc.addr_of();\n-}\n-\n-address ShenandoahHeap::gc_state_addr() {\n-  return (address) ShenandoahHeap::heap()->_gc_state.addr_of();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -296,1 +296,0 @@\n-  static address gc_state_addr();\n@@ -317,1 +316,1 @@\n-  inline bool is_gc_in_progress_mask(uint mask) const;\n+\n@@ -337,1 +336,0 @@\n-  static address cancelled_gc_addr();\n@@ -357,1 +355,0 @@\n-  void prepare_evacuation(bool concurrent);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -386,4 +386,0 @@\n-inline bool ShenandoahHeap::is_gc_in_progress_mask(uint mask) const {\n-  return _gc_state.is_set(mask);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-#endif \/\/ SHARE_VM_GC_SHENANDOAH_SHENANDOAHJFRSUPPORT_HPP\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHJFRSUPPORT_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahJfrSupport.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-class ShenandoahCMDrainMarkingStackClosure;\n-\n@@ -39,2 +37,0 @@\n-  friend class ShenandoahCMDrainMarkingStackClosure;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMark.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,33 +55,0 @@\n-class ShenandoahHasCSetOopClosure : public OopClosure {\n-private:\n-  ShenandoahHeap* const _heap;\n-  bool                  _has_cset_oops;\n-\n-public:\n-  ShenandoahHasCSetOopClosure(ShenandoahHeap *heap) :\n-    _heap(heap),\n-    _has_cset_oops(false) {\n-  }\n-\n-  bool has_cset_oops() const {\n-    return _has_cset_oops;\n-  }\n-\n-  void do_oop(oop* p) {\n-    oop value = RawAccess<>::oop_load(p);\n-    if (!_has_cset_oops && _heap->in_collection_set(value)) {\n-      _has_cset_oops = true;\n-    }\n-  }\n-\n-  void do_oop(narrowOop* p) {\n-    ShouldNotReachHere();\n-  }\n-};\n-\n-bool ShenandoahNMethod::has_cset_oops(ShenandoahHeap *heap) {\n-  ShenandoahHasCSetOopClosure cl(heap);\n-  oops_do(&cl);\n-  return cl.has_cset_oops();\n-}\n-\n@@ -212,4 +179,0 @@\n-\n-  bool has_oops() {\n-    return !_oops.is_empty();\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -58,6 +58,0 @@\n-  bool has_cset_oops(ShenandoahHeap* heap);\n-\n-  inline int oop_count() const;\n-  inline bool has_oops() const;\n-\n-  inline void mark_unregistered();\n@@ -80,1 +74,0 @@\n-  bool has_non_immed_oops() const { return _has_non_immed_oops; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,12 +42,0 @@\n-int ShenandoahNMethod::oop_count() const {\n-  return _oops_count + static_cast<int>(nm()->oops_end() - nm()->oops_begin());\n-}\n-\n-bool ShenandoahNMethod::has_oops() const {\n-  return oop_count() > 0;\n-}\n-\n-void ShenandoahNMethod::mark_unregistered() {\n-  _unregistered = true;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.inline.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -405,1 +405,1 @@\n-void ShenandoahReferenceProcessor::process_references(ShenandoahRefProcThreadLocal& refproc_data, uint worker_id) {;\n+void ShenandoahReferenceProcessor::process_references(ShenandoahRefProcThreadLocal& refproc_data, uint worker_id) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-  _phase(phase),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -137,1 +137,0 @@\n-  const ShenandoahPhaseTimings::Phase _phase;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}