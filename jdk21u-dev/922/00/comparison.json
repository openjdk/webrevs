{"files":[{"patch":"@@ -127,2 +127,3 @@\n-Sometimes, an `@IR` rule should only be applied if a certain CPU feature is present. This can be done with\n-the attributes `applyIfCPUFeatureXXX` in [@IR](.\/IR.java) which follow the same logic as the `applyIfXXX` methods for flags in the previous section. If a `@Test` annotated method has multiple preconditions (for example `applyIf` and `applyIfCPUFeature`), they are evaluated as a logical conjunction. An example with `applyIfCPUFeatureXXX` can be found in [TestCPUFeatureCheck](..\/..\/..\/testlibrary_tests\/ir_framework\/tests\/TestCPUFeatureCheck.java) (internal framework test).\n+Sometimes, an `@IR` rule should only be applied if a certain CPU feature is present. This can be done with the attributes `applyIfCPUFeatureXXX` in [@IR](.\/IR.java) which follow the same logic as the `applyIfXXX` methods for flags in the previous section. An example with `applyIfCPUFeatureXXX` can be found in [TestCPUFeatureCheck](..\/..\/..\/testlibrary_tests\/ir_framework\/tests\/TestCPUFeatureCheck.java) (internal framework test).\n+\n+If a `@Test` annotated method has multiple preconditions (for example `applyIf` and `applyIfCPUFeature`), they are evaluated as a logical conjunction. It's worth noting that flags in `applyIf` are checked only if the CPU features in `applyIfCPUFeature` are matched when they are both specified. This avoids the VM flag being evaluated on hardware that does not support it. An example with both `applyIfCPUFeatureXXX` and `applyIfXXX` can be found in [TestPreconditions](..\/..\/..\/testlibrary_tests\/ir_framework\/tests\/TestPreconditions.java) (internal framework test).\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/README.md","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -135,0 +135,9 @@\n+        } else if (irAnno.applyIfCPUFeature().length != 0 && !hasAllRequiredCPUFeature(irAnno.applyIfCPUFeature())) {\n+            printDisableReason(m, \"Feature constraint not met (applyIfCPUFeature)\", irAnno.applyIfCPUFeature(), ruleIndex, ruleMax);\n+            return false;\n+        } else if (irAnno.applyIfCPUFeatureAnd().length != 0 && !hasAllRequiredCPUFeature(irAnno.applyIfCPUFeatureAnd())) {\n+            printDisableReason(m, \"Not all feature constraints are met (applyIfCPUFeatureAnd)\", irAnno.applyIfCPUFeatureAnd(), ruleIndex, ruleMax);\n+            return false;\n+        } else if (irAnno.applyIfCPUFeatureOr().length != 0 && !hasAnyRequiredCPUFeature(irAnno.applyIfCPUFeatureOr())) {\n+            printDisableReason(m, \"None of the feature constraints met (applyIfCPUFeatureOr)\", irAnno.applyIfCPUFeatureOr(), ruleIndex, ruleMax);\n+            return false;\n@@ -147,9 +156,0 @@\n-        } else if (irAnno.applyIfCPUFeature().length != 0 && !hasAllRequiredCPUFeature(irAnno.applyIfCPUFeature())) {\n-            printDisableReason(m, \"Feature constraint not met (applyIfCPUFeature)\", irAnno.applyIfCPUFeature(), ruleIndex, ruleMax);\n-            return false;\n-        } else if (irAnno.applyIfCPUFeatureAnd().length != 0 && !hasAllRequiredCPUFeature(irAnno.applyIfCPUFeatureAnd())) {\n-            printDisableReason(m, \"Not all feature constraints are met (applyIfCPUFeatureAnd)\", irAnno.applyIfCPUFeatureAnd(), ruleIndex, ruleMax);\n-            return false;\n-        } else if (irAnno.applyIfCPUFeatureOr().length != 0 && !hasAnyRequiredCPUFeature(irAnno.applyIfCPUFeatureOr())) {\n-            printDisableReason(m, \"None of the feature constraints met (applyIfCPUFeatureOr)\", irAnno.applyIfCPUFeatureOr(), ruleIndex, ruleMax);\n-            return false;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    public static void testApplyBoth() {}\n+    public static void testApplyBoth1() {}\n@@ -61,0 +61,23 @@\n+    \/\/ The IR check should not be applied on aarch64, because the \"applyIfAnd\"\n+    \/\/ condition returns false as the VM is run with LoopMaxUnroll=8.\n+    \/\/ Note that precondition `applyIfCPUFeature` will be evaluated first with\n+    \/\/ early return. Hence the IR check should not be applied on non-aarch64\n+    \/\/ systems, and no exception is thrown because we are not checking the value\n+    \/\/ of the unsupported \"UseSVE\" flag on non-aarch64 systems.\n+    @Test\n+    @IR(applyIfCPUFeature = {\"asimd\", \"true\"},\n+        applyIfAnd = {\"UseSVE\", \"= 0\", \"LoopMaxUnroll\", \"= 0\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyBoth2() {}\n+\n+    \/\/ The IR check should not be applied on x86, because the \"applyIfAnd\"\n+    \/\/ condition returns false as the VM is run with LoopMaxUnroll=8.\n+    \/\/ Note that precondition `applyIfCPUFeature` will be evaluated first with\n+    \/\/ early return. Hence the IR check should not be applied on non-avx systems,\n+    \/\/ and no exception is thrown because we are not checking the value of the\n+    \/\/ unsupported \"UseAVX\" flag on non-avx systems.\n+    @Test\n+    @IR(applyIfCPUFeature = {\"avx\", \"true\"},\n+        applyIfAnd = {\"UseAVX\", \"= 2\", \"LoopMaxUnroll\", \"= 0\"},\n+        counts = {IRNode.LOOP, \">= 1000\"})\n+    public static void testApplyBoth3() {}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPreconditions.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"}]}