{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+import java.time.Duration;\n@@ -53,0 +54,2 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -54,0 +57,1 @@\n+import java.util.stream.IntStream;\n@@ -98,1 +102,1 @@\n-    private static final int MIN_TIMEOUT = 50; \/\/ msec after which there are no retries.\n+    private static final int MIN_TIMEOUT = 0; \/\/ msec after which there are no retries.\n@@ -226,1 +230,4 @@\n-\n+        \/\/ Holder for unfulfilled timeouts left for each server\n+        AtomicLong[] unfulfilledUdpTimeouts = IntStream.range(0, servers.length)\n+                .mapToObj(AtomicLong::new)\n+                .toArray(AtomicLong[]::new);\n@@ -233,2 +240,2 @@\n-            for (int retry = 0; retry < retries; retry++) {\n-\n+            for (int retry = 0; retry <= retries; retry++) {\n+                boolean isLastRetry = retry == retries;\n@@ -240,0 +247,5 @@\n+                    \/\/ unfulfilledServerTimeout is always >= 0\n+                    AtomicLong unfulfilledServerTimeout = unfulfilledUdpTimeouts[i];\n+                    if (isLastRetry && unfulfilledServerTimeout.get() == 0) {\n+                        continue;\n+                    }\n@@ -248,1 +260,1 @@\n-                                                retry, xid);\n+                                retry, xid, unfulfilledServerTimeout, isLastRetry);\n@@ -262,1 +274,6 @@\n-                            int retryTimeout = (timeout * (1 << retry));\n+                            long retryTimeout = Math.clamp(\n+                                    timeout * (1L << (isLastRetry\n+                                            ? retry - 1\n+                                            : retry)),\n+                                    0L, Integer.MAX_VALUE);\n+                            ;\n@@ -304,1 +321,3 @@\n-                        if (caughtException == null) {\n+                        if (caughtException == null || servers.length == 1) {\n+                            \/\/ If there are several servers we continue trying with other\n+                            \/\/ servers, otherwise this exception will be reported\n@@ -306,0 +325,3 @@\n+                        } else {\n+                            \/\/ Best reporting effort\n+                            caughtException.addSuppressed(ex);\n@@ -312,1 +334,4 @@\n-                        if (caughtException == null) {\n+                        if (caughtException instanceof CommunicationException ce) {\n+                            e.addSuppressed(ce);\n+                            caughtException = e;\n+                        } else if (caughtException == null) {\n@@ -330,1 +355,3 @@\n-                        if (caughtException == null) {\n+                        if (caughtException == null || servers.length == 1) {\n+                            \/\/ If there are several servers we continue trying with other\n+                            \/\/ servers, otherwise this exception will be reported\n@@ -332,0 +359,3 @@\n+                        } else {\n+                            \/\/ Best reporting effort\n+                            caughtException.addSuppressed(e);\n@@ -342,2 +372,2 @@\n-        if (caughtException instanceof NamingException) {\n-            throw (NamingException) caughtException;\n+        if (caughtException instanceof NamingException ne) {\n+            throw ne;\n@@ -427,1 +457,3 @@\n-                                     int port, int retry, int xid)\n+                              int port, int retry, int xid,\n+                              AtomicLong unfulfilledTimeout,\n+                              boolean unfulfilledOnly)\n@@ -431,0 +463,20 @@\n+\n+\n+        \/\/ use 1L below to ensure conversion to long and avoid potential\n+        \/\/ integer overflow (timeout is an int).\n+        \/\/ no point in supporting timeout > Integer.MAX_VALUE, clamp if needed\n+        \/\/ timeout remaining after successive 'blockingReceive()'.\n+        long thisIterationTimeout = unfulfilledOnly\n+                ? 0L\n+                : Math.clamp(timeout * (1L << retry), 0L, Integer.MAX_VALUE);\n+\n+        \/\/ Compensate with server's positive unfulfilled timeout.\n+        \/\/ Calling method never supplies zero 'unfulfilledTimeout' when\n+        \/\/ 'unfulfilledOnly' is 'true', therefore 'thisIterationTimeout'\n+        \/\/ will always be a positive number, ie infinite timeout\n+        \/\/ is not possible.\n+        thisIterationTimeout += unfulfilledTimeout.get();\n+\n+        \/\/ Track left timeout for the current retry\n+        long timeoutLeft = thisIterationTimeout;\n+        long start = 0;\n@@ -439,1 +491,0 @@\n-                int pktTimeout = (timeout * (1 << retry));\n@@ -442,2 +493,0 @@\n-                \/\/ timeout remaining after successive 'blockingReceive()'\n-                int timeoutLeft = pktTimeout;\n@@ -446,0 +495,1 @@\n+                start = System.nanoTime();\n@@ -459,3 +509,1 @@\n-                    long start = System.currentTimeMillis();\n-                    gotData = blockingReceive(udpChannel, ipkt, timeoutLeft);\n-                    long end = System.currentTimeMillis();\n+                    gotData = blockingReceive(udpChannel, target, ipkt, timeoutLeft);\n@@ -474,1 +522,3 @@\n-                    timeoutLeft = pktTimeout - ((int) (end - start));\n+                    long elapsedMillis = TimeUnit.NANOSECONDS\n+                                                 .toMillis(System.nanoTime() - start);\n+                    timeoutLeft = thisIterationTimeout - elapsedMillis;\n@@ -480,0 +530,3 @@\n+            long carryoverTimeout = thisIterationTimeout -\n+                    TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n+            unfulfilledTimeout.set(Math.max(0, carryoverTimeout));\n@@ -484,1 +537,2 @@\n-    boolean blockingReceive(DatagramChannel dc, ByteBuffer buffer, long timeout) throws IOException {\n+    boolean blockingReceive(DatagramChannel dc, InetSocketAddress target,\n+                            ByteBuffer buffer, long timeout) throws IOException {\n@@ -494,2 +548,8 @@\n-                dc.receive(buffer);\n-                dataReceived = true;\n+                int before = buffer.position();\n+                var senderAddress = dc.receive(buffer);\n+                \/\/ Empty packets are ignored\n+                dataReceived = target.equals(senderAddress) && buffer.position() > before;\n+            }\n+            \/\/ Avoid contention with Selector.close() if called by a clean-up thread\n+            synchronized (keys) {\n+                keys.clear();\n@@ -497,1 +557,0 @@\n-            keys.clear();\n@@ -753,1 +812,1 @@\n-    private int timeoutLeft;\n+    private long timeoutLeft;\n@@ -755,1 +814,1 @@\n-    Tcp(InetAddress server, int port, int timeout) throws IOException {\n+    Tcp(InetAddress server, int port, long timeout) throws IOException {\n@@ -758,3 +817,8 @@\n-            long start = System.currentTimeMillis();\n-            sock.connect(new InetSocketAddress(server, port), timeout);\n-            timeoutLeft = (int) (timeout - (System.currentTimeMillis() - start));\n+            long start = System.nanoTime();\n+            \/\/ It is safe to cast to int since the value is\n+            \/\/ clamped by the caller\n+            int intTimeout = (int) timeout;\n+            sock.connect(new InetSocketAddress(server, port), intTimeout);\n+            timeoutLeft = Duration.ofMillis(timeout)\n+                    .minus(Duration.ofNanos((System.nanoTime() - start)))\n+                    .toMillis();\n@@ -788,3 +852,4 @@\n-\n-        sock.setSoTimeout(timeoutLeft);\n-        long start = System.currentTimeMillis();\n+        \/\/ It is safe to cast to int since the value is clamped\n+        int intTimeout = (int) timeoutLeft;\n+        sock.setSoTimeout(intTimeout);\n+        long start = System.nanoTime();\n@@ -795,1 +860,2 @@\n-            timeoutLeft -= (int) (System.currentTimeMillis() - start);\n+            timeoutLeft -= TimeUnit.NANOSECONDS.toMillis(\n+                    System.nanoTime() - start);\n","filename":"src\/jdk.naming.dns\/share\/classes\/com\/sun\/jndi\/dns\/DnsClient.java","additions":99,"deletions":33,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-                timeout = val;\n+                timeout = Math.max(val, 0);\n@@ -185,1 +185,1 @@\n-                retries = val;\n+                retries = Math.clamp(val, 1, 30);\n@@ -260,1 +260,1 @@\n-            : Integer.parseInt(val);\n+            : Math.max(Integer.parseInt(val), 0);\n@@ -264,1 +264,1 @@\n-            : Integer.parseInt(val);\n+            : Math.clamp(Integer.parseInt(val), 1, 30);\n","filename":"src\/jdk.naming.dns\/share\/classes\/com\/sun\/jndi\/dns\/DnsContext.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import java.time.Instant;\n@@ -43,1 +42,1 @@\n- * @run main Timeout\n+ * @run main\/othervm Timeout\n@@ -51,0 +50,4 @@\n+    \/\/ DnsClient retries again with increased timeout if left\n+    \/\/ timeout is less than this value, and max retry attempts\n+    \/\/ is not reached\n+    private static final int DNS_CLIENT_MIN_TIMEOUT = 0;\n@@ -52,1 +55,1 @@\n-    private Instant startTime;\n+    private long startTime;\n@@ -84,1 +87,1 @@\n-            startTime = Instant.now();\n+            startTime = System.nanoTime();\n@@ -95,1 +98,1 @@\n-            Duration elapsedTime = Duration.between(startTime, Instant.now());\n+            Duration elapsedTime = Duration.ofNanos(System.nanoTime() - startTime);\n@@ -101,2 +104,8 @@\n-            Duration expectedTime = Duration.ofMillis(TIMEOUT)\n-                    .multipliedBy((1 << RETRIES) - 1);\n+            Duration minAllowedTime = Duration.ofMillis(TIMEOUT)\n+                    .multipliedBy((1 << RETRIES) - 1)\n+                    .minus(Duration.ofMillis(DNS_CLIENT_MIN_TIMEOUT * RETRIES));\n+            Duration maxAllowedTime = Duration.ofMillis(TIMEOUT)\n+                    .multipliedBy((1 << RETRIES) - 1)\n+                    \/\/ max allowed timeout value is set to 2 * expected timeout\n+                    .multipliedBy(2);\n+\n@@ -104,1 +113,3 @@\n-            DNSTestUtils.debug(\"Expected (ms): \" + expectedTime.toMillis());\n+            String expectedRangeMsg = \"%s - %s\"\n+                    .formatted(minAllowedTime.toMillis(), maxAllowedTime.toMillis());\n+            DNSTestUtils.debug(\"Expected range (ms): \" + expectedRangeMsg);\n@@ -107,4 +118,3 @@\n-            \/\/ not more than 50% greater.\n-            if (elapsedTime.compareTo(expectedTime) >= 0 &&\n-                    elapsedTime.multipliedBy(2)\n-                            .compareTo(expectedTime.multipliedBy(3)) <= 0) {\n+            \/\/ not more than 2 times greater.\n+            if (elapsedTime.compareTo(minAllowedTime) >= 0 &&\n+                elapsedTime.compareTo(maxAllowedTime) <= 0) {\n@@ -115,2 +125,2 @@\n-                    \"Failed: timeout in \" + elapsedTime.toMillis()\n-                            + \" ms, expected\" + expectedTime.toMillis() + \"ms\");\n+                    \"Failed: timeout in \" + elapsedTime.toMillis() +\n+                    \" ms, expected to be in a range (ms): \" + expectedRangeMsg);\n","filename":"test\/jdk\/com\/sun\/jndi\/dns\/ConfigTests\/Timeout.java","additions":25,"deletions":15,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.net.URIBuilder;\n+\n+import javax.naming.CommunicationException;\n+import javax.naming.Context;\n+import javax.naming.directory.InitialDirContext;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.net.SocketTimeoutException;\n+import java.time.Duration;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+\/*\n+ * @test\n+ * @bug 8339538\n+ * @summary Tests that DnsClient correctly calculates left timeout in\n+ *          presence of empty datagram packets.\n+ * @library ..\/lib \/test\/lib\n+ * @modules java.base\/sun.security.util\n+ * @run main\/othervm TimeoutWithEmptyDatagrams\n+ *\/\n+\n+public class TimeoutWithEmptyDatagrams extends DNSTestBase {\n+    \/\/ initial timeout = 1\/4 sec\n+    private static final int TIMEOUT = 250;\n+    \/\/ try 5 times per server\n+    private static final int RETRIES = 5;\n+    \/\/ DnsClient retries again with increased timeout if left\n+    \/\/ timeout is less than this value, and max retry attempts\n+    \/\/ is not reached\n+    private static final int DNS_CLIENT_MIN_TIMEOUT = 0;\n+\n+    public TimeoutWithEmptyDatagrams() {\n+        setLocalServer(false);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        new TimeoutWithEmptyDatagrams().run(args);\n+    }\n+\n+    \/*\n+     * Tests that we can set the initial UDP timeout interval and the\n+     * number of retries.\n+     *\/\n+    @Override\n+    public void runTest() throws Exception {\n+        \/\/ Create a DatagramSocket and bind it to the loopback address to simulate\n+        \/\/ UDP DNS server that doesn't respond\n+        try (DatagramSocket ds = new DatagramSocket(new InetSocketAddress(\n+                InetAddress.getLoopbackAddress(), 0))) {\n+            CountDownLatch gotClientAddress = new CountDownLatch(1);\n+            AtomicReference<SocketAddress> clientAddress = new AtomicReference<>();\n+            AtomicBoolean stopTestThreads = new AtomicBoolean();\n+\n+            String allQuietUrl = URIBuilder.newBuilder()\n+                    .scheme(\"dns\")\n+                    .loopback()\n+                    .port(ds.getLocalPort())\n+                    .build()\n+                    .toString();\n+\n+            \/\/ Run a virtual thread that receives client request packets and extracts\n+            \/\/ sender address from them.\n+            Thread receiverThread = Thread.ofVirtual().start(() -> {\n+                while (!stopTestThreads.get()) {\n+                    try {\n+                        DatagramPacket packet = new DatagramPacket(new byte[1024], 1024);\n+                        ds.receive(packet);\n+                        System.err.println(\"Got packet from \" + packet.getSocketAddress());\n+                        boolean hasClientAddress = clientAddress.get() != null;\n+                        clientAddress.set(packet.getSocketAddress());\n+                        if (!hasClientAddress) {\n+                            gotClientAddress.countDown();\n+                        }\n+                    } catch (IOException e) {\n+                        if (!stopTestThreads.get()) {\n+                            throw new RuntimeException(e);\n+                        } else {\n+                            return;\n+                        }\n+                    }\n+                }\n+            });\n+\n+            \/\/ Run a virtual thread that will send an empty packets via server socket\n+            \/\/ that should wake up the selector on a client side.\n+            Thread wakeupThread = Thread.ofVirtual().start(() -> {\n+                try {\n+                    long timeout = Math.max(1, TIMEOUT \/ 4);\n+                    \/\/ wait for a first packet on a server socket\n+                    gotClientAddress.await();\n+\n+                    \/\/ Now start sending empty packets until we get a notification\n+                    \/\/ from client part to stop sending\n+                    while (!stopTestThreads.get()) {\n+                        System.err.println(\"Server timeout = \" + timeout);\n+                        TimeUnit.MILLISECONDS.sleep(timeout);\n+                        System.err.println(\"Sending wakeup packet to \" + clientAddress.get());\n+                        var wakeupPacket = new DatagramPacket(new byte[0], 0);\n+                        wakeupPacket.setSocketAddress(clientAddress.get());\n+                        ds.send(wakeupPacket);\n+                        timeout += Math.max(1, timeout \/ 2);\n+                    }\n+                } catch (IOException ioe) {\n+                    throw new RuntimeException(\"Test machinery failure\", ioe);\n+                } catch (InterruptedException e) {\n+                    throw new RuntimeException(\"Interrupted during wakeup packets sending\");\n+                } finally {\n+                    System.err.println(\"Server thread exiting\");\n+                }\n+            });\n+\n+            long startTime = 0;\n+            try {\n+                env().put(Context.PROVIDER_URL, allQuietUrl);\n+                env().put(\"com.sun.jndi.dns.timeout.initial\", String.valueOf(TIMEOUT));\n+                env().put(\"com.sun.jndi.dns.timeout.retries\", String.valueOf(RETRIES));\n+                setContext(new InitialDirContext(env()));\n+\n+                startTime = System.nanoTime();\n+                context().getAttributes(\"\");\n+\n+                \/\/ Any request should fail after timeouts have expired.\n+                throw new RuntimeException(\"Failed: getAttributes succeeded unexpectedly\");\n+            } catch (CommunicationException ce) {\n+                \/\/ We need to catch CommunicationException outside the test framework\n+                \/\/ flow because wakeupThread.join() can take some time that could\n+                \/\/ increase measured timeout\n+                long endTime = System.nanoTime();\n+                Duration elapsedTime = Duration.ofNanos(endTime - startTime);\n+                if (ce.getRootCause() instanceof SocketTimeoutException) {\n+\n+                    Duration minAllowedTime = Duration.ofMillis(TIMEOUT)\n+                            .multipliedBy((1 << RETRIES) - 1)\n+                            .minus(Duration.ofMillis(DNS_CLIENT_MIN_TIMEOUT * RETRIES));\n+                    Duration maxAllowedTime = Duration.ofMillis(TIMEOUT)\n+                            .multipliedBy((1 << RETRIES) - 1)\n+                            \/\/ max allowed timeout value is set to 2 * expected timeout\n+                            .multipliedBy(2);\n+\n+                    DNSTestUtils.debug(\"Elapsed (ms):  \" + elapsedTime.toMillis());\n+                    String expectedRangeMsg = \"%s - %s\"\n+                            .formatted(minAllowedTime.toMillis(), maxAllowedTime.toMillis());\n+                    DNSTestUtils.debug(\"Expected range (ms): \" + expectedRangeMsg);\n+\n+                    \/\/ Check that elapsed time is as long as expected, and\n+                    \/\/ not more than 2 times greater.\n+                    if (elapsedTime.compareTo(minAllowedTime) >= 0 &&\n+                        elapsedTime.compareTo(maxAllowedTime) <= 0) {\n+                        System.out.println(\"elapsed time is as long as expected.\");\n+                    } else {\n+                        throw new RuntimeException(\n+                                \"Failed: timeout in \" + elapsedTime.toMillis() +\n+                                \" ms, expected to be in a range (ms): \" + expectedRangeMsg);\n+                    }\n+                } else {\n+                    throw ce;\n+                }\n+            } finally {\n+                stopTestThreads.set(true);\n+                wakeupThread.join();\n+                ds.close();\n+                receiverThread.join();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jndi\/dns\/ConfigTests\/TimeoutWithEmptyDatagrams.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"}]}