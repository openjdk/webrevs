{"files":[{"patch":"@@ -4,1 +4,1 @@\n-version=21\n+version=21.0.3\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -181,1 +181,2 @@\n-      printf \"%.0f\", c; \\\n+      c = c + 0.5; \\\n+      printf \"%d\", c; \\\n@@ -359,1 +360,1 @@\n-    $(subst .sh,,$(subst .html,,$(subst .java,,$(suffix $(notdir $1)))))\n+    $(subst .jasm,,$(subst .sh,,$(subst .html,,$(subst .java,,$(suffix $(notdir $1))))))\n@@ -803,0 +804,1 @@\n+  # The minidumps are disabled by default on client Windows, so enable them\n@@ -805,0 +807,1 @@\n+    $1_JTREG_BASIC_OPTIONS += -vmoption:-XX:+CreateCoredumpOnCrash\n@@ -868,1 +871,1 @@\n-  clean-workdir-$1:\n+  clean-outputdirs-$1:\n@@ -870,0 +873,1 @@\n+\t$$(RM) -r $$($1_TEST_RESULTS_DIR)\n@@ -872,1 +876,1 @@\n-      $$(JAVA) $$($1_JTREG_LAUNCHER_OPTIONS) \\\n+      $$(JTREG_JAVA) $$($1_JTREG_LAUNCHER_OPTIONS) \\\n@@ -915,1 +919,1 @@\n-  run-test-$1: pre-run-test clean-workdir-$1\n+  run-test-$1: pre-run-test clean-outputdirs-$1\n@@ -952,1 +956,1 @@\n-  $1: run-test-$1 parse-test-$1 clean-workdir-$1\n+  $1: run-test-$1 parse-test-$1 clean-outputdirs-$1\n@@ -954,1 +958,1 @@\n-  TARGETS += $1 run-test-$1 parse-test-$1 clean-workdir-$1\n+  TARGETS += $1 run-test-$1 parse-test-$1 clean-outputdirs-$1\n","filename":"make\/RunTests.gmk","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3812,196 +3812,0 @@\n-  enc_class aarch64_enc_fast_lock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{\n-    C2_MacroAssembler _masm(&cbuf);\n-    Register oop = as_Register($object$$reg);\n-    Register box = as_Register($box$$reg);\n-    Register disp_hdr = as_Register($tmp$$reg);\n-    Register tmp = as_Register($tmp2$$reg);\n-    Label cont;\n-    Label object_has_monitor;\n-    Label count, no_count;\n-\n-    assert_different_registers(oop, box, tmp, disp_hdr);\n-\n-    \/\/ Load markWord from object into displaced_header.\n-    __ ldr(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      __ load_klass(tmp, oop);\n-      __ ldrw(tmp, Address(tmp, Klass::access_flags_offset()));\n-      __ tstw(tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n-      __ br(Assembler::NE, cont);\n-    }\n-\n-    \/\/ Check for existing monitor\n-    __ tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);\n-\n-    if (LockingMode == LM_MONITOR) {\n-      __ tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n-      __ b(cont);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n-      __ orr(tmp, disp_hdr, markWord::unlocked_value);\n-\n-      \/\/ Initialize the box. (Must happen before we update the object mark!)\n-      __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ Compare object markWord with an unlocked value (tmp) and if\n-      \/\/ equal exchange the stack address of our box with object markWord.\n-      \/\/ On failure disp_hdr contains the possibly locked markWord.\n-      __ cmpxchg(oop, tmp, box, Assembler::xword, \/*acquire*\/ true,\n-                 \/*release*\/ true, \/*weak*\/ false, disp_hdr);\n-      __ br(Assembler::EQ, cont);\n-\n-      assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-      \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-      \/\/ object, will have now locked it will continue at label cont\n-\n-      \/\/ Check if the owner is self by comparing the value in the\n-      \/\/ markWord of object (disp_hdr) with the stack pointer.\n-      __ mov(rscratch1, sp);\n-      __ sub(disp_hdr, disp_hdr, rscratch1);\n-      __ mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n-      \/\/ If condition is true we are cont and hence we can store 0 as the\n-      \/\/ displaced header in the box, which indicates that it is a recursive lock.\n-      __ ands(tmp\/*==0?*\/, disp_hdr, tmp);   \/\/ Sets flags for result\n-      __ str(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-      __ b(cont);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-      __ fast_lock(oop, disp_hdr, tmp, rscratch1, no_count);\n-      __ b(count);\n-    }\n-\n-    \/\/ Handle existing monitor.\n-    __ bind(object_has_monitor);\n-\n-    \/\/ The object's monitor m is unlocked iff m->owner == NULL,\n-    \/\/ otherwise m->owner may contain a thread or a stack address.\n-    \/\/\n-    \/\/ Try to CAS m->owner from NULL to current thread.\n-    __ add(tmp, disp_hdr, (in_bytes(ObjectMonitor::owner_offset())-markWord::monitor_value));\n-    __ cmpxchg(tmp, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n-               \/*release*\/ true, \/*weak*\/ false, rscratch1); \/\/ Sets flags for result\n-\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n-      \/\/ lock. The fast-path monitor unlock code checks for\n-      \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n-      \/\/ relevant bit set, and also matches ObjectSynchronizer::enter.\n-      __ mov(tmp, (address)markWord::unused_mark().value());\n-      __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-    }\n-    __ br(Assembler::EQ, cont); \/\/ CAS success means locking succeeded\n-\n-    __ cmp(rscratch1, rthread);\n-    __ br(Assembler::NE, cont); \/\/ Check for recursive locking\n-\n-    \/\/ Recursive lock case\n-    __ increment(Address(disp_hdr, in_bytes(ObjectMonitor::recursions_offset()) - markWord::monitor_value), 1);\n-    \/\/ flag == EQ still from the cmp above, checking if this is a reentrant lock\n-\n-    __ bind(cont);\n-    \/\/ flag == EQ indicates success\n-    \/\/ flag == NE indicates failure\n-    __ br(Assembler::NE, no_count);\n-\n-    __ bind(count);\n-    __ increment(Address(rthread, JavaThread::held_monitor_count_offset()));\n-\n-    __ bind(no_count);\n-  %}\n-\n-  enc_class aarch64_enc_fast_unlock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{\n-    C2_MacroAssembler _masm(&cbuf);\n-    Register oop = as_Register($object$$reg);\n-    Register box = as_Register($box$$reg);\n-    Register disp_hdr = as_Register($tmp$$reg);\n-    Register tmp = as_Register($tmp2$$reg);\n-    Label cont;\n-    Label object_has_monitor;\n-    Label count, no_count;\n-\n-    assert_different_registers(oop, box, tmp, disp_hdr);\n-\n-    if (LockingMode == LM_LEGACY) {\n-      \/\/ Find the lock address and load the displaced header from the stack.\n-      __ ldr(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ If the displaced header is 0, we have a recursive unlock.\n-      __ cmp(disp_hdr, zr);\n-      __ br(Assembler::EQ, cont);\n-    }\n-\n-    \/\/ Handle existing monitor.\n-    __ ldr(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));\n-    __ tbnz(tmp, exact_log2(markWord::monitor_value), object_has_monitor);\n-\n-    if (LockingMode == LM_MONITOR) {\n-      __ tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n-      __ b(cont);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Check if it is still a light weight lock, this is is true if we\n-      \/\/ see the stack address of the basicLock in the markWord of the\n-      \/\/ object.\n-\n-      __ cmpxchg(oop, box, disp_hdr, Assembler::xword, \/*acquire*\/ false,\n-                 \/*release*\/ true, \/*weak*\/ false, tmp);\n-      __ b(cont);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-      __ fast_unlock(oop, tmp, box, disp_hdr, no_count);\n-      __ b(count);\n-    }\n-\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-    \/\/ Handle existing monitor.\n-    __ bind(object_has_monitor);\n-    STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n-    __ add(tmp, tmp, -(int)markWord::monitor_value); \/\/ monitor\n-\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ If the owner is anonymous, we need to fix it -- in an outline stub.\n-      Register tmp2 = disp_hdr;\n-      __ ldr(tmp2, Address(tmp, ObjectMonitor::owner_offset()));\n-      \/\/ We cannot use tbnz here, the target might be too far away and cannot\n-      \/\/ be encoded.\n-      __ tst(tmp2, (uint64_t)ObjectMonitor::ANONYMOUS_OWNER);\n-      C2HandleAnonOMOwnerStub* stub = new (Compile::current()->comp_arena()) C2HandleAnonOMOwnerStub(tmp, tmp2);\n-      Compile::current()->output()->add_stub(stub);\n-      __ br(Assembler::NE, stub->entry());\n-      __ bind(stub->continuation());\n-    }\n-\n-    __ ldr(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-\n-    Label notRecursive;\n-    __ cbz(disp_hdr, notRecursive);\n-\n-    \/\/ Recursive lock\n-    __ sub(disp_hdr, disp_hdr, 1u);\n-    __ str(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-    __ cmp(disp_hdr, disp_hdr); \/\/ Sets flags for result\n-    __ b(cont);\n-\n-    __ bind(notRecursive);\n-    __ ldr(rscratch1, Address(tmp, ObjectMonitor::EntryList_offset()));\n-    __ ldr(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset()));\n-    __ orr(rscratch1, rscratch1, disp_hdr); \/\/ Will be 0 if both are 0.\n-    __ cmp(rscratch1, zr); \/\/ Sets flags for result\n-    __ cbnz(rscratch1, cont);\n-    \/\/ need a release store here\n-    __ lea(tmp, Address(tmp, ObjectMonitor::owner_offset()));\n-    __ stlr(zr, tmp); \/\/ set unowned\n-\n-    __ bind(cont);\n-    \/\/ flag == EQ indicates success\n-    \/\/ flag == NE indicates failure\n-    __ br(Assembler::NE, no_count);\n-\n-    __ bind(count);\n-    __ decrement(Address(rthread, JavaThread::held_monitor_count_offset()));\n-\n-    __ bind(no_count);\n-  %}\n-\n@@ -16626,1 +16430,1 @@\n-instruct cmpFastLock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2)\n+instruct cmpFastLock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -16629,1 +16433,1 @@\n-  effect(TEMP tmp, TEMP tmp2);\n+  effect(TEMP tmp, TEMP tmp2, TEMP tmp3);\n@@ -16636,1 +16440,3 @@\n-  ins_encode(aarch64_enc_fast_lock(object, box, tmp, tmp2));\n+  ins_encode %{\n+    __ fast_lock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n+  %}\n@@ -16649,1 +16455,3 @@\n-  ins_encode(aarch64_enc_fast_unlock(object, box, tmp, tmp2));\n+  ins_encode %{\n+    __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register);\n+  %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":8,"deletions":200,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -285,1 +285,2 @@\n-      __ ldp(r19, r20, Address(OSR_buf, slot_offset));\n+      __ ldr(r19, Address(OSR_buf, slot_offset));\n+      __ ldr(r20, Address(OSR_buf, slot_offset + BytesPerWord));\n@@ -437,1 +438,1 @@\n-      __ unlock_object(r5, r4, r0, *stub->entry());\n+      __ unlock_object(r5, r4, r0, r6, *stub->entry());\n@@ -2529,0 +2530,1 @@\n+  Register temp = op->scratch_opr()->as_register();\n@@ -2538,1 +2540,1 @@\n-    int null_check_offset = __ lock_object(hdr, obj, lock, *op->stub()->entry());\n+    int null_check_offset = __ lock_object(hdr, obj, lock, temp, *op->stub()->entry());\n@@ -2545,1 +2547,1 @@\n-    __ unlock_object(hdr, obj, lock, *op->stub()->entry());\n+    __ unlock_object(hdr, obj, lock, temp, *op->stub()->entry());\n@@ -2704,0 +2706,1 @@\n+    assert_different_registers(obj, tmp, rscratch1, rscratch2, mdo_addr.base(), mdo_addr.index());\n@@ -2705,0 +2708,2 @@\n+  } else {\n+    assert_different_registers(obj, rscratch1, rscratch2, mdo_addr.base(), mdo_addr.index());\n@@ -2761,2 +2766,2 @@\n-          \/\/ There is a chance that the checks above (re-reading profiling\n-          \/\/ data from memory) fail if another thread has just set the\n+          \/\/ There is a chance that the checks above\n+          \/\/ fail if another thread has just set the\n@@ -2765,0 +2770,1 @@\n+          __ eor(tmp, tmp, rscratch2); \/\/ get back original value before XOR\n@@ -2789,0 +2795,4 @@\n+#ifdef ASSERT\n+        __ andr(tmp, tmp, TypeEntries::type_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n@@ -2820,0 +2830,4 @@\n+#ifdef ASSERT\n+        __ andr(tmp, tmp, TypeEntries::type_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register temp, Label& slow_case) {\n@@ -66,1 +66,1 @@\n-  assert_different_registers(hdr, obj, disp_hdr);\n+  assert_different_registers(hdr, obj, disp_hdr, temp, rscratch2);\n@@ -86,1 +86,1 @@\n-    fast_lock(obj, hdr, rscratch1, rscratch2, slow_case);\n+    lightweight_lock(obj, hdr, temp, rscratch2, slow_case);\n@@ -128,1 +128,1 @@\n-void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n+void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Register temp, Label& slow_case) {\n@@ -131,1 +131,1 @@\n-  assert(hdr != obj && hdr != disp_hdr && obj != disp_hdr, \"registers must be different\");\n+  assert_different_registers(hdr, obj, disp_hdr, temp, rscratch2);\n@@ -152,1 +152,1 @@\n-    fast_unlock(obj, hdr, rscratch1, rscratch2, slow_case);\n+    lightweight_unlock(obj, hdr, temp, rscratch2, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  \/\/ temp    : temporary register, must not be rscratch1 or rscratch2\n@@ -62,1 +63,1 @@\n-  int lock_object  (Register swap, Register obj, Register disp_hdr, Label& slow_case);\n+  int lock_object  (Register swap, Register obj, Register disp_hdr, Register temp, Label& slow_case);\n@@ -68,1 +69,2 @@\n-  void unlock_object(Register swap, Register obj, Register lock, Label& slow_case);\n+  \/\/ temp    : temporary register, must not be rscratch1 or rscratch2\n+  void unlock_object(Register swap, Register obj, Register lock, Register temp, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,0 +48,196 @@\n+void C2_MacroAssembler::fast_lock(Register objectReg, Register boxReg, Register tmpReg,\n+                                  Register tmp2Reg, Register tmp3Reg) {\n+  Register oop = objectReg;\n+  Register box = boxReg;\n+  Register disp_hdr = tmpReg;\n+  Register tmp = tmp2Reg;\n+  Label cont;\n+  Label object_has_monitor;\n+  Label count, no_count;\n+\n+  assert_different_registers(oop, box, tmp, disp_hdr);\n+\n+  \/\/ Load markWord from object into displaced_header.\n+  ldr(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n+\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n+    load_klass(tmp, oop);\n+    ldrw(tmp, Address(tmp, Klass::access_flags_offset()));\n+    tstw(tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    br(Assembler::NE, cont);\n+  }\n+\n+  \/\/ Check for existing monitor\n+  tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);\n+\n+  if (LockingMode == LM_MONITOR) {\n+    tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n+    b(cont);\n+  } else if (LockingMode == LM_LEGACY) {\n+    \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n+    orr(tmp, disp_hdr, markWord::unlocked_value);\n+\n+    \/\/ Initialize the box. (Must happen before we update the object mark!)\n+    str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+    \/\/ Compare object markWord with an unlocked value (tmp) and if\n+    \/\/ equal exchange the stack address of our box with object markWord.\n+    \/\/ On failure disp_hdr contains the possibly locked markWord.\n+    cmpxchg(oop, tmp, box, Assembler::xword, \/*acquire*\/ true,\n+            \/*release*\/ true, \/*weak*\/ false, disp_hdr);\n+    br(Assembler::EQ, cont);\n+\n+    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n+    \/\/ object, will have now locked it will continue at label cont\n+\n+    \/\/ Check if the owner is self by comparing the value in the\n+    \/\/ markWord of object (disp_hdr) with the stack pointer.\n+    mov(rscratch1, sp);\n+    sub(disp_hdr, disp_hdr, rscratch1);\n+    mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n+    \/\/ If condition is true we are cont and hence we can store 0 as the\n+    \/\/ displaced header in the box, which indicates that it is a recursive lock.\n+    ands(tmp\/*==0?*\/, disp_hdr, tmp);   \/\/ Sets flags for result\n+    str(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+    b(cont);\n+  } else {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+    lightweight_lock(oop, disp_hdr, tmp, tmp3Reg, no_count);\n+    b(count);\n+  }\n+\n+  \/\/ Handle existing monitor.\n+  bind(object_has_monitor);\n+\n+  \/\/ The object's monitor m is unlocked iff m->owner == NULL,\n+  \/\/ otherwise m->owner may contain a thread or a stack address.\n+  \/\/\n+  \/\/ Try to CAS m->owner from NULL to current thread.\n+  add(tmp, disp_hdr, (in_bytes(ObjectMonitor::owner_offset())-markWord::monitor_value));\n+  cmpxchg(tmp, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n+          \/*release*\/ true, \/*weak*\/ false, rscratch1); \/\/ Sets flags for result\n+\n+  if (LockingMode != LM_LIGHTWEIGHT) {\n+    \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n+    \/\/ lock. The fast-path monitor unlock code checks for\n+    \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n+    \/\/ relevant bit set, and also matches ObjectSynchronizer::enter.\n+    mov(tmp, (address)markWord::unused_mark().value());\n+    str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+  }\n+  br(Assembler::EQ, cont); \/\/ CAS success means locking succeeded\n+\n+  cmp(rscratch1, rthread);\n+  br(Assembler::NE, cont); \/\/ Check for recursive locking\n+\n+  \/\/ Recursive lock case\n+  increment(Address(disp_hdr, in_bytes(ObjectMonitor::recursions_offset()) - markWord::monitor_value), 1);\n+  \/\/ flag == EQ still from the cmp above, checking if this is a reentrant lock\n+\n+  bind(cont);\n+  \/\/ flag == EQ indicates success\n+  \/\/ flag == NE indicates failure\n+  br(Assembler::NE, no_count);\n+\n+  bind(count);\n+  increment(Address(rthread, JavaThread::held_monitor_count_offset()));\n+\n+  bind(no_count);\n+}\n+\n+void C2_MacroAssembler::fast_unlock(Register objectReg, Register boxReg, Register tmpReg,\n+                                    Register tmp2Reg) {\n+  Register oop = objectReg;\n+  Register box = boxReg;\n+  Register disp_hdr = tmpReg;\n+  Register tmp = tmp2Reg;\n+  Label cont;\n+  Label object_has_monitor;\n+  Label count, no_count;\n+\n+  assert_different_registers(oop, box, tmp, disp_hdr);\n+\n+  if (LockingMode == LM_LEGACY) {\n+    \/\/ Find the lock address and load the displaced header from the stack.\n+    ldr(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+    \/\/ If the displaced header is 0, we have a recursive unlock.\n+    cmp(disp_hdr, zr);\n+    br(Assembler::EQ, cont);\n+  }\n+\n+  \/\/ Handle existing monitor.\n+  ldr(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));\n+  tbnz(tmp, exact_log2(markWord::monitor_value), object_has_monitor);\n+\n+  if (LockingMode == LM_MONITOR) {\n+    tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n+    b(cont);\n+  } else if (LockingMode == LM_LEGACY) {\n+    \/\/ Check if it is still a light weight lock, this is is true if we\n+    \/\/ see the stack address of the basicLock in the markWord of the\n+    \/\/ object.\n+\n+    cmpxchg(oop, box, disp_hdr, Assembler::xword, \/*acquire*\/ false,\n+            \/*release*\/ true, \/*weak*\/ false, tmp);\n+    b(cont);\n+  } else {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+    lightweight_unlock(oop, tmp, box, disp_hdr, no_count);\n+    b(count);\n+  }\n+\n+  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+  \/\/ Handle existing monitor.\n+  bind(object_has_monitor);\n+  STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n+  add(tmp, tmp, -(int)markWord::monitor_value); \/\/ monitor\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    \/\/ If the owner is anonymous, we need to fix it -- in an outline stub.\n+    Register tmp2 = disp_hdr;\n+    ldr(tmp2, Address(tmp, ObjectMonitor::owner_offset()));\n+    \/\/ We cannot use tbnz here, the target might be too far away and cannot\n+    \/\/ be encoded.\n+    tst(tmp2, (uint64_t)ObjectMonitor::ANONYMOUS_OWNER);\n+    C2HandleAnonOMOwnerStub* stub = new (Compile::current()->comp_arena()) C2HandleAnonOMOwnerStub(tmp, tmp2);\n+    Compile::current()->output()->add_stub(stub);\n+    br(Assembler::NE, stub->entry());\n+    bind(stub->continuation());\n+  }\n+\n+  ldr(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n+\n+  Label notRecursive;\n+  cbz(disp_hdr, notRecursive);\n+\n+  \/\/ Recursive lock\n+  sub(disp_hdr, disp_hdr, 1u);\n+  str(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n+  cmp(disp_hdr, disp_hdr); \/\/ Sets flags for result\n+  b(cont);\n+\n+  bind(notRecursive);\n+  ldr(rscratch1, Address(tmp, ObjectMonitor::EntryList_offset()));\n+  ldr(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset()));\n+  orr(rscratch1, rscratch1, disp_hdr); \/\/ Will be 0 if both are 0.\n+  cmp(rscratch1, zr); \/\/ Sets flags for result\n+  cbnz(rscratch1, cont);\n+  \/\/ need a release store here\n+  lea(tmp, Address(tmp, ObjectMonitor::owner_offset()));\n+  stlr(zr, tmp); \/\/ set unowned\n+\n+  bind(cont);\n+  \/\/ flag == EQ indicates success\n+  \/\/ flag == NE indicates failure\n+  br(Assembler::NE, no_count);\n+\n+  bind(count);\n+  decrement(Address(rthread, JavaThread::held_monitor_count_offset()));\n+\n+  bind(no_count);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":196,"deletions":0,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+  \/\/ Code used by cmpFastLock and cmpFastUnlock mach instructions in .ad file.\n+  \/\/ See full description in macroAssembler_aarch64.cpp.\n+  void fast_lock(Register object, Register box, Register tmp, Register tmp2, Register tmp3);\n+  void fast_unlock(Register object, Register box, Register tmp, Register tmp2);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2740,0 +2740,4 @@\n+#ifdef ASSERT\n+    \/\/ Poison rscratch1 which is written on !UseLSE branch\n+    mov(rscratch1, 0x1f1f1f1f1f1f1f1f);\n+#endif\n@@ -4155,0 +4159,2 @@\n+    \/\/ Registers v0..v7 are used as data registers.\n+    \/\/ Registers v16..v31 are used as tmp registers.\n@@ -4156,14 +4162,15 @@\n-    ldrq(v1, Address(buf, 0x10));\n-    ldrq(v2, Address(buf, 0x20));\n-    ldrq(v3, Address(buf, 0x30));\n-    ldrq(v4, Address(buf, 0x40));\n-    ldrq(v5, Address(buf, 0x50));\n-    ldrq(v6, Address(buf, 0x60));\n-    ldrq(v7, Address(buf, 0x70));\n-    ldrq(v8, Address(pre(buf, 0x80)));\n-\n-    movi(v25, T4S, 0);\n-    mov(v25, S, 0, crc);\n-    eor(v1, T16B, v1, v25);\n-\n-    ldrq(v0, Address(table));\n+    ldrq(v0, Address(buf, 0x10));\n+    ldrq(v1, Address(buf, 0x20));\n+    ldrq(v2, Address(buf, 0x30));\n+    ldrq(v3, Address(buf, 0x40));\n+    ldrq(v4, Address(buf, 0x50));\n+    ldrq(v5, Address(buf, 0x60));\n+    ldrq(v6, Address(buf, 0x70));\n+    ldrq(v7, Address(pre(buf, 0x80)));\n+\n+    movi(v31, T4S, 0);\n+    mov(v31, S, 0, crc);\n+    eor(v0, T16B, v0, v31);\n+\n+    \/\/ Register v16 contains constants from the crc table.\n+    ldrq(v16, Address(table));\n@@ -4174,39 +4181,41 @@\n-    pmull (v9,  T1Q, v1, v0, T1D);\n-    pmull2(v10, T1Q, v1, v0, T2D);\n-    ldrq(v1, Address(buf, 0x10));\n-    eor3(v1, T16B, v9,  v10, v1);\n-\n-    pmull (v11, T1Q, v2, v0, T1D);\n-    pmull2(v12, T1Q, v2, v0, T2D);\n-    ldrq(v2, Address(buf, 0x20));\n-    eor3(v2, T16B, v11, v12, v2);\n-\n-    pmull (v13, T1Q, v3, v0, T1D);\n-    pmull2(v14, T1Q, v3, v0, T2D);\n-    ldrq(v3, Address(buf, 0x30));\n-    eor3(v3, T16B, v13, v14, v3);\n-\n-    pmull (v15, T1Q, v4, v0, T1D);\n-    pmull2(v16, T1Q, v4, v0, T2D);\n-    ldrq(v4, Address(buf, 0x40));\n-    eor3(v4, T16B, v15, v16, v4);\n-\n-    pmull (v17, T1Q, v5, v0, T1D);\n-    pmull2(v18, T1Q, v5, v0, T2D);\n-    ldrq(v5, Address(buf, 0x50));\n-    eor3(v5, T16B, v17, v18, v5);\n-\n-    pmull (v19, T1Q, v6, v0, T1D);\n-    pmull2(v20, T1Q, v6, v0, T2D);\n-    ldrq(v6, Address(buf, 0x60));\n-    eor3(v6, T16B, v19, v20, v6);\n-\n-    pmull (v21, T1Q, v7, v0, T1D);\n-    pmull2(v22, T1Q, v7, v0, T2D);\n-    ldrq(v7, Address(buf, 0x70));\n-    eor3(v7, T16B, v21, v22, v7);\n-\n-    pmull (v23, T1Q, v8, v0, T1D);\n-    pmull2(v24, T1Q, v8, v0, T2D);\n-    ldrq(v8, Address(pre(buf, 0x80)));\n-    eor3(v8, T16B, v23, v24, v8);\n+    pmull (v17,  T1Q, v0, v16, T1D);\n+    pmull2(v18, T1Q, v0, v16, T2D);\n+    ldrq(v0, Address(buf, 0x10));\n+    eor3(v0, T16B, v17,  v18, v0);\n+\n+    pmull (v19, T1Q, v1, v16, T1D);\n+    pmull2(v20, T1Q, v1, v16, T2D);\n+    ldrq(v1, Address(buf, 0x20));\n+    eor3(v1, T16B, v19, v20, v1);\n+\n+    pmull (v21, T1Q, v2, v16, T1D);\n+    pmull2(v22, T1Q, v2, v16, T2D);\n+    ldrq(v2, Address(buf, 0x30));\n+    eor3(v2, T16B, v21, v22, v2);\n+\n+    pmull (v23, T1Q, v3, v16, T1D);\n+    pmull2(v24, T1Q, v3, v16, T2D);\n+    ldrq(v3, Address(buf, 0x40));\n+    eor3(v3, T16B, v23, v24, v3);\n+\n+    pmull (v25, T1Q, v4, v16, T1D);\n+    pmull2(v26, T1Q, v4, v16, T2D);\n+    ldrq(v4, Address(buf, 0x50));\n+    eor3(v4, T16B, v25, v26, v4);\n+\n+    pmull (v27, T1Q, v5, v16, T1D);\n+    pmull2(v28, T1Q, v5, v16, T2D);\n+    ldrq(v5, Address(buf, 0x60));\n+    eor3(v5, T16B, v27, v28, v5);\n+\n+    pmull (v29, T1Q, v6, v16, T1D);\n+    pmull2(v30, T1Q, v6, v16, T2D);\n+    ldrq(v6, Address(buf, 0x70));\n+    eor3(v6, T16B, v29, v30, v6);\n+\n+    \/\/ Reuse registers v23, v24.\n+    \/\/ Using them won't block the first instruction of the next iteration.\n+    pmull (v23, T1Q, v7, v16, T1D);\n+    pmull2(v24, T1Q, v7, v16, T2D);\n+    ldrq(v7, Address(pre(buf, 0x80)));\n+    eor3(v7, T16B, v23, v24, v7);\n@@ -4218,1 +4227,2 @@\n-    ldrq(v0, Address(table, 0x10));\n+    \/\/ Use v31 for constants because v16 can be still in use.\n+    ldrq(v31, Address(table, 0x10));\n@@ -4220,3 +4230,3 @@\n-    pmull (v10,  T1Q, v1, v0, T1D);\n-    pmull2(v11, T1Q, v1, v0, T2D);\n-    eor3(v1, T16B, v10, v11, v5);\n+    pmull (v17,  T1Q, v0, v31, T1D);\n+    pmull2(v18, T1Q, v0, v31, T2D);\n+    eor3(v0, T16B, v17, v18, v4);\n@@ -4224,3 +4234,3 @@\n-    pmull (v12, T1Q, v2, v0, T1D);\n-    pmull2(v13, T1Q, v2, v0, T2D);\n-    eor3(v2, T16B, v12, v13, v6);\n+    pmull (v19, T1Q, v1, v31, T1D);\n+    pmull2(v20, T1Q, v1, v31, T2D);\n+    eor3(v1, T16B, v19, v20, v5);\n@@ -4228,3 +4238,3 @@\n-    pmull (v14, T1Q, v3, v0, T1D);\n-    pmull2(v15, T1Q, v3, v0, T2D);\n-    eor3(v3, T16B, v14, v15, v7);\n+    pmull (v21, T1Q, v2, v31, T1D);\n+    pmull2(v22, T1Q, v2, v31, T2D);\n+    eor3(v2, T16B, v21, v22, v6);\n@@ -4232,3 +4242,3 @@\n-    pmull (v16, T1Q, v4, v0, T1D);\n-    pmull2(v17, T1Q, v4, v0, T2D);\n-    eor3(v4, T16B, v16, v17, v8);\n+    pmull (v23, T1Q, v3, v31, T1D);\n+    pmull2(v24, T1Q, v3, v31, T2D);\n+    eor3(v3, T16B, v23, v24, v7);\n@@ -4237,14 +4247,17 @@\n-    ldrq(v5, Address(table, 0x20));\n-    pmull (v10, T1Q, v1, v5, T1D);\n-    pmull2(v11, T1Q, v1, v5, T2D);\n-    eor3(v4, T16B, v4, v10, v11);\n-\n-    ldrq(v6, Address(table, 0x30));\n-    pmull (v12, T1Q, v2, v6, T1D);\n-    pmull2(v13, T1Q, v2, v6, T2D);\n-    eor3(v4, T16B, v4, v12, v13);\n-\n-    ldrq(v7, Address(table, 0x40));\n-    pmull (v14, T1Q, v3, v7, T1D);\n-    pmull2(v15, T1Q, v3, v7, T2D);\n-    eor3(v1, T16B, v4, v14, v15);\n+    \/\/ Use v17 for constants because v31 can be still in use.\n+    ldrq(v17, Address(table, 0x20));\n+    pmull (v25, T1Q, v0, v17, T1D);\n+    pmull2(v26, T1Q, v0, v17, T2D);\n+    eor3(v3, T16B, v3, v25, v26);\n+\n+    \/\/ Use v18 for constants because v17 can be still in use.\n+    ldrq(v18, Address(table, 0x30));\n+    pmull (v27, T1Q, v1, v18, T1D);\n+    pmull2(v28, T1Q, v1, v18, T2D);\n+    eor3(v3, T16B, v3, v27, v28);\n+\n+    \/\/ Use v19 for constants because v18 can be still in use.\n+    ldrq(v19, Address(table, 0x40));\n+    pmull (v29, T1Q, v2, v19, T1D);\n+    pmull2(v30, T1Q, v2, v19, T2D);\n+    eor3(v0, T16B, v3, v29, v30);\n@@ -4255,2 +4268,2 @@\n-    mov(tmp0, v1, D, 0);\n-    mov(tmp1, v1, D, 1);\n+    mov(tmp0, v0, D, 0);\n+    mov(tmp1, v0, D, 1);\n@@ -6260,1 +6273,1 @@\n-\/\/ Implements fast-locking.\n+\/\/ Implements lightweight-locking.\n@@ -6267,1 +6280,1 @@\n-void MacroAssembler::fast_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n@@ -6269,1 +6282,1 @@\n-  assert_different_registers(obj, hdr, t1, t2);\n+  assert_different_registers(obj, hdr, t1, t2, rscratch1);\n@@ -6281,0 +6294,1 @@\n+  \/\/ Clobbers rscratch1 when UseLSE is false\n@@ -6292,1 +6306,1 @@\n-\/\/ Implements fast-unlocking.\n+\/\/ Implements lightweight-unlocking.\n@@ -6299,1 +6313,1 @@\n-void MacroAssembler::fast_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n+void MacroAssembler::lightweight_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n@@ -6301,1 +6315,1 @@\n-  assert_different_registers(obj, hdr, t1, t2);\n+  assert_different_registers(obj, hdr, t1, t2, rscratch1);\n@@ -6341,0 +6355,1 @@\n+  \/\/ Clobbers rscratch1 when UseLSE is false\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":103,"deletions":88,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -1587,2 +1587,2 @@\n-  void fast_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n-  void fast_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n+  void lightweight_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n+  void lightweight_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3830,1 +3830,1 @@\n-  const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;\n+  const int entry_size = frame::interpreter_frame_monitor_size_in_bytes();\n@@ -3933,1 +3933,1 @@\n-  const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;\n+  const int entry_size = frame::interpreter_frame_monitor_size_in_bytes();\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2638,0 +2638,7 @@\n+  \/\/ There might be a volatile load before this Unsafe CAS.\n+  if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+    __ sync();\n+  } else {\n+    __ lwsync();\n+  }\n+\n@@ -2999,3 +3006,18 @@\n-  Register Rco = noreg;\n-  if (UseCompressedOops && data->is_oop()) {\n-    Rco = __ encode_heap_oop(Rtmp, data->as_register());\n+  Register Robj = noreg;\n+  if (data->is_oop()) {\n+    if (UseCompressedOops) {\n+      Robj = __ encode_heap_oop(Rtmp, data->as_register());\n+    } else {\n+      Robj = data->as_register();\n+      if (Robj == dest->as_register()) { \/\/ May happen with ZGC.\n+        __ mr(Rtmp, Robj);\n+        Robj = Rtmp;\n+      }\n+    }\n+  }\n+\n+  \/\/ There might be a volatile load before this Unsafe OP.\n+  if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+    __ sync();\n+  } else {\n+    __ lwsync();\n@@ -3021,0 +3043,1 @@\n+    assert_different_registers(Rptr, Rold, Robj);\n@@ -3022,2 +3045,1 @@\n-      assert_different_registers(Rptr, Rold, Rco);\n-      __ stwcx_(Rco, Rptr);\n+      __ stwcx_(Robj, Rptr);\n@@ -3026,7 +3048,0 @@\n-      Register Robj = data->as_register();\n-      assert_different_registers(Rptr, Rold, Rtmp);\n-      assert_different_registers(Rptr, Robj, Rtmp);\n-      if (Robj == Rold) { \/\/ May happen with ZGC.\n-        __ mr(Rtmp, Robj);\n-        Robj = Rtmp;\n-      }\n@@ -3060,0 +3075,6 @@\n+\n+  if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+    __ isync();\n+  } else {\n+    __ sync();\n+  }\n@@ -3144,1 +3165,1 @@\n-        __ andi_(R0, klass, TypeEntries::type_unknown);\n+        __ andi_(R0, tmp, TypeEntries::type_unknown);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":34,"deletions":13,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-    fast_lock(Roop, Rmark, Rscratch, slow_int);\n+    lightweight_lock(Roop, Rmark, Rscratch, slow_int);\n@@ -184,1 +184,1 @@\n-    fast_unlock(Roop, Rmark, slow_int);\n+    lightweight_unlock(Roop, Rmark, slow_int);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -366,1 +366,1 @@\n-      __ unlock_object(x15, x14, x10, *stub->entry());\n+      __ unlock_object(x15, x14, x10, x16, *stub->entry());\n@@ -1509,0 +1509,1 @@\n+  Register temp = op->scratch_opr()->as_register();\n@@ -1512,1 +1513,1 @@\n-      __ null_check(obj);\n+      __ null_check(obj, -1);\n@@ -1518,1 +1519,1 @@\n-    int null_check_offset = __ lock_object(hdr, obj, lock, *op->stub()->entry());\n+    int null_check_offset = __ lock_object(hdr, obj, lock, temp, *op->stub()->entry());\n@@ -1524,1 +1525,1 @@\n-    __ unlock_object(hdr, obj, lock, *op->stub()->entry());\n+    __ unlock_object(hdr, obj, lock, temp, *op->stub()->entry());\n@@ -1650,2 +1651,2 @@\n-      \/\/ There is a chance that the checks above (re-reading profiling\n-      \/\/ data from memory) fail if another thread has just set the\n+      \/\/ There is a chance that the checks above\n+      \/\/ fail if another thread has just set the\n@@ -1654,0 +1655,1 @@\n+      __ xorr(tmp, tmp, t1); \/\/ get back original value before XOR\n@@ -1680,0 +1682,4 @@\n+#ifdef ASSERT\n+    __ andi(tmp, tmp, TypeEntries::type_mask);\n+    __ verify_klass_ptr(tmp);\n+#endif\n@@ -1714,0 +1720,4 @@\n+#ifdef ASSERT\n+    __ andi(tmp, tmp, TypeEntries::type_mask);\n+    __ verify_klass_ptr(tmp);\n+#endif\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register temp, Label& slow_case) {\n@@ -55,1 +55,1 @@\n-  assert_different_registers(hdr, obj, disp_hdr);\n+  assert_different_registers(hdr, obj, disp_hdr, temp, t0, t1);\n@@ -68,2 +68,2 @@\n-    test_bit(t0, hdr, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n-    bnez(t0, slow_case, true \/* is_far *\/);\n+    test_bit(temp, hdr, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    bnez(temp, slow_case, true \/* is_far *\/);\n@@ -76,1 +76,1 @@\n-    fast_lock(obj, hdr, t0, t1, slow_case);\n+    lightweight_lock(obj, hdr, temp, t1, slow_case);\n@@ -86,2 +86,2 @@\n-    la(t1, Address(obj, hdr_offset));\n-    cmpxchgptr(hdr, disp_hdr, t1, t0, done, \/*fallthough*\/nullptr);\n+    la(temp, Address(obj, hdr_offset));\n+    cmpxchgptr(hdr, disp_hdr, temp, t1, done, \/*fallthough*\/nullptr);\n@@ -103,2 +103,2 @@\n-    mv(t0, aligned_mask - (int)os::vm_page_size());\n-    andr(hdr, hdr, t0);\n+    mv(temp, aligned_mask - (int)os::vm_page_size());\n+    andr(hdr, hdr, temp);\n@@ -118,1 +118,1 @@\n-void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n+void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Register temp, Label& slow_case) {\n@@ -121,1 +121,1 @@\n-  assert(hdr != obj && hdr != disp_hdr && obj != disp_hdr, \"registers must be different\");\n+  assert_different_registers(hdr, obj, disp_hdr, temp, t0, t1);\n@@ -138,3 +138,3 @@\n-    test_bit(t0, hdr, exact_log2(markWord::monitor_value));\n-    bnez(t0, slow_case, \/* is_far *\/ true);\n-    fast_unlock(obj, hdr, t0, t1, slow_case);\n+    test_bit(temp, hdr, exact_log2(markWord::monitor_value));\n+    bnez(temp, slow_case, \/* is_far *\/ true);\n+    lightweight_unlock(obj, hdr, temp, t1, slow_case);\n@@ -148,2 +148,2 @@\n-      la(t0, Address(obj, hdr_offset));\n-      cmpxchgptr(disp_hdr, hdr, t0, t1, done, &slow_case);\n+      la(temp, Address(obj, hdr_offset));\n+      cmpxchgptr(disp_hdr, hdr, temp, t1, done, &slow_case);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  \/\/ temp : temporary register, must not be scratch register t0 or t1\n@@ -63,1 +64,1 @@\n-  int lock_object  (Register swap, Register obj, Register disp_hdr, Label& slow_case);\n+  int lock_object(Register swap, Register obj, Register disp_hdr, Register temp, Label& slow_case);\n@@ -69,1 +70,2 @@\n-  void unlock_object(Register swap, Register obj, Register lock, Label& slow_case);\n+  \/\/ temp : temporary register, must not be scratch register t0 or t1\n+  void unlock_object(Register swap, Register obj, Register lock, Register temp, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -86,1 +86,1 @@\n-void C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n+void C1_MacroAssembler::lock_object(Register Rmark, Register Roop, Register Rbox, Label& slow_case) {\n@@ -88,2 +88,5 @@\n-  assert_different_registers(hdr, obj, disp_hdr);\n-  verify_oop(obj, FILE_AND_LINE);\n+  const Register tmp   = Z_R1_scratch;\n+\n+  assert_different_registers(Rmark, Roop, Rbox, tmp);\n+\n+  verify_oop(Roop, FILE_AND_LINE);\n@@ -93,1 +96,1 @@\n-  z_lg(hdr, Address(obj, hdr_offset));\n+  z_lg(Rmark, Address(Roop, hdr_offset));\n@@ -96,1 +99,1 @@\n-  z_stg(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n+  z_stg(Roop, Address(Rbox, BasicObjectLock::obj_offset()));\n@@ -99,3 +102,3 @@\n-    load_klass(Z_R1_scratch, obj);\n-    testbit(Address(Z_R1_scratch, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n-    z_btrue(slow_case);\n+    load_klass(tmp, Roop);\n+    testbit(Address(tmp, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    branch_optimized(Assembler::bcondAllOne, slow_case);\n@@ -107,1 +110,1 @@\n-    Unimplemented();\n+    lightweight_lock(Roop, Rmark, tmp, slow_case);\n@@ -111,1 +114,1 @@\n-    z_oill(hdr, markWord::unlocked_value);\n+    z_oill(Rmark, markWord::unlocked_value);\n@@ -113,1 +116,1 @@\n-    z_stg(hdr, Address(disp_hdr, (intptr_t) 0));\n+    z_stg(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n@@ -117,1 +120,1 @@\n-    z_csg(hdr, disp_hdr, hdr_offset, obj);\n+    z_csg(Rmark, Rbox, hdr_offset, Roop);\n@@ -120,1 +123,1 @@\n-    \/\/ If the object header was not the same, it is now in the hdr register.\n+    \/\/ If the object header was not the same, it is now in the Rmark register.\n@@ -123,3 +126,3 @@\n-    \/\/ 1) (hdr & markWord::lock_mask_in_place) == 0\n-    \/\/ 2) rsp <= hdr\n-    \/\/ 3) hdr <= rsp + page_size\n+    \/\/ 1) (Rmark & markWord::lock_mask_in_place) == 0\n+    \/\/ 2) rsp <= Rmark\n+    \/\/ 3) Rmark <= rsp + page_size\n@@ -129,1 +132,1 @@\n-    \/\/ (hdr - Z_SP) & (~(page_size-1) | markWord::lock_mask_in_place)\n+    \/\/ (Rmark - Z_SP) & (~(page_size-1) | markWord::lock_mask_in_place)\n@@ -133,1 +136,1 @@\n-    z_sgr(hdr, Z_SP);\n+    z_sgr(Rmark, Z_SP);\n@@ -136,1 +139,1 @@\n-    z_ngr(hdr, Z_R0_scratch); \/\/ AND sets CC (result eq\/ne 0).\n+    z_ngr(Rmark, Z_R0_scratch); \/\/ AND sets CC (result eq\/ne 0).\n@@ -138,2 +141,2 @@\n-    \/\/ location (null in the displaced hdr location indicates recursive locking).\n-    z_stg(hdr, Address(disp_hdr, (intptr_t) 0));\n+    \/\/ location (null in the displaced Rmark location indicates recursive locking).\n+    z_stg(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n@@ -147,2 +150,1 @@\n-void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n-  const int aligned_mask = BytesPerWord -1;\n+void C1_MacroAssembler::unlock_object(Register Rmark, Register Roop, Register Rbox, Label& slow_case) {\n@@ -150,1 +152,3 @@\n-  assert_different_registers(hdr, obj, disp_hdr);\n+\n+  assert_different_registers(Rmark, Roop, Rbox);\n+\n@@ -155,2 +159,2 @@\n-    z_ltg(hdr, Address(disp_hdr, (intptr_t) 0));\n-    \/\/ If the loaded hdr is null we had recursive locking, and we are done.\n+    z_ltg(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n+    \/\/ If the loaded Rmark is null we had recursive locking, and we are done.\n@@ -161,2 +165,2 @@\n-  z_lg(obj, Address(disp_hdr, BasicObjectLock::obj_offset()));\n-  verify_oop(obj, FILE_AND_LINE);\n+  z_lg(Roop, Address(Rbox, BasicObjectLock::obj_offset()));\n+  verify_oop(Roop, FILE_AND_LINE);\n@@ -165,2 +169,7 @@\n-    Unimplemented();\n-  } else {\n+    const Register tmp = Z_R1_scratch;\n+    z_lg(Rmark, Address(Roop, hdr_offset));\n+    z_lgr(tmp, Rmark);\n+    z_nill(tmp, markWord::monitor_value);\n+    branch_optimized(Assembler::bcondNotZero, slow_case);\n+    lightweight_unlock(Roop, Rmark, tmp, slow_case);\n+  } else if (LockingMode == LM_LEGACY) {\n@@ -170,1 +179,1 @@\n-    z_csg(disp_hdr, hdr, hdr_offset, obj);\n+    z_csg(Rbox, Rmark, hdr_offset, Roop);\n@@ -174,1 +183,1 @@\n-    \/\/ done\n+  \/\/ done\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":42,"deletions":33,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2016 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n@@ -44,5 +44,5 @@\n-  \/\/ hdr     : Used to hold locked markWord to be CASed into obj, contents destroyed.\n-  \/\/ obj     : Must point to the object to lock, contents preserved.\n-  \/\/ disp_hdr: Must point to the displaced header location, contents preserved.\n-  \/\/ Returns code offset at which to add null check debug information.\n-  void lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case);\n+  \/\/ Rmark        : Used to hold locked markWord to be CASed into obj, contents destroyed.\n+  \/\/ Roop         : Must point to the object to lock, contents preserved.\n+  \/\/ Rbox         : Must point to the displaced header location, contents preserved.\n+  \/\/ Z_R1_scratch : Used as temp and will be killed\n+  void lock_object(Register Rmark, Register Roop, Register Rbox, Label& slow_case);\n@@ -51,4 +51,5 @@\n-  \/\/ hdr     : Used to hold original markWord to be CASed back into obj, contents destroyed.\n-  \/\/ obj     : Must point to the object to lock, contents preserved.\n-  \/\/ disp_hdr: Must point to the displaced header location, contents destroyed.\n-  void unlock_object(Register hdr, Register obj, Register lock, Label& slow_case);\n+  \/\/ Rmark        : Used to hold original markWord to be CASed back into obj, contents destroyed.\n+  \/\/ Roop         : Must point to the object to lock, contents preserved.\n+  \/\/ Rbox         : Must point to the displaced header location, contents destroyed.\n+  \/\/ Z_R1_scratch : Used as temp and will be killed\n+  void unlock_object(Register Rmark, Register Roop, Register Rbox, Label& slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.hpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1716,1 +1716,1 @@\n-  __ cmpptr(obj, NULL_WORD);\n+  __ testptr(obj, obj);\n@@ -1795,1 +1795,1 @@\n-        __ cmpl(klass_RInfo, 0);\n+        __ testl(klass_RInfo, klass_RInfo);\n@@ -1809,1 +1809,1 @@\n-      __ cmpl(k_RInfo, 0);\n+      __ testl(k_RInfo, k_RInfo);\n@@ -1862,1 +1862,1 @@\n-    __ cmpptr(value, NULL_WORD);\n+    __ testptr(value, value);\n@@ -1893,1 +1893,1 @@\n-    __ cmpl(k_RInfo, 0);\n+    __ testl(k_RInfo, k_RInfo);\n@@ -2050,1 +2050,1 @@\n-    __ jcc (acond, skip);\n+    __ jccb(acond, skip);\n@@ -2667,1 +2667,6 @@\n-        __ cmpl(reg1, c->as_jint());\n+        jint i = c->as_jint();\n+        if (i == 0) {\n+          __ testl(reg1, reg1);\n+        } else {\n+          __ cmpl(reg1, i);\n+        }\n@@ -2673,1 +2678,1 @@\n-          __ cmpptr(reg1, NULL_WORD);\n+          __ testptr(reg1, reg1);\n@@ -2681,1 +2686,1 @@\n-          __ cmpptr(reg1, NULL_WORD);\n+          __ testptr(reg1, reg1);\n@@ -3150,1 +3155,1 @@\n-    __ cmpl(rax, 0);\n+    __ testl(rax, rax);\n@@ -3284,1 +3289,1 @@\n-      __ cmpl(src, 0);\n+      __ testl(src, src);\n@@ -3643,2 +3648,13 @@\n-  if (tmp != obj) {\n-    __ mov(tmp, obj);\n+#ifdef ASSERT\n+  if (obj == tmp) {\n+#ifdef _LP64\n+    assert_different_registers(obj, rscratch1, mdo_addr.base(), mdo_addr.index());\n+#else\n+    assert_different_registers(obj, mdo_addr.base(), mdo_addr.index());\n+#endif\n+  } else {\n+#ifdef _LP64\n+    assert_different_registers(obj, tmp, rscratch1, mdo_addr.base(), mdo_addr.index());\n+#else\n+    assert_different_registers(obj, tmp, mdo_addr.base(), mdo_addr.index());\n+#endif\n@@ -3646,0 +3662,1 @@\n+#endif\n@@ -3647,1 +3664,1 @@\n-    __ testptr(tmp, tmp);\n+    __ testptr(obj, obj);\n@@ -3650,0 +3667,8 @@\n+      __ testptr(mdo_addr, TypeEntries::null_seen);\n+#ifndef ASSERT\n+      __ jccb(Assembler::notZero, next); \/\/ already set\n+#else\n+      __ jcc(Assembler::notZero, next); \/\/ already set\n+#endif\n+      \/\/ atomic update to prevent overwriting Klass* with 0\n+      __ lock();\n@@ -3660,1 +3685,1 @@\n-    __ testptr(tmp, tmp);\n+    __ testptr(obj, obj);\n@@ -3672,1 +3697,1 @@\n-      __ load_klass(tmp, tmp, tmp_load_klass);\n+      __ load_klass(tmp, obj, tmp_load_klass);\n@@ -3687,1 +3712,1 @@\n-          __ load_klass(tmp, tmp, tmp_load_klass);\n+          __ load_klass(tmp, obj, tmp_load_klass);\n@@ -3689,1 +3714,3 @@\n-\n+#ifdef _LP64\n+        __ mov(rscratch1, tmp); \/\/ save original value before XOR\n+#endif\n@@ -3700,4 +3727,3 @@\n-          __ cmpptr(mdo_addr, 0);\n-          __ jccb(Assembler::equal, none);\n-          __ cmpptr(mdo_addr, TypeEntries::null_seen);\n-          __ jccb(Assembler::equal, none);\n+          __ testptr(mdo_addr, TypeEntries::type_mask);\n+          __ jccb(Assembler::zero, none);\n+#ifdef _LP64\n@@ -3707,0 +3733,1 @@\n+          __ mov(tmp, rscratch1); \/\/ get back original value before XOR\n@@ -3710,0 +3737,1 @@\n+#endif\n@@ -3715,2 +3743,1 @@\n-        __ movptr(tmp, mdo_addr);\n-        __ testptr(tmp, TypeEntries::type_unknown);\n+        __ testptr(mdo_addr, TypeEntries::type_unknown);\n@@ -3729,0 +3756,4 @@\n+#ifdef ASSERT\n+        __ andptr(tmp, TypeEntries::type_klass_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n@@ -3743,4 +3774,2 @@\n-          __ cmpptr(mdo_addr, 0);\n-          __ jcc(Assembler::equal, ok);\n-          __ cmpptr(mdo_addr, TypeEntries::null_seen);\n-          __ jcc(Assembler::equal, ok);\n+          __ testptr(mdo_addr, TypeEntries::type_mask);\n+          __ jcc(Assembler::zero, ok);\n@@ -3762,0 +3791,4 @@\n+#ifdef ASSERT\n+        __ andptr(tmp, TypeEntries::type_klass_mask);\n+        __ verify_klass_ptr(tmp);\n+#endif\n@@ -3766,2 +3799,1 @@\n-        __ movptr(tmp, mdo_addr);\n-        __ testptr(tmp, TypeEntries::type_unknown);\n+        __ testptr(mdo_addr, TypeEntries::type_unknown);\n@@ -3773,2 +3805,1 @@\n-\n-    __ bind(next);\n+  __ bind(next);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":63,"deletions":32,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    fast_lock_impl(obj, hdr, thread, tmp, slow_case);\n+    lightweight_lock(obj, hdr, thread, tmp, slow_case);\n@@ -138,1 +138,1 @@\n-    fast_unlock_impl(obj, disp_hdr, hdr, slow_case);\n+    lightweight_unlock(obj, disp_hdr, hdr, slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -624,1 +624,1 @@\n-    fast_lock_impl(objReg, tmpReg, thread, scrReg, NO_COUNT);\n+    lightweight_lock(objReg, tmpReg, thread, scrReg, NO_COUNT);\n@@ -928,1 +928,1 @@\n-      fast_unlock_impl(objReg, boxReg, tmpReg, NO_COUNT);\n+      lightweight_unlock(objReg, boxReg, tmpReg, NO_COUNT);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -9861,1 +9861,1 @@\n-\/\/ Implements fast-locking.\n+\/\/ Implements lightweight-locking.\n@@ -9869,1 +9869,1 @@\n-void MacroAssembler::fast_lock_impl(Register obj, Register hdr, Register thread, Register tmp, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register obj, Register hdr, Register thread, Register tmp, Label& slow) {\n@@ -9897,1 +9897,1 @@\n-\/\/ Implements fast-unlocking.\n+\/\/ Implements lightweight-unlocking.\n@@ -9904,1 +9904,1 @@\n-void MacroAssembler::fast_unlock_impl(Register obj, Register hdr, Register tmp, Label& slow) {\n+void MacroAssembler::lightweight_unlock(Register obj, Register hdr, Register tmp, Label& slow) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -890,0 +890,1 @@\n+  void testptr(Address src, int32_t imm32) {  LP64_ONLY(testq(src, imm32)) NOT_LP64(testl(src, imm32)); }\n@@ -2036,2 +2037,2 @@\n-  void fast_lock_impl(Register obj, Register hdr, Register thread, Register tmp, Label& slow);\n-  void fast_unlock_impl(Register obj, Register hdr, Register tmp, Label& slow);\n+  void lightweight_lock(Register obj, Register hdr, Register thread, Register tmp, Label& slow);\n+  void lightweight_unlock(Register obj, Register hdr, Register tmp, Label& slow);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4340,1 +4340,1 @@\n-  const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;\n+  const int entry_size = frame::interpreter_frame_monitor_size_in_bytes();\n@@ -4437,1 +4437,1 @@\n-  const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;\n+  const int entry_size = frame::interpreter_frame_monitor_size_in_bytes();\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+ , _loop(nullptr)\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -373,1 +373,1 @@\n-  if (ent->is_jar() && !ent->is_signed() && ent->manifest() != nullptr) {\n+  if (ent->is_jar() && ent->manifest() != nullptr) {\n@@ -627,23 +627,0 @@\n-\n-  \/\/ The return value indicates if the JAR is signed or not\n-  bool check_is_signed() {\n-    u1* attr = _current;\n-    bool isSigned = false;\n-    while (_current < _buffer_end) {\n-      if (*_current == '\\n') {\n-        *_current = '\\0';\n-        u1* value = (u1*)strchr((char*)attr, ':');\n-        if (value != nullptr) {\n-          assert(*(value+1) == ' ', \"Unrecognized format\" );\n-          if (strstr((char*)attr, \"-Digest\") != nullptr) {\n-            isSigned = true;\n-            break;\n-          }\n-        }\n-        *_current = '\\n'; \/\/ restore\n-        attr = _current + 1;\n-      }\n-      _current ++;\n-    }\n-    return isSigned;\n-  }\n@@ -662,12 +639,8 @@\n-    if (stream->check_is_signed()) {\n-      ent->set_is_signed();\n-    } else {\n-      \/\/ Copy the manifest into the shared archive\n-      manifest = ClassLoaderExt::read_raw_manifest(THREAD, cpe, &manifest_size);\n-      Array<u1>* buf = MetadataFactory::new_array<u1>(loader_data,\n-                                                      manifest_size,\n-                                                      CHECK);\n-      char* p = (char*)(buf->data());\n-      memcpy(p, manifest, manifest_size);\n-      ent->set_manifest(buf);\n-    }\n+    \/\/ Copy the manifest into the shared archive\n+    manifest = ClassLoaderExt::read_raw_manifest(THREAD, cpe, &manifest_size);\n+    Array<u1>* buf = MetadataFactory::new_array<u1>(loader_data,\n+                                                    manifest_size,\n+                                                    CHECK);\n+    char* p = (char*)(buf->data());\n+    memcpy(p, manifest, manifest_size);\n+    ent->set_manifest(buf);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":9,"deletions":36,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-    signed_jar_entry,\n@@ -93,4 +92,0 @@\n-  bool is_signed()        const { return _type == signed_jar_entry; }\n-  void set_is_signed() {\n-    _type = signed_jar_entry;\n-  }\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -180,0 +180,1 @@\n+  void push_contents_bounded(oop obj, HeapWord* left, HeapWord* right);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -134,0 +134,5 @@\n+inline void PSPromotionManager::push_contents_bounded(oop obj, HeapWord* left, HeapWord* right) {\n+  PSPushContentsClosure pcc(this);\n+  obj->oop_iterate(&pcc, MemRegion(left, right));\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -974,0 +974,3 @@\n+      if (ZapUnusedHeapArea) {\n+        SpaceMangler::mangle_region(MemRegion(r->top(), r->end()));\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -844,15 +844,5 @@\n-    \/\/ strategy is to try again, as long as GC makes progress.\n-    \/\/\n-    \/\/ Then, we need to make sure the allocation was retried after at least one\n-    \/\/ Full GC, which means we want to try more than ShenandoahFullGCThreshold times.\n-\n-    size_t tries = 0;\n-\n-    while (result == nullptr && _progress_last_gc.is_set()) {\n-      tries++;\n-      control_thread()->handle_alloc_failure(req);\n-      result = allocate_memory_under_lock(req, in_new_region);\n-    }\n-\n-    while (result == nullptr && tries <= ShenandoahFullGCThreshold) {\n-      tries++;\n+    \/\/ strategy is to try again, as long as GC makes progress (or until at least\n+    \/\/ one full GC has completed).\n+    size_t original_count = shenandoah_policy()->full_gc_count();\n+    while (result == nullptr\n+        && (_progress_last_gc.is_set() || original_count == shenandoah_policy()->full_gc_count())) {\n@@ -862,1 +852,0 @@\n-\n@@ -980,1 +969,1 @@\n-      ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);\n+      ShenandoahSuspendibleThreadSetJoiner stsj;\n@@ -1144,7 +1133,3 @@\n-  if (ShenandoahElasticTLAB) {\n-    \/\/ With Elastic TLABs, return the max allowed size, and let the allocation path\n-    \/\/ figure out the safe size for current allocation.\n-    return ShenandoahHeapRegion::max_tlab_size_bytes();\n-  } else {\n-    return MIN2(_free_set->unsafe_peek_free(), ShenandoahHeapRegion::max_tlab_size_bytes());\n-  }\n+  \/\/ Return the max allowed size, and let the allocation path\n+  \/\/ figure out the safe size for current allocation.\n+  return ShenandoahHeapRegion::max_tlab_size_bytes();\n@@ -1870,8 +1855,0 @@\n-address ShenandoahHeap::cancelled_gc_addr() {\n-  return (address) ShenandoahHeap::heap()->_cancelled_gc.addr_of();\n-}\n-\n-address ShenandoahHeap::gc_state_addr() {\n-  return (address) ShenandoahHeap::heap()->_gc_state.addr_of();\n-}\n-\n@@ -2018,1 +1995,1 @@\n-      ShenandoahSuspendibleThreadSetJoiner stsj(ShenandoahSuspendibleWorkers);\n+      ShenandoahSuspendibleThreadSetJoiner stsj;\n@@ -2200,3 +2177,1 @@\n-  if (ShenandoahSuspendibleWorkers) {\n-    SuspendibleThreadSet::synchronize();\n-  }\n+  SuspendibleThreadSet::synchronize();\n@@ -2206,3 +2181,1 @@\n-  if (ShenandoahSuspendibleWorkers) {\n-    SuspendibleThreadSet::desynchronize();\n-  }\n+  SuspendibleThreadSet::desynchronize();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":12,"deletions":39,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -247,1 +247,1 @@\n-  if (sts_active && ShenandoahSuspendibleWorkers && !cancelled_gc()) {\n+  if (sts_active && !cancelled_gc()) {\n@@ -400,4 +400,0 @@\n-inline bool ShenandoahHeap::is_gc_in_progress_mask(uint mask) const {\n-  return _gc_state.is_set(mask);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -229,0 +230,1 @@\n+  AARCH64_ONLY(fatal(\"Should use ZLoadBarrierStubC2Aarch64::create\"));\n@@ -278,0 +280,1 @@\n+  AARCH64_ONLY(fatal(\"Should use ZStoreBarrierStubC2Aarch64::create\"));\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+    _is_active(false),\n@@ -106,0 +107,14 @@\n+void ZRelocateQueue::activate(uint nworkers) {\n+  _is_active = true;\n+  join(nworkers);\n+}\n+\n+void ZRelocateQueue::deactivate() {\n+  Atomic::store(&_is_active, false);\n+  clear();\n+}\n+\n+bool ZRelocateQueue::is_active() const {\n+  return Atomic::load(&_is_active);\n+}\n+\n@@ -330,1 +345,1 @@\n-  _queue.join(workers()->active_workers());\n+  _queue.activate(workers()->active_workers());\n@@ -1092,0 +1107,3 @@\n+\n+    \/\/ Signal that we're not using the queue anymore. Used mostly for asserts.\n+    _queue->deactivate();\n@@ -1236,2 +1254,0 @@\n-\n-  _queue.clear();\n@@ -1320,0 +1336,4 @@\n+\n+bool ZRelocate::is_queue_active() const {\n+  return _queue.is_active();\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":23,"deletions":3,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -343,1 +343,1 @@\n-      _fillerArrayKlassObj = TypeArrayKlass::create_klass(T_INT, \"Ljdk\/internal\/vm\/FillerArray;\", CHECK);\n+      _fillerArrayKlassObj = TypeArrayKlass::create_klass(T_INT, \"[Ljdk\/internal\/vm\/FillerElement;\", CHECK);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -554,1 +554,0 @@\n-  ttyLocker ttyl;\n@@ -559,6 +558,6 @@\n-  if (xtty != nullptr) {\n-    xtty->head(\"ideal compile_id='%d'%s compile_phase='%s'\",\n-               compile_id(),\n-               is_osr_compilation() ? \" compile_kind='osr'\" : \"\",\n-               phase_name);\n-  }\n+\n+  \/\/ Node dumping can cause a safepoint, which can break the tty lock.\n+  \/\/ Buffer all node dumps, so that all safepoints happen before we lock.\n+  ResourceMark rm;\n+  stringStream ss;\n+\n@@ -566,1 +565,1 @@\n-    tty->print_cr(\"AFTER: %s\", phase_name);\n+    ss.print_cr(\"AFTER: %s\", phase_name);\n@@ -568,1 +567,1 @@\n-    root()->dump_bfs(MaxNodeLimit, nullptr, \"+S$\");\n+    root()->dump_bfs(MaxNodeLimit, nullptr, \"+S$\", &ss);\n@@ -571,1 +570,1 @@\n-    _output->print_scheduling();\n+    _output->print_scheduling(&ss);\n@@ -574,0 +573,3 @@\n+  \/\/ Check that the lock is not broken by a safepoint.\n+  NoSafepointVerifier nsv;\n+  ttyLocker ttyl;\n@@ -575,0 +577,5 @@\n+    xtty->head(\"ideal compile_id='%d'%s compile_phase='%s'\",\n+               compile_id(),\n+               is_osr_compilation() ? \" compile_kind='osr'\" : \"\",\n+               phase_name);\n+    xtty->print(\"%s\", ss.as_string()); \/\/ print to tty would use xml escape encoding\n@@ -576,0 +583,2 @@\n+  } else {\n+    tty->print(\"%s\", ss.as_string());\n@@ -829,2 +838,2 @@\n-  if (StressLCM || StressGCM || StressIGVN || StressCCP) {\n-    if (FLAG_IS_DEFAULT(StressSeed) || (FLAG_IS_ERGO(StressSeed) && RepeatCompilation)) {\n+  if (StressLCM || StressGCM || StressIGVN || StressCCP || StressIncrementalInlining) {\n+    if (FLAG_IS_DEFAULT(StressSeed) || (FLAG_IS_ERGO(StressSeed) && directive->RepeatCompilationOption)) {\n@@ -2237,0 +2246,2 @@\n+  if (failing())  return;\n+\n@@ -2247,1 +2258,3 @@\n-    if (AlwaysIncrementalInline) {\n+    if (failing())  return;\n+\n+    if (AlwaysIncrementalInline || StressIncrementalInlining) {\n@@ -2262,0 +2275,2 @@\n+  if (failing())  return;\n+\n@@ -2266,0 +2281,2 @@\n+  if (failing())  return;\n+\n@@ -2271,1 +2288,1 @@\n-\n+    if (failing())  return;\n@@ -2291,0 +2308,2 @@\n+  if (failing())  return;\n+\n@@ -2400,0 +2419,2 @@\n+  if (failing())  return;\n+\n@@ -2438,0 +2459,1 @@\n+    if (failing())  return;\n@@ -4914,0 +4936,1 @@\n+      if (failing())  return;\n@@ -4984,2 +5007,2 @@\n-void NodeCloneInfo::dump() const {\n-  tty->print(\" {%d:%d} \", idx(), gen());\n+void NodeCloneInfo::dump_on(outputStream* st) const {\n+  st->print(\" {%d:%d} \", idx(), gen());\n@@ -5032,1 +5055,1 @@\n-void CloneMap::dump(node_idx_t key) const {\n+void CloneMap::dump(node_idx_t key, outputStream* st) const {\n@@ -5036,1 +5059,1 @@\n-    ni.dump();\n+    ni.dump_on(st);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":41,"deletions":18,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -1111,0 +1111,1 @@\n+  clear_upper_avx();\n@@ -1365,0 +1366,1 @@\n+  clear_upper_avx();\n@@ -2867,0 +2869,1 @@\n+  Node* vt_oop = _gvn.transform(must_be_not_null(argument(0), true)); \/\/ VirtualThread this argument\n@@ -2875,0 +2878,1 @@\n+    sync_kit(ideal);\n@@ -2877,3 +2881,0 @@\n-    Node* vt_oop = _gvn.transform(must_be_not_null(argument(0), true)); \/\/ VirtualThread this argument\n-\n-    sync_kit(ideal);\n@@ -2884,1 +2885,0 @@\n-    Node* vt_oop = _gvn.transform(argument(0)); \/\/ this argument - VirtualThread oop\n@@ -4997,2 +4997,2 @@\n-      Node* obj_size  = nullptr;\n-      Node* alloc_obj = new_array(obj_klass, obj_length, 0, &obj_size, \/*deoptimize_on_exception=*\/true);\n+      Node* array_size = nullptr; \/\/ Size of the array without object alignment padding.\n+      Node* alloc_obj = new_array(obj_klass, obj_length, 0, &array_size, \/*deoptimize_on_exception=*\/true);\n@@ -5031,1 +5031,1 @@\n-        copy_to_clone(obj, alloc_obj, obj_size, true);\n+        copy_to_clone(obj, alloc_obj, array_size, true);\n@@ -5071,1 +5071,1 @@\n-      Node* obj_size  = nullptr;\n+      Node* obj_size = nullptr; \/\/ Total object size, including object alignment padding.\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+  { Bad,             T_ARRAY,      \"interfaces:\",   false, Node::NotAMachineReg, relocInfo::none          },  \/\/ Interfaces\n@@ -123,2 +124,2 @@\n-const TypePtr::InterfaceSet* TypeAryPtr::_array_interfaces = nullptr;\n-const TypePtr::InterfaceSet* TypeAryKlassPtr::_array_interfaces = nullptr;\n+const TypeInterfaces* TypeAryPtr::_array_interfaces = nullptr;\n+const TypeInterfaces* TypeAryKlassPtr::_array_interfaces = nullptr;\n@@ -574,1 +575,1 @@\n-  TypeAryPtr::_array_interfaces = new TypePtr::InterfaceSet(&array_interfaces);\n+  TypeAryPtr::_array_interfaces = TypeInterfaces::make(&array_interfaces);\n@@ -3255,2 +3256,2 @@\n-TypePtr::InterfaceSet::InterfaceSet()\n-        : _list(Compile::current()->type_arena(), 0, 0, nullptr),\n+TypeInterfaces::TypeInterfaces()\n+        : Type(Interfaces), _list(Compile::current()->type_arena(), 0, 0, nullptr),\n@@ -3261,2 +3262,2 @@\n-TypePtr::InterfaceSet::InterfaceSet(GrowableArray<ciInstanceKlass*>* interfaces)\n-        : _list(Compile::current()->type_arena(), interfaces->length(), 0, nullptr),\n+TypeInterfaces::TypeInterfaces(GrowableArray<ciInstanceKlass*>* interfaces)\n+        : Type(Interfaces), _list(Compile::current()->type_arena(), interfaces->length(), 0, nullptr),\n@@ -3270,1 +3271,6 @@\n-void TypePtr::InterfaceSet::initialize() {\n+const TypeInterfaces* TypeInterfaces::make(GrowableArray<ciInstanceKlass*>* interfaces) {\n+  TypeInterfaces* result = (interfaces == nullptr) ? new TypeInterfaces() : new TypeInterfaces(interfaces);\n+  return (const TypeInterfaces*)result->hashcons();\n+}\n+\n+void TypeInterfaces::initialize() {\n@@ -3276,1 +3282,1 @@\n-int TypePtr::InterfaceSet::compare(ciKlass* const& k1, ciKlass* const& k2) {\n+int TypeInterfaces::compare(ciInstanceKlass* const& k1, ciInstanceKlass* const& k2) {\n@@ -3285,1 +3291,1 @@\n-void TypePtr::InterfaceSet::add(ciKlass* interface) {\n+void TypeInterfaces::add(ciInstanceKlass* interface) {\n@@ -3291,7 +3297,3 @@\n-void TypePtr::InterfaceSet::raw_add(ciKlass* interface) {\n-  assert(interface->is_interface(), \"for interfaces only\");\n-  _list.push(interface);\n-}\n-\n-bool TypePtr::InterfaceSet::eq(const InterfaceSet& other) const {\n-  if (_list.length() != other._list.length()) {\n+bool TypeInterfaces::eq(const Type* t) const {\n+  const TypeInterfaces* other = (const TypeInterfaces*)t;\n+  if (_list.length() != other->_list.length()) {\n@@ -3302,1 +3304,1 @@\n-    ciKlass* k2 = other._list.at(i);\n+    ciKlass* k2 = other->_list.at(i);\n@@ -3310,1 +3312,1 @@\n-bool TypePtr::InterfaceSet::eq(ciInstanceKlass* k) const {\n+bool TypeInterfaces::eq(ciInstanceKlass* k) const {\n@@ -3312,1 +3314,1 @@\n-  GrowableArray<ciInstanceKlass *>* interfaces = k->as_instance_klass()->transitive_interfaces();\n+  GrowableArray<ciInstanceKlass *>* interfaces = k->transitive_interfaces();\n@@ -3318,1 +3320,1 @@\n-    _list.find_sorted<ciKlass*, compare>(interfaces->at(i), found);\n+    _list.find_sorted<ciInstanceKlass*, compare>(interfaces->at(i), found);\n@@ -3327,1 +3329,1 @@\n-uint TypePtr::InterfaceSet::hash() const {\n+uint TypeInterfaces::hash() const {\n@@ -3332,1 +3334,5 @@\n-void TypePtr::InterfaceSet::compute_hash() {\n+const Type* TypeInterfaces::xdual() const {\n+  return this;\n+}\n+\n+void TypeInterfaces::compute_hash() {\n@@ -3341,1 +3347,1 @@\n-static int compare_interfaces(ciKlass** k1, ciKlass** k2) {\n+static int compare_interfaces(ciInstanceKlass** k1, ciInstanceKlass** k2) {\n@@ -3345,1 +3351,1 @@\n-void TypePtr::InterfaceSet::dump(outputStream* st) const {\n+void TypeInterfaces::dump(outputStream* st) const {\n@@ -3351,1 +3357,1 @@\n-  GrowableArray<ciKlass*> interfaces;\n+  GrowableArray<ciInstanceKlass*> interfaces;\n@@ -3366,1 +3372,1 @@\n-void TypePtr::InterfaceSet::verify() const {\n+void TypeInterfaces::verify() const {\n@@ -3368,2 +3374,2 @@\n-    ciKlass* k1 = _list.at(i-1);\n-    ciKlass* k2 = _list.at(i);\n+    ciInstanceKlass* k1 = _list.at(i-1);\n+    ciInstanceKlass* k2 = _list.at(i);\n@@ -3376,2 +3382,2 @@\n-TypePtr::InterfaceSet TypeOopPtr::InterfaceSet::union_with(const InterfaceSet& other) const {\n-  InterfaceSet result;\n+const TypeInterfaces* TypeInterfaces::union_with(const TypeInterfaces* other) const {\n+  GrowableArray<ciInstanceKlass*> result_list;\n@@ -3380,1 +3386,1 @@\n-  while (i < _list.length() || j < other._list.length()) {\n+  while (i < _list.length() || j < other->_list.length()) {\n@@ -3382,3 +3388,3 @@\n-           (j >= other._list.length() ||\n-            compare(_list.at(i), other._list.at(j)) < 0)) {\n-      result.raw_add(_list.at(i));\n+           (j >= other->_list.length() ||\n+            compare(_list.at(i), other->_list.at(j)) < 0)) {\n+      result_list.push(_list.at(i));\n@@ -3387,1 +3393,1 @@\n-    while (j < other._list.length() &&\n+    while (j < other->_list.length() &&\n@@ -3389,2 +3395,2 @@\n-            compare(other._list.at(j), _list.at(i)) < 0)) {\n-      result.raw_add(other._list.at(j));\n+            compare(other->_list.at(j), _list.at(i)) < 0)) {\n+      result_list.push(other->_list.at(j));\n@@ -3394,3 +3400,3 @@\n-        j < other._list.length() &&\n-        _list.at(i) == other._list.at(j)) {\n-      result.raw_add(_list.at(i));\n+        j < other->_list.length() &&\n+        _list.at(i) == other->_list.at(j)) {\n+      result_list.push(_list.at(i));\n@@ -3401,1 +3407,1 @@\n-  result.initialize();\n+  const TypeInterfaces* result = TypeInterfaces::make(&result_list);\n@@ -3403,1 +3409,1 @@\n-  result.verify();\n+  result->verify();\n@@ -3405,1 +3411,1 @@\n-    assert(result._list.contains(_list.at(i)), \"missing\");\n+    assert(result->_list.contains(_list.at(i)), \"missing\");\n@@ -3407,2 +3413,2 @@\n-  for (int i = 0; i < other._list.length(); i++) {\n-    assert(result._list.contains(other._list.at(i)), \"missing\");\n+  for (int i = 0; i < other->_list.length(); i++) {\n+    assert(result->_list.contains(other->_list.at(i)), \"missing\");\n@@ -3410,2 +3416,2 @@\n-  for (int i = 0; i < result._list.length(); i++) {\n-    assert(_list.contains(result._list.at(i)) || other._list.contains(result._list.at(i)), \"missing\");\n+  for (int i = 0; i < result->_list.length(); i++) {\n+    assert(_list.contains(result->_list.at(i)) || other->_list.contains(result->_list.at(i)), \"missing\");\n@@ -3417,2 +3423,2 @@\n-TypePtr::InterfaceSet TypeOopPtr::InterfaceSet::intersection_with(const InterfaceSet& other) const {\n-  InterfaceSet result;\n+const TypeInterfaces* TypeInterfaces::intersection_with(const TypeInterfaces* other) const {\n+  GrowableArray<ciInstanceKlass*> result_list;\n@@ -3421,1 +3427,1 @@\n-  while (i < _list.length() || j < other._list.length()) {\n+  while (i < _list.length() || j < other->_list.length()) {\n@@ -3423,2 +3429,2 @@\n-           (j >= other._list.length() ||\n-            compare(_list.at(i), other._list.at(j)) < 0)) {\n+           (j >= other->_list.length() ||\n+            compare(_list.at(i), other->_list.at(j)) < 0)) {\n@@ -3427,1 +3433,1 @@\n-    while (j < other._list.length() &&\n+    while (j < other->_list.length() &&\n@@ -3429,1 +3435,1 @@\n-            compare(other._list.at(j), _list.at(i)) < 0)) {\n+            compare(other->_list.at(j), _list.at(i)) < 0)) {\n@@ -3433,3 +3439,3 @@\n-        j < other._list.length() &&\n-        _list.at(i) == other._list.at(j)) {\n-      result.raw_add(_list.at(i));\n+        j < other->_list.length() &&\n+        _list.at(i) == other->_list.at(j)) {\n+      result_list.push(_list.at(i));\n@@ -3440,1 +3446,1 @@\n-  result.initialize();\n+  const TypeInterfaces* result = TypeInterfaces::make(&result_list);\n@@ -3442,1 +3448,1 @@\n-  result.verify();\n+  result->verify();\n@@ -3444,1 +3450,1 @@\n-    assert(!other._list.contains(_list.at(i)) || result._list.contains(_list.at(i)), \"missing\");\n+    assert(!other->_list.contains(_list.at(i)) || result->_list.contains(_list.at(i)), \"missing\");\n@@ -3446,2 +3452,2 @@\n-  for (int i = 0; i < other._list.length(); i++) {\n-    assert(!_list.contains(other._list.at(i)) || result._list.contains(other._list.at(i)), \"missing\");\n+  for (int i = 0; i < other->_list.length(); i++) {\n+    assert(!_list.contains(other->_list.at(i)) || result->_list.contains(other->_list.at(i)), \"missing\");\n@@ -3449,2 +3455,2 @@\n-  for (int i = 0; i < result._list.length(); i++) {\n-    assert(_list.contains(result._list.at(i)) && other._list.contains(result._list.at(i)), \"missing\");\n+  for (int i = 0; i < result->_list.length(); i++) {\n+    assert(_list.contains(result->_list.at(i)) && other->_list.contains(result->_list.at(i)), \"missing\");\n@@ -3457,1 +3463,1 @@\n-ciKlass* TypePtr::InterfaceSet::exact_klass() const {\n+ciInstanceKlass* TypeInterfaces::exact_klass() const {\n@@ -3462,1 +3468,1 @@\n-void TypePtr::InterfaceSet::compute_exact_klass() {\n+void TypeInterfaces::compute_exact_klass() {\n@@ -3467,1 +3473,1 @@\n-  ciKlass* res = nullptr;\n+  ciInstanceKlass* res = nullptr;\n@@ -3469,1 +3475,1 @@\n-    ciInstanceKlass* interface = _list.at(i)->as_instance_klass();\n+    ciInstanceKlass* interface = _list.at(i);\n@@ -3479,1 +3485,1 @@\n-void TypePtr::InterfaceSet::verify_is_loaded() const {\n+void TypeInterfaces::verify_is_loaded() const {\n@@ -3487,0 +3493,11 @@\n+\/\/ Can't be implemented because there's no way to know if the type is above or below the center line.\n+const Type* TypeInterfaces::xmeet(const Type* t) const {\n+  ShouldNotReachHere();\n+  return Type::xmeet(t);\n+}\n+\n+bool TypeInterfaces::singleton(void) const {\n+  ShouldNotReachHere();\n+  return Type::singleton();\n+}\n+\n@@ -3488,1 +3505,1 @@\n-TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset,\n+TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, const TypeInterfaces* interfaces, bool xk, ciObject* o, int offset,\n@@ -3500,1 +3517,1 @@\n-    interfaces.verify_is_loaded();\n+    interfaces->verify_is_loaded();\n@@ -3577,1 +3594,2 @@\n-  return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, InterfaceSet(), xk, o, offset, instance_id, speculative, inline_depth))->hashcons();\n+  const TypeInterfaces* interfaces = TypeInterfaces::make();\n+  return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, interfaces, xk, o, offset, instance_id, speculative, inline_depth))->hashcons();\n@@ -3722,1 +3740,1 @@\n-    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n+    const TypeInterfaces* interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n@@ -3955,1 +3973,1 @@\n-TypePtr::InterfaceSet TypeOopPtr::meet_interfaces(const TypeOopPtr* other) const {\n+const TypeInterfaces* TypeOopPtr::meet_interfaces(const TypeOopPtr* other) const {\n@@ -3957,1 +3975,1 @@\n-    return _interfaces.union_with(other->_interfaces);\n+    return _interfaces->union_with(other->_interfaces);\n@@ -3963,1 +3981,1 @@\n-  return _interfaces.intersection_with(other->_interfaces);\n+  return _interfaces->intersection_with(other->_interfaces);\n@@ -3992,1 +4010,1 @@\n-  if (_interfaces.empty()) {\n+  if (_interfaces->empty()) {\n@@ -3996,1 +4014,1 @@\n-    if (_interfaces.eq(_klass->as_instance_klass())) {\n+    if (_interfaces->eq(_klass->as_instance_klass())) {\n@@ -4001,1 +4019,1 @@\n-  return _interfaces.exact_klass();\n+  return _interfaces->exact_klass();\n@@ -4005,1 +4023,1 @@\n-TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int off,\n+TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, const TypeInterfaces* interfaces, bool xk, ciObject* o, int off,\n@@ -4017,1 +4035,1 @@\n-                                     const InterfaceSet& interfaces,\n+                                     const TypeInterfaces* interfaces,\n@@ -4049,1 +4067,1 @@\n-TypePtr::InterfaceSet TypePtr::interfaces(ciKlass*& k, bool klass, bool interface, bool array, InterfaceHandling interface_handling) {\n+const TypeInterfaces* TypePtr::interfaces(ciKlass*& k, bool klass, bool interface, bool array, InterfaceHandling interface_handling) {\n@@ -4055,1 +4073,1 @@\n-        InterfaceSet interfaces;\n+        const TypeInterfaces* interfaces = TypeInterfaces::make();\n@@ -4059,1 +4077,1 @@\n-      InterfaceSet interfaces(k_interfaces);\n+      const TypeInterfaces* interfaces = TypeInterfaces::make(k_interfaces);\n@@ -4068,1 +4086,1 @@\n-    InterfaceSet interfaces;\n+    const TypeInterfaces* interfaces = TypeInterfaces::make();\n@@ -4079,1 +4097,1 @@\n-  return *TypeAryPtr::_array_interfaces;\n+  return TypeAryPtr::_array_interfaces;\n@@ -4133,1 +4151,1 @@\n-const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst, const InterfaceSet& interfaces) const {\n+const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst, const TypeInterfaces* interfaces) const {\n@@ -4290,1 +4308,1 @@\n-    InterfaceSet interfaces = meet_interfaces(tinst);\n+    const TypeInterfaces* interfaces = meet_interfaces(tinst);\n@@ -4350,2 +4368,2 @@\n-template<class T> TypePtr::MeetResult TypePtr::meet_instptr(PTR& ptr, InterfaceSet& interfaces, const T* this_type, const T* other_type,\n-                      ciKlass*& res_klass, bool& res_xk) {\n+template<class T> TypePtr::MeetResult TypePtr::meet_instptr(PTR& ptr, const TypeInterfaces*& interfaces, const T* this_type, const T* other_type,\n+                                                            ciKlass*& res_klass, bool& res_xk) {\n@@ -4358,2 +4376,2 @@\n-  InterfaceSet this_interfaces = this_type->interfaces();\n-  InterfaceSet other_interfaces = other_type->interfaces();\n+  const TypeInterfaces* this_interfaces = this_type->interfaces();\n+  const TypeInterfaces* other_interfaces = other_type->interfaces();\n@@ -4444,1 +4462,1 @@\n-  interfaces = this_interfaces.intersection_with(other_interfaces);\n+  interfaces = this_interfaces->intersection_with(other_interfaces);\n@@ -4480,1 +4498,1 @@\n-    _interfaces.eq(p->_interfaces) &&\n+    _interfaces->eq(p->_interfaces) &&\n@@ -4487,1 +4505,1 @@\n-  return klass()->hash() + TypeOopPtr::hash() + _interfaces.hash();\n+  return klass()->hash() + TypeOopPtr::hash() + _interfaces->hash();\n@@ -4510,1 +4528,1 @@\n-  _interfaces.dump(st);\n+  _interfaces->dump(st);\n@@ -4594,1 +4612,1 @@\n-    if (_interfaces.eq(ik)) {\n+    if (_interfaces->eq(ik)) {\n@@ -4611,1 +4629,1 @@\n-  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty()) {\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces->empty()) {\n@@ -4616,1 +4634,1 @@\n-         (!this_xk || this_one->_interfaces.contains(other->_interfaces));\n+         (!this_xk || this_one->_interfaces->contains(other->_interfaces));\n@@ -4626,1 +4644,1 @@\n-  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty()) {\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces->empty()) {\n@@ -4631,1 +4649,1 @@\n-    return other->klass() == ciEnv::current()->Object_klass() && this_one->_interfaces.contains(other->_interfaces);\n+    return other->klass() == ciEnv::current()->Object_klass() && this_one->_interfaces->contains(other->_interfaces);\n@@ -4648,1 +4666,1 @@\n-    return this_one->_klass->is_subtype_of(other->_klass);\n+    return this_one->klass()->is_subtype_of(other->klass());\n@@ -4752,1 +4770,1 @@\n-  jint max_hi = max_array_length(elem()->basic_type());\n+  jint max_hi = max_array_length(elem()->array_element_basic_type());\n@@ -4974,3 +4992,3 @@\n-    InterfaceSet interfaces = meet_interfaces(tp);\n-    InterfaceSet tp_interfaces = tp->_interfaces;\n-    InterfaceSet this_interfaces = _interfaces;\n+    const TypeInterfaces* interfaces = meet_interfaces(tp);\n+    const TypeInterfaces* tp_interfaces = tp->_interfaces;\n+    const TypeInterfaces* this_interfaces = _interfaces;\n@@ -4984,1 +5002,1 @@\n-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.contains(tp_interfaces) && !tp->klass_is_exact()) {\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces->contains(tp_interfaces) && !tp->klass_is_exact()) {\n@@ -4990,1 +5008,1 @@\n-        interfaces = this_interfaces.intersection_with(tp_interfaces);\n+        interfaces = this_interfaces->intersection_with(tp_interfaces);\n@@ -5003,1 +5021,1 @@\n-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.contains(tp_interfaces) && !tp->klass_is_exact()) {\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces->contains(tp_interfaces) && !tp->klass_is_exact()) {\n@@ -5017,1 +5035,1 @@\n-      interfaces = this_interfaces.intersection_with(tp_interfaces);\n+      interfaces = this_interfaces->intersection_with(tp_interfaces);\n@@ -5131,1 +5149,1 @@\n-  _interfaces.dump(st);\n+  _interfaces->dump(st);\n@@ -5581,1 +5599,1 @@\n-    const InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n+    const TypeInterfaces* interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n@@ -5589,1 +5607,1 @@\n-TypeKlassPtr::TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, int offset)\n+TypeKlassPtr::TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, const TypeInterfaces* interfaces, int offset)\n@@ -5598,1 +5616,1 @@\n-  if (_interfaces.empty()) {\n+  if (_interfaces->empty()) {\n@@ -5602,1 +5620,1 @@\n-    if (_interfaces.eq(_klass->as_instance_klass())) {\n+    if (_interfaces->eq(_klass->as_instance_klass())) {\n@@ -5607,1 +5625,1 @@\n-  return _interfaces.exact_klass();\n+  return _interfaces->exact_klass();\n@@ -5615,1 +5633,1 @@\n-    _interfaces.eq(p->_interfaces) &&\n+    _interfaces->eq(p->_interfaces) &&\n@@ -5622,1 +5640,1 @@\n-  return TypePtr::hash() + _interfaces.hash();\n+  return TypePtr::hash() + _interfaces->hash();\n@@ -5649,1 +5667,1 @@\n-TypePtr::InterfaceSet TypeKlassPtr::meet_interfaces(const TypeKlassPtr* other) const {\n+const TypeInterfaces* TypeKlassPtr::meet_interfaces(const TypeKlassPtr* other) const {\n@@ -5651,1 +5669,1 @@\n-    return _interfaces.union_with(other->_interfaces);\n+    return _interfaces->union_with(other->_interfaces);\n@@ -5657,1 +5675,1 @@\n-  return _interfaces.intersection_with(other->_interfaces);\n+  return _interfaces->intersection_with(other->_interfaces);\n@@ -5697,1 +5715,1 @@\n-      _interfaces.dump(st);\n+      _interfaces->dump(st);\n@@ -5738,1 +5756,1 @@\n-const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, int offset) {\n+const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, const TypeInterfaces* interfaces, int offset) {\n@@ -5790,1 +5808,1 @@\n-  TypePtr::InterfaceSet interfaces = _interfaces;\n+  const TypeInterfaces* interfaces = _interfaces;\n@@ -5799,1 +5817,1 @@\n-        if (_interfaces.eq(sub)) {\n+        if (_interfaces->eq(sub)) {\n@@ -5883,1 +5901,1 @@\n-    InterfaceSet interfaces = meet_interfaces(tkls);\n+    const TypeInterfaces* interfaces = meet_interfaces(tkls);\n@@ -5906,3 +5924,3 @@\n-    InterfaceSet interfaces = meet_interfaces(tp);\n-    InterfaceSet tp_interfaces = tp->_interfaces;\n-    InterfaceSet this_interfaces = _interfaces;\n+    const TypeInterfaces* interfaces = meet_interfaces(tp);\n+    const TypeInterfaces* tp_interfaces = tp->_interfaces;\n+    const TypeInterfaces* this_interfaces = _interfaces;\n@@ -5916,1 +5934,1 @@\n-      if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces.contains(this_interfaces) && !klass_is_exact()) {\n+      if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces->contains(this_interfaces) && !klass_is_exact()) {\n@@ -5921,1 +5939,1 @@\n-        interfaces = _interfaces.intersection_with(tp->_interfaces);\n+        interfaces = _interfaces->intersection_with(tp->_interfaces);\n@@ -5934,1 +5952,1 @@\n-        if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces.contains(this_interfaces) && !klass_is_exact()) {\n+        if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces->contains(this_interfaces) && !klass_is_exact()) {\n@@ -5944,1 +5962,1 @@\n-      interfaces = this_interfaces.intersection_with(tp_interfaces);\n+      interfaces = this_interfaces->intersection_with(tp_interfaces);\n@@ -5973,1 +5991,1 @@\n-  if (other->klass()->equals(ciEnv::current()->Object_klass()) && other->_interfaces.empty()) {\n+  if (other->klass()->equals(ciEnv::current()->Object_klass()) && other->_interfaces->empty()) {\n@@ -5977,1 +5995,1 @@\n-  return this_one->_klass->is_subtype_of(other->_klass) && this_one->_interfaces.contains(other->_interfaces);\n+  return this_one->klass()->is_subtype_of(other->klass()) && this_one->_interfaces->contains(other->_interfaces);\n@@ -5992,1 +6010,1 @@\n-  return this_one->_klass->equals(other->_klass) && this_one->_interfaces.eq(other->_interfaces);\n+  return this_one->klass()->equals(other->klass()) && this_one->_interfaces->eq(other->_interfaces);\n@@ -6006,1 +6024,1 @@\n-    return !this_exact && this_one->_klass->equals(ciEnv::current()->Object_klass())  && other->_interfaces.contains(this_one->_interfaces);\n+    return !this_exact && this_one->klass()->equals(ciEnv::current()->Object_klass())  && other->_interfaces->contains(this_one->_interfaces);\n@@ -6015,1 +6033,1 @@\n-  if (!this_one->_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(this_one->_klass)) {\n+  if (!this_one->klass()->is_subtype_of(other->klass()) && !other->klass()->is_subtype_of(this_one->klass())) {\n@@ -6020,1 +6038,1 @@\n-    return this_one->_klass->is_subtype_of(other->_klass) && this_one->_interfaces.contains(other->_interfaces);\n+    return this_one->klass()->is_subtype_of(other->klass()) && this_one->_interfaces->contains(other->_interfaces);\n@@ -6038,1 +6056,1 @@\n-  TypePtr::InterfaceSet interfaces = _interfaces;\n+  const TypeInterfaces* interfaces = _interfaces;\n@@ -6046,1 +6064,1 @@\n-        if (_interfaces.eq(sub)) {\n+        if (_interfaces->eq(sub)) {\n@@ -6100,1 +6118,1 @@\n-ciKlass* TypeAryPtr::compute_klass(DEBUG_ONLY(bool verify)) const {\n+ciKlass* TypeAryPtr::compute_klass() const {\n@@ -6121,22 +6139,1 @@\n-    \/\/ Cannot compute array klass directly from basic type,\n-    \/\/ since subtypes of TypeInt all have basic type T_INT.\n-#ifdef ASSERT\n-    if (verify && el->isa_int()) {\n-      \/\/ Check simple cases when verifying klass.\n-      BasicType bt = T_ILLEGAL;\n-      if (el == TypeInt::BYTE) {\n-        bt = T_BYTE;\n-      } else if (el == TypeInt::SHORT) {\n-        bt = T_SHORT;\n-      } else if (el == TypeInt::CHAR) {\n-        bt = T_CHAR;\n-      } else if (el == TypeInt::INT) {\n-        bt = T_INT;\n-      } else {\n-        return _klass; \/\/ just return specified klass\n-      }\n-      return ciTypeArrayKlass::make(bt);\n-    }\n-#endif\n-    assert(!el->isa_int(),\n-           \"integral arrays must be pre-equipped with a class\");\n+    assert(!el->isa_int(), \"integral arrays must be pre-equipped with a class\");\n@@ -6340,3 +6337,3 @@\n-    InterfaceSet interfaces = meet_interfaces(tp);\n-    InterfaceSet tp_interfaces = tp->_interfaces;\n-    InterfaceSet this_interfaces = _interfaces;\n+    const TypeInterfaces* interfaces = meet_interfaces(tp);\n+    const TypeInterfaces* tp_interfaces = tp->_interfaces;\n+    const TypeInterfaces* this_interfaces = _interfaces;\n@@ -6350,1 +6347,1 @@\n-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.intersection_with(tp_interfaces).eq(tp_interfaces) && !tp->klass_is_exact()) {\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces->intersection_with(tp_interfaces)->eq(tp_interfaces) && !tp->klass_is_exact()) {\n@@ -6355,1 +6352,1 @@\n-        interfaces = this_interfaces.intersection_with(tp->_interfaces);\n+        interfaces = this_interfaces->intersection_with(tp->_interfaces);\n@@ -6368,1 +6365,1 @@\n-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.intersection_with(tp_interfaces).eq(tp_interfaces) && !tp->klass_is_exact()) {\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces->intersection_with(tp_interfaces)->eq(tp_interfaces) && !tp->klass_is_exact()) {\n@@ -6377,1 +6374,1 @@\n-      interfaces = this_interfaces.intersection_with(tp_interfaces);\n+      interfaces = this_interfaces->intersection_with(tp_interfaces);\n@@ -6390,1 +6387,1 @@\n-  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty() && other_exact) {\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces->empty() && other_exact) {\n@@ -6402,1 +6399,1 @@\n-    return other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.intersection_with(this_one->_interfaces).eq(other->_interfaces) && other_exact;\n+    return other->klass() == ciEnv::current()->Object_klass() && other->_interfaces->intersection_with(this_one->_interfaces)->eq(other->_interfaces) && other_exact;\n@@ -6418,1 +6415,1 @@\n-    return this_one->_klass->is_subtype_of(other->_klass);\n+    return this_one->klass()->is_subtype_of(other->klass());\n@@ -6450,2 +6447,1 @@\n-    assert(this_one->_klass != nullptr && other->_klass != nullptr, \"\");\n-    return this_one->_klass->equals(other->_klass);\n+    return this_one->klass()->equals(other->klass());\n@@ -6462,1 +6458,1 @@\n-  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty() && other_exact) {\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces->empty() && other_exact) {\n@@ -6471,1 +6467,1 @@\n-    return other->_klass->equals(ciEnv::current()->Object_klass()) && other->_interfaces.intersection_with(this_one->_interfaces).eq(other->_interfaces);\n+    return other->klass()->equals(ciEnv::current()->Object_klass()) && other->_interfaces->intersection_with(this_one->_interfaces)->eq(other->_interfaces);\n@@ -6490,1 +6486,1 @@\n-    return this_one->_klass->is_subtype_of(other->_klass);\n+    return this_one->klass()->is_subtype_of(other->klass());\n@@ -6546,1 +6542,1 @@\n-      _interfaces.dump(st);\n+      _interfaces->dump(st);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":177,"deletions":181,"binary":false,"changes":358,"status":"modified"},{"patch":"@@ -1907,2 +1907,1 @@\n-\n-#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM) && !defined(PPC64)\n+#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM) && !defined(PPC64) && !defined(S390)\n@@ -1915,9 +1914,0 @@\n-  if (UseHeavyMonitors) {\n-    if (FLAG_IS_CMDLINE(LockingMode) && LockingMode != LM_MONITOR) {\n-      jio_fprintf(defaultStream::error_stream(),\n-                  \"Conflicting -XX:+UseHeavyMonitors and -XX:LockingMode=%d flags\", LockingMode);\n-      return false;\n-    }\n-    FLAG_SET_CMDLINE(LockingMode, LM_MONITOR);\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -302,0 +302,3 @@\n+  product(size_t, InlineCacheBufferSize, 10*K, EXPERIMENTAL,                \\\n+          \"InlineCacheBuffer size\")                                         \\\n+                                                                            \\\n@@ -1057,4 +1060,0 @@\n-  develop(bool, UseHeavyMonitors, false,                                    \\\n-          \"(Deprecated) Use heavyweight instead of lightweight Java \"       \\\n-          \"monitors\")                                                       \\\n-                                                                            \\\n@@ -1063,1 +1062,1 @@\n-          \"+UseHeavyMonitors\")                                              \\\n+          \"-XX:LockingMode=0 (LM_MONITOR)\")                                 \\\n@@ -1984,1 +1983,1 @@\n-  product(uint, TrimNativeHeapInterval, 0, EXPERIMENTAL,                    \\\n+  product(uint, TrimNativeHeapInterval, 0,                                  \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -367,1 +367,0 @@\n-  void      release_object() { _object.release(_oop_storage); _object.set_null(); }\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -1644,2 +1644,2 @@\n-    SuspendibleThreadSet::synchronize();\n-    SuspendibleThreadSet::desynchronize();\n+    Universe::heap()->safepoint_synchronize_begin();\n+    Universe::heap()->safepoint_synchronize_end();\n@@ -1649,1 +1649,2 @@\n-static size_t delete_monitors(GrowableArray<ObjectMonitor*>* delete_list) {\n+static size_t delete_monitors(Thread* current, GrowableArray<ObjectMonitor*>* delete_list,\n+                              LogStream* ls, elapsedTimer* timer_p) {\n@@ -1651,1 +1652,1 @@\n-  size_t count = 0;\n+  size_t deleted_count = 0;\n@@ -1654,1 +1655,6 @@\n-    count++;\n+    deleted_count++;\n+    if (current->is_Java_thread()) {\n+      \/\/ A JavaThread must check for a safepoint\/handshake and honor it.\n+      ObjectSynchronizer::chk_for_block_req(JavaThread::cast(current), \"deletion\", \"deleted_count\",\n+                                            deleted_count, ls, timer_p);\n+    }\n@@ -1656,1 +1662,1 @@\n-  return count;\n+  return deleted_count;\n@@ -1734,24 +1740,1 @@\n-    if (current->is_Java_thread()) {\n-      if (ls != NULL) {\n-        timer.stop();\n-        ls->print_cr(\"before setting blocked: unlinked_count=\" SIZE_FORMAT\n-                     \", in_use_list stats: ceiling=\" SIZE_FORMAT \", count=\"\n-                     SIZE_FORMAT \", max=\" SIZE_FORMAT,\n-                     unlinked_count, in_use_list_ceiling(),\n-                     _in_use_list.count(), _in_use_list.max());\n-      }\n-      \/\/ Mark the calling JavaThread blocked (safepoint safe) while we free\n-      \/\/ the ObjectMonitors so we don't delay safepoints whilst doing that.\n-      ThreadBlockInVM tbivm(JavaThread::cast(current));\n-      if (ls != NULL) {\n-        ls->print_cr(\"after setting blocked: in_use_list stats: ceiling=\"\n-                     SIZE_FORMAT \", count=\" SIZE_FORMAT \", max=\" SIZE_FORMAT,\n-                     in_use_list_ceiling(), _in_use_list.count(), _in_use_list.max());\n-        timer.start();\n-      }\n-      deleted_count = delete_monitors(&delete_list);\n-      \/\/ ThreadBlockInVM is destroyed here\n-    } else {\n-      \/\/ A non-JavaThread can just free the ObjectMonitors:\n-      deleted_count = delete_monitors(&delete_list);\n-    }\n+    deleted_count = delete_monitors(current, &delete_list, ls, &timer);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":14,"deletions":31,"binary":false,"changes":45,"status":"modified"}]}