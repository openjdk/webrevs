{"files":[{"patch":"@@ -340,9 +340,0 @@\n-    MTTFHAR_OPCODE   = (MTSPR_OPCODE | 4 << SPR_5_9_SHIFT | 0 << SPR_0_4_SHIFT),\n-    MFTFHAR_OPCODE   = (MFSPR_OPCODE | 4 << SPR_5_9_SHIFT | 0 << SPR_0_4_SHIFT),\n-    MTTFIAR_OPCODE   = (MTSPR_OPCODE | 4 << SPR_5_9_SHIFT | 1 << SPR_0_4_SHIFT),\n-    MFTFIAR_OPCODE   = (MFSPR_OPCODE | 4 << SPR_5_9_SHIFT | 1 << SPR_0_4_SHIFT),\n-    MTTEXASR_OPCODE  = (MTSPR_OPCODE | 4 << SPR_5_9_SHIFT | 2 << SPR_0_4_SHIFT),\n-    MFTEXASR_OPCODE  = (MFSPR_OPCODE | 4 << SPR_5_9_SHIFT | 2 << SPR_0_4_SHIFT),\n-    MTTEXASRU_OPCODE = (MTSPR_OPCODE | 4 << SPR_5_9_SHIFT | 3 << SPR_0_4_SHIFT),\n-    MFTEXASRU_OPCODE = (MFSPR_OPCODE | 4 << SPR_5_9_SHIFT | 3 << SPR_0_4_SHIFT),\n-\n@@ -769,11 +760,0 @@\n-    \/\/ Transactional Memory instructions (introduced with Power 8)\n-    TBEGIN_OPCODE    = (31u << OPCODE_SHIFT |  654u << 1),\n-    TEND_OPCODE      = (31u << OPCODE_SHIFT |  686u << 1),\n-    TABORT_OPCODE    = (31u << OPCODE_SHIFT |  910u << 1),\n-    TABORTWC_OPCODE  = (31u << OPCODE_SHIFT |  782u << 1),\n-    TABORTWCI_OPCODE = (31u << OPCODE_SHIFT |  846u << 1),\n-    TABORTDC_OPCODE  = (31u << OPCODE_SHIFT |  814u << 1),\n-    TABORTDCI_OPCODE = (31u << OPCODE_SHIFT |  878u << 1),\n-    TSR_OPCODE       = (31u << OPCODE_SHIFT |  750u << 1),\n-    TCHECK_OPCODE    = (31u << OPCODE_SHIFT |  718u << 1),\n-\n@@ -1817,27 +1797,0 @@\n-  \/\/ Transactional Memory Registers\n-  inline void mftfhar(Register d);\n-  inline void mftfiar(Register d);\n-  inline void mftexasr(Register d);\n-  inline void mftexasru(Register d);\n-\n-  \/\/ TEXASR bit description\n-  enum transaction_failure_reason {\n-    \/\/ Upper half (TEXASRU):\n-    tm_failure_code       =  0, \/\/ The Failure Code is copied from tabort or treclaim operand.\n-    tm_failure_persistent =  7, \/\/ The failure is likely to recur on each execution.\n-    tm_disallowed         =  8, \/\/ The instruction is not permitted.\n-    tm_nesting_of         =  9, \/\/ The maximum transaction level was exceeded.\n-    tm_footprint_of       = 10, \/\/ The tracking limit for transactional storage accesses was exceeded.\n-    tm_self_induced_cf    = 11, \/\/ A self-induced conflict occurred in Suspended state.\n-    tm_non_trans_cf       = 12, \/\/ A conflict occurred with a non-transactional access by another processor.\n-    tm_trans_cf           = 13, \/\/ A conflict occurred with another transaction.\n-    tm_translation_cf     = 14, \/\/ A conflict occurred with a TLB invalidation.\n-    tm_inst_fetch_cf      = 16, \/\/ An instruction fetch was performed from a block that was previously written transactionally.\n-    tm_tabort             = 31, \/\/ Termination was caused by the execution of an abort instruction.\n-    \/\/ Lower half:\n-    tm_suspended          = 32, \/\/ Failure was recorded in Suspended state.\n-    tm_failure_summary    = 36, \/\/ Failure has been detected and recorded.\n-    tm_tfiar_exact        = 37, \/\/ Value in the TFIAR is exact.\n-    tm_rot                = 38, \/\/ Rollback-only transaction.\n-    tm_transaction_level  = 52, \/\/ Transaction level (nesting depth + 1).\n-  };\n@@ -2455,19 +2408,0 @@\n-  \/\/ Transactional Memory instructions (introduced with Power 8)\n-  inline void tbegin_();    \/\/ R=0\n-  inline void tbeginrot_(); \/\/ R=1 Rollback-Only Transaction\n-  inline void tend_();    \/\/ A=0\n-  inline void tendall_(); \/\/ A=1\n-  inline void tabort_();\n-  inline void tabort_(Register a);\n-  inline void tabortwc_(int t, Register a, Register b);\n-  inline void tabortwci_(int t, Register a, int si);\n-  inline void tabortdc_(int t, Register a, Register b);\n-  inline void tabortdci_(int t, Register a, int si);\n-  inline void tsuspend_(); \/\/ tsr with L=0\n-  inline void tresume_();  \/\/ tsr with L=1\n-  inline void tcheck(int f);\n-\n-  static bool is_tbegin(int x) {\n-    return TBEGIN_OPCODE == (x & (0x3f << OPCODE_SHIFT | 0x3ff << 1));\n-  }\n-\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":0,"deletions":66,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -436,5 +436,0 @@\n-\/\/ Transactional Memory Registers\n-inline void Assembler::mftfhar(Register d )       { emit_int32(MFTFHAR_OPCODE   | rt(d)); }\n-inline void Assembler::mftfiar(Register d )       { emit_int32(MFTFIAR_OPCODE   | rt(d)); }\n-inline void Assembler::mftexasr(Register d )      { emit_int32(MFTEXASR_OPCODE  | rt(d)); }\n-inline void Assembler::mftexasru(Register d )     { emit_int32(MFTEXASRU_OPCODE | rt(d)); }\n@@ -442,1 +437,0 @@\n-\/\/ SAP JVM 2006-02-13 PPC branch instruction.\n@@ -1051,15 +1045,0 @@\n-\/\/ Transactional Memory instructions (introduced with Power 8)\n-inline void Assembler::tbegin_()                                { emit_int32( TBEGIN_OPCODE | rc(1)); }\n-inline void Assembler::tbeginrot_()                             { emit_int32( TBEGIN_OPCODE | \/*R=1*\/ 1u << (31-10) | rc(1)); }\n-inline void Assembler::tend_()                                  { emit_int32( TEND_OPCODE | rc(1)); }\n-inline void Assembler::tendall_()                               { emit_int32( TEND_OPCODE | \/*A=1*\/ 1u << (31-6) | rc(1)); }\n-inline void Assembler::tabort_()                                { emit_int32( TABORT_OPCODE | rc(1)); }\n-inline void Assembler::tabort_(Register a)                      { assert(a != R0, \"r0 not allowed\"); emit_int32( TABORT_OPCODE | ra(a) | rc(1)); }\n-inline void Assembler::tabortwc_(int t, Register a, Register b) { emit_int32( TABORTWC_OPCODE | to(t) | ra(a) | rb(b) | rc(1)); }\n-inline void Assembler::tabortwci_(int t, Register a, int si)    { emit_int32( TABORTWCI_OPCODE | to(t) | ra(a) | sh1620(si) | rc(1)); }\n-inline void Assembler::tabortdc_(int t, Register a, Register b) { emit_int32( TABORTDC_OPCODE | to(t) | ra(a) | rb(b) | rc(1)); }\n-inline void Assembler::tabortdci_(int t, Register a, int si)    { emit_int32( TABORTDCI_OPCODE | to(t) | ra(a) | sh1620(si) | rc(1)); }\n-inline void Assembler::tsuspend_()                              { emit_int32( TSR_OPCODE | rc(1)); }\n-inline void Assembler::tresume_()                               { emit_int32( TSR_OPCODE | \/*L=1*\/ 1u << (31-10) | rc(1)); }\n-inline void Assembler::tcheck(int f)                            { emit_int32( TCHECK_OPCODE | bf(f)); }\n-\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -48,7 +48,0 @@\n-#if defined(COMPILER2) && (defined(AIX) || defined(LINUX))\n-\/\/ Include Transactional Memory lock eliding optimization\n-#define INCLUDE_RTM_OPT 1\n-#else\n-#define INCLUDE_RTM_OPT 0\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/ppc\/globalDefinitions_ppc.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -154,44 +154,1 @@\n-          \"Write 0x0101... to empty memory. Use this to ease debugging.\")   \\\n-                                                                            \\\n-  \/* Use Restricted Transactional Memory for lock elision *\/                \\\n-  product(bool, UseRTMLocking, false,                                       \\\n-          \"Enable RTM lock eliding for inflated locks in compiled code\")    \\\n-                                                                            \\\n-  product(bool, UseRTMForStackLocks, false, EXPERIMENTAL,                   \\\n-          \"Enable RTM lock eliding for stack locks in compiled code\")       \\\n-                                                                            \\\n-  product(bool, UseRTMDeopt, false,                                         \\\n-          \"Perform deopt and recompilation based on RTM abort ratio\")       \\\n-                                                                            \\\n-  product(int, RTMRetryCount, 5,                                            \\\n-          \"Number of RTM retries on lock abort or busy\")                    \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(int, RTMSpinLoopCount, 100, EXPERIMENTAL,                         \\\n-          \"Spin count for lock to become free before RTM retry\")            \\\n-          range(0, 32767) \/* immediate operand limit on ppc *\/              \\\n-                                                                            \\\n-  product(int, RTMAbortThreshold, 1000, EXPERIMENTAL,                       \\\n-          \"Calculate abort ratio after this number of aborts\")              \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(int, RTMLockingThreshold, 10000, EXPERIMENTAL,                    \\\n-          \"Lock count at which to do RTM lock eliding without \"             \\\n-          \"abort ratio calculation\")                                        \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(int, RTMAbortRatio, 50, EXPERIMENTAL,                             \\\n-          \"Lock abort ratio at which to stop use RTM lock eliding\")         \\\n-          range(0, 100) \/* natural range *\/                                 \\\n-                                                                            \\\n-  product(int, RTMTotalCountIncrRate, 64, EXPERIMENTAL,                     \\\n-          \"Increment total RTM attempted lock count once every n times\")    \\\n-          range(1, 32767) \/* immediate operand limit on ppc *\/              \\\n-          constraint(RTMTotalCountIncrRateConstraintFunc,AfterErgo)         \\\n-                                                                            \\\n-  product(intx, RTMLockingCalculationDelay, 0, EXPERIMENTAL,                \\\n-          \"Number of milliseconds to wait before start calculating aborts \" \\\n-          \"for RTM locking\")                                                \\\n-                                                                            \\\n-  product(bool, UseRTMXendForLockBusy, true, EXPERIMENTAL,                  \\\n-          \"Use RTM Xend instead of Xabort when lock busy\")\n+          \"Write 0x0101... to empty memory. Use this to ease debugging.\")\n","filename":"src\/hotspot\/cpu\/ppc\/globals_ppc.hpp","additions":1,"deletions":44,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2176,448 +2176,0 @@\n-\/\/ TM on PPC64.\n-void MacroAssembler::atomic_inc_ptr(Register addr, Register result, int simm16) {\n-  Label retry;\n-  bind(retry);\n-  ldarx(result, addr, \/*hint*\/ false);\n-  addi(result, result, simm16);\n-  stdcx_(result, addr);\n-  if (UseStaticBranchPredictionInCompareAndSwapPPC64) {\n-    bne_predict_not_taken(CCR0, retry); \/\/ stXcx_ sets CCR0\n-  } else {\n-    bne(                  CCR0, retry); \/\/ stXcx_ sets CCR0\n-  }\n-}\n-\n-void MacroAssembler::atomic_ori_int(Register addr, Register result, int uimm16) {\n-  Label retry;\n-  bind(retry);\n-  lwarx(result, addr, \/*hint*\/ false);\n-  ori(result, result, uimm16);\n-  stwcx_(result, addr);\n-  if (UseStaticBranchPredictionInCompareAndSwapPPC64) {\n-    bne_predict_not_taken(CCR0, retry); \/\/ stXcx_ sets CCR0\n-  } else {\n-    bne(                  CCR0, retry); \/\/ stXcx_ sets CCR0\n-  }\n-}\n-\n-#if INCLUDE_RTM_OPT\n-\n-\/\/ Update rtm_counters based on abort status\n-\/\/ input: abort_status\n-\/\/        rtm_counters_Reg (RTMLockingCounters*)\n-void MacroAssembler::rtm_counters_update(Register abort_status, Register rtm_counters_Reg) {\n-  \/\/ Mapping to keep PreciseRTMLockingStatistics similar to x86.\n-  \/\/ x86 ppc (! means inverted, ? means not the same)\n-  \/\/  0   31  Set if abort caused by XABORT instruction.\n-  \/\/  1  ! 7  If set, the transaction may succeed on a retry. This bit is always clear if bit 0 is set.\n-  \/\/  2   13  Set if another logical processor conflicted with a memory address that was part of the transaction that aborted.\n-  \/\/  3   10  Set if an internal buffer overflowed.\n-  \/\/  4  ?12  Set if a debug breakpoint was hit.\n-  \/\/  5  ?32  Set if an abort occurred during execution of a nested transaction.\n-  const int failure_bit[] = {tm_tabort, \/\/ Signal handler will set this too.\n-                             tm_failure_persistent,\n-                             tm_non_trans_cf,\n-                             tm_trans_cf,\n-                             tm_footprint_of,\n-                             tm_failure_code,\n-                             tm_transaction_level};\n-\n-  const int num_failure_bits = sizeof(failure_bit) \/ sizeof(int);\n-  const int num_counters = RTMLockingCounters::ABORT_STATUS_LIMIT;\n-\n-  const int bit2counter_map[][num_counters] =\n-  \/\/ 0 = no map; 1 = mapped, no inverted logic; -1 = mapped, inverted logic\n-  \/\/ Inverted logic means that if a bit is set don't count it, or vice-versa.\n-  \/\/ Care must be taken when mapping bits to counters as bits for a given\n-  \/\/ counter must be mutually exclusive. Otherwise, the counter will be\n-  \/\/ incremented more than once.\n-  \/\/ counters:\n-  \/\/ 0        1        2         3         4         5\n-  \/\/ abort  , persist, conflict, overflow, debug   , nested         bits:\n-  {{ 1      , 0      , 0       , 0       , 0       , 0      },   \/\/ abort\n-   { 0      , -1     , 0       , 0       , 0       , 0      },   \/\/ failure_persistent\n-   { 0      , 0      , 1       , 0       , 0       , 0      },   \/\/ non_trans_cf\n-   { 0      , 0      , 1       , 0       , 0       , 0      },   \/\/ trans_cf\n-   { 0      , 0      , 0       , 1       , 0       , 0      },   \/\/ footprint_of\n-   { 0      , 0      , 0       , 0       , -1      , 0      },   \/\/ failure_code = 0xD4\n-   { 0      , 0      , 0       , 0       , 0       , 1      }};  \/\/ transaction_level > 1\n-  \/\/ ...\n-\n-  \/\/ Move abort_status value to R0 and use abort_status register as a\n-  \/\/ temporary register because R0 as third operand in ld\/std is treated\n-  \/\/ as base address zero (value). Likewise, R0 as second operand in addi\n-  \/\/ is problematic because it amounts to li.\n-  const Register temp_Reg = abort_status;\n-  const Register abort_status_R0 = R0;\n-  mr(abort_status_R0, abort_status);\n-\n-  \/\/ Increment total abort counter.\n-  int counters_offs = RTMLockingCounters::abort_count_offset();\n-  ld(temp_Reg, counters_offs, rtm_counters_Reg);\n-  addi(temp_Reg, temp_Reg, 1);\n-  std(temp_Reg, counters_offs, rtm_counters_Reg);\n-\n-  \/\/ Increment specific abort counters.\n-  if (PrintPreciseRTMLockingStatistics) {\n-\n-    \/\/ #0 counter offset.\n-    int abortX_offs = RTMLockingCounters::abortX_count_offset();\n-\n-    for (int nbit = 0; nbit < num_failure_bits; nbit++) {\n-      for (int ncounter = 0; ncounter < num_counters; ncounter++) {\n-        if (bit2counter_map[nbit][ncounter] != 0) {\n-          Label check_abort;\n-          int abort_counter_offs = abortX_offs + (ncounter << 3);\n-\n-          if (failure_bit[nbit] == tm_transaction_level) {\n-            \/\/ Don't check outer transaction, TL = 1 (bit 63). Hence only\n-            \/\/ 11 bits in the TL field are checked to find out if failure\n-            \/\/ occurred in a nested transaction. This check also matches\n-            \/\/ the case when nesting_of = 1 (nesting overflow).\n-            rldicr_(temp_Reg, abort_status_R0, failure_bit[nbit], 10);\n-          } else if (failure_bit[nbit] == tm_failure_code) {\n-            \/\/ Check failure code for trap or illegal caught in TM.\n-            \/\/ Bits 0:7 are tested as bit 7 (persistent) is copied from\n-            \/\/ tabort or treclaim source operand.\n-            \/\/ On Linux: trap or illegal is TM_CAUSE_SIGNAL (0xD4).\n-            rldicl(temp_Reg, abort_status_R0, 8, 56);\n-            cmpdi(CCR0, temp_Reg, 0xD4);\n-          } else {\n-            rldicr_(temp_Reg, abort_status_R0, failure_bit[nbit], 0);\n-          }\n-\n-          if (bit2counter_map[nbit][ncounter] == 1) {\n-            beq(CCR0, check_abort);\n-          } else {\n-            bne(CCR0, check_abort);\n-          }\n-\n-          \/\/ We don't increment atomically.\n-          ld(temp_Reg, abort_counter_offs, rtm_counters_Reg);\n-          addi(temp_Reg, temp_Reg, 1);\n-          std(temp_Reg, abort_counter_offs, rtm_counters_Reg);\n-\n-          bind(check_abort);\n-        }\n-      }\n-    }\n-  }\n-  \/\/ Restore abort_status.\n-  mr(abort_status, abort_status_R0);\n-}\n-\n-\/\/ Branch if (random & (count-1) != 0), count is 2^n\n-\/\/ tmp and CR0 are killed\n-void MacroAssembler::branch_on_random_using_tb(Register tmp, int count, Label& brLabel) {\n-  mftb(tmp);\n-  andi_(tmp, tmp, count-1);\n-  bne(CCR0, brLabel);\n-}\n-\n-\/\/ Perform abort ratio calculation, set no_rtm bit if high ratio.\n-\/\/ input:  rtm_counters_Reg (RTMLockingCounters* address) - KILLED\n-void MacroAssembler::rtm_abort_ratio_calculation(Register rtm_counters_Reg,\n-                                                 RTMLockingCounters* rtm_counters,\n-                                                 Metadata* method_data) {\n-  Label L_done, L_check_always_rtm1, L_check_always_rtm2;\n-\n-  if (RTMLockingCalculationDelay > 0) {\n-    \/\/ Delay calculation.\n-    ld(rtm_counters_Reg, (RegisterOrConstant)(intptr_t)RTMLockingCounters::rtm_calculation_flag_addr());\n-    cmpdi(CCR0, rtm_counters_Reg, 0);\n-    beq(CCR0, L_done);\n-    load_const_optimized(rtm_counters_Reg, (address)rtm_counters, R0); \/\/ reload\n-  }\n-  \/\/ Abort ratio calculation only if abort_count > RTMAbortThreshold.\n-  \/\/   Aborted transactions = abort_count * 100\n-  \/\/   All transactions = total_count *  RTMTotalCountIncrRate\n-  \/\/   Set no_rtm bit if (Aborted transactions >= All transactions * RTMAbortRatio)\n-  ld(R0, RTMLockingCounters::abort_count_offset(), rtm_counters_Reg);\n-  if (is_simm(RTMAbortThreshold, 16)) {   \/\/ cmpdi can handle 16bit immediate only.\n-    cmpdi(CCR0, R0, RTMAbortThreshold);\n-    blt(CCR0, L_check_always_rtm2);  \/\/ reload of rtm_counters_Reg not necessary\n-  } else {\n-    load_const_optimized(rtm_counters_Reg, RTMAbortThreshold);\n-    cmpd(CCR0, R0, rtm_counters_Reg);\n-    blt(CCR0, L_check_always_rtm1);  \/\/ reload of rtm_counters_Reg required\n-  }\n-  mulli(R0, R0, 100);\n-\n-  const Register tmpReg = rtm_counters_Reg;\n-  ld(tmpReg, RTMLockingCounters::total_count_offset(), rtm_counters_Reg);\n-  mulli(tmpReg, tmpReg, RTMTotalCountIncrRate); \/\/ allowable range: int16\n-  mulli(tmpReg, tmpReg, RTMAbortRatio);         \/\/ allowable range: int16\n-  cmpd(CCR0, R0, tmpReg);\n-  blt(CCR0, L_check_always_rtm1); \/\/ jump to reload\n-  if (method_data != nullptr) {\n-    \/\/ Set rtm_state to \"no rtm\" in MDO.\n-    \/\/ Not using a metadata relocation. Method and Class Loader are kept alive anyway.\n-    \/\/ (See nmethod::metadata_do and CodeBuffer::finalize_oop_references.)\n-    load_const(R0, (address)method_data + in_bytes(MethodData::rtm_state_offset()), tmpReg);\n-    atomic_ori_int(R0, tmpReg, NoRTM);\n-  }\n-  b(L_done);\n-\n-  bind(L_check_always_rtm1);\n-  load_const_optimized(rtm_counters_Reg, (address)rtm_counters, R0); \/\/ reload\n-  bind(L_check_always_rtm2);\n-  ld(tmpReg, RTMLockingCounters::total_count_offset(), rtm_counters_Reg);\n-  int64_t thresholdValue = RTMLockingThreshold \/ RTMTotalCountIncrRate;\n-  if (is_simm(thresholdValue, 16)) {   \/\/ cmpdi can handle 16bit immediate only.\n-    cmpdi(CCR0, tmpReg, thresholdValue);\n-  } else {\n-    load_const_optimized(R0, thresholdValue);\n-    cmpd(CCR0, tmpReg, R0);\n-  }\n-  blt(CCR0, L_done);\n-  if (method_data != nullptr) {\n-    \/\/ Set rtm_state to \"always rtm\" in MDO.\n-    \/\/ Not using a metadata relocation. See above.\n-    load_const(R0, (address)method_data + in_bytes(MethodData::rtm_state_offset()), tmpReg);\n-    atomic_ori_int(R0, tmpReg, UseRTM);\n-  }\n-  bind(L_done);\n-}\n-\n-\/\/ Update counters and perform abort ratio calculation.\n-\/\/ input: abort_status_Reg\n-void MacroAssembler::rtm_profiling(Register abort_status_Reg, Register temp_Reg,\n-                                   RTMLockingCounters* rtm_counters,\n-                                   Metadata* method_data,\n-                                   bool profile_rtm) {\n-\n-  assert(rtm_counters != nullptr, \"should not be null when profiling RTM\");\n-  \/\/ Update rtm counters based on state at abort.\n-  \/\/ Reads abort_status_Reg, updates flags.\n-  assert_different_registers(abort_status_Reg, temp_Reg);\n-  load_const_optimized(temp_Reg, (address)rtm_counters, R0);\n-  rtm_counters_update(abort_status_Reg, temp_Reg);\n-  if (profile_rtm) {\n-    assert(rtm_counters != nullptr, \"should not be null when profiling RTM\");\n-    rtm_abort_ratio_calculation(temp_Reg, rtm_counters, method_data);\n-  }\n-}\n-\n-\/\/ Retry on abort if abort's status indicates non-persistent failure.\n-\/\/ inputs: retry_count_Reg\n-\/\/       : abort_status_Reg\n-\/\/ output: retry_count_Reg decremented by 1\n-void MacroAssembler::rtm_retry_lock_on_abort(Register retry_count_Reg, Register abort_status_Reg,\n-                                             Label& retryLabel, Label* checkRetry) {\n-  Label doneRetry;\n-\n-  \/\/ Don't retry if failure is persistent.\n-  \/\/ The persistent bit is set when a (A) Disallowed operation is performed in\n-  \/\/ transactional state, like for instance trying to write the TFHAR after a\n-  \/\/ transaction is started; or when there is (B) a Nesting Overflow (too many\n-  \/\/ nested transactions); or when (C) the Footprint overflows (too many\n-  \/\/ addresses touched in TM state so there is no more space in the footprint\n-  \/\/ area to track them); or in case of (D) a Self-Induced Conflict, i.e. a\n-  \/\/ store is performed to a given address in TM state, then once in suspended\n-  \/\/ state the same address is accessed. Failure (A) is very unlikely to occur\n-  \/\/ in the JVM. Failure (D) will never occur because Suspended state is never\n-  \/\/ used in the JVM. Thus mostly (B) a Nesting Overflow or (C) a Footprint\n-  \/\/ Overflow will set the persistent bit.\n-  rldicr_(R0, abort_status_Reg, tm_failure_persistent, 0);\n-  bne(CCR0, doneRetry);\n-\n-  \/\/ Don't retry if transaction was deliberately aborted, i.e. caused by a\n-  \/\/ tabort instruction.\n-  rldicr_(R0, abort_status_Reg, tm_tabort, 0);\n-  bne(CCR0, doneRetry);\n-\n-  \/\/ Retry if transaction aborted due to a conflict with another thread.\n-  if (checkRetry) { bind(*checkRetry); }\n-  addic_(retry_count_Reg, retry_count_Reg, -1);\n-  blt(CCR0, doneRetry);\n-  b(retryLabel);\n-  bind(doneRetry);\n-}\n-\n-\/\/ Spin and retry if lock is busy.\n-\/\/ inputs: owner_addr_Reg (monitor address)\n-\/\/       : retry_count_Reg\n-\/\/ output: retry_count_Reg decremented by 1\n-\/\/ CTR is killed\n-void MacroAssembler::rtm_retry_lock_on_busy(Register retry_count_Reg, Register owner_addr_Reg, Label& retryLabel) {\n-  Label SpinLoop, doneRetry, doRetry;\n-  addic_(retry_count_Reg, retry_count_Reg, -1);\n-  blt(CCR0, doneRetry);\n-\n-  if (RTMSpinLoopCount > 1) {\n-    li(R0, RTMSpinLoopCount);\n-    mtctr(R0);\n-  }\n-\n-  \/\/ low thread priority\n-  smt_prio_low();\n-  bind(SpinLoop);\n-\n-  if (RTMSpinLoopCount > 1) {\n-    bdz(doRetry);\n-    ld(R0, 0, owner_addr_Reg);\n-    cmpdi(CCR0, R0, 0);\n-    bne(CCR0, SpinLoop);\n-  }\n-\n-  bind(doRetry);\n-\n-  \/\/ restore thread priority to default in userspace\n-#ifdef LINUX\n-  smt_prio_medium_low();\n-#else\n-  smt_prio_medium();\n-#endif\n-\n-  b(retryLabel);\n-\n-  bind(doneRetry);\n-}\n-\n-\/\/ Use RTM for normal stack locks.\n-\/\/ Input: objReg (object to lock)\n-void MacroAssembler::rtm_stack_locking(ConditionRegister flag,\n-                                       Register obj, Register mark_word, Register tmp,\n-                                       Register retry_on_abort_count_Reg,\n-                                       RTMLockingCounters* stack_rtm_counters,\n-                                       Metadata* method_data, bool profile_rtm,\n-                                       Label& DONE_LABEL, Label& IsInflated) {\n-  assert(UseRTMForStackLocks, \"why call this otherwise?\");\n-  Label L_rtm_retry, L_decrement_retry, L_on_abort;\n-\n-  if (RTMRetryCount > 0) {\n-    load_const_optimized(retry_on_abort_count_Reg, RTMRetryCount); \/\/ Retry on abort\n-    bind(L_rtm_retry);\n-  }\n-  andi_(R0, mark_word, markWord::monitor_value);  \/\/ inflated vs stack-locked|neutral\n-  bne(CCR0, IsInflated);\n-\n-  if (PrintPreciseRTMLockingStatistics || profile_rtm) {\n-    Label L_noincrement;\n-    if (RTMTotalCountIncrRate > 1) {\n-      branch_on_random_using_tb(tmp, RTMTotalCountIncrRate, L_noincrement);\n-    }\n-    assert(stack_rtm_counters != nullptr, \"should not be null when profiling RTM\");\n-    load_const_optimized(tmp, (address)stack_rtm_counters->total_count_addr(), R0);\n-    \/\/atomic_inc_ptr(tmp, \/*temp, will be reloaded*\/mark_word); We don't increment atomically\n-    ldx(mark_word, tmp);\n-    addi(mark_word, mark_word, 1);\n-    stdx(mark_word, tmp);\n-    bind(L_noincrement);\n-  }\n-  tbegin_();\n-  beq(CCR0, L_on_abort);\n-  ld(mark_word, oopDesc::mark_offset_in_bytes(), obj);   \/\/ Reload in transaction, conflicts need to be tracked.\n-  andi(R0, mark_word, markWord::lock_mask_in_place);     \/\/ look at 2 lock bits\n-  cmpwi(flag, R0, markWord::unlocked_value);             \/\/ bits = 01 unlocked\n-  beq(flag, DONE_LABEL);                                 \/\/ all done if unlocked\n-\n-  if (UseRTMXendForLockBusy) {\n-    tend_();\n-    b(L_decrement_retry);\n-  } else {\n-    tabort_();\n-  }\n-  bind(L_on_abort);\n-  const Register abort_status_Reg = tmp;\n-  mftexasr(abort_status_Reg);\n-  if (PrintPreciseRTMLockingStatistics || profile_rtm) {\n-    rtm_profiling(abort_status_Reg, \/*temp*\/mark_word, stack_rtm_counters, method_data, profile_rtm);\n-  }\n-  ld(mark_word, oopDesc::mark_offset_in_bytes(), obj); \/\/ reload\n-  if (RTMRetryCount > 0) {\n-    \/\/ Retry on lock abort if abort status is not permanent.\n-    rtm_retry_lock_on_abort(retry_on_abort_count_Reg, abort_status_Reg, L_rtm_retry, &L_decrement_retry);\n-  } else {\n-    bind(L_decrement_retry);\n-  }\n-}\n-\n-\/\/ Use RTM for inflating locks\n-\/\/ inputs: obj       (object to lock)\n-\/\/         mark_word (current header - KILLED)\n-\/\/         boxReg    (on-stack box address (displaced header location) - KILLED)\n-void MacroAssembler::rtm_inflated_locking(ConditionRegister flag,\n-                                          Register obj, Register mark_word, Register boxReg,\n-                                          Register retry_on_busy_count_Reg, Register retry_on_abort_count_Reg,\n-                                          RTMLockingCounters* rtm_counters,\n-                                          Metadata* method_data, bool profile_rtm,\n-                                          Label& DONE_LABEL) {\n-  assert(UseRTMLocking, \"why call this otherwise?\");\n-  Label L_rtm_retry, L_decrement_retry, L_on_abort;\n-  \/\/ Clean monitor_value bit to get valid pointer.\n-  int owner_offset = in_bytes(ObjectMonitor::owner_offset()) - markWord::monitor_value;\n-\n-  \/\/ Store non-null, using boxReg instead of (intptr_t)markWord::unused_mark().\n-  std(boxReg, BasicLock::displaced_header_offset_in_bytes(), boxReg);\n-  const Register tmpReg = boxReg;\n-  const Register owner_addr_Reg = mark_word;\n-  addi(owner_addr_Reg, mark_word, owner_offset);\n-\n-  if (RTMRetryCount > 0) {\n-    load_const_optimized(retry_on_busy_count_Reg, RTMRetryCount);  \/\/ Retry on lock busy.\n-    load_const_optimized(retry_on_abort_count_Reg, RTMRetryCount); \/\/ Retry on abort.\n-    bind(L_rtm_retry);\n-  }\n-  if (PrintPreciseRTMLockingStatistics || profile_rtm) {\n-    Label L_noincrement;\n-    if (RTMTotalCountIncrRate > 1) {\n-      branch_on_random_using_tb(R0, RTMTotalCountIncrRate, L_noincrement);\n-    }\n-    assert(rtm_counters != nullptr, \"should not be null when profiling RTM\");\n-    load_const(R0, (address)rtm_counters->total_count_addr(), tmpReg);\n-    \/\/atomic_inc_ptr(R0, tmpReg); We don't increment atomically\n-    ldx(tmpReg, R0);\n-    addi(tmpReg, tmpReg, 1);\n-    stdx(tmpReg, R0);\n-    bind(L_noincrement);\n-  }\n-  tbegin_();\n-  beq(CCR0, L_on_abort);\n-  \/\/ We don't reload mark word. Will only be reset at safepoint.\n-  ld(R0, 0, owner_addr_Reg); \/\/ Load in transaction, conflicts need to be tracked.\n-  cmpdi(flag, R0, 0);\n-  beq(flag, DONE_LABEL);\n-\n-  if (UseRTMXendForLockBusy) {\n-    tend_();\n-    b(L_decrement_retry);\n-  } else {\n-    tabort_();\n-  }\n-  bind(L_on_abort);\n-  const Register abort_status_Reg = tmpReg;\n-  mftexasr(abort_status_Reg);\n-  if (PrintPreciseRTMLockingStatistics || profile_rtm) {\n-    rtm_profiling(abort_status_Reg, \/*temp*\/ owner_addr_Reg, rtm_counters, method_data, profile_rtm);\n-    \/\/ Restore owner_addr_Reg\n-    ld(mark_word, oopDesc::mark_offset_in_bytes(), obj);\n-#ifdef ASSERT\n-    andi_(R0, mark_word, markWord::monitor_value);\n-    asm_assert_ne(\"must be inflated\"); \/\/ Deflating only allowed at safepoint.\n-#endif\n-    addi(owner_addr_Reg, mark_word, owner_offset);\n-  }\n-  if (RTMRetryCount > 0) {\n-    \/\/ Retry on lock abort if abort status is not permanent.\n-    rtm_retry_lock_on_abort(retry_on_abort_count_Reg, abort_status_Reg, L_rtm_retry);\n-  }\n-\n-  \/\/ Appears unlocked - try to swing _owner from null to non-null.\n-  cmpxchgd(flag, \/*current val*\/ R0, (intptr_t)0, \/*new val*\/ R16_thread, owner_addr_Reg,\n-           MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-           MacroAssembler::cmpxchgx_hint_acquire_lock(), noreg, &L_decrement_retry, true);\n-\n-  if (RTMRetryCount > 0) {\n-    \/\/ success done else retry\n-    b(DONE_LABEL);\n-    bind(L_decrement_retry);\n-    \/\/ Spin and retry if lock is busy.\n-    rtm_retry_lock_on_busy(retry_on_busy_count_Reg, owner_addr_Reg, L_rtm_retry);\n-  } else {\n-    bind(L_decrement_retry);\n-  }\n-}\n-\n-#endif \/\/  INCLUDE_RTM_OPT\n-\n@@ -2626,5 +2178,1 @@\n-                                               Register temp, Register displaced_header, Register current_header,\n-                                               RTMLockingCounters* rtm_counters,\n-                                               RTMLockingCounters* stack_rtm_counters,\n-                                               Metadata* method_data,\n-                                               bool use_rtm, bool profile_rtm) {\n+                                               Register temp, Register displaced_header, Register current_header) {\n@@ -2647,8 +2195,0 @@\n-#if INCLUDE_RTM_OPT\n-  if (UseRTMForStackLocks && use_rtm) {\n-    rtm_stack_locking(flag, oop, displaced_header, temp, \/*temp*\/ current_header,\n-                      stack_rtm_counters, method_data, profile_rtm,\n-                      success, object_has_monitor);\n-  }\n-#endif \/\/ INCLUDE_RTM_OPT\n-\n@@ -2719,9 +2259,0 @@\n-#if INCLUDE_RTM_OPT\n-  \/\/ Use the same RTM locking code in 32- and 64-bit VM.\n-  if (use_rtm) {\n-    rtm_inflated_locking(flag, oop, displaced_header, box, temp, \/*temp*\/ current_header,\n-                         rtm_counters, method_data, profile_rtm, success);\n-    bne(flag, failure);\n-  } else {\n-#endif \/\/ INCLUDE_RTM_OPT\n-\n@@ -2754,4 +2285,0 @@\n-#if INCLUDE_RTM_OPT\n-  } \/\/ use_rtm()\n-#endif\n-\n@@ -2766,2 +2293,1 @@\n-                                                 Register temp, Register displaced_header, Register current_header,\n-                                                 bool use_rtm) {\n+                                                 Register temp, Register displaced_header, Register current_header) {\n@@ -2772,13 +2298,0 @@\n-#if INCLUDE_RTM_OPT\n-  if (UseRTMForStackLocks && use_rtm) {\n-    Label L_regular_unlock;\n-    ld(current_header, oopDesc::mark_offset_in_bytes(), oop);   \/\/ fetch markword\n-    andi(R0, current_header, markWord::lock_mask_in_place);     \/\/ look at 2 lock bits\n-    cmpwi(flag, R0, markWord::unlocked_value);                  \/\/ bits = 01 unlocked\n-    bne(flag, L_regular_unlock);                                \/\/ else RegularLock\n-    tend_();                                                    \/\/ otherwise end...\n-    b(success);                                                 \/\/ ... and we're done\n-    bind(L_regular_unlock);\n-  }\n-#endif\n-\n@@ -2796,1 +2309,0 @@\n-  RTM_OPT_ONLY( if (!(UseRTMForStackLocks && use_rtm)) ) \/\/ skip load if already done\n@@ -2832,13 +2344,0 @@\n-  \/\/ It's inflated.\n-#if INCLUDE_RTM_OPT\n-  if (use_rtm) {\n-    Label L_regular_inflated_unlock;\n-    \/\/ Clean monitor_value bit to get valid pointer\n-    cmpdi(flag, temp, 0);\n-    bne(flag, L_regular_inflated_unlock);\n-    tend_();\n-    b(success);\n-    bind(L_regular_inflated_unlock);\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":2,"deletions":503,"binary":false,"changes":505,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"runtime\/rtmLocking.hpp\"\n@@ -626,25 +625,0 @@\n-  void atomic_inc_ptr(Register addr, Register result, int simm16 = 1);\n-  void atomic_ori_int(Register addr, Register result, int uimm16);\n-\n-#if INCLUDE_RTM_OPT\n-  void rtm_counters_update(Register abort_status, Register rtm_counters);\n-  void branch_on_random_using_tb(Register tmp, int count, Label& brLabel);\n-  void rtm_abort_ratio_calculation(Register rtm_counters_reg, RTMLockingCounters* rtm_counters,\n-                                   Metadata* method_data);\n-  void rtm_profiling(Register abort_status_Reg, Register temp_Reg,\n-                     RTMLockingCounters* rtm_counters, Metadata* method_data, bool profile_rtm);\n-  void rtm_retry_lock_on_abort(Register retry_count, Register abort_status,\n-                               Label& retryLabel, Label* checkRetry = nullptr);\n-  void rtm_retry_lock_on_busy(Register retry_count, Register owner_addr, Label& retryLabel);\n-  void rtm_stack_locking(ConditionRegister flag, Register obj, Register mark_word, Register tmp,\n-                         Register retry_on_abort_count,\n-                         RTMLockingCounters* stack_rtm_counters,\n-                         Metadata* method_data, bool profile_rtm,\n-                         Label& DONE_LABEL, Label& IsInflated);\n-  void rtm_inflated_locking(ConditionRegister flag, Register obj, Register mark_word, Register box,\n-                            Register retry_on_busy_count, Register retry_on_abort_count,\n-                            RTMLockingCounters* rtm_counters,\n-                            Metadata* method_data, bool profile_rtm,\n-                            Label& DONE_LABEL);\n-#endif\n-\n@@ -652,5 +626,1 @@\n-                                 Register tmp1, Register tmp2, Register tmp3,\n-                                 RTMLockingCounters* rtm_counters = nullptr,\n-                                 RTMLockingCounters* stack_rtm_counters = nullptr,\n-                                 Metadata* method_data = nullptr,\n-                                 bool use_rtm = false, bool profile_rtm = false);\n+                                 Register tmp1, Register tmp2, Register tmp3);\n@@ -659,2 +629,1 @@\n-                                   Register tmp1, Register tmp2, Register tmp3,\n-                                   bool use_rtm = false);\n+                                   Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":2,"deletions":33,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -12141,1 +12141,0 @@\n-  predicate(!Compile::current()->use_rtm());\n@@ -12154,20 +12153,0 @@\n-\/\/ Separate version for TM. Use bound register for box to enable USE_KILL.\n-instruct cmpFastLock_tm(flagsReg crx, iRegPdst oop, rarg2RegP box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{\n-  match(Set crx (FastLock oop box));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL box);\n-  predicate(Compile::current()->use_rtm());\n-\n-  format %{ \"FASTLOCK  $oop, $box, $tmp1, $tmp2, $tmp3 (TM)\" %}\n-  ins_encode %{\n-    __ compiler_fast_lock_object($crx$$CondRegister, $oop$$Register, $box$$Register,\n-                                 $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n-                                 _rtm_counters, _stack_rtm_counters,\n-                                 ((Method*)(ra_->C->method()->constant_encoding()))->method_data(),\n-                                 \/*RTM*\/ true, ra_->C->profile_rtm());\n-    \/\/ If locking was successful, crx should indicate 'EQ'.\n-    \/\/ The compiler generates a branch to the runtime call to\n-    \/\/ _complete_monitor_locking_Java for the case where crx is 'NE'.\n-  %}\n-  ins_pipe(pipe_class_compare);\n-%}\n-\n@@ -12177,1 +12156,0 @@\n-  predicate(!Compile::current()->use_rtm());\n@@ -12182,19 +12160,1 @@\n-                                   $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n-                                   false);\n-    \/\/ If unlocking was successful, crx should indicate 'EQ'.\n-    \/\/ The compiler generates a branch to the runtime call to\n-    \/\/ _complete_monitor_unlocking_Java for the case where crx is 'NE'.\n-  %}\n-  ins_pipe(pipe_class_compare);\n-%}\n-\n-instruct cmpFastUnlock_tm(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{\n-  match(Set crx (FastUnlock oop box));\n-  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n-  predicate(Compile::current()->use_rtm());\n-\n-  format %{ \"FASTUNLOCK  $oop, $box, $tmp1, $tmp2 (TM)\" %}\n-  ins_encode %{\n-    __ compiler_fast_unlock_object($crx$$CondRegister, $oop$$Register, $box$$Register,\n-                                   $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n-                                   \/*RTM*\/ true);\n+                                   $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":1,"deletions":41,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2280,7 +2280,0 @@\n-  if (UseRTMLocking) {\n-    \/\/ Abort RTM transaction before calling JNI\n-    \/\/ because critical section can be large and\n-    \/\/ abort anyway. Also nmethod can be deoptimized.\n-    __ tabort_();\n-  }\n-\n@@ -3168,5 +3161,0 @@\n-  if (UseRTMLocking) {\n-    \/\/ Abort RTM transaction before possible nmethod deoptimization.\n-    __ tabort_();\n-  }\n-\n@@ -3323,7 +3311,0 @@\n-  if (UseRTMLocking) {\n-    \/\/ Abort RTM transaction before calling runtime\n-    \/\/ because critical section can be large and so\n-    \/\/ will abort anyway. Also nmethod can be deoptimized.\n-    __ tabort_();\n-  }\n-\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -48,8 +48,0 @@\n-#if defined(LINUX) && defined(VM_LITTLE_ENDIAN)\n-#include <sys\/auxv.h>\n-\n-#ifndef PPC_FEATURE2_HTM_NOSC\n-#define PPC_FEATURE2_HTM_NOSC (1 << 24)\n-#endif\n-#endif\n-\n@@ -185,1 +177,1 @@\n-               \"ppc64%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n+               \"ppc64%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s\",\n@@ -202,1 +194,0 @@\n-               (has_tm()      ? \" rtm\"     : \"\"),\n@@ -379,43 +370,0 @@\n-\n-  \/\/ Adjust RTM (Restricted Transactional Memory) flags.\n-  if (UseRTMLocking) {\n-    \/\/ If CPU or OS do not support RTM:\n-    if (PowerArchitecturePPC64 < 8 || PowerArchitecturePPC64 > 9) {\n-      vm_exit_during_initialization(\"RTM instructions are not available on this CPU.\");\n-    }\n-\n-    if (!has_tm()) {\n-      vm_exit_during_initialization(\"RTM is not supported on this OS version.\");\n-    }\n-\n-#if INCLUDE_RTM_OPT\n-    if (!FLAG_IS_CMDLINE(UseRTMLocking)) {\n-      \/\/ RTM locking should be used only for applications with\n-      \/\/ high lock contention. For now we do not use it by default.\n-      vm_exit_during_initialization(\"UseRTMLocking flag should be only set on command line\");\n-    }\n-    if (LockingMode != LM_LEGACY) {\n-      warning(\"UseRTMLocking requires LockingMode = 1\");\n-      FLAG_SET_DEFAULT(UseRTMLocking, false);\n-    }\n-#else\n-    \/\/ Only C2 does RTM locking optimization.\n-    vm_exit_during_initialization(\"RTM locking optimization is not supported in this VM\");\n-#endif\n-  } else { \/\/ !UseRTMLocking\n-    if (UseRTMForStackLocks) {\n-      if (!FLAG_IS_DEFAULT(UseRTMForStackLocks)) {\n-        warning(\"UseRTMForStackLocks flag should be off when UseRTMLocking flag is off\");\n-      }\n-      FLAG_SET_DEFAULT(UseRTMForStackLocks, false);\n-    }\n-    if (UseRTMDeopt) {\n-      FLAG_SET_DEFAULT(UseRTMDeopt, false);\n-    }\n-#ifdef COMPILER2\n-    if (PrintPreciseRTMLockingStatistics) {\n-      FLAG_SET_DEFAULT(PrintPreciseRTMLockingStatistics, false);\n-    }\n-#endif\n-  }\n-\n@@ -604,1 +552,0 @@\n-  \/\/ rtm is determined by OS\n@@ -658,1 +605,0 @@\n-  \/\/ feature rtm_m is determined by OS\n@@ -670,31 +616,0 @@\n-\n-#ifdef AIX\n-  \/\/ To enable it on AIX it's necessary POWER8 or above and at least AIX 7.2.\n-  \/\/ Actually, this is supported since AIX 7.1.. Unfortunately, this first\n-  \/\/ contained bugs, so that it can only be enabled after AIX 7.1.3.30.\n-  \/\/ The Java property os.version, which is used in RTM tests to decide\n-  \/\/ whether the feature is available, only knows major and minor versions.\n-  \/\/ We don't want to change this property, as user code might depend on it.\n-  \/\/ So the tests can not check on subversion 3.30, and we only enable RTM\n-  \/\/ with AIX 7.2.\n-  if (has_lqarx() && !has_brw()) { \/\/ POWER8 or POWER9\n-    if (os::Aix::os_version() >= 0x07020000) { \/\/ At least AIX 7.2.\n-      _features |= rtm_m;\n-    }\n-  }\n-#endif\n-#if defined(LINUX) && defined(VM_LITTLE_ENDIAN)\n-  unsigned long auxv = getauxval(AT_HWCAP2);\n-\n-  if (auxv & PPC_FEATURE2_HTM_NOSC) {\n-    if (auxv & PPC_FEATURE2_HAS_HTM) {\n-      \/\/ TM on POWER8 and POWER9 in compat mode (VM) is supported by the JVM.\n-      \/\/ TM on POWER9 DD2.1 NV (baremetal) is not supported by the JVM (TM on\n-      \/\/ POWER9 DD2.1 NV has a few issues that need a couple of firmware\n-      \/\/ and kernel workarounds, so there is a new mode only supported\n-      \/\/ on non-virtualized P9 machines called HTM with no Suspend Mode).\n-      \/\/ TM on POWER9 D2.2+ NV is not supported at all by Linux.\n-      _features |= rtm_m;\n-    }\n-  }\n-#endif\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":1,"deletions":86,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-    rtm,\n@@ -76,1 +75,0 @@\n-    rtm_m                 = (1 << rtm    ),\n@@ -119,1 +117,0 @@\n-  static bool has_tm()      { return (_features & rtm_m) != 0; }\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1921,1 +1921,1 @@\n-#if (defined(X86) || defined(PPC64)) && !defined(ZERO)\n+#if defined(X86) && !defined(ZERO)\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-compiler\/rtm\/locking\/TestRTMDeoptOnLowAbortRatio.java 8183263,8307907 generic-x64,generic-i586,aix-ppc64\n+compiler\/rtm\/locking\/TestRTMDeoptOnLowAbortRatio.java 8183263 generic-x64,generic-i586\n@@ -60,1 +60,1 @@\n-compiler\/rtm\/locking\/TestRTMLockingThreshold.java 8183263,8307907 generic-x64,generic-i586,aix-ppc64\n+compiler\/rtm\/locking\/TestRTMLockingThreshold.java 8183263 generic-x64,generic-i586\n@@ -63,2 +63,2 @@\n-compiler\/rtm\/locking\/TestUseRTMXendForLockBusy.java 8183263,8307907 generic-x64,generic-i586,aix-ppc64\n-compiler\/rtm\/print\/TestPrintPreciseRTMLockingStatistics.java 8183263,8307907 generic-x64,generic-i586,aix-ppc64\n+compiler\/rtm\/locking\/TestUseRTMXendForLockBusy.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/print\/TestPrintPreciseRTMLockingStatistics.java 8183263 generic-x64,generic-i586\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,2 +39,0 @@\n-    protected static final String RTM_OS_ERROR\n-            = \"RTM is not supported on this OS version\";\n@@ -87,1 +85,1 @@\n-        if (Platform.isX86() || Platform.isX64() || Platform.isPPC()) {\n+        if (Platform.isX86() || Platform.isX64()) {\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/RTMGenericCommandLineOptionTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-        if (Platform.isX86() || Platform.isX64() || Platform.isPPC()) {\n+        if (Platform.isX86() || Platform.isX64()) {\n@@ -56,27 +56,7 @@\n-            try {\n-                \/\/ verify that we get an error when use +UseRTMLocking\n-                \/\/ on unsupported CPU\n-                CommandLineOptionTest.verifySameJVMStartup(\n-                        new String[] { errorMessage },\n-                        new String[] { unrecognizedOption }, shouldFailMessage,\n-                        shouldFailMessage + \". Error message should be shown.\",\n-                        ExitCode.FAIL, \"-XX:+UseRTMLocking\");\n-            } catch (Throwable e) {\n-                \/\/ verify that we get an error when use +UseRTMLocking\n-                \/\/ on unsupported OS. It might be the case that although CPU\n-                \/\/ supports RTM the OS version does not support RTM\n-                if (Platform.isPPC()) {\n-                    String errorMessage2 = RTMGenericCommandLineOptionTest.RTM_OS_ERROR;\n-                    String shouldFailMessage2 = \"JVM startup should fail with option \" +\n-                                                \"-XX:+UseRTMLocking on unsupported CPU or \" +\n-                                                \"OS version\";\n-\n-                    CommandLineOptionTest.verifySameJVMStartup(\n-                            new String[] { errorMessage2 },\n-                            new String[] { unrecognizedOption}, shouldFailMessage2,\n-                            shouldFailMessage2 + \". Error message should be shown.\",\n-                            ExitCode.FAIL, \"-XX:+UseRTMLocking\");\n-                } else {\n-                    throw e; \/\/ checking unsupported OS error is not necessary\n-                }\n-            }\n+            \/\/ verify that we get an error when use +UseRTMLocking\n+            \/\/ on unsupported CPU\n+            CommandLineOptionTest.verifySameJVMStartup(\n+                    new String[] { errorMessage },\n+                    new String[] { unrecognizedOption }, shouldFailMessage,\n+                    shouldFailMessage + \". Error message should be shown.\",\n+                    ExitCode.FAIL, \"-XX:+UseRTMLocking\");\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestUseRTMLockingOptionOnUnsupportedCPU.java","additions":8,"deletions":28,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -66,5 +66,1 @@\n-        if (Platform.isPPC()) {\n-            SPIN_LOOP_COUNTS = new int[] { 0, 10, 100, 1_000, 10_000 };\n-        } else {\n-            SPIN_LOOP_COUNTS = new int[] { 0, 100, 1_000, 10_000, 100_000 };\n-        }\n+        SPIN_LOOP_COUNTS = new int[] { 0, 100, 1_000, 10_000, 100_000 };\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/locking\/TestRTMSpinLoopCount.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"}]}