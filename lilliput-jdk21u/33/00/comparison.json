{"files":[{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024 SAP SE. All rights reserved.\n@@ -3152,0 +3152,4 @@\n+  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n+\n+  assert_different_registers(temp1, temp2, oop, box);\n+\n@@ -3155,1 +3159,1 @@\n-  z_lg(displacedHeader, 0, oop);\n+  z_lg(displacedHeader, hdr_offset, oop);\n@@ -3158,2 +3162,2 @@\n-    load_klass(Z_R1_scratch, oop);\n-    z_l(Z_R1_scratch, Address(Z_R1_scratch, Klass::access_flags_offset()));\n+    load_klass(temp, oop);\n+    z_l(temp, Address(temp, Klass::access_flags_offset()));\n@@ -3161,1 +3165,1 @@\n-    z_nilh(Z_R1_scratch, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n+    z_nilh(temp, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n@@ -3168,3 +3172,2 @@\n-  z_lgr(temp, displacedHeader);\n-  z_nill(temp, markWord::monitor_value);\n-  z_brne(object_has_monitor);\n+  z_tmll(displacedHeader, markWord::monitor_value);\n+  z_brnaz(object_has_monitor);\n@@ -3174,0 +3177,1 @@\n+    \/\/ From loading the markWord, we know that oop != nullptr\n@@ -3185,6 +3189,3 @@\n-    \/\/ Memory Fence (in cmpxchgd)\n-    \/\/ Compare object markWord with mark and if equal exchange scratch1 with object markWord.\n-\n-    \/\/ If the compare-and-swap succeeded, then we found an unlocked object and we\n-    \/\/ have now locked it.\n-    z_csg(displacedHeader, box, 0, oop);\n+    \/\/ Compare object markWord with mark and if equal, exchange box with object markWork.\n+    \/\/ If the compare-and-swap succeeds, then we found an unlocked object and have now locked it.\n+    z_csg(displacedHeader, box, hdr_offset, oop);\n@@ -3194,2 +3195,4 @@\n-    \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n+    \/\/ We did not see an unlocked object\n+    \/\/ currentHeader contains what is currently stored in the oop's markWord.\n+    \/\/ We might have a recursive case. Verify by checking if the owner is self.\n+    \/\/ To do so, compare the value in the markWord (currentHeader) with the stack pointer.\n@@ -3200,2 +3203,4 @@\n-    \/\/   z_brne(done);\n-    \/\/   z_release();\n+\n+    \/\/ result zero: owner is self -> recursive lock. Indicate that by storing 0 in the box.\n+    \/\/ result not-zero: attempt failed. We don't hold the lock -> go for slow case.\n+\n@@ -3211,0 +3216,2 @@\n+  bind(object_has_monitor);\n+\n@@ -3213,1 +3220,0 @@\n-  bind(object_has_monitor);\n@@ -3216,1 +3222,1 @@\n-  \/\/\n+\n@@ -3218,1 +3224,0 @@\n-  z_lghi(zero, 0);\n@@ -3220,0 +3225,2 @@\n+  \/\/ Otherwise, register zero is filled with the current owner.\n+  z_lghi(zero, 0);\n@@ -3225,8 +3232,12 @@\n-#ifdef ASSERT\n-  z_brne(done);\n-  \/\/ We've acquired the monitor, check some invariants.\n-  \/\/ Invariant 1: _recursions should be 0.\n-  asm_assert_mem8_is_zero(OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions), monitor_tagged,\n-                          \"monitor->_recursions should be 0\", -1);\n-  z_ltgr(zero, zero); \/\/ Set CR=EQ.\n-#endif\n+\n+  z_bre(done); \/\/ acquired the lock for the first time.\n+\n+  BLOCK_COMMENT(\"fast_path_recursive_lock {\");\n+  \/\/ Check if we are already the owner (recursive lock)\n+  z_cgr(Z_thread, zero); \/\/ owner is stored in zero by \"z_csg\" above\n+  z_brne(done); \/\/ not a recursive lock\n+\n+  \/\/ Current thread already owns the lock. Just increment recursion count.\n+  z_agsi(Address(monitor_tagged, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n+  z_cgr(zero, zero); \/\/ set the CC to EQUAL\n+  BLOCK_COMMENT(\"} fast_path_recursive_lock\");\n@@ -3245,1 +3256,0 @@\n-  Register monitor = temp2;\n@@ -3249,1 +3259,3 @@\n-  Label done, object_has_monitor;\n+  assert_different_registers(temp1, temp2, oop, box);\n+\n+  Label done, object_has_monitor, not_recursive;\n@@ -3264,5 +3276,3 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    z_lgr(temp, currentHeader);\n-  }\n-  z_nill(currentHeader, markWord::monitor_value);\n-  z_brne(object_has_monitor);\n+\n+  z_tmll(currentHeader, markWord::monitor_value);\n+  z_brnaz(object_has_monitor);\n@@ -3275,1 +3285,1 @@\n-    \/\/ Check if it is still a light weight lock, this is true if we see\n+    \/\/ Check if it is still a lightweight lock, this is true if we see\n@@ -3279,1 +3289,1 @@\n-    z_csg(currentHeader, displacedHeader, 0, oop);\n+    z_csg(currentHeader, displacedHeader, hdr_offset, oop);\n@@ -3284,4 +3294,1 @@\n-    \/\/ don't load currentHead again from stack-top after monitor check, as it is possible\n-    \/\/ some other thread modified it.\n-    \/\/ currentHeader is altered, but it's contents are copied in temp as well\n-    lightweight_unlock(oop, temp, currentHeader, done);\n+    lightweight_unlock(oop, currentHeader, displacedHeader, done);\n@@ -3296,4 +3303,2 @@\n-  z_lg(currentHeader, hdr_offset, oop);    \/\/ CurrentHeader is tagged with monitor_value set.\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-  z_brne(done);\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n+\n+  z_cg(Z_thread, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n@@ -3301,0 +3306,13 @@\n+\n+  BLOCK_COMMENT(\"fast_path_recursive_unlock {\");\n+  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+  z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n+\n+  \/\/ Recursive inflated unlock\n+  z_agsi(Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n+  z_cgr(currentHeader, currentHeader); \/\/ set the CC to EQUAL\n+  BLOCK_COMMENT(\"} fast_path_recursive_unlock\");\n+  z_bru(done);\n+\n+  bind(not_recursive);\n+\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":65,"deletions":47,"binary":false,"changes":112,"status":"modified"}]}