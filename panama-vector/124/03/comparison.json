{"files":[{"patch":"@@ -2704,1 +2704,5 @@\n-      (UseSVE > 0 && m->Opcode() == Op_VectorStoreMask)) {\n+      (UseSVE > 0 && m->Opcode() == Op_VectorStoreMask &&\n+       (n->Opcode() == Op_StoreVector ||\n+        n->Opcode() == Op_VectorMaskTrueCount ||\n+        n->Opcode() == Op_VectorMaskFirstTrue ||\n+        n->Opcode() == Op_VectorMaskLastTrue))) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4386,1 +4386,1 @@\n-\/\/ vector mask cast\n+\/\/ ------------------------------ Vector mask cast --------------------------\n@@ -4401,0 +4401,32 @@\n+instruct vmaskcast_extend(pRegGov dst, pReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            (Matcher::vector_length_in_bytes(n) == 2 * Matcher::vector_length_in_bytes(n->in(1)) ||\n+             Matcher::vector_length_in_bytes(n) == 4 * Matcher::vector_length_in_bytes(n->in(1)) ||\n+             Matcher::vector_length_in_bytes(n) == 8 * Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorMaskCast src));\n+  ins_cost(SVE_COST * 3);\n+  format %{ \"sve_vmaskcast_extend  $dst, $src\\t# extend predicate $src\" %}\n+  ins_encode %{\n+    __ sve_vmaskcast_extend(as_PRegister($dst$$reg), as_PRegister($src$$reg),\n+                            Matcher::vector_length_in_bytes(this), Matcher::vector_length_in_bytes(this, $src));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_narrow(pRegGov dst, pReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            (Matcher::vector_length_in_bytes(n) * 2 == Matcher::vector_length_in_bytes(n->in(1)) ||\n+             Matcher::vector_length_in_bytes(n) * 4 == Matcher::vector_length_in_bytes(n->in(1)) ||\n+             Matcher::vector_length_in_bytes(n) * 8 == Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorMaskCast src));\n+  ins_cost(SVE_COST * 3);\n+  format %{ \"sve_vmaskcast_narrow  $dst, $src\\t# narrow predicate $src\" %}\n+  ins_encode %{\n+    __ sve_vmaskcast_narrow(as_PRegister($dst$$reg), as_PRegister($src$$reg),\n+                            Matcher::vector_length_in_bytes(this), Matcher::vector_length_in_bytes(this, $src));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2138,1 +2138,1 @@\n-\/\/ vector mask cast\n+\/\/ ------------------------------ Vector mask cast --------------------------\n@@ -2153,0 +2153,33 @@\n+instruct vmaskcast_extend(pRegGov dst, pReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            (Matcher::vector_length_in_bytes(n) == 2 * Matcher::vector_length_in_bytes(n->in(1)) ||\n+             Matcher::vector_length_in_bytes(n) == 4 * Matcher::vector_length_in_bytes(n->in(1)) ||\n+             Matcher::vector_length_in_bytes(n) == 8 * Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorMaskCast src));\n+  ins_cost(SVE_COST * 3);\n+  format %{ \"sve_vmaskcast_extend  $dst, $src\\t# extend predicate $src\" %}\n+  ins_encode %{\n+    __ sve_vmaskcast_extend(as_PRegister($dst$$reg), as_PRegister($src$$reg),\n+                            Matcher::vector_length_in_bytes(this), Matcher::vector_length_in_bytes(this, $src));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vmaskcast_narrow(pRegGov dst, pReg src)\n+%{\n+  predicate(UseSVE > 0 &&\n+            (Matcher::vector_length_in_bytes(n) * 2 == Matcher::vector_length_in_bytes(n->in(1)) ||\n+             Matcher::vector_length_in_bytes(n) * 4 == Matcher::vector_length_in_bytes(n->in(1)) ||\n+             Matcher::vector_length_in_bytes(n) * 8 == Matcher::vector_length_in_bytes(n->in(1))));\n+  match(Set dst (VectorMaskCast src));\n+  ins_cost(SVE_COST * 3);\n+  format %{ \"sve_vmaskcast_narrow  $dst, $src\\t# narrow predicate $src\" %}\n+  ins_encode %{\n+    __ sve_vmaskcast_narrow(as_PRegister($dst$$reg), as_PRegister($src$$reg),\n+                            Matcher::vector_length_in_bytes(this), Matcher::vector_length_in_bytes(this, $src));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+dnl\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -3394,0 +3394,12 @@\n+\/\/ SVE unpack predicate elements\n+#define INSN(NAME, op) \\\n+  void NAME(PRegister Pd, PRegister Pn) { \\\n+    starti;                                                          \\\n+    f(0b000001010011000, 31, 17), f(op, 16), f(0b0100000, 15, 9);    \\\n+    prf(Pn, 5), f(0b0, 4), prf(Pd, 0);                               \\\n+  }\n+\n+  INSN(sve_punpkhi, 0b1); \/\/ Unpack and widen high half of predicate\n+  INSN(sve_punpklo, 0b0); \/\/ Unpack and widen low half of predicate\n+#undef INSN\n+\n@@ -3407,0 +3419,13 @@\n+\/\/ SVE permute predicate elements\n+#define INSN(NAME, op) \\\n+  void NAME(PRegister Pd, SIMD_RegVariant T, PRegister Pn, PRegister Pm) {             \\\n+    starti;                                                                            \\\n+    assert(T != Q, \"invalid size\");                                                    \\\n+    f(0b00000101, 31, 24), f(T, 23, 22), f(0b10, 21, 20), prf(Pm, 16);                 \\\n+    f(0b01001, 15, 11), f(op, 10), f(0b0, 9), prf(Pn, 5), f(0b0, 4), prf(Pd, 0);       \\\n+  }\n+\n+  INSN(sve_uzp1, 0b0); \/\/ Concatenate even elements from two predicates\n+  INSN(sve_uzp2, 0b1); \/\/ Concatenate odd elements from two predicates\n+#undef INSN\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1010,0 +1010,40 @@\n+\/\/ Extend src predicate to dst predicate with the same lane count but larger\n+\/\/ element size, e.g. 64Byte -> 512Long\n+void C2_MacroAssembler::sve_vmaskcast_extend(PRegister dst, PRegister src,\n+                                             uint dst_element_length_in_bytes,\n+                                             uint src_element_length_in_bytes) {\n+  if (dst_element_length_in_bytes == 2 * src_element_length_in_bytes) {\n+    sve_punpklo(dst, src);\n+  } else if (dst_element_length_in_bytes == 4 * src_element_length_in_bytes) {\n+    sve_punpklo(dst, src);\n+    sve_punpklo(dst, dst);\n+  } else if (dst_element_length_in_bytes == 8 * src_element_length_in_bytes) {\n+    sve_punpklo(dst, src);\n+    sve_punpklo(dst, dst);\n+    sve_punpklo(dst, dst);\n+  } else {\n+    assert(false, \"unsupported\");\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+\/\/ Narrow src predicate to dst predicate with the same lane count but\n+\/\/ smaller element size, e.g. 512Long -> 64Byte\n+void C2_MacroAssembler::sve_vmaskcast_narrow(PRegister dst, PRegister src,\n+                                             uint dst_element_length_in_bytes, uint src_element_length_in_bytes) {\n+  \/\/ The insignificant bits in src predicate are expected to be zero.\n+  if (dst_element_length_in_bytes * 2 == src_element_length_in_bytes) {\n+    sve_uzp1(dst, B, src, src);\n+  } else if (dst_element_length_in_bytes * 4 == src_element_length_in_bytes) {\n+    sve_uzp1(dst, H, src, src);\n+    sve_uzp1(dst, B, dst, dst);\n+  } else if (dst_element_length_in_bytes * 8 == src_element_length_in_bytes) {\n+    sve_uzp1(dst, S, src, src);\n+    sve_uzp1(dst, H, dst, dst);\n+    sve_uzp1(dst, B, dst, dst);\n+  } else {\n+    assert(false, \"unsupported\");\n+    ShouldNotReachHere();\n+  }\n+}\n+\n@@ -1107,1 +1147,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -70,0 +70,6 @@\n+  void sve_vmaskcast_extend(PRegister dst, PRegister src,\n+                            uint dst_element_length_in_bytes, uint src_element_lenght_in_bytes);\n+\n+  void sve_vmaskcast_narrow(PRegister dst, PRegister src,\n+                            uint dst_element_length_in_bytes, uint src_element_lenght_in_bytes);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-#if COMPILER2\n+#ifdef COMPILER2\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -658,9 +658,13 @@\n-          OptoReg::Name lo = OptoReg::add(hi, (1-num_regs)); \/\/ Find lo\n-          \/\/ We have to use pair [lo,lo+1] even for wide vectors\/vmasks because\n-          \/\/ the rest of code generation works only with pairs. It is safe\n-          \/\/ since for registers encoding only 'lo' is used.\n-          \/\/ Second reg from pair is used in ScheduleAndBundle on SPARC where\n-          \/\/ vector max size is 8 which corresponds to registers pair.\n-          \/\/ It is also used in BuildOopMaps but oop operations are not\n-          \/\/ vectorized.\n-          set2(i, lo);\n+          if (num_regs == 1) {\n+            set1(i, hi);\n+          } else {\n+            OptoReg::Name lo = OptoReg::add(hi, (1 - num_regs)); \/\/ Find lo\n+            \/\/ We have to use pair [lo,lo+1] even for wide vectors\/vmasks because\n+            \/\/ the rest of code generation works only with pairs. It is safe\n+            \/\/ since for registers encoding only 'lo' is used.\n+            \/\/ Second reg from pair is used in ScheduleAndBundle with vector max\n+            \/\/ size 8 which corresponds to registers pair.\n+            \/\/ It is also used in BuildOopMaps but oop operations are not\n+            \/\/ vectorized.\n+            set2(i, lo);\n+          }\n","filename":"src\/hotspot\/share\/opto\/chaitin.cpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -647,0 +647,1 @@\n+    *idealreg2spillmask[Op_RegVectMask] = *idealreg2regmask[Op_RegVectMask];\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1682,0 +1682,10 @@\n+                        [\"uzp1\",    \"__ sve_uzp1(p0, __ B, p0, p1);\",                     \"uzp1\\tp0.b, p0.b, p1.b\"],\n+                        [\"uzp1\",    \"__ sve_uzp1(p0, __ H, p0, p1);\",                     \"uzp1\\tp0.h, p0.h, p1.h\"],\n+                        [\"uzp1\",    \"__ sve_uzp1(p0, __ S, p0, p1);\",                     \"uzp1\\tp0.s, p0.s, p1.s\"],\n+                        [\"uzp1\",    \"__ sve_uzp1(p0, __ D, p0, p1);\",                     \"uzp1\\tp0.d, p0.d, p1.d\"],\n+                        [\"uzp2\",    \"__ sve_uzp2(p0, __ B, p0, p1);\",                     \"uzp2\\tp0.b, p0.b, p1.b\"],\n+                        [\"uzp2\",    \"__ sve_uzp2(p0, __ H, p0, p1);\",                     \"uzp2\\tp0.h, p0.h, p1.h\"],\n+                        [\"uzp2\",    \"__ sve_uzp2(p0, __ S, p0, p1);\",                     \"uzp2\\tp0.s, p0.s, p1.s\"],\n+                        [\"uzp2\",    \"__ sve_uzp2(p0, __ D, p0, p1);\",                     \"uzp2\\tp0.d, p0.d, p1.d\"],\n+                        [\"punpklo\", \"__ sve_punpklo(p1, p0);\",                            \"punpklo\\tp1.h, p0.b\"],\n+                        [\"punpkhi\", \"__ sve_punpkhi(p1, p0);\",                            \"punpkhi\\tp1.h, p0.b\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -871,0 +871,10 @@\n+    __ sve_uzp1(p0, __ B, p0, p1);                     \/\/       uzp1    p0.b, p0.b, p1.b\n+    __ sve_uzp1(p0, __ H, p0, p1);                     \/\/       uzp1    p0.h, p0.h, p1.h\n+    __ sve_uzp1(p0, __ S, p0, p1);                     \/\/       uzp1    p0.s, p0.s, p1.s\n+    __ sve_uzp1(p0, __ D, p0, p1);                     \/\/       uzp1    p0.d, p0.d, p1.d\n+    __ sve_uzp2(p0, __ B, p0, p1);                     \/\/       uzp2    p0.b, p0.b, p1.b\n+    __ sve_uzp2(p0, __ H, p0, p1);                     \/\/       uzp2    p0.h, p0.h, p1.h\n+    __ sve_uzp2(p0, __ S, p0, p1);                     \/\/       uzp2    p0.s, p0.s, p1.s\n+    __ sve_uzp2(p0, __ D, p0, p1);                     \/\/       uzp2    p0.d, p0.d, p1.d\n+    __ sve_punpklo(p1, p0);                            \/\/       punpklo p1.h, p0.b\n+    __ sve_punpkhi(p1, p0);                            \/\/       punpkhi p1.h, p0.b\n@@ -1085,7 +1095,7 @@\n-    0x14000000,     0x17ffffd7,     0x14000374,     0x94000000,\n-    0x97ffffd4,     0x94000371,     0x3400000a,     0x34fffa2a,\n-    0x34006dca,     0x35000008,     0x35fff9c8,     0x35006d68,\n-    0xb400000b,     0xb4fff96b,     0xb4006d0b,     0xb500001d,\n-    0xb5fff91d,     0xb5006cbd,     0x10000013,     0x10fff8b3,\n-    0x10006c53,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36306bd6,     0x3758000c,     0x375ff7cc,     0x37586b6c,\n+    0x14000000,     0x17ffffd7,     0x1400037e,     0x94000000,\n+    0x97ffffd4,     0x9400037b,     0x3400000a,     0x34fffa2a,\n+    0x34006f0a,     0x35000008,     0x35fff9c8,     0x35006ea8,\n+    0xb400000b,     0xb4fff96b,     0xb4006e4b,     0xb500001d,\n+    0xb5fff91d,     0xb5006dfd,     0x10000013,     0x10fff8b3,\n+    0x10006d93,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36306d16,     0x3758000c,     0x375ff7cc,     0x37586cac,\n@@ -1096,13 +1106,13 @@\n-    0x54006940,     0x54000001,     0x54fff541,     0x540068e1,\n-    0x54000002,     0x54fff4e2,     0x54006882,     0x54000002,\n-    0x54fff482,     0x54006822,     0x54000003,     0x54fff423,\n-    0x540067c3,     0x54000003,     0x54fff3c3,     0x54006763,\n-    0x54000004,     0x54fff364,     0x54006704,     0x54000005,\n-    0x54fff305,     0x540066a5,     0x54000006,     0x54fff2a6,\n-    0x54006646,     0x54000007,     0x54fff247,     0x540065e7,\n-    0x54000008,     0x54fff1e8,     0x54006588,     0x54000009,\n-    0x54fff189,     0x54006529,     0x5400000a,     0x54fff12a,\n-    0x540064ca,     0x5400000b,     0x54fff0cb,     0x5400646b,\n-    0x5400000c,     0x54fff06c,     0x5400640c,     0x5400000d,\n-    0x54fff00d,     0x540063ad,     0x5400000e,     0x54ffefae,\n-    0x5400634e,     0x5400000f,     0x54ffef4f,     0x540062ef,\n+    0x54006a80,     0x54000001,     0x54fff541,     0x54006a21,\n+    0x54000002,     0x54fff4e2,     0x540069c2,     0x54000002,\n+    0x54fff482,     0x54006962,     0x54000003,     0x54fff423,\n+    0x54006903,     0x54000003,     0x54fff3c3,     0x540068a3,\n+    0x54000004,     0x54fff364,     0x54006844,     0x54000005,\n+    0x54fff305,     0x540067e5,     0x54000006,     0x54fff2a6,\n+    0x54006786,     0x54000007,     0x54fff247,     0x54006727,\n+    0x54000008,     0x54fff1e8,     0x540066c8,     0x54000009,\n+    0x54fff189,     0x54006669,     0x5400000a,     0x54fff12a,\n+    0x5400660a,     0x5400000b,     0x54fff0cb,     0x540065ab,\n+    0x5400000c,     0x54fff06c,     0x5400654c,     0x5400000d,\n+    0x54fff00d,     0x540064ed,     0x5400000e,     0x54ffefae,\n+    0x5400648e,     0x5400000f,     0x54ffef4f,     0x5400642f,\n@@ -1140,1 +1150,1 @@\n-    0xbd1b1869,     0x5800533b,     0x1800000b,     0xf8945060,\n+    0xbd1b1869,     0x5800547b,     0x1800000b,     0xf8945060,\n@@ -1264,43 +1274,46 @@\n-    0x1e601000,     0x1e603000,     0x1e621000,     0x1e623000,\n-    0x1e641000,     0x1e643000,     0x1e661000,     0x1e663000,\n-    0x1e681000,     0x1e683000,     0x1e6a1000,     0x1e6a3000,\n-    0x1e6c1000,     0x1e6c3000,     0x1e6e1000,     0x1e6e3000,\n-    0x1e701000,     0x1e703000,     0x1e721000,     0x1e723000,\n-    0x1e741000,     0x1e743000,     0x1e761000,     0x1e763000,\n-    0x1e781000,     0x1e783000,     0x1e7a1000,     0x1e7a3000,\n-    0x1e7c1000,     0x1e7c3000,     0x1e7e1000,     0x1e7e3000,\n-    0xf8208193,     0xf83101b6,     0xf83c13fe,     0xf821239a,\n-    0xf824309e,     0xf826535e,     0xf8304109,     0xf82c7280,\n-    0xf8216058,     0xf8a08309,     0xf8ba03d0,     0xf8a312ea,\n-    0xf8aa21e4,     0xf8a2310b,     0xf8aa522f,     0xf8a2418a,\n-    0xf8ac71af,     0xf8a26287,     0xf8fa8090,     0xf8e20184,\n-    0xf8f01215,     0xf8f022ab,     0xf8f7334c,     0xf8f751dc,\n-    0xf8eb4038,     0xf8ec715f,     0xf8f06047,     0xf863826d,\n-    0xf8710070,     0xf86113cb,     0xf86521e8,     0xf87d301e,\n-    0xf8745287,     0xf87742bc,     0xf87b70b9,     0xf8616217,\n-    0xb83f8185,     0xb82901fc,     0xb83d13f6,     0xb83320bf,\n-    0xb82e33f0,     0xb830529b,     0xb830416c,     0xb82973c6,\n-    0xb831639b,     0xb8be8147,     0xb8b4008a,     0xb8b81231,\n-    0xb8b623a3,     0xb8af3276,     0xb8b35056,     0xb8af4186,\n-    0xb8b071ab,     0xb8b763c1,     0xb8f38225,     0xb8e202d0,\n-    0xb8ed12aa,     0xb8fd219b,     0xb8fb3023,     0xb8ff5278,\n-    0xb8f14389,     0xb8fb70ef,     0xb8f563f7,     0xb87983e2,\n-    0xb87b0150,     0xb8771073,     0xb8702320,     0xb87a3057,\n-    0xb870508c,     0xb87c43be,     0xb87070db,     0xb86961fd,\n-    0xce273c87,     0xce080ac9,     0xce7e8e9b,     0xce808b45,\n-    0xce79806e,     0xce758768,     0xcec0835a,     0xce608ad8,\n-    0x043100c4,     0x046105e3,     0x65c900a6,     0x65d60a87,\n-    0x65c80545,     0x0416a63e,     0x04001f8b,     0x045a179a,\n-    0x04d09e0d,     0x045aa1a5,     0x04990b4f,     0x049386cb,\n-    0x04918264,     0x04500dd1,     0x0497b062,     0x041ea4d7,\n-    0x04980f71,     0x04c80450,     0x048a04c3,     0x04810d93,\n-    0x04dcba68,     0x65808ae0,     0x65cd9db3,     0x658680e6,\n-    0x65879911,     0x65c296d6,     0x04dda1e2,     0x65c2a494,\n-    0x65c0a107,     0x65c1b493,     0x65cdb569,     0x65819e05,\n-    0x65ad8c36,     0x65af1334,     0x65e63104,     0x65fd5e04,\n-    0x65eb6c49,     0x049a4423,     0x04916d11,     0x043330b8,\n-    0x04b032d1,     0x04603274,     0x04e432f1,     0x2413bb21,\n-    0x249889c2,     0x241e9497,     0x2440b592,     0x05316b07,\n-    0x05e96cdb,     0x04da2e17,     0x04d83696,     0x049929bc,\n-    0x04483787,     0x048a2d6b,     0x65c73901,     0x65c6322d,\n-    0x65982064,     0x04812dc7,\n+    0x05214800,     0x05614800,     0x05a14800,     0x05e14800,\n+    0x05214c00,     0x05614c00,     0x05a14c00,     0x05e14c00,\n+    0x05304001,     0x05314001,     0x1e601000,     0x1e603000,\n+    0x1e621000,     0x1e623000,     0x1e641000,     0x1e643000,\n+    0x1e661000,     0x1e663000,     0x1e681000,     0x1e683000,\n+    0x1e6a1000,     0x1e6a3000,     0x1e6c1000,     0x1e6c3000,\n+    0x1e6e1000,     0x1e6e3000,     0x1e701000,     0x1e703000,\n+    0x1e721000,     0x1e723000,     0x1e741000,     0x1e743000,\n+    0x1e761000,     0x1e763000,     0x1e781000,     0x1e783000,\n+    0x1e7a1000,     0x1e7a3000,     0x1e7c1000,     0x1e7c3000,\n+    0x1e7e1000,     0x1e7e3000,     0xf8208193,     0xf83101b6,\n+    0xf83c13fe,     0xf821239a,     0xf824309e,     0xf826535e,\n+    0xf8304109,     0xf82c7280,     0xf8216058,     0xf8a08309,\n+    0xf8ba03d0,     0xf8a312ea,     0xf8aa21e4,     0xf8a2310b,\n+    0xf8aa522f,     0xf8a2418a,     0xf8ac71af,     0xf8a26287,\n+    0xf8fa8090,     0xf8e20184,     0xf8f01215,     0xf8f022ab,\n+    0xf8f7334c,     0xf8f751dc,     0xf8eb4038,     0xf8ec715f,\n+    0xf8f06047,     0xf863826d,     0xf8710070,     0xf86113cb,\n+    0xf86521e8,     0xf87d301e,     0xf8745287,     0xf87742bc,\n+    0xf87b70b9,     0xf8616217,     0xb83f8185,     0xb82901fc,\n+    0xb83d13f6,     0xb83320bf,     0xb82e33f0,     0xb830529b,\n+    0xb830416c,     0xb82973c6,     0xb831639b,     0xb8be8147,\n+    0xb8b4008a,     0xb8b81231,     0xb8b623a3,     0xb8af3276,\n+    0xb8b35056,     0xb8af4186,     0xb8b071ab,     0xb8b763c1,\n+    0xb8f38225,     0xb8e202d0,     0xb8ed12aa,     0xb8fd219b,\n+    0xb8fb3023,     0xb8ff5278,     0xb8f14389,     0xb8fb70ef,\n+    0xb8f563f7,     0xb87983e2,     0xb87b0150,     0xb8771073,\n+    0xb8702320,     0xb87a3057,     0xb870508c,     0xb87c43be,\n+    0xb87070db,     0xb86961fd,     0xce273c87,     0xce080ac9,\n+    0xce7e8e9b,     0xce808b45,     0xce79806e,     0xce758768,\n+    0xcec0835a,     0xce608ad8,     0x043100c4,     0x046105e3,\n+    0x65c900a6,     0x65d60a87,     0x65c80545,     0x0416a63e,\n+    0x04001f8b,     0x045a179a,     0x04d09e0d,     0x045aa1a5,\n+    0x04990b4f,     0x049386cb,     0x04918264,     0x04500dd1,\n+    0x0497b062,     0x041ea4d7,     0x04980f71,     0x04c80450,\n+    0x048a04c3,     0x04810d93,     0x04dcba68,     0x65808ae0,\n+    0x65cd9db3,     0x658680e6,     0x65879911,     0x65c296d6,\n+    0x04dda1e2,     0x65c2a494,     0x65c0a107,     0x65c1b493,\n+    0x65cdb569,     0x65819e05,     0x65ad8c36,     0x65af1334,\n+    0x65e63104,     0x65fd5e04,     0x65eb6c49,     0x049a4423,\n+    0x04916d11,     0x043330b8,     0x04b032d1,     0x04603274,\n+    0x04e432f1,     0x2413bb21,     0x249889c2,     0x241e9497,\n+    0x2440b592,     0x05316b07,     0x05e96cdb,     0x04da2e17,\n+    0x04d83696,     0x049929bc,     0x04483787,     0x048a2d6b,\n+    0x65c73901,     0x65c6322d,     0x65982064,     0x04812dc7,\n+\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":77,"deletions":64,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -0,0 +1,468 @@\n+\/*\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import java.util.Random;\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.test.lib.Utils;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test\n+ * @bug 8273264\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @summary AArch64: [vector] Add missing rules for VectorMaskCast\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run testng\/othervm -XX:-TieredCompilation -XX:CompileThreshold=100 compiler.vectorapi.VectorMaskCastTest\n+ *\/\n+\n+\n+\/\/ Current vector mask cast test cases at test\/jdk\/jdk\/incubator\/vector\/*ConversionTests.java\n+\/\/ could not be intrinsfied, hence not able to verify compiler codegen, see [1]. As a\n+\/\/ supplement, we add more tests for vector mask cast operations, which could be intrinsified\n+\/\/ by c2 compiler to generate vector\/mask instructions on supported targets.\n+\/\/\n+\/\/ [1] https:\/\/bugs.openjdk.java.net\/browse\/JDK-8259610\n+\n+public class VectorMaskCastTest{\n+\n+    private static final int NUM_ITER = 5000;\n+    private static final Random rd = Utils.getRandomInstance();\n+\n+    public static boolean[] genMask() {\n+        boolean[] mask = new boolean[64];\n+        for (int i = 0; i < 64; i ++) {\n+            mask[i] = rd.nextBoolean();\n+        }\n+        return mask;\n+    }\n+\n+    \/\/ Byte\n+    private static void testByte64ToShort128(boolean[] mask_arr) {\n+        VectorMask<Byte> mByte64 = VectorMask.fromArray(ByteVector.SPECIES_64, mask_arr, 0);\n+        Assert.assertEquals(mByte64.cast(ShortVector.SPECIES_128).toString(), mByte64.toString());\n+    }\n+\n+    private static void testByte64ToInt256(boolean[] mask_arr) {\n+        VectorMask<Byte> mByte64 = VectorMask.fromArray(ByteVector.SPECIES_64, mask_arr, 0);\n+        Assert.assertEquals(mByte64.cast(IntVector.SPECIES_256).toString(), mByte64.toString());\n+    }\n+\n+    private static void testByte64ToFloat256(boolean[] mask_arr) {\n+        VectorMask<Byte> mByte64 = VectorMask.fromArray(ByteVector.SPECIES_64, mask_arr, 0);\n+        Assert.assertEquals(mByte64.cast(FloatVector.SPECIES_256).toString(), mByte64.toString());\n+    }\n+\n+    private static void testByte64ToLong512(boolean[] mask_arr) {\n+        VectorMask<Byte> mByte64 = VectorMask.fromArray(ByteVector.SPECIES_64, mask_arr, 0);\n+        Assert.assertEquals(mByte64.cast(LongVector.SPECIES_512).toString(), mByte64.toString());\n+    }\n+\n+    private static void testByte64ToDouble512(boolean[] mask_arr) {\n+        VectorMask<Byte> mByte64 = VectorMask.fromArray(ByteVector.SPECIES_64, mask_arr, 0);\n+        Assert.assertEquals(mByte64.cast(DoubleVector.SPECIES_512).toString(), mByte64.toString());\n+    }\n+\n+    private static void testByte128ToShort256(boolean[] mask_arr) {\n+        VectorMask<Byte> mByte128 = VectorMask.fromArray(ByteVector.SPECIES_128, mask_arr, 0);\n+        Assert.assertEquals(mByte128.cast(ShortVector.SPECIES_256).toString(), mByte128.toString());\n+    }\n+\n+    private static void testByte128ToInt512(boolean[] mask_arr) {\n+        VectorMask<Byte> mByte128 = VectorMask.fromArray(ByteVector.SPECIES_128, mask_arr, 0);\n+        Assert.assertEquals(mByte128.cast(IntVector.SPECIES_512).toString(), mByte128.toString());\n+    }\n+\n+    private static void testByte128ToFloat512(boolean[] mask_arr) {\n+        VectorMask<Byte> mByte128 = VectorMask.fromArray(ByteVector.SPECIES_128, mask_arr, 0);\n+        Assert.assertEquals(mByte128.cast(FloatVector.SPECIES_512).toString(), mByte128.toString());\n+    }\n+\n+    private static void testByte256ToShort512(boolean[] mask_arr) {\n+        VectorMask<Byte> mByte256 = VectorMask.fromArray(ByteVector.SPECIES_256, mask_arr, 0);\n+        Assert.assertEquals(mByte256.cast(ShortVector.SPECIES_512).toString(), mByte256.toString());\n+    }\n+\n+    \/\/ Short\n+    private static void testShort64ToInt128(boolean[] mask_arr) {\n+        VectorMask<Short> mShort64 = VectorMask.fromArray(ShortVector.SPECIES_64, mask_arr, 0);\n+        Assert.assertEquals(mShort64.cast(IntVector.SPECIES_128).toString(), mShort64.toString());\n+    }\n+\n+    private static void testShort64ToFloat128(boolean[] mask_arr) {\n+        VectorMask<Short> mShort64 = VectorMask.fromArray(ShortVector.SPECIES_64, mask_arr, 0);\n+        Assert.assertEquals(mShort64.cast(FloatVector.SPECIES_128).toString(), mShort64.toString());\n+    }\n+\n+    private static void testShort64ToLong256(boolean[] mask_arr) {\n+        VectorMask<Short> mShort64 = VectorMask.fromArray(ShortVector.SPECIES_64, mask_arr, 0);\n+        Assert.assertEquals(mShort64.cast(LongVector.SPECIES_256).toString(), mShort64.toString());\n+    }\n+\n+    private static void testShort64ToDouble256(boolean[] mask_arr) {\n+        VectorMask<Short> mShort64 = VectorMask.fromArray(ShortVector.SPECIES_64, mask_arr, 0);\n+        Assert.assertEquals(mShort64.cast(DoubleVector.SPECIES_256).toString(), mShort64.toString());\n+    }\n+\n+    private static void testShort128ToByte64(boolean[] mask_arr) {\n+        VectorMask<Short> mShort128 = VectorMask.fromArray(ShortVector.SPECIES_128, mask_arr, 0);\n+        Assert.assertEquals(mShort128.cast(ByteVector.SPECIES_64).toString(), mShort128.toString());\n+    }\n+\n+    private static void testShort128ToInt256(boolean[] mask_arr) {\n+        VectorMask<Short> mShort128 = VectorMask.fromArray(ShortVector.SPECIES_128, mask_arr, 0);\n+        Assert.assertEquals(mShort128.cast(IntVector.SPECIES_256).toString(), mShort128.toString());\n+    }\n+\n+    private static void testShort128ToFloat256(boolean[] mask_arr) {\n+        VectorMask<Short> mShort128 = VectorMask.fromArray(ShortVector.SPECIES_128, mask_arr, 0);\n+        Assert.assertEquals(mShort128.cast(FloatVector.SPECIES_256).toString(), mShort128.toString());\n+    }\n+\n+    private static void testShort128ToLong512(boolean[] mask_arr) {\n+        VectorMask<Short> mShort128 = VectorMask.fromArray(ShortVector.SPECIES_128, mask_arr, 0);\n+        Assert.assertEquals(mShort128.cast(LongVector.SPECIES_512).toString(), mShort128.toString());\n+    }\n+\n+    private static void testShort128ToDouble512(boolean[] mask_arr) {\n+        VectorMask<Short> mShort128 = VectorMask.fromArray(ShortVector.SPECIES_128, mask_arr, 0);\n+        Assert.assertEquals(mShort128.cast(DoubleVector.SPECIES_512).toString(), mShort128.toString());\n+    }\n+\n+    private static void testShort256ToByte128(boolean[] mask_arr) {\n+        VectorMask<Short> mShort256 = VectorMask.fromArray(ShortVector.SPECIES_256, mask_arr, 0);\n+        Assert.assertEquals(mShort256.cast(ByteVector.SPECIES_128).toString(), mShort256.toString());\n+    }\n+\n+    private static void testShort256ToInt512(boolean[] mask_arr) {\n+        VectorMask<Short> mShort256 = VectorMask.fromArray(ShortVector.SPECIES_256, mask_arr, 0);\n+        Assert.assertEquals(mShort256.cast(IntVector.SPECIES_512).toString(), mShort256.toString());\n+    }\n+\n+    private static void testShort256ToFloat512(boolean[] mask_arr) {\n+        VectorMask<Short> mShort256 = VectorMask.fromArray(ShortVector.SPECIES_256, mask_arr, 0);\n+        Assert.assertEquals(mShort256.cast(FloatVector.SPECIES_512).toString(), mShort256.toString());\n+    }\n+\n+    private static void testShort512ToByte256(boolean[] mask_arr) {\n+        VectorMask<Short> mShort512 = VectorMask.fromArray(ShortVector.SPECIES_512, mask_arr, 0);\n+        Assert.assertEquals(mShort512.cast(ByteVector.SPECIES_256).toString(), mShort512.toString());\n+    }\n+\n+    \/\/ Int\n+    private static void testInt64ToLong128(boolean[] mask_arr) {\n+        VectorMask<Integer> mInt64 = VectorMask.fromArray(IntVector.SPECIES_64, mask_arr, 0);\n+        Assert.assertEquals(mInt64.cast(LongVector.SPECIES_128).toString(), mInt64.toString());\n+    }\n+\n+    private static void testInt64ToDouble128(boolean[] mask_arr) {\n+        VectorMask<Integer> mInt64 = VectorMask.fromArray(IntVector.SPECIES_64, mask_arr, 0);\n+        Assert.assertEquals(mInt64.cast(DoubleVector.SPECIES_128).toString(), mInt64.toString());\n+    }\n+\n+    private static void testInt128ToShort64(boolean[] mask_arr) {\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mask_arr, 0);\n+        Assert.assertEquals(mInt128.cast(ShortVector.SPECIES_64).toString(), mInt128.toString());\n+    }\n+\n+    private static void testInt128ToLong256(boolean[] mask_arr) {\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mask_arr, 0);\n+        Assert.assertEquals(mInt128.cast(LongVector.SPECIES_256).toString(), mInt128.toString());\n+    }\n+\n+    private static void testInt128ToDouble256(boolean[] mask_arr) {\n+        VectorMask<Integer> mInt128 = VectorMask.fromArray(IntVector.SPECIES_128, mask_arr, 0);\n+        Assert.assertEquals(mInt128.cast(DoubleVector.SPECIES_256).toString(), mInt128.toString());\n+    }\n+\n+    private static void testInt256ToShort128(boolean[] mask_arr) {\n+        VectorMask<Integer> mInt256 = VectorMask.fromArray(IntVector.SPECIES_256, mask_arr, 0);\n+        Assert.assertEquals(mInt256.cast(ShortVector.SPECIES_128).toString(), mInt256.toString());\n+    }\n+\n+    private static void testInt256ToByte64(boolean[] mask_arr) {\n+        VectorMask<Integer> mInt256 = VectorMask.fromArray(IntVector.SPECIES_256, mask_arr, 0);\n+        Assert.assertEquals(mInt256.cast(ByteVector.SPECIES_64).toString(), mInt256.toString());\n+    }\n+\n+    private static void testInt256ToLong512(boolean[] mask_arr) {\n+        VectorMask<Integer> mInt256 = VectorMask.fromArray(IntVector.SPECIES_256, mask_arr, 0);\n+        Assert.assertEquals(mInt256.cast(LongVector.SPECIES_512).toString(), mInt256.toString());\n+    }\n+\n+    private static void testInt256ToDouble512(boolean[] mask_arr) {\n+        VectorMask<Integer> mInt256 = VectorMask.fromArray(IntVector.SPECIES_256, mask_arr, 0);\n+        Assert.assertEquals(mInt256.cast(DoubleVector.SPECIES_512).toString(), mInt256.toString());\n+    }\n+\n+    private static void testInt512ToShort256(boolean[] mask_arr) {\n+        VectorMask<Integer> mInt512 = VectorMask.fromArray(IntVector.SPECIES_512, mask_arr, 0);\n+        Assert.assertEquals(mInt512.cast(ShortVector.SPECIES_256).toString(), mInt512.toString());\n+    }\n+\n+    private static void testInt512ToByte128(boolean[] mask_arr) {\n+        VectorMask<Integer> mInt512 = VectorMask.fromArray(IntVector.SPECIES_512, mask_arr, 0);\n+        Assert.assertEquals(mInt512.cast(ByteVector.SPECIES_128).toString(), mInt512.toString());\n+    }\n+\n+    \/\/ Float\n+    private static void testFloat64ToLong128(boolean[] mask_arr) {\n+        VectorMask<Float> mFloat64 = VectorMask.fromArray(FloatVector.SPECIES_64, mask_arr, 0);\n+        Assert.assertEquals(mFloat64.cast(LongVector.SPECIES_128).toString(), mFloat64.toString());\n+    }\n+\n+    private static void testFloat64ToDouble128(boolean[] mask_arr) {\n+        VectorMask<Float> mFloat64 = VectorMask.fromArray(FloatVector.SPECIES_64, mask_arr, 0);\n+        Assert.assertEquals(mFloat64.cast(DoubleVector.SPECIES_128).toString(), mFloat64.toString());\n+    }\n+\n+    private static void testFloat128ToShort64(boolean[] mask_arr) {\n+        VectorMask<Float> mFloat128 = VectorMask.fromArray(FloatVector.SPECIES_128, mask_arr, 0);\n+        Assert.assertEquals(mFloat128.cast(ShortVector.SPECIES_64).toString(), mFloat128.toString());\n+    }\n+\n+    private static void testFloat128ToLong256(boolean[] mask_arr) {\n+        VectorMask<Float> mFloat128 = VectorMask.fromArray(FloatVector.SPECIES_128, mask_arr, 0);\n+        Assert.assertEquals(mFloat128.cast(LongVector.SPECIES_256).toString(), mFloat128.toString());\n+    }\n+\n+    private static void testFloat128ToDouble256(boolean[] mask_arr) {\n+        VectorMask<Float> mFloat128 = VectorMask.fromArray(FloatVector.SPECIES_128, mask_arr, 0);\n+        Assert.assertEquals(mFloat128.cast(DoubleVector.SPECIES_256).toString(), mFloat128.toString());\n+    }\n+\n+    private static void testFloat256ToShort128(boolean[] mask_arr) {\n+        VectorMask<Float> mFloat256 = VectorMask.fromArray(FloatVector.SPECIES_256, mask_arr, 0);\n+        Assert.assertEquals(mFloat256.cast(ShortVector.SPECIES_128).toString(), mFloat256.toString());\n+    }\n+\n+    private static void testFloat256ToByte64(boolean[] mask_arr) {\n+        VectorMask<Float> mFloat256 = VectorMask.fromArray(FloatVector.SPECIES_256, mask_arr, 0);\n+        Assert.assertEquals(mFloat256.cast(ByteVector.SPECIES_64).toString(), mFloat256.toString());\n+    }\n+\n+    private static void testFloat256ToLong512(boolean[] mask_arr) {\n+        VectorMask<Float> mFloat256 = VectorMask.fromArray(FloatVector.SPECIES_256, mask_arr, 0);\n+        Assert.assertEquals(mFloat256.cast(LongVector.SPECIES_512).toString(), mFloat256.toString());\n+    }\n+\n+    private static void testFloat256ToDouble512(boolean[] mask_arr) {\n+        VectorMask<Float> mFloat256 = VectorMask.fromArray(FloatVector.SPECIES_256, mask_arr, 0);\n+        Assert.assertEquals(mFloat256.cast(DoubleVector.SPECIES_512).toString(), mFloat256.toString());\n+    }\n+\n+    private static void testFloat512ToShort256(boolean[] mask_arr) {\n+        VectorMask<Float> mFloat512 = VectorMask.fromArray(FloatVector.SPECIES_512, mask_arr, 0);\n+        Assert.assertEquals(mFloat512.cast(ShortVector.SPECIES_256).toString(), mFloat512.toString());\n+    }\n+\n+    private static void testFloat512ToByte128(boolean[] mask_arr) {\n+        VectorMask<Float> mFloat512 = VectorMask.fromArray(FloatVector.SPECIES_512, mask_arr, 0);\n+        Assert.assertEquals(mFloat512.cast(ByteVector.SPECIES_128).toString(), mFloat512.toString());\n+    }\n+\n+    \/\/ Long\n+    private static void testLong128ToInt64(boolean[] mask_arr) {\n+        VectorMask<Long> mLong128 = VectorMask.fromArray(LongVector.SPECIES_128, mask_arr, 0);\n+        Assert.assertEquals(mLong128.cast(IntVector.SPECIES_64).toString(), mLong128.toString());\n+    }\n+\n+    private static void testLong128ToFloat64(boolean[] mask_arr) {\n+        VectorMask<Long> mLong128 = VectorMask.fromArray(LongVector.SPECIES_128, mask_arr, 0);\n+        Assert.assertEquals(mLong128.cast(FloatVector.SPECIES_64).toString(), mLong128.toString());\n+    }\n+\n+    private static void testLong256ToInt128(boolean[] mask_arr) {\n+        VectorMask<Long> mLong256 = VectorMask.fromArray(LongVector.SPECIES_256, mask_arr, 0);\n+        Assert.assertEquals(mLong256.cast(IntVector.SPECIES_128).toString(), mLong256.toString());\n+    }\n+\n+    private static void testLong256ToFloat128(boolean[] mask_arr) {\n+        VectorMask<Long> mLong256 = VectorMask.fromArray(LongVector.SPECIES_256, mask_arr, 0);\n+        Assert.assertEquals(mLong256.cast(FloatVector.SPECIES_128).toString(), mLong256.toString());\n+    }\n+\n+    private static void testLong256ToShort64(boolean[] mask_arr) {\n+        VectorMask<Long> mLong256 = VectorMask.fromArray(LongVector.SPECIES_256, mask_arr, 0);\n+        Assert.assertEquals(mLong256.cast(ShortVector.SPECIES_64).toString(), mLong256.toString());\n+    }\n+\n+    private static void testLong512ToInt256(boolean[] mask_arr) {\n+        VectorMask<Long> mLong512 = VectorMask.fromArray(LongVector.SPECIES_512, mask_arr, 0);\n+        Assert.assertEquals(mLong512.cast(IntVector.SPECIES_256).toString(), mLong512.toString());\n+    }\n+\n+    private static void testLong512ToFloat256(boolean[] mask_arr) {\n+        VectorMask<Long> mLong512 = VectorMask.fromArray(LongVector.SPECIES_512, mask_arr, 0);\n+        Assert.assertEquals(mLong512.cast(FloatVector.SPECIES_256).toString(), mLong512.toString());\n+    }\n+\n+    private static void testLong512ToShort128(boolean[] mask_arr) {\n+        VectorMask<Long> mLong512 = VectorMask.fromArray(LongVector.SPECIES_512, mask_arr, 0);\n+        Assert.assertEquals(mLong512.cast(ShortVector.SPECIES_128).toString(), mLong512.toString());\n+    }\n+\n+    private static void testLong512ToByte64(boolean[] mask_arr) {\n+        VectorMask<Long> mLong512 = VectorMask.fromArray(LongVector.SPECIES_512, mask_arr, 0);\n+        Assert.assertEquals(mLong512.cast(ByteVector.SPECIES_64).toString(), mLong512.toString());\n+    }\n+\n+    \/\/ Double\n+    private static void testDouble128ToInt64(boolean[] mask_arr) {\n+        VectorMask<Double> mDouble128 = VectorMask.fromArray(DoubleVector.SPECIES_128, mask_arr, 0);\n+        Assert.assertEquals(mDouble128.cast(IntVector.SPECIES_64).toString(), mDouble128.toString());\n+    }\n+\n+    private static void testDouble128ToFloat64(boolean[] mask_arr) {\n+        VectorMask<Double> mDouble128 = VectorMask.fromArray(DoubleVector.SPECIES_128, mask_arr, 0);\n+        Assert.assertEquals(mDouble128.cast(FloatVector.SPECIES_64).toString(), mDouble128.toString());\n+    }\n+\n+    private static void testDouble256ToInt128(boolean[] mask_arr) {\n+        VectorMask<Double> mDouble256 = VectorMask.fromArray(DoubleVector.SPECIES_256, mask_arr, 0);\n+        Assert.assertEquals(mDouble256.cast(IntVector.SPECIES_128).toString(), mDouble256.toString());\n+    }\n+\n+    private static void testDouble256ToFloat128(boolean[] mask_arr) {\n+        VectorMask<Double> mDouble256 = VectorMask.fromArray(DoubleVector.SPECIES_256, mask_arr, 0);\n+        Assert.assertEquals(mDouble256.cast(FloatVector.SPECIES_128).toString(), mDouble256.toString());\n+    }\n+\n+    private static void testDouble256ToShort64(boolean[] mask_arr) {\n+        VectorMask<Double> mDouble256 = VectorMask.fromArray(DoubleVector.SPECIES_256, mask_arr, 0);\n+        Assert.assertEquals(mDouble256.cast(ShortVector.SPECIES_64).toString(), mDouble256.toString());\n+    };\n+\n+    private static void testDouble512ToInt256(boolean[] mask_arr) {\n+        VectorMask<Double> mDouble512 = VectorMask.fromArray(DoubleVector.SPECIES_512, mask_arr, 0);\n+        Assert.assertEquals(mDouble512.cast(IntVector.SPECIES_256).toString(), mDouble512.toString());\n+    }\n+\n+    private static void testDouble512ToFloat256(boolean[] mask_arr) {\n+        VectorMask<Double> mDouble512 = VectorMask.fromArray(DoubleVector.SPECIES_512, mask_arr, 0);\n+        Assert.assertEquals(mDouble512.cast(FloatVector.SPECIES_256).toString(), mDouble512.toString());\n+    }\n+\n+    private static void testDouble512ToShort128(boolean[] mask_arr) {\n+        VectorMask<Double> mDouble512 = VectorMask.fromArray(DoubleVector.SPECIES_512, mask_arr, 0);\n+        Assert.assertEquals(mDouble512.cast(ShortVector.SPECIES_128).toString(), mDouble512.toString());\n+    }\n+\n+    private static void testDouble512ToByte64(boolean[] mask_arr) {\n+        VectorMask<Double> mDouble512 = VectorMask.fromArray(DoubleVector.SPECIES_512, mask_arr, 0);\n+        Assert.assertEquals(mDouble512.cast(ByteVector.SPECIES_64).toString(), mDouble512.toString());\n+    }\n+\n+\n+    @Test\n+    public static void testMaskCast() {\n+        for (int i = 0; i < NUM_ITER; i++) {\n+            boolean[] mask = genMask();\n+            \/\/ Byte\n+            testByte64ToShort128(mask);\n+            testByte64ToInt256(mask);\n+            testByte64ToFloat256(mask);\n+            testByte64ToLong512(mask);\n+            testByte64ToDouble512(mask);\n+            testByte128ToShort256(mask);\n+            testByte128ToInt512(mask);\n+            testByte128ToFloat512(mask);\n+            testByte256ToShort512(mask);\n+\n+            \/\/ Short\n+            testShort64ToInt128(mask);\n+            testShort64ToFloat128(mask);\n+            testShort64ToLong256(mask);\n+            testShort64ToDouble256(mask);\n+            testShort128ToByte64(mask);\n+            testShort128ToInt256(mask);\n+            testShort128ToFloat256(mask);\n+            testShort128ToLong512(mask);\n+            testShort128ToDouble512(mask);\n+            testShort256ToByte128(mask);\n+            testShort256ToInt512(mask);\n+            testShort256ToFloat512(mask);\n+            testShort512ToByte256(mask);\n+\n+            \/\/ Int\n+            testInt64ToLong128(mask);\n+            testInt64ToDouble128(mask);\n+            testInt128ToShort64(mask);\n+            testInt128ToLong256(mask);\n+            testInt128ToDouble256(mask);\n+            testInt256ToShort128(mask);\n+            testInt256ToByte64(mask);\n+            testInt256ToLong512(mask);\n+            testInt256ToDouble512(mask);\n+            testInt512ToShort256(mask);\n+            testInt512ToByte128(mask);\n+\n+            \/\/ Float\n+            testFloat64ToLong128(mask);\n+            testFloat64ToDouble128(mask);\n+            testFloat128ToShort64(mask);\n+            testFloat128ToLong256(mask);\n+            testFloat128ToDouble256(mask);\n+            testFloat256ToShort128(mask);\n+            testFloat256ToByte64(mask);\n+            testFloat256ToLong512(mask);\n+            testFloat256ToDouble512(mask);\n+            testFloat512ToShort256(mask);\n+            testFloat512ToByte128(mask);\n+\n+            \/\/ Long\n+            testLong128ToInt64(mask);\n+            testLong128ToFloat64(mask);\n+            testLong256ToInt128(mask);\n+            testLong256ToFloat128(mask);\n+            testLong256ToShort64(mask);\n+            testLong512ToInt256(mask);\n+            testLong512ToFloat256(mask);\n+            testLong512ToShort128(mask);\n+            testLong512ToByte64(mask);\n+\n+            \/\/ Double\n+            testDouble128ToInt64(mask);\n+            testDouble128ToFloat64(mask);\n+            testDouble256ToInt128(mask);\n+            testDouble256ToFloat128(mask);\n+            testDouble256ToShort64(mask);\n+            testDouble512ToInt256(mask);\n+            testDouble512ToFloat256(mask);\n+            testDouble512ToShort128(mask);\n+            testDouble512ToByte64(mask);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskCastTest.java","additions":468,"deletions":0,"binary":false,"changes":468,"status":"added"}]}