{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=panama\n@@ -26,2 +26,1 @@\n-reviewers=1\n-ignore=duke\n+committers=1\n","filename":".jcheck\/conf","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,26 @@\n+% Benchmarking Vector API\n+\n+Benchmarks are generted from scripts in this directory to `test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation`\n+\n+## Test selection\n+Run benchmarks from the top level git dir using:\n+\n+``` shell\n+make test TEST=\"micro:<benchmark-name>\" CONF=linux-x86_64-server-release\n+\n+### One Test\n+make test TEST=\"micro:Int64Vector\" CONF=linux-x86_64-server-release\n+\n+### Run all tests -- WARNING requires ~4-5 hours\n+make test TEST=\"micro:org.openjdk.bench.jdk.incubator.vector\" CONF=linux-x86_64-server-release\n+```\n+\n+### JMH Configuration\n+See `https:\/\/github.com\/openjdk\/jdk\/blob\/master\/doc\/testing.md` or `doc\/testing.md` dir in this git repo for more detailed steps on running the benchmarks for Vector API at `test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation`.\n+\n+From doc\/testing.md:\n+To be able to run microbenchmarks, `configure` needs to know where to find the\n+JMH dependency. Use `--with-jmh=<path to JMH jars>` to point to a directory\n+containing the core JMH and transitive dependencies. The recommended\n+dependencies can be retrieved by running `sh make\/devkit\/createJMHBundle.sh`,\n+after which `--with-jmh=build\/jmh\/jars` should work.\n","filename":"test\/jdk\/jdk\/incubator\/vector\/BENCHMARKS.md","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -25,2 +25,2 @@\n-VECTORTESTS_HOME=\"$(pwd)\"\n-JDK_SRC_HOME=\".\/..\/..\/..\/..\/..\/\"\n+JDK_SRC_HOME=\"$(git rev-parse --show-toplevel)\"\n+VECTORTESTS_HOME=\"$JDK_SRC_HOME\/test\/jdk\/jdk\/incubator\/vector\/\"\n@@ -36,0 +36,3 @@\n+TESTNG_JAR=\"${TESTNG_PLUGIN}\/plugins\/org.testng.source_6.13.1.r201712040515.jar\"\n+TESTNG_RUN_JAR=\"${TESTNG_PLUGIN}\/plugins\/org.testng_6.13.1.r201712040515.jar\"\n+JCOMMANDER_JAR=\"${TESTNG_PLUGIN}\/plugins\/com.beust.jcommander_1.72.0.jar\"\n@@ -40,1 +43,2 @@\n-PERF_DEST=\"benchmark\/src\/main\/java\/benchmark\/jdk\/incubator\/vector\/\"\n+PERF_DEST=\"$JDK_SRC_HOME\/test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\"\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/config.sh","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,19 @@\n+    @Benchmark\n+    public Object [[TEST]][[TEST_TYPE]][[OP_NAME]]() {\n+        $type$[] a = fa.apply(size);\n+        $type$[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                $abstractvectortype$ bv = $abstractvectortype$.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.[[TEST]], bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Compare.template","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+    @Benchmark\n+    public Object compress[[TEST_TYPE]][[OP_NAME]]() {\n+        $type$[] a = fa.apply(size);\n+        $type$[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand[[TEST_TYPE]][[OP_NAME]]() {\n+        $type$[] a = fa.apply(size);\n+        $type$[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress[[TEST_TYPE]][[OP_NAME]]() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-CompressExpand.template","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = [[TEST_INIT]];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = [[TEST_INIT]];\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = [[TEST_OP]](ra, av.reduceLanes(VectorOperators.[[TEST]], vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Reduction-Masked-op-func.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<$Wideboxtype$> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        $type$ ra = [[TEST_INIT]];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = [[TEST_INIT]];\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra [[TEST_OP]]= av.reduceLanes(VectorOperators.[[TEST]], vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Reduction-Masked-op.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ ra = [[TEST_INIT]];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = [[TEST_INIT]];\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra = [[TEST_OP]](ra, av.reduceLanes(VectorOperators.[[TEST]]));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Reduction-op-func.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] a = fa.apply(SPECIES.length());\n+        $type$ ra = [[TEST_INIT]];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = [[TEST_INIT]];\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+                ra [[TEST_OP]]= av.reduceLanes(VectorOperators.[[TEST]]);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Reduction-op.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,21 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)([[TEST_OP]]);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Binary-Masked-op.template","additions":21,"deletions":0,"binary":false,"changes":21,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Binary-op-math.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Binary-op.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Blend-op.template","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < ms.length; i++) {\n+                r [[TEST_OP]]= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-BoolReduction-op.template","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\n+    void broadcastShared(int window, Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ $Wideboxtype$.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ $Wideboxtype$.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ $Wideboxtype$.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ $Wideboxtype$.SIZE;\n+        broadcastShared(window, bh);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Broadcast.template","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= [[TEST_OP]](as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Compare.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\n+    @Benchmark\n+    public void compressScalar[[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = new $type$[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[j++] = as[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void expandScalar[[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = new $type$[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[i++] = as[j++];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void maskCompressScalar[[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        boolean[] im = fmt.apply(size);\n+        boolean[] rm = new boolean[size];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < im.length; i++) {\n+                if (im[i]) {\n+                    rm[j++] = im[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rm);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-CompressExpand.template","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\n+    void rearrangeShared(int window, Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    $type$ a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ $Wideboxtype$.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ $Wideboxtype$.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ $Wideboxtype$.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ $Wideboxtype$.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Rearrange.template","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        $type$ r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = ($type$)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Reduction-Masked-Max-op.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        $type$ r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r = ($type$)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Reduction-Masked-Min-op.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        $type$ r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r [[TEST_OP]]= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Reduction-Masked-op.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$ r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < as.length; i++) {\n+                r = ($type$)Math.max(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Reduction-Max-op.template","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$ r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < as.length; i++) {\n+                r = ($type$)Math.min(r, as[i]);\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Reduction-Min-op.template","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Lanes(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$ r = [[TEST_INIT]];\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = [[TEST_INIT]];\n+            for (int i = 0; i < as.length; i++) {\n+                r [[TEST_OP]]= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Reduction-op.template","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Const(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Shift-Const-op.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Const(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)([[TEST_OP]]) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Shift-Masked-Const-op.template","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)([[TEST_OP]]) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Shift-Masked-op.template","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Shift-op.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,23 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] cs = fc.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                $type$ c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = ($type$)([[TEST_OP]]);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Ternary-Masked-op.template","additions":23,"deletions":0,"binary":false,"changes":23,"status":"added"},{"patch":"@@ -0,0 +1,19 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] bs = fb.apply(size);\n+        $type$[] cs = fc.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                $type$ b = bs[i];\n+                $type$ c = cs[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Ternary-op.template","additions":19,"deletions":0,"binary":false,"changes":19,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                r &= ([[TEST_OP]]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Test.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,17 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? ($type$)([[TEST_OP]]) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Unary-Masked-op.template","additions":17,"deletions":0,"binary":false,"changes":17,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Unary-math.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,15 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Unary-op-math.template","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+        $type$[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                $type$ a = as[i];\n+                rs[i] = ($type$)([[TEST_OP]]);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Unary-op.template","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        $type$[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = ($type$)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-Zero.template","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-footer.template","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-footer.template","status":"copied"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+#warn This file is preprocessed before being compiled\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+import jdk.incubator.vector.VectorMath;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class $Type$Scalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+#if[BITWISE]\n+    private static final $type$ CONST_SHIFT = $Boxtype$.SIZE \/ 2;\n+#end[BITWISE]\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    $type$[] fill(IntFunction<$Wideboxtype$> f) {\n+        $type$[] array = new $type$[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static $bitstype$ bits($type$ e) {\n+        return {#if[FP]?$Type$.$type$To$Bitstype$Bits(e):e};\n+    }\n+\n+    $type$[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> ($type$)(2*i));\n+        bs = fill(i -> ($type$)(i+1));\n+        cs = fill(i -> ($type$)(i+5));\n+        rs = fill(i -> ($type$)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RAND.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<$type$[]> fa = vl -> as;\n+    final IntFunction<$type$[]> fb = vl -> bs;\n+    final IntFunction<$type$[]> fc = vl -> cs;\n+    final IntFunction<$type$[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq($type$ a, $type$ b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq($type$ a, $type$ b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt($type$ a, $type$ b) {\n+        return a < b;\n+    }\n+\n+    static boolean le($type$ a, $type$ b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt($type$ a, $type$ b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge($type$ a, $type$ b) {\n+        return a >= b;\n+    }\n+\n+#if[!FP]\n+    static boolean ult($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge($type$ a, $type$ b) {\n+        return $Boxtype$.compareUnsigned(a, b) >= 0;\n+    }\n+#end[!FP]\n+\n+#if[BITWISE]\n+    static $type$ ROL_scalar($type$ a, $type$ b) {\n+#if[intOrLong]\n+        return $Wideboxtype$.rotateLeft(a, ((int)b));\n+#else[intOrLong]\n+#if[short]\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+#else[short]\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ ROR_scalar($type$ a, $type$ b) {\n+#if[intOrLong]\n+        return $Wideboxtype$.rotateRight(a, ((int)b));\n+#else[intOrLong]\n+#if[short]\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+#else[short]\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ TRAILING_ZEROS_COUNT_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.numberOfTrailingZeros(a);\n+#else[intOrLong]\n+#if[short]\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+#else[short]\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ LEADING_ZEROS_COUNT_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.numberOfLeadingZeros(a);\n+#else[intOrLong]\n+#if[short]\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+#else[short]\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+#end[short]\n+#end[intOrLong]\n+    }\n+\n+    static $type$ REVERSE_scalar($type$ a) {\n+#if[intOrLong]\n+        return $Wideboxtype$.reverse(a);\n+#else[intOrLong]\n+#if[short]\n+        $type$ b = ROL_scalar(a, ($type$) 8);\n+        b = (short)(((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short)(((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short)(((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+#else[short]\n+        $type$ b = ROL_scalar(a, ($type$) 4);\n+        b = (byte)(((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte)(((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+#end[short]\n+#end[intOrLong]\n+    }\n+#end[BITWISE]\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Scalar-header.template","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Const(Blackhole bh) {\n+[[KERNEL]]\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Shift-Const-op.template","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]]Const(Blackhole bh) {\n+[[KERNEL]]\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Shift-Masked-Const-op.template","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,18 @@\n+\n+    @Benchmark\n+    public Object [[TEST]][[TEST_TYPE]][[OP_NAME]]() {\n+        $type$[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<$Wideboxtype$> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                $abstractvectortype$ av = $abstractvectortype$.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.[[TEST]]));\n+            }\n+        }\n+\n+        return m;\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-Test.template","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-footer.template","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-footer.template","status":"copied"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+#warn This file is preprocessed before being compiled\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.$Type$Vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class $vectorbenchtype$ extends AbstractVectorBenchmark {\n+#if[MaxBit]\n+    static final VectorSpecies<$Wideboxtype$> SPECIES = $Type$Vector.SPECIES_MAX;\n+#else[MaxBit]\n+    static final VectorSpecies<$Wideboxtype$> SPECIES = $Type$Vector.SPECIES_$bits$;\n+#end[MaxBit]\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+#if[BITWISE]\n+    static void replaceZero($type$[] a, $type$ v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero($type$[] a, boolean[] mask, $type$ v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+#end[BITWISE]\n+\n+    static $type$ firstNonZero($type$ a, $type$ b) {\n+        return $Boxtype$.compare(a, ($type$) 0) != 0 ? a : b;\n+    }\n+\n+#if[BITWISE]\n+    private static final $type$ CONST_SHIFT = $Boxtype$.SIZE \/ 2;\n+#end[BITWISE]\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    $type$[] fill(IntFunction<$Wideboxtype$> f) {\n+        $type$[] array = new $type$[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    $type$[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> ($type$)(2*i));\n+        b = fill(i -> ($type$)(i+1));\n+        c = fill(i -> ($type$)(i+5));\n+        r = fill(i -> ($type$)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<$type$[]> fa = vl -> a;\n+    final IntFunction<$type$[]> fb = vl -> b;\n+    final IntFunction<$type$[]> fc = vl -> c;\n+    final IntFunction<$type$[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-header.template","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+\n+    @Benchmark\n+    public void [[TEST]][[TEST_TYPE]][[OP_NAME]](Blackhole bh) {\n+[[KERNEL]]\n+        bh.consume(r);\n+    }\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Perf-wrapper.template","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.bigdata;\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class BooleanArrayCheck {\n+\n+  @Param(\"1024\")\n+  int ARRAY_LENGTH;\n+\n+  static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_PREFERRED;\n+\n+  private boolean[] bitsArray;\n+\n+  @Setup\n+  public void init() {\n+    System.out.println(\"SPECIES's length: \" + SPECIES.length());\n+\n+    bitsArray = new boolean[ARRAY_LENGTH];\n+    for (int i = 0; i < ARRAY_LENGTH; i++) {\n+      bitsArray[i] = true;\n+    }\n+  }\n+\n+  @Benchmark\n+  public boolean filterAll_vec() {\n+    int filterPos = 0;\n+\n+    for (; filterPos < ARRAY_LENGTH; filterPos += SPECIES.length()) {\n+      VectorMask<Byte> mask = VectorMask.fromArray(SPECIES, bitsArray, filterPos);\n+      if (!mask.allTrue()) {\n+        return false;\n+      }\n+    }\n+\n+    for (filterPos -= SPECIES.length(); filterPos < ARRAY_LENGTH; filterPos++) {\n+      if (!bitsArray[filterPos]) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Benchmark\n+  public boolean filterAll() {\n+    int filterPos = 0;\n+\n+    for (; filterPos < ARRAY_LENGTH; filterPos++) {\n+      if (!bitsArray[filterPos]) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/bigdata\/BooleanArrayCheck.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.bigdata;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.random.RandomGenerator;\n+\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 10, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class SelectiveStore {\n+\n+  @Param(\"1024\")\n+  int ARRAY_LENGTH;\n+\n+  private static final VectorSpecies<Integer> INT_64_SPECIES =\n+    IntVector.SPECIES_64;\n+  private static final VectorSpecies<Integer> INT_128_SPECIES =\n+    IntVector.SPECIES_128;\n+  private static final VectorSpecies<Integer> INT_256_SPECIES =\n+    IntVector.SPECIES_256;\n+  private static final VectorSpecies<Integer> INT_512_SPECIES =\n+    IntVector.SPECIES_512;\n+  private static final VectorSpecies<Integer> INT_PREFERRED_SPECIES =\n+    IntVector.SPECIES_PREFERRED;\n+\n+  private int conflict_cnt;\n+  private int[] index;\n+  private int[] input1;\n+  private int[] input2;\n+  private int[] conflict_array;\n+\n+  @Setup\n+  public void init() {\n+    index = new int[ARRAY_LENGTH];\n+    input1 = new int[ARRAY_LENGTH];\n+    input2 = new int[ARRAY_LENGTH];\n+    conflict_array = new int[ARRAY_LENGTH];\n+\n+    RandomGenerator rng = RandomGenerator.getDefault();\n+    int conflict_id_each_5_elements = rng.nextInt(5);\n+\n+    for (int i = 0; i < ARRAY_LENGTH; i++) {\n+      index[i] = rng.nextInt(ARRAY_LENGTH);\n+      input1[i] = rng.nextInt();\n+      \/\/ Generate 20% conflict data\n+      int remainder = i % 5;\n+      if (remainder == conflict_id_each_5_elements) {\n+        input2[i] = rng.nextInt();\n+      } else {\n+        input2[i] = input1[i];\n+      }\n+      conflict_array[i] = 0;\n+    }\n+  }\n+\n+  private void selectiveStore(VectorSpecies<Integer> species) {\n+    conflict_cnt = 0;\n+    for (int i = 0; i < ARRAY_LENGTH; i += species.length()) {\n+      IntVector av = IntVector.fromArray(species, input1, i);\n+      IntVector bv = IntVector.fromArray(species, input2, i);\n+      IntVector cv = IntVector.fromArray(species, index, i);\n+      VectorMask<Integer> mask = av.compare(VectorOperators.NE, bv);\n+      IntVector dv = cv.compress(mask);\n+      dv.intoArray(conflict_array, conflict_cnt, mask.compress());\n+      conflict_cnt += mask.trueCount();\n+    }\n+  }\n+\n+  @Benchmark\n+  public void selectiveStore_scalar() {\n+    conflict_cnt = 0;\n+    for (int i = 0; i < ARRAY_LENGTH; i++) {\n+      if (input1[i] != input2[i]) {\n+        conflict_array[conflict_cnt] = index[i];\n+        conflict_cnt++;\n+      }\n+    }\n+  }\n+\n+  @Benchmark\n+  public void selectiveStore_vector_64() {\n+    selectiveStore(INT_64_SPECIES);\n+  }\n+\n+  @Benchmark\n+  public void selectiveStore_vector_128() {\n+    selectiveStore(INT_128_SPECIES);\n+  }\n+\n+  @Benchmark\n+  public void selectiveStore_vector_256() {\n+    selectiveStore(INT_256_SPECIES);\n+  }\n+\n+  @Benchmark\n+  public void selectiveStore_vector_512() {\n+    selectiveStore(INT_512_SPECIES);\n+  }\n+\n+  @Benchmark\n+  public void selectiveStore_vector_preferred() {\n+    selectiveStore(INT_PREFERRED_SPECIES);\n+  }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/bigdata\/SelectiveStore.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.bigdata;\n+\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class ValueRangeCheckAndCastL2I {\n+\n+  @Param(\"1024\")\n+  int ARRAY_LENGTH;\n+\n+  private long min = Integer.MIN_VALUE;\n+  private long max = Integer.MAX_VALUE;\n+\n+  private static final VectorSpecies<Long> LONG_SPECIES =\n+    LongVector.SPECIES_PREFERRED;\n+  private static final VectorSpecies<Integer> INT_SPECIES =\n+    VectorSpecies.of(int.class, VectorShape.forBitSize(LONG_SPECIES.vectorBitSize() \/ 2));\n+\n+  private int[] intResult;\n+  private long[] longArray;\n+\n+  @Setup\n+  public void init() {\n+    System.out.println(\"LONG_SPECIES's length: \" + LONG_SPECIES.length());\n+    System.out.println(\"INT_SPECIES's length: \" + INT_SPECIES.length());\n+    System.out.println(\"Min is: \" + min + \". Max is: \" + max);\n+\n+    longArray = new long[ARRAY_LENGTH];\n+    intResult = new int[ARRAY_LENGTH];\n+\n+    Random rand = new Random();\n+    for (int i = 0; i < ARRAY_LENGTH; i++) {\n+      intResult[i] = 0;\n+      longArray[i] = rand.nextInt(Integer.MAX_VALUE);\n+    }\n+  }\n+\n+  @Benchmark\n+  public boolean castL2I() {\n+    for (int i = 0; i < longArray.length; i++) {\n+      if (longArray[i] >= min && longArray[i] <= max) {\n+        intResult[i] = (int)(longArray[i]);\n+      } else {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  @Benchmark\n+  public boolean castL2I_vec() {\n+    for (int i = 0; i < longArray.length; i += LONG_SPECIES.length()) {\n+      LongVector av = LongVector.fromArray(LONG_SPECIES, longArray, i);\n+      if (av.compare(VectorOperators.GE, min).and(av.compare(VectorOperators.LE, max)).allTrue()) {\n+        ((IntVector) av.castShape(INT_SPECIES, 0)).intoArray(intResult, i);\n+      } else {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/bigdata\/ValueRangeCheckAndCastL2I.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,583 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.bigdata;\n+\n+import jdk.incubator.vector.*;\n+import java.util.Base64;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class VectorDistance {\n+\n+    static final VectorSpecies<Float> SPECIES_FLOAT_128 = FloatVector.SPECIES_128;\n+    static final VectorSpecies<Float> SPECIES_FLOAT_256 = FloatVector.SPECIES_256;\n+    static final VectorSpecies<Float> SPECIES_FLOAT_MAX = FloatVector.SPECIES_MAX;\n+    static final VectorSpecies<Double> SPECIES_DOUBLE_128 = DoubleVector.SPECIES_128;\n+    static final VectorSpecies<Double> SPECIES_DOUBLE_256 = DoubleVector.SPECIES_256;\n+    static final VectorSpecies<Double> SPECIES_DOUBLE_MAX = DoubleVector.SPECIES_MAX;\n+\n+\n+    static long num = 0;\n+    private static String x1 = \"L5GSwXhHpEH05mNBHnmcQMTw3EBnagFCW1DGQHe\/nUFO1B1BlJOpwCBJ9j\" +\n+                \"+RkY1BzqKeQSglN0Gy7krB5CSfQFzxB8Djn5nB2KNFwKcSRMGYzRQ7qMGWQZ0FF0FTceDAIKjxv\/zhdkHFZMHB6hU4QZbo2cCAryRB+7OOQCxbfEHRtBlBxPG6P0BYSD+Pgz9BqzOLv\/nVO8C9x5\/BQOY\/wTTIx0GfW1BBGv2lQQwdDcGCqBfB12t\/QKUBoEEejIXBPN9kQWsFbEGsGcnBkqJkwKhLgr\/IQZxAelAWQfcYpcFQv0HBeiGCQWExhEDrKAnBpAwBQV4bVcFpGNjAyDsNQVOc+0CSc4nBgG\/ZQQGRccEXts9BKhYzQNK5+MAlU0DBzPGWwPGRCcEZC5\/ADxOcv7lUkEBomM5BuqKiwV2MU8HNGHDBSB84QZRSyMB8RZlBVFdZQXSVgcBTQQBCdWa\/QBQ0qkGILUW\/6NA9QQnkmsG+5PPBj0UowT6nYD9cwpjAS\/w5wTbX2UH8Gb5AR\/HUQMTNAMJ9MN9AgHoqPbbUyUFbe47BBHANQWZJBsGBuPlBy94EQADeXsG5eOtBnA+yQCRka8EMcGLBjuoRwb4k7sAasB5Bmk\/UwaI1akErp6xBq5G5wNo1E8KHa7tB3IiKQTCffcHphK1BTgJzwVY3JEEip\/VAlmgXQSeKCsLEABs\/n1\/xwL5u58CgQY49ahUWQoAJjj1hhqBASXrrQb6nM0H2fY+\/thtbQAQobMAohvXAxM3xv7xyqD+MvpDBrlDiQfBvPcGA8X5AQE4SwXhGx7+uLA1AxY8xu2mVjEE7KlFBArveQFNMtUD3N7DB12BbQcyH4cFhSw3Bu5VWQeTW0z9o03TBxtMlQctp\/8E\/lLVAGUtTwZsGJMKv\/R5A1HKVQV6RhsC1Ji5AcXLFQJd6f0HbB+e+ZDi8wV9tQ0FwCN\/B+A89v2DrU0Bcpc5BglTeQH5dT0HePS9Al4XPwdA6YEFlueXAbWKSQSBWzkBy2RnCt9Yawl9b77+xgxBC9eCqQd8f0kFoBG9BVxrkQZh2QkHNW\/zBEQiawLJEocDhutTA8zEYwbIvEUIO1T9BmlOTwIhbNEDhrtlAVk9BQARQaj89NQNC6usGwDfQrkBSJrlAON7FQQ8FqsEEc\/TAY3zeQYsqUEHV8QPBHJoYQQdn5kGyCiJBlDMYQBBNoUFrxbw\/NlmPP3B24j6ChIdBXk2bwdxdDMFQw1rA4hybQXTchr8d9wvBuCbLQSMKmMBH4RpBQIXePa5DT8IjgvtBgAetQZgGgMEprc1BAOeSPJ5XpEEMa0NBgX4uwX7XIsG2Ie0688iqQSpJPsCAy9LBAGHkPw==\";\n+    private static String x2 = \"5R3ZwGPrxEFMKyNBLFSeQdYav0BQtDFCur7WQAgRYEGHFYC\/MKZtvkiFUT+RNXfBVsGBP2KWSUCmAUTBIf+EQG57kMCtXo7BV1DuwLd98r+YzRQ7qKXNwBMSPUFNQffBPrxeQYw1t7\/7JjFAKNaXP+cMSEG6GI5BuEx0wUANDMEvDqdAT9YEworQTEEiVBZBiMejQP7t67+iRwzB3HadQB1be0Ei5g5BMt+cQXvYTUHwZsLAuoy3QfrR6EFrIiHB5X8Dwc8XbUH8Yr8\/AvGEwa5GkUH3F5tAP8YJQTiDyz+gKsRAFl\/rwDxJuUAPyyxBvg2gQU6bjMEPEa7Bz6wYQpQy7MDF5LvB8HP+QCJdicHQDjpC6RpWQcGeY8FMK6vBoeUjQcPYmUG2QmRBBI0nwScESsGMAcxBvRmawRL2A8IByKNAgTQBQuxdDEGq8JBBHJWmQSBDfz8sLe9BE3gFwTdCPkHEaMxBhX8Xwe7BCcE\/783Bt6EHwdpbpkHc5L\/BCPzRwUdIQUEd\/k3AoGNcQQwNmMEyuKRBtnWlwdCBAUI5Y5DBwOZYvdI+MsEu\/ixBnpMrwRtYt8FECytC6JjEQW3RHcBtfn3B+sgQQcyQKcEI5ytByvw2wPZdaUH+aqLAQFQ+QPi4REBF\/9lBCvJNQTdlEcIAMbzBtD+hwZWufsAEjus\/YRyjwR1YuMHj0ZhBa4w+QORAhMEq9qdB\/L8JQrjhyUAJBeBAKqoIQUnAq0GsLFdBkfrvQHc1zMHH6THBeggSwaJIOsAawwBBDDWqPwrAlkBYDqe\/maUcQabhwsFF2VBBxY8xu5aMQUFDkHVBKhRRwHhgWsEA5jXBlh9NQVMaT0CWlhTAroaFQRyciUHQlp7BF4trQa8unsE4TfI+9XLJQDNpLcIXLZdAuX2MwShiTsFcQh5BrHMqQVI1+UBWe4fBAzi0wfe11UFAIjq9Y1iAQDxrTsEY6plB\/JiXQfjFwkHkYGRBVNOhwCMxtEFbqZTA378WQeA\/Sb+FrSXCqlYywtb5SsDcqlZBk1EtQZ\/RREHZIxG\/kcv8QekDIkHPsDXCBL4VQHN8CMGtNvvAC3YwweUuAkKkJCnANEtVQG9z\/0DrwyTBQ9hnwWX3kMEdLB1CvIlKwQ0IO0HK1ErBvdRQQVpjMMCJDI\/Bb4X8QYVipEGpG2nBeLGUvmBlBT7ISgRB4iGAQUunkkFDFLm\/HNaqPzKTVkCITJG\/XzlYwbj0XcGD60PBbpLwQbvrs8Az8RXB4ubxQXh\/HEDtXLU\/kONrwVBs4MGc2X1BJaHkQd0ByEAKXLJBTq7JwPPkJUGJIIRBlh57wX3FjcC2Ie060Qc6Qal5xcCfqQrCl7edQQ==\";\n+    static float[] queryVectorFloat = parseBase64ToVector(x1);\n+    static float[] inputVectorFloat = parseBase64ToVector(x2);\n+    static double[] queryVectorDouble;\n+    static double[] inputVectorDouble;\n+\n+    static float normQueryVectorFloat;\n+    static double normQueryVectorDouble;\n+\n+    public static float[] parseArray(byte[] input) {\n+        if (input == null) {\n+            return null;\n+        }\n+        float[] floatArr = new float[input.length \/ 4];\n+        for (int i = 0; i < floatArr.length; i++) {\n+            int l;\n+            l = input[i << 2];\n+            l &= 0xff;\n+            l |= ((int) input[(i << 2) + 1] << 8);\n+            l &= 0xffff;\n+            l |= ((int) input[(i << 2) + 2] << 16);\n+            l &= 0xffffff;\n+            l |= ((int) input[(i << 2) + 3] << 24);\n+            floatArr[i] = Float.intBitsToFloat(l);\n+        }\n+        return floatArr;\n+    }\n+\n+    public static float[] parseBase64ToVector(String vectorBase64) {\n+        return parseArray(Base64.getDecoder().decode(vectorBase64));\n+    }\n+\n+    @Setup\n+    public void init() {\n+        queryVectorDouble = new double[queryVectorFloat.length];\n+        inputVectorDouble = new double[inputVectorFloat.length];\n+        for (int i = 0; i < queryVectorFloat.length; i++) {\n+            queryVectorDouble[i] = (double)(queryVectorFloat[i]);\n+        }\n+        for (int i = 0; i < inputVectorFloat.length; i++) {\n+            inputVectorDouble[i] = (double)(inputVectorFloat[i]);\n+        }\n+        float xSquare = 0;\n+        for (int i = 0; i < queryVectorFloat.length; i++) {\n+            xSquare += (float)(queryVectorFloat[i] * queryVectorFloat[i]);\n+        }\n+        normQueryVectorFloat = xSquare;\n+        normQueryVectorDouble = (double)xSquare;\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilOptimizedScalarFloat() {\n+        float dotProduct = 0.0f;\n+        float normInputVector = 0.0f;\n+        for (int i = 0; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        if (normalizedProduct == 0) {\n+            return Float.MIN_VALUE;\n+        }\n+        return (float) (dotProduct \/ (Math.sqrt(normalizedProduct)));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilOptimizedVectorFloat128() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_128);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_128);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_128);;\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_128.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_128.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_128, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_128, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilOptimizedVectorFloat256() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_256);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_256);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_256);;\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_256.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_256.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_256, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_256, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilOptimizedVectorFloatMax() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_MAX);;\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_MAX.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_MAX.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_MAX, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_MAX, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilScalarFloat() {\n+        float dotProduct = 0.0f;\n+        float normQueryVectorFloat = 0.0f;\n+        float normInputVector = 0.0f;\n+        for (int i = 0; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normQueryVectorFloat += queryVectorFloat[i] * queryVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        if (normalizedProduct == 0) {\n+            return Float.MIN_VALUE;\n+        }\n+        return (float) (dotProduct \/ (Math.sqrt(normalizedProduct)));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilVectorFloat128() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_128);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_128);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_128);;\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_128.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_128.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_128, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_128, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        float normQueryVectorFloat = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+            normQueryVectorFloat += queryVectorFloat[i] * queryVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilVectorFloat256() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_256);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_256);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_256);;\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_256.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_256.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_256, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_256, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        float normQueryVectorFloat = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+            normQueryVectorFloat += queryVectorFloat[i] * queryVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public float cosinesimilVectorFloatMax() {\n+        FloatVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        xSquareV = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        ySquareV = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_MAX.length()) <= queryVectorFloat.length; i += SPECIES_FLOAT_MAX.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_MAX, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_MAX, inputVectorFloat, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        float dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        float normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        float normQueryVectorFloat = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorFloat.length; i++) {\n+            dotProduct += queryVectorFloat[i] * inputVectorFloat[i];\n+            normInputVector += inputVectorFloat[i] * inputVectorFloat[i];\n+            normQueryVectorFloat += queryVectorFloat[i] * queryVectorFloat[i];\n+        }\n+        float normalizedProduct = normQueryVectorFloat * normInputVector;\n+        return (float)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilOptimizedScalarDouble() {\n+        double dotProduct = 0.0;\n+        double normInputVector = 0.0;\n+        for (int i = 0; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return dotProduct \/ (Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilOptimizedVectorDouble128() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_128.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_128.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_128, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_128, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilOptimizedVectorDouble256() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_256.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_256.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_256, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_256, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilOptimizedVectorDoubleMax() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_MAX.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_MAX.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilScalarDouble() {\n+        double dotProduct = 0.0f;\n+        double normQueryVectorDouble = 0.0f;\n+        double normInputVector = 0.0f;\n+        for (int i = 0; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normQueryVectorDouble += queryVectorDouble[i] * queryVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double) (dotProduct \/ (Math.sqrt(normalizedProduct)));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilVectorDouble128() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_128.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_128.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_128, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_128, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        double normQueryVectorDouble = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+            normQueryVectorDouble += queryVectorDouble[i] * queryVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilVectorDouble256() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_256.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_256.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_256, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_256, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        double normQueryVectorDouble = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+            normQueryVectorDouble += queryVectorDouble[i] * queryVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    @Benchmark\n+    public double cosinesimilVectorDoubleMax() {\n+        DoubleVector vecX, vecY, vecSum, xSquareV, ySquareV;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        xSquareV = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        ySquareV = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_MAX.length()) <= queryVectorDouble.length; i += SPECIES_DOUBLE_MAX.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, inputVectorDouble, i);\n+            vecSum = vecX.fma(vecY, vecSum);\n+            xSquareV = vecX.fma(vecX, xSquareV);\n+            ySquareV = vecY.fma(vecY, ySquareV);\n+        }\n+        double dotProduct = vecSum.reduceLanes(VectorOperators.ADD);\n+        double normInputVector = ySquareV.reduceLanes(VectorOperators.ADD);\n+        double normQueryVectorDouble = xSquareV.reduceLanes(VectorOperators.ADD);\n+        for (; i < queryVectorDouble.length; i++) {\n+            dotProduct += queryVectorDouble[i] * inputVectorDouble[i];\n+            normInputVector += inputVectorDouble[i] * inputVectorDouble[i];\n+            normQueryVectorDouble += queryVectorDouble[i] * queryVectorDouble[i];\n+        }\n+        double normalizedProduct = normQueryVectorDouble * normInputVector;\n+        return (double)(dotProduct \/ Math.sqrt(normalizedProduct));\n+    }\n+\n+    \/\/ l2Squared is used to compute Euclidean distance\n+    @Benchmark\n+    public float l2SquaredVectorFloat128() {\n+        FloatVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_128);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_128.length()) <= inputVectorFloat.length; i += SPECIES_FLOAT_128.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_128, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_128, inputVectorFloat, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        float sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorFloat.length; i++) {\n+            float diff = queryVectorFloat[i] - inputVectorFloat[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public float l2SquaredVectorFloat256() {\n+        FloatVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_256);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_256.length()) <= inputVectorFloat.length; i += SPECIES_FLOAT_256.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_256, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_256, inputVectorFloat, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        float sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorFloat.length; i++) {\n+            float diff = queryVectorFloat[i] - inputVectorFloat[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public float l2SquaredVectorFloatMax() {\n+        FloatVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = FloatVector.zero(SPECIES_FLOAT_MAX);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_FLOAT_MAX.length()) <= inputVectorFloat.length; i += SPECIES_FLOAT_MAX.length()) {\n+            vecX = FloatVector.fromArray(SPECIES_FLOAT_MAX, queryVectorFloat, i);\n+            vecY = FloatVector.fromArray(SPECIES_FLOAT_MAX, inputVectorFloat, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        float sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorFloat.length; i++) {\n+            float diff = queryVectorFloat[i] - inputVectorFloat[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public double l2SquaredVectorDouble128() {\n+        DoubleVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_128);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_128.length()) <= inputVectorDouble.length; i += SPECIES_DOUBLE_128.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_128, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_128, inputVectorDouble, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        double sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorDouble.length; i++) {\n+            double diff = queryVectorDouble[i] - inputVectorDouble[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public double l2SquaredVectorDouble256() {\n+        DoubleVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_256);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_256.length()) <= inputVectorDouble.length; i += SPECIES_DOUBLE_256.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_256, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_256, inputVectorDouble, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        double sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorDouble.length; i++) {\n+            double diff = queryVectorDouble[i] - inputVectorDouble[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public double l2SquaredVectorDoubleMax() {\n+        DoubleVector vecX, vecY, vecSum, vecSquare, vecDiff;\n+        vecSum = DoubleVector.zero(SPECIES_DOUBLE_MAX);\n+        int i = 0;\n+        for (i = 0; i + (SPECIES_DOUBLE_MAX.length()) <= inputVectorDouble.length; i += SPECIES_DOUBLE_MAX.length()) {\n+            vecX = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, queryVectorDouble, i);\n+            vecY = DoubleVector.fromArray(SPECIES_DOUBLE_MAX, inputVectorDouble, i);\n+            vecDiff = vecX.sub(vecY);\n+            vecSquare = vecDiff.mul(vecDiff);\n+            vecSum = vecDiff.fma(vecDiff, vecSum);\n+        }\n+        double sum = vecSum.reduceLanes(VectorOperators.ADD);\n+        for (; i < inputVectorDouble.length; i++) {\n+            double diff = queryVectorDouble[i] - inputVectorDouble[i];\n+            sum += diff * diff;\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public float l2SquaredScalar() {\n+        float squaredDistance = 0;\n+        for (int i = 0; i < inputVectorFloat.length; i++) {\n+            float diff = queryVectorFloat[i] - inputVectorFloat[i];\n+            squaredDistance += diff * diff;\n+        }\n+        return squaredDistance;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/bigdata\/VectorDistance.java","additions":583,"deletions":0,"binary":false,"changes":583,"status":"added"},{"patch":"@@ -0,0 +1,432 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.crypto;\n+\n+import org.openjdk.jmh.annotations.*;\n+import java.lang.foreign.MemorySegment;\n+import jdk.incubator.vector.*;\n+\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.Throughput)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+@Warmup(iterations = 3, time = 3)\n+@Measurement(iterations = 8, time = 2)\n+public class ChaChaBench {\n+\n+    @Param({\"16384\", \"65536\"})\n+    private int dataSize;\n+\n+    private ChaChaVector cc20_S128 = makeCC20(VectorShape.S_128_BIT);\n+    private ChaChaVector cc20_S256 = makeCC20(VectorShape.S_256_BIT);\n+    private ChaChaVector cc20_S512 = makeCC20(VectorShape.S_512_BIT);\n+\n+    private MemorySegment in;\n+    private MemorySegment out;\n+\n+    private byte[] key = new byte[32];\n+    private byte[] nonce = new byte[12];\n+    private long counter = 0;\n+\n+    private static ChaChaVector makeCC20(VectorShape shape) {\n+        ChaChaVector cc20 = new ChaChaVector(shape);\n+        runKAT(cc20);\n+        return cc20;\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        in = MemorySegment.ofArray(new byte[dataSize]);\n+        out = MemorySegment.ofArray(new byte[dataSize]);\n+    }\n+\n+    @Benchmark\n+    public void encrypt128() {\n+        cc20_S128.chacha20(key, nonce, counter, in, out);\n+    }\n+\n+    @Benchmark\n+    public void encrypt256() {\n+        cc20_S256.chacha20(key, nonce, counter, in, out);\n+    }\n+\n+    @Benchmark\n+    public void encrypt512() {\n+        cc20_S512.chacha20(key, nonce, counter, in, out);\n+    }\n+\n+    private static class ChaChaVector {\n+\n+        private static final int[] STATE_CONSTANTS =\n+            new int[]{0x61707865, 0x3320646e, 0x79622d32, 0x6b206574};\n+\n+        private final VectorSpecies<Integer> intSpecies;\n+        private final int numBlocks;\n+\n+        private final VectorShuffle<Integer> rot1;\n+        private final VectorShuffle<Integer> rot2;\n+        private final VectorShuffle<Integer> rot3;\n+\n+        private final IntVector counterAdd;\n+\n+        private final VectorShuffle<Integer> shuf0;\n+        private final VectorShuffle<Integer> shuf1;\n+        private final VectorShuffle<Integer> shuf2;\n+        private final VectorShuffle<Integer> shuf3;\n+\n+        private final VectorMask<Integer> mask0;\n+        private final VectorMask<Integer> mask1;\n+        private final VectorMask<Integer> mask2;\n+        private final VectorMask<Integer> mask3;\n+\n+        private final int[] state;\n+\n+        public ChaChaVector(VectorShape shape) {\n+            this.intSpecies = VectorSpecies.of(int.class, shape);\n+            this.numBlocks = intSpecies.length() \/ 4;\n+\n+            this.rot1 = makeRotate(1);\n+            this.rot2 = makeRotate(2);\n+            this.rot3 = makeRotate(3);\n+\n+            this.counterAdd = makeCounterAdd();\n+\n+            this.shuf0 = makeRearrangeShuffle(0);\n+            this.shuf1 = makeRearrangeShuffle(1);\n+            this.shuf2 = makeRearrangeShuffle(2);\n+            this.shuf3 = makeRearrangeShuffle(3);\n+\n+            this.mask0 = makeRearrangeMask(0);\n+            this.mask1 = makeRearrangeMask(1);\n+            this.mask2 = makeRearrangeMask(2);\n+            this.mask3 = makeRearrangeMask(3);\n+\n+            this.state = new int[numBlocks * 16];\n+        }\n+\n+        private VectorShuffle<Integer>  makeRotate(int amount) {\n+            int[] shuffleArr = new int[intSpecies.length()];\n+\n+            for (int i = 0; i < intSpecies.length(); i ++) {\n+                int offset = (i \/ 4) * 4;\n+                shuffleArr[i] = offset + ((i + amount) % 4);\n+            }\n+\n+            return VectorShuffle.fromValues(intSpecies, shuffleArr);\n+        }\n+\n+        private IntVector makeCounterAdd() {\n+            int[] addArr = new int[intSpecies.length()];\n+            for(int i = 0; i < numBlocks; i++) {\n+                addArr[4 * i] = numBlocks;\n+            }\n+            return IntVector.fromArray(intSpecies, addArr, 0);\n+        }\n+\n+        private VectorShuffle<Integer>  makeRearrangeShuffle(int order) {\n+            int[] shuffleArr = new int[intSpecies.length()];\n+            int start = order * 4;\n+            for (int i = 0; i < shuffleArr.length; i++) {\n+                shuffleArr[i] = (i % 4) + start;\n+            }\n+            return VectorShuffle.fromArray(intSpecies, shuffleArr, 0);\n+        }\n+\n+        private VectorMask<Integer> makeRearrangeMask(int order) {\n+            boolean[] maskArr = new boolean[intSpecies.length()];\n+            int start = order * 4;\n+            if (start < maskArr.length) {\n+                for (int i = 0; i < 4; i++) {\n+                    maskArr[i + start] = true;\n+                }\n+            }\n+\n+            return VectorMask.fromValues(intSpecies, maskArr);\n+        }\n+\n+        public void makeState(byte[] key, byte[] nonce, long counter,\n+            int[] out) {\n+\n+            \/\/ first field is constants\n+            for (int i = 0; i < 4; i++) {\n+                for (int j = 0; j < numBlocks; j++) {\n+                    out[4*j + i] = STATE_CONSTANTS[i];\n+                }\n+            }\n+\n+            \/\/ second field is first part of key\n+            int fieldStart = 4 * numBlocks;\n+            for (int i = 0; i < 4; i++) {\n+                int keyInt = 0;\n+                for (int j = 0; j < 4; j++) {\n+                    keyInt += (0xFF & key[4 * i + j]) << 8 * j;\n+                }\n+                for (int j = 0; j < numBlocks; j++) {\n+                    out[fieldStart + j*4 + i] = keyInt;\n+                }\n+            }\n+\n+            \/\/ third field is second part of key\n+            fieldStart = 8 * numBlocks;\n+            for (int i = 0; i < 4; i++) {\n+                int keyInt = 0;\n+                for (int j = 0; j < 4; j++) {\n+                    keyInt += (0xFF & key[4 * (i + 4) + j]) << 8 * j;\n+                }\n+\n+                for (int j = 0; j < numBlocks; j++) {\n+                    out[fieldStart + j*4 + i] = keyInt;\n+                }\n+            }\n+\n+            \/\/ fourth field is counter and nonce\n+            fieldStart = 12 * numBlocks;\n+            for (int j = 0; j < numBlocks; j++) {\n+                out[fieldStart + j*4] = (int) (counter + j);\n+            }\n+\n+            for (int i = 0; i < 3; i++) {\n+                int nonceInt = 0;\n+                for (int j = 0; j < 4; j++) {\n+                    nonceInt += (0xFF & nonce[4 * i + j]) << 8 * j;\n+                }\n+\n+                for (int j = 0; j < numBlocks; j++) {\n+                    out[fieldStart + j*4 + 1 + i] = nonceInt;\n+                }\n+            }\n+        }\n+\n+        public void chacha20(byte[] key, byte[] nonce, long counter,\n+            MemorySegment in, MemorySegment out) {\n+\n+            makeState(key, nonce, counter, state);\n+\n+            int len = intSpecies.length();\n+\n+            IntVector sa = IntVector.fromArray(intSpecies, state, 0);\n+            IntVector sb = IntVector.fromArray(intSpecies, state, len);\n+            IntVector sc = IntVector.fromArray(intSpecies, state, 2 * len);\n+            IntVector sd = IntVector.fromArray(intSpecies, state, 3 * len);\n+\n+            int stateLenBytes = state.length * 4;\n+            int numStates = (((int) in.byteSize()) + stateLenBytes - 1) \/ stateLenBytes;\n+            for (int j = 0; j < numStates; j++){\n+\n+                IntVector a = sa;\n+                IntVector b = sb;\n+                IntVector c = sc;\n+                IntVector d = sd;\n+\n+                for (int i = 0; i < 10; i++) {\n+                    \/\/ first round\n+                    a = a.add(b);\n+                    d = d.lanewise(VectorOperators.XOR, a);\n+                    d = d.lanewise(VectorOperators.ROL, 16);\n+\n+                    c = c.add(d);\n+                    b = b.lanewise(VectorOperators.XOR, c);\n+                    b = b.lanewise(VectorOperators.ROL,12);\n+\n+                    a = a.add(b);\n+                    d = d.lanewise(VectorOperators.XOR, a);\n+                    d = d.lanewise(VectorOperators.ROL,8);\n+\n+                    c = c.add(d);\n+                    b = b.lanewise(VectorOperators.XOR, c);\n+                    b = b.lanewise(VectorOperators.ROL,7);\n+\n+                    \/\/ makeRotate\n+                    b = b.rearrange(rot1);\n+                    c = c.rearrange(rot2);\n+                    d = d.rearrange(rot3);\n+\n+                    \/\/ second round\n+                    a = a.add(b);\n+                    d = d.lanewise(VectorOperators.XOR, a);\n+                    d = d.lanewise(VectorOperators.ROL,16);\n+\n+                    c = c.add(d);\n+                    b = b.lanewise(VectorOperators.XOR, c);\n+                    b = b.lanewise(VectorOperators.ROL,12);\n+\n+                    a = a.add(b);\n+                    d = d.lanewise(VectorOperators.XOR, a);\n+                    d = d.lanewise(VectorOperators.ROL,8);\n+\n+                    c = c.add(d);\n+                    b = b.lanewise(VectorOperators.XOR, c);\n+                    b = b.lanewise(VectorOperators.ROL,7);\n+\n+                    \/\/ makeRotate\n+                    b = b.rearrange(rot3);\n+                    c = c.rearrange(rot2);\n+                    d = d.rearrange(rot1);\n+                }\n+\n+                a = a.add(sa);\n+                b = b.add(sb);\n+                c = c.add(sc);\n+                d = d.add(sd);\n+\n+                \/\/ rearrange the vectors\n+                if (intSpecies.length() == 4) {\n+                    \/\/ no rearrange needed\n+                } else if (intSpecies.length() == 8) {\n+                    IntVector a_r =\n+                            a.rearrange(shuf0).blend(b.rearrange(shuf0), mask1);\n+                    IntVector b_r =\n+                            c.rearrange(shuf0).blend(d.rearrange(shuf0), mask1);\n+                    IntVector c_r =\n+                            a.rearrange(shuf1).blend(b.rearrange(shuf1), mask1);\n+                    IntVector d_r =\n+                            c.rearrange(shuf1).blend(d.rearrange(shuf1), mask1);\n+\n+                    a = a_r;\n+                    b = b_r;\n+                    c = c_r;\n+                    d = d_r;\n+                } else if (intSpecies.length() == 16) {\n+                    IntVector a_r = a;\n+                    a_r = a_r.blend(b.rearrange(shuf0), mask1);\n+                    a_r = a_r.blend(c.rearrange(shuf0), mask2);\n+                    a_r = a_r.blend(d.rearrange(shuf0), mask3);\n+\n+                    IntVector b_r = b;\n+                    b_r = b_r.blend(a.rearrange(shuf1), mask0);\n+                    b_r = b_r.blend(c.rearrange(shuf1), mask2);\n+                    b_r = b_r.blend(d.rearrange(shuf1), mask3);\n+\n+                    IntVector c_r = c;\n+                    c_r = c_r.blend(a.rearrange(shuf2), mask0);\n+                    c_r = c_r.blend(b.rearrange(shuf2), mask1);\n+                    c_r = c_r.blend(d.rearrange(shuf2), mask3);\n+\n+                    IntVector d_r = d;\n+                    d_r = d_r.blend(a.rearrange(shuf3), mask0);\n+                    d_r = d_r.blend(b.rearrange(shuf3), mask1);\n+                    d_r = d_r.blend(c.rearrange(shuf3), mask2);\n+\n+                    a = a_r;\n+                    b = b_r;\n+                    c = c_r;\n+                    d = d_r;\n+                } else {\n+                    throw new RuntimeException(\"not supported\");\n+                }\n+\n+                \/\/ xor keystream with input\n+                int inOff = stateLenBytes * j;\n+                IntVector ina = IntVector.fromMemorySegment(intSpecies, in, inOff, ByteOrder.LITTLE_ENDIAN);\n+                IntVector inb = IntVector.fromMemorySegment(intSpecies, in, inOff + 4L * len, ByteOrder.LITTLE_ENDIAN);\n+                IntVector inc = IntVector.fromMemorySegment(intSpecies, in, inOff + 8L * len, ByteOrder.LITTLE_ENDIAN);\n+                IntVector ind = IntVector.fromMemorySegment(intSpecies, in, inOff + 12L * len, ByteOrder.LITTLE_ENDIAN);\n+\n+                ina.lanewise(VectorOperators.XOR, a).intoMemorySegment(out, inOff, ByteOrder.LITTLE_ENDIAN);\n+                inb.lanewise(VectorOperators.XOR, b).intoMemorySegment(out, inOff + 4L * len, ByteOrder.LITTLE_ENDIAN);\n+                inc.lanewise(VectorOperators.XOR, c).intoMemorySegment(out, inOff + 8L * len, ByteOrder.LITTLE_ENDIAN);\n+                ind.lanewise(VectorOperators.XOR, d).intoMemorySegment(out, inOff + 12L * len, ByteOrder.LITTLE_ENDIAN);\n+\n+                \/\/ increment counter\n+                sd = sd.add(counterAdd);\n+            }\n+        }\n+\n+        public int implBlockSize() {\n+            return numBlocks * 64;\n+        }\n+    }\n+\n+    private static byte[] hexStringToByteArray(String str) {\n+        byte[] result = new byte[str.length() \/ 2];\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = (byte) Character.digit(str.charAt(2 * i), 16);\n+            result[i] <<= 4;\n+            result[i] += (byte) Character.digit(str.charAt(2 * i + 1), 16);\n+        }\n+        return result;\n+    }\n+\n+    private static void runKAT(ChaChaVector cc20, String keyStr,\n+        String nonceStr, long counter, String inStr, String outStr) {\n+\n+        byte[] key = hexStringToByteArray(keyStr);\n+        byte[] nonce = hexStringToByteArray(nonceStr);\n+        byte[] in = hexStringToByteArray(inStr);\n+        byte[] expOut = hexStringToByteArray(outStr);\n+\n+        \/\/ implementation only works at multiples of some size\n+        int blockSize = cc20.implBlockSize();\n+\n+        int length = blockSize * ((in.length + blockSize - 1) \/ blockSize);\n+        in = Arrays.copyOf(in, length);\n+        byte[] out = new byte[length];\n+\n+        cc20.chacha20(key, nonce, counter, MemorySegment.ofArray(in), MemorySegment.ofArray(out));\n+\n+        byte[] actOut = new byte[expOut.length];\n+        System.arraycopy(out, 0, actOut, 0, expOut.length);\n+\n+        if (!Arrays.equals(out, 0, expOut.length, expOut, 0, expOut.length)) {\n+            throw new RuntimeException(\"Incorrect result\");\n+        }\n+    }\n+\n+    \/*\n+     * ChaCha20 Known Answer Tests to ensure that the implementation is correct.\n+     *\/\n+    private static void runKAT(ChaChaVector cc20) {\n+        runKAT(cc20,\n+        \"0000000000000000000000000000000000000000000000000000000000000001\",\n+        \"000000000000000000000002\",\n+        1,\n+        \"416e79207375626d697373696f6e20746f20746865204945544620696e74656e\" +\n+        \"6465642062792074686520436f6e7472696275746f7220666f72207075626c69\" +\n+        \"636174696f6e20617320616c6c206f722070617274206f6620616e2049455446\" +\n+        \"20496e7465726e65742d4472616674206f722052464320616e6420616e792073\" +\n+        \"746174656d656e74206d6164652077697468696e2074686520636f6e74657874\" +\n+        \"206f6620616e204945544620616374697669747920697320636f6e7369646572\" +\n+        \"656420616e20224945544620436f6e747269627574696f6e222e205375636820\" +\n+        \"73746174656d656e747320696e636c756465206f72616c2073746174656d656e\" +\n+        \"747320696e20494554462073657373696f6e732c2061732077656c6c20617320\" +\n+        \"7772697474656e20616e6420656c656374726f6e696320636f6d6d756e696361\" +\n+        \"74696f6e73206d61646520617420616e792074696d65206f7220706c6163652c\" +\n+        \"207768696368206172652061646472657373656420746f\",\n+        \"a3fbf07df3fa2fde4f376ca23e82737041605d9f4f4f57bd8cff2c1d4b7955ec\" +\n+        \"2a97948bd3722915c8f3d337f7d370050e9e96d647b7c39f56e031ca5eb6250d\" +\n+        \"4042e02785ececfa4b4bb5e8ead0440e20b6e8db09d881a7c6132f420e527950\" +\n+        \"42bdfa7773d8a9051447b3291ce1411c680465552aa6c405b7764d5e87bea85a\" +\n+        \"d00f8449ed8f72d0d662ab052691ca66424bc86d2df80ea41f43abf937d3259d\" +\n+        \"c4b2d0dfb48a6c9139ddd7f76966e928e635553ba76c5c879d7b35d49eb2e62b\" +\n+        \"0871cdac638939e25e8a1e0ef9d5280fa8ca328b351c3c765989cbcf3daa8b6c\" +\n+        \"cc3aaf9f3979c92b3720fc88dc95ed84a1be059c6499b9fda236e7e818b04b0b\" +\n+        \"c39c1e876b193bfe5569753f88128cc08aaa9b63d1a16f80ef2554d7189c411f\" +\n+        \"5869ca52c5b83fa36ff216b9c1d30062bebcfd2dc5bce0911934fda79a86f6e6\" +\n+        \"98ced759c3ff9b6477338f3da4f9cd8514ea9982ccafb341b2384dd902f3d1ab\" +\n+        \"7ac61dd29c6f21ba5b862f3730e37cfdc4fd806c22f221\"\n+        );\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/crypto\/ChaChaBench.java","additions":432,"deletions":0,"binary":false,"changes":432,"status":"added"},{"patch":"@@ -0,0 +1,665 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.crypto;\n+\n+import java.lang.foreign.MemorySegment;\n+import org.openjdk.jmh.annotations.*;\n+import jdk.incubator.vector.*;\n+\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.Throughput)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+@Warmup(iterations = 3, time = 3)\n+@Measurement(iterations = 8, time = 2)\n+public class Poly1305Bench {\n+\n+    @Param({\"16384\", \"65536\"})\n+    private int dataSize;\n+\n+    private Poly1305Vector poly1305_S128 = makePoly1305(VectorShape.S_128_BIT);\n+    private Poly1305Vector poly1305_S256 = makePoly1305(VectorShape.S_256_BIT);\n+    private Poly1305Vector poly1305_S512 = makePoly1305(VectorShape.S_512_BIT);\n+\n+    private byte[] in;\n+    private byte[] out = new byte[16];\n+    private byte[] key = new byte[32];\n+\n+    private static Poly1305Vector makePoly1305(VectorShape shape) {\n+        Poly1305Vector poly = new Poly1305Vector(shape);\n+        runKAT(poly);\n+        return poly;\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        in = new byte[dataSize];\n+    }\n+\n+    @Benchmark\n+    public void auth128() {\n+        poly1305_S128.computeTag(key, in, out);\n+    }\n+\n+    @Benchmark\n+    public void auth256() {\n+        poly1305_S256.computeTag(key, in, out);\n+    }\n+\n+    @Benchmark\n+    public void auth512() {\n+        poly1305_S512.computeTag(key, in, out);\n+    }\n+\n+    private static class Poly1305Vector {\n+\n+        private static final int BITS_PER_LIMB = 26;\n+        private static final int LIMB_MASK = (1 << BITS_PER_LIMB) - 1;\n+        private static final int KEY_LENGTH = 32;\n+        private static final int RS_LENGTH = KEY_LENGTH \/ 2;\n+\n+        private final VectorSpecies<Long> longSpecies;\n+        private final VectorSpecies<Integer> intSpecies;\n+        private final int vectorWidth;\n+        private final int parBlockCount;\n+\n+        private final VectorShuffle<Long> inShuffle0;\n+        private final VectorShuffle<Long> inShuffle1;\n+        private final VectorMask<Long> inMask;\n+\n+        public Poly1305Vector(VectorShape shape) {\n+\n+            this.longSpecies = VectorSpecies.of(long.class, shape);\n+            int intSize = shape.vectorBitSize() \/ 2;\n+            VectorShape intShape = VectorShape.forBitSize(intSize);\n+            this.intSpecies = VectorSpecies.of(int.class, intShape);\n+            this.vectorWidth = longSpecies.length();\n+            this.parBlockCount = vectorWidth * 16;\n+\n+            this.inShuffle0 = makeInShuffle0();\n+            this.inShuffle1 = makeInShuffle1();\n+            this.inMask = makeInMask();\n+        }\n+\n+        private VectorShuffle<Long> makeInShuffle0() {\n+            int[] indexArr = new int[vectorWidth];\n+            for (int i = 0; i < indexArr.length; i++) {\n+                indexArr[i] = (2 * i) % vectorWidth;\n+            }\n+            return VectorShuffle.fromArray(longSpecies, indexArr, 0);\n+        }\n+        private VectorShuffle<Long> makeInShuffle1() {\n+            int[] indexArr = new int[vectorWidth];\n+            for (int i = 0; i < indexArr.length; i++) {\n+                indexArr[i] = ((2 * i) % vectorWidth) + 1;\n+            }\n+            return VectorShuffle.fromArray(longSpecies, indexArr, 0);\n+        }\n+        private VectorMask<Long> makeInMask() {\n+            boolean[] maskArr = new boolean[vectorWidth];\n+            for (int i = vectorWidth \/ 2; i < vectorWidth; i++) {\n+                maskArr[i] = true;\n+            }\n+            return VectorMask.fromArray(longSpecies, maskArr, 0);\n+        }\n+\n+        private static int[] fromByteArray(byte[] buf) {\n+            int[] result = new int[5];\n+\n+            result[0]\n+                    = (buf[0] & 0xFF)\n+                    + ((buf[1] & 0xFF) << 8)\n+                    + ((buf[2] & 0xFF) << 16)\n+                    + ((buf[3] & 0x03) << 24);\n+            result[1]\n+                    = ((buf[3] & 0xFF) >> 2)\n+                    + ((buf[4] & 0xFF) << 6)\n+                    + ((buf[5] & 0xFF) << 14)\n+                    + ((buf[6] & 0x0F) << 22);\n+            result[2]\n+                    = ((buf[6] & 0xFF) >> 4)\n+                    + ((buf[7] & 0xFF) << 4)\n+                    + ((buf[8] & 0xFF) << 12)\n+                    + ((buf[9] & 0x3F) << 20);\n+            result[3]\n+                    = ((buf[9] & 0xFF) >> 6)\n+                    + ((buf[10] & 0xFF) << 2)\n+                    + ((buf[11] & 0xFF) << 10)\n+                    + ((buf[12] & 0xFF) << 18);\n+            result[4]\n+                    = (buf[13] & 0xFF)\n+                    + ((buf[14] & 0xFF) << 8)\n+                    + ((buf[15] & 0xFF) << 16);\n+\n+            return result;\n+        }\n+\n+        private static void toByteArray(long v0, long v1, long v2, long v3,\n+            long v4, byte[] dst) {\n+\n+            dst[0] = (byte) v0;\n+            v0 >>= 8;\n+            dst[1] = (byte) v0;\n+            v0 >>= 8;\n+            dst[2] = (byte) v0;\n+            v0 >>= 8;\n+            dst[3] = (byte) v0;\n+\n+            dst[3] += (byte) ((v1 & 0x3F) << 2);\n+            v1 >>= 6;\n+            dst[4] = (byte) v1;\n+            v1 >>= 8;\n+            dst[5] = (byte) v1;\n+            v1 >>= 8;\n+            dst[6] = (byte) v1;\n+\n+            dst[6] += (byte) ((v2 & 0xF) << 4);\n+            v2 >>= 4;\n+            dst[7] = (byte) v2;\n+            v2 >>= 8;\n+            dst[8] = (byte) v2;\n+            v2 >>= 8;\n+            dst[9] = (byte) v2;\n+\n+            dst[9] += (byte) ((v3 & 0x3) << 6);\n+            v3 >>= 2;\n+            dst[10] = (byte) v3;\n+            v3 >>= 8;\n+            dst[11] = (byte) v3;\n+            v3 >>= 8;\n+            dst[12] = (byte) v3;\n+\n+            dst[13] = (byte) v4;\n+            v4 >>= 8;\n+            dst[14] = (byte) v4;\n+            v4 >>= 8;\n+            dst[15] = (byte) v4;\n+        }\n+\n+        protected static long carryValue(long x) {\n+            return x >> BITS_PER_LIMB;\n+        }\n+\n+        public static void carryReduce(int[] r, long c0, long c1, long c2,\n+            long c3, long c4) {\n+\n+            long c;\n+\n+            c = carryValue(c3); c3 &= LIMB_MASK; c4 += c;\n+            c = carryValue(c4); c4 &= LIMB_MASK; c0 += c * 5;\n+            c = carryValue(c0); c0 &= LIMB_MASK; c1 += c;\n+            c = carryValue(c1); c1 &= LIMB_MASK; c2 += c;\n+            c = carryValue(c2); c2 &= LIMB_MASK; c3 += c;\n+            c = carryValue(c3); c3 &= LIMB_MASK; c4 += c;\n+\n+            r[0] = (int) c0;\n+            r[1] = (int) c1;\n+            r[2] = (int) c2;\n+            r[3] = (int) c3;\n+            r[4] = (int) c4;\n+        }\n+\n+        private int[] multiply(int[] a, int[] b) {\n+            int[] result = new int[5];\n+\n+            long a0 = a[0];\n+            long a1 = a[1];\n+            long a2 = a[2];\n+            long a3 = a[3];\n+            long a4 = a[4];\n+\n+            long c0 = (a0 * b[0]) + 5 * (a1 * b[4]) + 5 * (a2 * b[3]) +\n+                5 * (a3 * b[2]) + 5 * (a4 * b[1]);\n+            long c1 = (a0 * b[1]) + (a1 * b[0]) + 5 * (a2 * b[4]) +\n+                5 * (a3 * b[3]) + 5 * (a4 * b[2]);\n+            long c2 = (a0 * b[2]) + (a1 * b[1]) + (a2 * b[0]) +\n+                5 * (a3 * b[4]) + 5 * (a4 * b[3]);\n+            long c3 = (a0 * b[3]) + (a1 * b[2]) + (a2 * b[1]) + (a3 * b[0]) +\n+                5 * (a4 * b[4]);\n+            long c4 = (a0 * b[4]) + (a1 * b[3]) + (a2 * b[2]) + (a3 * b[1]) +\n+                (a4 * b[0]);\n+\n+            carryReduce(result, c0, c1, c2, c3, c4);\n+\n+            return result;\n+        }\n+\n+        private LongVector rPowerVec(int[][] r, long[] temp, int maxIndex,\n+            int secondIndex) {\n+\n+            for (int i = 0; i < temp.length; i++) {\n+                temp[i] = r[maxIndex - i][secondIndex];\n+            }\n+            return LongVector.fromArray(longSpecies, temp, 0);\n+        }\n+\n+        public void computeTag(byte[] key, byte[] msg, byte[] out) {\n+\n+            byte[] keyBytes = key.clone();\n+\n+            \/\/ setup key values\n+            \/\/ Clamp the bytes in the \"r\" half of the key.\n+            keyBytes[3] &= 15;\n+            keyBytes[7] &= 15;\n+            keyBytes[11] &= 15;\n+            keyBytes[15] &= 15;\n+            keyBytes[4] &= (byte) 252;\n+            keyBytes[8] &= (byte) 252;\n+            keyBytes[12] &= (byte) 252;\n+\n+            \/\/ Create IntegerModuloP elements from the r and s values\n+            int[][] r = new int[vectorWidth][];\n+            r[0] = fromByteArray(keyBytes);\n+            for (int i = 1; i < vectorWidth; i++) {\n+                r[i] = multiply(r[i - 1], r[0]);\n+            }\n+\n+            int rUpIndex = vectorWidth - 1;\n+            IntVector rUp0_int = IntVector.broadcast(intSpecies, r[rUpIndex][0]);\n+            IntVector rUp1_int = IntVector.broadcast(intSpecies, r[rUpIndex][1]);\n+            IntVector rUp2_int = IntVector.broadcast(intSpecies, r[rUpIndex][2]);\n+            IntVector rUp3_int = IntVector.broadcast(intSpecies, r[rUpIndex][3]);\n+            IntVector rUp4_int = IntVector.broadcast(intSpecies, r[rUpIndex][4]);\n+\n+            IntVector r5Up1_int = rUp1_int.mul(5);\n+            IntVector r5Up2_int = rUp2_int.mul(5);\n+            IntVector r5Up3_int = rUp3_int.mul(5);\n+            IntVector r5Up4_int = rUp4_int.mul(5);\n+\n+            MemorySegment msMsg = MemorySegment.ofArray(msg);\n+            LongVector longMsg0 = LongVector.fromMemorySegment(longSpecies, msMsg, 0, ByteOrder.LITTLE_ENDIAN);\n+            LongVector longMsg1 =\n+                LongVector.fromMemorySegment(longSpecies, msMsg, vectorWidth * 8L, ByteOrder.LITTLE_ENDIAN);\n+\n+            LongVector inAlign0 =\n+            longMsg0.rearrange(inShuffle0).blend(longMsg1.rearrange(inShuffle0), inMask);\n+            LongVector inAlign1 =\n+            longMsg0.rearrange(inShuffle1).blend(longMsg1.rearrange(inShuffle1), inMask);\n+\n+            IntVector a0 = (IntVector)\n+                inAlign0.and(LIMB_MASK).castShape(intSpecies, 0);\n+            IntVector a1 = (IntVector)\n+                inAlign0.lanewise(VectorOperators.LSHR,26).and(LIMB_MASK).castShape(intSpecies, 0);\n+            IntVector a2 = (IntVector)\n+                inAlign0.lanewise(VectorOperators.LSHR,52).and(0xFFF).castShape(intSpecies, 0);\n+            a2 = a2.or(inAlign1.and(0x3FFF).lanewise(VectorOperators.LSHL,12).castShape(intSpecies, 0));\n+            IntVector a3 = (IntVector)\n+                inAlign1.lanewise(VectorOperators.LSHR,14).and(LIMB_MASK).castShape(intSpecies, 0);\n+            IntVector a4 = (IntVector)\n+                inAlign1.lanewise(VectorOperators.LSHR,40).and(0xFFFFFF).castShape(intSpecies, 0);\n+            a4 = a4.or(1 << 24);\n+\n+            int numParBlocks = msg.length \/ parBlockCount - 1;\n+            for (int i = 0; i < numParBlocks; i++) {\n+\n+                \/\/ multiply and reduce\n+                LongVector c0 = (LongVector)\n+                    a0.castShape(longSpecies, 0).mul(rUp0_int.castShape(longSpecies, 0))\n+                    .add(a1.castShape(longSpecies, 0).mul(r5Up4_int.castShape(longSpecies, 0)))\n+                    .add(a2.castShape(longSpecies, 0).mul(r5Up3_int.castShape(longSpecies, 0)))\n+                    .add(a3.castShape(longSpecies, 0).mul(r5Up2_int.castShape(longSpecies, 0)))\n+                    .add(a4.castShape(longSpecies, 0).mul(r5Up1_int.castShape(longSpecies, 0)));\n+\n+                LongVector c1 = (LongVector)\n+                    a0.castShape(longSpecies, 0).mul(rUp1_int.castShape(longSpecies, 0))\n+                    .add(a1.castShape(longSpecies, 0).mul(rUp0_int.castShape(longSpecies, 0)))\n+                    .add(a2.castShape(longSpecies, 0).mul(r5Up4_int.castShape(longSpecies, 0)))\n+                    .add(a3.castShape(longSpecies, 0).mul(r5Up3_int.castShape(longSpecies, 0)))\n+                    .add(a4.castShape(longSpecies, 0).mul(r5Up2_int.castShape(longSpecies, 0)));\n+\n+                LongVector c2 = (LongVector)\n+                    a0.castShape(longSpecies, 0).mul(rUp2_int.castShape(longSpecies, 0))\n+                    .add(a1.castShape(longSpecies, 0).mul(rUp1_int.castShape(longSpecies, 0)))\n+                    .add(a2.castShape(longSpecies, 0).mul(rUp0_int.castShape(longSpecies, 0)))\n+                    .add(a3.castShape(longSpecies, 0).mul(r5Up4_int.castShape(longSpecies, 0)))\n+                    .add(a4.castShape(longSpecies, 0).mul(r5Up3_int.castShape(longSpecies, 0)));\n+\n+                LongVector c3 = (LongVector)\n+                    a0.castShape(longSpecies, 0).mul(rUp3_int.castShape(longSpecies, 0))\n+                    .add(a1.castShape(longSpecies, 0).mul(rUp2_int.castShape(longSpecies, 0)))\n+                    .add(a2.castShape(longSpecies, 0).mul(rUp1_int.castShape(longSpecies, 0)))\n+                    .add(a3.castShape(longSpecies, 0).mul(rUp0_int.castShape(longSpecies, 0)))\n+                    .add(a4.castShape(longSpecies, 0).mul(r5Up4_int.castShape(longSpecies, 0)));\n+\n+                LongVector c4 = (LongVector)\n+                    a0.castShape(longSpecies, 0).mul(rUp4_int.castShape(longSpecies, 0))\n+                    .add(a1.castShape(longSpecies, 0).mul(rUp3_int.castShape(longSpecies, 0)))\n+                    .add(a2.castShape(longSpecies, 0).mul(rUp2_int.castShape(longSpecies, 0)))\n+                    .add(a3.castShape(longSpecies, 0).mul(rUp1_int.castShape(longSpecies, 0)))\n+                    .add(a4.castShape(longSpecies, 0).mul(rUp0_int.castShape(longSpecies, 0)));\n+\n+                \/\/ carry\/reduce\n+                \/\/ Note: this carry\/reduce sequence might not be correct\n+                c4 = c4.add(c3.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+                c3 = c3.and(LIMB_MASK);\n+                c0 = c0.add(c4.lanewise(VectorOperators.LSHR, BITS_PER_LIMB).mul(5));\n+                c4 = c4.and(LIMB_MASK);\n+                c1 = c1.add(c0.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+                c0 = c0.and(LIMB_MASK);\n+                c2 = c2.add(c1.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+                c1 = c1.and(LIMB_MASK);\n+                c3 = c3.add(c2.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+                c2 = c2.and(LIMB_MASK);\n+                c4 = c4.add(c3.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+                c3 = c3.and(LIMB_MASK);\n+\n+                a0 = (IntVector) c0.castShape(intSpecies, 0);\n+                a1 = (IntVector) c1.castShape(intSpecies, 0);\n+                a2 = (IntVector) c2.castShape(intSpecies, 0);\n+                a3 = (IntVector) c3.castShape(intSpecies, 0);\n+                a4 = (IntVector) c4.castShape(intSpecies, 0);\n+\n+                \/\/ fromByteArray and add next part of message\n+                int start = parBlockCount * (i + 1);\n+\n+                longMsg0 = LongVector.fromMemorySegment(longSpecies, msMsg, start, ByteOrder.LITTLE_ENDIAN);\n+                longMsg1 = LongVector.fromMemorySegment(longSpecies, msMsg,\n+                    start + vectorWidth * 8L, ByteOrder.LITTLE_ENDIAN);\n+\n+                inAlign0 =\n+                        longMsg0.rearrange(inShuffle0).blend(longMsg1.rearrange(inShuffle0), inMask);\n+                inAlign1 =\n+                        longMsg0.rearrange(inShuffle1).blend(longMsg1.rearrange(inShuffle1), inMask);\n+\n+                IntVector in0 = (IntVector)\n+                    inAlign0.and(LIMB_MASK).castShape(intSpecies, 0);\n+                IntVector in1 = (IntVector)\n+                    inAlign0.lanewise(VectorOperators.LSHR, 26).and(LIMB_MASK).castShape(intSpecies, 0);\n+                IntVector in2 = (IntVector)\n+                    inAlign0.lanewise(VectorOperators.LSHR, 52).and(0xFFF).castShape(intSpecies, 0);\n+                in2 = in2.or(inAlign1.and(0x3FFF).lanewise(VectorOperators.LSHL, 12).castShape(intSpecies, 0));\n+                IntVector in3 = (IntVector)\n+                    inAlign1.lanewise(VectorOperators.LSHR, 14).and(LIMB_MASK).castShape(intSpecies, 0);\n+                IntVector in4 = (IntVector)\n+                    inAlign1.lanewise(VectorOperators.LSHR, 40).and(0xFFFFFF).castShape(intSpecies, 0);\n+                in4 = in4.or(1 << 24);\n+\n+                a0 = a0.add(in0);\n+                a1 = a1.add(in1);\n+                a2 = a2.add(in2);\n+                a3 = a3.add(in3);\n+                a4 = a4.add(in4);\n+            }\n+\n+            \/\/ multiply by powers of r\n+            long[] rTemp = new long[vectorWidth];\n+            LongVector rFin0 = rPowerVec(r, rTemp, rUpIndex, 0);\n+            LongVector rFin1 = rPowerVec(r, rTemp, rUpIndex, 1);\n+            LongVector rFin2 = rPowerVec(r, rTemp, rUpIndex, 2);\n+            LongVector rFin3 = rPowerVec(r, rTemp, rUpIndex, 3);\n+            LongVector rFin4 = rPowerVec(r, rTemp, rUpIndex, 4);\n+\n+            LongVector r5Fin_1 = rFin1.mul(5);\n+            LongVector r5Fin_2 = rFin2.mul(5);\n+            LongVector r5Fin_3 = rFin3.mul(5);\n+            LongVector r5Fin_4 = rFin4.mul(5);\n+\n+            LongVector c0 = (LongVector) a0.castShape(longSpecies, 0).mul(rFin0)\n+                .add(a1.castShape(longSpecies, 0).mul(r5Fin_4))\n+                .add(a2.castShape(longSpecies, 0).mul(r5Fin_3))\n+                .add(a3.castShape(longSpecies, 0).mul(r5Fin_2))\n+                .add(a4.castShape(longSpecies, 0).mul(r5Fin_1));\n+            LongVector c1 = (LongVector) a0.castShape(longSpecies, 0).mul(rFin1)\n+                .add(a1.castShape(longSpecies, 0).mul(rFin0))\n+                .add(a2.castShape(longSpecies, 0).mul(r5Fin_4))\n+                .add(a3.castShape(longSpecies, 0).mul(r5Fin_3))\n+                .add(a4.castShape(longSpecies, 0).mul(r5Fin_2));\n+            LongVector c2 = (LongVector) a0.castShape(longSpecies, 0).mul(rFin2)\n+                .add(a1.castShape(longSpecies, 0).mul(rFin1))\n+                .add(a2.castShape(longSpecies, 0).mul(rFin0))\n+                .add(a3.castShape(longSpecies, 0).mul(r5Fin_4))\n+                .add(a4.castShape(longSpecies, 0).mul(r5Fin_3));\n+            LongVector c3 = (LongVector) a0.castShape(longSpecies, 0).mul(rFin3)\n+                .add(a1.castShape(longSpecies, 0).mul(rFin2))\n+                .add(a2.castShape(longSpecies, 0).mul(rFin1))\n+                .add(a3.castShape(longSpecies, 0).mul(rFin0))\n+                .add(a4.castShape(longSpecies, 0).mul(r5Fin_4));\n+            LongVector c4 = (LongVector) a0.castShape(longSpecies, 0).mul(rFin4)\n+                .add(a1.castShape(longSpecies, 0).mul(rFin3))\n+                .add(a2.castShape(longSpecies, 0).mul(rFin2))\n+                .add(a3.castShape(longSpecies, 0).mul(rFin1))\n+                .add(a4.castShape(longSpecies, 0).mul(rFin0));\n+\n+            c4 = c4.add(c3.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+            c3 = c3.and(LIMB_MASK);\n+            c0 = c0.add(c4.lanewise(VectorOperators.LSHR, BITS_PER_LIMB).mul(5));\n+            c4 = c4.and(LIMB_MASK);\n+            c1 = c1.add(c0.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+            c0 = c0.and(LIMB_MASK);\n+            c2 = c2.add(c1.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+            c1 = c1.and(LIMB_MASK);\n+            c3 = c3.add(c2.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+            c2 = c2.and(LIMB_MASK);\n+            c4 = c4.add(c3.lanewise(VectorOperators.LSHR, BITS_PER_LIMB));\n+            c3 = c3.and(LIMB_MASK);\n+\n+            a0 = (IntVector) c0.castShape(intSpecies, 0);\n+            a1 = (IntVector) c1.castShape(intSpecies, 0);\n+            a2 = (IntVector) c2.castShape(intSpecies, 0);\n+            a3 = (IntVector) c3.castShape(intSpecies, 0);\n+            a4 = (IntVector) c4.castShape(intSpecies, 0);\n+\n+            \/\/ collect lanes and calculate tag\n+            long a0Fin = a0.reduceLanes(VectorOperators.ADD);\n+            long a1Fin = a1.reduceLanes(VectorOperators.ADD);\n+            long a2Fin = a2.reduceLanes(VectorOperators.ADD);\n+            long a3Fin = a3.reduceLanes(VectorOperators.ADD);\n+            long a4Fin = a4.reduceLanes(VectorOperators.ADD);\n+\n+            \/\/ carry\/reduce the result\n+            a4Fin = a4Fin + (a3Fin >>> BITS_PER_LIMB);\n+            a3Fin = a3Fin & LIMB_MASK;\n+            a0Fin = a0Fin + ((a4Fin >>> BITS_PER_LIMB) * 5);\n+            a4Fin = a4Fin & LIMB_MASK;\n+            a1Fin = a1Fin + (a0Fin >>> BITS_PER_LIMB);\n+            a0Fin = a0Fin & LIMB_MASK;\n+            a2Fin = a2Fin + (a1Fin >>> BITS_PER_LIMB);\n+            a1Fin = a1Fin & LIMB_MASK;\n+            a3Fin = a3Fin + (a2Fin >>> BITS_PER_LIMB);\n+            a2Fin = a2Fin & LIMB_MASK;\n+            a4Fin = a4Fin + (a3Fin >>> BITS_PER_LIMB);\n+            a3Fin = a3Fin & LIMB_MASK;\n+\n+            byte[] s_arr =\n+                Arrays.copyOfRange(keyBytes, RS_LENGTH, 2 * RS_LENGTH);\n+            int[] s = fromByteArray(s_arr);\n+\n+            \/\/ Add in the s-half of the key to the accumulator\n+            a0Fin += s[0];\n+            a1Fin += s[1];\n+            a2Fin += s[2];\n+            a3Fin += s[3];\n+            a4Fin += s[4];\n+\n+            \/\/ final carry mod 2^130\n+            a1Fin = a1Fin + (a0Fin >> BITS_PER_LIMB);\n+            a0Fin = a0Fin & LIMB_MASK;\n+            a2Fin = a2Fin + (a1Fin >> BITS_PER_LIMB);\n+            a1Fin = a1Fin & LIMB_MASK;\n+            a3Fin = a3Fin + (a2Fin >> BITS_PER_LIMB);\n+            a2Fin = a2Fin & LIMB_MASK;\n+            a4Fin = a4Fin + (a3Fin >> BITS_PER_LIMB);\n+            a3Fin = a3Fin & LIMB_MASK;\n+            a4Fin = a4Fin & LIMB_MASK;\n+\n+            \/\/ put result in buffer\n+            toByteArray(a0Fin, a1Fin, a2Fin, a3Fin, a4Fin, out);\n+        }\n+    }\n+\n+\n+    private static byte[] hexStringToByteArray(String str) {\n+        byte[] result = new byte[str.length() \/ 2];\n+        for (int i = 0; i < result.length; i++) {\n+            result[i] = (byte) (Character.digit(str.charAt(2 * i), 16));\n+            result[i] <<= 4;\n+            result[i] += (byte) (Character.digit(str.charAt(2 * i + 1), 16));\n+        }\n+        return result;\n+    }\n+\n+    public static String byteArrayToHexString(byte[] arr) {\n+        StringBuilder result = new StringBuilder();\n+        for (int i = 0; i < arr.length; ++i) {\n+            byte curVal = arr[i];\n+            result.append(Character.forDigit(curVal >> 4 & 0xF, 16));\n+            result.append(Character.forDigit(curVal & 0xF, 16));\n+        }\n+        return result.toString();\n+    }\n+\n+    private static void kat(Poly1305Vector poly1305, String key, String msg,\n+        String expectedTag) {\n+\n+        kat(poly1305, hexStringToByteArray(key), hexStringToByteArray(msg),\n+            hexStringToByteArray(expectedTag));\n+    }\n+\n+    private static void kat(Poly1305Vector poly1305, byte[] key, byte[] msg,\n+        byte[] expectedTag) {\n+\n+        byte[] tag = new byte[expectedTag.length];\n+        poly1305.computeTag(key, msg, tag);\n+        if (!Arrays.equals(tag, expectedTag)) {\n+            throw new RuntimeException(\n+                    \"bad tag: \" + byteArrayToHexString(tag) +\n+                    \" expected: \" + byteArrayToHexString(expectedTag));\n+        }\n+    }\n+\n+    \/*\n+     * Poly1305 Known Answer Tests to ensure that the implementation is correct.\n+     *\/\n+    private static void runKAT(Poly1305Vector poly1305) {\n+        kat(poly1305,\n+            \"d212b886dd4682a41f1759e6c5aef84760e5a63d4423ca7d1fb5c7ecfc5dac27\",\n+            \"5d2ad39e2a7b0bc5f375488643acf391188d01ad936971457427bc053c4262a1\" +\n+            \"598532850def8573213c5f79fa736703c57c03ec49b55617210998c8af408698\" +\n+            \"866632a7ecf7e9a688605cbca919e17e2badd090a7a6d83ad90be0617fa44642\" +\n+            \"cc9a1ca38514a026cbea51c287ec0b56719fc61183c88e9450ba85aa8ab7d390\",\n+            \"7ccdfa8e82df540276e8172f705adce2\");\n+\n+        kat(poly1305,\n+            \"2b0b684c86910104aee1d261ac4d5a0f5443b4b7746cf7f8ba03921d273f6a9b\",\n+            \"027b359f44a5d60f81073ceb74749207742529dcefa4a26a1817db2c8d50ba2b\" +\n+            \"d9e170cd1930946872d95e4eae41389f362087871a749897e0fbe42494e6f0b3\" +\n+            \"8db01e2059510b6fda4f422ce7d226433ba00940e1761baaff80d9b8f3a61d11\" +\n+            \"a109e6082d231cf85aa718199e6eaaaf07bad562469ef1b8e639c727967bf6da\" +\n+            \"bcd16fcb0fc102095325e2fac92e599e81c26900df1deb7b0a0b5c321a658024\" +\n+            \"26506740509ece646fecf33a517b66e57577372156aae85765c6b473521d1019\" +\n+            \"4f5fbe0e932cfee716e1d41c9154fb8e15b82ab7e807fb54f3d7d3e4c589cc9a\" +\n+            \"492d17ea4fd27894fa9d22a9db6d5df674cd1e97e7e8758a360291f22dfe1cc3\",\n+            \"84ca3a778faf0ab9f840fe5fb38ace27\");\n+\n+        kat(poly1305,\n+            \"870c6fa7da2eadb845ac8b0eeaed4cf856eca67bf96b64a29a2e6a881821fa8a\",\n+            \"ff1a3b67a4f575be5f05c4054e4c7365838c2cbe786ba78900c8b43f197c3c4d\" +\n+            \"120432a287e434669af579bcd56f3320e54d2f97a306f917f2f41b1c97cc69db\" +\n+            \"4ac2051adccd687fa89f92504d1ab5c3006681d846c8051aabccca0024ef5ec4\" +\n+            \"c43b8701ffc9d14fef8d55e229ed210a2b9bde996f5d7b545d15e1fc32764604\" +\n+            \"b2a0384dd173aa800b7526c8ff397c05130bb6a1f2194968adaef6979b023cd8\" +\n+            \"d9195d2739351c7e4ac6c43508634f813641f669e78cbcf732ccb1321a2cd2c4\" +\n+            \"14c7df5b9ea3408f2e12fbf3a3cbdb98699dd5402725ec25f9fff9bcd0f93cb3\" +\n+            \"cf0dac016fec41a5ef3ae8b8d258a09f530ad14ad2e52186041592eac0ea22ff\" +\n+            \"8c3751009b516c60f7764cccbb816394ef035bd8cb2a38d5c6b9229e528e56cd\" +\n+            \"62600b5219b64212642384e628f01d790eeef4963a7d1a63a9faff79d4acfa09\" +\n+            \"78b58b0b623ae89389661aa408b16814d3baaca20978dce6888c3365f4ffd2fa\" +\n+            \"8f031a44f2e870a06da21d7becf450d335e1386268bc189435e7955a477bc368\",\n+            \"ff4e0ee6feb1c6a57e638a79fafc7c60\");\n+\n+        kat(poly1305,\n+            \"c27987ae88a833ae2ea90371b2e257c15773da3bc34516b6b075446e1f844a81\",\n+            \"64e5a2e2940b173c7103ae931ced302a8f8c778f4e5c0b3677c51552655005d8\" +\n+            \"504b724107e7262448c94db83fc9c6a2a26fc973360dce15c0553b73bb733d3e\" +\n+            \"f61fcba8977e76c32523b80c3b45b1226b23ee17522f9b677880c69b356917ae\" +\n+            \"3c792a0c5b0c77b90dfa51483626323b7a73fffb1b128c595d553bf62a8f5bb9\" +\n+            \"fa48b4a850a932481bf607e8da84730c9052bba9316ec7eb84007a4eb5cbed5c\" +\n+            \"7c67ef32d4c5cb6cfbccd738d239857c240de6d3d4e5af14d480feb63541e5d8\" +\n+            \"036e088b2e32431e6fe0c4d3505aebe2e14bd02b6b15325f89aef048cd1236db\" +\n+            \"4461a59304b7c61ece2c52ef8ac4cf2326e6aaff013494b1b191be4ae4381f57\" +\n+            \"e72b947ee23d0a528087db9338bc28c68484929fc3436995b2083b06a765ceb7\" +\n+            \"09e9dd41ba896d99832d6851189766e844137d9a83d2890bc2be7afc82f9ebb8\" +\n+            \"bafe08ef5f7ff0cce9a1d08e6b797a17df04731f384a34b16e72e9f2ab070114\" +\n+            \"8008945509fe378658dc51eb752248f48364be327cd1b6bd148c518a976ae95d\" +\n+            \"d391f3b0d447251988c7e77400c9d44395b8f9f10cbc442a6804d0ad83e8c3e3\" +\n+            \"9fa09c2140fac143c90f09a7d907c57e29b528d54c8bd927f39aee2cec671213\" +\n+            \"c50fe657b29682d57a419e3e52dafb348cbe44b6c17e4be18f5c5e411734fcfc\" +\n+            \"99b9ca26f29a21cc93374ef1bfa86ca2bb3be76b94b4ef69ec790c968a51e4d0\",\n+            \"d4c09727f68fa3beb57ce9e74205b652\");\n+\n+        kat(poly1305,\n+            \"2593adf2efc0e49c7fde0d45de4f7a21ceb76df45c0e5a917ef1f6b7fbf4fb7e\",\n+            \"23665b9a6d4f04c9d58347d32d64d4cbf8d4ca993a8bb73758e6eb2db9f97096\" +\n+            \"d0f00aca8cb16460d2bc15c0136fa92482602f47b3ec78244c4dc619d9b28afa\" +\n+            \"19b063c196bcff848eff179102cce29dfcc58bf90a2f6311e6d021e2573ccbb4\" +\n+            \"4e06947167c9865127c0b7362196523f97c8157058f7aebff475f77e23393dc1\" +\n+            \"a3031bbaf31270db3eadc00cca6ae073aa53160d095afdce0a202de8a23d9a38\" +\n+            \"b0bed20cbe64e1ec77fc13ba0cfc9be52edb70475bf1aeaaff25e11f2e0ae47f\" +\n+            \"f23cbd4a6219d276fcc6c8f12a739f11434c86d4e24397f96ef6e36d9195fa8a\" +\n+            \"48eb55990d69feacfb754b5019a3ebafa98d5544077b46c136cc11de8ee7f8a6\" +\n+            \"76a6696600088696233f4e8f060ba8a64890fb638469639bfb727ed758c36250\" +\n+            \"a553b7ce1115509f2bb19c13cea87003a8eff45ce9e1cff0a21ba5ae19226d50\" +\n+            \"e108db212a588e5f4c502468859b9b607922c3311b5d912bd9400e696d7debbb\" +\n+            \"9ac5454cc7d0f95fc242c491f095a02f0d3bd7ead0f0b7358c9b1d85e4e9ab75\" +\n+            \"24bb43867c94a21a4e0db6470a210c9dd937e4801396bd687127fa7c83014c85\" +\n+            \"372553c56dfd6cd9b75fa10483aea825f8e3fa53c6bf17467e37c2e7439ed0ea\" +\n+            \"6fb24d13d428965c44f1ac943c7bc77fa84711c91b41f5ee6d9a7d9091648a96\" +\n+            \"cc7c261d7fc5d964446d1e3dcc41d32ecaa8d7791b8462563fcf7f96cd1d11d4\" +\n+            \"34923e0150321356866f5bdafebc96f2661bfd3c1f104e96b6492cafcbe25fc6\" +\n+            \"ec0c92a3bbec7328e1905d5951fae04625a2452f596027a5d9c64eed55165c8a\" +\n+            \"23bc3f944b4fa9c7ad83ebc1777c7153d5de13d04c0a12e774b17906a62f5134\" +\n+            \"685c2de31da08bd04840299fd62d56ffe95248365034e7ba95961cebf0542b24\",\n+            \"b9f68b0996caf5135136b10b37fe5f81\");\n+\n+        kat(poly1305,\n+            \"e9c8c78bc0ad5751f094fd4657fe5ef2a3c232f6930eef3431cde76659f04210\",\n+            \"914e57a2745fd475d7b8f982483fe11a05d7b55853239112d5ae99616c718b3c\" +\n+            \"4a0c2d05e3ca1df509614c0fe051b414d404149ec422e0998e192e51518518c4\" +\n+            \"b8acd9e3e3ff9f3b4ef931d3052755785d38e75821ceefa7da0bfe3f1fb2dc6d\" +\n+            \"738e2a2332e53ce77d44547621bb7aa724dd8805c7c795088db865d6b13d9b3e\" +\n+            \"8acec846efb072d105ab6e599f8292a7601087e0ba13af9f503dcfd426e26e4d\" +\n+            \"fb22bf5a1ff1a82d67d9bd8871e6adc17aa39d221f2865f81da9ed566192c269\" +\n+            \"3c85f0442924e603b9ae54b88dd0f21e92eedc40c08dd484c552e297894eeee8\" +\n+            \"b5acc91d5ae16f56257bb0836b48e1a8fa72e83a8b10b7026a7f466c8b08eac5\" +\n+            \"4359b70e639117cf688e263b891f004db94d77941380f3ab0559538c9398c859\" +\n+            \"b76d2bbcd6b635e753160583e7adc263097a80520d003514e134a21597c1ec57\" +\n+            \"55da3a70acc6951b4d4d81e98b9eb962d9e3bc37d5e8ebd61e2a3f61cc452a65\" +\n+            \"56571e12c190d4e3d0f8cc61ffcb60324b4a6987e7375a832ff807682e0b4595\" +\n+            \"66ef1f765638f3d2e837ed43ce2c1c7837f271c866908d865c3d9174fd4f8056\" +\n+            \"265abfb88fbc207db7a12c0a0ad035e5a728725e98cb682d41fd0bcf3aef2fd7\" +\n+            \"ab261727f310fc7cf3b34286c9e9ee235995315167191f3b4d77e5642fb57dbd\" +\n+            \"fdb5ccadefc5d03866918ab1a3eff54b405d8946e2b0c2fa444d1b2be4c3d41d\" +\n+            \"990515e7534190d66d10e38c36c5d3df0315db85ba10c924bef97d1faa07a5f8\" +\n+            \"f04998a7d38689237a1912bea3f821357d8383d7c5cfa66ba5965b5a94bb702c\" +\n+            \"e6583e59879021139355c5b90e0f9cd13b34f3357ffde404bbf34c97f9fd55b5\" +\n+            \"53e42d8a6b370eded02c8a5221e15db701da56918412520e12fd1ef9f4748647\" +\n+            \"858488d5e0abd5b9e01457768907e1d24581f9591771304192711292e4025fce\" +\n+            \"bd92adb2297e9496852f80bd78578bbdb292ca209f7584ff76e9eb66ec8a111e\" +\n+            \"add30dc7ef364c4f1339312f226fe0cfa7a5b1602417e469cf2c8e3874c51232\" +\n+            \"00f2d90dbe7f3c3ff5c6c6484052a80eb6229a6ed6176ad600da185da624bea6\",\n+            \"c1de44dd8ea245ca43e5587460feb514\");\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/crypto\/Poly1305Bench.java","additions":665,"deletions":0,"binary":false,"changes":665,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+import jdk.incubator.vector.*;\n+\n+import java.util.Random;\n+import java.util.function.IntFunction;\n+\n+public class AbstractVectorBenchmark {\n+    static final Random RAND = new Random(Integer.getInteger(\"jdk.incubator.vector.random-seed\", 1337));\n+\n+    static final VectorSpecies<Byte> B64  = ByteVector.SPECIES_64;\n+    static final VectorSpecies<Byte> B128 = ByteVector.SPECIES_128;\n+    static final VectorSpecies<Byte> B256 = ByteVector.SPECIES_256;\n+    static final VectorSpecies<Byte> B512 = ByteVector.SPECIES_512;\n+\n+    static final VectorSpecies<Short> S64  = ShortVector.SPECIES_64;\n+    static final VectorSpecies<Short> S128 = ShortVector.SPECIES_128;\n+    static final VectorSpecies<Short> S256 = ShortVector.SPECIES_256;\n+    static final VectorSpecies<Short> S512 = ShortVector.SPECIES_512;\n+\n+    static final VectorSpecies<Integer> I64  = IntVector.SPECIES_64;\n+    static final VectorSpecies<Integer> I128 = IntVector.SPECIES_128;\n+    static final VectorSpecies<Integer> I256 = IntVector.SPECIES_256;\n+    static final VectorSpecies<Integer> I512 = IntVector.SPECIES_512;\n+\n+    static final VectorSpecies<Long> L64  = LongVector.SPECIES_64;\n+    static final VectorSpecies<Long> L128 = LongVector.SPECIES_128;\n+    static final VectorSpecies<Long> L256 = LongVector.SPECIES_256;\n+    static final VectorSpecies<Long> L512 = LongVector.SPECIES_512;\n+\n+    static VectorShape widen(VectorShape s) {\n+        switch (s) {\n+            case S_64_BIT:  return VectorShape.S_128_BIT;\n+            case S_128_BIT: return VectorShape.S_256_BIT;\n+            case S_256_BIT: return VectorShape.S_512_BIT;\n+            default: throw new IllegalArgumentException(\"\" + s);\n+        }\n+    }\n+\n+    static VectorShape narrow(VectorShape s) {\n+        switch (s) {\n+            case S_512_BIT: return VectorShape.S_256_BIT;\n+            case S_256_BIT: return VectorShape.S_128_BIT;\n+            case S_128_BIT: return VectorShape.S_64_BIT;\n+            default: throw new IllegalArgumentException(\"\" + s);\n+        }\n+    }\n+\n+    static <E> VectorSpecies<E> widen(VectorSpecies<E> s) {\n+        return VectorSpecies.of(s.elementType(), widen(s.vectorShape()));\n+    }\n+\n+    static <E> VectorSpecies<E> narrow(VectorSpecies<E> s) {\n+        return VectorSpecies.of(s.elementType(), narrow(s.vectorShape()));\n+    }\n+\n+    static IntVector join(VectorSpecies<Integer> from, VectorSpecies<Integer> to, IntVector lo, IntVector hi) {\n+        assert 2 * from.length() == to.length();\n+\n+        int vlen = from.length();\n+        var lo_mask = mask(from, to, 0);\n+\n+        var v1 = lo.reinterpretShape(to, 0);\n+        var v2 = hi.reinterpretShape(to, 0).unslice(vlen);\n+        var r = v2.blend(v1, lo_mask);\n+        return (IntVector)r;\n+    }\n+\n+    static VectorMask<Integer> mask(VectorSpecies<Integer> from, VectorSpecies<Integer> to, int i) {\n+        int vlen = from.length();\n+        var v1 = IntVector.broadcast(from, 1);                   \/\/                         [1 1 ... 1]\n+        var v2 = v1.reinterpretShape(to, 0);                     \/\/ [0 0 ... 0 |   ...     | 1 1 ... 1]\n+        var v3 = v2.unslice(i * vlen);                           \/\/ [0 0 ... 0 | 1 1 ... 1 | 0 0 ... 0]\n+        return v3.compare(VectorOperators.NE, to.broadcast(0));  \/\/ [F F ... F | T T ... T | F F ... F]\n+    }\n+\n+    static <E> IntVector sum(ByteVector va) {\n+        VectorSpecies<Integer> species = VectorSpecies.of(Integer.class, va.shape());\n+        var acc = IntVector.zero(species);\n+        int limit = va.length() \/ species.length();\n+        for (int k = 0; k < limit; k++) {\n+            var vb = ((IntVector)(va.slice(k * B64.length()).reinterpretShape(B64, 0).castShape(species, 0))).and(0xFF);\n+            acc = acc.add(vb);\n+        }\n+        return acc;\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    boolean[] fillMask(int size, IntFunction<Boolean> f) {\n+        boolean[] array = new boolean[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    byte[] fillByte(int size, IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < size; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    int[] fillInt(int size, IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    long[] fillLong(int size, IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/AbstractVectorBenchmark.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,2435 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ByteVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Byte128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(byte[] a, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(byte[] a, boolean[] mask, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static byte firstNonZero(byte a, byte b) {\n+        return Byte.compare(a, (byte) 0) != 0 ? a : b;\n+    }\n+\n+    private static final byte CONST_SHIFT = Byte.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    byte[] fill(IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    byte[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (byte)(2*i));\n+        b = fill(i -> (byte)(i+1));\n+        c = fill(i -> (byte)(i+5));\n+        r = fill(i -> (byte)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<byte[]> fa = vl -> a;\n+    final IntFunction<byte[]> fb = vl -> b;\n+    final IntFunction<byte[]> fc = vl -> c;\n+    final IntFunction<byte[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = (byte) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (byte) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = (byte) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (byte) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        byte[] a = fa.apply(size);\n+        byte[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        byte[] a = fa.apply(size);\n+        byte[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte128Vector.java","additions":2435,"deletions":0,"binary":false,"changes":2435,"status":"added"},{"patch":"@@ -0,0 +1,2435 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ByteVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Byte256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(byte[] a, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(byte[] a, boolean[] mask, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static byte firstNonZero(byte a, byte b) {\n+        return Byte.compare(a, (byte) 0) != 0 ? a : b;\n+    }\n+\n+    private static final byte CONST_SHIFT = Byte.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    byte[] fill(IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    byte[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (byte)(2*i));\n+        b = fill(i -> (byte)(i+1));\n+        c = fill(i -> (byte)(i+5));\n+        r = fill(i -> (byte)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<byte[]> fa = vl -> a;\n+    final IntFunction<byte[]> fb = vl -> b;\n+    final IntFunction<byte[]> fc = vl -> c;\n+    final IntFunction<byte[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = (byte) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (byte) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = (byte) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (byte) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        byte[] a = fa.apply(size);\n+        byte[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        byte[] a = fa.apply(size);\n+        byte[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte256Vector.java","additions":2435,"deletions":0,"binary":false,"changes":2435,"status":"added"},{"patch":"@@ -0,0 +1,2435 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ByteVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Byte512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(byte[] a, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(byte[] a, boolean[] mask, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static byte firstNonZero(byte a, byte b) {\n+        return Byte.compare(a, (byte) 0) != 0 ? a : b;\n+    }\n+\n+    private static final byte CONST_SHIFT = Byte.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    byte[] fill(IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    byte[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (byte)(2*i));\n+        b = fill(i -> (byte)(i+1));\n+        c = fill(i -> (byte)(i+5));\n+        r = fill(i -> (byte)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<byte[]> fa = vl -> a;\n+    final IntFunction<byte[]> fb = vl -> b;\n+    final IntFunction<byte[]> fc = vl -> c;\n+    final IntFunction<byte[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = (byte) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (byte) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = (byte) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (byte) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        byte[] a = fa.apply(size);\n+        byte[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        byte[] a = fa.apply(size);\n+        byte[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte512Vector.java","additions":2435,"deletions":0,"binary":false,"changes":2435,"status":"added"},{"patch":"@@ -0,0 +1,2435 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ByteVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Byte64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(byte[] a, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(byte[] a, boolean[] mask, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static byte firstNonZero(byte a, byte b) {\n+        return Byte.compare(a, (byte) 0) != 0 ? a : b;\n+    }\n+\n+    private static final byte CONST_SHIFT = Byte.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    byte[] fill(IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    byte[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (byte)(2*i));\n+        b = fill(i -> (byte)(i+1));\n+        c = fill(i -> (byte)(i+5));\n+        r = fill(i -> (byte)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<byte[]> fa = vl -> a;\n+    final IntFunction<byte[]> fb = vl -> b;\n+    final IntFunction<byte[]> fc = vl -> c;\n+    final IntFunction<byte[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = (byte) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (byte) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = (byte) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (byte) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        byte[] a = fa.apply(size);\n+        byte[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        byte[] a = fa.apply(size);\n+        byte[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Byte64Vector.java","additions":2435,"deletions":0,"binary":false,"changes":2435,"status":"added"},{"patch":"@@ -0,0 +1,2435 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ByteVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class ByteMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Byte> SPECIES = ByteVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(byte[] a, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(byte[] a, boolean[] mask, byte v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static byte firstNonZero(byte a, byte b) {\n+        return Byte.compare(a, (byte) 0) != 0 ? a : b;\n+    }\n+\n+    private static final byte CONST_SHIFT = Byte.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    byte[] fill(IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    byte[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (byte)(2*i));\n+        b = fill(i -> (byte)(i+1));\n+        c = fill(i -> (byte)(i+5));\n+        r = fill(i -> (byte)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<byte[]> fa = vl -> a;\n+    final IntFunction<byte[]> fb = vl -> b;\n+    final IntFunction<byte[]> fc = vl -> c;\n+    final IntFunction<byte[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (byte) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUB(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUBMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = Byte.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Byte.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = (byte) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte ra = (byte) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (byte) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte ra = (byte) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (byte) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        byte[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGT() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGE() {\n+        byte[] a = fa.apply(size);\n+        byte[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        byte[] a = fa.apply(size);\n+        byte[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        byte[] a = fa.apply(size);\n+        byte[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Byte> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        byte[] r = new byte[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] b = fb.apply(SPECIES.length());\n+        byte[] c = fc.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                ByteVector bv = ByteVector.fromArray(SPECIES, b, i);\n+                ByteVector cv = ByteVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        byte[] a = fa.apply(SPECIES.length());\n+        byte[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Byte> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ByteVector av = ByteVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteMaxVector.java","additions":2435,"deletions":0,"binary":false,"changes":2435,"status":"added"},{"patch":"@@ -0,0 +1,1944 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+import jdk.incubator.vector.VectorMath;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class ByteScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+    private static final byte CONST_SHIFT = Byte.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    byte[] fill(IntFunction<Byte> f) {\n+        byte[] array = new byte[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static byte bits(byte e) {\n+        return e;\n+    }\n+\n+    byte[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> (byte)(2*i));\n+        bs = fill(i -> (byte)(i+1));\n+        cs = fill(i -> (byte)(i+5));\n+        rs = fill(i -> (byte)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RAND.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<byte[]> fa = vl -> as;\n+    final IntFunction<byte[]> fb = vl -> bs;\n+    final IntFunction<byte[]> fc = vl -> cs;\n+    final IntFunction<byte[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(byte a, byte b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(byte a, byte b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(byte a, byte b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(byte a, byte b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(byte a, byte b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(byte a, byte b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(byte a, byte b) {\n+        return Byte.compareUnsigned(a, b) >= 0;\n+    }\n+\n+    static byte ROL_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) << (b & 7)) | ((((byte)a) & 0xFF) >>> (8 - (b & 7))));\n+    }\n+\n+    static byte ROR_scalar(byte a, byte b) {\n+        return (byte)(((((byte)a) & 0xFF) >>> (b & 7)) | ((((byte)a) & 0xFF) << (8 - (b & 7))));\n+    }\n+\n+    static byte TRAILING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a != 0 ? Integer.numberOfTrailingZeros(a) : 8);\n+    }\n+\n+    static byte LEADING_ZEROS_COUNT_scalar(byte a) {\n+        return (byte) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 24 : 0);\n+    }\n+\n+    static byte REVERSE_scalar(byte a) {\n+        byte b = ROL_scalar(a, (byte) 4);\n+        b = (byte)(((b & 0x55) << 1) | ((b & 0xAA) >>> 1));\n+        b = (byte)(((b & 0x33) << 2) | ((b & 0xCC) >>> 2));\n+        return b;\n+    }\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a + b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a + b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a - b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a - b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a * b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a * b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)((a)!=0?a:b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)((a)!=0?a:b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a & b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a & b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a & ~b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a & ~b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a | b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a | b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(a ^ b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(a ^ b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)((a << (b & 0x7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)((a << (b & 0x7)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)((a >> (b & 0x7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)((a >> (b & 0x7)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(((a & 0xFF) >>> (b & 0x7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(((a & 0xFF) >>> (b & 0x7)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)((a << (b & 7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)((a << (b & 7))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(((a & 0xFF) >>> (b & 7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(((a & 0xFF) >>> (b & 7))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)((a >> (b & 7)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)((a >> (b & 7))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(ROR_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(ROR_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(ROL_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(ROL_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(ROR_scalar(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(ROR_scalar(a, b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(ROL_scalar(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(ROL_scalar(a, b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(((a & 0xFF) >>> CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(((a & 0xFF) >>> CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)((a << CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)((a << CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)((a >> CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)((a >> CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(ROR_scalar(a, CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(ROR_scalar(a, CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(ROL_scalar(a, CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(ROL_scalar(a, CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(Math.min(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(Math.max(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(VectorMath.minUnsigned(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(VectorMath.minUnsigned(a, b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                rs[i] = (byte)(VectorMath.maxUnsigned(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)(VectorMath.maxUnsigned(a, b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        byte r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        byte r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        byte r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        byte r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        byte r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = false;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = false;\n+            for (int i = 0; i < ms.length; i++) {\n+                r |= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = true;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = true;\n+            for (int i = 0; i < ms.length; i++) {\n+                r &= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_DEFAULT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                r &= (bits(a)==0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NEGATIVE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                r &= (bits(a)<0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EQ(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ULT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ult(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UGT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ugt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ULE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ule(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UGE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= uge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    void rearrangeShared(int window, Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    byte a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ Byte.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ Byte.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ Byte.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ Byte.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void compressScalar(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = new byte[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[j++] = as[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void expandScalar(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = new byte[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[i++] = as[j++];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void maskCompressScalar(Blackhole bh) {\n+        boolean[] im = fmt.apply(size);\n+        boolean[] rm = new boolean[size];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < im.length; i++) {\n+                if (im[i]) {\n+                    rm[j++] = im[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rm);\n+    }\n+\n+    void broadcastShared(int window, Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ Byte.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ Byte.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ Byte.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ Byte.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = (byte)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] cs = fc.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                byte c = cs[i];\n+                rs[i] = (byte)((a&~(c))|(b&c));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] bs = fb.apply(size);\n+        byte[] cs = fc.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                byte b = bs[i];\n+                byte c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (byte)((a&~(c))|(b&c));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)(-((byte)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(-((byte)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)(Math.abs((byte)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(Math.abs((byte)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)(~((byte)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(~((byte)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)((a==0?0:-1));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)((a==0?0:-1)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)(Integer.bitCount((int)a & 0xFF));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(Integer.bitCount((int)a & 0xFF)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)(TRAILING_ZEROS_COUNT_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(TRAILING_ZEROS_COUNT_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)(LEADING_ZEROS_COUNT_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(LEADING_ZEROS_COUNT_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)(REVERSE_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(REVERSE_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                rs[i] = (byte)(a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        byte[] as = fa.apply(size);\n+        byte[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                byte a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (byte)(a) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ByteScalar.java","additions":1944,"deletions":0,"binary":false,"changes":1944,"status":"added"},{"patch":"@@ -0,0 +1,1481 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.DoubleVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Double128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Double> SPECIES = DoubleVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static double firstNonZero(double a, double b) {\n+        return Double.compare(a, (double) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    double[] fill(IntFunction<Double> f) {\n+        double[] array = new double[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    double[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (double)(2*i));\n+        b = fill(i -> (double)(i+1));\n+        c = fill(i -> (double)(i+5));\n+        r = fill(i -> (double)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<double[]> fa = vl -> a;\n+    final IntFunction<double[]> fb = vl -> b;\n+    final IntFunction<double[]> fc = vl -> c;\n+    final IntFunction<double[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = (double) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (double) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = (double) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (double) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        double[] a = fa.apply(size);\n+        double[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        double[] a = fa.apply(size);\n+        double[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double128Vector.java","additions":1481,"deletions":0,"binary":false,"changes":1481,"status":"added"},{"patch":"@@ -0,0 +1,1481 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.DoubleVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Double256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Double> SPECIES = DoubleVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static double firstNonZero(double a, double b) {\n+        return Double.compare(a, (double) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    double[] fill(IntFunction<Double> f) {\n+        double[] array = new double[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    double[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (double)(2*i));\n+        b = fill(i -> (double)(i+1));\n+        c = fill(i -> (double)(i+5));\n+        r = fill(i -> (double)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<double[]> fa = vl -> a;\n+    final IntFunction<double[]> fb = vl -> b;\n+    final IntFunction<double[]> fc = vl -> c;\n+    final IntFunction<double[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = (double) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (double) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = (double) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (double) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        double[] a = fa.apply(size);\n+        double[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        double[] a = fa.apply(size);\n+        double[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double256Vector.java","additions":1481,"deletions":0,"binary":false,"changes":1481,"status":"added"},{"patch":"@@ -0,0 +1,1481 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.DoubleVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Double512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Double> SPECIES = DoubleVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static double firstNonZero(double a, double b) {\n+        return Double.compare(a, (double) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    double[] fill(IntFunction<Double> f) {\n+        double[] array = new double[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    double[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (double)(2*i));\n+        b = fill(i -> (double)(i+1));\n+        c = fill(i -> (double)(i+5));\n+        r = fill(i -> (double)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<double[]> fa = vl -> a;\n+    final IntFunction<double[]> fb = vl -> b;\n+    final IntFunction<double[]> fc = vl -> c;\n+    final IntFunction<double[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = (double) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (double) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = (double) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (double) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        double[] a = fa.apply(size);\n+        double[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        double[] a = fa.apply(size);\n+        double[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double512Vector.java","additions":1481,"deletions":0,"binary":false,"changes":1481,"status":"added"},{"patch":"@@ -0,0 +1,1481 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.DoubleVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Double64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Double> SPECIES = DoubleVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static double firstNonZero(double a, double b) {\n+        return Double.compare(a, (double) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    double[] fill(IntFunction<Double> f) {\n+        double[] array = new double[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    double[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (double)(2*i));\n+        b = fill(i -> (double)(i+1));\n+        c = fill(i -> (double)(i+5));\n+        r = fill(i -> (double)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<double[]> fa = vl -> a;\n+    final IntFunction<double[]> fb = vl -> b;\n+    final IntFunction<double[]> fc = vl -> c;\n+    final IntFunction<double[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = (double) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (double) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = (double) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (double) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        double[] a = fa.apply(size);\n+        double[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        double[] a = fa.apply(size);\n+        double[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Double64Vector.java","additions":1481,"deletions":0,"binary":false,"changes":1481,"status":"added"},{"patch":"@@ -0,0 +1,1481 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.DoubleVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class DoubleMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Double> SPECIES = DoubleVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static double firstNonZero(double a, double b) {\n+        return Double.compare(a, (double) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    double[] fill(IntFunction<Double> f) {\n+        double[] array = new double[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    double[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (double)(2*i));\n+        b = fill(i -> (double)(i+1));\n+        c = fill(i -> (double)(i+5));\n+        r = fill(i -> (double)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<double[]> fa = vl -> a;\n+    final IntFunction<double[]> fb = vl -> b;\n+    final IntFunction<double[]> fc = vl -> c;\n+    final IntFunction<double[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = Double.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Double.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = (double) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double ra = (double) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (double) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double ra = (double) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (double) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        double[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        double[] a = fa.apply(size);\n+        double[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        double[] a = fa.apply(size);\n+        double[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        double[] a = fa.apply(size);\n+        double[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Double> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        double[] r = new double[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] b = fb.apply(SPECIES.length());\n+        double[] c = fc.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                DoubleVector bv = DoubleVector.fromArray(SPECIES, b, i);\n+                DoubleVector cv = DoubleVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        double[] a = fa.apply(SPECIES.length());\n+        double[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Double> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                DoubleVector av = DoubleVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleMaxVector.java","additions":1481,"deletions":0,"binary":false,"changes":1481,"status":"added"},{"patch":"@@ -0,0 +1,1131 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+import jdk.incubator.vector.VectorMath;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class DoubleScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    double[] fill(IntFunction<Double> f) {\n+        double[] array = new double[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static long bits(double e) {\n+        return Double.doubleToLongBits(e);\n+    }\n+\n+    double[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> (double)(2*i));\n+        bs = fill(i -> (double)(i+1));\n+        cs = fill(i -> (double)(i+5));\n+        rs = fill(i -> (double)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RAND.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<double[]> fa = vl -> as;\n+    final IntFunction<double[]> fb = vl -> bs;\n+    final IntFunction<double[]> fc = vl -> cs;\n+    final IntFunction<double[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(double a, double b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(double a, double b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(double a, double b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(double a, double b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(double a, double b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(double a, double b) {\n+        return a >= b;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(a + b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (double)(a + b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(a - b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (double)(a - b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(a * b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (double)(a * b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(a \/ b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (double)(a \/ b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(Double.doubleToLongBits(a)!=0?a:b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (double)(Double.doubleToLongBits(a)!=0?a:b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(Math.min(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(Math.max(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        double r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        double r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_DEFAULT(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                r &= (bits(a)==0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NEGATIVE(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                r &= (bits(a)<0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_FINITE(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                r &= (Double.isFinite(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NAN(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                r &= (Double.isNaN(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_INFINITE(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                r &= (Double.isInfinite(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LT(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GT(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EQ(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NE(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LE(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GE(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    void rearrangeShared(int window, Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    double a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ Double.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ Double.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ Double.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ Double.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void compressScalar(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = new double[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[j++] = as[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void expandScalar(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = new double[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[i++] = as[j++];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void maskCompressScalar(Blackhole bh) {\n+        boolean[] im = fmt.apply(size);\n+        boolean[] rm = new boolean[size];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < im.length; i++) {\n+                if (im[i]) {\n+                    rm[j++] = im[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rm);\n+    }\n+\n+    void broadcastShared(int window, Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ Double.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ Double.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ Double.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ Double.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = (double)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.sin((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.exp((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.log1p((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.log((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.log10((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.expm1((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.cos((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.tan((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.sinh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.cosh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.tanh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.asin((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.acos((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.atan((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.cbrt((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(Math.hypot((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(Math.pow((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                rs[i] = (double)(Math.atan2((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] cs = fc.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                double c = cs[i];\n+                rs[i] = (double)(Math.fma(a, b, c));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] bs = fb.apply(size);\n+        double[] cs = fc.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                double b = bs[i];\n+                double c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (double)(Math.fma(a, b, c));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(-((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (double)(-((double)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.abs((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (double)(Math.abs((double)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                rs[i] = (double)(Math.sqrt((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        double[] as = fa.apply(size);\n+        double[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                double a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (double)(Math.sqrt((double)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/DoubleScalar.java","additions":1131,"deletions":0,"binary":false,"changes":1131,"status":"added"},{"patch":"@@ -0,0 +1,1481 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.FloatVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Float128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static float firstNonZero(float a, float b) {\n+        return Float.compare(a, (float) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    float[] fill(IntFunction<Float> f) {\n+        float[] array = new float[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    float[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (float)(2*i));\n+        b = fill(i -> (float)(i+1));\n+        c = fill(i -> (float)(i+5));\n+        r = fill(i -> (float)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<float[]> fa = vl -> a;\n+    final IntFunction<float[]> fb = vl -> b;\n+    final IntFunction<float[]> fc = vl -> c;\n+    final IntFunction<float[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = (float) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (float) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = (float) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (float) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        float[] a = fa.apply(size);\n+        float[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        float[] a = fa.apply(size);\n+        float[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float128Vector.java","additions":1481,"deletions":0,"binary":false,"changes":1481,"status":"added"},{"patch":"@@ -0,0 +1,1481 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.FloatVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Float256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static float firstNonZero(float a, float b) {\n+        return Float.compare(a, (float) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    float[] fill(IntFunction<Float> f) {\n+        float[] array = new float[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    float[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (float)(2*i));\n+        b = fill(i -> (float)(i+1));\n+        c = fill(i -> (float)(i+5));\n+        r = fill(i -> (float)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<float[]> fa = vl -> a;\n+    final IntFunction<float[]> fb = vl -> b;\n+    final IntFunction<float[]> fc = vl -> c;\n+    final IntFunction<float[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = (float) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (float) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = (float) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (float) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        float[] a = fa.apply(size);\n+        float[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        float[] a = fa.apply(size);\n+        float[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float256Vector.java","additions":1481,"deletions":0,"binary":false,"changes":1481,"status":"added"},{"patch":"@@ -0,0 +1,1481 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.FloatVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Float512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static float firstNonZero(float a, float b) {\n+        return Float.compare(a, (float) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    float[] fill(IntFunction<Float> f) {\n+        float[] array = new float[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    float[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (float)(2*i));\n+        b = fill(i -> (float)(i+1));\n+        c = fill(i -> (float)(i+5));\n+        r = fill(i -> (float)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<float[]> fa = vl -> a;\n+    final IntFunction<float[]> fb = vl -> b;\n+    final IntFunction<float[]> fc = vl -> c;\n+    final IntFunction<float[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = (float) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (float) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = (float) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (float) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        float[] a = fa.apply(size);\n+        float[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        float[] a = fa.apply(size);\n+        float[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float512Vector.java","additions":1481,"deletions":0,"binary":false,"changes":1481,"status":"added"},{"patch":"@@ -0,0 +1,1481 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.FloatVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Float64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static float firstNonZero(float a, float b) {\n+        return Float.compare(a, (float) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    float[] fill(IntFunction<Float> f) {\n+        float[] array = new float[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    float[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (float)(2*i));\n+        b = fill(i -> (float)(i+1));\n+        c = fill(i -> (float)(i+5));\n+        r = fill(i -> (float)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<float[]> fa = vl -> a;\n+    final IntFunction<float[]> fb = vl -> b;\n+    final IntFunction<float[]> fc = vl -> c;\n+    final IntFunction<float[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = (float) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (float) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = (float) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (float) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        float[] a = fa.apply(size);\n+        float[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        float[] a = fa.apply(size);\n+        float[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Float64Vector.java","additions":1481,"deletions":0,"binary":false,"changes":1481,"status":"added"},{"patch":"@@ -0,0 +1,1481 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.FloatVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class FloatMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Float> SPECIES = FloatVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+\n+    static float firstNonZero(float a, float b) {\n+        return Float.compare(a, (float) 0) != 0 ? a : b;\n+    }\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    float[] fill(IntFunction<Float> f) {\n+        float[] array = new float[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    float[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (float)(2*i));\n+        b = fill(i -> (float)(i+1));\n+        c = fill(i -> (float)(i+5));\n+        r = fill(i -> (float)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<float[]> fa = vl -> a;\n+    final IntFunction<float[]> fb = vl -> b;\n+    final IntFunction<float[]> fc = vl -> c;\n+    final IntFunction<float[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.POSITIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.POSITIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = Float.NEGATIVE_INFINITY;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Float.NEGATIVE_INFINITY;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = (float) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float ra = (float) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (float) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float ra = (float) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (float) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_FINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_FINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NAN() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NAN));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_INFINITE() {\n+        float[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_INFINITE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        float[] a = fa.apply(size);\n+        float[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        float[] a = fa.apply(size);\n+        float[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        float[] a = fa.apply(size);\n+        float[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Float> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        float[] r = new float[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXP).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG1P).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LOG10).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.EXPM1).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SINH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.COSH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TANH).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASIN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ACOS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ATAN).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.CBRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.HYPOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.POW, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ATAN2, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] b = fb.apply(SPECIES.length());\n+        float[] c = fc.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                FloatVector bv = FloatVector.fromArray(SPECIES, b, i);\n+                FloatVector cv = FloatVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.FMA, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        float[] a = fa.apply(SPECIES.length());\n+        float[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Float> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                FloatVector av = FloatVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.SQRT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatMaxVector.java","additions":1481,"deletions":0,"binary":false,"changes":1481,"status":"added"},{"patch":"@@ -0,0 +1,1131 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+import jdk.incubator.vector.VectorMath;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class FloatScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    float[] fill(IntFunction<Float> f) {\n+        float[] array = new float[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static int bits(float e) {\n+        return Float.floatToIntBits(e);\n+    }\n+\n+    float[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> (float)(2*i));\n+        bs = fill(i -> (float)(i+1));\n+        cs = fill(i -> (float)(i+5));\n+        rs = fill(i -> (float)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RAND.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<float[]> fa = vl -> as;\n+    final IntFunction<float[]> fb = vl -> bs;\n+    final IntFunction<float[]> fc = vl -> cs;\n+    final IntFunction<float[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(float a, float b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(float a, float b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(float a, float b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(float a, float b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(float a, float b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(float a, float b) {\n+        return a >= b;\n+    }\n+\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(a + b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (float)(a + b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(a - b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (float)(a - b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(a * b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (float)(a * b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(a \/ b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (float)(a \/ b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(Double.doubleToLongBits(a)!=0?a:b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (float)(Double.doubleToLongBits(a)!=0?a:b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(Math.min(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(Math.max(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        float r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        float r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_DEFAULT(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                r &= (bits(a)==0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NEGATIVE(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                r &= (bits(a)<0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_FINITE(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                r &= (Float.isFinite(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NAN(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                r &= (Float.isNaN(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_INFINITE(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                r &= (Float.isInfinite(a)); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LT(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GT(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EQ(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NE(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LE(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GE(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    void rearrangeShared(int window, Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    float a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ Float.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ Float.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ Float.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ Float.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void compressScalar(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = new float[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[j++] = as[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void expandScalar(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = new float[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[i++] = as[j++];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void maskCompressScalar(Blackhole bh) {\n+        boolean[] im = fmt.apply(size);\n+        boolean[] rm = new boolean[size];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < im.length; i++) {\n+                if (im[i]) {\n+                    rm[j++] = im[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rm);\n+    }\n+\n+    void broadcastShared(int window, Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ Float.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ Float.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ Float.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ Float.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = (float)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n+\n+    @Benchmark\n+    public void SIN(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.sin((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void EXP(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.exp((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LOG1P(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.log1p((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LOG(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.log((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LOG10(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.log10((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void EXPM1(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.expm1((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void COS(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.cos((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void TAN(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.tan((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SINH(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.sinh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void COSH(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.cosh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void TANH(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.tanh((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASIN(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.asin((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ACOS(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.acos((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ATAN(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.atan((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void CBRT(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.cbrt((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void HYPOT(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(Math.hypot((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void POW(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(Math.pow((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ATAN2(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                rs[i] = (float)(Math.atan2((double)a, (double)b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FMA(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] cs = fc.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                float c = cs[i];\n+                rs[i] = (float)(Math.fma(a, b, c));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FMAMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] bs = fb.apply(size);\n+        float[] cs = fc.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                float b = bs[i];\n+                float c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (float)(Math.fma(a, b, c));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(-((float)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (float)(-((float)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.abs((float)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (float)(Math.abs((float)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void SQRT(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                rs[i] = (float)(Math.sqrt((double)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SQRTMasked(Blackhole bh) {\n+        float[] as = fa.apply(size);\n+        float[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                float a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (float)(Math.sqrt((double)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/FloatScalar.java","additions":1131,"deletions":0,"binary":false,"changes":1131,"status":"added"},{"patch":"@@ -0,0 +1,2507 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.IntVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Int128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Integer> SPECIES = IntVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(int[] a, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(int[] a, boolean[] mask, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static int firstNonZero(int a, int b) {\n+        return Integer.compare(a, (int) 0) != 0 ? a : b;\n+    }\n+\n+    private static final int CONST_SHIFT = Integer.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    int[] fill(IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    int[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (int)(2*i));\n+        b = fill(i -> (int)(i+1));\n+        c = fill(i -> (int)(i+5));\n+        r = fill(i -> (int)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<int[]> fa = vl -> a;\n+    final IntFunction<int[]> fb = vl -> b;\n+    final IntFunction<int[]> fc = vl -> c;\n+    final IntFunction<int[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = (int) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (int) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = (int) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (int) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        int[] a = fa.apply(size);\n+        int[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        int[] a = fa.apply(size);\n+        int[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int128Vector.java","additions":2507,"deletions":0,"binary":false,"changes":2507,"status":"added"},{"patch":"@@ -0,0 +1,2507 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.IntVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Int256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Integer> SPECIES = IntVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(int[] a, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(int[] a, boolean[] mask, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static int firstNonZero(int a, int b) {\n+        return Integer.compare(a, (int) 0) != 0 ? a : b;\n+    }\n+\n+    private static final int CONST_SHIFT = Integer.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    int[] fill(IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    int[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (int)(2*i));\n+        b = fill(i -> (int)(i+1));\n+        c = fill(i -> (int)(i+5));\n+        r = fill(i -> (int)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<int[]> fa = vl -> a;\n+    final IntFunction<int[]> fb = vl -> b;\n+    final IntFunction<int[]> fc = vl -> c;\n+    final IntFunction<int[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = (int) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (int) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = (int) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (int) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        int[] a = fa.apply(size);\n+        int[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        int[] a = fa.apply(size);\n+        int[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int256Vector.java","additions":2507,"deletions":0,"binary":false,"changes":2507,"status":"added"},{"patch":"@@ -0,0 +1,2507 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.IntVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Int512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Integer> SPECIES = IntVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(int[] a, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(int[] a, boolean[] mask, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static int firstNonZero(int a, int b) {\n+        return Integer.compare(a, (int) 0) != 0 ? a : b;\n+    }\n+\n+    private static final int CONST_SHIFT = Integer.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    int[] fill(IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    int[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (int)(2*i));\n+        b = fill(i -> (int)(i+1));\n+        c = fill(i -> (int)(i+5));\n+        r = fill(i -> (int)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<int[]> fa = vl -> a;\n+    final IntFunction<int[]> fb = vl -> b;\n+    final IntFunction<int[]> fc = vl -> c;\n+    final IntFunction<int[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = (int) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (int) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = (int) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (int) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        int[] a = fa.apply(size);\n+        int[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        int[] a = fa.apply(size);\n+        int[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int512Vector.java","additions":2507,"deletions":0,"binary":false,"changes":2507,"status":"added"},{"patch":"@@ -0,0 +1,2507 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.IntVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Int64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Integer> SPECIES = IntVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(int[] a, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(int[] a, boolean[] mask, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static int firstNonZero(int a, int b) {\n+        return Integer.compare(a, (int) 0) != 0 ? a : b;\n+    }\n+\n+    private static final int CONST_SHIFT = Integer.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    int[] fill(IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    int[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (int)(2*i));\n+        b = fill(i -> (int)(i+1));\n+        c = fill(i -> (int)(i+5));\n+        r = fill(i -> (int)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<int[]> fa = vl -> a;\n+    final IntFunction<int[]> fb = vl -> b;\n+    final IntFunction<int[]> fc = vl -> c;\n+    final IntFunction<int[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = (int) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (int) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = (int) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (int) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        int[] a = fa.apply(size);\n+        int[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        int[] a = fa.apply(size);\n+        int[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Int64Vector.java","additions":2507,"deletions":0,"binary":false,"changes":2507,"status":"added"},{"patch":"@@ -0,0 +1,2507 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.IntVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class IntMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Integer> SPECIES = IntVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(int[] a, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(int[] a, boolean[] mask, int v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static int firstNonZero(int a, int b) {\n+        return Integer.compare(a, (int) 0) != 0 ? a : b;\n+    }\n+\n+    private static final int CONST_SHIFT = Integer.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    int[] fill(IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    int[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (int)(2*i));\n+        b = fill(i -> (int)(i+1));\n+        c = fill(i -> (int)(i+5));\n+        r = fill(i -> (int)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<int[]> fa = vl -> a;\n+    final IntFunction<int[]> fb = vl -> b;\n+    final IntFunction<int[]> fc = vl -> c;\n+    final IntFunction<int[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (int) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUB(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUBMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = Integer.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Integer.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = (int) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int ra = (int) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (int) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int ra = (int) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (int) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        int[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGT() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGE() {\n+        int[] a = fa.apply(size);\n+        int[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        int[] a = fa.apply(size);\n+        int[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        int[] a = fa.apply(size);\n+        int[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Integer> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        int[] r = new int[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] b = fb.apply(SPECIES.length());\n+        int[] c = fc.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                IntVector bv = IntVector.fromArray(SPECIES, b, i);\n+                IntVector cv = IntVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        int[] a = fa.apply(SPECIES.length());\n+        int[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Integer> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                IntVector av = IntVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntMaxVector.java","additions":2507,"deletions":0,"binary":false,"changes":2507,"status":"added"},{"patch":"@@ -0,0 +1,2017 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+import jdk.incubator.vector.VectorMath;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class IntScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+    private static final int CONST_SHIFT = Integer.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    int[] fill(IntFunction<Integer> f) {\n+        int[] array = new int[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static int bits(int e) {\n+        return e;\n+    }\n+\n+    int[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> (int)(2*i));\n+        bs = fill(i -> (int)(i+1));\n+        cs = fill(i -> (int)(i+5));\n+        rs = fill(i -> (int)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RAND.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<int[]> fa = vl -> as;\n+    final IntFunction<int[]> fb = vl -> bs;\n+    final IntFunction<int[]> fc = vl -> cs;\n+    final IntFunction<int[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(int a, int b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(int a, int b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(int a, int b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(int a, int b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(int a, int b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(int a, int b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(int a, int b) {\n+        return Integer.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(int a, int b) {\n+        return Integer.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(int a, int b) {\n+        return Integer.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(int a, int b) {\n+        return Integer.compareUnsigned(a, b) >= 0;\n+    }\n+\n+    static int ROL_scalar(int a, int b) {\n+        return Integer.rotateLeft(a, ((int)b));\n+    }\n+\n+    static int ROR_scalar(int a, int b) {\n+        return Integer.rotateRight(a, ((int)b));\n+    }\n+\n+    static int TRAILING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfTrailingZeros(a);\n+    }\n+\n+    static int LEADING_ZEROS_COUNT_scalar(int a) {\n+        return Integer.numberOfLeadingZeros(a);\n+    }\n+\n+    static int REVERSE_scalar(int a) {\n+        return Integer.reverse(a);\n+    }\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a + b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a + b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a - b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a - b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a * b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a * b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a)!=0?a:b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)((a)!=0?a:b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a & b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a & b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a & ~b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a & ~b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a | b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a | b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(a ^ b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(a ^ b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(Integer.compress(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(Integer.compress(a, b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(Integer.expand(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(Integer.expand(a, b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a << b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)((a << b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a >> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)((a >> b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a >>> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)((a >>> b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a << b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)((a << b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a >>> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)((a >>> b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a >> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)((a >> b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(ROR_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(ROR_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(ROL_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(ROL_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(ROR_scalar(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(ROR_scalar(a, b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(ROL_scalar(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(ROL_scalar(a, b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a >>> CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)((a >>> CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a << CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)((a << CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)((a >> CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)((a >> CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(ROR_scalar(a, CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(ROR_scalar(a, CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(ROL_scalar(a, CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(ROL_scalar(a, CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(Math.min(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(Math.max(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(VectorMath.minUnsigned(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(VectorMath.minUnsigned(a, b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                rs[i] = (int)(VectorMath.maxUnsigned(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)(VectorMath.maxUnsigned(a, b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        int r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        int r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        int r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        int r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        int r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = false;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = false;\n+            for (int i = 0; i < ms.length; i++) {\n+                r |= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = true;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = true;\n+            for (int i = 0; i < ms.length; i++) {\n+                r &= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_DEFAULT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                r &= (bits(a)==0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NEGATIVE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                r &= (bits(a)<0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EQ(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ULT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ult(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UGT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ugt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ULE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ule(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UGE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= uge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    void rearrangeShared(int window, Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    int a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ Integer.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ Integer.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ Integer.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ Integer.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void compressScalar(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = new int[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[j++] = as[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void expandScalar(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = new int[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[i++] = as[j++];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void maskCompressScalar(Blackhole bh) {\n+        boolean[] im = fmt.apply(size);\n+        boolean[] rm = new boolean[size];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < im.length; i++) {\n+                if (im[i]) {\n+                    rm[j++] = im[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rm);\n+    }\n+\n+    void broadcastShared(int window, Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ Integer.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ Integer.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ Integer.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ Integer.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = (int)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] cs = fc.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                int c = cs[i];\n+                rs[i] = (int)((a&~(c))|(b&c));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] bs = fb.apply(size);\n+        int[] cs = fc.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                int b = bs[i];\n+                int c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (int)((a&~(c))|(b&c));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)(-((int)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(-((int)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)(Math.abs((int)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(Math.abs((int)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)(~((int)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(~((int)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)((a==0?0:-1));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)((a==0?0:-1)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)(Integer.bitCount(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(Integer.bitCount(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)(TRAILING_ZEROS_COUNT_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(TRAILING_ZEROS_COUNT_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)(LEADING_ZEROS_COUNT_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(LEADING_ZEROS_COUNT_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)(REVERSE_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(REVERSE_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                rs[i] = (int)(Integer.reverseBytes(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        int[] as = fa.apply(size);\n+        int[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                int a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (int)(Integer.reverseBytes(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/IntScalar.java","additions":2017,"deletions":0,"binary":false,"changes":2017,"status":"added"},{"patch":"@@ -0,0 +1,2507 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.LongVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Long128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Long> SPECIES = LongVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(long[] a, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(long[] a, boolean[] mask, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static long firstNonZero(long a, long b) {\n+        return Long.compare(a, (long) 0) != 0 ? a : b;\n+    }\n+\n+    private static final long CONST_SHIFT = Long.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    long[] fill(IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    long[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (long)(2*i));\n+        b = fill(i -> (long)(i+1));\n+        c = fill(i -> (long)(i+5));\n+        r = fill(i -> (long)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<long[]> fa = vl -> a;\n+    final IntFunction<long[]> fb = vl -> b;\n+    final IntFunction<long[]> fc = vl -> c;\n+    final IntFunction<long[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = (long) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (long) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = (long) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (long) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        long[] a = fa.apply(size);\n+        long[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        long[] a = fa.apply(size);\n+        long[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long128Vector.java","additions":2507,"deletions":0,"binary":false,"changes":2507,"status":"added"},{"patch":"@@ -0,0 +1,2507 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.LongVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Long256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Long> SPECIES = LongVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(long[] a, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(long[] a, boolean[] mask, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static long firstNonZero(long a, long b) {\n+        return Long.compare(a, (long) 0) != 0 ? a : b;\n+    }\n+\n+    private static final long CONST_SHIFT = Long.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    long[] fill(IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    long[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (long)(2*i));\n+        b = fill(i -> (long)(i+1));\n+        c = fill(i -> (long)(i+5));\n+        r = fill(i -> (long)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<long[]> fa = vl -> a;\n+    final IntFunction<long[]> fb = vl -> b;\n+    final IntFunction<long[]> fc = vl -> c;\n+    final IntFunction<long[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = (long) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (long) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = (long) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (long) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        long[] a = fa.apply(size);\n+        long[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        long[] a = fa.apply(size);\n+        long[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long256Vector.java","additions":2507,"deletions":0,"binary":false,"changes":2507,"status":"added"},{"patch":"@@ -0,0 +1,2507 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.LongVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Long512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Long> SPECIES = LongVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(long[] a, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(long[] a, boolean[] mask, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static long firstNonZero(long a, long b) {\n+        return Long.compare(a, (long) 0) != 0 ? a : b;\n+    }\n+\n+    private static final long CONST_SHIFT = Long.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    long[] fill(IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    long[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (long)(2*i));\n+        b = fill(i -> (long)(i+1));\n+        c = fill(i -> (long)(i+5));\n+        r = fill(i -> (long)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<long[]> fa = vl -> a;\n+    final IntFunction<long[]> fb = vl -> b;\n+    final IntFunction<long[]> fc = vl -> c;\n+    final IntFunction<long[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = (long) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (long) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = (long) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (long) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        long[] a = fa.apply(size);\n+        long[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        long[] a = fa.apply(size);\n+        long[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long512Vector.java","additions":2507,"deletions":0,"binary":false,"changes":2507,"status":"added"},{"patch":"@@ -0,0 +1,2507 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.LongVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Long64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Long> SPECIES = LongVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(long[] a, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(long[] a, boolean[] mask, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static long firstNonZero(long a, long b) {\n+        return Long.compare(a, (long) 0) != 0 ? a : b;\n+    }\n+\n+    private static final long CONST_SHIFT = Long.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    long[] fill(IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    long[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (long)(2*i));\n+        b = fill(i -> (long)(i+1));\n+        c = fill(i -> (long)(i+5));\n+        r = fill(i -> (long)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<long[]> fa = vl -> a;\n+    final IntFunction<long[]> fb = vl -> b;\n+    final IntFunction<long[]> fc = vl -> c;\n+    final IntFunction<long[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = (long) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (long) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = (long) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (long) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        long[] a = fa.apply(size);\n+        long[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        long[] a = fa.apply(size);\n+        long[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Long64Vector.java","additions":2507,"deletions":0,"binary":false,"changes":2507,"status":"added"},{"patch":"@@ -0,0 +1,2507 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.LongVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class LongMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Long> SPECIES = LongVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(long[] a, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(long[] a, boolean[] mask, long v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static long firstNonZero(long a, long b) {\n+        return Long.compare(a, (long) 0) != 0 ? a : b;\n+    }\n+\n+    private static final long CONST_SHIFT = Long.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    long[] fill(IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    long[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (long)(2*i));\n+        b = fill(i -> (long)(i+1));\n+        c = fill(i -> (long)(i+5));\n+        r = fill(i -> (long)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<long[]> fa = vl -> a;\n+    final IntFunction<long[]> fb = vl -> b;\n+    final IntFunction<long[]> fc = vl -> c;\n+    final IntFunction<long[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (long) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.COMPRESS_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.EXPAND_BITS, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUB(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUBMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = Long.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Long.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = (long) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long ra = (long) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (long) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long ra = (long) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (long) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        long[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGT() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGE() {\n+        long[] a = fa.apply(size);\n+        long[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        long[] a = fa.apply(size);\n+        long[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        long[] a = fa.apply(size);\n+        long[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Long> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        long[] r = new long[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] b = fb.apply(SPECIES.length());\n+        long[] c = fc.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                LongVector bv = LongVector.fromArray(SPECIES, b, i);\n+                LongVector cv = LongVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        long[] a = fa.apply(SPECIES.length());\n+        long[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Long> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                LongVector av = LongVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongMaxVector.java","additions":2507,"deletions":0,"binary":false,"changes":2507,"status":"added"},{"patch":"@@ -0,0 +1,2017 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+import jdk.incubator.vector.VectorMath;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class LongScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+    private static final long CONST_SHIFT = Long.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    long[] fill(IntFunction<Long> f) {\n+        long[] array = new long[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static long bits(long e) {\n+        return e;\n+    }\n+\n+    long[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> (long)(2*i));\n+        bs = fill(i -> (long)(i+1));\n+        cs = fill(i -> (long)(i+5));\n+        rs = fill(i -> (long)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RAND.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<long[]> fa = vl -> as;\n+    final IntFunction<long[]> fb = vl -> bs;\n+    final IntFunction<long[]> fc = vl -> cs;\n+    final IntFunction<long[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(long a, long b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(long a, long b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(long a, long b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(long a, long b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(long a, long b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(long a, long b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(long a, long b) {\n+        return Long.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(long a, long b) {\n+        return Long.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(long a, long b) {\n+        return Long.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(long a, long b) {\n+        return Long.compareUnsigned(a, b) >= 0;\n+    }\n+\n+    static long ROL_scalar(long a, long b) {\n+        return Long.rotateLeft(a, ((int)b));\n+    }\n+\n+    static long ROR_scalar(long a, long b) {\n+        return Long.rotateRight(a, ((int)b));\n+    }\n+\n+    static long TRAILING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfTrailingZeros(a);\n+    }\n+\n+    static long LEADING_ZEROS_COUNT_scalar(long a) {\n+        return Long.numberOfLeadingZeros(a);\n+    }\n+\n+    static long REVERSE_scalar(long a) {\n+        return Long.reverse(a);\n+    }\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a + b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a + b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a - b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a - b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a * b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a * b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a)!=0?a:b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)((a)!=0?a:b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a & b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a & b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a & ~b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a & ~b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a | b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a | b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(a ^ b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(a ^ b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITS(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(Long.compress(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void COMPRESS_BITSMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(Long.compress(a, b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITS(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(Long.expand(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void EXPAND_BITSMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(Long.expand(a, b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a << b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)((a << b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a >> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)((a >> b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a >>> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)((a >>> b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a << b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)((a << b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a >>> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)((a >>> b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a >> b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)((a >> b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(ROR_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(ROR_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(ROL_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(ROL_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(ROR_scalar(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(ROR_scalar(a, b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(ROL_scalar(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(ROL_scalar(a, b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a >>> CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)((a >>> CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a << CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)((a << CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)((a >> CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)((a >> CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(ROR_scalar(a, CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(ROR_scalar(a, CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(ROL_scalar(a, CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(ROL_scalar(a, CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(Math.min(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(Math.max(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(VectorMath.minUnsigned(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(VectorMath.minUnsigned(a, b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                rs[i] = (long)(VectorMath.maxUnsigned(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)(VectorMath.maxUnsigned(a, b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        long r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        long r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        long r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        long r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        long r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = false;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = false;\n+            for (int i = 0; i < ms.length; i++) {\n+                r |= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = true;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = true;\n+            for (int i = 0; i < ms.length; i++) {\n+                r &= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_DEFAULT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                r &= (bits(a)==0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NEGATIVE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                r &= (bits(a)<0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EQ(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ULT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ult(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UGT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ugt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ULE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ule(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UGE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= uge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    void rearrangeShared(int window, Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    long a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ Long.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ Long.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ Long.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ Long.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void compressScalar(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = new long[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[j++] = as[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void expandScalar(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = new long[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[i++] = as[j++];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void maskCompressScalar(Blackhole bh) {\n+        boolean[] im = fmt.apply(size);\n+        boolean[] rm = new boolean[size];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < im.length; i++) {\n+                if (im[i]) {\n+                    rm[j++] = im[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rm);\n+    }\n+\n+    void broadcastShared(int window, Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ Long.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ Long.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ Long.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ Long.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = (long)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] cs = fc.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                long c = cs[i];\n+                rs[i] = (long)((a&~(c))|(b&c));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] bs = fb.apply(size);\n+        long[] cs = fc.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                long b = bs[i];\n+                long c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (long)((a&~(c))|(b&c));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)(-((long)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(-((long)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)(Math.abs((long)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(Math.abs((long)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)(~((long)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(~((long)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)((a==0?0:-1));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)((a==0?0:-1)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)(Long.bitCount(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(Long.bitCount(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)(TRAILING_ZEROS_COUNT_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(TRAILING_ZEROS_COUNT_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)(LEADING_ZEROS_COUNT_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(LEADING_ZEROS_COUNT_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)(REVERSE_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(REVERSE_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                rs[i] = (long)(Long.reverseBytes(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        long[] as = fa.apply(size);\n+        long[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                long a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (long)(Long.reverseBytes(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/LongScalar.java","additions":2017,"deletions":0,"binary":false,"changes":2017,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+import jdk.incubator.vector.*;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Merge extends AbstractVectorBenchmark {\n+\n+    @Param({\"64\", \"1024\", \"65536\"})\n+    int size;\n+\n+    int[] in, out;\n+\n+    @Setup\n+    public void setup() {\n+        size = size + (size % 64); \/\/ FIXME: process tails\n+        in  = new int[size];\n+        out = new int[size];\n+        for (int i = 0; i < size; i++) {\n+            in[i] = i;\n+        }\n+    }\n+\n+    @Benchmark\n+    public void merge64_128() {\n+        merge(I64, I128);\n+    }\n+\n+    @Benchmark\n+    public void merge128_256() {\n+        merge(I128, I256);\n+    }\n+\n+    @Benchmark\n+    public void merge256_512() {\n+        merge(I256, I512);\n+    }\n+\n+    @Benchmark\n+    public void merge64_256() {\n+        merge(I64, I256);\n+    }\n+\n+    @Benchmark\n+    public void merge128_512() {\n+        merge(I128, I512);\n+    }\n+\n+    @Benchmark\n+    public void merge64_512() {\n+        merge(I64, I256);\n+    }\n+\n+    IntVector merge(VectorSpecies<Integer> from, VectorSpecies<Integer> to, int idx) {\n+        assert from.length() <= to.length();\n+\n+        int vlenFrom = from.length();\n+        int vlenTo   =   to.length();\n+\n+        if (vlenFrom == vlenTo) {\n+            return IntVector.fromArray(from, in, idx);\n+        } else {\n+            var stepDown = narrow(to);\n+            int mid = stepDown.length();\n+            var lo = merge(from, stepDown, idx);\n+            var hi = merge(from, stepDown, idx + mid);\n+            return join(stepDown, to, lo, hi);\n+        }\n+    }\n+\n+\n+    void merge(VectorSpecies<Integer> from, VectorSpecies<Integer> to) {\n+        int vlenTo = to.length();\n+        for (int i = 0; i < in.length; i += vlenTo) {\n+            var r = merge(from, to, i);\n+            r.intoArray(out, i);\n+        }\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        assert Arrays.deepEquals(new Object[] {in}, new Object[] {out});\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Merge.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,630 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+import jdk.incubator.vector.*;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Population count algorithms from \"Faster Population Counts Using AVX2 Instructions\", 2018 by Mula, Kurz, Lemire\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class PopulationCount extends AbstractVectorBenchmark {\n+    @Param({\"64\", \"1024\", \"65536\"})\n+    int size;\n+\n+    private long[] data;\n+\n+    @Setup\n+    public void init() {\n+        data = fillLong(size, i -> RAND.nextLong());\n+\/\/        data = fillLong(size, i -> 0L);\n+\/\/        data = fillLong(size, i -> -1L);\n+\n+        checkConsistency();\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        checkConsistency();\n+    }\n+\n+    void checkConsistency() {\n+        long popCount = longBitCount();\n+        assert popCount == treeOfAdders();\n+        assert popCount == WilkesWheelerGill();\n+        assert popCount == Wegner();\n+        assert popCount == Lauradoux();\n+        assert popCount == HarleySeal();\n+        assert popCount == Mula128();\n+        assert popCount == Mula256();\n+        assert popCount == HarleySeal256();\n+    }\n+\n+    long tail(int upper) {\n+        long acc = 0;\n+        for (int i = upper; i < data.length; i++) {\n+            acc += Long.bitCount(data[i]);\n+        }\n+        return acc;\n+    }\n+\n+    @Benchmark\n+    public long longBitCount() {\n+        long acc = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            acc += Long.bitCount(data[i]);\n+        }\n+        return acc;\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 4. The Wegner function in C\n+\n+    long popcntWegner(long x) {\n+        int v = 0;\n+        while (x != 0) {\n+            x &= x - 1;\n+            v++;\n+        }\n+        return v;\n+    }\n+\n+    @Benchmark\n+    public long Wegner() {\n+        long acc = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            acc += popcntWegner(data[i]);\n+        }\n+        return acc;\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 2. A naive tree-of-adders function in C\n+\n+    static long popcntTree(long x) {\n+        long c1  = 0x5555555555555555L;\n+        long c2  = 0x3333333333333333L;\n+        long c4  = 0x0F0F0F0F0F0F0F0FL;\n+        long c8  = 0x00FF00FF00FF00FFL;\n+        long c16 = 0x0000FFFF0000FFFFL;\n+        long c32 = 0x00000000FFFFFFFFL;\n+\n+        x = (x & c1)  + ((x >>> 1)  & c1);\n+        x = (x & c2)  + ((x >>> 2)  & c2);\n+        x = (x & c4)  + ((x >>> 4)  & c4);\n+        x = (x & c8)  + ((x >>> 8)  & c8);\n+        x = (x & c16) + ((x >>> 16) & c16);\n+        x = (x & c32) + ((x >>> 32) & c32);\n+        return x;\n+    }\n+\n+    @Benchmark\n+    public long treeOfAdders() {\n+        long acc = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            acc += popcntTree(data[i]);\n+        }\n+        return acc;\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 3. The Wilkes-Wheeler-Gill function in C\n+\n+    static long popcntWWG(long x) {\n+        long c1 = 0x5555555555555555L;\n+        long c2 = 0x3333333333333333L;\n+        long c4 = 0x0F0F0F0F0F0F0F0FL;\n+\n+        x -= (x >>> 1) & c1;\n+        x = (( x >>> 2) & c2) + (x & c2) ;\n+        x = ( x + (x >>> 4) ) & c4;\n+        x *= 0x0101010101010101L;\n+        x = x >>> 56;\n+        return x;\n+    }\n+\n+    @Benchmark\n+    public long WilkesWheelerGill() {\n+        long acc = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            acc += popcntWWG(data[i]);\n+        }\n+        return acc;\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 5. The Lauradoux population count in C for sets of 12 words.\n+\n+    static long parallelPopcnt(long count1, long count2, long count3) {\n+        long m1  = 0x5555555555555555L;\n+        long m2  = 0x3333333333333333L;\n+        long m4  = 0x0F0F0F0F0F0F0F0FL;\n+\n+        long half1 = (count3      ) & m1;\n+        long half2 = (count3 >>> 1) & m1;\n+\n+        count1 -= (count1 >>> 1) & m1;\n+        count2 -= (count2 >>> 1) & m1;\n+        count1 += half1;\n+        count2 += half2;\n+        count1  = (count1 & m2) + (( count1 >>> 2) & m2);\n+        count1 += (count2 & m2) + (( count2 >>> 2) & m2);\n+        return (count1 & m4) + (( count1 >>> 4) & m4);\n+    }\n+\n+    static long reduce(long acc) {\n+        long m8  = 0x00FF00FF00FF00FFL;\n+        long m16 = 0x0000FFFF0000FFFFL;\n+        long m32 = 0x00000000FFFFFFFFL;\n+\n+        acc = (acc & m8) + (( acc >>> 8) & m8);\n+        acc = (acc + (acc >>> 16) ) & m16;\n+        acc = (acc & m32) + (acc >>> 32);\n+        return acc;\n+    }\n+\n+    static long popcntLauradoux(long[] xs, int off) {\n+        long acc = 0;\n+        for (int j = off; j < off+12; j += 3) {\n+            acc += parallelPopcnt(xs[j+0], xs[j+1], xs[j+2]);\n+        }\n+        return reduce(acc);\n+    }\n+\n+    @Benchmark\n+    public long Lauradoux() {\n+        long acc = 0;\n+        int upper = data.length - (data.length % 12);\n+        for (int i = 0; i < upper; i += 12) {\n+            acc += popcntLauradoux(data, i);\n+        }\n+        return acc + tail(upper);\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 6. A C function implementing a bitwise parallel carry-save adder (CSA). Given three input words a, b, c, it\n+    \/\/ generates two new words h, l in which each bit represents the high and low bits in the bitwise sum of the bits from a,\n+    \/\/ b, and c.\n+\n+    static long csaLow(long a, long b, long c) {\n+        long u = a ^ b;\n+        long lo = u ^ c;\n+        return lo;\n+    }\n+\n+    static long csaHigh(long a, long b, long c) {\n+        long u = a ^ b;\n+        long hi = (a & b) | (u & c) ;\n+        return hi;\n+    }\n+\n+    \/\/ FIGURE 8. A C function implementing the Harley-Seal\n+    \/\/ population count over an array of 64-bit words. The count\n+    \/\/ function could be the Wilkes-Wheeler-Gill function.\n+    @Benchmark\n+    public long HarleySeal() {\n+        long total = 0, ones = 0, twos = 0, fours = 0, eights = 0, sixteens = 0;\n+        long twosA   = 0, twosB   = 0;\n+        long foursA  = 0, foursB  = 0;\n+        long eightsA = 0, eightsB = 0;\n+\n+        int step = 16;\n+        int upper = data.length - (data.length % step);\n+        for (int i = 0; i < upper; i += step) {\n+            \/\/ CSA(&twosA, &ones, ones, d[i+0], d[i +1]);\n+            twosA = csaHigh(ones, data[i+0], data[i+1]);\n+            ones  = csaLow(ones, data[i+0], data[i+1]);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+2], d[i+3]);\n+            twosB = csaHigh(ones, data[i+2], data[i+3]);\n+            ones  = csaLow(ones, data[i+2], data[i+3]);\n+\n+            \/\/ CSA(&foursA, &twos, twos, twosA, twosB);\n+            foursA = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&twosA, &ones, ones, d[i+4], d[i+5]);\n+            twosA = csaHigh(ones, data[i+4], data[i+5]);\n+            ones  = csaLow(ones, data[i+4], data[i+5]);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+6], d[i+7]);\n+            twosB = csaHigh(ones, data[i+6], data[i+7]);\n+            ones  = csaLow(ones, data[i+6], data[i+7]);\n+\n+            \/\/ CSA(&foursB, &twos, twos, twosA, twosB);\n+            foursB = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&eightsA, &fours, fours, foursA, foursB);\n+            eightsA = csaHigh(fours, foursA, foursB);\n+            fours   = csaLow(fours, foursA, foursB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&twosA, &ones, ones, d[i+8], d[i+9]);\n+            twosA = csaHigh(ones, data[i+8], data[i+9]);\n+            ones  = csaLow(ones, data[i+8], data[i+9]);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+10],d[i+11]);\n+            twosB = csaHigh(ones, data[i+10], data[i+11]);\n+            ones  = csaLow(ones, data[i+10], data[i+11]);\n+\n+            \/\/ CSA(&foursA, &twos, twos, twosA, twosB);\n+            foursA = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&twosA, &ones, ones, d[i+12], d[i +13]);\n+            twosA = csaHigh(ones, data[i+12], data[i+13]);\n+            ones  = csaLow(ones, data[i+12], data[i+13]);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+14], d[i +15]);\n+            twosB = csaHigh(ones, data[i+14], data[i+15]);\n+            ones  = csaLow(ones, data[i+14], data[i+15]);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&foursB, &twos, twos, twosA, twosB);\n+            foursB = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ CSA(&eightsB, &fours, fours, foursA, foursB);\n+            eightsB = csaHigh(fours, foursA, foursB);\n+            fours   = csaLow(fours, foursA, foursB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&sixteens, &eights, eights, eightsA, eightsB);\n+            sixteens = csaHigh(eights, eightsA, eightsB);\n+            eights   = csaLow(eights, eightsA, eightsB);\n+\n+            total += Long.bitCount(sixteens);\n+        }\n+        total = 16 * total\n+                + 8 * Long.bitCount(eights)\n+                + 4 * Long.bitCount(fours)\n+                + 2 * Long.bitCount(twos)\n+                + 1 * Long.bitCount(ones);\n+\n+        return total + tail(upper);\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 9. A C function using SSE intrinsics implementing Mula's algorithm to compute sixteen population counts,\n+    \/\/ corresponding to sixteen input bytes.\n+\n+    static final ByteVector MULA128_LOOKUP = IntVector.fromArray(I128,\n+            new int[]{\n+                    0x02_01_01_00, \/\/ 0, 1, 1, 2,\n+                    0x03_02_02_01, \/\/ 1, 2, 2, 3,\n+                    0x03_02_02_01, \/\/ 1, 2, 2, 3,\n+                    0x04_03_03_02  \/\/ 2, 3, 3, 4\n+            },\n+            0\n+            ).reinterpretAsBytes();\n+\n+    ByteVector popcntB128(ByteVector v) {\n+        var low_mask = ByteVector.broadcast(B128, (byte)0x0f);\n+\n+        var lo = v          .and(low_mask);\n+        var hi = v.lanewise(VectorOperators.LSHR, 4).and(low_mask);\n+\n+        var cnt1 = MULA128_LOOKUP.rearrange(lo.toShuffle());\n+        var cnt2 = MULA128_LOOKUP.rearrange(hi.toShuffle());\n+\n+        return cnt1.add(cnt2);\n+    }\n+\n+    @Benchmark\n+    public long Mula128() {\n+        var acc = LongVector.zero(L128); \/\/ IntVector\n+        int step = 32; \/\/ % B128.length() == 0!\n+        int upper = data.length - (data.length % step);\n+        for (int i = 0; i < upper; i += step) {\n+            var bacc = ByteVector.zero(B128);\n+            for (int j = 0; j < step; j += L128.length()) {\n+                var v1 = LongVector.fromArray(L128, data, i + j);\n+                var v2 = v1.reinterpretAsBytes();\n+                var v3 = popcntB128(v2);\n+                bacc = bacc.add(v3);\n+            }\n+            acc = acc.add(sumUnsignedBytes(bacc));\n+        }\n+        var r = acc.reduceLanes(VectorOperators.ADD) + tail(upper);\n+        return r;\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 10. A C function using AVX2 intrinsics implementing Mula's algorithm to compute the four population counts\n+    \/\/ of the four 64-bit words in a 256-bit vector. The 32 B output vector should be interpreted as four separate\n+    \/\/ 64-bit counts that need to be summed to obtain the final population count.\n+\n+    static final ByteVector MULA256_LOOKUP = \n+            join(I128, I256, MULA128_LOOKUP.reinterpretAsInts(), MULA128_LOOKUP.reinterpretAsInts()).reinterpretAsBytes();\n+\n+    ByteVector popcntB256(ByteVector v) {\n+        var low_mask = ByteVector.broadcast(B256, (byte)0x0F);\n+\n+        var lo = v          .and(low_mask);\n+        var hi = v.lanewise(VectorOperators.LSHR, 4).and(low_mask);\n+\n+        var cnt1 = MULA256_LOOKUP.rearrange(lo.toShuffle());\n+        var cnt2 = MULA256_LOOKUP.rearrange(hi.toShuffle());\n+        var cnt = cnt1.add(cnt2);\n+\n+        return cnt;\n+    }\n+\n+    \/\/ Horizontally sum each consecutive 8 differences to produce four unsigned 16-bit integers,\n+    \/\/ and pack these unsigned 16-bit integers in the low 16 bits of 64-bit elements in dst:\n+    \/\/   _mm256_sad_epu8(total, _mm256_setzero_si256())\n+    LongVector sumUnsignedBytes(ByteVector vb) {\n+        return sumUnsignedBytesShapes(vb);\n+\/\/        return sumUnsignedBytesShifts(vb);\n+    }\n+\n+    LongVector sumUnsignedBytesShapes(ByteVector vb) {\n+        VectorSpecies<Short> shortSpecies = VectorSpecies.of(short.class, vb.shape());\n+        VectorSpecies<Integer> intSpecies = VectorSpecies.of(int.class, vb.shape());\n+        VectorSpecies<Long> longSpecies = VectorSpecies.of(long.class, vb.shape());\n+\n+        var low_short_mask = ShortVector.broadcast(shortSpecies, (short) 0xFF);\n+        var low_int_mask = IntVector.broadcast(intSpecies, 0xFFFF);\n+        var low_long_mask = LongVector.broadcast(longSpecies, 0xFFFFFFFFL);\n+\n+        var vs = vb.reinterpretAsShorts(); \/\/ 16-bit\n+        var vs0 = vs.and(low_short_mask);\n+        var vs1 = vs.lanewise(VectorOperators.LSHR, 8).and(low_short_mask);\n+        var vs01 = vs0.add(vs1);\n+\n+        var vi = vs01.reinterpretAsInts(); \/\/ 32-bit\n+        var vi0 = vi.and(low_int_mask);\n+        var vi1 = vi.lanewise(VectorOperators.LSHR, 16).and(low_int_mask);\n+        var vi01 = vi0.add(vi1);\n+\n+        var vl = vi01.reinterpretAsLongs(); \/\/ 64-bit\n+        var vl0 = vl.and(low_long_mask);\n+        var vl1 = vl.lanewise(VectorOperators.LSHR, 32).and(low_long_mask);\n+        var vl01 = vl0.add(vl1);\n+\n+        return vl01;\n+    }\n+\n+    LongVector sumUnsignedBytesShifts(ByteVector vb) {\n+        VectorSpecies<Long> to = VectorSpecies.of(long.class, vb.shape());\n+\n+        var low_mask = LongVector.broadcast(to, 0xFF);\n+\n+        var vl = vb.reinterpretAsLongs();\n+\n+        var v0 = vl           .and(low_mask); \/\/ 8-bit\n+        var v1 = vl.lanewise(VectorOperators.LSHR, 8).and(low_mask);  \/\/ 8-bit\n+        var v2 = vl.lanewise(VectorOperators.LSHR, 16).and(low_mask); \/\/ 8-bit\n+        var v3 = vl.lanewise(VectorOperators.LSHR, 24).and(low_mask); \/\/ 8-bit\n+        var v4 = vl.lanewise(VectorOperators.LSHR, 32).and(low_mask); \/\/ 8-bit\n+        var v5 = vl.lanewise(VectorOperators.LSHR, 40).and(low_mask); \/\/ 8-bit\n+        var v6 = vl.lanewise(VectorOperators.LSHR, 48).and(low_mask); \/\/ 8-bit\n+        var v7 = vl.lanewise(VectorOperators.LSHR, 56).and(low_mask); \/\/ 8-bit\n+\n+        var v01 = v0.add(v1);\n+        var v23 = v2.add(v3);\n+        var v45 = v4.add(v5);\n+        var v67 = v6.add(v7);\n+\n+        var v03 = v01.add(v23);\n+        var v47 = v45.add(v67);\n+\n+        var sum = v03.add(v47); \/\/ 64-bit\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public long Mula256() {\n+        var acc = LongVector.zero(L256);\n+        int step = 32; \/\/ % B256.length() == 0!\n+        int upper = data.length - (data.length % step);\n+        for (int i = 0; i < upper; i += step) {\n+            var bacc = ByteVector.zero(B256);\n+            for (int j = 0; j < step; j += L256.length()) {\n+                var v1 = LongVector.fromArray(L256, data, i + j);\n+                var v2 = popcntB256(v1.reinterpretAsBytes());\n+                bacc = bacc.add(v2);\n+            }\n+            acc = acc.add(sumUnsignedBytes(bacc));\n+        }\n+        return acc.reduceLanes(VectorOperators.ADD) + tail(upper);\n+    }\n+\n+\n+    \/* ============================================================================================================== *\/\n+\n+    \/\/ FIGURE 11. A C function using AVX2 intrinsics implementing a bitwise parallel carry-save adder (CSA).\n+\n+    LongVector csaLow(LongVector a, LongVector b, LongVector c) {\n+        var u = a.lanewise(VectorOperators.XOR, b);\n+        var r = u.lanewise(VectorOperators.XOR, c);\n+        return r;\n+    }\n+\n+    LongVector csaHigh(LongVector a, LongVector b, LongVector c) {\n+        var u  = a.lanewise(VectorOperators.XOR, b);\n+        var ab = a.and(b);\n+        var uc = u.and(c);\n+        var r  = ab.or(uc); \/\/ (a & b) | ((a ^ b) & c)\n+        return r;\n+    }\n+\n+    LongVector popcntL256(LongVector v) {\n+        var vb1 = v.reinterpretAsBytes();\n+        var vb2 = popcntB256(vb1);\n+        return sumUnsignedBytes(vb2);\n+    }\n+\n+    \/\/ FIGURE 12. A C function using AVX2 intrinsics implementing Harley-Seal's algorithm. It assumes, for\n+    \/\/ simplicity, that the input size in 256-bit vectors is divisible by 16. See Fig. 10 for the count function.\n+\n+    @Benchmark\n+    public long HarleySeal256() {\n+        LongVector ones, twos, fours, eights, sixteens, vtotal, twosA, twosB, foursA, foursB, eightsA, eightsB;\n+        ones = twos = fours = eights = sixteens = twosA = twosB = foursA = foursB = eightsA = eights = vtotal = LongVector.broadcast(L256, 0);\n+\n+        var vlen = L256.length();\n+        int step = 16 * vlen;\n+        int upper = data.length - (data.length % step);\n+        for (int i = 0; i < upper; i += step) {\n+            \/\/ CSA(&twosA, &ones, ones, d[i+0], d[i +1]);\n+            var d0 = LongVector.fromArray(L256, data, i + 0 * vlen);\n+            var d1 = LongVector.fromArray(L256, data, i + 1 * vlen);\n+\n+            twosA = csaHigh(ones, d0, d1);\n+            ones  = csaLow(ones, d0, d1);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+2], d[i+3]);\n+            var d2 = LongVector.fromArray(L256, data, i + 2 * vlen);\n+            var d3 = LongVector.fromArray(L256, data, i + 3 * vlen);\n+            twosB = csaHigh(ones, d2, d3);\n+            ones  = csaLow(ones, d2, d3);\n+\n+            \/\/ CSA(&foursA, &twos, twos, twosA, twosB);\n+            foursA = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&twosA, &ones, ones, d[i+4], d[i+5]);\n+            var d4 = LongVector.fromArray(L256, data, i + 4 * vlen);\n+            var d5 = LongVector.fromArray(L256, data, i + 5 * vlen);\n+            twosA = csaHigh(ones, d4, d5);\n+            ones  = csaLow(ones, d4, d5);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+6], d[i+7]);\n+            var d6 = LongVector.fromArray(L256, data, i + 6 * vlen);\n+            var d7 = LongVector.fromArray(L256, data, i + 7 * vlen);\n+            twosB = csaHigh(ones, d6, d7);\n+            ones  = csaLow(ones, d6, d7);\n+\n+            \/\/ CSA(&foursB, &twos, twos, twosA, twosB);\n+            foursB = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&eightsA, &fours, fours, foursA, foursB);\n+            eightsA = csaHigh(fours, foursA, foursB);\n+            fours   = csaLow(fours, foursA, foursB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&twosA, &ones, ones, d[i+8], d[i+9]);\n+            var d8 = LongVector.fromArray(L256, data, i + 8 * vlen);\n+            var d9 = LongVector.fromArray(L256, data, i + 9 * vlen);\n+            twosA = csaHigh(ones, d8, d9);\n+            ones  = csaLow(ones, d8, d9);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+10],d[i+11]);\n+            var d10 = LongVector.fromArray(L256, data, i + 10 * vlen);\n+            var d11 = LongVector.fromArray(L256, data, i + 11 * vlen);\n+            twosB = csaHigh(ones, d10, d11);\n+            ones  = csaLow(ones, d10, d11);\n+\n+            \/\/ CSA(&foursA, &twos, twos, twosA, twosB);\n+            foursA = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&twosA, &ones, ones, d[i+12], d[i +13]);\n+            var d12 = LongVector.fromArray(L256, data, i + 12 * vlen);\n+            var d13 = LongVector.fromArray(L256, data, i + 13 * vlen);\n+            twosA = csaHigh(ones, d12, d13);\n+            ones  = csaLow(ones, d12, d13);\n+\n+            \/\/ CSA(&twosB, &ones, ones, d[i+14], d[i +15]);\n+            var d14 = LongVector.fromArray(L256, data, i + 14 * vlen);\n+            var d15 = LongVector.fromArray(L256, data, i + 15 * vlen);\n+            twosB = csaHigh(ones, d14, d15);\n+            ones  = csaLow(ones, d14, d15);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&foursB, &twos, twos, twosA, twosB);\n+            foursB = csaHigh(twos, twosA, twosB);\n+            twos   = csaLow(twos, twosA, twosB);\n+\n+            \/\/ CSA(&eightsB, &fours, fours, foursA, foursB);\n+            eightsB = csaHigh(fours, foursA, foursB);\n+            fours   = csaLow(fours, foursA, foursB);\n+\n+            \/\/ ====================================\n+\n+            \/\/ CSA(&sixteens, &eights, eights, eightsA, eightsB);\n+            sixteens = csaHigh(eights, eightsA, eightsB);\n+            eights   = csaLow(eights, eightsA, eightsB);\n+\n+            vtotal = vtotal.add(popcntL256(sixteens));\n+        }\n+\n+        vtotal = vtotal.mul(16);                       \/\/ << 4\n+        vtotal = vtotal.add(popcntL256(eights).mul(8)); \/\/ << 3\n+        vtotal = vtotal.add(popcntL256(fours).mul(4));  \/\/ << 2\n+        vtotal = vtotal.add(popcntL256(twos).mul(2));   \/\/ << 1\n+        vtotal = vtotal.add(popcntL256(ones));          \/\/ << 0\n+\n+        var total = vtotal.reduceLanes(VectorOperators.ADD);\n+\n+        return total + tail(upper);\n+    }\n+\n+    \/* ============================================================================================================== *\/\n+\n+\/\/    ByteVector csaLow512(ByteVector a, ByteVector b, ByteVector c) {\n+\/\/        return _mm512_ternarylogic_epi32(c, b, a, 0x96); \/\/ vpternlogd\n+\/\/    }\n+\/\/\n+\/\/    ByteVector csaLow512(ByteVector a, ByteVector b, ByteVector c) {\n+\/\/        return _mm512_ternarylogic_epi32(c, b, a, 0xe8); \/\/ vpternlogd\n+\/\/    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/PopulationCount.java","additions":630,"deletions":0,"binary":false,"changes":630,"status":"added"},{"patch":"@@ -0,0 +1,2435 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ShortVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Short128Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Short> SPECIES = ShortVector.SPECIES_128;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(short[] a, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(short[] a, boolean[] mask, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    private static final short CONST_SHIFT = Short.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (short)(2*i));\n+        b = fill(i -> (short)(i+1));\n+        c = fill(i -> (short)(i+5));\n+        r = fill(i -> (short)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = (short) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (short) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = (short) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (short) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        short[] a = fa.apply(size);\n+        short[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        short[] a = fa.apply(size);\n+        short[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short128Vector.java","additions":2435,"deletions":0,"binary":false,"changes":2435,"status":"added"},{"patch":"@@ -0,0 +1,2435 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ShortVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Short256Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Short> SPECIES = ShortVector.SPECIES_256;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(short[] a, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(short[] a, boolean[] mask, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    private static final short CONST_SHIFT = Short.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (short)(2*i));\n+        b = fill(i -> (short)(i+1));\n+        c = fill(i -> (short)(i+5));\n+        r = fill(i -> (short)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = (short) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (short) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = (short) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (short) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        short[] a = fa.apply(size);\n+        short[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        short[] a = fa.apply(size);\n+        short[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short256Vector.java","additions":2435,"deletions":0,"binary":false,"changes":2435,"status":"added"},{"patch":"@@ -0,0 +1,2435 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ShortVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Short512Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Short> SPECIES = ShortVector.SPECIES_512;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(short[] a, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(short[] a, boolean[] mask, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    private static final short CONST_SHIFT = Short.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (short)(2*i));\n+        b = fill(i -> (short)(i+1));\n+        c = fill(i -> (short)(i+5));\n+        r = fill(i -> (short)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = (short) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (short) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = (short) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (short) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        short[] a = fa.apply(size);\n+        short[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        short[] a = fa.apply(size);\n+        short[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short512Vector.java","additions":2435,"deletions":0,"binary":false,"changes":2435,"status":"added"},{"patch":"@@ -0,0 +1,2435 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ShortVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class Short64Vector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Short> SPECIES = ShortVector.SPECIES_64;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(short[] a, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(short[] a, boolean[] mask, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    private static final short CONST_SHIFT = Short.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (short)(2*i));\n+        b = fill(i -> (short)(i+1));\n+        c = fill(i -> (short)(i+5));\n+        r = fill(i -> (short)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = (short) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (short) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = (short) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (short) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        short[] a = fa.apply(size);\n+        short[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        short[] a = fa.apply(size);\n+        short[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/Short64Vector.java","additions":2435,"deletions":0,"binary":false,"changes":2435,"status":"added"},{"patch":"@@ -0,0 +1,2435 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import jdk.incubator.vector.Vector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.incubator.vector.VectorShuffle;\n+import jdk.incubator.vector.ShortVector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.BiFunction;\n+import java.util.function.IntFunction;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class ShortMaxVector extends AbstractVectorBenchmark {\n+    static final VectorSpecies<Short> SPECIES = ShortVector.SPECIES_MAX;\n+\n+    static final int INVOC_COUNT = 1; \/\/ get rid of outer loop\n+\n+    static void replaceZero(short[] a, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static void replaceZero(short[] a, boolean[] mask, short v) {\n+        for (int i = 0; i < a.length; i++) {\n+            if (mask[i % mask.length] && a[i] == 0) {\n+                a[i] = v;\n+            }\n+        }\n+    }\n+\n+    static short firstNonZero(short a, short b) {\n+        return Short.compare(a, (short) 0) != 0 ? a : b;\n+    }\n+\n+    private static final short CONST_SHIFT = Short.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    short[] a, b, c, r;\n+    boolean[] m, mt, rm;\n+    int[] s;\n+\n+    @Setup\n+    public void init() {\n+        size += size % SPECIES.length(); \/\/ FIXME: add post-loops\n+\n+        a = fill(i -> (short)(2*i));\n+        b = fill(i -> (short)(i+1));\n+        c = fill(i -> (short)(i+5));\n+        r = fill(i -> (short)0);\n+\n+        m = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rm = fillMask(size, i -> false);\n+\n+        s = fillInt(size, i -> RAND.nextInt(SPECIES.length()));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> a;\n+    final IntFunction<short[]> fb = vl -> b;\n+    final IntFunction<short[]> fc = vl -> c;\n+    final IntFunction<short[]> fr = vl -> r;\n+    final IntFunction<boolean[]> fm = vl -> m;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rm;\n+    final BiFunction<Integer,Integer,int[]> fs = (i,j) -> s;\n+\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MUL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIV(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        replaceZero(b, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void DIVMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        replaceZero(b, mask, (short) 1);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.DIV, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.FIRST_NONZERO, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.AND_NOT, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.OR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.XOR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ASHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.LSHR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROR, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.ROL, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, (int)b[i], vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LSHL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ASHR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROR, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ROL, CONST_SHIFT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.MAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMIN, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.UMAX, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SSUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADD(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUADDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUADD, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUB(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void SUSUBMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.lanewise(VectorOperators.SUSUB, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = -1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = -1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra &= av.reduceLanes(VectorOperators.AND, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra |= av.reduceLanes(VectorOperators.OR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra ^= av.reduceLanes(VectorOperators.XOR, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra += av.reduceLanes(VectorOperators.ADD, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = 1;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = 1;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra *= av.reduceLanes(VectorOperators.MUL, vmask);\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MINMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MAX_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MAX_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) Math.min(ra, av.reduceLanes(VectorOperators.MIN, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void MAXMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = Short.MIN_VALUE;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = Short.MIN_VALUE;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = (short) Math.max(ra, av.reduceLanes(VectorOperators.MAX, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short ra = (short) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (short) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMaskedLanes(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short ra = (short) 0;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            ra = (short) 0;\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ra = firstNonZero(ra, av.reduceLanes(VectorOperators.FIRST_NONZERO, vmask));\n+            }\n+        }\n+        bh.consume(ra);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.anyTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        boolean[] r = fmr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < mask.length; i += SPECIES.length()) {\n+                VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, i);\n+                r[i] = vmask.allTrue();\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void withLane(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.withLane(j, b[i + j]).intoArray(r, i);\n+                a[i + j] = b[i + j];\n+                j = (j + 1) & (SPECIES.length() - 1);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public Object IS_DEFAULT() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_DEFAULT));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public Object IS_NEGATIVE() {\n+        short[] a = fa.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.test(VectorOperators.IS_NEGATIVE));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object EQ() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.EQ, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object NE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.NE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object LE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.LE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object GE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.GE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGT() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGT, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object ULE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.ULE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+    @Benchmark\n+    public Object UGE() {\n+        short[] a = fa.apply(size);\n+        short[] b = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+\n+                \/\/ accumulate results, so JIT can't eliminate relevant computations\n+                m = m.and(av.compare(VectorOperators.UGE, bv));\n+            }\n+        }\n+\n+        return m;\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.blend(bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void rearrange(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        int[] order = fs.apply(a.length, SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.rearrange(VectorShuffle.fromArray(SPECIES, order, i)).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+    @Benchmark\n+    public Object compress() {\n+        short[] a = fa.apply(size);\n+        short[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.compress(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object expand() {\n+        short[] a = fa.apply(size);\n+        short[] r = fb.apply(size);\n+        boolean[] ms = fmt.apply(size);\n+        VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.expand(m).intoArray(r, i);\n+            }\n+        }\n+\n+        return r;\n+    }\n+\n+    @Benchmark\n+    public Object maskCompress() {\n+        boolean[] ms = fmt.apply(size);\n+        boolean[] rs = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < ms.length; i += SPECIES.length()) {\n+                VectorMask<Short> m = VectorMask.fromArray(SPECIES, ms, i);\n+                m.compress().intoArray(rs, j);\n+                j += m.trueCount();\n+            }\n+        }\n+\n+        return rs;\n+    }\n+\n+    @Benchmark\n+    public void laneextract(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                int num_lanes = SPECIES.length();\n+                \/\/ Manually unroll because full unroll happens after intrinsification.\n+                \/\/ Unroll is needed because get intrinsic requires for index to be a known constant.\n+                if (num_lanes == 1) {\n+                    r[i]=av.lane(0);\n+                } else if (num_lanes == 2) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                } else if (num_lanes == 4) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                } else if (num_lanes == 8) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                } else if (num_lanes == 16) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                } else if (num_lanes == 32) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                } else if (num_lanes == 64) {\n+                    r[i]=av.lane(0);\n+                    r[i+1]=av.lane(1);\n+                    r[i+2]=av.lane(2);\n+                    r[i+3]=av.lane(3);\n+                    r[i+4]=av.lane(4);\n+                    r[i+5]=av.lane(5);\n+                    r[i+6]=av.lane(6);\n+                    r[i+7]=av.lane(7);\n+                    r[i+8]=av.lane(8);\n+                    r[i+9]=av.lane(9);\n+                    r[i+10]=av.lane(10);\n+                    r[i+11]=av.lane(11);\n+                    r[i+12]=av.lane(12);\n+                    r[i+13]=av.lane(13);\n+                    r[i+14]=av.lane(14);\n+                    r[i+15]=av.lane(15);\n+                    r[i+16]=av.lane(16);\n+                    r[i+17]=av.lane(17);\n+                    r[i+18]=av.lane(18);\n+                    r[i+19]=av.lane(19);\n+                    r[i+20]=av.lane(20);\n+                    r[i+21]=av.lane(21);\n+                    r[i+22]=av.lane(22);\n+                    r[i+23]=av.lane(23);\n+                    r[i+24]=av.lane(24);\n+                    r[i+25]=av.lane(25);\n+                    r[i+26]=av.lane(26);\n+                    r[i+27]=av.lane(27);\n+                    r[i+28]=av.lane(28);\n+                    r[i+29]=av.lane(29);\n+                    r[i+30]=av.lane(30);\n+                    r[i+31]=av.lane(31);\n+                    r[i+32]=av.lane(32);\n+                    r[i+33]=av.lane(33);\n+                    r[i+34]=av.lane(34);\n+                    r[i+35]=av.lane(35);\n+                    r[i+36]=av.lane(36);\n+                    r[i+37]=av.lane(37);\n+                    r[i+38]=av.lane(38);\n+                    r[i+39]=av.lane(39);\n+                    r[i+40]=av.lane(40);\n+                    r[i+41]=av.lane(41);\n+                    r[i+42]=av.lane(42);\n+                    r[i+43]=av.lane(43);\n+                    r[i+44]=av.lane(44);\n+                    r[i+45]=av.lane(45);\n+                    r[i+46]=av.lane(46);\n+                    r[i+47]=av.lane(47);\n+                    r[i+48]=av.lane(48);\n+                    r[i+49]=av.lane(49);\n+                    r[i+50]=av.lane(50);\n+                    r[i+51]=av.lane(51);\n+                    r[i+52]=av.lane(52);\n+                    r[i+53]=av.lane(53);\n+                    r[i+54]=av.lane(54);\n+                    r[i+55]=av.lane(55);\n+                    r[i+56]=av.lane(56);\n+                    r[i+57]=av.lane(57);\n+                    r[i+58]=av.lane(58);\n+                    r[i+59]=av.lane(59);\n+                    r[i+60]=av.lane(60);\n+                    r[i+61]=av.lane(61);\n+                    r[i+62]=av.lane(62);\n+                    r[i+63]=av.lane(63);\n+                } else {\n+                    for (int j = 0; j < SPECIES.length(); j++) {\n+                        r[i+j]=av.lane(j);\n+                    }\n+                }\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void broadcast(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.broadcast(SPECIES, a[i]).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector.zero(SPECIES).intoArray(a, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.slice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void sliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.slice(origin, bv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceUnary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.unslice(origin).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceBinary(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void unsliceMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+        short[] r = new short[a.length];\n+        int origin = RAND.nextInt(SPECIES.length());\n+        int part = RAND.nextInt(2);\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                av.unslice(origin, bv, part, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] b = fb.apply(SPECIES.length());\n+        short[] c = fc.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                ShortVector bv = ShortVector.fromArray(SPECIES, b, i);\n+                ShortVector cv = ShortVector.fromArray(SPECIES, c, i);\n+                av.lanewise(VectorOperators.BITWISE_BLEND, bv, cv, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NEG, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ABS, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.NOT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.ZOMO, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.BIT_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.TRAILING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.LEADING_ZEROS_COUNT, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        short[] a = fa.apply(SPECIES.length());\n+        short[] r = fr.apply(SPECIES.length());\n+        boolean[] mask = fm.apply(SPECIES.length());\n+        VectorMask<Short> vmask = VectorMask.fromArray(SPECIES, mask, 0);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < a.length; i += SPECIES.length()) {\n+                ShortVector av = ShortVector.fromArray(SPECIES, a, i);\n+                av.lanewise(VectorOperators.REVERSE_BYTES, vmask).intoArray(r, i);\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortMaxVector.java","additions":2435,"deletions":0,"binary":false,"changes":2435,"status":"added"},{"patch":"@@ -0,0 +1,1945 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.IntFunction;\n+import jdk.incubator.vector.VectorMath;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class ShortScalar extends AbstractVectorBenchmark {\n+    static final int INVOC_COUNT = 1; \/\/ To align with vector benchmarks.\n+\n+    private static final short CONST_SHIFT = Short.SIZE \/ 2;\n+\n+    @Param(\"1024\")\n+    int size;\n+\n+    short[] fill(IntFunction<Short> f) {\n+        short[] array = new short[size];\n+        for (int i = 0; i < array.length; i++) {\n+            array[i] = f.apply(i);\n+        }\n+        return array;\n+    }\n+\n+    static short bits(short e) {\n+        return e;\n+    }\n+\n+    short[] as, bs, cs, rs;\n+    boolean[] ms, mt, rms;\n+    int[] ss;\n+\n+    @Setup\n+    public void init() {\n+        as = fill(i -> (short)(2*i));\n+        bs = fill(i -> (short)(i+1));\n+        cs = fill(i -> (short)(i+5));\n+        rs = fill(i -> (short)0);\n+        ms = fillMask(size, i -> (i % 2) == 0);\n+        mt = fillMask(size, i -> true);\n+        rms = fillMask(size, i -> false);\n+\n+        ss = fillInt(size, i -> RAND.nextInt(Math.max(i,1)));\n+    }\n+\n+    final IntFunction<short[]> fa = vl -> as;\n+    final IntFunction<short[]> fb = vl -> bs;\n+    final IntFunction<short[]> fc = vl -> cs;\n+    final IntFunction<short[]> fr = vl -> rs;\n+    final IntFunction<boolean[]> fm = vl -> ms;\n+    final IntFunction<boolean[]> fmt = vl -> mt;\n+    final IntFunction<boolean[]> fmr = vl -> rms;\n+    final IntFunction<int[]> fs = vl -> ss;\n+\n+    static boolean eq(short a, short b) {\n+        return a == b;\n+    }\n+\n+    static boolean neq(short a, short b) {\n+        return a != b;\n+    }\n+\n+    static boolean lt(short a, short b) {\n+        return a < b;\n+    }\n+\n+    static boolean le(short a, short b) {\n+        return a <= b;\n+    }\n+\n+    static boolean gt(short a, short b) {\n+        return a > b;\n+    }\n+\n+    static boolean ge(short a, short b) {\n+        return a >= b;\n+    }\n+\n+    static boolean ult(short a, short b) {\n+        return Short.compareUnsigned(a, b) < 0;\n+    }\n+\n+    static boolean ule(short a, short b) {\n+        return Short.compareUnsigned(a, b) <= 0;\n+    }\n+\n+    static boolean ugt(short a, short b) {\n+        return Short.compareUnsigned(a, b) > 0;\n+    }\n+\n+    static boolean uge(short a, short b) {\n+        return Short.compareUnsigned(a, b) >= 0;\n+    }\n+\n+    static short ROL_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) << (b & 15)) | ((((short)a) & 0xFFFF) >>> (16 - (b & 15))));\n+    }\n+\n+    static short ROR_scalar(short a, short b) {\n+        return (short)(((((short)a) & 0xFFFF) >>> (b & 15)) | ((((short)a) & 0xFFFF) << (16 - (b & 15))));\n+    }\n+\n+    static short TRAILING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a != 0 ? Integer.numberOfTrailingZeros(a) : 16);\n+    }\n+\n+    static short LEADING_ZEROS_COUNT_scalar(short a) {\n+        return (short) (a >= 0 ? Integer.numberOfLeadingZeros(a) - 16 : 0);\n+    }\n+\n+    static short REVERSE_scalar(short a) {\n+        short b = ROL_scalar(a, (short) 8);\n+        b = (short)(((b & 0x5555) << 1) | ((b & 0xAAAA) >>> 1));\n+        b = (short)(((b & 0x3333) << 2) | ((b & 0xCCCC) >>> 2));\n+        b = (short)(((b & 0x0F0F) << 4) | ((b & 0xF0F0) >>> 4));\n+        return b;\n+    }\n+\n+    @Benchmark\n+    public void ADD(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a + b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ADDMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a + b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUB(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a - b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void SUBMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a - b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MUL(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a * b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MULMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a * b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZERO(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)((a)!=0?a:b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void FIRST_NONZEROMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)((a)!=0?a:b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void AND(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a & b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ANDMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a & b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a & ~b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void AND_NOTMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a & ~b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void OR(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a | b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ORMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a | b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void XOR(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(a ^ b);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void XORMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(a ^ b);\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHL(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)((a << (b & 0xF)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)((a << (b & 0xF)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHR(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)((a >> (b & 0xF)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)((a >> (b & 0xF)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHR(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(((a & 0xFFFF) >>> (b & 0xF)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(((a & 0xFFFF) >>> (b & 0xF)));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)((a << (b & 15)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)((a << (b & 15))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(((a & 0xFFFF) >>> (b & 15)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(((a & 0xFFFF) >>> (b & 15))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)((a >> (b & 15)));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)((a >> (b & 15))) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROR(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(ROR_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void RORMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(ROR_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROL(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(ROL_scalar(a,b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROLMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(ROL_scalar(a,b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void RORShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(ROR_scalar(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(ROR_scalar(a, b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROLShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(ROL_scalar(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShift(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(ROL_scalar(a, b)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHRShiftConst(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(((a & 0xFFFF) >>> CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHRMaskedShiftConst(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(((a & 0xFFFF) >>> CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHLShiftConst(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)((a << CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LSHLMaskedShiftConst(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)((a << CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHRShiftConst(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)((a >> CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ASHRMaskedShiftConst(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)((a >> CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void RORShiftConst(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(ROR_scalar(a, CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void RORMaskedShiftConst(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(ROR_scalar(a, CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROLShiftConst(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(ROL_scalar(a, CONST_SHIFT));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ROLMaskedShiftConst(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(ROL_scalar(a, CONST_SHIFT)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MIN(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Math.min(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void MAX(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(Math.max(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void UMIN(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(VectorMath.minUnsigned(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void UMINMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(VectorMath.minUnsigned(a, b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void UMAX(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                rs[i] = (short)(VectorMath.maxUnsigned(a, b));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void UMAXMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)(VectorMath.maxUnsigned(a, b));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ANDLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ANDMaskedLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        short r = -1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = -1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r &= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ORMaskedLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        short r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r |= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void XORMaskedLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        short r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r ^= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ADDMaskedLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        short r = 0;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 0;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r += as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void MULMaskedLanes(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean[] ms = fm.apply(size);\n+        short r = 1;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = 1;\n+            for (int i = 0; i < as.length; i++) {\n+                if (ms[i % ms.length])\n+                    r *= as[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void anyTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = false;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = false;\n+            for (int i = 0; i < ms.length; i++) {\n+                r |= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void allTrue(Blackhole bh) {\n+        boolean[] ms = fm.apply(size);\n+        boolean r = true;\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            r = true;\n+            for (int i = 0; i < ms.length; i++) {\n+                r &= ms[i];\n+            }\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_DEFAULT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                r &= (bits(a)==0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void IS_NEGATIVE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                r &= (bits(a)<0); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= lt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= gt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void EQ(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= eq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void NE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= neq(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void LE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= le(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void GE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ULT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ult(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UGT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ugt(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void ULE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= ule(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void UGE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        boolean r = true;\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                r &= uge(as[i], bs[i]); \/\/ accumulate so JIT can't eliminate the computation\n+            }\n+        }\n+\n+        bh.consume(r);\n+    }\n+\n+    @Benchmark\n+    public void blend(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? b : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    void rearrangeShared(int window, Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        int[] order = fs.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                for (int j = 0; j < window; j++) {\n+                    short a = as[i+j];\n+                    int pos = order[j];\n+                    rs[i + pos] = a;\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void rearrange064(Blackhole bh) {\n+        int window = 64 \/ Short.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange128(Blackhole bh) {\n+        int window = 128 \/ Short.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange256(Blackhole bh) {\n+        int window = 256 \/ Short.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void rearrange512(Blackhole bh) {\n+        int window = 512 \/ Short.SIZE;\n+        rearrangeShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void compressScalar(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = new short[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[j++] = as[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void expandScalar(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = new short[size];\n+        boolean[] im = fmt.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < as.length; i++) {\n+                if (im[i]) {\n+                    rs[i++] = as[j++];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void maskCompressScalar(Blackhole bh) {\n+        boolean[] im = fmt.apply(size);\n+        boolean[] rm = new boolean[size];\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0, j = 0; i < im.length; i++) {\n+                if (im[i]) {\n+                    rm[j++] = im[i];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rm);\n+    }\n+\n+    void broadcastShared(int window, Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i += window) {\n+                int idx = i;\n+                for (int j = 0; j < window; j++) {\n+                    rs[j] = as[idx];\n+                }\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void broadcast064(Blackhole bh) {\n+        int window = 64 \/ Short.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast128(Blackhole bh) {\n+        int window = 128 \/ Short.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast256(Blackhole bh) {\n+        int window = 256 \/ Short.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void broadcast512(Blackhole bh) {\n+        int window = 512 \/ Short.SIZE;\n+        broadcastShared(window, bh);\n+    }\n+\n+    @Benchmark\n+    public void zero(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                as[i] = (short)0;\n+            }\n+        }\n+\n+        bh.consume(as);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLEND(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] cs = fc.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                short c = cs[i];\n+                rs[i] = (short)((a&~(c))|(b&c));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void BITWISE_BLENDMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] bs = fb.apply(size);\n+        short[] cs = fc.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                short b = bs[i];\n+                short c = cs[i];\n+                if (ms[i % ms.length]) {\n+                    rs[i] = (short)((a&~(c))|(b&c));\n+                } else {\n+                    rs[i] = a;\n+                }\n+            }\n+        }\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void NEG(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(-((short)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NEGMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(-((short)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void ABS(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(Math.abs((short)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ABSMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(Math.abs((short)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void NOT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(~((short)a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void NOTMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(~((short)a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void ZOMO(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)((a==0?0:-1));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void ZOMOMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)((a==0?0:-1)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void BIT_COUNT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(Integer.bitCount((int)a & 0xFFFF));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void BIT_COUNTMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(Integer.bitCount((int)a & 0xFFFF)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(TRAILING_ZEROS_COUNT_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void TRAILING_ZEROS_COUNTMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(TRAILING_ZEROS_COUNT_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNT(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(LEADING_ZEROS_COUNT_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void LEADING_ZEROS_COUNTMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(LEADING_ZEROS_COUNT_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void REVERSE(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(REVERSE_scalar(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void REVERSEMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(REVERSE_scalar(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+    @Benchmark\n+    public void REVERSE_BYTES(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                rs[i] = (short)(Short.reverseBytes(a));\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+\n+    @Benchmark\n+    public void REVERSE_BYTESMasked(Blackhole bh) {\n+        short[] as = fa.apply(size);\n+        short[] rs = fr.apply(size);\n+        boolean[] ms = fm.apply(size);\n+\n+        for (int ic = 0; ic < INVOC_COUNT; ic++) {\n+            for (int i = 0; i < as.length; i++) {\n+                short a = as[i];\n+                boolean m = ms[i % ms.length];\n+                rs[i] = (m ? (short)(Short.reverseBytes(a)) : a);\n+            }\n+        }\n+\n+        bh.consume(rs);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/ShortScalar.java","additions":1945,"deletions":0,"binary":false,"changes":1945,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+import jdk.incubator.vector.*;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Inspired by \"Sorting an AVX512 register\"\n+ *   http:\/\/0x80.pl\/articles\/avx512-sort-register.html\n+ *\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class SortVector extends AbstractVectorBenchmark {\n+    @Param({\"64\", \"1024\", \"65536\"})\n+    int size;\n+\n+    int[] in, out;\n+\n+    @Setup\n+    public void setup() {\n+        size = size + (size % 16); \/\/ FIXME: process tails\n+        in  = fillInt(size, i -> RAND.nextInt());\n+        out = new int[size];\n+    }\n+\n+    @Benchmark\n+    public void sortVectorI64() {\n+        sort(I64);\n+    }\n+\n+    @Benchmark\n+    public void sortVectorI128() {\n+        sort(I128);\n+    }\n+\n+    @Benchmark\n+    public void sortVectorI256() {\n+        sort(I256);\n+    }\n+\n+    @Benchmark\n+    public void sortVectorI512() {\n+        sort(I512);\n+    }\n+\n+\n+    void sort(VectorSpecies<Integer> spec) {\n+        var iota = (IntVector) VectorShuffle.iota(spec, 0, 1, false).toVector(); \/\/ [ 0 1 ... n ]\n+\n+        var result = IntVector.broadcast(spec, 0);\n+        var index = IntVector.broadcast(spec, 0);\n+        var incr = IntVector.broadcast(spec, 1);\n+\n+        for (int i = 0; i < in.length; i += spec.length()) {\n+            var input = IntVector.fromArray(spec, in, i);\n+\n+            for (int j = 0; j < input.length(); j++) {\n+                var shuf = index.toShuffle().wrapIndexes();\n+                var b = input.rearrange(shuf); \/\/ broadcast j-th element\n+                var lt = input.lt(b).trueCount();\n+                var eq = input.eq(b).trueCount();\n+\n+                \/\/ int\/long -> mask?\n+                \/\/ int m = (1 << (lt + eq)) - (1 << lt);\n+                \/\/ var mask = masks[lt + eq].lanewise(VectorOperators.XOR, masks[lt]);\n+                \/\/ var mask = masks[lt + eq].and(masks[lt].not());\n+                \/\/\n+                \/\/ masks[i] =  [ 0 0 ... 0 1 ... 1 ]\n+                \/\/                      i-th\n+                var m = iota.lt(spec.broadcast(lt + eq)).and(iota.lt(spec.broadcast(lt)).not());\n+\n+                result = result.blend(b, m);\n+                index = index.add(incr);\n+            }\n+            result.intoArray(out, i);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/SortVector.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector.operation;\n+\n+import jdk.incubator.vector.*;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\n+\/\/ Inspired by \"SIMDized sum of all bytes in the array\"\n+\/\/   http:\/\/0x80.pl\/notesen\/2018-10-24-sse-sumbytes.html\n+\/\/\n+\/\/ C\/C++ equivalent: https:\/\/github.com\/WojciechMula\/toys\/tree\/master\/sse-sumbytes\n+\/\/\n+@BenchmarkMode(Mode.Throughput)\n+@Warmup(iterations = 3, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class SumOfUnsignedBytes extends AbstractVectorBenchmark {\n+\n+    @Param({\"64\", \"1024\", \"4096\"})\n+    int size;\n+\n+    private byte[] data;\n+\n+    @Setup\n+    public void init() {\n+        size = size + size % 32; \/\/ FIXME: process tails\n+        data = fillByte(size, i -> (byte)(int)i);\n+\n+        int sum = scalar();\n+        assert vectorInt() == sum;\n+        assert vectorShort() == sum;\n+        \/\/assert vectorByte() == sum;\n+        \/\/assert vectorSAD() == sum;\n+    }\n+\n+    @Benchmark\n+    public int scalar() {\n+        int sum = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            sum += data[i] & 0xFF;\n+        }\n+        return sum;\n+    }\n+\n+    \/\/ 1. 32-bit accumulators\n+    @Benchmark\n+    public int vectorInt() {\n+        final var lobyte_mask = IntVector.broadcast(I256, 0x000000FF);\n+\n+        var acc = IntVector.zero(I256);\n+        for (int i = 0; i < data.length; i += B256.length()) {\n+            var vb = ByteVector.fromArray(B256, data, i);\n+            var vi = (IntVector)vb.reinterpretAsInts();\n+            for (int j = 0; j < 4; j++) {\n+                var tj = vi.lanewise(VectorOperators.LSHR, j * 8).and(lobyte_mask);\n+                acc = acc.add(tj);\n+            }\n+        }\n+        return (int)Integer.toUnsignedLong(acc.reduceLanes(VectorOperators.ADD));\n+    }\n+\n+    \/\/ 2. 16-bit accumulators\n+    @Benchmark\n+    public int vectorShort() {\n+        final var lobyte_mask = ShortVector.broadcast(S256, (short) 0x00FF);\n+\n+        \/\/ FIXME: overflow\n+        var acc = ShortVector.zero(S256);\n+        for (int i = 0; i < data.length; i += B256.length()) {\n+            var vb = ByteVector.fromArray(B256, data, i);\n+            var vs = (ShortVector)vb.reinterpretAsShorts();\n+            for (int j = 0; j < 2; j++) {\n+                var tj = vs.lanewise(VectorOperators.LSHR, j * 8).and(lobyte_mask);\n+                acc = acc.add(tj);\n+            }\n+        }\n+\n+        int mid = S128.length();\n+        var accLo = ((IntVector)(acc.reinterpretShape(S128, 0).castShape(I256, 0))).and(0xFFFF); \/\/ low half as ints\n+        var accHi = ((IntVector)(acc.reinterpretShape(S128, 1).castShape(I256, 0))).and(0xFFFF); \/\/ high half as ints\n+        return accLo.reduceLanes(VectorOperators.ADD) + accHi.reduceLanes(VectorOperators.ADD);\n+    }\n+\n+    \/*\n+    \/\/ 3. 8-bit halves (MISSING: _mm_adds_epu8)\n+    @Benchmark\n+    public int vectorByte() {\n+        int window = 256;\n+        var acc_hi  = IntVector.zero(I256);\n+        var acc8_lo = ByteVector.zero(B256);\n+        for (int i = 0; i < data.length; i += window) {\n+            var acc8_hi = ByteVector.zero(B256);\n+            int limit = Math.min(window, data.length - i);\n+            for (int j = 0; j < limit; j += B256.length()) {\n+                var vb = ByteVector.fromArray(B256, data, i + j);\n+\n+                var t0 = acc8_lo.add(vb);\n+                var t1 = addSaturated(acc8_lo, vb); \/\/ MISSING\n+                var overflow = t0.notEqual(t1);\n+\n+                acc8_lo = t0;\n+                acc8_hi = acc8_hi.add((byte) 1, overflow);\n+            }\n+            acc_hi = acc_hi.add(sum(acc8_hi));\n+        }\n+        return sum(acc8_lo)\n+                .add(acc_hi.mul(256)) \/\/ overflow\n+                .addAll();\n+    }\n+\n+    \/\/ 4. Sum Of Absolute Differences (SAD) (MISSING: VPSADBW, _mm256_sad_epu8)\n+    public int vectorSAD() {\n+        var acc = IntVector.zero(I256);\n+        for (int i = 0; i < data.length; i += B256.length()) {\n+            var v = ByteVector.fromArray(B256, data, i);\n+            var sad = sumOfAbsoluteDifferences(v, ByteVector.zero(B256)); \/\/ MISSING\n+            acc = acc.add(sad);\n+        }\n+        return acc.addAll();\n+    } *\/\n+\n+    \/\/ Helpers\n+    \/*\n+    static ByteVector addSaturated(ByteVector va, ByteVector vb) {\n+        var vc = ByteVector.zero(B256);\n+        for (int i = 0; i < B256.length(); i++) {\n+            if ((va.get(i) & 0xFF) + (vb.get(i) & 0xFF) < 0xFF) {\n+                vc = vc.withLane(i, (byte)(va.get(i) + vb.get(i)));\n+            } else {\n+                vc = vc.withLane(i, (byte)0xFF);\n+            }\n+        }\n+        return vc;\n+    }\n+    IntVector sumOfAbsoluteDifferences(ByteVector va, ByteVector vb) {\n+        var vc = ByteVector.zero(B256);\n+        for (int i = 0; i < B256.length(); i++) {\n+            if ((va.get(i) & 0xFF) > (vb.get(i) & 0xFF)) {\n+                vc = vc.withLane(i, (byte)(va.get(i) - vb.get(i)));\n+            } else {\n+                vc = vc.withLane(i, (byte)(vb.get(i) - va.get(i)));\n+            }\n+        }\n+        return sum(vc);\n+    } *\/\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/operation\/SumOfUnsignedBytes.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,589 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector.utf8;\n+\n+import java.util.HashMap;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+import java.nio.Buffer;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CoderResult;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import jdk.incubator.vector.*;\n+\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@Fork(value = 1, jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+@Warmup(iterations = 5, time = 3)\n+@Measurement(iterations = 8, time = 2)\n+public class DecodeBench {\n+\n+    @Param({\"32768\", \"8388608\"})\n+    private int dataSize;\n+\n+    @Param({\"1\", \"2\", \"3\", \"4\"})\n+    private int maxBytes;\n+\n+    private ByteBuffer src;\n+    private CharBuffer dst;\n+    private String in;\n+    private String out;\n+\n+    private static final VectorSpecies<Byte>  B128 = ByteVector.SPECIES_128;\n+    private static final VectorSpecies<Short> S128 = ShortVector.SPECIES_128;\n+    private static final VectorSpecies<Short> S256 = ShortVector.SPECIES_256;\n+\n+    private static final HashMap<Long, DecoderLutEntry> lutTable = new HashMap<Long, DecoderLutEntry>();\n+\n+    private static class DecoderLutEntry {\n+        public final VectorShuffle<Byte> shufAB;   \/\/ shuffling mask to get lower two bytes of symbols\n+        public final VectorShuffle<Byte> shufC;    \/\/ shuffling mask to get third bytes of symbols\n+        public final byte srcStep;                 \/\/ number of bytes processed in input buffer\n+        public final byte dstStep;                 \/\/ number of symbols produced in output buffer (doubled)\n+        public final Vector<Byte> headerMask;      \/\/ mask of \"111..10\" bits required in each byte\n+        public final Vector<Short> zeroBits;\n+\n+        public DecoderLutEntry(VectorShuffle<Byte> _shufAB, VectorShuffle<Byte> _shufC,\n+                               byte _srcStep, byte _dstStep,\n+                               Vector<Byte> _headerMask, Vector<Short> _zeroBits) {\n+            shufAB = _shufAB;\n+            shufC = _shufC;\n+            srcStep = _srcStep;\n+            dstStep = _dstStep;\n+            headerMask = _headerMask;\n+            zeroBits = _zeroBits;\n+        }\n+\n+        \/\/ @Override\n+        \/\/ public String toString() {\n+        \/\/     return String.format(\"shufAB = %s, shufC = %s, srcStep = %d, dstStep = %d, headerMask = %s, zeroBits = %s\",\n+        \/\/         arrayToString(shufAB), arrayToString(shufC), srcStep, dstStep, arrayToString(headerMask), arrayToString(zeroBits));\n+        \/\/ }\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void setupLutTable() {\n+        int[] sizes = new int[32];\n+        computeLutRecursive(sizes, 0, 0); \/\/10609 entries total\n+\n+        \/\/ for (var entry : lutTable.entrySet()) {\n+        \/\/     System.out.println(\"\" + entry.getKey() + \" -> \" + entry.getValue());\n+        \/\/ }\n+    }\n+\n+    static void computeLutRecursive(int[] sizes, int num, int total) {\n+        if (total >= 16) {\n+            computeLutEntry(sizes, num);\n+            return;\n+        }\n+        for (int size = 1; size <= 3; size++) {\n+            sizes[num] = size;\n+            computeLutRecursive(sizes, num + 1, total + size);\n+        }\n+    }\n+\n+    static void computeLutEntry(int[] sizes, int num) {\n+        \/\/find maximal number of chars to decode\n+        int cnt = num - 1;\n+        int preSum = 0;\n+        for (int i = 0; i < cnt; i++)\n+            preSum += sizes[i];\n+        assert preSum < 16;\n+        \/\/ Note: generally, we can process a char only if the next byte is within XMM register\n+        \/\/ However, if the last char takes 3 bytes and fits the register tightly, we can take it too\n+        if (preSum == 13 && preSum + sizes[cnt] == 16)\n+            preSum += sizes[cnt++];\n+        \/\/still cannot process more that 8 chars per register\n+        while (cnt > 8)\n+            preSum -= sizes[--cnt];\n+\n+        \/\/generate bitmask\n+        long mask = 0;\n+        for (int i = 0, pos = 0; i < num; i++) {\n+            for (int j = 0; j < sizes[i]; j++, pos++) {\n+                \/\/ The first byte is not represented in the mask\n+                if (j > 0) {\n+                    mask |= 1 << pos;\n+                }\n+            }\n+        }\n+        assert mask <= 0xFFFF;\n+\n+        \/\/generate shuffle masks\n+        byte[] shufAB = new byte[16];\n+        byte[] shufC  = new byte[16];\n+        for (int i = 0; i < 16; i++)\n+            shufAB[i] = shufC[i] = (byte)0xFF;\n+        for (int i = 0, pos = 0; i < cnt; i++) {\n+            int sz = sizes[i];\n+            for (int j = sz-1; j >= 0; j--, pos++) {\n+                if (j < 2)\n+                    shufAB[2 * i + j] = (byte)pos;\n+                else\n+                    shufC[2 * i] = (byte)pos;\n+            }\n+        }\n+\n+        \/\/generate header masks for validation\n+        byte[] headerMask = new byte[16];\n+        for (int i = 0, pos = 0; i < cnt; i++) {\n+            int sz = sizes[i];\n+            for (int j = 0; j < sz; j++, pos++) {\n+                int bits;\n+                if      (j > 0)    bits = 2;\n+                else if (sz == 1)  bits = 1;\n+                else if (sz == 2)  bits = 3;\n+                else   \/*sz == 3*\/ bits = 4;\n+                headerMask[pos] = (byte)-(1 << (8 - bits));\n+            }\n+        }\n+\n+        \/\/generate min symbols values for validation\n+        short[] zeroBits = new short[8];\n+        for (int i = 0; i < 8; i++) {\n+            int sz = i < cnt ? sizes[i] : 1;\n+            if      (sz == 1)  zeroBits[i] = (short)(0xFF80);\n+            else if (sz == 2)  zeroBits[i] = (short)(0xF800);\n+            else   \/*sz == 3*\/ zeroBits[i] = (short)(0x0000);\n+        }\n+\n+        \/\/store info into the lookup table\n+        lutTable.put(mask, new DecoderLutEntry(ByteVector.fromArray(B128, shufAB, 0).toShuffle(),\n+                                               ByteVector.fromArray(B128, shufC, 0).toShuffle(),\n+                                               (byte)preSum, (byte)cnt,\n+                                               ByteVector.fromArray(B128, headerMask, 0),\n+                                               ShortVector.fromArray(S128, zeroBits, 0)));\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void setup() {\n+        in = randomString(dataSize, maxBytes);\n+        src = ByteBuffer.wrap(in.getBytes());\n+        dst = CharBuffer.allocate(in.length());\n+    }\n+\n+    @Setup(Level.Invocation)\n+    public void setupInvocation() {\n+        src.clear();\n+        dst.clear();\n+    }\n+\n+    @TearDown(Level.Invocation)\n+    public void tearDownInvocation() {\n+        out = new String(dst.array());\n+        if (!in.equals(out)) {\n+            System.out.println(\"in  = (\" + in.length() + \") \\\"\" + arrayToString(in.getBytes()) + \"\\\"\");\n+            System.out.println(\"out = (\" + out.length() + \") \\\"\" + arrayToString(out.getBytes()) + \"\\\"\");\n+            throw new RuntimeException(\"Incorrect result\");\n+        }\n+    }\n+\n+    private static final Random RANDOM = new Random(0);\n+    private static int randomInt(int min \/* inclusive *\/, int max \/* inclusive *\/) {\n+        return RANDOM.nextInt(max - min + 1) + min;\n+    }\n+    private static String randomString(int dataSize, int maxBytes) {\n+        ByteBuffer buf = ByteBuffer.allocate(dataSize);\n+        for (int i = 0, size = randomInt(1, maxBytes); i + size - 1 < dataSize; i += size, size = randomInt(1, maxBytes)) {\n+            int b1, b2, b3, b4;\n+            switch (size) {\n+            case 1: {\n+                b1 = randomInt(0x00, 0x7F);\n+                buf.put(i + 0, (byte)((0b0     << (8 - 1)) | b1));\n+                break;\n+            }\n+            case 2: {\n+                b1 = randomInt(0xC2, 0xDF);\n+                b2 = randomInt(0x80, 0xBF);\n+                buf.put(i + 0, (byte)((0b110   << (8 - 3)) | b1));\n+                buf.put(i + 1, (byte)((0b10    << (8 - 2)) | b2));\n+                break;\n+            }\n+            case 3: {\n+                b1 = randomInt(0xE0, 0xEF);\n+                switch (b1) {\n+                case 0xE0:\n+                    b2 = randomInt(0xA0, 0xBF);\n+                    b3 = randomInt(0x80, 0xBF);\n+                    break;\n+                default:\n+                    b2 = randomInt(0x80, 0xBF);\n+                    b3 = randomInt(0x80, 0xBF);\n+                    break;\n+                }\n+                buf.put(i + 0, (byte)((0b1110  << (8 - 4)) | b1));\n+                buf.put(i + 1, (byte)((0b10    << (8 - 2)) | b2));\n+                buf.put(i + 2, (byte)((0b10    << (8 - 2)) | b3));\n+                break;\n+            }\n+            case 4: {\n+                b1 = randomInt(0xF0, 0xF4);\n+                switch (b1) {\n+                case 0xF0:\n+                    b2 = randomInt(0x90, 0xBF);\n+                    b3 = randomInt(0x80, 0xBF);\n+                    b4 = randomInt(0x80, 0xBF);\n+                    break;\n+                case 0xF4:\n+                    b2 = randomInt(0x80, 0x8F);\n+                    b3 = randomInt(0x80, 0xBF);\n+                    b4 = randomInt(0x80, 0xBF);\n+                    break;\n+                default:\n+                    b2 = randomInt(0x80, 0xBF);\n+                    b3 = randomInt(0x80, 0xBF);\n+                    b4 = randomInt(0x80, 0xBF);\n+                    break;\n+                }\n+                buf.put(i + 0, (byte)((0b11110 << (8 - 5)) | b1));\n+                buf.put(i + 1, (byte)((0b10    << (8 - 2)) | b2));\n+                buf.put(i + 2, (byte)((0b10    << (8 - 2)) | b3));\n+                buf.put(i + 3, (byte)((0b10    << (8 - 2)) | b4));\n+                break;\n+            }\n+            default:\n+                throw new RuntimeException(\"not supported\");\n+            }\n+        }\n+        return new String(buf.array(), Charset.forName(\"UTF-8\"));\n+    }\n+\n+    private static String arrayToString(byte[] array) {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"[\");\n+        for (int i = 0; i < array.length; ++i) {\n+            if (i != 0) sb.append(\",\");\n+            sb.append(String.format(\"%x\", (byte)array[i]));\n+        }\n+        sb.append(\"]\");\n+        return sb.toString();\n+    }\n+\n+    @Benchmark\n+    public void decodeScalar() {\n+        decodeArrayLoop(src, dst);\n+    }\n+\n+    @Benchmark\n+    public void decodeVector() {\n+        decodeArrayVectorized(src, dst);\n+        decodeArrayLoop(src, dst);\n+    }\n+\n+    @Benchmark\n+    public void decodeVectorASCII() {\n+        decodeArrayVectorizedASCII(src, dst);\n+        decodeArrayLoop(src, dst);\n+    }\n+\n+    private static void decodeArrayVectorized(ByteBuffer src, CharBuffer dst) {\n+        \/\/ Algorithm is largely inspired from https:\/\/dirtyhandscoding.github.io\/posts\/utf8lut-vectorized-utf-8-converter-introduction.html\n+\n+        byte[] sa = src.array();\n+        int sp = src.arrayOffset() + src.position();\n+        int sl = src.arrayOffset() + src.limit();\n+\n+        char[] da = dst.array();\n+        int dp = dst.arrayOffset() + dst.position();\n+        int dl = dst.arrayOffset() + dst.limit();\n+\n+        \/\/ Vectorized loop\n+        while (sp + B128.length() < sl && dp + S128.length() < dl) {\n+            var bytes = ByteVector.fromArray(B128, sa, sp);\n+\n+            \/* Decode *\/\n+\n+            var continuationByteMask = bytes.lanewise(VectorOperators.AND, (byte)0xC0).compare(VectorOperators.EQ, (byte)0x80);\n+            final DecoderLutEntry lookup = lutTable.get(continuationByteMask.toLong());\n+            if (lookup == null) {\n+                break;\n+            }\n+            \/\/ Shuffle the 1st and 2nd bytes\n+            var Rab = bytes.rearrange(lookup.shufAB, lookup.shufAB.toVector().compare(VectorOperators.NE, -1)).reinterpretAsShorts();\n+            \/\/ Shuffle the 3rd byte\n+            var Rc  = bytes.rearrange(lookup.shufC, lookup.shufC.toVector().compare(VectorOperators.NE, -1)).reinterpretAsShorts();\n+            \/\/ Extract the bits from each byte\n+            var sum = Rab.lanewise(VectorOperators.AND, (short)0x007F)\n+                 .add(Rab.lanewise(VectorOperators.AND, (short)0x3F00).lanewise(VectorOperators.LSHR, 2))\n+                 .add(Rc.lanewise(VectorOperators.LSHL, 12));\n+\n+            \/* Validate *\/\n+\n+            var zeroBits = lookup.zeroBits;\n+            if (sum.lanewise(VectorOperators.AND, zeroBits).compare(VectorOperators.NE, 0).anyTrue()) {\n+                break;\n+            }\n+            \/\/ Check for surrogate code point\n+            if (sum.lanewise(VectorOperators.SUB, (short)0x6000).compare(VectorOperators.GT, 0x77FF).anyTrue()) {\n+                break;\n+            }\n+            var headerMask = lookup.headerMask;\n+            if (bytes.lanewise(VectorOperators.AND, headerMask).compare(VectorOperators.NE, headerMask.lanewise(VectorOperators.LSHL, 1)).anyTrue()) {\n+                break;\n+            }\n+\n+            \/* Advance *\/\n+\n+            ((ShortVector)sum).intoCharArray(da, dp);\n+            sp += lookup.srcStep;\n+            dp += lookup.dstStep;\n+        }\n+\n+        updatePositions(src, sp, dst, dp);\n+    }\n+\n+    private static void decodeArrayVectorizedASCII(ByteBuffer src, CharBuffer dst) {\n+        byte[] sa = src.array();\n+        int sp = src.arrayOffset() + src.position();\n+        int sl = src.arrayOffset() + src.limit();\n+\n+        char[] da = dst.array();\n+        int dp = dst.arrayOffset() + dst.position();\n+        int dl = dst.arrayOffset() + dst.limit();\n+\n+        \/\/ Vectorized loop\n+        for (; sp <= sl - B128.length() && dp <= dl - S256.length(); sp += B128.length(), dp += S256.length()) {\n+            var bytes = ByteVector.fromArray(B128, sa, sp);\n+\n+            if (bytes.compare(VectorOperators.LT, (byte) 0x00).anyTrue())\n+                break;\n+\n+            ((ShortVector) bytes.convertShape(VectorOperators.B2S, S256, 0)).intoCharArray(da, dp);\n+        }\n+\n+        updatePositions(src, sp, dst, dp);\n+    }\n+\n+    private static CoderResult decodeArrayLoop(ByteBuffer src, CharBuffer dst) {\n+        \/\/ This method is optimized for ASCII input.\n+        byte[] sa = src.array();\n+        int sp = src.arrayOffset() + src.position();\n+        int sl = src.arrayOffset() + src.limit();\n+\n+        char[] da = dst.array();\n+        int dp = dst.arrayOffset() + dst.position();\n+        int dl = dst.arrayOffset() + dst.limit();\n+        int dlASCII = dp + Math.min(sl - sp, dl - dp);\n+\n+        \/\/ ASCII only loop\n+        while (dp < dlASCII && sa[sp] >= 0)\n+            da[dp++] = (char) sa[sp++];\n+        while (sp < sl) {\n+            int b1 = sa[sp];\n+            if (b1 >= 0) {\n+                \/\/ 1 byte, 7 bits: 0xxxxxxx\n+                if (dp >= dl)\n+                    return xflow(src, sp, sl, dst, dp, 1);\n+                da[dp++] = (char) b1;\n+                sp++;\n+            } else if ((b1 >> 5) == -2 && (b1 & 0x1e) != 0) {\n+                \/\/ 2 bytes, 11 bits: 110xxxxx 10xxxxxx\n+                \/\/                   [C2..DF] [80..BF]\n+                if (sl - sp < 2 || dp >= dl)\n+                    return xflow(src, sp, sl, dst, dp, 2);\n+                int b2 = sa[sp + 1];\n+                \/\/ Now we check the first byte of 2-byte sequence as\n+                \/\/     if ((b1 >> 5) == -2 && (b1 & 0x1e) != 0)\n+                \/\/ no longer need to check b1 against c1 & c0 for\n+                \/\/ malformed as we did in previous version\n+                \/\/   (b1 & 0x1e) == 0x0 || (b2 & 0xc0) != 0x80;\n+                \/\/ only need to check the second byte b2.\n+                if (isNotContinuation(b2))\n+                    return malformedForLength(src, sp, dst, dp, 1);\n+                da[dp++] = (char) (((b1 << 6) ^ b2)\n+                                   ^\n+                                   (((byte) 0xC0 << 6) ^\n+                                    ((byte) 0x80 << 0)));\n+                sp += 2;\n+            } else if ((b1 >> 4) == -2) {\n+                \/\/ 3 bytes, 16 bits: 1110xxxx 10xxxxxx 10xxxxxx\n+                int srcRemaining = sl - sp;\n+                if (srcRemaining < 3 || dp >= dl) {\n+                    if (srcRemaining > 1 && isMalformed3_2(b1, sa[sp + 1]))\n+                        return malformedForLength(src, sp, dst, dp, 1);\n+                    return xflow(src, sp, sl, dst, dp, 3);\n+                }\n+                int b2 = sa[sp + 1];\n+                int b3 = sa[sp + 2];\n+                if (isMalformed3(b1, b2, b3))\n+                    return malformed(src, sp, dst, dp, 3);\n+                char c = (char)\n+                    ((b1 << 12) ^\n+                     (b2 <<  6) ^\n+                     (b3 ^\n+                      (((byte) 0xE0 << 12) ^\n+                       ((byte) 0x80 <<  6) ^\n+                       ((byte) 0x80 <<  0))));\n+                if (Character.isSurrogate(c))\n+                    return malformedForLength(src, sp, dst, dp, 3);\n+                da[dp++] = c;\n+                sp += 3;\n+            } else if ((b1 >> 3) == -2) {\n+                \/\/ 4 bytes, 21 bits: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n+                int srcRemaining = sl - sp;\n+                if (srcRemaining < 4 || dl - dp < 2) {\n+                    b1 &= 0xff;\n+                    if (b1 > 0xf4 ||\n+                        srcRemaining > 1 && isMalformed4_2(b1, sa[sp + 1] & 0xff))\n+                        return malformedForLength(src, sp, dst, dp, 1);\n+                    if (srcRemaining > 2 && isMalformed4_3(sa[sp + 2]))\n+                        return malformedForLength(src, sp, dst, dp, 2);\n+                    return xflow(src, sp, sl, dst, dp, 4);\n+                }\n+                int b2 = sa[sp + 1];\n+                int b3 = sa[sp + 2];\n+                int b4 = sa[sp + 3];\n+                int uc = ((b1 << 18) ^\n+                          (b2 << 12) ^\n+                          (b3 <<  6) ^\n+                          (b4 ^\n+                           (((byte) 0xF0 << 18) ^\n+                            ((byte) 0x80 << 12) ^\n+                            ((byte) 0x80 <<  6) ^\n+                            ((byte) 0x80 <<  0))));\n+                if (isMalformed4(b2, b3, b4) ||\n+                    \/\/ shortest form check\n+                    !Character.isSupplementaryCodePoint(uc)) {\n+                    return malformed(src, sp, dst, dp, 4);\n+                }\n+                da[dp++] = Character.highSurrogate(uc);\n+                da[dp++] = Character.lowSurrogate(uc);\n+                sp += 4;\n+            } else\n+                return malformed(src, sp, dst, dp, 1);\n+        }\n+        return xflow(src, sp, sl, dst, dp, 0);\n+    }\n+\n+    private static CoderResult xflow(Buffer src, int sp, int sl,\n+                                     Buffer dst, int dp, int nb) {\n+        updatePositions(src, sp, dst, dp);\n+        return (nb == 0 || sl - sp < nb)\n+               ? CoderResult.UNDERFLOW : CoderResult.OVERFLOW;\n+    }\n+\n+    private static CoderResult malformedForLength(ByteBuffer src,\n+                                                  int sp,\n+                                                  CharBuffer dst,\n+                                                  int dp,\n+                                                  int malformedNB)\n+    {\n+        updatePositions(src, sp, dst, dp);\n+        return CoderResult.malformedForLength(malformedNB);\n+    }\n+\n+    private static CoderResult malformed(ByteBuffer src, int sp,\n+                                         CharBuffer dst, int dp,\n+                                         int nb)\n+    {\n+        src.position(sp - src.arrayOffset());\n+        CoderResult cr = malformedN(src, sp, nb);\n+        updatePositions(src, sp, dst, dp);\n+        return cr;\n+    }\n+\n+    private static CoderResult malformedN(ByteBuffer src, int sp,\n+                                          int nb) {\n+        switch (nb) {\n+        case 1:\n+        case 2:                    \/\/ always 1\n+            return CoderResult.malformedForLength(1);\n+        case 3:\n+            int b1 = src.get();\n+            int b2 = src.get();    \/\/ no need to lookup b3\n+            return CoderResult.malformedForLength(\n+                ((b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+                 isNotContinuation(b2)) ? 1 : 2);\n+        case 4:  \/\/ we don't care the speed here\n+            b1 = src.get() & 0xff;\n+            b2 = src.get() & 0xff;\n+            if (b1 > 0xf4 ||\n+                (b1 == 0xf0 && (b2 < 0x90 || b2 > 0xbf)) ||\n+                (b1 == 0xf4 && (b2 & 0xf0) != 0x80) ||\n+                isNotContinuation(b2))\n+                return CoderResult.malformedForLength(1);\n+            if (isNotContinuation(src.get()))\n+                return CoderResult.malformedForLength(2);\n+            return CoderResult.malformedForLength(3);\n+        default:\n+            assert false;\n+            return null;\n+        }\n+    }\n+\n+    private static boolean isNotContinuation(int b) {\n+        return (b & 0xc0) != 0x80;\n+    }\n+\n+    \/\/  [E0]     [A0..BF] [80..BF]\n+    \/\/  [E1..EF] [80..BF] [80..BF]\n+    private static boolean isMalformed3(int b1, int b2, int b3) {\n+        return (b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+               (b2 & 0xc0) != 0x80 || (b3 & 0xc0) != 0x80;\n+    }\n+\n+    \/\/ only used when there is only one byte left in src buffer\n+    private static boolean isMalformed3_2(int b1, int b2) {\n+        return (b1 == (byte)0xe0 && (b2 & 0xe0) == 0x80) ||\n+               (b2 & 0xc0) != 0x80;\n+    }\n+\n+    \/\/  [F0]     [90..BF] [80..BF] [80..BF]\n+    \/\/  [F1..F3] [80..BF] [80..BF] [80..BF]\n+    \/\/  [F4]     [80..8F] [80..BF] [80..BF]\n+    \/\/  only check 80-be range here, the [0xf0,0x80...] and [0xf4,0x90-...]\n+    \/\/  will be checked by Character.isSupplementaryCodePoint(uc)\n+    private static boolean isMalformed4(int b2, int b3, int b4) {\n+        return (b2 & 0xc0) != 0x80 || (b3 & 0xc0) != 0x80 ||\n+               (b4 & 0xc0) != 0x80;\n+    }\n+\n+    \/\/ only used when there is less than 4 bytes left in src buffer.\n+    \/\/ both b1 and b2 should be \"& 0xff\" before passed in.\n+    private static boolean isMalformed4_2(int b1, int b2) {\n+        return (b1 == 0xf0 && (b2  < 0x90 || b2 > 0xbf)) ||\n+               (b1 == 0xf4 && (b2 & 0xf0) != 0x80) ||\n+               (b2 & 0xc0) != 0x80;\n+    }\n+\n+    \/\/ tests if b1 and b2 are malformed as the first 2 bytes of a\n+    \/\/ legal`4-byte utf-8 byte sequence.\n+    \/\/ only used when there is less than 4 bytes left in src buffer,\n+    \/\/ after isMalformed4_2 has been invoked.\n+    private static boolean isMalformed4_3(int b3) {\n+        return (b3 & 0xc0) != 0x80;\n+    }\n+\n+    private static void updatePositions(Buffer src, int sp,\n+                                        Buffer dst, int dp) {\n+        src.position(sp - src.arrayOffset());\n+        dst.position(dp - dst.arrayOffset());\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/utf8\/DecodeBench.java","additions":589,"deletions":0,"binary":false,"changes":589,"status":"added"}]}