{"files":[{"patch":"@@ -359,0 +359,8 @@\n+  # Check if it's GNU date\n+  check_date=`$DATE --version 2>&1 | $GREP GNU`\n+  if test \"x$check_date\" != x; then\n+    IS_GNU_DATE=yes\n+  else\n+    IS_GNU_DATE=no\n+  fi\n+\n","filename":"make\/autoconf\/basic_tools.m4","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,3 +37,4 @@\n-      # distinguishing between WSL1 and WSL2. Assume only WSL2 has WSL_INTEROP\n-      # in \/run\/WSL\n-      if test -d \"\/run\/WSL\" ; then\n+      # distinguishing between WSL1 and WSL2.\n+      # Check whether \"Hyper-V\" appears in \/proc\/interrupts because WSL2 runs on Hyper-V.\n+      $GREP -q Hyper-V \/proc\/interrupts\n+      if test $? -eq 0; then\n","filename":"make\/autoconf\/basic_windows.m4","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -202,0 +202,6 @@\n+  elif test \"x$SOURCE_DATE_EPOCH\" != x; then\n+    if test \"x$IS_GNU_DATE\" = xyes; then\n+      COPYRIGHT_YEAR=`date --date=@$SOURCE_DATE_EPOCH +%Y`\n+    else\n+      COPYRIGHT_YEAR=`date -j -f %s $SOURCE_DATE_EPOCH +%Y`\n+    fi\n","filename":"make\/autoconf\/jdk-options.m4","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -310,1 +310,2 @@\n-        test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" ; then\n+        test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" || \\\n+        test \"x$OPENJDK_TARGET_CPU\" = \"xppc64le\"; then\n","filename":"make\/autoconf\/jvm-features.m4","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1157,1 +1157,1 @@\n-            revision: \"1.28+1.0\"\n+            revision: \"1.33+1.0\"\n","filename":"make\/conf\/jib-profiles.js","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -152,0 +152,1 @@\n+        $d\/cpu\/$(HOTSPOT_TARGET_CPU_ARCH)\/gc\/shenandoah\/shenandoah_$(HOTSPOT_TARGET_CPU_ARCH).ad \\\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+    static int copyrightYear;\n@@ -220,0 +221,4 @@\n+                    case \"-year\":\n+                        copyrightYear = Integer.parseInt(args[++i]);\n+                        break;\n+\n@@ -238,1 +243,1 @@\n-                severe(\"unknown or imcomplete arg(s): \" + currentArg);\n+                severe(\"unknown or incomplete arg(s): \" + currentArg);\n@@ -263,0 +268,4 @@\n+        if (copyrightYear == 0) {\n+            copyrightYear = ZonedDateTime.now(ZoneId.of(\"America\/Los_Angeles\")).getYear();\n+        }\n+\n@@ -295,0 +304,1 @@\n+                + \"\\t-year year     copyright year in output%n\"\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/CLDRConverter.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Date;\n@@ -134,2 +135,1 @@\n-    static String getOracleCopyright() {\n-        int year = getYear();\n+    static String getOracleCopyright(int year) {\n@@ -143,2 +143,1 @@\n-    static String getOpenJDKCopyright() {\n-        int year = getYear();\n+    static String getOpenJDKCopyright(int year) {\n@@ -148,5 +147,0 @@\n-    private static int getYear() {\n-        return new GregorianCalendar(TimeZone.getTimeZone(\"America\/Los_Angeles\"),\n-                                         Locale.US).get(Calendar.YEAR);\n-    }\n-\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/CopyrightHeaders.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n-            out.println(CopyrightHeaders.getOpenJDKCopyright());\n+            out.println(CopyrightHeaders.getOpenJDKCopyright(CLDRConverter.copyrightYear));\n@@ -269,1 +269,1 @@\n-            out.printf(CopyrightHeaders.getOpenJDKCopyright());\n+            out.printf(CopyrightHeaders.getOpenJDKCopyright(CLDRConverter.copyrightYear));\n","filename":"make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/ResourceBundleGenerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-import java.time.ZoneId;\n-import java.time.ZonedDateTime;\n@@ -36,0 +34,3 @@\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n@@ -39,0 +40,1 @@\n+import java.util.TimeZone;\n@@ -54,1 +56,1 @@\n-        if (args.length != 2) {\n+        if (args.length != 3) {\n@@ -56,1 +58,1 @@\n-                    + \" language-subtag-registry.txt LocaleEquivalentMaps.java\");\n+                    + \" language-subtag-registry.txt LocaleEquivalentMaps.java copyrightYear\");\n@@ -59,0 +61,1 @@\n+        copyrightYear = Integer.parseInt(args[2]);\n@@ -65,0 +68,1 @@\n+    private static int copyrightYear;\n@@ -247,3 +251,1 @@\n-        int year = ZonedDateTime.now(ZoneId\n-                .of(\"America\/Los_Angeles\")).getYear();\n-        return String.format(Locale.US, COPYRIGHT, year);\n+        return String.format(Locale.US, COPYRIGHT, copyrightYear);\n","filename":"make\/jdk\/src\/classes\/build\/tools\/generatelsrequivmaps\/EquivMapsGenerator.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+\t    -year $(COPYRIGHT_YEAR) \\\n@@ -102,1 +103,1 @@\n-\t$(TOOL_GENERATELSREQUIVMAPS) $< $@\n+\t$(TOOL_GENERATELSREQUIVMAPS) $< $@ $(COPYRIGHT_YEAR)\n","filename":"make\/modules\/java.base\/Gensrc.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-      NAME := jpackageapplauncher, \\\n+      NAME := jpackageapplauncheraux, \\\n@@ -97,1 +97,1 @@\n-      SYMBOLS_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/libjpackageapplauncher, \\\n+      SYMBOLS_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/libjpackageapplauncheraux, \\\n","filename":"make\/modules\/jdk.jpackage\/Lib.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+\t    -year $(COPYRIGHT_YEAR) \\\n","filename":"make\/modules\/jdk.localedata\/Gensrc.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1202,0 +1202,3 @@\n+reg_class p0_reg(P0);\n+reg_class p1_reg(P1);\n+\n@@ -2689,0 +2692,41 @@\n+bool can_combine_with_imm(Node* binary_node, Node* replicate_node) {\n+  if (UseSVE == 0 || !VectorNode::is_invariant_vector(replicate_node)){\n+    return false;\n+  }\n+  Node* imm_node = replicate_node->in(1);\n+  if (!imm_node->is_Con()) {\n+    return false;\n+  }\n+\n+  const Type* t = imm_node->bottom_type();\n+  if (!(t->isa_int() || t->isa_long())) {\n+    return false;\n+  }\n+\n+  switch (binary_node->Opcode()) {\n+  case Op_AndV:\n+  case Op_OrV:\n+  case Op_XorV: {\n+    Assembler::SIMD_RegVariant T = Assembler::elemType_to_regVariant(Matcher::vector_element_basic_type(binary_node));\n+    uint64_t value = t->isa_long() ? (uint64_t)imm_node->get_long() : (uint64_t)imm_node->get_int();\n+    return Assembler::operand_valid_for_sve_logical_immediate(Assembler::regVariant_to_elemBits(T), value);\n+  }\n+  case Op_AddVB:\n+    return (imm_node->get_int() <= 255 && imm_node->get_int() >= -255);\n+  case Op_AddVS:\n+  case Op_AddVI:\n+    return Assembler::operand_valid_for_sve_add_sub_immediate((int64_t)imm_node->get_int());\n+  case Op_AddVL:\n+    return Assembler::operand_valid_for_sve_add_sub_immediate(imm_node->get_long());\n+  default:\n+    return false;\n+  }\n+}\n+\n+bool is_vector_arith_imm_pattern(Node* n, Node* m) {\n+  if (n != NULL && m != NULL) {\n+    return can_combine_with_imm(n, m);\n+  }\n+  return false;\n+}\n+\n@@ -2693,0 +2737,1 @@\n+  \/\/ Binary src (Replicate con)\n@@ -2694,1 +2739,2 @@\n-      (UseSVE > 0 && m->Opcode() == Op_VectorStoreMask && n->Opcode() == Op_StoreVector)) {\n+      (UseSVE > 0 && m->Opcode() == Op_VectorStoreMask && n->Opcode() == Op_StoreVector) ||\n+      is_vector_arith_imm_pattern(n, m)) {\n@@ -3906,1 +3952,1 @@\n-               \/*release*\/ true, \/*weak*\/ false, noreg); \/\/ Sets flags for result\n+               \/*release*\/ true, \/*weak*\/ false, rscratch1); \/\/ Sets flags for result\n@@ -3915,0 +3961,9 @@\n+    __ br(Assembler::EQ, cont); \/\/ CAS success means locking succeeded\n+\n+    __ cmp(rscratch1, rthread);\n+    __ br(Assembler::NE, cont); \/\/ Check for recursive locking\n+\n+    \/\/ Recursive lock case\n+    __ increment(Address(disp_hdr, ObjectMonitor::recursions_offset_in_bytes() - markWord::monitor_value), 1);\n+    \/\/ flag == EQ still from the cmp above, checking if this is a reentrant lock\n+\n@@ -3958,3 +4013,3 @@\n-    __ eor(rscratch1, rscratch1, rthread); \/\/ Will be 0 if we are the owner.\n-    __ orr(rscratch1, rscratch1, disp_hdr); \/\/ Will be 0 if there are 0 recursions\n-    __ cmp(rscratch1, zr); \/\/ Sets flags for result\n+\n+    Label notRecursive;\n+    __ cmp(rscratch1, rthread);\n@@ -3963,0 +4018,9 @@\n+    __ cbz(disp_hdr, notRecursive);\n+\n+    \/\/ Recursive lock\n+    __ sub(disp_hdr, disp_hdr, 1u);\n+    __ str(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset_in_bytes()));\n+    \/\/ flag == EQ was set in the ownership check above\n+    __ b(cont);\n+\n+    __ bind(notRecursive);\n@@ -4615,0 +4679,11 @@\n+\/\/ 8 bit integer valid for vector add sub immediate\n+operand immBAddSubV()\n+%{\n+  predicate(n->get_int() <= 255 && n->get_int() >= -255);\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -4625,0 +4700,11 @@\n+\/\/ 32 bit integer valid for vector add sub immediate\n+operand immIAddSubV()\n+%{\n+  predicate(Assembler::operand_valid_for_sve_add_sub_immediate((int64_t)n->get_int()));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -4626,1 +4712,21 @@\n-\/\/ TODO -- check this is right when e.g the mask is 0x80000000\n+\n+operand immBLog()\n+%{\n+  predicate(Assembler::operand_valid_for_sve_logical_immediate(BitsPerByte, (uint64_t)n->get_int()));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immSLog()\n+%{\n+  predicate(Assembler::operand_valid_for_sve_logical_immediate(BitsPerShort, (uint64_t)n->get_int()));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -4704,0 +4810,11 @@\n+\/\/ 64 bit integer valid for addv subv immediate\n+operand immLAddSubV()\n+%{\n+  predicate(Assembler::operand_valid_for_sve_add_sub_immediate(n->get_long()));\n+  match(ConL);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -5572,0 +5689,18 @@\n+operand pRegGov_P0()\n+%{\n+  constraint(ALLOC_IN_RC(p0_reg));\n+  match(RegVectMask);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n+operand pRegGov_P1()\n+%{\n+  constraint(ALLOC_IN_RC(p1_reg));\n+  match(RegVectMask);\n+  op_cost(0);\n+  format %{ %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -16550,1 +16685,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU));\n@@ -16560,1 +16695,1 @@\n-                      fnoreg, fnoreg, fnoreg, StrIntrinsicNode::UU);\n+                      fnoreg, fnoreg, fnoreg, pnoreg, pnoreg, StrIntrinsicNode::UU);\n@@ -16568,1 +16703,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL));\n@@ -16577,1 +16712,1 @@\n-                      fnoreg, fnoreg, fnoreg, StrIntrinsicNode::LL);\n+                      fnoreg, fnoreg, fnoreg, pnoreg, pnoreg, StrIntrinsicNode::LL);\n@@ -16586,1 +16721,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n+  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL));\n@@ -16597,1 +16732,1 @@\n-                      $vtmp3$$FloatRegister, StrIntrinsicNode::UL);\n+                      $vtmp3$$FloatRegister, pnoreg, pnoreg, StrIntrinsicNode::UL);\n@@ -16606,1 +16741,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n+  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU));\n@@ -16617,1 +16752,1 @@\n-                      $vtmp3$$FloatRegister,StrIntrinsicNode::LU);\n+                      $vtmp3$$FloatRegister, pnoreg, pnoreg, StrIntrinsicNode::LU);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":149,"deletions":14,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -940,0 +940,211 @@\n+\/\/ vector add reg imm (unpredicated)\n+\n+instruct vaddImmB(vReg dst_src, immBAddSubV con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddVB dst_src (ReplicateB con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    int32_t val = $con$$constant;\n+    if (val > 0){\n+      __ sve_add(as_FloatRegister($dst_src$$reg), __ B, val);\n+    } else if (val < 0){\n+      __ sve_sub(as_FloatRegister($dst_src$$reg), __ B, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddImmS(vReg dst_src, immIAddSubV con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddVS dst_src (ReplicateS con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    int32_t val = $con$$constant;\n+    if (val > 0){\n+      __ sve_add(as_FloatRegister($dst_src$$reg), __ H, val);\n+    } else if (val < 0){\n+      __ sve_sub(as_FloatRegister($dst_src$$reg), __ H, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddImmI(vReg dst_src, immIAddSubV con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddVI dst_src (ReplicateI con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    int32_t val = $con$$constant;\n+    if (val > 0){\n+      __ sve_add(as_FloatRegister($dst_src$$reg), __ S, val);\n+    } else if (val < 0){\n+      __ sve_sub(as_FloatRegister($dst_src$$reg), __ S, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddImmL(vReg dst_src, immLAddSubV con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddVL dst_src (ReplicateL con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    int32_t val = $con$$constant;\n+    if (val > 0){\n+      __ sve_add(as_FloatRegister($dst_src$$reg), __ D, val);\n+    } else if (val < 0){\n+      __ sve_sub(as_FloatRegister($dst_src$$reg), __ D, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector binary op reg imm (unpredicated)\n+\n+instruct vandB(vReg dst_src, immBLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AndV dst_src (ReplicateB con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_and $dst_src, $dst_src, $con\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_and(as_FloatRegister($dst_src$$reg), __ B,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vandH(vReg dst_src, immSLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AndV dst_src (ReplicateS con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_and $dst_src, $dst_src, $con\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_and(as_FloatRegister($dst_src$$reg), __ H,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vandS(vReg dst_src, immILog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AndV dst_src (ReplicateI con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_and $dst_src, $dst_src, $con\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_and(as_FloatRegister($dst_src$$reg), __ S,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vandD(vReg dst_src, immLLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AndV dst_src (ReplicateL con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_and $dst_src, $dst_src, $con\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_and(as_FloatRegister($dst_src$$reg), __ D,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vorB(vReg dst_src, immBLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (OrV dst_src (ReplicateB con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_orr $dst_src, $dst_src, $con\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_orr(as_FloatRegister($dst_src$$reg), __ B,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vorH(vReg dst_src, immSLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (OrV dst_src (ReplicateS con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_orr $dst_src, $dst_src, $con\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_orr(as_FloatRegister($dst_src$$reg), __ H,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vorS(vReg dst_src, immILog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (OrV dst_src (ReplicateI con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_orr $dst_src, $dst_src, $con\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_orr(as_FloatRegister($dst_src$$reg), __ S,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vorD(vReg dst_src, immLLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (OrV dst_src (ReplicateL con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_orr $dst_src, $dst_src, $con\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_orr(as_FloatRegister($dst_src$$reg), __ D,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxorB(vReg dst_src, immBLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV dst_src (ReplicateB con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_eor $dst_src, $dst_src, $con\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_eor(as_FloatRegister($dst_src$$reg), __ B,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxorH(vReg dst_src, immSLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV dst_src (ReplicateS con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_eor $dst_src, $dst_src, $con\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_eor(as_FloatRegister($dst_src$$reg), __ H,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxorS(vReg dst_src, immILog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV dst_src (ReplicateI con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_eor $dst_src, $dst_src, $con\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_eor(as_FloatRegister($dst_src$$reg), __ S,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxorD(vReg dst_src, immLLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV dst_src (ReplicateL con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_eor $dst_src, $dst_src, $con\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_eor(as_FloatRegister($dst_src$$reg), __ D,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -5345,0 +5556,99 @@\n+\/\/ Intrisics for String.compareTo()\n+\n+\/\/ Note that Z registers alias the corresponding NEON registers, we declare the vector operands of\n+\/\/ these string_compare variants as NEON register type for convenience so that the prototype of\n+\/\/ string_compare can be shared with all variants.\n+\n+\n+instruct string_compareLL_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::LL);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct string_compareLU_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::LU);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct string_compareUL_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::UL);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n+instruct string_compareUU_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::UU);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":310,"deletions":0,"binary":false,"changes":310,"status":"modified"},{"patch":"@@ -608,0 +608,19 @@\n+dnl\n+dnl ADD_IMM($1,          $2,   $3      )\n+dnl ADD_IMM(name_suffix, size, imm_type)\n+define(`ADD_IMM', `\n+instruct vaddImm$1(vReg dst_src, $3 con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddV$1 dst_src (Replicate$1 con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    int32_t val = $con$$constant;\n+    if (val > 0){\n+      __ sve_add(as_FloatRegister($dst_src$$reg), __ $2, val);\n+    } else if (val < 0){\n+      __ sve_sub(as_FloatRegister($dst_src$$reg), __ $2, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n@@ -609,0 +628,35 @@\n+\/\/ vector add reg imm (unpredicated)\n+ADD_IMM(B, B, immBAddSubV)\n+ADD_IMM(S, H, immIAddSubV)\n+ADD_IMM(I, S, immIAddSubV)\n+ADD_IMM(L, D, immLAddSubV)\n+dnl\n+dnl BITWISE_OP_IMM($1,        $2        $3,   $4    $5      )\n+dnl BITWISE_OP_IMM(insn_name, op_name1, size, type, op_name2)\n+define(`BITWISE_OP_IMM', `\n+instruct $1(vReg dst_src, imm$4Log con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src ($2 dst_src (Replicate$4 con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"$5 $dst_src, $dst_src, $con\\t # vector (sve) ($3)\" %}\n+  ins_encode %{\n+    __ $5(as_FloatRegister($dst_src$$reg), __ $3,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+\/\/ vector binary op reg imm (unpredicated)\n+BITWISE_OP_IMM(vandB, AndV, B, B, sve_and)\n+BITWISE_OP_IMM(vandH, AndV, H, S, sve_and)\n+BITWISE_OP_IMM(vandS, AndV, S, I, sve_and)\n+BITWISE_OP_IMM(vandD, AndV, D, L, sve_and)\n+BITWISE_OP_IMM(vorB,  OrV,  B, B, sve_orr)\n+BITWISE_OP_IMM(vorH,  OrV,  H, S, sve_orr)\n+BITWISE_OP_IMM(vorS,  OrV,  S, I, sve_orr)\n+BITWISE_OP_IMM(vorD,  OrV,  D, L, sve_orr)\n+BITWISE_OP_IMM(vxorB, XorV, B, B, sve_eor)\n+BITWISE_OP_IMM(vxorH, XorV, H, S, sve_eor)\n+BITWISE_OP_IMM(vxorS, XorV, S, I, sve_eor)\n+BITWISE_OP_IMM(vxorD, XorV, D, L, sve_eor)\n+dnl\n@@ -2995,0 +3049,36 @@\n+\/\/ Intrisics for String.compareTo()\n+\n+\/\/ Note that Z registers alias the corresponding NEON registers, we declare the vector operands of\n+\/\/ these string_compare variants as NEON register type for convenience so that the prototype of\n+\/\/ string_compare can be shared with all variants.\n+\n+dnl\n+define(`STRING_COMPARETO', `\n+instruct string_compare$1_sve(iRegP_R1 str1, iRegI_R2 cnt1, iRegP_R3 str2, iRegI_R4 cnt2,\n+                              iRegI_R0 result, iRegP_R10 tmp1, iRegL_R11 tmp2,\n+                              vRegD_V0 vtmp1, vRegD_V1 vtmp2, pRegGov_P0 pgtmp1,\n+                              pRegGov_P1 pgtmp2, rFlagsReg cr)\n+%{\n+  predicate((UseSVE > 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::$1));\n+  match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));\n+  effect(TEMP tmp1, TEMP tmp2, TEMP vtmp1, TEMP vtmp2, TEMP pgtmp1, TEMP pgtmp2,\n+         USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL cr);\n+\n+  format %{ \"String Compare $str1,$cnt1,$str2,$cnt2 -> $result   # USE sve\" %}\n+  ins_encode %{\n+    \/\/ Count is in 8-bit bytes; non-Compact chars are 16 bits.\n+    __ string_compare($str1$$Register, $str2$$Register,\n+                      $cnt1$$Register, $cnt2$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register,\n+                      $vtmp1$$FloatRegister, $vtmp2$$FloatRegister, fnoreg,\n+                      as_PRegister($pgtmp1$$reg), as_PRegister($pgtmp2$$reg),\n+                      StrIntrinsicNode::$1);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}')dnl\n+dnl              $1\n+STRING_COMPARETO(LL)\n+STRING_COMPARETO(LU)\n+STRING_COMPARETO(UL)\n+STRING_COMPARETO(UU)\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":90,"deletions":0,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -85,0 +85,5 @@\n+unsigned Assembler::regVariant_to_elemBits(Assembler::SIMD_RegVariant T){\n+  guarantee(T != Q, \"Invalid register variant\");\n+  return 1 << (T + 3);\n+}\n+\n@@ -342,9 +347,5 @@\n-  bool shift = false;\n-  uint64_t uimm = (uint64_t)uabs((jlong)imm);\n-  if (uimm < (1 << 12))\n-    return true;\n-  if (uimm < (1 << 24)\n-      && ((uimm >> 12) << 12 == uimm)) {\n-    return true;\n-  }\n-  return false;\n+  return operand_valid_for_immediate_bits(imm, 12);\n+}\n+\n+bool Assembler::operand_valid_for_sve_add_sub_immediate(int64_t imm) {\n+  return operand_valid_for_immediate_bits(imm, 8);\n@@ -357,0 +358,4 @@\n+bool Assembler::operand_valid_for_sve_logical_immediate(unsigned elembits, uint64_t imm) {\n+  return encode_sve_logical_immediate(elembits, imm) != 0xffffffff;\n+}\n+\n@@ -386,0 +391,11 @@\n+bool asm_util::operand_valid_for_immediate_bits(int64_t imm, unsigned nbits) {\n+  guarantee(nbits == 8 || nbits == 12, \"invalid nbits value\");\n+  uint64_t uimm = (uint64_t)uabs((jlong)imm);\n+  if (uimm < (UCONST64(1) << nbits))\n+    return true;\n+  if (uimm < (UCONST64(1) << (2 * nbits))\n+      && ((uimm >> nbits) << nbits == uimm)) {\n+    return true;\n+  }\n+  return false;\n+}\n@@ -406,0 +422,19 @@\n+uint32_t\n+asm_util::encode_sve_logical_immediate(unsigned elembits, uint64_t imm) {\n+  guarantee(elembits == 8 || elembits == 16 ||\n+            elembits == 32 || elembits == 64, \"unsupported element size\");\n+  uint64_t upper = UCONST64(-1) << (elembits\/2) << (elembits\/2);\n+  \/* Allow all zeros or all ones in top bits, so that\n+   * constant expressions like ~1 are permitted. *\/\n+  if ((imm & ~upper) != imm && (imm | upper) != imm)\n+    return 0xffffffff;\n+\n+  \/\/ Replicate the immediate in different element sizes to 64 bits.\n+  imm &= ~upper;\n+  for (unsigned i = elembits; i < 64; i *= 2) {\n+    imm |= (imm << i);\n+  }\n+\n+  return encoding_for_logical_immediate(imm);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":44,"deletions":9,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -162,0 +162,2 @@\n+  uint32_t encode_sve_logical_immediate(unsigned elembits, uint64_t imm);\n+  bool operand_valid_for_immediate_bits(int64_t imm, unsigned nbits);\n@@ -1519,0 +1521,2 @@\n+  \/\/ Return the corresponding bits for different SIMD_RegVariant value.\n+  static unsigned regVariant_to_elemBits(SIMD_RegVariant T);\n@@ -2956,0 +2960,26 @@\n+\/\/ SVE integer add\/subtract immediate (unpredicated)\n+#define INSN(NAME, op)                                                  \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, unsigned imm8) {       \\\n+    starti;                                                             \\\n+    \/* The immediate is an unsigned value in the range 0 to 255, and    \\\n+     * for element width of 16 bits or higher it may also be a          \\\n+     * positive multiple of 256 in the range 256 to 65280.              \\\n+     *\/                                                                 \\\n+    assert(T != Q, \"invalid size\");                                     \\\n+    int sh = 0;                                                         \\\n+    if (imm8 <= 0xff) {                                                 \\\n+      sh = 0;                                                           \\\n+    } else if (T != B && imm8 <= 0xff00 && (imm8 & 0xff) == 0) {        \\\n+      sh = 1;                                                           \\\n+      imm8 = (imm8 >> 8);                                               \\\n+    } else {                                                            \\\n+      guarantee(false, \"invalid immediate\");                            \\\n+    }                                                                   \\\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(0b10000, 21, 17);            \\\n+    f(op, 16, 14), f(sh, 13), f(imm8, 12, 5), rf(Zd, 0);                \\\n+  }\n+\n+  INSN(sve_add, 0b011);\n+  INSN(sve_sub, 0b111);\n+#undef INSN\n+\n@@ -3093,0 +3123,14 @@\n+\/\/ SVE bitwise logical with immediate (unpredicated)\n+#define INSN(NAME, opc)                                                      \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, uint64_t imm) {             \\\n+    starti;                                                                  \\\n+    unsigned elembits = regVariant_to_elemBits(T);                           \\\n+    uint32_t val = encode_sve_logical_immediate(elembits, imm);              \\\n+    f(0b00000101, 31, 24), f(opc, 23, 22), f(0b0000, 21, 18);                \\\n+    f(val, 17, 5), rf(Zd, 0);                                                \\\n+  }\n+  INSN(sve_and, 0b10);\n+  INSN(sve_eor, 0b01);\n+  INSN(sve_orr, 0b00);\n+#undef INSN\n+\n@@ -3650,0 +3694,1 @@\n+  static bool operand_valid_for_sve_logical_immediate(unsigned elembits, uint64_t imm);\n@@ -3651,0 +3696,1 @@\n+  static bool operand_valid_for_sve_add_sub_immediate(int64_t imm);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1567,1 +1567,1 @@\n-    assert(addr_ptr->index() == LIR_OprDesc::illegalOpr(), \"need 0 index\");\n+    assert(addr_ptr->index() == LIR_Opr::illegalOpr(), \"need 0 index\");\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-FloatRegister LIR_OprDesc::as_float_reg() const {\n+FloatRegister LIR_Opr::as_float_reg() const {\n@@ -33,1 +33,1 @@\n-FloatRegister LIR_OprDesc::as_double_reg() const {\n+FloatRegister LIR_Opr::as_double_reg() const {\n@@ -40,5 +40,5 @@\n-  return (LIR_Opr)(intptr_t)((reg1 << LIR_OprDesc::reg1_shift) |\n-                             (reg1 << LIR_OprDesc::reg2_shift) |\n-                             LIR_OprDesc::double_type          |\n-                             LIR_OprDesc::fpu_register         |\n-                             LIR_OprDesc::double_size);\n+  return (LIR_Opr)(intptr_t)((reg1 << LIR_Opr::reg1_shift) |\n+                             (reg1 << LIR_Opr::reg2_shift) |\n+                             LIR_Opr::double_type          |\n+                             LIR_Opr::fpu_register         |\n+                             LIR_Opr::double_size);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIR_aarch64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -679,1 +679,2 @@\n-    FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3, int ae) {\n+    FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3,\n+    PRegister pgtmp1, PRegister pgtmp2, int ae) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-                      FloatRegister vtmp2, FloatRegister vtmp3, int ae);\n+                      FloatRegister vtmp2, FloatRegister vtmp3,\n+                      PRegister pgtmp1, PRegister pgtmp2, int ae);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -271,0 +271,2 @@\n+CONSTANT_REGISTER_DECLARATION(PRegister, pnoreg, (-1));\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,0 +191,2 @@\n+REGISTER_DEFINITION(PRegister, pnoreg);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/register_definitions_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5034,0 +5034,91 @@\n+  enum string_compare_mode {\n+    LL,\n+    LU,\n+    UL,\n+    UU,\n+  };\n+\n+  \/\/ The following registers are declared in aarch64.ad\n+  \/\/ r0  = result\n+  \/\/ r1  = str1\n+  \/\/ r2  = cnt1\n+  \/\/ r3  = str2\n+  \/\/ r4  = cnt2\n+  \/\/ r10 = tmp1\n+  \/\/ r11 = tmp2\n+  \/\/ z0  = ztmp1\n+  \/\/ z1  = ztmp2\n+  \/\/ p0  = pgtmp1\n+  \/\/ p1  = pgtmp2\n+  address generate_compare_long_string_sve(string_compare_mode mode) {\n+    __ align(CodeEntryAlignment);\n+    address entry = __ pc();\n+    Register result = r0, str1 = r1, cnt1 = r2, str2 = r3, cnt2 = r4,\n+             tmp1 = r10, tmp2 = r11;\n+\n+    Label LOOP, MATCH, DONE, NOMATCH;\n+    Register vec_len = tmp1;\n+    Register idx = tmp2;\n+    \/\/ The minimum of the string lengths has been stored in cnt2.\n+    Register cnt = cnt2;\n+    FloatRegister ztmp1 = z0, ztmp2 = z1;\n+    PRegister pgtmp1 = p0, pgtmp2 = p1;\n+\n+    if (mode == LL) {\n+      __ sve_cntb(vec_len);\n+    } else {\n+      __ sve_cnth(vec_len);\n+    }\n+\n+    __ mov(idx, 0);\n+    __ sve_whilelt(pgtmp1, mode == LL ? __ B : __ H, idx, cnt);\n+\n+    __ bind(LOOP);\n+      switch (mode) {\n+        case LL:\n+          __ sve_ld1b(ztmp1, __ B, pgtmp1, Address(str1, idx));\n+          __ sve_ld1b(ztmp2, __ B, pgtmp1, Address(str2, idx));\n+          break;\n+        case LU:\n+          __ sve_ld1b(ztmp1, __ H, pgtmp1, Address(str1, idx));\n+          __ sve_ld1h(ztmp2, __ H, pgtmp1, Address(str2, idx, Address::lsl(1)));\n+          break;\n+        case UL:\n+          __ sve_ld1h(ztmp1, __ H, pgtmp1, Address(str1, idx, Address::lsl(1)));\n+          __ sve_ld1b(ztmp2, __ H, pgtmp1, Address(str2, idx));\n+          break;\n+        case UU:\n+          __ sve_ld1h(ztmp1, __ H, pgtmp1, Address(str1, idx, Address::lsl(1)));\n+          __ sve_ld1h(ztmp2, __ H, pgtmp1, Address(str2, idx, Address::lsl(1)));\n+          break;\n+        default: ShouldNotReachHere();\n+      }\n+      __ add(idx, idx, vec_len);\n+\n+      \/\/ Compare strings.\n+      __ sve_cmp(Assembler::NE, pgtmp2, mode == LL ? __ B : __ H, pgtmp1, ztmp1, ztmp2);\n+      __ br(__ NE, MATCH);\n+      __ sve_whilelt(pgtmp1, mode == LL ? __ B : __ H, idx, cnt);\n+      __ br(__ LT, LOOP);\n+\n+      \/\/ The result has been computed in the caller prior to entering this stub.\n+      __ b(DONE);\n+\n+    __ bind(MATCH);\n+\n+      \/\/ Crop the vector to find its location.\n+      __ sve_brkb(pgtmp2, pgtmp1, pgtmp2, false \/* isMerge *\/);\n+\n+      \/\/ Extract the first different characters of each string.\n+      __ sve_lasta(rscratch1, mode == LL ? __ B : __ H, pgtmp2, ztmp1);\n+      __ sve_lasta(rscratch2, mode == LL ? __ B : __ H, pgtmp2, ztmp2);\n+\n+      \/\/ Compute the difference of the first different characters.\n+      __ sub(result, rscratch1, rscratch2);\n+\n+    __ bind(DONE);\n+      __ ret(lr);\n+\n+    return entry;\n+  }\n+\n@@ -5156,0 +5247,1 @@\n+    if (UseSVE == 0) {\n@@ -5164,0 +5256,10 @@\n+    } else {\n+      StubRoutines::aarch64::_compare_long_string_LL\n+          = generate_compare_long_string_sve(LL);\n+      StubRoutines::aarch64::_compare_long_string_UU\n+          = generate_compare_long_string_sve(UU);\n+      StubRoutines::aarch64::_compare_long_string_LU\n+          = generate_compare_long_string_sve(LU);\n+      StubRoutines::aarch64::_compare_long_string_UL\n+          = generate_compare_long_string_sve(UL);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":102,"deletions":0,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -205,0 +205,8 @@\n+\n+    if (FLAG_IS_DEFAULT(OnSpinWaitInst)) {\n+      FLAG_SET_DEFAULT(OnSpinWaitInst, \"isb\");\n+    }\n+\n+    if (FLAG_IS_DEFAULT(OnSpinWaitInstCount)) {\n+      FLAG_SET_DEFAULT(OnSpinWaitInstCount, 1);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1384,1 +1384,1 @@\n-  assert(op->addr()->is_register() || op->addr()->as_address_ptr()->index() == LIR_OprDesc::illegalOpr(), \"unexpected index\");\n+  assert(op->addr()->is_register() || op->addr()->as_address_ptr()->index() == LIR_Opr::illegalOpr(), \"unexpected index\");\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-FloatRegister LIR_OprDesc::as_float_reg() const {\n+FloatRegister LIR_Opr::as_float_reg() const {\n@@ -32,1 +32,1 @@\n-FloatRegister LIR_OprDesc::as_double_reg() const {\n+FloatRegister LIR_Opr::as_double_reg() const {\n@@ -38,5 +38,5 @@\n-  return (LIR_Opr)(intptr_t)((reg1 << LIR_OprDesc::reg1_shift) |\n-                             (reg2 << LIR_OprDesc::reg2_shift) |\n-                             LIR_OprDesc::double_type          |\n-                             LIR_OprDesc::fpu_register         |\n-                             LIR_OprDesc::double_size);\n+  return (LIR_Opr)(intptr_t)((reg1 << LIR_Opr::reg1_shift) |\n+                             (reg2 << LIR_Opr::reg2_shift) |\n+                             LIR_Opr::double_type          |\n+                             LIR_Opr::fpu_register         |\n+                             LIR_Opr::double_size);\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIR_arm.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-FloatRegister LIR_OprDesc::as_float_reg() const {\n+FloatRegister LIR_Opr::as_float_reg() const {\n@@ -34,1 +34,1 @@\n-FloatRegister LIR_OprDesc::as_double_reg() const {\n+FloatRegister LIR_Opr::as_double_reg() const {\n@@ -41,5 +41,5 @@\n-  return (LIR_Opr)(intptr_t)((reg1 << LIR_OprDesc::reg1_shift) |\n-                             (reg1 << LIR_OprDesc::reg2_shift) |\n-                             LIR_OprDesc::double_type          |\n-                             LIR_OprDesc::fpu_register         |\n-                             LIR_OprDesc::double_size);\n+  return (LIR_Opr)(intptr_t)((reg1 << LIR_Opr::reg1_shift) |\n+                             (reg1 << LIR_Opr::reg2_shift) |\n+                             LIR_Opr::double_type          |\n+                             LIR_Opr::fpu_register         |\n+                             LIR_Opr::double_size);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIR_ppc.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -154,0 +154,2 @@\n+  __ block_comment(\"nmethod_entry_barrier (nmethod_entry_barrier) {\");\n+\n@@ -170,0 +172,2 @@\n+\n+  __ block_comment(\"} nmethod_entry_barrier (nmethod_entry_barrier)\");\n@@ -180,0 +184,2 @@\n+  __ block_comment(\"c2i_entry_barrier (c2i_entry_barrier) {\");\n+\n@@ -210,0 +216,2 @@\n+\n+  __ block_comment(\"} c2i_entry_barrier (c2i_entry_barrier)\");\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/macroAssembler.inline.hpp\"\n+#include \"c1\/c1_LIRAssembler.hpp\"\n+#include \"c1\/c1_MacroAssembler.hpp\"\n+#include \"gc\/shenandoah\/shenandoahBarrierSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahBarrierSetAssembler.hpp\"\n+#include \"gc\/shenandoah\/c1\/shenandoahBarrierSetC1.hpp\"\n+\n+#define __ masm->masm()->\n+\n+void LIR_OpShenandoahCompareAndSwap::emit_code(LIR_Assembler *masm) {\n+  __ block_comment(\"LIR_OpShenandoahCompareAndSwap (shenandaohgc) {\");\n+\n+  Register addr = _addr->as_register_lo();\n+  Register new_val = _new_value->as_register();\n+  Register cmp_val = _cmp_value->as_register();\n+  Register tmp1 = _tmp1->as_register();\n+  Register tmp2 = _tmp2->as_register();\n+  Register result = result_opr()->as_register();\n+\n+  if (ShenandoahIUBarrier) {\n+    ShenandoahBarrierSet::assembler()->iu_barrier(masm->masm(), new_val, tmp1, tmp2,\n+                                                  MacroAssembler::PRESERVATION_FRAME_LR_GP_FP_REGS);\n+  }\n+\n+  if (UseCompressedOops) {\n+    __ encode_heap_oop(cmp_val, cmp_val);\n+    __ encode_heap_oop(new_val, new_val);\n+  }\n+\n+  \/\/ Due to the memory barriers emitted in ShenandoahBarrierSetC1::atomic_cmpxchg_at_resolved,\n+  \/\/ there is no need to specify stronger memory semantics.\n+  ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm->masm(), addr, cmp_val, new_val, tmp1, tmp2,\n+                                                 false, result);\n+\n+  if (UseCompressedOops) {\n+    __ decode_heap_oop(cmp_val);\n+    __ decode_heap_oop(new_val);\n+  }\n+\n+  __ block_comment(\"} LIR_OpShenandoahCompareAndSwap (shenandaohgc)\");\n+}\n+\n+#undef __\n+\n+#ifdef ASSERT\n+#define __ gen->lir(__FILE__, __LINE__)->\n+#else\n+#define __ gen->lir()->\n+#endif\n+\n+LIR_Opr ShenandoahBarrierSetC1::atomic_cmpxchg_at_resolved(LIRAccess &access, LIRItem &cmp_value, LIRItem &new_value) {\n+  BasicType bt = access.type();\n+\n+  if (access.is_oop()) {\n+    LIRGenerator* gen = access.gen();\n+\n+    if (ShenandoahCASBarrier) {\n+      if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+        __ membar();\n+      } else {\n+        __ membar_release();\n+      }\n+    }\n+\n+    if (ShenandoahSATBBarrier) {\n+      pre_barrier(gen, access.access_emit_info(), access.decorators(), access.resolved_addr(),\n+                  LIR_OprFact::illegalOpr);\n+    }\n+\n+    if (ShenandoahCASBarrier) {\n+      cmp_value.load_item();\n+      new_value.load_item();\n+\n+      LIR_Opr t1 = gen->new_register(T_OBJECT);\n+      LIR_Opr t2 = gen->new_register(T_OBJECT);\n+      LIR_Opr addr = access.resolved_addr()->as_address_ptr()->base();\n+      LIR_Opr result = gen->new_register(T_INT);\n+\n+      __ append(new LIR_OpShenandoahCompareAndSwap(addr, cmp_value.result(), new_value.result(), t1, t2, result));\n+\n+      if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+        __ membar_acquire();\n+      } else {\n+        __ membar();\n+      }\n+\n+      return result;\n+    }\n+  }\n+\n+  return BarrierSetC1::atomic_cmpxchg_at_resolved(access, cmp_value, new_value);\n+}\n+\n+LIR_Opr ShenandoahBarrierSetC1::atomic_xchg_at_resolved(LIRAccess &access, LIRItem &value) {\n+  LIRGenerator* gen = access.gen();\n+  BasicType type = access.type();\n+\n+  LIR_Opr result = gen->new_register(type);\n+  value.load_item();\n+  LIR_Opr value_opr = value.result();\n+\n+  if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+    __ membar();\n+  } else {\n+    __ membar_release();\n+  }\n+\n+  if (access.is_oop()) {\n+    value_opr = iu_barrier(access.gen(), value_opr, access.access_emit_info(), access.decorators());\n+  }\n+\n+  assert(type == T_INT || is_reference_type(type) LP64_ONLY( || type == T_LONG ), \"unexpected type\");\n+  LIR_Opr tmp_xchg = gen->new_register(T_INT);\n+  __ xchg(access.resolved_addr(), value_opr, result, tmp_xchg);\n+\n+  if (access.is_oop()) {\n+    result = load_reference_barrier_impl(access.gen(), result, LIR_OprFact::addressConst(0),\n+                                         access.decorators());\n+\n+    LIR_Opr tmp_barrier = gen->new_register(type);\n+    __ move(result, tmp_barrier);\n+    result = tmp_barrier;\n+\n+    if (ShenandoahSATBBarrier) {\n+      pre_barrier(access.gen(), access.access_emit_info(), access.decorators(), LIR_OprFact::illegalOpr, result);\n+    }\n+  }\n+\n+  if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+    __ membar_acquire();\n+  } else {\n+    __ membar();\n+  }\n+\n+  return result;\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_ppc.cpp","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,1012 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"gc\/shared\/gcArguments.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"macroAssembler_ppc.hpp\"\n+#include \"precompiled.hpp\"\n+#include \"asm\/macroAssembler.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahBarrierSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahBarrierSetAssembler.hpp\"\n+#include \"gc\/shenandoah\/shenandoahForwarding.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeapRegion.hpp\"\n+#include \"gc\/shenandoah\/shenandoahRuntime.hpp\"\n+#include \"gc\/shenandoah\/shenandoahThreadLocalData.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"vm_version_ppc.hpp\"\n+\n+#ifdef COMPILER1\n+\n+#include \"c1\/c1_LIRAssembler.hpp\"\n+#include \"c1\/c1_MacroAssembler.hpp\"\n+#include \"gc\/shenandoah\/c1\/shenandoahBarrierSetC1.hpp\"\n+\n+#endif\n+\n+#define __ masm->\n+\n+void ShenandoahBarrierSetAssembler::satb_write_barrier(MacroAssembler *masm,\n+                                                       Register base, RegisterOrConstant ind_or_offs,\n+                                                       Register tmp1, Register tmp2, Register tmp3,\n+                                                       MacroAssembler::PreservationLevel preservation_level) {\n+  if (ShenandoahSATBBarrier) {\n+    __ block_comment(\"satb_write_barrier (shenandoahgc) {\");\n+    satb_write_barrier_impl(masm, 0, base, ind_or_offs, tmp1, tmp2, tmp3, preservation_level);\n+    __ block_comment(\"} satb_write_barrier (shenandoahgc)\");\n+  }\n+}\n+\n+void ShenandoahBarrierSetAssembler::iu_barrier(MacroAssembler *masm,\n+                                               Register val,\n+                                               Register tmp1, Register tmp2,\n+                                               MacroAssembler::PreservationLevel preservation_level,\n+                                               DecoratorSet decorators) {\n+  \/\/ IU barriers are also employed to avoid resurrection of weak references,\n+  \/\/ even if Shenandoah does not operate in incremental update mode.\n+  if (ShenandoahIUBarrier || ShenandoahSATBBarrier) {\n+    __ block_comment(\"iu_barrier (shenandoahgc) {\");\n+    satb_write_barrier_impl(masm, decorators, noreg, noreg, val, tmp1, tmp2, preservation_level);\n+    __ block_comment(\"} iu_barrier (shenandoahgc)\");\n+  }\n+}\n+\n+void ShenandoahBarrierSetAssembler::load_reference_barrier(MacroAssembler *masm, DecoratorSet decorators,\n+                                                           Register base, RegisterOrConstant ind_or_offs,\n+                                                           Register dst,\n+                                                           Register tmp1, Register tmp2,\n+                                                           MacroAssembler::PreservationLevel preservation_level) {\n+  if (ShenandoahLoadRefBarrier) {\n+    __ block_comment(\"load_reference_barrier (shenandoahgc) {\");\n+    load_reference_barrier_impl(masm, decorators, base, ind_or_offs, dst, tmp1, tmp2, preservation_level);\n+    __ block_comment(\"} load_reference_barrier (shenandoahgc)\");\n+  }\n+}\n+\n+void ShenandoahBarrierSetAssembler::arraycopy_prologue(MacroAssembler *masm, DecoratorSet decorators, BasicType type,\n+                                                       Register src, Register dst, Register count,\n+                                                       Register preserve1, Register preserve2) {\n+  __ block_comment(\"arraycopy_prologue (shenandoahgc) {\");\n+\n+  Register R11_tmp = R11_scratch1;\n+\n+  assert_different_registers(src, dst, count, R11_tmp, noreg);\n+  if (preserve1 != noreg) {\n+    \/\/ Technically not required, but likely to indicate an error.\n+    assert_different_registers(preserve1, preserve2);\n+  }\n+\n+  \/* ==== Check whether barrier is required (optimizations) ==== *\/\n+  \/\/ Fast path: Component type of array is not a reference type.\n+  if (!is_reference_type(type)) {\n+    return;\n+  }\n+\n+  bool dest_uninitialized = (decorators & IS_DEST_UNINITIALIZED) != 0;\n+\n+  \/\/ Fast path: No barrier required if for every barrier type, it is either disabled or would not store\n+  \/\/ any useful information.\n+  if ((!ShenandoahSATBBarrier || dest_uninitialized) && !ShenandoahIUBarrier && !ShenandoahLoadRefBarrier) {\n+    return;\n+  }\n+\n+  Label skip_prologue;\n+\n+  \/\/ Fast path: Array is of length zero.\n+  __ cmpdi(CCR0, count, 0);\n+  __ beq(CCR0, skip_prologue);\n+\n+  \/* ==== Check whether barrier is required (gc state) ==== *\/\n+  __ lbz(R11_tmp, in_bytes(ShenandoahThreadLocalData::gc_state_offset()),\n+         R16_thread);\n+\n+  \/\/ The set of garbage collection states requiring barriers depends on the available barrier types and the\n+  \/\/ type of the reference in question.\n+  \/\/ For instance, satb barriers may be skipped if it is certain that the overridden values are not relevant\n+  \/\/ for the garbage collector.\n+  const int required_states = ShenandoahSATBBarrier && dest_uninitialized\n+                              ? ShenandoahHeap::HAS_FORWARDED\n+                              : ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::MARKING;\n+\n+  __ andi_(R11_tmp, R11_tmp, required_states);\n+  __ beq(CCR0, skip_prologue);\n+\n+  \/* ==== Invoke runtime ==== *\/\n+  \/\/ Save to-be-preserved registers.\n+  int highest_preserve_register_index = 0;\n+  {\n+    if (preserve1 != noreg && preserve1->is_volatile()) {\n+      __ std(preserve1, -BytesPerWord * ++highest_preserve_register_index, R1_SP);\n+    }\n+    if (preserve2 != noreg && preserve2 != preserve1 && preserve2->is_volatile()) {\n+      __ std(preserve2, -BytesPerWord * ++highest_preserve_register_index, R1_SP);\n+    }\n+\n+    __ std(src, -BytesPerWord * ++highest_preserve_register_index, R1_SP);\n+    __ std(dst, -BytesPerWord * ++highest_preserve_register_index, R1_SP);\n+    __ std(count, -BytesPerWord * ++highest_preserve_register_index, R1_SP);\n+\n+    __ save_LR_CR(R11_tmp);\n+    __ push_frame_reg_args(-BytesPerWord * highest_preserve_register_index,\n+                           R11_tmp);\n+  }\n+\n+  \/\/ Invoke runtime.\n+  address jrt_address = NULL;\n+  if (UseCompressedOops) {\n+    jrt_address = CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_narrow_oop_entry);\n+  } else {\n+    jrt_address = CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_oop_entry);\n+  }\n+  assert(jrt_address != nullptr, \"jrt routine cannot be found\");\n+\n+  __ call_VM_leaf(jrt_address, src, dst, count);\n+\n+  \/\/ Restore to-be-preserved registers.\n+  {\n+    __ pop_frame();\n+    __ restore_LR_CR(R11_tmp);\n+\n+    __ ld(count, -BytesPerWord * highest_preserve_register_index--, R1_SP);\n+    __ ld(dst, -BytesPerWord * highest_preserve_register_index--, R1_SP);\n+    __ ld(src, -BytesPerWord * highest_preserve_register_index--, R1_SP);\n+\n+    if (preserve2 != noreg && preserve2 != preserve1 && preserve2->is_volatile()) {\n+      __ ld(preserve2, -BytesPerWord * highest_preserve_register_index--, R1_SP);\n+    }\n+    if (preserve1 != noreg && preserve1->is_volatile()) {\n+      __ ld(preserve1, -BytesPerWord * highest_preserve_register_index--, R1_SP);\n+    }\n+  }\n+\n+  __ bind(skip_prologue);\n+  __ block_comment(\"} arraycopy_prologue (shenandoahgc)\");\n+}\n+\n+\/\/ The to-be-enqueued value can either be determined\n+\/\/ - dynamically by passing the reference's address information (load mode) or\n+\/\/ - statically by passing a register the value is stored in (preloaded mode)\n+\/\/   - for performance optimizations in cases where the previous value is known (currently not implemented) and\n+\/\/   - for incremental-update barriers.\n+\/\/\n+\/\/ decorators:  The previous value's decorator set.\n+\/\/              In \"load mode\", the value must equal '0'.\n+\/\/ base:        Base register of the reference's address (load mode).\n+\/\/              In \"preloaded mode\", the register must equal 'noreg'.\n+\/\/ ind_or_offs: Index or offset of the reference's address (load mode).\n+\/\/              If 'base' equals 'noreg' (preloaded mode), the passed value is ignored.\n+\/\/ pre_val:     Register holding the to-be-stored value (preloaded mode).\n+\/\/              In \"load mode\", this register acts as a temporary register and must\n+\/\/              thus not be 'noreg'.  In \"preloaded mode\", its content will be sustained.\n+\/\/ tmp1\/tmp2:   Temporary registers, one of which must be non-volatile in \"preloaded mode\".\n+void ShenandoahBarrierSetAssembler::satb_write_barrier_impl(MacroAssembler *masm, DecoratorSet decorators,\n+                                                            Register base, RegisterOrConstant ind_or_offs,\n+                                                            Register pre_val,\n+                                                            Register tmp1, Register tmp2,\n+                                                            MacroAssembler::PreservationLevel preservation_level) {\n+  assert_different_registers(tmp1, tmp2, pre_val, noreg);\n+\n+  Label skip_barrier;\n+\n+  \/* ==== Determine necessary runtime invocation preservation measures ==== *\/\n+  const bool needs_frame           = preservation_level >= MacroAssembler::PRESERVATION_FRAME_LR;\n+  const bool preserve_gp_registers = preservation_level >= MacroAssembler::PRESERVATION_FRAME_LR_GP_REGS;\n+  const bool preserve_fp_registers = preservation_level >= MacroAssembler::PRESERVATION_FRAME_LR_GP_FP_REGS;\n+\n+  \/\/ Check whether marking is active.\n+  __ lbz(tmp1, in_bytes(ShenandoahThreadLocalData::gc_state_offset()), R16_thread);\n+\n+  __ andi_(tmp1, tmp1, ShenandoahHeap::MARKING);\n+  __ beq(CCR0, skip_barrier);\n+\n+  \/* ==== Determine the reference's previous value ==== *\/\n+  bool preloaded_mode = base == noreg;\n+  Register pre_val_save = noreg;\n+\n+  if (preloaded_mode) {\n+    \/\/ Previous value has been passed to the method, so it must not be determined manually.\n+    \/\/ In case 'pre_val' is a volatile register, it must be saved across the C-call\n+    \/\/ as callers may depend on its value.\n+    \/\/ Unless the general purposes registers are saved anyway, one of the temporary registers\n+    \/\/ (i.e., 'tmp1' and 'tmp2') is used to the preserve 'pre_val'.\n+    if (!preserve_gp_registers && pre_val->is_volatile()) {\n+      pre_val_save = !tmp1->is_volatile() ? tmp1 : tmp2;\n+      assert(!pre_val_save->is_volatile(), \"at least one of the temporary registers must be non-volatile\");\n+    }\n+\n+    if ((decorators & IS_NOT_NULL) != 0) {\n+#ifdef ASSERT\n+      __ cmpdi(CCR0, pre_val, 0);\n+      __ asm_assert_ne(\"null oop is not allowed\");\n+#endif \/\/ ASSERT\n+    } else {\n+      __ cmpdi(CCR0, pre_val, 0);\n+      __ beq(CCR0, skip_barrier);\n+    }\n+  } else {\n+    \/\/ Load from the reference address to determine the reference's current value (before the store is being performed).\n+    \/\/ Contrary to the given value in \"preloaded mode\", it is not necessary to preserve it.\n+    assert(decorators == 0, \"decorator set must be empty\");\n+    assert(base != noreg, \"base must be a register\");\n+    assert(!ind_or_offs.is_register() || ind_or_offs.as_register() != noreg, \"ind_or_offs must be a register\");\n+    if (UseCompressedOops) {\n+      __ lwz(pre_val, ind_or_offs, base);\n+    } else {\n+      __ ld(pre_val, ind_or_offs, base);\n+    }\n+\n+    __ cmpdi(CCR0, pre_val, 0);\n+    __ beq(CCR0, skip_barrier);\n+\n+    if (UseCompressedOops) {\n+      __ decode_heap_oop_not_null(pre_val);\n+    }\n+  }\n+\n+  \/* ==== Try to enqueue the to-be-stored value directly into thread's local SATB mark queue ==== *\/\n+  {\n+    Label runtime;\n+    Register Rbuffer = tmp1, Rindex = tmp2;\n+\n+    \/\/ Check whether the queue has enough capacity to store another oop.\n+    \/\/ If not, jump to the runtime to commit the buffer and to allocate a new one.\n+    \/\/ (The buffer's index corresponds to the amount of remaining free space.)\n+    __ ld(Rindex, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset()), R16_thread);\n+    __ cmpdi(CCR0, Rindex, 0);\n+    __ beq(CCR0, runtime); \/\/ If index == 0 (buffer is full), goto runtime.\n+\n+    \/\/ Capacity suffices.  Decrement the queue's size by the size of one oop.\n+    \/\/ (The buffer is filled contrary to the heap's growing direction, i.e., it is filled downwards.)\n+    __ addi(Rindex, Rindex, -wordSize);\n+    __ std(Rindex, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset()), R16_thread);\n+\n+    \/\/ Enqueue the previous value and skip the invocation of the runtime.\n+    __ ld(Rbuffer, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset()), R16_thread);\n+    __ stdx(pre_val, Rbuffer, Rindex);\n+    __ b(skip_barrier);\n+\n+    __ bind(runtime);\n+  }\n+\n+  \/* ==== Invoke runtime to commit SATB mark queue to gc and allocate a new buffer ==== *\/\n+  \/\/ Save to-be-preserved registers.\n+  int nbytes_save = 0;\n+\n+  if (needs_frame) {\n+    if (preserve_gp_registers) {\n+      nbytes_save = (preserve_fp_registers\n+                     ? MacroAssembler::num_volatile_gp_regs + MacroAssembler::num_volatile_fp_regs\n+                     : MacroAssembler::num_volatile_gp_regs) * BytesPerWord;\n+      __ save_volatile_gprs(R1_SP, -nbytes_save, preserve_fp_registers);\n+    }\n+\n+    __ save_LR_CR(tmp1);\n+    __ push_frame_reg_args(nbytes_save, tmp2);\n+  }\n+\n+  if (!preserve_gp_registers && preloaded_mode && pre_val->is_volatile()) {\n+    assert(pre_val_save != noreg, \"nv_save must not be noreg\");\n+\n+    \/\/ 'pre_val' register must be saved manually unless general-purpose are preserved in general.\n+    __ mr(pre_val_save, pre_val);\n+  }\n+\n+  \/\/ Invoke runtime.\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), pre_val, R16_thread);\n+\n+  \/\/ Restore to-be-preserved registers.\n+  if (!preserve_gp_registers && preloaded_mode && pre_val->is_volatile()) {\n+    __ mr(pre_val, pre_val_save);\n+  }\n+\n+  if (needs_frame) {\n+    __ pop_frame();\n+    __ restore_LR_CR(tmp1);\n+\n+    if (preserve_gp_registers) {\n+      __ restore_volatile_gprs(R1_SP, -nbytes_save, preserve_fp_registers);\n+    }\n+  }\n+\n+  __ bind(skip_barrier);\n+}\n+\n+void ShenandoahBarrierSetAssembler::resolve_forward_pointer_not_null(MacroAssembler *masm, Register dst, Register tmp) {\n+  __ block_comment(\"resolve_forward_pointer_not_null (shenandoahgc) {\");\n+\n+  Register tmp1 = tmp,\n+           R0_tmp2 = R0;\n+  assert_different_registers(dst, tmp1, R0_tmp2, noreg);\n+\n+  \/\/ If the object has been evacuated, the mark word layout is as follows:\n+  \/\/ | forwarding pointer (62-bit) | '11' (2-bit) |\n+\n+  \/\/ The invariant that stack\/thread pointers have the lowest two bits cleared permits retrieving\n+  \/\/ the forwarding pointer solely by inversing the lowest two bits.\n+  \/\/ This invariant follows inevitably from hotspot's minimal alignment.\n+  assert(markWord::marked_value <= (unsigned long) MinObjAlignmentInBytes,\n+         \"marked value must not be higher than hotspot's minimal alignment\");\n+\n+  Label done;\n+\n+  \/\/ Load the object's mark word.\n+  __ ld(tmp1, oopDesc::mark_offset_in_bytes(), dst);\n+\n+  \/\/ Load the bit mask for the lock bits.\n+  __ li(R0_tmp2, markWord::lock_mask_in_place);\n+\n+  \/\/ Check whether all bits matching the bit mask are set.\n+  \/\/ If that is the case, the object has been evacuated and the most significant bits form the forward pointer.\n+  __ andc_(R0_tmp2, R0_tmp2, tmp1);\n+\n+  assert(markWord::lock_mask_in_place == markWord::marked_value,\n+         \"marked value must equal the value obtained when all lock bits are being set\");\n+  if (VM_Version::has_isel()) {\n+    __ xori(tmp1, tmp1, markWord::lock_mask_in_place);\n+    __ isel(dst, CCR0, Assembler::equal, false, tmp1);\n+  } else {\n+    __ bne(CCR0, done);\n+    __ xori(dst, tmp1, markWord::lock_mask_in_place);\n+  }\n+\n+  __ bind(done);\n+  __ block_comment(\"} resolve_forward_pointer_not_null (shenandoahgc)\");\n+}\n+\n+\/\/ base:        Base register of the reference's address.\n+\/\/ ind_or_offs: Index or offset of the reference's address (load mode).\n+\/\/ dst:         Reference's address.  In case the object has been evacuated, this is the to-space version\n+\/\/              of that object.\n+void ShenandoahBarrierSetAssembler::load_reference_barrier_impl(\n+    MacroAssembler *masm, DecoratorSet decorators,\n+    Register base, RegisterOrConstant ind_or_offs,\n+    Register dst,\n+    Register tmp1, Register tmp2,\n+    MacroAssembler::PreservationLevel preservation_level) {\n+  if (ind_or_offs.is_register()) {\n+    assert_different_registers(tmp1, tmp2, base, ind_or_offs.as_register(), dst, noreg);\n+  } else {\n+    assert_different_registers(tmp1, tmp2, base, dst, noreg);\n+  }\n+\n+  Label skip_barrier;\n+\n+  bool is_strong  = ShenandoahBarrierSet::is_strong_access(decorators);\n+  bool is_weak    = ShenandoahBarrierSet::is_weak_access(decorators);\n+  bool is_phantom = ShenandoahBarrierSet::is_phantom_access(decorators);\n+  bool is_native  = ShenandoahBarrierSet::is_native_access(decorators);\n+  bool is_narrow  = UseCompressedOops && !is_native;\n+\n+  \/* ==== Check whether heap is stable ==== *\/\n+  __ lbz(tmp2, in_bytes(ShenandoahThreadLocalData::gc_state_offset()), R16_thread);\n+\n+  if (is_strong) {\n+    \/\/ For strong references, the heap is considered stable if \"has forwarded\" is not active.\n+    __ andi_(tmp1, tmp2, ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::EVACUATION);\n+    __ beq(CCR0, skip_barrier);\n+#ifdef ASSERT\n+    \/\/ \"evacuation\" -> (implies) \"has forwarded\".  If we reach this code, \"has forwarded\" must thus be set.\n+    __ andi_(tmp1, tmp1, ShenandoahHeap::HAS_FORWARDED);\n+    __ asm_assert_ne(\"'has forwarded' is missing\");\n+#endif \/\/ ASSERT\n+  } else {\n+    \/\/ For all non-strong references, the heap is considered stable if not any of \"has forwarded\",\n+    \/\/ \"root set processing\", and \"weak reference processing\" is active.\n+    \/\/ The additional phase conditions are in place to avoid the resurrection of weak references (see JDK-8266440).\n+    Label skip_fastpath;\n+    __ andi_(tmp1, tmp2, ShenandoahHeap::WEAK_ROOTS);\n+    __ bne(CCR0, skip_fastpath);\n+\n+    __ andi_(tmp1, tmp2, ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::EVACUATION);\n+    __ beq(CCR0, skip_barrier);\n+#ifdef ASSERT\n+    \/\/ \"evacuation\" -> (implies) \"has forwarded\".  If we reach this code, \"has forwarded\" must thus be set.\n+    __ andi_(tmp1, tmp1, ShenandoahHeap::HAS_FORWARDED);\n+    __ asm_assert_ne(\"'has forwarded' is missing\");\n+#endif \/\/ ASSERT\n+\n+    __ bind(skip_fastpath);\n+  }\n+\n+  \/* ==== Check whether region is in collection set ==== *\/\n+  if (is_strong) {\n+    \/\/ Shenandoah stores metadata on regions in a continuous area of memory in which a single byte corresponds to\n+    \/\/ an entire region of the shenandoah heap.  At present, only the least significant bit is of significance\n+    \/\/ and indicates whether the region is part of the collection set.\n+    \/\/\n+    \/\/ All regions are of the same size and are always aligned by a power of two.\n+    \/\/ Any address can thus be shifted by a fixed number of bits to retrieve the address prefix shared by\n+    \/\/ all objects within that region (region identification bits).\n+    \/\/\n+    \/\/  | unused bits | region identification bits | object identification bits |\n+    \/\/  (Region size depends on a couple of criteria, such as page size, user-provided arguments and the max heap size.\n+    \/\/   The number of object identification bits can thus not be determined at compile time.)\n+    \/\/\n+    \/\/ -------------------------------------------------------  <--- cs (collection set) base address\n+    \/\/ | lost space due to heap space base address                   -> 'ShenandoahHeap::in_cset_fast_test_addr()'\n+    \/\/ | (region identification bits contain heap base offset)\n+    \/\/ |------------------------------------------------------  <--- cs base address + (heap_base >> region size shift)\n+    \/\/ | collection set in the proper                                -> shift: 'region_size_bytes_shift_jint()'\n+    \/\/ |\n+    \/\/ |------------------------------------------------------  <--- cs base address + (heap_base >> region size shift)\n+    \/\/                                                                               + number of regions\n+    __ load_const_optimized(tmp2, ShenandoahHeap::in_cset_fast_test_addr(), tmp1);\n+    __ srdi(tmp1, dst, ShenandoahHeapRegion::region_size_bytes_shift_jint());\n+    __ lbzx(tmp2, tmp1, tmp2);\n+    __ andi_(tmp2, tmp2, 1);\n+    __ beq(CCR0, skip_barrier);\n+  }\n+\n+  \/* ==== Invoke runtime ==== *\/\n+  \/\/ Save to-be-preserved registers.\n+  int nbytes_save = 0;\n+\n+  const bool needs_frame           = preservation_level >= MacroAssembler::PRESERVATION_FRAME_LR;\n+  const bool preserve_gp_registers = preservation_level >= MacroAssembler::PRESERVATION_FRAME_LR_GP_REGS;\n+  const bool preserve_fp_registers = preservation_level >= MacroAssembler::PRESERVATION_FRAME_LR_GP_FP_REGS;\n+\n+  if (needs_frame) {\n+    if (preserve_gp_registers) {\n+      nbytes_save = (preserve_fp_registers\n+                     ? MacroAssembler::num_volatile_gp_regs + MacroAssembler::num_volatile_fp_regs\n+                     : MacroAssembler::num_volatile_gp_regs) * BytesPerWord;\n+      __ save_volatile_gprs(R1_SP, -nbytes_save, preserve_fp_registers);\n+    }\n+\n+    __ save_LR_CR(tmp1);\n+    __ push_frame_reg_args(nbytes_save, tmp1);\n+  }\n+\n+  \/\/ Calculate the reference's absolute address.\n+  __ add(R4_ARG2, ind_or_offs, base);\n+\n+  \/\/ Invoke runtime.\n+  address jrt_address = nullptr;\n+\n+  if (is_strong) {\n+    if (is_narrow) {\n+      jrt_address = CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_strong_narrow);\n+    } else {\n+      jrt_address = CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_strong);\n+    }\n+  } else if (is_weak) {\n+    if (is_narrow) {\n+      jrt_address = CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak_narrow);\n+    } else {\n+      jrt_address = CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak);\n+    }\n+  } else {\n+    assert(is_phantom, \"only remaining strength\");\n+    assert(!is_narrow, \"phantom access cannot be narrow\");\n+    jrt_address = CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_phantom);\n+  }\n+  assert(jrt_address != nullptr, \"jrt routine cannot be found\");\n+\n+  __ call_VM_leaf(jrt_address, dst \/* reference *\/, R4_ARG2 \/* reference address *\/);\n+\n+  \/\/ Restore to-be-preserved registers.\n+  if (preserve_gp_registers) {\n+    __ mr(R0, R3_RET);\n+  } else {\n+    __ mr_if_needed(dst, R3_RET);\n+  }\n+\n+  if (needs_frame) {\n+    __ pop_frame();\n+    __ restore_LR_CR(tmp1);\n+\n+    if (preserve_gp_registers) {\n+      __ restore_volatile_gprs(R1_SP, -nbytes_save, preserve_fp_registers);\n+      __ mr(dst, R0);\n+    }\n+  }\n+\n+  __ bind(skip_barrier);\n+}\n+\n+\/\/ base:           Base register of the reference's address.\n+\/\/ ind_or_offs:    Index or offset of the reference's address.\n+\/\/ L_handle_null:  An optional label that will be jumped to if the reference is null.\n+void ShenandoahBarrierSetAssembler::load_at(\n+    MacroAssembler *masm, DecoratorSet decorators, BasicType type,\n+    Register base, RegisterOrConstant ind_or_offs, Register dst,\n+    Register tmp1, Register tmp2,\n+    MacroAssembler::PreservationLevel preservation_level, Label *L_handle_null) {\n+  \/\/ Register must not clash, except 'base' and 'dst'.\n+  if (ind_or_offs.is_register()) {\n+    if (base != noreg) {\n+      assert_different_registers(tmp1, tmp2, base, ind_or_offs.register_or_noreg(), R0, noreg);\n+    }\n+    assert_different_registers(tmp1, tmp2, dst, ind_or_offs.register_or_noreg(), R0, noreg);\n+  } else {\n+    if (base == noreg) {\n+      assert_different_registers(tmp1, tmp2, base, R0, noreg);\n+    }\n+    assert_different_registers(tmp1, tmp2, dst, R0, noreg);\n+  }\n+\n+  \/* ==== Apply load barrier, if required ==== *\/\n+  if (ShenandoahBarrierSet::need_load_reference_barrier(decorators, type)) {\n+    assert(is_reference_type(type), \"need_load_reference_barrier must check whether type is a reference type\");\n+\n+    \/\/ If 'dst' clashes with either 'base' or 'ind_or_offs', use an intermediate result register\n+    \/\/ to keep the values of those alive until the load reference barrier is applied.\n+    Register intermediate_dst = (dst == base || (ind_or_offs.is_register() && dst == ind_or_offs.as_register()))\n+                                ? tmp2\n+                                : dst;\n+\n+    BarrierSetAssembler::load_at(masm, decorators, type,\n+                                 base, ind_or_offs,\n+                                 intermediate_dst,\n+                                 tmp1, noreg,\n+                                 preservation_level, L_handle_null);\n+\n+    load_reference_barrier(masm, decorators,\n+                           base, ind_or_offs,\n+                           intermediate_dst,\n+                           tmp1, R0,\n+                           preservation_level);\n+\n+    __ mr_if_needed(dst, intermediate_dst);\n+  } else {\n+    BarrierSetAssembler::load_at(masm, decorators, type,\n+                                 base, ind_or_offs,\n+                                 dst,\n+                                 tmp1, tmp2,\n+                                 preservation_level, L_handle_null);\n+  }\n+\n+  \/* ==== Apply keep-alive barrier, if required (e.g., to inhibit weak reference resurrection) ==== *\/\n+  if (ShenandoahBarrierSet::need_keep_alive_barrier(decorators, type)) {\n+    iu_barrier(masm, dst, tmp1, tmp2, preservation_level);\n+  }\n+}\n+\n+\/\/ base:        Base register of the reference's address.\n+\/\/ ind_or_offs: Index or offset of the reference's address.\n+\/\/ val:         To-be-stored value\/reference's new value.\n+void ShenandoahBarrierSetAssembler::store_at(MacroAssembler *masm, DecoratorSet decorators, BasicType type,\n+                                             Register base, RegisterOrConstant ind_or_offs, Register val,\n+                                             Register tmp1, Register tmp2, Register tmp3,\n+                                             MacroAssembler::PreservationLevel preservation_level) {\n+  if (is_reference_type(type)) {\n+    if (ShenandoahSATBBarrier) {\n+      satb_write_barrier(masm, base, ind_or_offs, tmp1, tmp2, tmp3, preservation_level);\n+    }\n+\n+    if (ShenandoahIUBarrier && val != noreg) {\n+      iu_barrier(masm, val, tmp1, tmp2, preservation_level, decorators);\n+    }\n+  }\n+\n+  BarrierSetAssembler::store_at(masm, decorators, type,\n+                                base, ind_or_offs,\n+                                val,\n+                                tmp1, tmp2, tmp3,\n+                                preservation_level);\n+}\n+\n+void ShenandoahBarrierSetAssembler::try_resolve_jobject_in_native(MacroAssembler *masm,\n+                                                                  Register dst, Register jni_env, Register obj,\n+                                                                  Register tmp, Label &slowpath) {\n+  __ block_comment(\"try_resolve_jobject_in_native (shenandoahgc) {\");\n+\n+  assert_different_registers(jni_env, obj, tmp);\n+\n+  Label done;\n+\n+  \/\/ Fast path: Reference is null (JNI tags are zero for null pointers).\n+  __ cmpdi(CCR0, obj, 0);\n+  __ beq(CCR0, done);\n+\n+  \/\/ Resolve jobject using standard implementation.\n+  BarrierSetAssembler::try_resolve_jobject_in_native(masm, dst, jni_env, obj, tmp, slowpath);\n+\n+  \/\/ Check whether heap is stable.\n+  __ lbz(tmp,\n+         in_bytes(ShenandoahThreadLocalData::gc_state_offset() - JavaThread::jni_environment_offset()),\n+         jni_env);\n+\n+  __ andi_(tmp, tmp, ShenandoahHeap::EVACUATION | ShenandoahHeap::HAS_FORWARDED);\n+  __ bne(CCR0, slowpath);\n+\n+  __ bind(done);\n+  __ block_comment(\"} try_resolve_jobject_in_native (shenandoahgc)\");\n+}\n+\n+\/\/ Special shenandoah CAS implementation that handles false negatives due\n+\/\/ to concurrent evacuation.  That is, the CAS operation is intended to succeed in\n+\/\/ the following scenarios (success criteria):\n+\/\/  s1) The reference pointer ('base_addr') equals the expected ('expected') pointer.\n+\/\/  s2) The reference pointer refers to the from-space version of an already-evacuated\n+\/\/      object, whereas the expected pointer refers to the to-space version of the same object.\n+\/\/ Situations in which the reference pointer refers to the to-space version of an object\n+\/\/ and the expected pointer refers to the from-space version of the same object can not occur due to\n+\/\/ shenandoah's strong to-space invariant.  This also implies that the reference stored in 'new_val'\n+\/\/ can not refer to the from-space version of an already-evacuated object.\n+\/\/\n+\/\/ To guarantee correct behavior in concurrent environments, two races must be addressed:\n+\/\/  r1) A concurrent thread may heal the reference pointer (i.e., it is no longer referring to the\n+\/\/      from-space version but to the to-space version of the object in question).\n+\/\/      In this case, the CAS operation should succeed.\n+\/\/  r2) A concurrent thread may mutate the reference (i.e., the reference pointer refers to an entirely different object).\n+\/\/      In this case, the CAS operation should fail.\n+\/\/\n+\/\/ By default, the value held in the 'result' register is zero to indicate failure of CAS,\n+\/\/ non-zero to indicate success.  If 'is_cae' is set, the result is the most recently fetched\n+\/\/ value from 'base_addr' rather than a boolean success indicator.\n+void ShenandoahBarrierSetAssembler::cmpxchg_oop(MacroAssembler *masm, Register base_addr,\n+                                                Register expected, Register new_val, Register tmp1, Register tmp2,\n+                                                bool is_cae, Register result) {\n+  __ block_comment(\"cmpxchg_oop (shenandoahgc) {\");\n+\n+  assert_different_registers(base_addr, new_val, tmp1, tmp2, result, R0);\n+  assert_different_registers(base_addr, expected, tmp1, tmp2, result, R0);\n+\n+  \/\/ Potential clash of 'success_flag' and 'tmp' is being accounted for.\n+  Register success_flag  = is_cae ? noreg  : result,\n+           current_value = is_cae ? result : tmp1,\n+           tmp           = is_cae ? tmp1   : result,\n+           initial_value = tmp2;\n+\n+  Label done, step_four;\n+\n+  __ bind(step_four);\n+\n+  \/* ==== Step 1 (\"Standard\" CAS) ==== *\/\n+  \/\/ Fast path: The values stored in 'expected' and 'base_addr' are equal.\n+  \/\/ Given that 'expected' must refer to the to-space object of an evacuated object (strong to-space invariant),\n+  \/\/ no special processing is required.\n+  if (UseCompressedOops) {\n+    __ cmpxchgw(CCR0, current_value, expected, new_val, base_addr, MacroAssembler::MemBarNone,\n+                false, success_flag, true);\n+  } else {\n+    __ cmpxchgd(CCR0, current_value, expected, new_val, base_addr, MacroAssembler::MemBarNone,\n+                false, success_flag, NULL, true);\n+  }\n+\n+  \/\/ Skip the rest of the barrier if the CAS operation succeeds immediately.\n+  \/\/ If it does not, the value stored at the address is either the from-space pointer of the\n+  \/\/ referenced object (success criteria s2)) or simply another object.\n+  __ beq(CCR0, done);\n+\n+  \/* ==== Step 2 (Null check) ==== *\/\n+  \/\/ The success criteria s2) cannot be matched with a null pointer\n+  \/\/ (null pointers cannot be subject to concurrent evacuation).  The failure of the CAS operation is thus legitimate.\n+  __ cmpdi(CCR0, current_value, 0);\n+  __ beq(CCR0, done);\n+\n+  \/* ==== Step 3 (reference pointer refers to from-space version; success criteria s2)) ==== *\/\n+  \/\/ To check whether the reference pointer refers to the from-space version, the forward\n+  \/\/ pointer of the object referred to by the reference is resolved and compared against the expected pointer.\n+  \/\/ If this check succeed, another CAS operation is issued with the from-space pointer being the expected pointer.\n+  \/\/\n+  \/\/ Save the potential from-space pointer.\n+  __ mr(initial_value, current_value);\n+\n+  \/\/ Resolve forward pointer.\n+  if (UseCompressedOops) { __ decode_heap_oop_not_null(current_value); }\n+  resolve_forward_pointer_not_null(masm, current_value, tmp);\n+  if (UseCompressedOops) { __ encode_heap_oop_not_null(current_value); }\n+\n+  if (!is_cae) {\n+    \/\/ 'success_flag' was overwritten by call to 'resovle_forward_pointer_not_null'.\n+    \/\/ Load zero into register for the potential failure case.\n+    __ li(success_flag, 0);\n+  }\n+  __ cmpd(CCR0, current_value, expected);\n+  __ bne(CCR0, done);\n+\n+  \/\/ Discard fetched value as it might be a reference to the from-space version of an object.\n+  if (UseCompressedOops) {\n+    __ cmpxchgw(CCR0, R0, initial_value, new_val, base_addr, MacroAssembler::MemBarNone,\n+                false, success_flag);\n+  } else {\n+    __ cmpxchgd(CCR0, R0, initial_value, new_val, base_addr, MacroAssembler::MemBarNone,\n+                false, success_flag);\n+  }\n+\n+  \/* ==== Step 4 (Retry CAS with to-space pointer (success criteria s2) under race r1)) ==== *\/\n+  \/\/ The reference pointer could have been healed whilst the previous CAS operation was being performed.\n+  \/\/ Another CAS operation must thus be issued with the to-space pointer being the expected pointer.\n+  \/\/ If that CAS operation fails as well, race r2) must have occurred, indicating that\n+  \/\/ the operation failure is legitimate.\n+  \/\/\n+  \/\/ To keep the code's size small and thus improving cache (icache) performance, this highly\n+  \/\/ unlikely case should be handled by the smallest possible code.  Instead of emitting a third,\n+  \/\/ explicit CAS operation, the code jumps back and reuses the first CAS operation (step 1)\n+  \/\/ (passed arguments are identical).\n+  \/\/\n+  \/\/ A failure of the CAS operation in step 1 would imply that the overall CAS operation is supposed\n+  \/\/ to fail.  Jumping back to step 1 requires, however, that step 2 and step 3 are re-executed as well.\n+  \/\/ It is thus important to ensure that a re-execution of those steps does not put program correctness\n+  \/\/ at risk:\n+  \/\/ - Step 2: Either terminates in failure (desired result) or falls through to step 3.\n+  \/\/ - Step 3: Terminates if the comparison between the forwarded, fetched pointer and the expected value\n+  \/\/           fails.  Unless the reference has been updated in the meanwhile once again, this is\n+  \/\/           guaranteed to be the case.\n+  \/\/           In case of a concurrent update, the CAS would be retried again. This is legitimate\n+  \/\/           in terms of program correctness (even though it is not desired).\n+  __ bne(CCR0, step_four);\n+\n+  __ bind(done);\n+  __ block_comment(\"} cmpxchg_oop (shenandoahgc)\");\n+}\n+\n+#undef __\n+\n+#ifdef COMPILER1\n+\n+#define __ ce->masm()->\n+\n+void ShenandoahBarrierSetAssembler::gen_pre_barrier_stub(LIR_Assembler *ce, ShenandoahPreBarrierStub *stub) {\n+  __ block_comment(\"gen_pre_barrier_stub (shenandoahgc) {\");\n+\n+  ShenandoahBarrierSetC1 *bs = (ShenandoahBarrierSetC1*) BarrierSet::barrier_set()->barrier_set_c1();\n+  __ bind(*stub->entry());\n+\n+  \/\/ GC status has already been verified by 'ShenandoahBarrierSetC1::pre_barrier'.\n+  \/\/ This stub is the slowpath of that function.\n+\n+  assert(stub->pre_val()->is_register(), \"pre_val must be a register\");\n+  Register pre_val = stub->pre_val()->as_register();\n+\n+  \/\/ If 'do_load()' returns false, the to-be-stored value is already available in 'stub->pre_val()'\n+  \/\/ (\"preloaded mode\" of the store barrier).\n+  if (stub->do_load()) {\n+    ce->mem2reg(stub->addr(), stub->pre_val(), T_OBJECT, stub->patch_code(), stub->info(), false);\n+  }\n+\n+  \/\/ Fast path: Reference is null.\n+  __ cmpdi(CCR0, pre_val, 0);\n+  __ bc_far_optimized(Assembler::bcondCRbiIs1_bhintNoHint, __ bi0(CCR0, Assembler::equal), *stub->continuation());\n+\n+  \/\/ Argument passing via the stack.\n+  __ std(pre_val, -8, R1_SP);\n+\n+  __ load_const_optimized(R0, bs->pre_barrier_c1_runtime_code_blob()->code_begin());\n+  __ call_stub(R0);\n+\n+  __ b(*stub->continuation());\n+  __ block_comment(\"} gen_pre_barrier_stub (shenandoahgc)\");\n+}\n+\n+void ShenandoahBarrierSetAssembler::gen_load_reference_barrier_stub(LIR_Assembler *ce,\n+                                                                    ShenandoahLoadReferenceBarrierStub *stub) {\n+  __ block_comment(\"gen_load_reference_barrier_stub (shenandoahgc) {\");\n+\n+  ShenandoahBarrierSetC1 *bs = (ShenandoahBarrierSetC1*) BarrierSet::barrier_set()->barrier_set_c1();\n+  __ bind(*stub->entry());\n+\n+  Register obj  = stub->obj()->as_register();\n+  Register res  = stub->result()->as_register();\n+  Register addr = stub->addr()->as_pointer_register();\n+  Register tmp1 = stub->tmp1()->as_register();\n+  Register tmp2 = stub->tmp2()->as_register();\n+  assert_different_registers(addr, res, tmp1, tmp2);\n+\n+#ifdef ASSERT\n+  \/\/ Ensure that 'res' is 'R3_ARG1' and contains the same value as 'obj' to reduce the number of required\n+  \/\/ copy instructions.\n+  assert(R3_RET == res, \"res must be r3\");\n+  __ cmpd(CCR0, res, obj);\n+  __ asm_assert_eq(\"result register must contain the reference stored in obj\");\n+#endif\n+\n+  DecoratorSet decorators = stub->decorators();\n+\n+  \/* ==== Check whether region is in collection set ==== *\/\n+  \/\/ GC status (unstable) has already been verified by 'ShenandoahBarrierSetC1::load_reference_barrier_impl'.\n+  \/\/ This stub is the slowpath of that function.\n+\n+  bool is_strong  = ShenandoahBarrierSet::is_strong_access(decorators);\n+  bool is_weak    = ShenandoahBarrierSet::is_weak_access(decorators);\n+  bool is_phantom = ShenandoahBarrierSet::is_phantom_access(decorators);\n+  bool is_native  = ShenandoahBarrierSet::is_native_access(decorators);\n+\n+  if (is_strong) {\n+    \/\/ Check whether object is in collection set.\n+    __ load_const_optimized(tmp2, ShenandoahHeap::in_cset_fast_test_addr(), tmp1);\n+    __ srdi(tmp1, obj, ShenandoahHeapRegion::region_size_bytes_shift_jint());\n+    __ lbzx(tmp2, tmp1, tmp2);\n+\n+    __ andi_(tmp2, tmp2, 1);\n+    __ bc_far_optimized(Assembler::bcondCRbiIs1_bhintNoHint, __ bi0(CCR0, Assembler::equal), *stub->continuation());\n+  }\n+\n+  address blob_addr = nullptr;\n+\n+  if (is_strong) {\n+    if (is_native) {\n+      blob_addr = bs->load_reference_barrier_strong_native_rt_code_blob()->code_begin();\n+    } else {\n+      blob_addr = bs->load_reference_barrier_strong_rt_code_blob()->code_begin();\n+    }\n+  } else if (is_weak) {\n+    blob_addr = bs->load_reference_barrier_weak_rt_code_blob()->code_begin();\n+  } else {\n+    assert(is_phantom, \"only remaining strength\");\n+    blob_addr = bs->load_reference_barrier_phantom_rt_code_blob()->code_begin();\n+  }\n+\n+  assert(blob_addr != nullptr, \"code blob cannot be found\");\n+\n+  \/\/ Argument passing via the stack.  'obj' is passed implicitly (as asserted above).\n+  __ std(addr, -8, R1_SP);\n+\n+  __ load_const_optimized(tmp1, blob_addr, tmp2);\n+  __ call_stub(tmp1);\n+\n+  \/\/ 'res' is 'R3_RET'.  The result is thus already in the correct register.\n+\n+  __ b(*stub->continuation());\n+  __ block_comment(\"} gen_load_reference_barrier_stub (shenandoahgc)\");\n+}\n+\n+#undef __\n+\n+#define __ sasm->\n+\n+void ShenandoahBarrierSetAssembler::generate_c1_pre_barrier_runtime_stub(StubAssembler *sasm) {\n+  __ block_comment(\"generate_c1_pre_barrier_runtime_stub (shenandoahgc) {\");\n+\n+  Label runtime, skip_barrier;\n+  BarrierSet *bs = BarrierSet::barrier_set();\n+\n+  \/\/ Argument passing via the stack.\n+  const int caller_stack_slots = 3;\n+\n+  Register R0_pre_val = R0;\n+  __ ld(R0, -8, R1_SP);\n+  Register R11_tmp1 = R11_scratch1;\n+  __ std(R11_tmp1, -16, R1_SP);\n+  Register R12_tmp2 = R12_scratch2;\n+  __ std(R12_tmp2, -24, R1_SP);\n+\n+  \/* ==== Check whether marking is active ==== *\/\n+  \/\/ Even though gc status was checked in 'ShenandoahBarrierSetAssembler::gen_pre_barrier_stub',\n+  \/\/ another check is required as a safepoint might have been reached in the meantime (JDK-8140588).\n+  __ lbz(R12_tmp2, in_bytes(ShenandoahThreadLocalData::gc_state_offset()), R16_thread);\n+\n+  __ andi_(R12_tmp2, R12_tmp2, ShenandoahHeap::MARKING);\n+  __ beq(CCR0, skip_barrier);\n+\n+  \/* ==== Add previous value directly to thread-local SATB mark queue ==== *\/\n+  \/\/ Check queue's capacity.  Jump to runtime if no free slot is available.\n+  __ ld(R12_tmp2, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset()), R16_thread);\n+  __ cmpdi(CCR0, R12_tmp2, 0);\n+  __ beq(CCR0, runtime);\n+\n+  \/\/ Capacity suffices.  Decrement the queue's size by one slot (size of one oop).\n+  __ addi(R12_tmp2, R12_tmp2, -wordSize);\n+  __ std(R12_tmp2, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset()), R16_thread);\n+\n+  \/\/ Enqueue the previous value and skip the runtime invocation.\n+  __ ld(R11_tmp1, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset()), R16_thread);\n+  __ stdx(R0_pre_val, R11_tmp1, R12_tmp2);\n+  __ b(skip_barrier);\n+\n+  __ bind(runtime);\n+\n+  \/* ==== Invoke runtime to commit SATB mark queue to gc and allocate a new buffer ==== *\/\n+  \/\/ Save to-be-preserved registers.\n+  const int nbytes_save = (MacroAssembler::num_volatile_regs + caller_stack_slots) * BytesPerWord;\n+  __ save_volatile_gprs(R1_SP, -nbytes_save);\n+  __ save_LR_CR(R11_tmp1);\n+  __ push_frame_reg_args(nbytes_save, R11_tmp1);\n+\n+  \/\/ Invoke runtime.\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_field_pre_entry), R0_pre_val, R16_thread);\n+\n+  \/\/ Restore to-be-preserved registers.\n+  __ pop_frame();\n+  __ restore_LR_CR(R11_tmp1);\n+  __ restore_volatile_gprs(R1_SP, -nbytes_save);\n+\n+  __ bind(skip_barrier);\n+\n+  \/\/ Restore spilled registers.\n+  __ ld(R11_tmp1, -16, R1_SP);\n+  __ ld(R12_tmp2, -24, R1_SP);\n+\n+  __ blr();\n+  __ block_comment(\"} generate_c1_pre_barrier_runtime_stub (shenandoahgc)\");\n+}\n+\n+void ShenandoahBarrierSetAssembler::generate_c1_load_reference_barrier_runtime_stub(StubAssembler *sasm,\n+                                                                                    DecoratorSet decorators) {\n+  __ block_comment(\"generate_c1_load_reference_barrier_runtime_stub (shenandoahgc) {\");\n+\n+  \/\/ Argument passing via the stack.\n+  const int caller_stack_slots = 1;\n+\n+  \/\/ Save to-be-preserved registers.\n+  const int nbytes_save = (MacroAssembler::num_volatile_regs - 1 \/\/ 'R3_ARG1' is skipped\n+                           + caller_stack_slots) * BytesPerWord;\n+  __ save_volatile_gprs(R1_SP, -nbytes_save, true, false);\n+\n+  \/\/ Load arguments from stack.\n+  \/\/ No load required, as assured by assertions in 'ShenandoahBarrierSetAssembler::gen_load_reference_barrier_stub'.\n+  Register R3_obj = R3_ARG1;\n+  Register R4_load_addr = R4_ARG2;\n+  __ ld(R4_load_addr, -8, R1_SP);\n+\n+  Register R11_tmp = R11_scratch1;\n+\n+  \/* ==== Invoke runtime ==== *\/\n+  bool is_strong  = ShenandoahBarrierSet::is_strong_access(decorators);\n+  bool is_weak    = ShenandoahBarrierSet::is_weak_access(decorators);\n+  bool is_phantom = ShenandoahBarrierSet::is_phantom_access(decorators);\n+  bool is_native  = ShenandoahBarrierSet::is_native_access(decorators);\n+\n+  address jrt_address = NULL;\n+\n+  if (is_strong) {\n+    if (is_native) {\n+      jrt_address = CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_strong);\n+    } else {\n+      if (UseCompressedOops) {\n+        jrt_address = CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_strong_narrow);\n+      } else {\n+        jrt_address = CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_strong);\n+      }\n+    }\n+  } else if (is_weak) {\n+    assert(!is_native, \"weak load reference barrier must not be called off-heap\");\n+    if (UseCompressedOops) {\n+      jrt_address = CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak_narrow);\n+    } else {\n+      jrt_address = CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak);\n+    }\n+  } else {\n+    assert(is_phantom, \"reference type must be phantom\");\n+    assert(is_native, \"phantom load reference barrier must be called off-heap\");\n+    jrt_address = CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_phantom);\n+  }\n+  assert(jrt_address != NULL, \"load reference barrier runtime routine cannot be found\");\n+\n+  __ save_LR_CR(R11_tmp);\n+  __ push_frame_reg_args(nbytes_save, R11_tmp);\n+\n+  \/\/ Invoke runtime.  Arguments are already stored in the corresponding registers.\n+  __ call_VM_leaf(jrt_address, R3_obj, R4_load_addr);\n+\n+  \/\/ Restore to-be-preserved registers.\n+  __ pop_frame();\n+  __ restore_LR_CR(R11_tmp);\n+  __ restore_volatile_gprs(R1_SP, -nbytes_save, true, false); \/\/ Skip 'R3_RET' register.\n+\n+  __ blr();\n+  __ block_comment(\"} generate_c1_load_reference_barrier_runtime_stub (shenandoahgc)\");\n+}\n+\n+#undef __\n+\n+#endif \/\/ COMPILER1\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":1012,"deletions":0,"binary":false,"changes":1012,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_PPC_GC_SHENANDOAH_SHENANDOAHBARRIERSETASSEMBLER_PPC_HPP\n+#define CPU_PPC_GC_SHENANDOAH_SHENANDOAHBARRIERSETASSEMBLER_PPC_HPP\n+\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n+#include \"gc\/shenandoah\/shenandoahBarrierSet.hpp\"\n+\n+#ifdef COMPILER1\n+\n+class LIR_Assembler;\n+class ShenandoahPreBarrierStub;\n+class ShenandoahLoadReferenceBarrierStub;\n+class StubAssembler;\n+\n+#endif\n+\n+class StubCodeGenerator;\n+\n+class ShenandoahBarrierSetAssembler: public BarrierSetAssembler {\n+private:\n+\n+  \/* ==== Actual barrier implementations ==== *\/\n+  void satb_write_barrier_impl(MacroAssembler* masm, DecoratorSet decorators,\n+                               Register base, RegisterOrConstant ind_or_offs,\n+                               Register pre_val,\n+                               Register tmp1, Register tmp2,\n+                               MacroAssembler::PreservationLevel preservation_level);\n+\n+  void load_reference_barrier_impl(MacroAssembler* masm, DecoratorSet decorators,\n+                                   Register base, RegisterOrConstant ind_or_offs,\n+                                   Register dst,\n+                                   Register tmp1, Register tmp2,\n+                                   MacroAssembler::PreservationLevel preservation_level);\n+\n+  \/* ==== Helper methods for barrier implementations ==== *\/\n+  void resolve_forward_pointer_not_null(MacroAssembler* masm, Register dst, Register tmp);\n+\n+public:\n+\n+  \/* ==== C1 stubs ==== *\/\n+#ifdef COMPILER1\n+\n+  void gen_pre_barrier_stub(LIR_Assembler* ce, ShenandoahPreBarrierStub* stub);\n+\n+  void gen_load_reference_barrier_stub(LIR_Assembler* ce, ShenandoahLoadReferenceBarrierStub* stub);\n+\n+  void generate_c1_pre_barrier_runtime_stub(StubAssembler* sasm);\n+\n+  void generate_c1_load_reference_barrier_runtime_stub(StubAssembler* sasm, DecoratorSet decorators);\n+\n+#endif\n+\n+  \/* ==== Available barriers (facades of the actual implementations) ==== *\/\n+  void satb_write_barrier(MacroAssembler* masm,\n+                          Register base, RegisterOrConstant ind_or_offs,\n+                          Register tmp1, Register tmp2, Register tmp3,\n+                          MacroAssembler::PreservationLevel preservation_level);\n+\n+  void iu_barrier(MacroAssembler* masm,\n+                        Register val,\n+                        Register tmp1, Register tmp2,\n+                        MacroAssembler::PreservationLevel preservation_level, DecoratorSet decorators = 0);\n+\n+  void load_reference_barrier(MacroAssembler* masm, DecoratorSet decorators,\n+                              Register base, RegisterOrConstant ind_or_offs,\n+                              Register dst,\n+                              Register tmp1, Register tmp2,\n+                              MacroAssembler::PreservationLevel preservation_level);\n+\n+  \/* ==== Helper methods used by C1 and C2 ==== *\/\n+  void cmpxchg_oop(MacroAssembler* masm, Register base_addr, Register expected, Register new_val,\n+                   Register tmp1, Register tmp2,\n+                   bool is_cae, Register result);\n+\n+  \/* ==== Access api ==== *\/\n+  virtual void arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                          Register src, Register dst, Register count, Register preserve1, Register preserve2);\n+\n+  virtual void store_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                        Register base, RegisterOrConstant ind_or_offs, Register val,\n+                        Register tmp1, Register tmp2, Register tmp3,\n+                        MacroAssembler::PreservationLevel preservation_level);\n+\n+  virtual void load_at(MacroAssembler* masm, DecoratorSet decorators, BasicType type,\n+                       Register base, RegisterOrConstant ind_or_offs, Register dst,\n+                       Register tmp1, Register tmp2,\n+                       MacroAssembler::PreservationLevel preservation_level, Label* L_handle_null = NULL);\n+\n+  virtual void try_resolve_jobject_in_native(MacroAssembler* masm, Register dst, Register jni_env,\n+                                             Register obj, Register tmp, Label& slowpath);\n+};\n+\n+#endif \/\/ CPU_PPC_GC_SHENANDOAH_SHENANDOAHBARRIERSETASSEMBLER_PPC_HPP\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.hpp","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,217 @@\n+\/\/\n+\/\/ Copyright (c) 2018, 2021, Red Hat, Inc. All rights reserved.\n+\/\/ Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+\n+source_hpp %{\n+#include \"gc\/shenandoah\/shenandoahBarrierSet.hpp\"\n+#include \"gc\/shenandoah\/shenandoahBarrierSetAssembler.hpp\"\n+%}\n+\n+\/\/ Weak compareAndSwap operations are treated as strong compareAndSwap operations.\n+\/\/ This is motivated by the retry logic of ShenandoahBarrierSetAssembler::cmpxchg_oop which is hard to realise\n+\/\/ using weak CAS operations.\n+\n+instruct compareAndSwapP_shenandoah(iRegIdst res, indirect mem, iRegPsrc oldval, iRegPsrc newval,\n+                                    iRegPdst tmp1, iRegPdst tmp2, flagsRegCR0 cr) %{\n+  match(Set res (ShenandoahCompareAndSwapP mem (Binary oldval newval)));\n+  match(Set res (ShenandoahWeakCompareAndSwapP mem (Binary oldval newval)));\n+  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr);\n+\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire\n+            && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n+\n+  format %{ \"CMPXCHG $res, $mem, $oldval, $newval; as bool; ptr\" %}\n+  ins_encode %{\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(\n+        &_masm,\n+        $mem$$Register, $oldval$$Register, $newval$$Register,\n+        $tmp1$$Register, $tmp2$$Register,\n+        false, $res$$Register\n+    );\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct compareAndSwapN_shenandoah(iRegIdst res, indirect mem, iRegNsrc oldval, iRegNsrc newval,\n+                                    iRegNdst tmp1, iRegNdst tmp2, flagsRegCR0 cr) %{\n+  match(Set res (ShenandoahCompareAndSwapN mem (Binary oldval newval)));\n+  match(Set res (ShenandoahWeakCompareAndSwapN mem (Binary oldval newval)));\n+  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr);\n+\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire\n+            && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n+\n+  format %{ \"CMPXCHG $res, $mem, $oldval, $newval; as bool; ptr\" %}\n+  ins_encode %{\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(\n+        &_masm,\n+        $mem$$Register, $oldval$$Register, $newval$$Register,\n+        $tmp1$$Register, $tmp2$$Register,\n+        false, $res$$Register\n+    );\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct compareAndSwapP_acq_shenandoah(iRegIdst res, indirect mem, iRegPsrc oldval, iRegPsrc newval,\n+                                       iRegPdst tmp1, iRegPdst tmp2, flagsRegCR0 cr) %{\n+  match(Set res (ShenandoahCompareAndSwapP mem (Binary oldval newval)));\n+  match(Set res (ShenandoahWeakCompareAndSwapP mem (Binary oldval newval)));\n+  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr);\n+\n+  predicate(((CompareAndSwapNode*)n)->order() == MemNode::acquire\n+            || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst);\n+\n+  format %{ \"CMPXCHGD acq $res, $mem, $oldval, $newval; as bool; ptr\" %}\n+  ins_encode %{\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(\n+        &_masm,\n+        $mem$$Register, $oldval$$Register, $newval$$Register,\n+        $tmp1$$Register, $tmp2$$Register,\n+        false, $res$$Register\n+    );\n+    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+      __ isync();\n+    } else {\n+      __ sync();\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct compareAndSwapN_acq_shenandoah(iRegIdst res, indirect mem, iRegNsrc oldval, iRegNsrc newval,\n+                                        iRegNdst tmp1, iRegNdst tmp2, flagsRegCR0 cr) %{\n+  match(Set res (ShenandoahCompareAndSwapN mem (Binary oldval newval)));\n+  match(Set res (ShenandoahWeakCompareAndSwapN mem (Binary oldval newval)));\n+  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr);\n+\n+  predicate(((CompareAndSwapNode*)n)->order() == MemNode::acquire\n+            || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst);\n+\n+  format %{ \"CMPXCHGD acq $res, $mem, $oldval, $newval; as bool; ptr\" %}\n+  ins_encode %{\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(\n+        &_masm,\n+        $mem$$Register, $oldval$$Register, $newval$$Register,\n+        $tmp1$$Register, $tmp2$$Register,\n+        false, $res$$Register\n+    );\n+    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+      __ isync();\n+    } else {\n+      __ sync();\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct compareAndExchangeP_shenandoah(iRegPdst res, indirect mem, iRegPsrc oldval, iRegPsrc newval,\n+                                        iRegPdst tmp1, iRegPdst tmp2, flagsRegCR0 cr) %{\n+  match(Set res (ShenandoahCompareAndExchangeP mem (Binary oldval newval)));\n+  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr);\n+\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire\n+            && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n+\n+  format %{ \"CMPXCHGD $res, $mem, $oldval, $newval; as ptr; ptr\" %}\n+  ins_encode %{\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(\n+        &_masm,\n+        $mem$$Register, $oldval$$Register, $newval$$Register,\n+        $tmp1$$Register, $tmp2$$Register,\n+        true, $res$$Register\n+    );\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct compareAndExchangeN_shenandoah(iRegNdst res, indirect mem, iRegNsrc oldval, iRegNsrc newval,\n+                                        iRegNdst tmp1, iRegNdst tmp2, flagsRegCR0 cr) %{\n+  match(Set res (ShenandoahCompareAndExchangeN mem (Binary oldval newval)));\n+  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr);\n+\n+  predicate(((CompareAndSwapNode*)n)->order() != MemNode::acquire\n+            && ((CompareAndSwapNode*)n)->order() != MemNode::seqcst);\n+\n+  format %{ \"CMPXCHGD $res, $mem, $oldval, $newval; as ptr; ptr\" %}\n+  ins_encode %{\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(\n+        &_masm,\n+        $mem$$Register, $oldval$$Register, $newval$$Register,\n+        $tmp1$$Register, $tmp2$$Register,\n+        true, $res$$Register\n+    );\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct compareAndExchangePAcq_shenandoah(iRegPdst res, indirect mem, iRegPsrc oldval, iRegPsrc newval,\n+                                           iRegPdst tmp1, iRegPdst tmp2, flagsRegCR0 cr) %{\n+  match(Set res (ShenandoahCompareAndExchangeP mem (Binary oldval newval)));\n+  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr);\n+\n+  predicate(((CompareAndSwapNode*)n)->order() == MemNode::acquire\n+            || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst);\n+\n+  format %{ \"CMPXCHGD acq $res, $mem, $oldval, $newval; as ptr; ptr\" %}\n+  ins_encode %{\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(\n+        &_masm,\n+        $mem$$Register, $oldval$$Register, $newval$$Register,\n+        $tmp1$$Register, $tmp2$$Register,\n+        true, $res$$Register\n+    );\n+    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+      __ isync();\n+    } else {\n+      __ sync();\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct compareAndExchangeNAcq_shenandoah(iRegNdst res, indirect mem, iRegNsrc oldval, iRegNsrc newval,\n+                                           iRegNdst tmp1, iRegNdst tmp2, flagsRegCR0 cr) %{\n+  match(Set res (ShenandoahCompareAndExchangeN mem (Binary oldval newval)));\n+  effect(TEMP_DEF res, TEMP tmp1, TEMP tmp2, KILL cr);\n+\n+  predicate(((CompareAndSwapNode*)n)->order() == MemNode::acquire\n+            || ((CompareAndSwapNode*)n)->order() == MemNode::seqcst);\n+\n+  format %{ \"CMPXCHGD acq $res, $mem, $oldval, $newval; as ptr; ptr\" %}\n+  ins_encode %{\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(\n+        &_masm,\n+        $mem$$Register, $oldval$$Register, $newval$$Register,\n+        $tmp1$$Register, $tmp2$$Register,\n+        true, $res$$Register\n+    );\n+    if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+      __ isync();\n+    } else {\n+      __ sync();\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoah_ppc.ad","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n-FloatRegister LIR_OprDesc::as_float_reg() const {\n+FloatRegister LIR_Opr::as_float_reg() const {\n@@ -36,1 +36,1 @@\n-FloatRegister LIR_OprDesc::as_double_reg() const {\n+FloatRegister LIR_Opr::as_double_reg() const {\n@@ -43,5 +43,5 @@\n-  return (LIR_Opr)(intptr_t)((reg1 << LIR_OprDesc::reg1_shift) |\n-                             (reg1 << LIR_OprDesc::reg2_shift) |\n-                             LIR_OprDesc::double_type          |\n-                             LIR_OprDesc::fpu_register         |\n-                             LIR_OprDesc::double_size);\n+  return (LIR_Opr)(intptr_t)((reg1 << LIR_Opr::reg1_shift) |\n+                             (reg1 << LIR_Opr::reg2_shift) |\n+                             LIR_Opr::double_type          |\n+                             LIR_Opr::fpu_register         |\n+                             LIR_Opr::double_size);\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIR_s390.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-FloatRegister LIR_OprDesc::as_float_reg() const {\n+FloatRegister LIR_Opr::as_float_reg() const {\n@@ -36,1 +36,1 @@\n-FloatRegister LIR_OprDesc::as_double_reg() const {\n+FloatRegister LIR_Opr::as_double_reg() const {\n@@ -41,1 +41,1 @@\n-XMMRegister LIR_OprDesc::as_xmm_float_reg() const {\n+XMMRegister LIR_Opr::as_xmm_float_reg() const {\n@@ -45,1 +45,1 @@\n-XMMRegister LIR_OprDesc::as_xmm_double_reg() const {\n+XMMRegister LIR_Opr::as_xmm_double_reg() const {\n@@ -53,5 +53,5 @@\n-  return (LIR_Opr)(intptr_t)((reg1 << LIR_OprDesc::reg1_shift) |\n-                             (reg1 << LIR_OprDesc::reg2_shift) |\n-                             LIR_OprDesc::double_type          |\n-                             LIR_OprDesc::fpu_register         |\n-                             LIR_OprDesc::double_size);\n+  return (LIR_Opr)(intptr_t)((reg1 << LIR_Opr::reg1_shift) |\n+                             (reg1 << LIR_Opr::reg2_shift) |\n+                             LIR_Opr::double_type          |\n+                             LIR_Opr::fpu_register         |\n+                             LIR_Opr::double_size);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIR_x86.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -577,1 +577,0 @@\n-  \/\/ Intentional fall-through into DONE_LABEL ...\n@@ -579,0 +578,6 @@\n+  jcc(Assembler::equal, DONE_LABEL);           \/\/ CAS above succeeded; propagate ZF = 1 (success)\n+\n+  cmpptr(r15_thread, rax);                     \/\/ Check if we are already the owner (recursive lock)\n+  jcc(Assembler::notEqual, DONE_LABEL);        \/\/ If not recursive, ZF = 0 at this point (fail)\n+  incq(Address(scrReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+  xorq(rax, rax); \/\/ Set ZF = 1 (success) for recursive lock, denoting locking success\n@@ -673,4 +678,0 @@\n-  \/\/ I'd like to add more cases in fast_lock() and fast_unlock() --\n-  \/\/ such as recursive enter and exit -- but we have to be wary of\n-  \/\/ I$ bloat, T$ effects and BP$ effects.\n-  \/\/\n@@ -724,3 +725,10 @@\n-  xorptr(boxReg, boxReg);\n-  orptr(boxReg, Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-  jccb  (Assembler::notZero, DONE_LABEL);\n+  Label LNotRecursive, LSuccess, LGoSlowPath;\n+\n+  cmpptr(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 0);\n+  jccb(Assembler::equal, LNotRecursive);\n+\n+  \/\/ Recursive inflated unlock\n+  decq(Address(tmpReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+  jmpb(LSuccess);\n+\n+  bind(LNotRecursive);\n@@ -735,1 +743,0 @@\n-  Label LSuccess, LGoSlowPath ;\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -158,0 +158,1 @@\n+  NativeCall* call = NULL;\n@@ -160,1 +161,1 @@\n-      break;\n+      return;\n@@ -165,1 +166,1 @@\n-      NativeCall* call = nativeCall_at(_instructions->start() + pc_offset);\n+      call = nativeCall_at(_instructions->start() + pc_offset);\n@@ -175,1 +176,1 @@\n-      NativeCall* call = nativeCall_at(_instructions->start() + pc_offset);\n+      call = nativeCall_at(_instructions->start() + pc_offset);\n@@ -183,1 +184,1 @@\n-      NativeCall* call = nativeCall_at(_instructions->start() + pc_offset);\n+      call = nativeCall_at(_instructions->start() + pc_offset);\n@@ -190,2 +191,5 @@\n-      JVMCI_ERROR(\"invalid _next_call_type value\");\n-      break;\n+      JVMCI_ERROR(\"invalid _next_call_type value: %d\", _next_call_type);\n+      return;\n+  }\n+  if (!call->is_displacement_aligned()) {\n+    JVMCI_ERROR(\"unaligned displacement for call at offset %d\", pc_offset);\n","filename":"src\/hotspot\/cpu\/x86\/jvmciCodeInstaller_x86.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -263,0 +263,3 @@\n+bool NativeCall::is_displacement_aligned() {\n+  return (uintptr_t) displacement_address() % 4 == 0;\n+}\n@@ -285,2 +288,1 @@\n-  bool is_aligned = ((uintptr_t)displacement_address() + 0) \/ cache_line_size ==\n-                    ((uintptr_t)displacement_address() + 3) \/ cache_line_size;\n+  bool is_aligned = is_displacement_aligned();\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -163,2 +163,0 @@\n-  enum { cache_line_size = BytesPerWord };  \/\/ conservative estimate!\n-\n@@ -178,0 +176,2 @@\n+  \/\/ Returns whether the 4-byte displacement operand is 4-byte aligned.\n+  bool  is_displacement_aligned();\n@@ -180,1 +180,1 @@\n-  void  verify_alignment() { assert((intptr_t)addr_at(displacement_offset) % BytesPerInt == 0, \"must be aligned\"); }\n+  void  verify_alignment() { assert(is_displacement_aligned(), \"displacement of call is not aligned\"); }\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -6227,1 +6227,1 @@\n-  predicate(Matcher::vector_length(n) <= 8 && VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(Matcher::vector_length(n) <= 8 && !n->as_ShiftV()->is_var_shift());\n@@ -6247,1 +6247,1 @@\n-  predicate(Matcher::vector_length(n) == 16 && VectorNode::is_vshift_cnt(n->in(2)) &&\n+  predicate(Matcher::vector_length(n) == 16 && !n->as_ShiftV()->is_var_shift() &&\n@@ -6272,1 +6272,1 @@\n-  predicate(Matcher::vector_length(n) == 16 && VectorNode::is_vshift_cnt(n->in(2)) &&\n+  predicate(Matcher::vector_length(n) == 16 && !n->as_ShiftV()->is_var_shift() &&\n@@ -6293,1 +6293,1 @@\n-  predicate(Matcher::vector_length(n) == 32 && VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(Matcher::vector_length(n) == 32 && !n->as_ShiftV()->is_var_shift());\n@@ -6318,1 +6318,1 @@\n-  predicate(Matcher::vector_length(n) == 64 && VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(Matcher::vector_length(n) == 64 && !n->as_ShiftV()->is_var_shift());\n@@ -6351,1 +6351,1 @@\n-  predicate(VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(!n->as_ShiftV()->is_var_shift());\n@@ -6382,1 +6382,1 @@\n-  predicate(VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(!n->as_ShiftV()->is_var_shift());\n@@ -6436,1 +6436,1 @@\n-  predicate(VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(!n->as_ShiftV()->is_var_shift());\n@@ -6477,1 +6477,1 @@\n-  predicate(VectorNode::is_vshift_cnt(n->in(2)) && UseAVX <= 2);\n+  predicate(!n->as_ShiftV()->is_var_shift() && UseAVX <= 2);\n@@ -6506,1 +6506,1 @@\n-  predicate(VectorNode::is_vshift_cnt(n->in(2)) && UseAVX > 2);\n+  predicate(!n->as_ShiftV()->is_var_shift() && UseAVX > 2);\n@@ -6520,1 +6520,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6540,1 +6540,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6568,1 +6568,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6604,1 +6604,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6623,1 +6623,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6647,1 +6647,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6672,1 +6672,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6707,1 +6707,1 @@\n-  predicate(!VectorNode::is_vshift_cnt(n->in(2)) &&\n+  predicate(n->as_ShiftV()->is_var_shift() &&\n@@ -6728,1 +6728,1 @@\n-  predicate(!VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(n->as_ShiftV()->is_var_shift());\n@@ -6745,1 +6745,1 @@\n-  predicate(!VectorNode::is_vshift_cnt(n->in(2)));\n+  predicate(n->as_ShiftV()->is_var_shift());\n@@ -6762,1 +6762,1 @@\n-            !VectorNode::is_vshift_cnt(n->in(2)) &&\n+            n->as_ShiftV()->is_var_shift() &&\n@@ -6777,1 +6777,1 @@\n-  predicate(!VectorNode::is_vshift_cnt(n->in(2)) &&\n+  predicate(n->as_ShiftV()->is_var_shift() &&\n@@ -9092,0 +9092,1 @@\n+  predicate(!n->as_ShiftV()->is_var_shift());\n@@ -9100,1 +9101,0 @@\n-    bool is_varshift = !VectorNode::is_vshift_cnt_opcode(in(2)->isa_Mach()->ideal_Opcode());\n@@ -9102,1 +9102,17 @@\n-                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, is_varshift);\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, false);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vlshiftv_reg_masked(vec dst, vec src2, kReg mask) %{\n+  predicate(n->as_ShiftV()->is_var_shift());\n+  match(Set dst (LShiftVS (Binary dst src2) mask));\n+  match(Set dst (LShiftVI (Binary dst src2) mask));\n+  match(Set dst (LShiftVL (Binary dst src2) mask));\n+  format %{ \"vplshiftv_masked $dst, $dst, $src2, $mask\\t! lshift masked operation\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int opc = this->ideal_Opcode();\n+    __ evmasked_op(opc, bt, $mask$$KRegister, $dst$$XMMRegister,\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, true);\n@@ -9138,0 +9154,1 @@\n+  predicate(!n->as_ShiftV()->is_var_shift());\n@@ -9146,1 +9163,0 @@\n-    bool is_varshift = !VectorNode::is_vshift_cnt_opcode(in(2)->isa_Mach()->ideal_Opcode());\n@@ -9148,1 +9164,17 @@\n-                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, is_varshift);\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, false);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vrshiftv_reg_masked(vec dst, vec src2, kReg mask) %{\n+  predicate(n->as_ShiftV()->is_var_shift());\n+  match(Set dst (RShiftVS (Binary dst src2) mask));\n+  match(Set dst (RShiftVI (Binary dst src2) mask));\n+  match(Set dst (RShiftVL (Binary dst src2) mask));\n+  format %{ \"vprshiftv_masked $dst, $dst, $src2, $mask\\t! rshift masked operation\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int opc = this->ideal_Opcode();\n+    __ evmasked_op(opc, bt, $mask$$KRegister, $dst$$XMMRegister,\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, true);\n@@ -9184,0 +9216,1 @@\n+  predicate(!n->as_ShiftV()->is_var_shift());\n@@ -9192,1 +9225,0 @@\n-    bool is_varshift = !VectorNode::is_vshift_cnt_opcode(in(2)->isa_Mach()->ideal_Opcode());\n@@ -9194,1 +9226,17 @@\n-                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, is_varshift);\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, false);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct vurshiftv_reg_masked(vec dst, vec src2, kReg mask) %{\n+  predicate(n->as_ShiftV()->is_var_shift());\n+  match(Set dst (URShiftVS (Binary dst src2) mask));\n+  match(Set dst (URShiftVI (Binary dst src2) mask));\n+  match(Set dst (URShiftVL (Binary dst src2) mask));\n+  format %{ \"vpurshiftv_masked $dst, $dst, $src2, $mask\\t! urshift masked operation\" %}\n+  ins_encode %{\n+    int vlen_enc = vector_length_encoding(this);\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    int opc = this->ideal_Opcode();\n+    __ evmasked_op(opc, bt, $mask$$KRegister, $dst$$XMMRegister,\n+                   $dst$$XMMRegister, $src2$$XMMRegister, true, vlen_enc, true);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":76,"deletions":28,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -13153,1 +13153,19 @@\n-\/\/ Compare 2 longs and CMOVE ints.\n+instruct cmovII_reg_LTGE_U(cmpOpU cmp, flagsReg_ulong_LTGE flags, rRegI dst, rRegI src) %{\n+  predicate(VM_Version::supports_cmov() && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::lt || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ge ));\n+  match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));\n+  ins_cost(200);\n+  expand %{\n+    cmovII_reg_LTGE(cmp, flags, dst, src);\n+  %}\n+%}\n+\n+instruct cmovII_mem_LTGE_U(cmpOpU cmp, flagsReg_ulong_LTGE flags, rRegI dst, memory src) %{\n+  predicate(VM_Version::supports_cmov() && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::lt || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ge ));\n+  match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));\n+  ins_cost(250);\n+  expand %{\n+    cmovII_mem_LTGE(cmp, flags, dst, src);\n+  %}\n+%}\n+\n+\/\/ Compare 2 longs and CMOVE ptrs.\n@@ -13316,1 +13334,19 @@\n-\/\/ Compare 2 longs and CMOVE ints.\n+instruct cmovII_reg_EQNE_U(cmpOpU cmp, flagsReg_ulong_EQNE flags, rRegI dst, rRegI src) %{\n+  predicate(VM_Version::supports_cmov() && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::eq || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ne ));\n+  match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));\n+  ins_cost(200);\n+  expand %{\n+    cmovII_reg_EQNE(cmp, flags, dst, src);\n+  %}\n+%}\n+\n+instruct cmovII_mem_EQNE_U(cmpOpU cmp, flagsReg_ulong_EQNE flags, rRegI dst, memory src) %{\n+  predicate(VM_Version::supports_cmov() && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::eq || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::ne ));\n+  match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));\n+  ins_cost(250);\n+  expand %{\n+    cmovII_mem_EQNE(cmp, flags, dst, src);\n+  %}\n+%}\n+\n+\/\/ Compare 2 longs and CMOVE ptrs.\n@@ -13472,5 +13508,3 @@\n-  format %{ \"CMOV$cmp $dst.lo,$src.lo\\n\\t\"\n-            \"CMOV$cmp $dst.hi,$src.hi\" %}\n-  opcode(0x0F,0x40);\n-  ins_encode( enc_cmov(cmp), RegReg_Lo2( dst, src ), enc_cmov(cmp), RegReg_Hi2( dst, src ) );\n-  ins_pipe( pipe_cmov_reg_long );\n+  expand %{\n+    cmovLL_reg_LEGT(cmp, flags, dst, src);\n+  %}\n@@ -13483,5 +13517,3 @@\n-  format %{ \"CMOV$cmp $dst.lo,$src.lo\\n\\t\"\n-            \"CMOV$cmp $dst.hi,$src.hi+4\" %}\n-  opcode(0x0F,0x40);\n-  ins_encode( enc_cmov(cmp), RegMem(dst, src), enc_cmov(cmp), RegMem_Hi(dst, src) );\n-  ins_pipe( pipe_cmov_reg_long );\n+  expand %{\n+    cmovLL_mem_LEGT(cmp, flags, dst, src);\n+  %}\n@@ -13511,0 +13543,18 @@\n+instruct cmovII_reg_LEGT_U(cmpOpU_commute cmp, flagsReg_ulong_LEGT flags, rRegI dst, rRegI src) %{\n+  predicate(VM_Version::supports_cmov() && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::le || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::gt ));\n+  match(Set dst (CMoveI (Binary cmp flags) (Binary dst src)));\n+  ins_cost(200);\n+  expand %{\n+    cmovII_reg_LEGT(cmp, flags, dst, src);\n+  %}\n+%}\n+\n+instruct cmovII_mem_LEGT_U(cmpOpU_commute cmp, flagsReg_ulong_LEGT flags, rRegI dst, memory src) %{\n+  predicate(VM_Version::supports_cmov() && ( _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::le || _kids[0]->_kids[0]->_leaf->as_Bool()->_test._test == BoolTest::gt ));\n+  match(Set dst (CMoveI (Binary cmp flags) (Binary dst (LoadI src))));\n+  ins_cost(250);\n+  expand %{\n+    cmovII_mem_LEGT(cmp, flags, dst, src);\n+  %}\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":62,"deletions":12,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -72,2 +72,1 @@\n-\/\/ No performance work done here yet.\n-define_pd_global(bool, CompactStrings, false);\n+define_pd_global(bool, CompactStrings, true);\n","filename":"src\/hotspot\/cpu\/zero\/globals_zero.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-Register LIR_OprDesc::as_register() const {\n+Register LIR_Opr::as_register() const {\n@@ -40,1 +40,1 @@\n-Register LIR_OprDesc::as_register_lo() const {\n+Register LIR_Opr::as_register_lo() const {\n@@ -44,1 +44,1 @@\n-Register LIR_OprDesc::as_register_hi() const {\n+Register LIR_Opr::as_register_hi() const {\n@@ -96,1 +96,1 @@\n-char LIR_OprDesc::type_char(BasicType t) {\n+char LIR_Opr::type_char(BasicType t) {\n@@ -124,1 +124,1 @@\n-void LIR_OprDesc::validate_type() const {\n+void LIR_Opr::validate_type() const {\n@@ -176,1 +176,1 @@\n-bool LIR_OprDesc::is_oop() const {\n+bool LIR_Opr::is_oop() const {\n@@ -1376,1 +1376,1 @@\n-  \/\/ guarantee(sizeof(LIR_OprDesc) == wordSize, \"may not have a v-table\");\n+  \/\/ guarantee(sizeof(LIR_Opr) == wordSize, \"may not have a v-table\");\n@@ -1451,2 +1451,2 @@\n-\/\/ LIR_OprDesc\n-void LIR_OprDesc::print() const {\n+\/\/ LIR_Opr\n+void LIR_Opr::print() const {\n@@ -1456,1 +1456,1 @@\n-void LIR_OprDesc::print(outputStream* out) const {\n+void LIR_Opr::print(outputStream* out) const {\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -481,10 +481,1 @@\n-\/\/ TODO: Remove this hack.\n-\/\/ UGLY HACK: add a type alias. `LIR_Opr` is not actually equivalent to the\n-\/\/ previous `LIR_OprDesc` (`LIR_Opr` is like more similar to previous\n-\/\/ `LIR_OprDesc*`). The only purpose of this typedef is so that the various\n-\/\/ `LIR_OprDesc::enum_value` scattered everywhere don't need to be\n-\/\/ modified. This should be removed, and a textual replacement of\n-\/\/ `LIR_OprDesc::` to `LIR_Opr::` done throughout the code.\n-typedef LIR_Opr LIR_OprDesc;\n-\n-inline LIR_OprDesc::OprType as_OprType(BasicType type) {\n+inline LIR_Opr::OprType as_OprType(BasicType type) {\n@@ -492,4 +483,4 @@\n-  case T_INT:      return LIR_OprDesc::int_type;\n-  case T_LONG:     return LIR_OprDesc::long_type;\n-  case T_FLOAT:    return LIR_OprDesc::float_type;\n-  case T_DOUBLE:   return LIR_OprDesc::double_type;\n+  case T_INT:      return LIR_Opr::int_type;\n+  case T_LONG:     return LIR_Opr::long_type;\n+  case T_FLOAT:    return LIR_Opr::float_type;\n+  case T_DOUBLE:   return LIR_Opr::double_type;\n@@ -497,3 +488,3 @@\n-  case T_ARRAY:    return LIR_OprDesc::object_type;\n-  case T_ADDRESS:  return LIR_OprDesc::address_type;\n-  case T_METADATA: return LIR_OprDesc::metadata_type;\n+  case T_ARRAY:    return LIR_Opr::object_type;\n+  case T_ADDRESS:  return LIR_Opr::address_type;\n+  case T_METADATA: return LIR_Opr::metadata_type;\n@@ -501,1 +492,1 @@\n-  default: ShouldNotReachHere(); return LIR_OprDesc::unknown_type;\n+  default: ShouldNotReachHere(); return LIR_Opr::unknown_type;\n@@ -505,1 +496,1 @@\n-inline BasicType as_BasicType(LIR_OprDesc::OprType t) {\n+inline BasicType as_BasicType(LIR_Opr::OprType t) {\n@@ -507,8 +498,8 @@\n-  case LIR_OprDesc::int_type:     return T_INT;\n-  case LIR_OprDesc::long_type:    return T_LONG;\n-  case LIR_OprDesc::float_type:   return T_FLOAT;\n-  case LIR_OprDesc::double_type:  return T_DOUBLE;\n-  case LIR_OprDesc::object_type:  return T_OBJECT;\n-  case LIR_OprDesc::address_type: return T_ADDRESS;\n-  case LIR_OprDesc::metadata_type:return T_METADATA;\n-  case LIR_OprDesc::unknown_type: \/\/ fall through\n+  case LIR_Opr::int_type:     return T_INT;\n+  case LIR_Opr::long_type:    return T_LONG;\n+  case LIR_Opr::float_type:   return T_FLOAT;\n+  case LIR_Opr::double_type:  return T_DOUBLE;\n+  case LIR_Opr::object_type:  return T_OBJECT;\n+  case LIR_Opr::address_type: return T_ADDRESS;\n+  case LIR_Opr::metadata_type:return T_METADATA;\n+  case LIR_Opr::unknown_type: \/\/ fall through\n@@ -552,1 +543,1 @@\n-     , _index(LIR_OprDesc::illegalOpr())\n+     , _index(LIR_Opr::illegalOpr())\n@@ -559,1 +550,1 @@\n-     , _index(LIR_OprDesc::illegalOpr())\n+     , _index(LIR_Opr::illegalOpr())\n@@ -603,4 +594,4 @@\n-    return (LIR_Opr)(intptr_t)((reg  << LIR_OprDesc::reg1_shift) |\n-                               LIR_OprDesc::int_type             |\n-                               LIR_OprDesc::cpu_register         |\n-                               LIR_OprDesc::single_size);\n+    return (LIR_Opr)(intptr_t)((reg  << LIR_Opr::reg1_shift) |\n+                               LIR_Opr::int_type             |\n+                               LIR_Opr::cpu_register         |\n+                               LIR_Opr::single_size);\n@@ -609,4 +600,4 @@\n-    return (LIR_Opr)(intptr_t)((reg  << LIR_OprDesc::reg1_shift) |\n-                               LIR_OprDesc::object_type          |\n-                               LIR_OprDesc::cpu_register         |\n-                               LIR_OprDesc::single_size);\n+    return (LIR_Opr)(intptr_t)((reg  << LIR_Opr::reg1_shift) |\n+                               LIR_Opr::object_type          |\n+                               LIR_Opr::cpu_register         |\n+                               LIR_Opr::single_size);\n@@ -615,4 +606,4 @@\n-    return (LIR_Opr)(intptr_t)((reg  << LIR_OprDesc::reg1_shift) |\n-                               LIR_OprDesc::address_type         |\n-                               LIR_OprDesc::cpu_register         |\n-                               LIR_OprDesc::single_size);\n+    return (LIR_Opr)(intptr_t)((reg  << LIR_Opr::reg1_shift) |\n+                               LIR_Opr::address_type         |\n+                               LIR_Opr::cpu_register         |\n+                               LIR_Opr::single_size);\n@@ -621,4 +612,4 @@\n-    return (LIR_Opr)(intptr_t)((reg  << LIR_OprDesc::reg1_shift) |\n-                               LIR_OprDesc::metadata_type        |\n-                               LIR_OprDesc::cpu_register         |\n-                               LIR_OprDesc::single_size);\n+    return (LIR_Opr)(intptr_t)((reg  << LIR_Opr::reg1_shift) |\n+                               LIR_Opr::metadata_type        |\n+                               LIR_Opr::cpu_register         |\n+                               LIR_Opr::single_size);\n@@ -628,5 +619,5 @@\n-    return (LIR_Opr)(intptr_t)((reg1 << LIR_OprDesc::reg1_shift) |\n-                               (reg2 << LIR_OprDesc::reg2_shift) |\n-                               LIR_OprDesc::long_type            |\n-                               LIR_OprDesc::cpu_register         |\n-                               LIR_OprDesc::double_size);\n+    return (LIR_Opr)(intptr_t)((reg1 << LIR_Opr::reg1_shift) |\n+                               (reg2 << LIR_Opr::reg2_shift) |\n+                               LIR_Opr::long_type            |\n+                               LIR_Opr::cpu_register         |\n+                               LIR_Opr::double_size);\n@@ -636,4 +627,4 @@\n-    return (LIR_Opr)(intptr_t)((reg  << LIR_OprDesc::reg1_shift) |\n-                               LIR_OprDesc::float_type           |\n-                               LIR_OprDesc::fpu_register         |\n-                               LIR_OprDesc::single_size);\n+    return (LIR_Opr)(intptr_t)((reg  << LIR_Opr::reg1_shift) |\n+                               LIR_Opr::float_type           |\n+                               LIR_Opr::fpu_register         |\n+                               LIR_Opr::single_size);\n@@ -647,4 +638,4 @@\n-    return (LIR_Opr)(intptr_t)((reg  << LIR_OprDesc::reg1_shift) |\n-                               LIR_OprDesc::float_type           |\n-                               LIR_OprDesc::cpu_register         |\n-                               LIR_OprDesc::single_size);\n+    return (LIR_Opr)(intptr_t)((reg  << LIR_Opr::reg1_shift) |\n+                               LIR_Opr::float_type           |\n+                               LIR_Opr::cpu_register         |\n+                               LIR_Opr::single_size);\n@@ -653,5 +644,5 @@\n-    return (LIR_Opr)(intptr_t)((reg1 << LIR_OprDesc::reg1_shift) |\n-                               (reg2 << LIR_OprDesc::reg2_shift) |\n-                               LIR_OprDesc::double_type          |\n-                               LIR_OprDesc::cpu_register         |\n-                               LIR_OprDesc::double_size);\n+    return (LIR_Opr)(intptr_t)((reg1 << LIR_Opr::reg1_shift) |\n+                               (reg2 << LIR_Opr::reg2_shift) |\n+                               LIR_Opr::double_type          |\n+                               LIR_Opr::cpu_register         |\n+                               LIR_Opr::double_size);\n@@ -663,5 +654,5 @@\n-    return (LIR_Opr)(intptr_t)((reg << LIR_OprDesc::reg1_shift) |\n-                               LIR_OprDesc::float_type          |\n-                               LIR_OprDesc::fpu_register        |\n-                               LIR_OprDesc::single_size         |\n-                               LIR_OprDesc::is_xmm_mask);\n+    return (LIR_Opr)(intptr_t)((reg << LIR_Opr::reg1_shift) |\n+                               LIR_Opr::float_type          |\n+                               LIR_Opr::fpu_register        |\n+                               LIR_Opr::single_size         |\n+                               LIR_Opr::is_xmm_mask);\n@@ -670,6 +661,6 @@\n-    return (LIR_Opr)(intptr_t)((reg << LIR_OprDesc::reg1_shift) |\n-                               (reg << LIR_OprDesc::reg2_shift) |\n-                               LIR_OprDesc::double_type         |\n-                               LIR_OprDesc::fpu_register        |\n-                               LIR_OprDesc::double_size         |\n-                               LIR_OprDesc::is_xmm_mask);\n+    return (LIR_Opr)(intptr_t)((reg << LIR_Opr::reg1_shift) |\n+                               (reg << LIR_Opr::reg2_shift) |\n+                               LIR_Opr::double_type         |\n+                               LIR_Opr::fpu_register        |\n+                               LIR_Opr::double_size         |\n+                               LIR_Opr::is_xmm_mask);\n@@ -680,1 +671,1 @@\n-    if (index > LIR_OprDesc::vreg_max) {\n+    if (index > LIR_Opr::vreg_max) {\n@@ -689,5 +680,5 @@\n-        res = (LIR_Opr)(intptr_t)((index << LIR_OprDesc::data_shift)  |\n-                                            LIR_OprDesc::object_type  |\n-                                            LIR_OprDesc::cpu_register |\n-                                            LIR_OprDesc::single_size  |\n-                                            LIR_OprDesc::virtual_mask);\n+        res = (LIR_Opr)(intptr_t)((index << LIR_Opr::data_shift)  |\n+                                            LIR_Opr::object_type  |\n+                                            LIR_Opr::cpu_register |\n+                                            LIR_Opr::single_size  |\n+                                            LIR_Opr::virtual_mask);\n@@ -697,5 +688,5 @@\n-        res = (LIR_Opr)(intptr_t)((index << LIR_OprDesc::data_shift)  |\n-                                            LIR_OprDesc::metadata_type|\n-                                            LIR_OprDesc::cpu_register |\n-                                            LIR_OprDesc::single_size  |\n-                                            LIR_OprDesc::virtual_mask);\n+        res = (LIR_Opr)(intptr_t)((index << LIR_Opr::data_shift)  |\n+                                            LIR_Opr::metadata_type|\n+                                            LIR_Opr::cpu_register |\n+                                            LIR_Opr::single_size  |\n+                                            LIR_Opr::virtual_mask);\n@@ -705,5 +696,5 @@\n-        res = (LIR_Opr)(intptr_t)((index << LIR_OprDesc::data_shift) |\n-                                  LIR_OprDesc::int_type              |\n-                                  LIR_OprDesc::cpu_register          |\n-                                  LIR_OprDesc::single_size           |\n-                                  LIR_OprDesc::virtual_mask);\n+        res = (LIR_Opr)(intptr_t)((index << LIR_Opr::data_shift) |\n+                                  LIR_Opr::int_type              |\n+                                  LIR_Opr::cpu_register          |\n+                                  LIR_Opr::single_size           |\n+                                  LIR_Opr::virtual_mask);\n@@ -713,5 +704,5 @@\n-        res = (LIR_Opr)(intptr_t)((index << LIR_OprDesc::data_shift) |\n-                                  LIR_OprDesc::address_type          |\n-                                  LIR_OprDesc::cpu_register          |\n-                                  LIR_OprDesc::single_size           |\n-                                  LIR_OprDesc::virtual_mask);\n+        res = (LIR_Opr)(intptr_t)((index << LIR_Opr::data_shift) |\n+                                  LIR_Opr::address_type          |\n+                                  LIR_Opr::cpu_register          |\n+                                  LIR_Opr::single_size           |\n+                                  LIR_Opr::virtual_mask);\n@@ -721,5 +712,5 @@\n-        res = (LIR_Opr)(intptr_t)((index << LIR_OprDesc::data_shift) |\n-                                  LIR_OprDesc::long_type             |\n-                                  LIR_OprDesc::cpu_register          |\n-                                  LIR_OprDesc::double_size           |\n-                                  LIR_OprDesc::virtual_mask);\n+        res = (LIR_Opr)(intptr_t)((index << LIR_Opr::data_shift) |\n+                                  LIR_Opr::long_type             |\n+                                  LIR_Opr::cpu_register          |\n+                                  LIR_Opr::double_size           |\n+                                  LIR_Opr::virtual_mask);\n@@ -730,5 +721,5 @@\n-        res = (LIR_Opr)(intptr_t)((index << LIR_OprDesc::data_shift) |\n-                                  LIR_OprDesc::float_type  |\n-                                  LIR_OprDesc::cpu_register |\n-                                  LIR_OprDesc::single_size |\n-                                  LIR_OprDesc::virtual_mask);\n+        res = (LIR_Opr)(intptr_t)((index << LIR_Opr::data_shift) |\n+                                  LIR_Opr::float_type  |\n+                                  LIR_Opr::cpu_register |\n+                                  LIR_Opr::single_size |\n+                                  LIR_Opr::virtual_mask);\n@@ -737,5 +728,5 @@\n-        res = (LIR_Opr)(intptr_t)((index << LIR_OprDesc::data_shift) |\n-                                  LIR_OprDesc::double_type |\n-                                  LIR_OprDesc::cpu_register |\n-                                  LIR_OprDesc::double_size |\n-                                  LIR_OprDesc::virtual_mask);\n+        res = (LIR_Opr)(intptr_t)((index << LIR_Opr::data_shift) |\n+                                  LIR_Opr::double_type |\n+                                  LIR_Opr::cpu_register |\n+                                  LIR_Opr::double_size |\n+                                  LIR_Opr::virtual_mask);\n@@ -745,5 +736,5 @@\n-        res = (LIR_Opr)(intptr_t)((index << LIR_OprDesc::data_shift) |\n-                                  LIR_OprDesc::float_type           |\n-                                  LIR_OprDesc::fpu_register         |\n-                                  LIR_OprDesc::single_size          |\n-                                  LIR_OprDesc::virtual_mask);\n+        res = (LIR_Opr)(intptr_t)((index << LIR_Opr::data_shift) |\n+                                  LIR_Opr::float_type           |\n+                                  LIR_Opr::fpu_register         |\n+                                  LIR_Opr::single_size          |\n+                                  LIR_Opr::virtual_mask);\n@@ -753,5 +744,5 @@\n-        T_DOUBLE: res = (LIR_Opr)(intptr_t)((index << LIR_OprDesc::data_shift) |\n-                                            LIR_OprDesc::double_type           |\n-                                            LIR_OprDesc::fpu_register          |\n-                                            LIR_OprDesc::double_size           |\n-                                            LIR_OprDesc::virtual_mask);\n+        T_DOUBLE: res = (LIR_Opr)(intptr_t)((index << LIR_Opr::data_shift) |\n+                                            LIR_Opr::double_type           |\n+                                            LIR_Opr::fpu_register          |\n+                                            LIR_Opr::double_size           |\n+                                            LIR_Opr::virtual_mask);\n@@ -766,2 +757,2 @@\n-    assert(index >= LIR_OprDesc::vreg_base, \"must start at vreg_base\");\n-    assert(index <= (max_jint >> LIR_OprDesc::data_shift), \"index is too big\");\n+    assert(index >= LIR_Opr::vreg_base, \"must start at vreg_base\");\n+    assert(index <= (max_jint >> LIR_Opr::data_shift), \"index is too big\");\n@@ -770,1 +761,1 @@\n-    LIR_OprDesc::OprType t = as_OprType(type);\n+    LIR_Opr::OprType t = as_OprType(type);\n@@ -772,1 +763,1 @@\n-    LIR_Opr old_res = (LIR_Opr)(intptr_t)((index << LIR_OprDesc::data_shift) |\n+    LIR_Opr old_res = (LIR_Opr)(intptr_t)((index << LIR_Opr::data_shift) |\n@@ -774,2 +765,2 @@\n-                               LIR_OprDesc::cpu_register |\n-                               LIR_OprDesc::size_for(type) | LIR_OprDesc::virtual_mask);\n+                               LIR_Opr::cpu_register |\n+                               LIR_Opr::size_for(type) | LIR_Opr::virtual_mask);\n@@ -777,3 +768,3 @@\n-    LIR_Opr old_res = (LIR_Opr)(intptr_t)((index << LIR_OprDesc::data_shift) | t |\n-                                          ((type == T_FLOAT || type == T_DOUBLE) ?  LIR_OprDesc::fpu_register : LIR_OprDesc::cpu_register) |\n-                               LIR_OprDesc::size_for(type) | LIR_OprDesc::virtual_mask);\n+    LIR_Opr old_res = (LIR_Opr)(intptr_t)((index << LIR_Opr::data_shift) | t |\n+                                          ((type == T_FLOAT || type == T_DOUBLE) ?  LIR_Opr::fpu_register : LIR_Opr::cpu_register) |\n+                               LIR_Opr::size_for(type) | LIR_Opr::virtual_mask);\n@@ -795,4 +786,4 @@\n-        res = (LIR_Opr)(intptr_t)((index << LIR_OprDesc::data_shift) |\n-                                  LIR_OprDesc::object_type           |\n-                                  LIR_OprDesc::stack_value           |\n-                                  LIR_OprDesc::single_size);\n+        res = (LIR_Opr)(intptr_t)((index << LIR_Opr::data_shift) |\n+                                  LIR_Opr::object_type           |\n+                                  LIR_Opr::stack_value           |\n+                                  LIR_Opr::single_size);\n@@ -802,4 +793,4 @@\n-        res = (LIR_Opr)(intptr_t)((index << LIR_OprDesc::data_shift) |\n-                                  LIR_OprDesc::metadata_type         |\n-                                  LIR_OprDesc::stack_value           |\n-                                  LIR_OprDesc::single_size);\n+        res = (LIR_Opr)(intptr_t)((index << LIR_Opr::data_shift) |\n+                                  LIR_Opr::metadata_type         |\n+                                  LIR_Opr::stack_value           |\n+                                  LIR_Opr::single_size);\n@@ -808,4 +799,4 @@\n-        res = (LIR_Opr)(intptr_t)((index << LIR_OprDesc::data_shift) |\n-                                  LIR_OprDesc::int_type              |\n-                                  LIR_OprDesc::stack_value           |\n-                                  LIR_OprDesc::single_size);\n+        res = (LIR_Opr)(intptr_t)((index << LIR_Opr::data_shift) |\n+                                  LIR_Opr::int_type              |\n+                                  LIR_Opr::stack_value           |\n+                                  LIR_Opr::single_size);\n@@ -815,4 +806,4 @@\n-        res = (LIR_Opr)(intptr_t)((index << LIR_OprDesc::data_shift) |\n-                                  LIR_OprDesc::address_type          |\n-                                  LIR_OprDesc::stack_value           |\n-                                  LIR_OprDesc::single_size);\n+        res = (LIR_Opr)(intptr_t)((index << LIR_Opr::data_shift) |\n+                                  LIR_Opr::address_type          |\n+                                  LIR_Opr::stack_value           |\n+                                  LIR_Opr::single_size);\n@@ -822,4 +813,4 @@\n-        res = (LIR_Opr)(intptr_t)((index << LIR_OprDesc::data_shift) |\n-                                  LIR_OprDesc::long_type             |\n-                                  LIR_OprDesc::stack_value           |\n-                                  LIR_OprDesc::double_size);\n+        res = (LIR_Opr)(intptr_t)((index << LIR_Opr::data_shift) |\n+                                  LIR_Opr::long_type             |\n+                                  LIR_Opr::stack_value           |\n+                                  LIR_Opr::double_size);\n@@ -829,4 +820,4 @@\n-        res = (LIR_Opr)(intptr_t)((index << LIR_OprDesc::data_shift) |\n-                                  LIR_OprDesc::float_type            |\n-                                  LIR_OprDesc::stack_value           |\n-                                  LIR_OprDesc::single_size);\n+        res = (LIR_Opr)(intptr_t)((index << LIR_Opr::data_shift) |\n+                                  LIR_Opr::float_type            |\n+                                  LIR_Opr::stack_value           |\n+                                  LIR_Opr::single_size);\n@@ -835,4 +826,4 @@\n-        res = (LIR_Opr)(intptr_t)((index << LIR_OprDesc::data_shift) |\n-                                  LIR_OprDesc::double_type           |\n-                                  LIR_OprDesc::stack_value           |\n-                                  LIR_OprDesc::double_size);\n+        res = (LIR_Opr)(intptr_t)((index << LIR_Opr::data_shift) |\n+                                  LIR_Opr::double_type           |\n+                                  LIR_Opr::stack_value           |\n+                                  LIR_Opr::double_size);\n@@ -846,1 +837,1 @@\n-    assert(index <= (max_jint >> LIR_OprDesc::data_shift), \"index is too big\");\n+    assert(index <= (max_jint >> LIR_Opr::data_shift), \"index is too big\");\n@@ -848,2 +839,2 @@\n-    LIR_Opr old_res = (LIR_Opr)(intptr_t)((index << LIR_OprDesc::data_shift) |\n-                                          LIR_OprDesc::stack_value           |\n+    LIR_Opr old_res = (LIR_Opr)(intptr_t)((index << LIR_Opr::data_shift) |\n+                                          LIR_Opr::stack_value           |\n@@ -851,1 +842,1 @@\n-                                          LIR_OprDesc::size_for(type));\n+                                          LIR_Opr::size_for(type));\n@@ -2477,1 +2468,1 @@\n-inline LIR_Opr LIR_OprDesc::illegalOpr()   { return LIR_OprFact::illegalOpr; };\n+inline LIR_Opr LIR_Opr::illegalOpr()   { return LIR_OprFact::illegalOpr; };\n@@ -2479,1 +2470,1 @@\n-inline LIR_Opr LIR_OprDesc::nullOpr()   { return LIR_OprFact::nullOpr; };\n+inline LIR_Opr LIR_Opr::nullOpr()   { return LIR_OprFact::nullOpr; };\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":154,"deletions":163,"binary":false,"changes":317,"status":"modified"},{"patch":"@@ -1022,1 +1022,1 @@\n-  if (vreg_num + 20 >= LIR_OprDesc::vreg_max) {\n+  if (vreg_num + 20 >= LIR_Opr::vreg_max) {\n@@ -1024,1 +1024,1 @@\n-    if (vreg_num + 2 >= LIR_OprDesc::vreg_max) {\n+    if (vreg_num + 2 >= LIR_Opr::vreg_max) {\n@@ -1026,2 +1026,2 @@\n-      _virtual_register_number = LIR_OprDesc::vreg_base;\n-      vreg_num = LIR_OprDesc::vreg_base;\n+      _virtual_register_number = LIR_Opr::vreg_base;\n+      vreg_num = LIR_Opr::vreg_base;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -505,1 +505,1 @@\n-    , _virtual_register_number(LIR_OprDesc::vreg_base)\n+    , _virtual_register_number(LIR_Opr::vreg_base)\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-  return i->reg_num() >= LIR_OprDesc::vreg_base;\n+  return i->reg_num() >= LIR_Opr::vreg_base;\n@@ -185,1 +185,1 @@\n-  return i->reg_num() >= LIR_OprDesc::vreg_base;\n+  return i->reg_num() >= LIR_Opr::vreg_base;\n@@ -187,1 +187,1 @@\n-  return i->reg_num() >= LIR_OprDesc::vreg_base && (i->type() != T_FLOAT && i->type() != T_DOUBLE);\n+  return i->reg_num() >= LIR_Opr::vreg_base && (i->type() != T_FLOAT && i->type() != T_DOUBLE);\n@@ -199,1 +199,1 @@\n-  return i->reg_num() >= LIR_OprDesc::vreg_base && (i->type() == T_FLOAT || i->type() == T_DOUBLE);\n+  return i->reg_num() >= LIR_Opr::vreg_base && (i->type() == T_FLOAT || i->type() == T_DOUBLE);\n@@ -277,1 +277,1 @@\n-  if (reg_num < LIR_OprDesc::vreg_base) {\n+  if (reg_num < LIR_Opr::vreg_base) {\n@@ -822,1 +822,1 @@\n-    for (int j = 0; j < LIR_OprDesc::vreg_base; j++) {\n+    for (int j = 0; j < LIR_Opr::vreg_base; j++) {\n@@ -1336,1 +1336,1 @@\n-      assert(number >= LIR_OprDesc::vreg_base, \"fixed intervals must not be live on block bounds\");\n+      assert(number >= LIR_Opr::vreg_base, \"fixed intervals must not be live on block bounds\");\n@@ -1709,1 +1709,1 @@\n-  result = new Interval(LIR_OprDesc::vreg_base);\n+  result = new Interval(LIR_Opr::vreg_base);\n@@ -2438,1 +2438,1 @@\n-    assert(interval->reg_num() >= LIR_OprDesc::vreg_base, \"fixed interval found\");\n+    assert(interval->reg_num() >= LIR_Opr::vreg_base, \"fixed interval found\");\n@@ -3221,1 +3221,1 @@\n-  } else if (reg_num >= LIR_OprDesc::vreg_base) {\n+  } else if (reg_num >= LIR_Opr::vreg_base) {\n@@ -3301,1 +3301,1 @@\n-    if (i1->reg_num() >= LIR_OprDesc::vreg_base && i1->type() == T_ILLEGAL) {\n+    if (i1->reg_num() >= LIR_Opr::vreg_base && i1->type() == T_ILLEGAL) {\n@@ -3972,1 +3972,1 @@\n-  if (reg_num + 20 >= LIR_OprDesc::vreg_max) {\n+  if (reg_num + 20 >= LIR_Opr::vreg_max) {\n@@ -3974,1 +3974,1 @@\n-    if (reg_num + 2 >= LIR_OprDesc::vreg_max) {\n+    if (reg_num + 2 >= LIR_Opr::vreg_max) {\n@@ -3976,1 +3976,1 @@\n-      reg_num = LIR_OprDesc::vreg_base;\n+      reg_num = LIR_Opr::vreg_base;\n@@ -4408,1 +4408,1 @@\n-  if (use_kind != noUse && reg_num() >= LIR_OprDesc::vreg_base) {\n+  if (use_kind != noUse && reg_num() >= LIR_Opr::vreg_base) {\n@@ -4638,1 +4638,1 @@\n-  if (reg_num() < LIR_OprDesc::vreg_base) {\n+  if (reg_num() < LIR_Opr::vreg_base) {\n@@ -4655,1 +4655,1 @@\n-    if (reg_num() < LIR_OprDesc::vreg_base) {\n+    if (reg_num() < LIR_Opr::vreg_base) {\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -550,2 +550,2 @@\n-  BasicType        type() const                  { assert(_reg_num == -1 || _reg_num >= LIR_OprDesc::vreg_base, \"cannot access type for fixed interval\"); return _type; }\n-  void             set_type(BasicType type)      { assert(_reg_num < LIR_OprDesc::vreg_base || _type == T_ILLEGAL || _type == type, \"overwriting existing type\"); _type = type; }\n+  BasicType        type() const                  { assert(_reg_num == -1 || _reg_num >= LIR_Opr::vreg_base, \"cannot access type for fixed interval\"); return _type; }\n+  void             set_type(BasicType type)      { assert(_reg_num < LIR_Opr::vreg_base || _type == T_ILLEGAL || _type == type, \"overwriting existing type\"); _type = type; }\n","filename":"src\/hotspot\/share\/c1\/c1_LinearScan.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1657,0 +1657,1 @@\n+\n@@ -1659,1 +1660,2 @@\n-  out->print_cr(\"instanceKlass %s\", CURRENT_ENV->replay_name(task()->method()->method_holder()));\n+  ciInstanceKlass::dump_replay_instanceKlass(out, task()->method()->method_holder());\n+\n@@ -1684,2 +1686,2 @@\n-  static char buffer[O_BUFLEN];\n-  int ret = jio_snprintf(buffer, O_BUFLEN, \"replay_pid%p_compid%d.log\", os::current_process_id(), compile_id);\n+  char buffer[64];\n+  int ret = jio_snprintf(buffer, sizeof(buffer), \"replay_pid%d_compid%d.log\", os::current_process_id(), compile_id);\n@@ -1702,2 +1704,2 @@\n-  static char buffer[O_BUFLEN];\n-  int ret = jio_snprintf(buffer, O_BUFLEN, \"inline_pid%p_compid%d.log\", os::current_process_id(), compile_id);\n+  char buffer[64];\n+  int ret = jio_snprintf(buffer, sizeof(buffer), \"inline_pid%d_compid%d.log\", os::current_process_id(), compile_id);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -735,0 +735,13 @@\n+void ciInstanceKlass::dump_replay_instanceKlass(outputStream* out, InstanceKlass* ik) {\n+  if (ik->is_hidden()) {\n+    const char *name = CURRENT_ENV->dyno_name(ik);\n+    if (name != NULL) {\n+      out->print_cr(\"instanceKlass %s # %s\", name, ik->name()->as_quoted_ascii());\n+    } else {\n+      out->print_cr(\"# instanceKlass %s\", ik->name()->as_quoted_ascii());\n+    }\n+  } else {\n+    out->print_cr(\"instanceKlass %s\", ik->name()->as_quoted_ascii());\n+  }\n+}\n+\n@@ -746,10 +759,1 @@\n-      if (isub->is_hidden()) {\n-        const char *name = CURRENT_ENV->dyno_name(isub);\n-        if (name != NULL) {\n-          out->print_cr(\"instanceKlass %s # %s\", name, sub->name()->as_quoted_ascii());\n-        } else {\n-          out->print_cr(\"# instanceKlass %s\", sub->name()->as_quoted_ascii());\n-        }\n-      } else {\n-        out->print_cr(\"instanceKlass %s\", sub->name()->as_quoted_ascii());\n-      }\n+      dump_replay_instanceKlass(out, isub);\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -296,0 +296,3 @@\n+  static void dump_replay_instanceKlass(outputStream* out, InstanceKlass* ik);\n+\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+  bool _inline_late;\n@@ -439,1 +440,1 @@\n-        obj = cp->resolve_possibly_cached_constant_at(bootstrap_specifier.bsm_index(), thread);\n+        obj = cp->resolve_possibly_cached_constant_at(bootstrap_specifier.bsm_index(), CHECK_NULL);\n@@ -468,5 +469,6 @@\n-      {\n-        bool found_it;\n-        ik->link_class(CHECK_NULL);\n-        obj = cp->find_cached_constant_at(cpi, found_it, thread);\n-      }\n+      ik->link_class(CHECK_NULL);\n+      obj = cp->resolve_possibly_cached_constant_at(cpi, CHECK_NULL);\n+    }\n+    if (obj == NULL) {\n+      report_error(\"null cp object found\");\n+      return NULL;\n@@ -475,8 +477,18 @@\n-    if (obj != NULL) {\n-      skip_ws();\n-      \/\/ loop: read fields\n-      char* field = NULL;\n-      do {\n-        field = parse_string();\n-        if (field == NULL) {\n-          report_error(\"no field found\");\n+    skip_ws();\n+    \/\/ loop: read fields\n+    char* field = NULL;\n+    do {\n+      field = parse_string();\n+      if (field == NULL) {\n+        report_error(\"no field found\");\n+        return NULL;\n+      }\n+      if (strcmp(field, \";\") == 0) {\n+        break;\n+      }\n+      \/\/ raw Method*\n+      if (strcmp(field, \"<vmtarget>\") == 0) {\n+        Method* vmtarget = java_lang_invoke_MemberName::vmtarget(obj);\n+        k = (vmtarget == NULL) ? NULL : vmtarget->method_holder();\n+        if (k == NULL) {\n+          report_error(\"null vmtarget found\");\n@@ -485,16 +497,3 @@\n-        if (strcmp(field, \";\") == 0) {\n-          break;\n-        }\n-        \/\/ raw Method*\n-        if (strcmp(field, \"<vmtarget>\") == 0) {\n-          Method* vmtarget = java_lang_invoke_MemberName::vmtarget(obj);\n-          k = (vmtarget == NULL) ? NULL : vmtarget->method_holder();\n-          if (k == NULL) {\n-            report_error(\"null vmtarget found\");\n-            return NULL;\n-          }\n-          if (!parse_terminator()) {\n-            report_error(\"missing terminator\");\n-            return NULL;\n-          }\n-          return k;\n+        if (!parse_terminator()) {\n+          report_error(\"missing terminator\");\n+          return NULL;\n@@ -502,10 +501,10 @@\n-        obj = ciReplay::obj_field(obj, field);\n-        \/\/ array\n-        if (obj != NULL && obj->is_objArray()) {\n-          objArrayOop arr = (objArrayOop)obj;\n-          int index = parse_int(\"index\");\n-          if (index >= arr->length()) {\n-            report_error(\"bad array index\");\n-            return NULL;\n-          }\n-          obj = arr->obj_at(index);\n+        return k;\n+      }\n+      obj = ciReplay::obj_field(obj, field);\n+      \/\/ array\n+      if (obj != NULL && obj->is_objArray()) {\n+        objArrayOop arr = (objArrayOop)obj;\n+        int index = parse_int(\"index\");\n+        if (index >= arr->length()) {\n+          report_error(\"bad array index\");\n+          return NULL;\n@@ -513,4 +512,1 @@\n-      } while (obj != NULL);\n-      if (obj == NULL) {\n-        report_error(\"null field found\");\n-        return NULL;\n+        obj = arr->obj_at(index);\n@@ -518,1 +514,4 @@\n-      k = obj->klass();\n+    } while (obj != NULL);\n+    if (obj == NULL) {\n+      report_error(\"null field found\");\n+      return NULL;\n@@ -520,0 +519,1 @@\n+    k = obj->klass();\n@@ -724,1 +724,1 @@\n-  \/\/ compile <klass> <name> <signature> <entry_bci> <comp_level> inline <count> (<depth> <bci> <klass> <name> <signature>)*\n+  \/\/ compile <klass> <name> <signature> <entry_bci> <comp_level> inline <count> (<depth> <bci> <inline_late> <klass> <name> <signature>)*\n@@ -766,0 +766,8 @@\n+        int inline_late = 0;\n+        if (_version >= 2) {\n+          inline_late = parse_int(\"inline_late\");\n+          if (had_error()) {\n+              break;\n+          }\n+        }\n+\n@@ -770,1 +778,1 @@\n-        new_ciInlineRecord(inl_method, bci, depth);\n+        new_ciInlineRecord(inl_method, bci, depth, inline_late);\n@@ -1231,1 +1239,1 @@\n-  ciInlineRecord* new_ciInlineRecord(Method* method, int bci, int depth) {\n+  ciInlineRecord* new_ciInlineRecord(Method* method, int bci, int depth, int inline_late) {\n@@ -1238,0 +1246,1 @@\n+    rec->_inline_late = inline_late;\n@@ -1474,1 +1483,1 @@\n-bool ciReplay::should_inline(void* data, ciMethod* method, int bci, int inline_depth) {\n+bool ciReplay::should_inline(void* data, ciMethod* method, int bci, int inline_depth, bool& should_delay) {\n@@ -1476,1 +1485,1 @@\n-    GrowableArray<ciInlineRecord*>*  records = (GrowableArray<ciInlineRecord*>*)data;\n+    GrowableArray<ciInlineRecord*>* records = (GrowableArray<ciInlineRecord*>*)data;\n@@ -1479,1 +1488,6 @@\n-    return CompileReplay::find_ciInlineRecord(records, method->get_Method(), bci, inline_depth) != NULL;\n+    ciInlineRecord* record = CompileReplay::find_ciInlineRecord(records, method->get_Method(), bci, inline_depth);\n+    if (record == NULL) {\n+      return false;\n+    }\n+    should_delay = record->_inline_late;\n+    return true;\n@@ -1483,1 +1497,6 @@\n-    return replay_state->find_ciInlineRecord(method->get_Method(), bci, inline_depth) != NULL;\n+    ciInlineRecord* record = replay_state->find_ciInlineRecord(method->get_Method(), bci, inline_depth);\n+    if (record == NULL) {\n+      return false;\n+    }\n+    should_delay = record->_inline_late;\n+    return true;\n@@ -1490,1 +1509,1 @@\n-    GrowableArray<ciInlineRecord*>*  records = (GrowableArray<ciInlineRecord*>*)data;\n+    GrowableArray<ciInlineRecord*>* records = (GrowableArray<ciInlineRecord*>*)data;\n","filename":"src\/hotspot\/share\/ci\/ciReplay.cpp","additions":72,"deletions":53,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-  static bool should_inline(void* data, ciMethod* method, int bci, int inline_depth);\n+  static bool should_inline(void* data, ciMethod* method, int bci, int inline_depth, bool& should_delay);\n@@ -138,1 +138,2 @@\n-#define REPLAY_VERSION 1 \/\/ current version, bump up for incompatible changes\n+\/\/ 2: incremental inlining support (8254108)\n+#define REPLAY_VERSION 2 \/\/ current version, bump up for incompatible changes\n","filename":"src\/hotspot\/share\/ci\/ciReplay.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,12 +29,17 @@\n- *\n- * SipHash reference C implementation\n- *\n- * Copyright (c) 2016 Jean-Philippe Aumasson <jeanphilippe.aumasson@gmail.com>\n- *\n- * To the extent possible under law, the author(s) have dedicated all copyright\n- * and related and neighboring rights to this software to the public domain\n- * worldwide. This software is distributed without any warranty.\n- *\n- * You should have received a copy of the CC0 Public Domain Dedication along\n- * with this software. If not, see\n- * <http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/>.\n+ *\/\n+\n+\/*\n+   SipHash reference C implementation\n+\n+   Copyright (c) 2012-2021 Jean-Philippe Aumasson\n+   <jeanphilippe.aumasson@gmail.com>\n+   Copyright (c) 2012-2014 Daniel J. Bernstein <djb@cr.yp.to>\n+\n+   To the extent possible under law, the author(s) have dedicated all copyright\n+   and related and neighboring rights to this software to the public domain\n+   worldwide. This software is distributed without any warranty.\n+\n+   You should have received a copy of the CC0 Public Domain Dedication along\n+   with\n+   this software. If not, see\n+   <http:\/\/creativecommons.org\/publicdomain\/zero\/1.0\/>.\n@@ -138,1 +143,3 @@\n-uint32_t AltHashing::halfsiphash_32(uint64_t seed, const uint8_t* data, int len) {\n+uint32_t AltHashing::halfsiphash_32(uint64_t seed, const void* in, int len) {\n+\n+  const unsigned char* data = (const unsigned char*)in;\n","filename":"src\/hotspot\/share\/classfile\/altHashing.cpp","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-  static uint32_t halfsiphash_32(uint64_t seed, const uint8_t* data, int len);\n+  static uint32_t halfsiphash_32(uint64_t seed, const void* in, int len);\n","filename":"src\/hotspot\/share\/classfile\/altHashing.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,0 +94,2 @@\n+\n+#ifdef USE_LIBRARY_BASED_TLS_ONLY\n@@ -95,0 +97,5 @@\n+#else\n+\/\/ \"_lookup_shared_first\" can get highly contended with many cores if multiple threads\n+\/\/ are updating \"lookup success history\" in a global shared variable. If built-in TLS is available, use it.\n+static THREAD_LOCAL bool _lookup_shared_first = false;\n+#endif\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -481,0 +481,4 @@\n+    } else {\n+      \/\/ This inline cache is a megamorphic vtable call. Those ICs never hold\n+      \/\/ any Metadata and should therefore never be cleaned by this function.\n+      return true;\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -927,1 +927,1 @@\n-      CompileTask::print(st, this, msg, \/*short_form:*\/ false, \/* cr *\/ true, \/* timestamp *\/ false);\n+      CompileTask::print(st, this, msg, \/*short_form:*\/ false);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -414,0 +414,1 @@\n+  _last = NULL;\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-                             const char* msg, bool short_form, bool cr, bool timestamp,\n+                             const char* msg, bool short_form, bool cr,\n@@ -242,4 +242,2 @@\n-    if (timestamp) {\n-      \/\/ Print current time\n-      st->print(\"%7d \", (int)tty->time_stamp().milliseconds());\n-    }\n+    \/\/ Print current time\n+    st->print(\"%7d \", (int)tty->time_stamp().milliseconds());\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -107,1 +107,2 @@\n-    _lock = new Monitor(Mutex::safepoint, \"CompileTask_lock\");\n+    \/\/ May hold MethodCompileQueue_lock\n+    _lock = new Monitor(Mutex::safepoint-1, \"CompileTask_lock\");\n@@ -190,1 +191,1 @@\n-                                      const char* msg = NULL, bool short_form = false, bool cr = true, bool timestamp = true,\n+                                      const char* msg = NULL, bool short_form = false, bool cr = true,\n@@ -196,1 +197,1 @@\n-  static void  print(outputStream* st, const nmethod* nm, const char* msg = NULL, bool short_form = false, bool cr = true, bool timestamp = true) {\n+  static void  print(outputStream* st, const nmethod* nm, const char* msg = NULL, bool short_form = false, bool cr = true) {\n@@ -199,1 +200,1 @@\n-                           msg, short_form, cr, timestamp);\n+                           msg, short_form, cr);\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-                            LIR_OprDesc::illegalOpr());\n+                            LIR_Opr::illegalOpr());\n@@ -161,1 +161,1 @@\n-                            LIR_OprDesc::illegalOpr());\n+                            LIR_Opr::illegalOpr());\n","filename":"src\/hotspot\/share\/gc\/g1\/c1\/g1BarrierSetC1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,0 +48,3 @@\n+  \/\/ Initialize card size before initializing alignments\n+  CardTable::initialize_card_size();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-    G1CardSet::G1CardSetPtrIterator* _scan_f;\n+    G1CardSet::CardSetPtrClosure* _scan_f;\n@@ -236,1 +236,1 @@\n-    explicit G1CardSetHashTableScan(G1CardSet::G1CardSetPtrIterator* f) : _scan_f(f) { }\n+    explicit G1CardSetHashTableScan(G1CardSet::CardSetPtrClosure* f) : _scan_f(f) { }\n@@ -287,1 +287,1 @@\n-  void iterate_safepoint(G1CardSet::G1CardSetPtrIterator* cl2) {\n+  void iterate_safepoint(G1CardSet::CardSetPtrClosure* cl2) {\n@@ -292,1 +292,1 @@\n-  void iterate(G1CardSet::G1CardSetPtrIterator* cl2) {\n+  void iterate(G1CardSet::CardSetPtrClosure* cl2) {\n@@ -803,1 +803,1 @@\n-void G1CardSet::iterate_cards_during_transfer(CardSetPtr const card_set, CardVisitor& found) {\n+void G1CardSet::iterate_cards_during_transfer(CardSetPtr const card_set, CardVisitor& cl) {\n@@ -812,1 +812,1 @@\n-      ptr.iterate(found, _config->inline_ptr_bits_per_card());\n+      ptr.iterate(cl, _config->inline_ptr_bits_per_card());\n@@ -816,1 +816,1 @@\n-      card_set_ptr<G1CardSetArray>(card_set)->iterate(found);\n+      card_set_ptr<G1CardSetArray>(card_set)->iterate(cl);\n@@ -824,1 +824,1 @@\n-void G1CardSet::iterate_containers(G1CardSetPtrIterator* found, bool at_safepoint) {\n+void G1CardSet::iterate_containers(CardSetPtrClosure* cl, bool at_safepoint) {\n@@ -826,1 +826,1 @@\n-    _table->iterate_safepoint(found);\n+    _table->iterate_safepoint(cl);\n@@ -828,1 +828,1 @@\n-    _table->iterate(found);\n+    _table->iterate(cl);\n@@ -832,0 +832,1 @@\n+\/\/ Applied to all card (ranges) of the containers.\n@@ -833,2 +834,2 @@\n-class G1ContainerCards {\n-  Closure& _iter;\n+class G1ContainerCardsClosure {\n+  Closure& _cl;\n@@ -838,1 +839,1 @@\n-  G1ContainerCards(Closure& iter, uint region_idx) : _iter(iter), _region_idx(region_idx) { }\n+  G1ContainerCardsClosure(Closure& cl, uint region_idx) : _cl(cl), _region_idx(region_idx) { }\n@@ -843,1 +844,1 @@\n-    _iter.do_card(_region_idx, card_idx);\n+    _cl.do_card(_region_idx, card_idx);\n@@ -848,1 +849,1 @@\n-      _iter.do_card(_region_idx, card_idx);\n+      _cl.do_card(_region_idx, card_idx);\n@@ -854,1 +855,1 @@\n-class G1CardSetIterateCardsIterator : public G1CardSet::G1CardSetPtrIterator {\n+class G1CardSetContainersClosure : public G1CardSet::CardSetPtrClosure {\n@@ -856,1 +857,1 @@\n-  Closure& _iter;\n+  Closure& _cl;\n@@ -860,2 +861,2 @@\n-  G1CardSetIterateCardsIterator(G1CardSet* card_set,\n-                                Closure& iter) :\n+  G1CardSetContainersClosure(G1CardSet* card_set,\n+                             Closure& cl) :\n@@ -863,1 +864,1 @@\n-    _iter(iter) { }\n+    _cl(cl) { }\n@@ -866,1 +867,1 @@\n-    CardOrRanges<Closure> cl(_iter, region_idx);\n+    CardOrRanges<Closure> cl(_cl, region_idx);\n@@ -871,3 +872,3 @@\n-void G1CardSet::iterate_cards(G1CardSetCardIterator& iter) {\n-  G1CardSetIterateCardsIterator<G1CardSetCardIterator, G1ContainerCards> cl(this, iter);\n-  iterate_containers(&cl);\n+void G1CardSet::iterate_cards(CardClosure& cl) {\n+  G1CardSetContainersClosure<CardClosure, G1ContainerCardsClosure> cl2(this, cl);\n+  iterate_containers(&cl2);\n@@ -889,1 +890,1 @@\n-  class GetNumberOfContainers : public G1CardSetPtrIterator {\n+  class GetNumberOfContainers : public CardSetPtrClosure {\n@@ -893,1 +894,1 @@\n-    GetNumberOfContainers() : G1CardSetPtrIterator(), _count(0) { }\n+    GetNumberOfContainers() : CardSetPtrClosure(), _count(0) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":27,"deletions":26,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-  void iterate_cards_during_transfer(CardSetPtr const card_set, CardVisitor& found);\n+  void iterate_cards_during_transfer(CardSetPtr const card_set, CardVisitor& vl);\n@@ -356,1 +356,1 @@\n-  void iterate_cards_or_ranges_in_container(CardSetPtr const card_set, CardOrRangeVisitor& found);\n+  void iterate_cards_or_ranges_in_container(CardSetPtr const card_set, CardOrRangeVisitor& cl);\n@@ -358,1 +358,1 @@\n-  class G1CardSetPtrIterator {\n+  class CardSetPtrClosure {\n@@ -363,1 +363,1 @@\n-  void iterate_containers(G1CardSetPtrIterator* iter, bool safepoint = false);\n+  void iterate_containers(CardSetPtrClosure* cl, bool safepoint = false);\n@@ -365,1 +365,1 @@\n-  class G1CardSetCardIterator {\n+  class CardClosure {\n@@ -370,1 +370,1 @@\n-  void iterate_cards(G1CardSetCardIterator& iter);\n+  void iterate_cards(CardClosure& cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-inline void G1CardSet::iterate_cards_or_ranges_in_container(CardSetPtr const card_set, CardOrRangeVisitor& found) {\n+inline void G1CardSet::iterate_cards_or_ranges_in_container(CardSetPtr const card_set, CardOrRangeVisitor& cl) {\n@@ -48,1 +48,1 @@\n-      if (found.start_iterate(G1GCPhaseTimes::MergeRSMergedInline)) {\n+      if (cl.start_iterate(G1GCPhaseTimes::MergeRSMergedInline)) {\n@@ -50,1 +50,1 @@\n-        ptr.iterate(found, _config->inline_ptr_bits_per_card());\n+        ptr.iterate(cl, _config->inline_ptr_bits_per_card());\n@@ -55,2 +55,2 @@\n-      if (found.start_iterate(G1GCPhaseTimes::MergeRSMergedArrayOfCards)) {\n-        card_set_ptr<G1CardSetArray>(card_set)->iterate(found);\n+      if (cl.start_iterate(G1GCPhaseTimes::MergeRSMergedArrayOfCards)) {\n+        card_set_ptr<G1CardSetArray>(card_set)->iterate(cl);\n@@ -68,2 +68,2 @@\n-        if (found.start_iterate(G1GCPhaseTimes::MergeRSMergedFull)) {\n-          found(0, _config->max_cards_in_region());\n+        if (cl.start_iterate(G1GCPhaseTimes::MergeRSMergedFull)) {\n+          cl(0, _config->max_cards_in_region());\n@@ -73,2 +73,2 @@\n-      if (found.start_iterate(G1GCPhaseTimes::MergeRSMergedHowl)) {\n-        card_set_ptr<G1CardSetHowl>(card_set)->iterate(found, _config);\n+      if (cl.start_iterate(G1GCPhaseTimes::MergeRSMergedHowl)) {\n+        card_set_ptr<G1CardSetHowl>(card_set)->iterate(cl, _config);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.inline.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"logging\/log.hpp\"\n@@ -31,1 +31,0 @@\n-#include \"utilities\/formatBuffer.hpp\"\n@@ -145,160 +144,0 @@\n-G1CardSetMemoryStats::G1CardSetMemoryStats() {\n-  clear();\n-}\n-\n-void G1CardSetMemoryStats::clear() {\n-  for (uint i = 0; i < num_pools(); i++) {\n-    _num_mem_sizes[i] = 0;\n-    _num_buffers[i] = 0;\n-  }\n-}\n-\n-void G1CardSetFreePool::update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processor) {\n-  uint num_free_lists = _freelist_pool.num_free_lists();\n-\n-  for (uint i = 0; i < num_free_lists; i++) {\n-    unlink_processor->at(i)->visit_free_list(_freelist_pool.free_list(i));\n-  }\n-}\n-\n-void G1CardSetFreePool::G1ReturnMemoryProcessor::visit_free_list(G1CardSetBufferList* source) {\n-  assert(_source == nullptr, \"already visited\");\n-  if (_return_to_vm_size > 0) {\n-    _source = source;\n-  } else {\n-    assert(_source == nullptr, \"must be\");\n-  }\n-  if (source->mem_size() > _return_to_vm_size) {\n-    _first = source->get_all(_num_unlinked, _unlinked_bytes);\n-  } else {\n-    assert(_first == nullptr, \"must be\");\n-  }\n-  \/\/ Above we were racing with other threads getting the contents of the free list,\n-  \/\/ so while we might have been asked to return something to the OS initially,\n-  \/\/ the free list might be empty anyway. In this case just reset internal values\n-  \/\/ used for checking whether there is work available.\n-  if (_first == nullptr) {\n-    _source = nullptr;\n-    _return_to_vm_size = 0;\n-  }\n-}\n-\n-bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_vm(jlong deadline) {\n-  assert(!finished_return_to_vm(), \"already returned everything to the VM\");\n-  assert(_first != nullptr, \"must have element to return\");\n-\n-  size_t keep_size = 0;\n-  size_t keep_num = 0;\n-\n-  G1CardSetBuffer* cur = _first;\n-  G1CardSetBuffer* last = nullptr;\n-\n-  while (cur != nullptr && _return_to_vm_size > 0) {\n-    size_t cur_size = cur->mem_size();\n-    _return_to_vm_size -= MIN2(_return_to_vm_size, cur_size);\n-\n-    keep_size += cur_size;\n-    keep_num++;\n-\n-    last = cur;\n-    cur = cur->next();\n-    \/\/ To ensure progress, perform the deadline check here.\n-    if (os::elapsed_counter() > deadline) {\n-      break;\n-    }\n-  }\n-\n-  assert(_first != nullptr, \"must be\");\n-  assert(last != nullptr, \"must be\");\n-\n-  last->set_next(nullptr);\n-\n-  \/\/ Wait for any in-progress pops to avoid ABA for them.\n-  GlobalCounter::write_synchronize();\n-  _source->bulk_add(*_first, *last, keep_num, keep_size);\n-  _first = cur;\n-\n-  log_trace(gc, task)(\"Card Set Free Memory: Returned to VM %zu buffers size %zu\", keep_num, keep_size);\n-\n-  \/\/ _return_to_vm_size may be larger than what is available in the list at the\n-  \/\/ time we actually get the list. I.e. the list and _return_to_vm_size may be\n-  \/\/ inconsistent.\n-  \/\/ So also check if we actually already at the end of the list for the exit\n-  \/\/ condition.\n-  if (_return_to_vm_size == 0 || _first == nullptr) {\n-    _source = nullptr;\n-    _return_to_vm_size = 0;\n-  }\n-  return _source != nullptr;\n-}\n-\n-bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_os(jlong deadline) {\n-  assert(finished_return_to_vm(), \"not finished returning to VM\");\n-  assert(!finished_return_to_os(), \"already returned everything to the OS\");\n-\n-  \/\/ Now delete the rest.\n-  size_t num_delete = 0;\n-  size_t mem_size_deleted = 0;\n-\n-  while (_first != nullptr) {\n-    G1CardSetBuffer* next = _first->next();\n-    num_delete++;\n-    mem_size_deleted += _first->mem_size();\n-    delete _first;\n-    _first = next;\n-\n-    \/\/ To ensure progress, perform the deadline check here.\n-    if (os::elapsed_counter() > deadline) {\n-      break;\n-    }\n-  }\n-\n-  log_trace(gc, task)(\"Card Set Free Memory: Return to OS %zu buffers size %zu\", num_delete, mem_size_deleted);\n-\n-  return _first != nullptr;\n-}\n-\n-G1CardSetFreePool G1CardSetFreePool::_freelist_pool(G1CardSetConfiguration::num_mem_object_types());\n-\n-G1CardSetFreePool::G1CardSetFreePool(uint num_free_lists) :\n-  _num_free_lists(num_free_lists) {\n-\n-  _free_lists = NEW_C_HEAP_ARRAY(G1CardSetBufferList, _num_free_lists, mtGC);\n-  for (uint i = 0; i < _num_free_lists; i++) {\n-    new (&_free_lists[i]) G1CardSetBufferList();\n-  }\n-}\n-\n-G1CardSetFreePool::~G1CardSetFreePool() {\n-  for (uint i = 0; i < _num_free_lists; i++) {\n-    _free_lists[i].~G1CardSetBufferList();\n-  }\n-  FREE_C_HEAP_ARRAY(mtGC, _free_lists);\n-}\n-\n-G1CardSetMemoryStats G1CardSetFreePool::memory_sizes() const {\n-  G1CardSetMemoryStats free_list_stats;\n-  assert(free_list_stats.num_pools() == num_free_lists(), \"must be\");\n-  for (uint i = 0; i < num_free_lists(); i++) {\n-    free_list_stats._num_mem_sizes[i] = _free_lists[i].mem_size();\n-    free_list_stats._num_buffers[i] = _free_lists[i].num_buffers();\n-  }\n-  return free_list_stats;\n-}\n-\n-size_t G1CardSetFreePool::mem_size() const {\n-  size_t result = 0;\n-  for (uint i = 0; i < _num_free_lists; i++) {\n-    result += _free_lists[i].mem_size();\n-  }\n-  return result;\n-}\n-\n-void G1CardSetFreePool::print_on(outputStream* out) {\n-  out->print_cr(\"  Free Pool: size %zu\", free_list_pool()->mem_size());\n-  for (uint i = 0; i < _num_free_lists; i++) {\n-    FormatBuffer<> fmt(\"    %s\", G1CardSetConfiguration::mem_object_type_name_str(i));\n-    _free_lists[i].print_on(out, fmt);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.cpp","additions":1,"deletions":162,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"gc\/g1\/g1SegmentedArrayFreePool.hpp\"\n@@ -139,93 +139,0 @@\n-\/\/ Statistics for a fixed set of buffer lists. Contains the number of buffers and memory\n-\/\/ used for each. Note that statistics are typically not taken atomically so there\n-\/\/ can be inconsistencies. The user must be prepared for them.\n-class G1CardSetMemoryStats {\n-public:\n-\n-  size_t _num_mem_sizes[G1CardSetConfiguration::num_mem_object_types()];\n-  size_t _num_buffers[G1CardSetConfiguration::num_mem_object_types()];\n-\n-  \/\/ Returns all-zero statistics.\n-  G1CardSetMemoryStats();\n-\n-  void add(G1CardSetMemoryStats const other) {\n-    STATIC_ASSERT(ARRAY_SIZE(_num_buffers) == ARRAY_SIZE(_num_mem_sizes));\n-    for (uint i = 0; i < ARRAY_SIZE(_num_mem_sizes); i++) {\n-      _num_mem_sizes[i] += other._num_mem_sizes[i];\n-      _num_buffers[i] += other._num_buffers[i];\n-    }\n-  }\n-\n-  void clear();\n-\n-  uint num_pools() const { return G1CardSetConfiguration::num_mem_object_types(); }\n-};\n-\n-\/\/ A set of free lists holding memory buffers for use by G1CardSetAllocators.\n-class G1CardSetFreePool {\n-  \/\/ The global free pool.\n-  static G1CardSetFreePool _freelist_pool;\n-\n-  const uint _num_free_lists;\n-  G1CardSetBufferList* _free_lists;\n-\n-public:\n-  static G1CardSetFreePool* free_list_pool() { return &_freelist_pool; }\n-  static G1CardSetMemoryStats free_list_sizes() { return _freelist_pool.memory_sizes(); }\n-\n-  class G1ReturnMemoryProcessor;\n-  typedef GrowableArrayCHeap<G1ReturnMemoryProcessor*, mtGC> G1ReturnMemoryProcessorSet;\n-\n-  static void update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processors);\n-\n-  explicit G1CardSetFreePool(uint num_free_lists);\n-  ~G1CardSetFreePool();\n-\n-  G1CardSetBufferList* free_list(uint i) {\n-    assert(i < _num_free_lists, \"must be\");\n-    return &_free_lists[i];\n-  }\n-\n-  uint num_free_lists() const { return _num_free_lists; }\n-\n-  G1CardSetMemoryStats memory_sizes() const;\n-  size_t mem_size() const;\n-\n-  void print_on(outputStream* out);\n-};\n-\n-\/\/ Data structure containing current in-progress state for returning memory to the\n-\/\/ operating system for a single G1CardSetBufferList.\n-class G1CardSetFreePool::G1ReturnMemoryProcessor : public CHeapObj<mtGC> {\n-  G1CardSetBufferList* _source;\n-  size_t _return_to_vm_size;\n-\n-  G1CardSetBuffer* _first;\n-  size_t _unlinked_bytes;\n-  size_t _num_unlinked;\n-\n-public:\n-  explicit G1ReturnMemoryProcessor(size_t return_to_vm) :\n-    _source(nullptr), _return_to_vm_size(return_to_vm), _first(nullptr), _unlinked_bytes(0), _num_unlinked(0) {\n-  }\n-\n-  \/\/ Updates the instance members about the given card set buffer list for the purpose\n-  \/\/ of giving back memory. Only necessary members are updated, e.g. if there is\n-  \/\/ nothing to return to the VM, do not set the source list.\n-  void visit_free_list(G1CardSetBufferList* source);\n-\n-  bool finished_return_to_vm() const { return _return_to_vm_size == 0; }\n-  bool finished_return_to_os() const { return _first == nullptr; }\n-\n-  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n-  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n-  \/\/ has been processed after returning.\n-  \/\/ return_to_vm() re-adds buffers to the respective free list.\n-  bool return_to_vm(jlong deadline);\n-  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n-  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n-  \/\/ has been processed after returning.\n-  \/\/ return_to_os() gives back buffers to the OS.\n-  bool return_to_os(jlong deadline);\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.hpp","additions":1,"deletions":94,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -1663,1 +1663,1 @@\n-  guarantee(heap_rs.base() >= (char*)G1CardTable::card_size, \"Java heap must not start within the first card.\");\n+  guarantee((uintptr_t)(heap_rs.base()) >= G1CardTable::card_size, \"Java heap must not start within the first card.\");\n@@ -1831,1 +1831,0 @@\n-                           (ParallelGCThreads > 1) || (ConcGCThreads > 1), \/\/ mt discovery\n@@ -1840,1 +1839,0 @@\n-                           (ParallelGCThreads > 1),              \/\/ mt discovery\n@@ -2265,1 +2263,1 @@\n-class G1ParallelObjectIterator : public ParallelObjectIterator {\n+class G1ParallelObjectIterator : public ParallelObjectIteratorImpl {\n@@ -2280,1 +2278,1 @@\n-ParallelObjectIterator* G1CollectedHeap::parallel_object_iterator(uint thread_num) {\n+ParallelObjectIteratorImpl* G1CollectedHeap::parallel_object_iterator(uint thread_num) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -780,2 +780,0 @@\n-  void wait_for_root_region_scanning();\n-\n@@ -939,3 +937,0 @@\n-  \/\/ Try to minimize the remembered set.\n-  void scrub_rem_set();\n-\n@@ -1085,1 +1080,1 @@\n-  ParallelObjectIterator* parallel_object_iterator(uint thread_num) override;\n+  ParallelObjectIteratorImpl* parallel_object_iterator(uint thread_num) override;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -44,0 +44,6 @@\n+inline bool G1STWIsAliveClosure::do_object_b(oop p) {\n+  \/\/ An object is reachable if it is outside the collection set,\n+  \/\/ or is inside and copied.\n+  return !_g1h->is_in_cset(p) || p->is_forwarded();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1621,4 +1621,0 @@\n-    \/\/ Set the concurrency level. The phase was already set prior to\n-    \/\/ executing the remark task.\n-    set_concurrency(active_workers);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n-#ifndef SHARE_GC_G1_G1EVACUATIONFAILUREOBJSINHR_HPP\n-#define SHARE_GC_G1_G1EVACUATIONFAILUREOBJSINHR_HPP\n+#ifndef SHARE_GC_G1_G1EVACFAILUREOBJECTSSET_HPP\n+#define SHARE_GC_G1_G1EVACFAILUREOBJECTSSET_HPP\n@@ -82,1 +82,1 @@\n-#endif \/\/SHARE_GC_G1_G1EVACUATIONFAILUREOBJSINHR_HPP\n+#endif \/\/SHARE_GC_G1_G1EVACFAILUREOBJECTSSET_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureObjectsSet.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,2 +63,1 @@\n-  HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());\n-  if (destination == NULL) {\n+  if (!obj->is_forwarded()) {\n@@ -69,0 +68,2 @@\n+  HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+    assert(object->is_forwarded(), \"must be forwarded\");\n@@ -107,14 +108,1 @@\n-    if (object->forwardee() != NULL) {\n-      \/\/ Object should not move but mark-word is used so it looks like the\n-      \/\/ object is forwarded. Need to clear the mark and it's no problem\n-      \/\/ since it will be restored by preserved marks.\n-      object->init_mark();\n-    } else {\n-      \/\/ Make sure object has the correct mark-word set or that it will be\n-      \/\/ fixed when restoring the preserved marks.\n-      assert(object->mark() == markWord::prototype() || \/\/ Correct mark\n-             object->mark_must_be_preserved(), \/\/ Will be restored by PreservedMarksSet\n-             \"should have correct prototype obj: \" PTR_FORMAT \" mark: \" PTR_FORMAT \" prototype: \" PTR_FORMAT,\n-             p2i(object), object->mark().value(), markWord::prototype().value());\n-    }\n-    assert(object->forwardee() == NULL, \"should be forwarded to NULL\");\n+    assert(!object->is_forwarded(), \"must not be forwarded\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -80,8 +80,5 @@\n-  oop forwardee = obj->forwardee();\n-  if (forwardee == NULL) {\n-    \/\/ Not forwarded, return current reference.\n-    assert(obj->mark() == markWord::prototype() || \/\/ Correct mark\n-           obj->mark_must_be_preserved(), \/\/ Will be restored by PreservedMarksSet\n-           \"Must have correct prototype or be preserved, obj: \" PTR_FORMAT \", mark: \" PTR_FORMAT \", prototype: \" PTR_FORMAT,\n-           p2i(obj), obj->mark().value(), markWord::prototype().value());\n-    return;\n+  if (obj->is_forwarded()) {\n+    oop forwardee = obj->forwardee();\n+    \/\/ Forwarded, just update.\n+    assert(G1CollectedHeap::heap()->is_in_reserved(forwardee), \"should be in object space\");\n+    RawAccess<IS_NOT_NULL>::oop_store(p, forwardee);\n@@ -90,3 +87,0 @@\n-  \/\/ Forwarded, just update.\n-  assert(G1CollectedHeap::heap()->is_in_reserved(forwardee), \"should be in object space\");\n-  RawAccess<IS_NOT_NULL>::oop_store(p, forwardee);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -171,2 +171,1 @@\n-  oop forwarded_to = obj->forwardee();\n-  if (forwarded_to != NULL && !_current->is_in(forwarded_to)) {\n+  if (obj->is_forwarded() && !_current->is_in(obj->forwardee())) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/g1\/g1CardSetMemory.hpp\"\n+#include \"gc\/g1\/g1SegmentedArrayFreePool.hpp\"\n+#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+\n+G1CardSetMemoryStats::G1CardSetMemoryStats() {\n+  clear();\n+}\n+\n+void G1CardSetMemoryStats::clear() {\n+  for (uint i = 0; i < num_pools(); i++) {\n+    _num_mem_sizes[i] = 0;\n+    _num_buffers[i] = 0;\n+  }\n+}\n+\n+void G1CardSetFreePool::update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processor) {\n+  uint num_free_lists = _freelist_pool.num_free_lists();\n+\n+  for (uint i = 0; i < num_free_lists; i++) {\n+    unlink_processor->at(i)->visit_free_list(_freelist_pool.free_list(i));\n+  }\n+}\n+\n+void G1CardSetFreePool::G1ReturnMemoryProcessor::visit_free_list(G1CardSetBufferList* source) {\n+  assert(_source == nullptr, \"already visited\");\n+  if (_return_to_vm_size > 0) {\n+    _source = source;\n+  } else {\n+    assert(_source == nullptr, \"must be\");\n+  }\n+  if (source->mem_size() > _return_to_vm_size) {\n+    _first = source->get_all(_num_unlinked, _unlinked_bytes);\n+  } else {\n+    assert(_first == nullptr, \"must be\");\n+  }\n+  \/\/ Above we were racing with other threads getting the contents of the free list,\n+  \/\/ so while we might have been asked to return something to the OS initially,\n+  \/\/ the free list might be empty anyway. In this case just reset internal values\n+  \/\/ used for checking whether there is work available.\n+  if (_first == nullptr) {\n+    _source = nullptr;\n+    _return_to_vm_size = 0;\n+  }\n+}\n+\n+bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_vm(jlong deadline) {\n+  assert(!finished_return_to_vm(), \"already returned everything to the VM\");\n+  assert(_first != nullptr, \"must have element to return\");\n+\n+  size_t keep_size = 0;\n+  size_t keep_num = 0;\n+\n+  G1CardSetBuffer* cur = _first;\n+  G1CardSetBuffer* last = nullptr;\n+\n+  while (cur != nullptr && _return_to_vm_size > 0) {\n+    size_t cur_size = cur->mem_size();\n+    _return_to_vm_size -= MIN2(_return_to_vm_size, cur_size);\n+\n+    keep_size += cur_size;\n+    keep_num++;\n+\n+    last = cur;\n+    cur = cur->next();\n+    \/\/ To ensure progress, perform the deadline check here.\n+    if (os::elapsed_counter() > deadline) {\n+      break;\n+    }\n+  }\n+\n+  assert(_first != nullptr, \"must be\");\n+  assert(last != nullptr, \"must be\");\n+\n+  last->set_next(nullptr);\n+\n+  \/\/ Wait for any in-progress pops to avoid ABA for them.\n+  GlobalCounter::write_synchronize();\n+  _source->bulk_add(*_first, *last, keep_num, keep_size);\n+  _first = cur;\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Returned to VM %zu buffers size %zu\", keep_num, keep_size);\n+\n+  \/\/ _return_to_vm_size may be larger than what is available in the list at the\n+  \/\/ time we actually get the list. I.e. the list and _return_to_vm_size may be\n+  \/\/ inconsistent.\n+  \/\/ So also check if we actually already at the end of the list for the exit\n+  \/\/ condition.\n+  if (_return_to_vm_size == 0 || _first == nullptr) {\n+    _source = nullptr;\n+    _return_to_vm_size = 0;\n+  }\n+  return _source != nullptr;\n+}\n+\n+bool G1CardSetFreePool::G1ReturnMemoryProcessor::return_to_os(jlong deadline) {\n+  assert(finished_return_to_vm(), \"not finished returning to VM\");\n+  assert(!finished_return_to_os(), \"already returned everything to the OS\");\n+\n+  \/\/ Now delete the rest.\n+  size_t num_delete = 0;\n+  size_t mem_size_deleted = 0;\n+\n+  while (_first != nullptr) {\n+    G1CardSetBuffer* next = _first->next();\n+    num_delete++;\n+    mem_size_deleted += _first->mem_size();\n+    delete _first;\n+    _first = next;\n+\n+    \/\/ To ensure progress, perform the deadline check here.\n+    if (os::elapsed_counter() > deadline) {\n+      break;\n+    }\n+  }\n+\n+  log_trace(gc, task)(\"Card Set Free Memory: Return to OS %zu buffers size %zu\", num_delete, mem_size_deleted);\n+\n+  return _first != nullptr;\n+}\n+\n+G1CardSetFreePool G1CardSetFreePool::_freelist_pool(G1CardSetConfiguration::num_mem_object_types());\n+\n+G1CardSetFreePool::G1CardSetFreePool(uint num_free_lists) :\n+  _num_free_lists(num_free_lists) {\n+\n+  _free_lists = NEW_C_HEAP_ARRAY(G1CardSetBufferList, _num_free_lists, mtGC);\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    new (&_free_lists[i]) G1CardSetBufferList();\n+  }\n+}\n+\n+G1CardSetFreePool::~G1CardSetFreePool() {\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    _free_lists[i].~G1CardSetBufferList();\n+  }\n+  FREE_C_HEAP_ARRAY(mtGC, _free_lists);\n+}\n+\n+G1CardSetBufferList* G1CardSetFreePool::free_list(uint i) {\n+  assert(i < _num_free_lists, \"must be\");\n+  return &_free_lists[i];\n+}\n+\n+G1CardSetMemoryStats G1CardSetFreePool::memory_sizes() const {\n+  G1CardSetMemoryStats free_list_stats;\n+  assert(free_list_stats.num_pools() == num_free_lists(), \"must be\");\n+  for (uint i = 0; i < num_free_lists(); i++) {\n+    free_list_stats._num_mem_sizes[i] = _free_lists[i].mem_size();\n+    free_list_stats._num_buffers[i] = _free_lists[i].num_buffers();\n+  }\n+  return free_list_stats;\n+}\n+\n+size_t G1CardSetFreePool::mem_size() const {\n+  size_t result = 0;\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    result += _free_lists[i].mem_size();\n+  }\n+  return result;\n+}\n+\n+void G1CardSetFreePool::print_on(outputStream* out) {\n+  out->print_cr(\"  Free Pool: size %zu\", free_list_pool()->mem_size());\n+  for (uint i = 0; i < _num_free_lists; i++) {\n+    FormatBuffer<> fmt(\"    %s\", G1CardSetConfiguration::mem_object_type_name_str(i));\n+    _free_lists[i].print_on(out, fmt);\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreePool.cpp","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef SHARE_GC_G1_G1SEGMENTEDARRAYFREEPOOL_HPP\n+#define SHARE_GC_G1_G1SEGMENTEDARRAYFREEPOOL_HPP\n+\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1SegmentedArray.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+\/\/ Statistics for a fixed set of buffer lists. Contains the number of buffers and memory\n+\/\/ used for each. Note that statistics are typically not taken atomically so there\n+\/\/ can be inconsistencies. The user must be prepared for them.\n+class G1CardSetMemoryStats {\n+public:\n+\n+  size_t _num_mem_sizes[G1CardSetConfiguration::num_mem_object_types()];\n+  size_t _num_buffers[G1CardSetConfiguration::num_mem_object_types()];\n+\n+  \/\/ Returns all-zero statistics.\n+  G1CardSetMemoryStats();\n+\n+  void add(G1CardSetMemoryStats const other) {\n+    STATIC_ASSERT(ARRAY_SIZE(_num_buffers) == ARRAY_SIZE(_num_mem_sizes));\n+    for (uint i = 0; i < ARRAY_SIZE(_num_mem_sizes); i++) {\n+      _num_mem_sizes[i] += other._num_mem_sizes[i];\n+      _num_buffers[i] += other._num_buffers[i];\n+    }\n+  }\n+\n+  void clear();\n+\n+  uint num_pools() const { return G1CardSetConfiguration::num_mem_object_types(); }\n+};\n+\n+typedef G1SegmentedArrayBuffer<mtGCCardSet> G1CardSetBuffer;\n+typedef G1SegmentedArrayBufferList<mtGCCardSet> G1CardSetBufferList;\n+\n+\/\/ A set of free lists holding memory buffers for use by G1CardSetAllocators.\n+class G1CardSetFreePool {\n+  \/\/ The global free pool.\n+  static G1CardSetFreePool _freelist_pool;\n+\n+  const uint _num_free_lists;\n+  G1CardSetBufferList* _free_lists;\n+\n+public:\n+  static G1CardSetFreePool* free_list_pool() { return &_freelist_pool; }\n+  static G1CardSetMemoryStats free_list_sizes() { return _freelist_pool.memory_sizes(); }\n+\n+  class G1ReturnMemoryProcessor;\n+  typedef GrowableArrayCHeap<G1ReturnMemoryProcessor*, mtGC> G1ReturnMemoryProcessorSet;\n+\n+  static void update_unlink_processors(G1ReturnMemoryProcessorSet* unlink_processors);\n+\n+  explicit G1CardSetFreePool(uint num_free_lists);\n+  ~G1CardSetFreePool();\n+\n+  G1CardSetBufferList* free_list(uint i);\n+\n+  uint num_free_lists() const { return _num_free_lists; }\n+\n+  G1CardSetMemoryStats memory_sizes() const;\n+  size_t mem_size() const;\n+\n+  void print_on(outputStream* out);\n+};\n+\n+\/\/ Data structure containing current in-progress state for returning memory to the\n+\/\/ operating system for a single G1CardSetBufferList.\n+class G1CardSetFreePool::G1ReturnMemoryProcessor : public CHeapObj<mtGC> {\n+  G1CardSetBufferList* _source;\n+  size_t _return_to_vm_size;\n+\n+  G1CardSetBuffer* _first;\n+  size_t _unlinked_bytes;\n+  size_t _num_unlinked;\n+\n+public:\n+  explicit G1ReturnMemoryProcessor(size_t return_to_vm) :\n+    _source(nullptr), _return_to_vm_size(return_to_vm), _first(nullptr), _unlinked_bytes(0), _num_unlinked(0) {\n+  }\n+\n+  \/\/ Updates the instance members about the given card set buffer list for the purpose\n+  \/\/ of giving back memory. Only necessary members are updated, e.g. if there is\n+  \/\/ nothing to return to the VM, do not set the source list.\n+  void visit_free_list(G1CardSetBufferList* source);\n+\n+  bool finished_return_to_vm() const { return _return_to_vm_size == 0; }\n+  bool finished_return_to_os() const { return _first == nullptr; }\n+\n+  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n+  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n+  \/\/ has been processed after returning.\n+  \/\/ return_to_vm() re-adds buffers to the respective free list.\n+  bool return_to_vm(jlong deadline);\n+  \/\/ Returns memory to the VM until the given deadline expires. Returns true if\n+  \/\/ there is no more work. Guarantees forward progress, i.e. at least one buffer\n+  \/\/ has been processed after returning.\n+  \/\/ return_to_os() gives back buffers to the OS.\n+  bool return_to_os(jlong deadline);\n+};\n+\n+#endif \/\/SHARE_GC_G1_G1SEGMENTEDARRAYFREEPOOL_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SegmentedArrayFreePool.hpp","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n@@ -859,1 +859,1 @@\n-      assert( obj->is_forwarded(), \"invariant\" );\n+      assert(obj->is_forwarded(), \"invariant\" );\n@@ -990,6 +990,0 @@\n-bool G1STWIsAliveClosure::do_object_b(oop p) {\n-  \/\/ An object is reachable if it is outside the collection set,\n-  \/\/ or is inside and copied.\n-  return !_g1h->is_in_cset(p) || p->is_forwarded();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  Closure& _iter;\n+  Closure& _cl;\n@@ -65,1 +65,1 @@\n-  G1ContainerCardsOrRanges(Closure& iter, uint region_idx, uint offset) : _iter(iter), _region_idx(region_idx), _offset(offset) { }\n+  G1ContainerCardsOrRanges(Closure& cl, uint region_idx, uint offset) : _cl(cl), _region_idx(region_idx), _offset(offset) { }\n@@ -68,1 +68,1 @@\n-    return _iter.start_iterate(tag, _region_idx);\n+    return _cl.start_iterate(tag, _region_idx);\n@@ -72,1 +72,1 @@\n-    _iter.do_card(card_idx + _offset);\n+    _cl.do_card(card_idx + _offset);\n@@ -76,1 +76,1 @@\n-    _iter.do_card_range(card_idx + _offset, length);\n+    _cl.do_card_range(card_idx + _offset, length);\n@@ -81,1 +81,1 @@\n-class G1HeapRegionRemSetMergeCardIterator : public G1CardSet::G1CardSetPtrIterator {\n+class G1HeapRegionRemSetMergeCardClosure : public G1CardSet::CardSetPtrClosure {\n@@ -83,1 +83,1 @@\n-  Closure& _iter;\n+  Closure& _cl;\n@@ -90,2 +90,2 @@\n-  G1HeapRegionRemSetMergeCardIterator(G1CardSet* card_set,\n-                                      Closure& iter,\n+  G1HeapRegionRemSetMergeCardClosure(G1CardSet* card_set,\n+                                      Closure& cl,\n@@ -95,1 +95,1 @@\n-    _iter(iter),\n+    _cl(cl),\n@@ -102,1 +102,1 @@\n-    CardOrRanges<Closure> cl(_iter,\n+    CardOrRanges<Closure> cl(_cl,\n@@ -111,4 +111,4 @@\n-  G1HeapRegionRemSetMergeCardIterator<CardOrRangeVisitor, G1ContainerCardsOrRanges> cl2(&_card_set,\n-                                                                                        cl,\n-                                                                                        _card_set.config()->log2_card_region_per_heap_region(),\n-                                                                                        _card_set.config()->log2_cards_per_card_region());\n+  G1HeapRegionRemSetMergeCardClosure<CardOrRangeVisitor, G1ContainerCardsOrRanges> cl2(&_card_set,\n+                                                                                       cl,\n+                                                                                       _card_set.config()->log2_card_region_per_heap_region(),\n+                                                                                       _card_set.config()->log2_cards_per_card_region());\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.inline.hpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -34,0 +34,10 @@\n+uint ObjectStartArray::block_shift = 0;\n+uint ObjectStartArray::block_size = 0;\n+uint ObjectStartArray::block_size_in_words = 0;\n+\n+void ObjectStartArray::initialize_block_size(uint card_shift) {\n+  block_shift = card_shift;\n+  block_size = 1 << block_shift;\n+  block_size_in_words = block_size \/ sizeof(HeapWord);\n+}\n+\n@@ -38,1 +48,1 @@\n-  assert((int)block_size <= 512, \"block_size must be less than or equal to 512\");\n+  assert(block_size <= MaxBlockSize, \"block_size must be less than or equal to \" UINT32_FORMAT, MaxBlockSize);\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,5 +55,11 @@\n-  enum BlockSizeConstants {\n-    block_shift                  = 9,\n-    block_size                   = 1 << block_shift,\n-    block_size_in_words          = block_size \/ sizeof(HeapWord)\n-  };\n+  static uint block_shift;\n+  static uint block_size;\n+  static uint block_size_in_words;\n+\n+  \/\/ Maximum size an offset table entry can cover. This maximum is derived from that\n+  \/\/ we need an extra bit for possible offsets in the byte for backskip values, leaving 2^7 possible offsets.\n+  \/\/ Minimum object alignment is 8 bytes (2^3), so we can at most represent 2^10 offsets within a BOT value.\n+  static const uint MaxBlockSize = 1024;\n+\n+  \/\/ Initialize block size based on card size\n+  static void initialize_block_size(uint card_shift);\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.hpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+  \/\/ Initialize card size before initializing alignments\n+  CardTable::initialize_card_size();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelArguments.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-class PSScavengeParallelObjectIterator : public ParallelObjectIterator {\n+class PSScavengeParallelObjectIterator : public ParallelObjectIteratorImpl {\n@@ -618,1 +618,1 @@\n-ParallelObjectIterator* ParallelScavengeHeap::parallel_object_iterator(uint thread_num) {\n+ParallelObjectIteratorImpl* ParallelScavengeHeap::parallel_object_iterator(uint thread_num) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-  virtual ParallelObjectIterator* parallel_object_iterator(uint thread_num);\n+  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint thread_num);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -855,1 +855,0 @@\n-      true,                \/\/ mt discovery\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -802,1 +802,0 @@\n-                           true,                       \/\/ mt discovery\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -881,5 +881,0 @@\n-void DefNewGeneration::ref_processor_init() {\n-  Generation::ref_processor_init();\n-}\n-\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -205,2 +205,0 @@\n-  virtual void ref_processor_init();\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,7 +91,2 @@\n-    oop new_obj = cast_to_oop(obj->mark().decode_pointer());\n-\n-    assert(new_obj != NULL ||                      \/\/ is forwarding ptr?\n-           obj->mark() == markWord::prototype(), \/\/ not gc marked?\n-           \"should be forwarded\");\n-\n-    if (new_obj != NULL) {\n+    if (obj->is_forwarded()) {\n+      oop new_obj = obj->forwardee();\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -36,0 +36,12 @@\n+uint BOTConstants::LogN = 0;\n+uint BOTConstants::LogN_words = 0;\n+uint BOTConstants::N_bytes = 0;\n+uint BOTConstants::N_words = 0;\n+\n+void BOTConstants::initialize_bot_size(uint card_shift) {\n+  LogN =  card_shift;\n+  LogN_words = LogN - LogHeapWordSize;\n+  N_bytes = 1 << LogN;\n+  N_words = 1 << LogN_words;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/blockOffsetTable.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/cardTable.hpp\"\n@@ -52,4 +53,5 @@\n-  static const uint LogN = 9;\n-  static const uint LogN_words = LogN - LogHeapWordSize;\n-  static const uint N_bytes = 1 << LogN;\n-  static const uint N_words = 1 << LogN_words;\n+  static uint LogN;\n+  static uint LogN_words;\n+  static uint N_bytes;\n+  static uint N_words;\n+\n@@ -62,0 +64,3 @@\n+  \/\/ Initialize bot size based on card size\n+  static void initialize_bot_size(uint card_shift);\n+\n@@ -96,0 +101,1 @@\n+    assert(BOTConstants::N_bytes == CardTable::card_size, \"sanity\");\n","filename":"src\/hotspot\/share\/gc\/shared\/blockOffsetTable.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"gc\/shared\/gcLogPrecious.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -35,0 +37,26 @@\n+#if INCLUDE_PARALLELGC\n+#include \"gc\/parallel\/objectStartArray.hpp\"\n+#endif\n+\n+uint CardTable::card_shift = 0;\n+uint CardTable::card_size = 0;\n+uint CardTable::card_size_in_words = 0;\n+\n+void CardTable::initialize_card_size() {\n+  assert(UseG1GC || UseParallelGC || UseSerialGC,\n+         \"Initialize card size should only be called by card based collectors.\");\n+\n+  card_size = GCCardSizeInBytes;\n+  card_shift = log2i_exact(card_size);\n+  card_size_in_words = card_size \/ sizeof(HeapWord);\n+\n+  \/\/ Set blockOffsetTable size based on card table entry size\n+  BOTConstants::initialize_bot_size(card_shift);\n+\n+#if INCLUDE_PARALLELGC\n+  \/\/ Set ObjectStartArray block size based on card table entry size\n+  ObjectStartArray::initialize_block_size(card_shift);\n+#endif\n+\n+  log_info_p(gc, init)(\"CardTable entry size: \" UINT32_FORMAT,  card_size);\n+}\n@@ -59,2 +87,0 @@\n-\n-  assert(card_size <= 512, \"card_size must be less than 512\"); \/\/ why?\n@@ -431,1 +457,2 @@\n-  return card_size * os::vm_page_size();\n+  \/\/ Calculate maximum alignment using GCCardSizeInBytes as card_size hasn't been set yet\n+  return GCCardSizeInBytes * os::vm_page_size();\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.cpp","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -231,6 +231,4 @@\n-  \/\/ Constants\n-  enum SomePublicConstants {\n-    card_shift                  = 9,\n-    card_size                   = 1 << card_shift,\n-    card_size_in_words          = card_size \/ sizeof(HeapWord)\n-  };\n+  \/\/ CardTable entry size\n+  static uint card_shift;\n+  static uint card_size;\n+  static uint card_size_in_words;\n@@ -242,0 +240,3 @@\n+  \/\/ Initialize card size\n+  static void initialize_card_size();\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTable.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -113,0 +113,12 @@\n+ParallelObjectIterator::ParallelObjectIterator(uint thread_num) :\n+  _impl(Universe::heap()->parallel_object_iterator(thread_num))\n+{}\n+\n+ParallelObjectIterator::~ParallelObjectIterator() {\n+  delete _impl;\n+}\n+\n+void ParallelObjectIterator::object_iterate(ObjectClosure* cl, uint worker_id) {\n+  _impl->object_iterate(cl, worker_id);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-class ParallelObjectIterator : public CHeapObj<mtGC> {\n+class ParallelObjectIteratorImpl : public CHeapObj<mtGC> {\n@@ -67,0 +67,1 @@\n+  virtual ~ParallelObjectIteratorImpl() {}\n@@ -68,1 +69,13 @@\n-  virtual ~ParallelObjectIterator() {}\n+};\n+\n+\/\/ User facing parallel object iterator. This is a StackObj, which ensures that\n+\/\/ the _impl is allocated and deleted in the scope of this object. This ensures\n+\/\/ the life cycle of the implementation is as required by ThreadsListHandle,\n+\/\/ which is sometimes used by the root iterators.\n+class ParallelObjectIterator : public StackObj {\n+  ParallelObjectIteratorImpl* _impl;\n+\n+public:\n+  ParallelObjectIterator(uint thread_num);\n+  ~ParallelObjectIterator();\n+  void object_iterate(ObjectClosure* cl, uint worker_id);\n@@ -85,0 +98,1 @@\n+  friend class ParallelObjectIterator;\n@@ -387,1 +401,2 @@\n-  virtual ParallelObjectIterator* parallel_object_iterator(uint thread_num) {\n+ protected:\n+  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint thread_num) {\n@@ -391,0 +406,1 @@\n+ public:\n@@ -464,8 +480,9 @@\n-  \/\/ Provides a thread pool to SafepointSynchronize to use\n-  \/\/ for parallel safepoint cleanup.\n-  \/\/ GCs that use a GC worker thread pool may want to share\n-  \/\/ it for use during safepoint cleanup. This is only possible\n-  \/\/ if the GC can pause and resume concurrent work (e.g. G1\n-  \/\/ concurrent marking) for an intermittent non-GC safepoint.\n-  \/\/ If this method returns NULL, SafepointSynchronize will\n-  \/\/ perform cleanup tasks serially in the VMThread.\n+  \/\/ Workers used in non-GC safepoints for parallel safepoint cleanup. If this\n+  \/\/ method returns NULL, cleanup tasks are done serially in the VMThread. See\n+  \/\/ `SafepointSynchronize::do_cleanup_tasks` for details.\n+  \/\/ GCs using a GC worker thread pool inside GC safepoints may opt to share\n+  \/\/ that pool with non-GC safepoints, avoiding creating extraneous threads.\n+  \/\/ Such sharing is safe, because GC safepoints and non-GC safepoints never\n+  \/\/ overlap. For example, `G1CollectedHeap::workers()` (for GC safepoints) and\n+  \/\/ `G1CollectedHeap::safepoint_workers()` (for non-GC safepoints) return the\n+  \/\/ same thread-pool.\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -695,3 +695,7 @@\n-          range(0, max_juint)\n-\n-\/\/ end of GC_FLAGS\n+          range(0, max_juint)                                               \\\n+                                                                            \\\n+  product(uint, GCCardSizeInBytes, 512,                                     \\\n+          \"Card table entry size (in bytes) for card based collectors\")     \\\n+          range(128, 1024)                                                  \\\n+          constraint(GCCardSizeInBytesConstraintFunc,AtParse)\n+  \/\/ end of GC_FLAGS\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shared\/cardTable.hpp\"\n@@ -64,0 +65,2 @@\n+  \/\/ Initialize card size before initializing alignments\n+  CardTable::initialize_card_size();\n","filename":"src\/hotspot\/share\/gc\/shared\/genArguments.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  virtual void ref_processor_init();\n+  void ref_processor_init();\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -427,0 +427,12 @@\n+JVMFlag::Error GCCardSizeInBytesConstraintFunc(uint value, bool verbose) {\n+  if (!is_power_of_2(value)) {\n+    JVMFlag::printError(verbose,\n+                        \"GCCardSizeInBytes ( %u ) must be \"\n+                        \"a power of 2\\n\",\n+                        value);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  } else {\n+    return JVMFlag::SUCCESS;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -69,1 +69,2 @@\n- f(size_t, MaxMetaspaceSizeConstraintFunc)\n+ f(size_t, MaxMetaspaceSizeConstraintFunc)                     \\\n+ f(uint, GCCardSizeInBytesConstraintFunc)\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -90,1 +90,0 @@\n-                                       bool      mt_discovery,\n@@ -102,1 +101,1 @@\n-  _discovery_is_mt         = mt_discovery;\n+  _discovery_is_mt         = (mt_discovery_degree > 1);\n@@ -202,0 +201,2 @@\n+  phase_times.set_processing_is_mt(processing_is_mt());\n+\n@@ -734,2 +735,0 @@\n-  phase_times.set_processing_is_mt(processing_is_mt());\n-\n@@ -768,1 +767,0 @@\n-  phase_times.set_processing_is_mt(processing_is_mt());\n@@ -795,1 +793,0 @@\n-  phase_times.set_processing_is_mt(processing_is_mt());\n@@ -1058,9 +1055,0 @@\n-bool ReferenceProcessor::has_discovered_references() {\n-  for (uint i = 0; i < _max_num_queues * number_of_subclasses_of_ref(); i++) {\n-    if (!_discovered_refs[i].is_empty()) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":3,"deletions":15,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -377,1 +377,1 @@\n-                     bool mt_discovery  = false, uint mt_discovery_degree  = 1,\n+                     uint mt_discovery_degree  = 1,\n@@ -424,3 +424,0 @@\n-  \/\/ Has discovered references that need handling\n-  bool has_discovered_references();\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -379,1 +379,1 @@\n-    assert(q->forwardee() == NULL, \"should be forwarded to NULL\");\n+    assert(!q->is_forwarded(), \"should not be forwarded\");\n@@ -539,1 +539,1 @@\n-    if (!cast_to_oop(cur_obj)->is_gc_marked()) {\n+    if (!cast_to_oop(cur_obj)->is_forwarded()) {\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,10 +39,0 @@\n-template <>\n-void WorkerDataArray<double>::WDAPrinter::summary(outputStream* out, double time) {\n-  out->print_cr(\" %.1lfms\", time * MILLIUNITS);\n-}\n-\n-template <>\n-void WorkerDataArray<size_t>::WDAPrinter::summary(outputStream* out, size_t value) {\n-  out->print_cr(\" \" SIZE_FORMAT, value);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/workerDataArray.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  WorkerDataArray(const char* short_name, const char* title, uint length, bool is_serial = false);\n+  WorkerDataArray(const char* short_name, const char* title, uint length);\n@@ -94,1 +94,0 @@\n-    static void summary(outputStream* out, double time);\n@@ -96,1 +95,0 @@\n-    static void summary(outputStream* out, size_t value);\n","filename":"src\/hotspot\/share\/gc\/shared\/workerDataArray.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-WorkerDataArray<T>::WorkerDataArray(const char* short_name, const char* title, uint length, bool is_serial) :\n+WorkerDataArray<T>::WorkerDataArray(const char* short_name, const char* title, uint length) :\n@@ -38,2 +38,1 @@\n- _title(title),\n- _is_serial(is_serial) {\n+ _title(title) {\n@@ -41,1 +40,0 @@\n-  assert(!is_serial || length == 1, \"Serial phase must only have a single entry.\");\n@@ -161,5 +159,1 @@\n-  if (_is_serial) {\n-    out->print(\"%s:\", title());\n-  } else {\n-    out->print(\"%-30s\", title());\n-  }\n+  out->print(\"%-30s\", title());\n@@ -172,15 +166,11 @@\n-    if (_is_serial) {\n-      WDAPrinter::summary(out, get(0));\n-    } else {\n-      T min = get(start);\n-      T max = min;\n-      T sum = 0;\n-      uint contributing_threads = 0;\n-      for (uint i = start; i < _length; ++i) {\n-        T value = get(i);\n-        if (value != uninitialized()) {\n-          max = MAX2(max, value);\n-          min = MIN2(min, value);\n-          sum += value;\n-          contributing_threads++;\n-        }\n+    T min = get(start);\n+    T max = min;\n+    T sum = 0;\n+    uint contributing_threads = 0;\n+    for (uint i = start; i < _length; ++i) {\n+      T value = get(i);\n+      if (value != uninitialized()) {\n+        max = MAX2(max, value);\n+        min = MIN2(min, value);\n+        sum += value;\n+        contributing_threads++;\n@@ -188,5 +178,0 @@\n-      T diff = max - min;\n-      assert(contributing_threads != 0, \"Must be since we found a used value for the start index\");\n-      double avg = sum \/ (double) contributing_threads;\n-      WDAPrinter::summary(out, min, avg, max, diff, sum, print_sum);\n-      out->print_cr(\", Workers: %d\", contributing_threads);\n@@ -194,0 +179,5 @@\n+    T diff = max - min;\n+    assert(contributing_threads != 0, \"Must be since we found a used value for the start index\");\n+    double avg = sum \/ (double) contributing_threads;\n+    WDAPrinter::summary(out, min, avg, max, diff, sum, print_sum);\n+    out->print_cr(\", Workers: %d\", contributing_threads);\n","filename":"src\/hotspot\/share\/gc\/shared\/workerDataArray.inline.hpp","additions":19,"deletions":29,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#if !(defined AARCH64 || defined AMD64 || defined IA32)\n+#if !(defined AARCH64 || defined AMD64 || defined IA32 || defined PPC64)\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1369,1 +1369,1 @@\n-class ShenandoahParallelObjectIterator : public ParallelObjectIterator {\n+class ShenandoahParallelObjectIterator : public ParallelObjectIteratorImpl {\n@@ -1468,1 +1468,1 @@\n-ParallelObjectIterator* ShenandoahHeap::parallel_object_iterator(uint workers) {\n+ParallelObjectIteratorImpl* ShenandoahHeap::parallel_object_iterator(uint workers) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -487,1 +487,1 @@\n-  virtual ParallelObjectIterator* parallel_object_iterator(uint workers);\n+  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint workers);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"memory\/metaspaceCriticalAllocation.hpp\"\n@@ -156,2 +157,0 @@\n-  MetaWord* result;\n-\n@@ -162,16 +161,1 @@\n-  result = loader_data->metaspace_non_null()->expand_and_allocate(size, mdtype);\n-  if (result != NULL) {\n-    return result;\n-  }\n-\n-  \/\/ Start synchronous GC\n-  collect(GCCause::_metadata_GC_clear_soft_refs);\n-\n-  \/\/ Retry allocation\n-  result = loader_data->metaspace_non_null()->allocate(size, mdtype);\n-  if (result != NULL) {\n-    return result;\n-  }\n-\n-  \/\/ Expand and retry allocation\n-  result = loader_data->metaspace_non_null()->expand_and_allocate(size, mdtype);\n+  MetaWord* const result = loader_data->metaspace_non_null()->expand_and_allocate(size, mdtype);\n@@ -182,2 +166,2 @@\n-  \/\/ Out of memory\n-  return NULL;\n+  \/\/ As a last resort, try a critical allocation, riding on a synchronous full GC\n+  return MetaspaceCriticalAllocation::allocate(loader_data, size, mdtype);\n@@ -245,1 +229,1 @@\n-ParallelObjectIterator* ZCollectedHeap::parallel_object_iterator(uint nworkers) {\n+ParallelObjectIteratorImpl* ZCollectedHeap::parallel_object_iterator(uint nworkers) {\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":5,"deletions":21,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-  virtual ParallelObjectIterator* parallel_object_iterator(uint nworkers);\n+  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint nworkers);\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-ParallelObjectIterator* ZHeap::parallel_object_iterator(uint nworkers, bool visit_weaks) {\n+ParallelObjectIteratorImpl* ZHeap::parallel_object_iterator(uint nworkers, bool visit_weaks) {\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-  ParallelObjectIterator* parallel_object_iterator(uint nworkers, bool visit_weaks);\n+  ParallelObjectIteratorImpl* parallel_object_iterator(uint nworkers, bool visit_weaks);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-class ZHeapIterator : public ParallelObjectIterator {\n+class ZHeapIterator : public ParallelObjectIteratorImpl {\n","filename":"src\/hotspot\/share\/gc\/z\/zHeapIterator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2808,1 +2808,1 @@\n-      CASE(_fast_faccess_0): {\n+      CASE(_fast_iaccess_0): {\n@@ -2823,1 +2823,1 @@\n-      CASE(_fast_iaccess_0): {\n+      CASE(_fast_faccess_0): {\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -581,12 +581,6 @@\n-      ParallelObjectIterator* poi = Universe::heap()->parallel_object_iterator(workers->active_workers());\n-      if (poi != NULL) {\n-        \/\/ The GC supports parallel object iteration.\n-\n-        ParHeapInspectTask task(poi, cit, filter);\n-        \/\/ Run task with the active workers.\n-        workers->run_task(&task);\n-\n-        delete poi;\n-        if (task.success()) {\n-          return task.missed_count();\n-        }\n+      ParallelObjectIterator poi(workers->active_workers());\n+      ParHeapInspectTask task(&poi, cit, filter);\n+      \/\/ Run task with the active workers.\n+      workers->run_task(&task);\n+      if (task.success()) {\n+        return task.missed_count();\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"memory\/metaspaceCriticalAllocation.hpp\"\n@@ -880,0 +881,3 @@\n+  \/\/ Deal with concurrent unloading failed allocation starvation\n+  MetaspaceCriticalAllocation::block_if_concurrent_purge();\n+\n@@ -995,0 +999,4 @@\n+  \/\/ The MetaspaceCritical_lock is used by a concurrent GC to block out concurrent metaspace\n+  \/\/ allocations, that would starve critical metaspace allocations, that are about to throw\n+  \/\/ OOM if they fail; they need precedence for correctness.\n+  MutexLocker ml(MetaspaceCritical_lock, Mutex::_no_safepoint_check_flag);\n@@ -1005,0 +1013,2 @@\n+\n+  MetaspaceCriticalAllocation::satisfy();\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/classLoaderData.hpp\"\n+#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/classLoaderMetaspace.hpp\"\n+#include \"memory\/metaspaceCriticalAllocation.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+\n+class MetadataAllocationRequest {\n+  ClassLoaderData*           _loader_data;\n+  size_t                     _word_size;\n+  Metaspace::MetadataType    _type;\n+  MetadataAllocationRequest* _next;\n+  MetaWord*                  _result;\n+  bool                       _has_result;\n+\n+public:\n+  MetadataAllocationRequest(ClassLoaderData* loader_data,\n+                            size_t word_size,\n+                            Metaspace::MetadataType type)\n+    : _loader_data(loader_data),\n+      _word_size(word_size),\n+      _type(type),\n+      _next(NULL),\n+      _result(NULL),\n+      _has_result(false) {\n+    MetaspaceCriticalAllocation::add(this);\n+  }\n+\n+  ~MetadataAllocationRequest() {\n+    MetaspaceCriticalAllocation::remove(this);\n+  }\n+\n+  ClassLoaderData*           loader_data() const { return _loader_data; }\n+  size_t                     word_size() const   { return _word_size; }\n+  Metaspace::MetadataType    type() const        { return _type; }\n+  MetadataAllocationRequest* next() const        { return _next; }\n+  MetaWord*                  result() const      { return _result; }\n+  bool                       has_result() const  { return _has_result; }\n+\n+  void set_next(MetadataAllocationRequest* next) { _next = next; }\n+  void set_result(MetaWord* result) {\n+    _result = result;\n+    _has_result = true;\n+  }\n+};\n+\n+volatile bool MetaspaceCriticalAllocation::_has_critical_allocation = false;\n+MetadataAllocationRequest* MetaspaceCriticalAllocation::_requests_head = NULL;\n+MetadataAllocationRequest* MetaspaceCriticalAllocation::_requests_tail = NULL;\n+\n+void MetaspaceCriticalAllocation::add(MetadataAllocationRequest* request) {\n+  MutexLocker ml(MetaspaceCritical_lock, Mutex::_no_safepoint_check_flag);\n+  log_info(metaspace)(\"Requesting critical metaspace allocation; almost out of memory\");\n+  Atomic::store(&_has_critical_allocation, true);\n+  if (_requests_head == NULL) {\n+    _requests_head = _requests_tail = request;\n+  } else {\n+    _requests_tail->set_next(request);\n+    _requests_tail = request;\n+  }\n+}\n+\n+void MetaspaceCriticalAllocation::unlink(MetadataAllocationRequest* curr, MetadataAllocationRequest* prev) {\n+  if (_requests_head == curr) {\n+    _requests_head = curr->next();\n+  }\n+  if (_requests_tail == curr) {\n+    _requests_tail = prev;\n+  }\n+  if (prev != NULL) {\n+    prev->set_next(curr->next());\n+  }\n+}\n+\n+void MetaspaceCriticalAllocation::remove(MetadataAllocationRequest* request) {\n+  MutexLocker ml(MetaspaceCritical_lock, Mutex::_no_safepoint_check_flag);\n+  MetadataAllocationRequest* prev = NULL;\n+  for (MetadataAllocationRequest* curr = _requests_head; curr != NULL; curr = curr->next()) {\n+    if (curr == request) {\n+      unlink(curr, prev);\n+      break;\n+    } else {\n+      prev = curr;\n+    }\n+  }\n+}\n+\n+bool MetaspaceCriticalAllocation::try_allocate_critical(MetadataAllocationRequest* request) {\n+  MutexLocker ml(MetaspaceCritical_lock, Mutex::_no_safepoint_check_flag);\n+  if (_requests_head == request) {\n+    \/\/ The first request can't opportunistically ride on a previous GC\n+    return false;\n+  }\n+  \/\/ Try to ride on a previous GC and hope for early satisfaction\n+  wait_for_purge(request);\n+  return request->result() != NULL;\n+}\n+\n+void MetaspaceCriticalAllocation::wait_for_purge(MetadataAllocationRequest* request) {\n+  while (!request->has_result()) {\n+    ThreadBlockInVM tbivm(JavaThread::current());\n+    MetaspaceCritical_lock->wait_without_safepoint_check();\n+  }\n+}\n+\n+void MetaspaceCriticalAllocation::block_if_concurrent_purge() {\n+  if (Atomic::load(&_has_critical_allocation)) {\n+    \/\/ If there is a concurrent Metaspace::purge() operation, we will block here,\n+    \/\/ to make sure critical allocations get precedence and don't get starved.\n+    MutexLocker ml(MetaspaceCritical_lock, Mutex::_no_safepoint_check_flag);\n+  }\n+}\n+\n+void MetaspaceCriticalAllocation::satisfy() {\n+  assert_lock_strong(MetaspaceCritical_lock);\n+  bool all_satisfied = true;\n+  for (MetadataAllocationRequest* curr = _requests_head; curr != NULL; curr = curr->next()) {\n+    if (curr->result() != NULL) {\n+      \/\/ Don't satisfy twice\n+      continue;\n+    }\n+    \/\/ Try to allocate metadata.\n+    MetaWord* result = curr->loader_data()->metaspace_non_null()->allocate(curr->word_size(), curr->type());\n+    if (result == NULL) {\n+      result = curr->loader_data()->metaspace_non_null()->expand_and_allocate(curr->word_size(), curr->type());\n+    }\n+    if (result == NULL) {\n+      all_satisfied = false;\n+    }\n+    curr->set_result(result);\n+  }\n+  if (all_satisfied) {\n+    Atomic::store(&_has_critical_allocation, false);\n+  }\n+  MetaspaceCritical_lock->notify_all();\n+}\n+\n+MetaWord* MetaspaceCriticalAllocation::allocate(ClassLoaderData* loader_data, size_t word_size, Metaspace::MetadataType type) {\n+  MetadataAllocationRequest request(loader_data, word_size, type);\n+\n+  if (try_allocate_critical(&request)) {\n+    \/\/ Try to allocate on a previous concurrent GC if there was one, and return if successful\n+    return request.result();\n+  }\n+\n+  \/\/ Always perform a synchronous full GC before bailing\n+  Universe::heap()->collect(GCCause::_metadata_GC_clear_soft_refs);\n+\n+  \/\/ Return the result, be that success or failure\n+  return request.result();\n+}\n","filename":"src\/hotspot\/share\/memory\/metaspaceCriticalAllocation.cpp","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_MEMORY_METASPACECRITICALALLOCATION_HPP\n+#define SHARE_MEMORY_METASPACECRITICALALLOCATION_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/metaspace.hpp\"\n+\n+class MetadataAllocationRequest;\n+class ClassLoaderData;\n+\n+\/\/ == Critical allocation support ==\n+\/\/\n+\/\/ The critical allocation support has the purpose of preventing starvation of failed\n+\/\/ metadata allocations that need a GC, in particular for concurrent GCs.\n+\/\/ A \"critical\" allocation request is registered, then a concurrent full GC is executed.\n+\/\/ When there is any critical allocation present in the system, allocations compete for\n+\/\/ a global lock, so that allocations can be shut out from the concurrent purge() call,\n+\/\/ which takes the same lock. The reasoning is that we gather all the critical allocations\n+\/\/ that are one more failure away from throwing metaspace OOM, in a queue before the GC,\n+\/\/ then free up metaspace due to class unloading in the purge() operation of that GC,\n+\/\/ and satisfy the registered critical allocations. This allows the critical allocations\n+\/\/ to get precedence over normal metaspace allocations, so that the critical allocations\n+\/\/ that are about to throw, do not get starved by other metaspace allocations that have\n+\/\/ not gone through the same dance.\n+\/\/\n+\/\/ The solution has an intended accuracy of not one allocation, but one per thread. What\n+\/\/ I mean by that, is that the allocations are allowed to throw if they got starved by\n+\/\/ one metaspace allocation per thread, even though a more complicated dance could have\n+\/\/ survived that situation in theory. The motivation is that we are at this point so close\n+\/\/ to being out of memory, and the VM is not having a good time, so the user really ought\n+\/\/ to increase the amount of available metaspace anyway, instead of GC:ing around more\n+\/\/ to satisfy a very small number of additional allocations. But it does solve pathologial\n+\/\/ unbounded starvation scenarios where OOM can get thrown even though most of metaspace\n+\/\/ is full of dead metadata.\n+\/\/\n+\/\/ The contract for this to work for a given GC is that GCCause::_metadata_GC_clear_soft_refs\n+\/\/ yields a full synchronous GC that unloads metaspace. And it is only intended to be used\n+\/\/ by GCs with concurrent class unloading.\n+\n+class MetaspaceCriticalAllocation : public AllStatic {\n+  friend class MetadataAllocationRequest;\n+\n+  static volatile bool _has_critical_allocation;\n+  static MetadataAllocationRequest* _requests_head;\n+  static MetadataAllocationRequest* _requests_tail;\n+\n+  static void unlink(MetadataAllocationRequest* curr, MetadataAllocationRequest* prev);\n+\n+  static void add(MetadataAllocationRequest* request);\n+  static void remove(MetadataAllocationRequest* request);\n+\n+  static bool try_allocate_critical(MetadataAllocationRequest* request);\n+  static void wait_for_purge(MetadataAllocationRequest* request);\n+\n+public:\n+  static void block_if_concurrent_purge();\n+  static void satisfy();\n+  static MetaWord* allocate(ClassLoaderData* loader_data, size_t word_size, Metaspace::MetadataType type);\n+};\n+\n+#endif \/\/ SHARE_MEMORY_METASPACECRITICALALLOCATION_HPP\n","filename":"src\/hotspot\/share\/memory\/metaspaceCriticalAllocation.hpp","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -2064,2 +2064,2 @@\n-\/* jni_id_for_impl for jfieldIds only *\/\n-JNIid* InstanceKlass::jni_id_for_impl(int offset) {\n+\/* jni_id_for for jfieldIds only *\/\n+JNIid* InstanceKlass::jni_id_for(int offset) {\n@@ -2067,1 +2067,0 @@\n-  \/\/ Retry lookup after we got the lock\n@@ -2070,1 +2069,1 @@\n-    \/\/ Slow case, allocate new static field identifier\n+    \/\/ Allocate new static field identifier\n@@ -2077,10 +2076,0 @@\n-\n-\/* jni_id_for for jfieldIds only *\/\n-JNIid* InstanceKlass::jni_id_for(int offset) {\n-  JNIid* probe = jni_ids() == NULL ? NULL : jni_ids()->find(offset);\n-  if (probe == NULL) {\n-    probe = jni_id_for_impl(offset);\n-  }\n-  return probe;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -257,2 +257,1 @@\n-    _misc_is_being_redefined                  = 1 << 14, \/\/ used for locking redefinition\n-    _misc_has_contended_annotations           = 1 << 15  \/\/ has @Contended annotation\n+    _misc_has_contended_annotations           = 1 << 14  \/\/ has @Contended annotation\n@@ -736,0 +735,2 @@\n+  \/\/ The flag is in access_flags so that it can be set and reset using atomic\n+  \/\/ operations, and not be reset by other misc_flag settings.\n@@ -737,1 +738,1 @@\n-    return ((_misc_flags & _misc_is_being_redefined) != 0);\n+    return _access_flags.is_being_redefined();\n@@ -741,1 +742,1 @@\n-      _misc_flags |= _misc_is_being_redefined;\n+      _access_flags.set_is_being_redefined();\n@@ -743,1 +744,1 @@\n-      _misc_flags &= ~_misc_is_being_redefined;\n+      _access_flags.clear_is_being_redefined();\n@@ -1201,2 +1202,0 @@\n-  \/* jni_id_for_impl for jfieldID only *\/\n-  JNIid* jni_id_for_impl                         (int offset);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -292,0 +292,1 @@\n+  assert(is_forwarded(), \"only decode when actually forwarded\");\n@@ -297,1 +298,1 @@\n-  assert(!is_forwarded(), \"Attempt to read age from forwarded mark\");\n+  assert(!mark().is_marked(), \"Attempt to read age from forwarded mark\");\n@@ -306,1 +307,1 @@\n-  assert(!is_forwarded(), \"Attempt to increment age of forwarded mark\");\n+  assert(!mark().is_marked(), \"Attempt to increment age of forwarded mark\");\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  _late_inline(false),\n@@ -116,1 +117,1 @@\n-                               int caller_bci, ciCallProfile& profile) {\n+                               int caller_bci, NOT_PRODUCT_ARG(bool& should_delay) ciCallProfile& profile) {\n@@ -131,3 +132,7 @@\n-  int inline_depth = inline_level()+1;\n-  if (ciReplay::should_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth)) {\n-    set_msg(\"force inline by ciReplay\");\n+  int inline_depth = inline_level() + 1;\n+  if (ciReplay::should_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth, should_delay)) {\n+    if (should_delay) {\n+      set_msg(\"force (incremental) inline by ciReplay\");\n+    } else {\n+      set_msg(\"force inline by ciReplay\");\n+    }\n@@ -197,1 +202,1 @@\n-                                   int caller_bci, ciCallProfile& profile) {\n+                                   int caller_bci, NOT_PRODUCT_ARG(bool& should_delay) ciCallProfile& profile) {\n@@ -235,3 +240,7 @@\n-  int inline_depth = inline_level()+1;\n-  if (ciReplay::should_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth)) {\n-    set_msg(\"force inline by ciReplay\");\n+  int inline_depth = inline_level() + 1;\n+  if (ciReplay::should_inline(C->replay_inline_data(), callee_method, caller_bci, inline_depth, should_delay)) {\n+    if (should_delay) {\n+      set_msg(\"force (incremental) inline by ciReplay\");\n+    } else {\n+      set_msg(\"force inline by ciReplay\");\n+    }\n@@ -372,1 +381,3 @@\n-  if (!should_inline(callee_method, caller_method, caller_bci, profile)) {\n+\n+  \/\/ 'should_delay' can be overridden during replay compilation\n+  if (!should_inline(callee_method, caller_method, caller_bci, NOT_PRODUCT_ARG(should_delay) profile)) {\n@@ -375,1 +386,2 @@\n-  if (should_not_inline(callee_method, caller_method, caller_bci, profile)) {\n+  \/\/ 'should_delay' can be overridden during replay compilation\n+  if (should_not_inline(callee_method, caller_method, caller_bci, NOT_PRODUCT_ARG(should_delay) profile)) {\n@@ -560,2 +572,0 @@\n-  assert(callee_method != NULL, \"caller checks for optimized virtual!\");\n-  assert(!should_delay, \"should be initialized to false\");\n@@ -563,0 +573,1 @@\n+  assert(callee_method != NULL, \"caller checks for optimized virtual!\");\n@@ -598,1 +609,5 @@\n-    build_inline_tree_for_callee(callee_method, jvms, caller_bci);\n+    InlineTree* callee_tree = build_inline_tree_for_callee(callee_method, jvms, caller_bci);\n+    if (should_delay) {\n+      \/\/ Record late inlining decision in order to dump it for compiler replay\n+      callee_tree->set_late_inline();\n+    }\n@@ -703,1 +718,1 @@\n-  out->print(\" %d %d \", inline_level(), caller_bci());\n+  out->print(\" %d %d %d \", inline_level(), caller_bci(), _late_inline);\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":29,"deletions":14,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-      bool should_delay = false;\n+      bool should_delay = AlwaysIncrementalInline;\n@@ -192,1 +192,1 @@\n-          } else if ((should_delay || AlwaysIncrementalInline)) {\n+          } else if (should_delay) {\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -178,0 +178,1 @@\n+class ShiftVNode;\n@@ -717,3 +718,4 @@\n-        DEFINE_CLASS_ID(CompressV, Vector, 3)\n-        DEFINE_CLASS_ID(ExpandV, Vector, 4)\n-        DEFINE_CLASS_ID(CompressM, Vector, 5)\n+        DEFINE_CLASS_ID(ShiftV, Vector, 3)\n+        DEFINE_CLASS_ID(CompressV, Vector, 4)\n+        DEFINE_CLASS_ID(ExpandV, Vector, 5)\n+        DEFINE_CLASS_ID(CompressM, Vector, 6)\n@@ -949,4 +951,4 @@\n-  DEFINE_CLASS_QUERY(VectorReinterpret);\n-  DEFINE_CLASS_QUERY(CompressV);\n-  DEFINE_CLASS_QUERY(ExpandV);\n-  DEFINE_CLASS_QUERY(CompressM);\n+  DEFINE_CLASS_QUERY(VectorReinterpret)\n+  DEFINE_CLASS_QUERY(CompressV)\n+  DEFINE_CLASS_QUERY(ExpandV)\n+  DEFINE_CLASS_QUERY(CompressM)\n@@ -957,0 +959,1 @@\n+  DEFINE_CLASS_QUERY(ShiftV)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  bool        _late_inline;       \/\/ method is inlined incrementally\n@@ -78,0 +79,1 @@\n+                            NOT_PRODUCT_ARG(bool& should_delay)\n@@ -82,0 +84,1 @@\n+                                NOT_PRODUCT_ARG(bool& should_delay)\n@@ -115,0 +118,4 @@\n+  void set_late_inline() {\n+    _late_inline = true;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1283,0 +1283,5 @@\n+  \/\/ The frame we rethrow the exception to might not have been processed by the GC yet.\n+  \/\/ The stack watermark barrier takes care of detecting that and ensuring the frame\n+  \/\/ has updated oops.\n+  StackWatermarkSet::after_unwind(current);\n+\n@@ -1425,1 +1430,1 @@\n-    RegisterMap map(current, false);\n+    RegisterMap map(current, false \/* update_map *\/, false \/* process_frames *\/);\n@@ -1464,5 +1469,0 @@\n-  \/\/ The frame we rethrow the exception to might not have been processed by the GC yet.\n-  \/\/ The stack watermark barrier takes care of detecting that and ensuring the frame\n-  \/\/ has updated oops.\n-  StackWatermarkSet::after_unwind(thread);\n-\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2561,0 +2561,8 @@\n+      } else if (opc == Op_ConvI2F || opc == Op_ConvL2D ||\n+                 opc == Op_ConvF2I || opc == Op_ConvD2L) {\n+        assert(n->req() == 2, \"only one input expected\");\n+        BasicType bt = velt_basic_type(n);\n+        int vopc = VectorNode::opcode(opc, bt);\n+        Node* in = vector_opd(p, 1);\n+        vn = VectorCastNode::make(vopc, in, bt, vlen);\n+        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -532,1 +532,1 @@\n-        operation = VectorNode::make(sopc, opd1, opd2, vt, is_vector_mask(vbox_klass));\n+        operation = VectorNode::make(sopc, opd1, opd2, vt, is_vector_mask(vbox_klass), VectorNode::is_shift_opcode(opc));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -227,0 +227,8 @@\n+  case Op_ConvI2F:\n+    return Op_VectorCastI2X;\n+  case Op_ConvL2D:\n+    return Op_VectorCastL2X;\n+  case Op_ConvF2I:\n+    return Op_VectorCastF2X;\n+  case Op_ConvD2L:\n+    return Op_VectorCastD2X;\n@@ -475,1 +483,1 @@\n-VectorNode* VectorNode::make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask) {\n+VectorNode* VectorNode::make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask, bool is_var_shift) {\n@@ -529,4 +537,4 @@\n-  case Op_LShiftVB: return new LShiftVBNode(n1, n2, vt);\n-  case Op_LShiftVS: return new LShiftVSNode(n1, n2, vt);\n-  case Op_LShiftVI: return new LShiftVINode(n1, n2, vt);\n-  case Op_LShiftVL: return new LShiftVLNode(n1, n2, vt);\n+  case Op_LShiftVB: return new LShiftVBNode(n1, n2, vt, is_var_shift);\n+  case Op_LShiftVS: return new LShiftVSNode(n1, n2, vt, is_var_shift);\n+  case Op_LShiftVI: return new LShiftVINode(n1, n2, vt, is_var_shift);\n+  case Op_LShiftVL: return new LShiftVLNode(n1, n2, vt, is_var_shift);\n@@ -534,4 +542,4 @@\n-  case Op_RShiftVB: return new RShiftVBNode(n1, n2, vt);\n-  case Op_RShiftVS: return new RShiftVSNode(n1, n2, vt);\n-  case Op_RShiftVI: return new RShiftVINode(n1, n2, vt);\n-  case Op_RShiftVL: return new RShiftVLNode(n1, n2, vt);\n+  case Op_RShiftVB: return new RShiftVBNode(n1, n2, vt, is_var_shift);\n+  case Op_RShiftVS: return new RShiftVSNode(n1, n2, vt, is_var_shift);\n+  case Op_RShiftVI: return new RShiftVINode(n1, n2, vt, is_var_shift);\n+  case Op_RShiftVL: return new RShiftVLNode(n1, n2, vt, is_var_shift);\n@@ -539,4 +547,4 @@\n-  case Op_URShiftVB: return new URShiftVBNode(n1, n2, vt);\n-  case Op_URShiftVS: return new URShiftVSNode(n1, n2, vt);\n-  case Op_URShiftVI: return new URShiftVINode(n1, n2, vt);\n-  case Op_URShiftVL: return new URShiftVLNode(n1, n2, vt);\n+  case Op_URShiftVB: return new URShiftVBNode(n1, n2, vt, is_var_shift);\n+  case Op_URShiftVS: return new URShiftVSNode(n1, n2, vt, is_var_shift);\n+  case Op_URShiftVI: return new URShiftVINode(n1, n2, vt, is_var_shift);\n+  case Op_URShiftVL: return new URShiftVLNode(n1, n2, vt, is_var_shift);\n@@ -562,1 +570,1 @@\n-VectorNode* VectorNode::make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt) {\n+VectorNode* VectorNode::make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt, bool is_var_shift) {\n@@ -567,1 +575,1 @@\n-  return make(vopc, n1, n2, vt);\n+  return make(vopc, n1, n2, vt, false, is_var_shift);\n@@ -1296,2 +1304,2 @@\n-  return new OrVNode(phase->transform(VectorNode::make(shiftLOpc, src, shiftLCnt, vlen, bt)),\n-                     phase->transform(VectorNode::make(shiftROpc, src, shiftRCnt, vlen, bt)),\n+  return new OrVNode(phase->transform(VectorNode::make(shiftLOpc, src, shiftLCnt, vlen, bt, is_binary_vector_op)),\n+                     phase->transform(VectorNode::make(shiftROpc, src, shiftRCnt, vlen, bt, is_binary_vector_op)),\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":25,"deletions":17,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -75,2 +75,2 @@\n-  static VectorNode* make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt);\n-  static VectorNode* make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask = false);\n+  static VectorNode* make(int opc, Node* n1, Node* n2, uint vlen, BasicType bt, bool is_var_shift = false);\n+  static VectorNode* make(int vopc, Node* n1, Node* n2, const TypeVect* vt, bool is_mask = false, bool is_var_shift = false);\n@@ -534,0 +534,1 @@\n+ bool _is_var_shift;\n@@ -535,1 +536,4 @@\n-  ShiftVNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1,in2,vt) {}\n+  ShiftVNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift) :\n+    VectorNode(in1,in2,vt), _is_var_shift(is_var_shift) {\n+    init_class_id(Class_ShiftV);\n+  }\n@@ -538,0 +542,2 @@\n+  bool is_var_shift() { return _is_var_shift;}\n+  virtual  uint  size_of() const { return sizeof(ShiftVNode); }\n@@ -544,1 +550,2 @@\n-  LShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  LShiftVBNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -552,1 +559,2 @@\n-  LShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  LShiftVSNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -560,1 +568,2 @@\n-  LShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  LShiftVINode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -568,1 +577,2 @@\n-  LShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  LShiftVLNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -576,1 +586,2 @@\n-  RShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  RShiftVBNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -584,1 +595,2 @@\n-  RShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  RShiftVSNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -592,1 +604,2 @@\n-  RShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  RShiftVINode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -600,1 +613,2 @@\n-  RShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  RShiftVLNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -608,1 +622,2 @@\n-  URShiftVBNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  URShiftVBNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -616,1 +631,2 @@\n-  URShiftVSNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  URShiftVSNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -624,1 +640,2 @@\n-  URShiftVINode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  URShiftVINode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+    ShiftVNode(in1,in2,vt,is_var_shift) {}\n@@ -632,1 +649,2 @@\n-  URShiftVLNode(Node* in1, Node* in2, const TypeVect* vt) : ShiftVNode(in1,in2,vt) {}\n+  URShiftVLNode(Node* in1, Node* in2, const TypeVect* vt, bool is_var_shift=false) :\n+     ShiftVNode(in1,in2,vt,is_var_shift) {}\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":33,"deletions":15,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1396,0 +1396,3 @@\n+  if (java_thread->is_exiting()) {\n+    return; \/* JVMTI_ERROR_THREAD_NOT_ALIVE (default) *\/\n+  }\n@@ -1526,0 +1529,4 @@\n+\n+  if (java_thread->is_exiting()) {\n+    return; \/* JVMTI_ERROR_THREAD_NOT_ALIVE (default) *\/\n+  }\n@@ -1602,8 +1609,6 @@\n-  if (!java_thread->is_exiting() && java_thread->threadObj() != NULL) {\n-    _state->update_for_pop_top_frame();\n-    java_thread->set_popframe_condition(JavaThread::popframe_pending_bit);\n-    \/\/ Set pending step flag for this popframe and it is cleared when next\n-    \/\/ step event is posted.\n-    _state->set_pending_step_for_popframe();\n-    _result = JVMTI_ERROR_NONE;\n-  }\n+  _state->update_for_pop_top_frame();\n+  java_thread->set_popframe_condition(JavaThread::popframe_pending_bit);\n+  \/\/ Set pending step flag for this popframe and it is cleared when next\n+  \/\/ step event is posted.\n+  _state->set_pending_step_for_popframe();\n+  _result = JVMTI_ERROR_NONE;\n@@ -1617,0 +1622,3 @@\n+  if (java_thread->is_exiting()) {\n+    return; \/* JVMTI_ERROR_THREAD_NOT_ALIVE (default) *\/\n+  }\n@@ -1636,3 +1644,0 @@\n-  if (java_thread->is_exiting() || java_thread->threadObj() == NULL) {\n-    return; \/* JVMTI_ERROR_THREAD_NOT_ALIVE (default) *\/\n-  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"prims\/jvmtiExport.hpp\"\n@@ -332,0 +333,1 @@\n+  JvmtiVMObjectAllocEventCollector oam;\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -295,0 +295,1 @@\n+        case T_LONG:   return Op_NegL;\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -531,0 +531,4 @@\n+  { \"DumpSharedSpaces\",             JDK_Version::jdk(18), JDK_Version::jdk(19), JDK_Version::undefined() },\n+  { \"DynamicDumpSharedSpaces\",      JDK_Version::jdk(18), JDK_Version::jdk(19), JDK_Version::undefined() },\n+  { \"RequireSharedSpaces\",          JDK_Version::jdk(18), JDK_Version::jdk(19), JDK_Version::undefined() },\n+  { \"UseSharedSpaces\",              JDK_Version::jdk(18), JDK_Version::jdk(19), JDK_Version::undefined() },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1804,1 +1804,1 @@\n-          \"Use shared spaces for metadata\")                                 \\\n+          \"(Deprecated) Use shared spaces for metadata\")                    \\\n@@ -1810,1 +1810,1 @@\n-          \"Require shared spaces for metadata\")                             \\\n+          \"(Deprecated) Require shared spaces for metadata\")                \\\n@@ -1813,3 +1813,3 @@\n-          \"Special mode: JVM reads a class list, loads classes, builds \"    \\\n-          \"shared spaces, and dumps the shared spaces to a file to be \"     \\\n-          \"used in future JVM runs\")                                        \\\n+          \"(Deprecated) Special mode: JVM reads a class list, loads \"       \\\n+          \"classes, builds shared spaces, and dumps the shared spaces to \"  \\\n+          \"a file to be used in future JVM runs\")                           \\\n@@ -1818,1 +1818,1 @@\n-          \"Dynamic archive\")                                                \\\n+          \"(Deprecated) Dynamic archive\")                                   \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -134,0 +134,1 @@\n+Monitor* MetaspaceCritical_lock       = NULL;\n@@ -246,0 +247,1 @@\n+  def(MetaspaceCritical_lock       , PaddedMonitor, nosafepoint-1);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,1 +142,2 @@\n-extern Mutex*   Metaspace_lock;            \/\/ protects Metaspace virtualspace and chunk expansions\n+extern Mutex*   Metaspace_lock;                  \/\/ protects Metaspace virtualspace and chunk expansions\n+extern Monitor* MetaspaceCritical_lock;          \/\/ synchronizes failed metaspace allocations that risk throwing metaspace OOM\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -500,1 +500,1 @@\n-      \/\/ * OptoRuntime::rethrow_C for C2 code\n+      \/\/ * OptoRuntime::handle_exception_C_helper for C2 code\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1913,1 +1913,0 @@\n-      _poi = Universe::heap()->parallel_object_iterator(_num_dumper_threads);\n@@ -2002,4 +2001,0 @@\n-    if (_poi != NULL) {\n-      delete _poi;\n-      _poi = NULL;\n-    }\n@@ -2255,1 +2250,8 @@\n-    workers->run_task(this);\n+    if (_num_dumper_threads > 1) {\n+      ParallelObjectIterator poi(_num_dumper_threads);\n+      _poi = &poi;\n+      workers->run_task(this);\n+      _poi = NULL;\n+    } else {\n+      workers->run_task(this);\n+    }\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+  JVM_ACC_IS_BEING_REDEFINED      = 0x00100000,     \/\/ True if the klass is being redefined.\n@@ -162,0 +163,4 @@\n+  bool is_being_redefined() const       { return (_flags & JVM_ACC_IS_BEING_REDEFINED) != 0; }\n+  void set_is_being_redefined()         { atomic_set_bits(JVM_ACC_IS_BEING_REDEFINED); }\n+  void clear_is_being_redefined()       { atomic_clear_bits(JVM_ACC_IS_BEING_REDEFINED); }\n+\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -102,1 +102,3 @@\n-     * Creates an OutputStreamWriter that uses the default character encoding.\n+     * Creates an OutputStreamWriter that uses the default character encoding, or\n+     * where {@code out} is a {@code PrintStream}, the charset used by the print\n+     * stream.\n@@ -110,1 +112,1 @@\n-                Charset.defaultCharset());\n+                out instanceof PrintStream ps ? ps.charset() : Charset.defaultCharset());\n","filename":"src\/java.base\/share\/classes\/java\/io\/OutputStreamWriter.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+    private final Charset charset;\n@@ -111,1 +112,2 @@\n-        this.charOut = new OutputStreamWriter(this);\n+        this.charset = out instanceof PrintStream ps ? ps.charset() : Charset.defaultCharset();\n+        this.charOut = new OutputStreamWriter(this, charset);\n@@ -127,1 +129,2 @@\n-     * to bytes using the default charset.\n+     * to bytes using the default charset, or where {@code out} is a\n+     * {@code PrintStream}, the charset used by the print stream.\n@@ -142,1 +145,2 @@\n-     * the default charset.\n+     * the default charset, or where {@code out} is a {@code PrintStream},\n+     * the charset used by the print stream.\n@@ -204,0 +208,1 @@\n+        this.charset = charset;\n@@ -1377,0 +1382,8 @@\n+    \/**\n+     * {@return the charset used in this {@code PrintStream} instance}\n+     *\n+     * @since 18\n+     *\/\n+    public Charset charset() {\n+        return charset;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/io\/PrintStream.java","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -121,1 +121,2 @@\n-     * into bytes using the default charset.\n+     * into bytes using the default charset, or where {@code out} is a\n+     * {@code PrintStream}, the charset used by the print stream.\n@@ -135,2 +136,3 @@\n-     * OutputStreamWriter, which will convert characters into bytes using the\n-     * default charset.\n+     * OutputStreamWriter, which will convert characters into bytes using\n+     * the default charset, or where {@code out} is a {@code PrintStream},\n+     * the charset used by the print stream.\n@@ -147,1 +149,1 @@\n-        this(out, autoFlush, Charset.defaultCharset());\n+        this(out, autoFlush, out instanceof PrintStream ps ? ps.charset() : Charset.defaultCharset());\n","filename":"src\/java.base\/share\/classes\/java\/io\/PrintWriter.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.io.UnsupportedEncodingException;\n@@ -48,1 +47,0 @@\n-import java.nio.charset.CharacterCodingException;\n@@ -51,0 +49,1 @@\n+import java.nio.charset.CharacterCodingException;\n@@ -87,0 +86,1 @@\n+import sun.nio.cs.UTF_8;\n@@ -191,0 +191,5 @@\n+    \/\/ `sun.jnu.encoding` if it is not supported. Otherwise null.\n+    \/\/ It is initialized in `initPhase1()` before any charset providers\n+    \/\/ are initialized.\n+    private static String notSupportedJnuEncoding;\n+\n@@ -2020,4 +2025,3 @@\n-       if (enc != null) {\n-            try {\n-                return new PrintStream(new BufferedOutputStream(fos, 128), true, enc);\n-            } catch (UnsupportedEncodingException uee) {}\n+        if (enc != null) {\n+            return new PrintStream(new BufferedOutputStream(fos, 128), true,\n+                                   Charset.forName(enc, UTF_8.INSTANCE));\n@@ -2116,0 +2120,7 @@\n+        \/\/ Check if sun.jnu.encoding is supported. If not, replace it with UTF-8.\n+        var jnuEncoding = props.getProperty(\"sun.jnu.encoding\");\n+        if (jnuEncoding == null || !Charset.isSupported(jnuEncoding)) {\n+            notSupportedJnuEncoding = jnuEncoding == null ? \"null\" : jnuEncoding;\n+            props.setProperty(\"sun.jnu.encoding\", \"UTF-8\");\n+        }\n+\n@@ -2144,1 +2155,0 @@\n-\n@@ -2251,0 +2261,8 @@\n+        \/\/ Emit a warning if `sun.jnu.encoding` is not supported.\n+        if (notSupportedJnuEncoding != null) {\n+            System.err.println(\n+                    \"WARNING: The encoding of the underlying platform's\" +\n+                    \" file system is not supported: \" +\n+                    notSupportedJnuEncoding);\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.lang.invoke.StringConcatFactory;\n@@ -35,0 +36,1 @@\n+import java.util.ArrayList;\n@@ -55,0 +57,2 @@\n+    private static final int MAX_STRING_CONCAT_SLOTS = 20;\n+\n@@ -254,2 +258,3 @@\n-    private static MethodHandle makeToString(Class<?> receiverClass,\n-                                            List<MethodHandle> getters,\n+    private static MethodHandle makeToString(MethodHandles.Lookup lookup,\n+                                            Class<?> receiverClass,\n+                                            MethodHandle[] getters,\n@@ -257,20 +262,6 @@\n-        \/\/ This is a pretty lousy algorithm; we spread the receiver over N places,\n-        \/\/ apply the N getters, apply N toString operations, and concat the result with String.format\n-        \/\/ Better to use String.format directly, or delegate to StringConcatFactory\n-        \/\/ Also probably want some quoting around String components\n-\n-        assert getters.size() == names.size();\n-\n-        int[] invArgs = new int[getters.size()];\n-        Arrays.fill(invArgs, 0);\n-        MethodHandle[] filters = new MethodHandle[getters.size()];\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(receiverClass.getSimpleName()).append(\"[\");\n-        for (int i=0; i<getters.size(); i++) {\n-            MethodHandle getter = getters.get(i); \/\/ (R)T\n-            MethodHandle stringify = stringifier(getter.type().returnType()); \/\/ (T)String\n-            MethodHandle stringifyThisField = MethodHandles.filterArguments(stringify, 0, getter);    \/\/ (R)String\n-            filters[i] = stringifyThisField;\n-            sb.append(names.get(i)).append(\"=%s\");\n-            if (i != getters.size() - 1)\n-                sb.append(\", \");\n+        assert getters.length == names.size();\n+        if (getters.length == 0) {\n+            \/\/ special case\n+            MethodHandle emptyRecordCase = MethodHandles.constant(String.class, receiverClass.getSimpleName() + \"[]\");\n+            emptyRecordCase = MethodHandles.dropArguments(emptyRecordCase, 0, receiverClass); \/\/ (R)S\n+            return emptyRecordCase;\n@@ -278,7 +269,85 @@\n-        sb.append(']');\n-        String formatString = sb.toString();\n-        MethodHandle formatter = MethodHandles.insertArguments(STRING_FORMAT, 0, formatString)\n-                                              .asCollector(String[].class, getters.size()); \/\/ (R*)String\n-        if (getters.size() == 0) {\n-            \/\/ Add back extra R\n-            formatter = MethodHandles.dropArguments(formatter, 0, receiverClass);\n+\n+        boolean firstTime = true;\n+        MethodHandle[] mhs;\n+        List<List<MethodHandle>> splits;\n+        MethodHandle[] toSplit = getters;\n+        int namesIndex = 0;\n+        do {\n+            \/* StringConcatFactory::makeConcatWithConstants can only deal with 200 slots, longs and double occupy two\n+             * the rest 1 slot, we need to chop the current `getters` into chunks, it could be that for records with\n+             * a lot of components that we need to do a couple of iterations. The main difference between the first\n+             * iteration and the rest would be on the recipe\n+             *\/\n+            splits = split(toSplit);\n+            mhs = new MethodHandle[splits.size()];\n+            for (int splitIndex = 0; splitIndex < splits.size(); splitIndex++) {\n+                String recipe = \"\";\n+                if (firstTime && splitIndex == 0) {\n+                    recipe = receiverClass.getSimpleName() + \"[\";\n+                }\n+                for (int i = 0; i < splits.get(splitIndex).size(); i++) {\n+                    recipe += firstTime ? names.get(namesIndex) + \"=\" + \"\\1\" : \"\\1\";\n+                    if (firstTime && namesIndex != names.size() - 1) {\n+                        recipe += \", \";\n+                    }\n+                    namesIndex++;\n+                }\n+                if (firstTime && splitIndex == splits.size() - 1) {\n+                    recipe += \"]\";\n+                }\n+                Class<?>[] concatTypeArgs = new Class<?>[splits.get(splitIndex).size()];\n+                \/\/ special case: no need to create another getters if there is only one split\n+                MethodHandle[] currentSplitGetters = new MethodHandle[splits.get(splitIndex).size()];\n+                for (int j = 0; j < splits.get(splitIndex).size(); j++) {\n+                    concatTypeArgs[j] = splits.get(splitIndex).get(j).type().returnType();\n+                    currentSplitGetters[j] = splits.get(splitIndex).get(j);\n+                }\n+                MethodType concatMT = MethodType.methodType(String.class, concatTypeArgs);\n+                try {\n+                    mhs[splitIndex] = StringConcatFactory.makeConcatWithConstants(\n+                            lookup, \"\",\n+                            concatMT,\n+                            recipe,\n+                            new Object[0]\n+                    ).getTarget();\n+                    mhs[splitIndex] = MethodHandles.filterArguments(mhs[splitIndex], 0, currentSplitGetters);\n+                    \/\/ this will spread the receiver class across all the getters\n+                    mhs[splitIndex] = MethodHandles.permuteArguments(\n+                            mhs[splitIndex],\n+                            MethodType.methodType(String.class, receiverClass),\n+                            new int[splits.get(splitIndex).size()]\n+                    );\n+                } catch (Throwable t) {\n+                    throw new RuntimeException(t);\n+                }\n+            }\n+            toSplit = mhs;\n+            firstTime = false;\n+        } while (splits.size() > 1);\n+        return mhs[0];\n+    }\n+\n+    \/**\n+     * Chops the getters into smaller chunks according to the maximum number of slots\n+     * StringConcatFactory::makeConcatWithConstants can chew\n+     * @param getters the current getters\n+     * @return chunks that wont surpass the maximum number of slots StringConcatFactory::makeConcatWithConstants can chew\n+     *\/\n+    private static List<List<MethodHandle>> split(MethodHandle[] getters) {\n+        List<List<MethodHandle>> splits = new ArrayList<>();\n+\n+        int slots = 0;\n+\n+        \/\/ Need to peel, so that neither call has more than acceptable number\n+        \/\/ of slots for the arguments.\n+        List<MethodHandle> cArgs = new ArrayList<>();\n+        for (MethodHandle methodHandle : getters) {\n+            Class<?> returnType = methodHandle.type().returnType();\n+            int needSlots = (returnType == long.class || returnType == double.class) ? 2 : 1;\n+            if (slots + needSlots > MAX_STRING_CONCAT_SLOTS) {\n+                splits.add(cArgs);\n+                cArgs = new ArrayList<>();\n+                slots = 0;\n+            }\n+            cArgs.add(methodHandle);\n+            slots += needSlots;\n@@ -286,3 +355,4 @@\n-        else {\n-            MethodHandle filtered = MethodHandles.filterArguments(formatter, 0, filters);\n-            formatter = MethodHandles.permuteArguments(filtered, MethodType.methodType(String.class, receiverClass), invArgs);\n+\n+        \/\/ Flush the tail slice\n+        if (!cArgs.isEmpty()) {\n+            splits.add(cArgs);\n@@ -291,1 +361,1 @@\n-        return formatter;\n+        return splits;\n@@ -370,1 +440,1 @@\n-                yield makeToString(recordClass, getterList, nameList);\n+                yield makeToString(lookup, recordClass, getters, nameList);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ObjectMethods.java","additions":104,"deletions":34,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -1081,1 +1081,1 @@\n-        if (header.indexOf(\"expires=\") != -1) {\n+        if (header.contains(\"expires=\")) {\n@@ -1084,1 +1084,1 @@\n-        } else if (header.indexOf(\"version=\") != -1) {\n+        } else if (header.contains(\"version=\")) {\n@@ -1087,1 +1087,1 @@\n-        } else if (header.indexOf(\"max-age\") != -1) {\n+        } else if (header.contains(\"max-age\")) {\n","filename":"src\/java.base\/share\/classes\/java\/net\/HttpCookie.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -603,1 +603,1 @@\n-            if (dateString.indexOf(\"GMT\") == -1) {\n+            if (!dateString.contains(\"GMT\")) {\n","filename":"src\/java.base\/share\/classes\/java\/net\/HttpURLConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.net.InetAddress;\n@@ -38,1 +37,0 @@\n-import java.security.Security;\n@@ -336,1 +334,1 @@\n-                    } else if (tokens == 8 && host.indexOf(\"::\") == -1) {\n+                    } else if (tokens == 8 && !host.contains(\"::\")) {\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketPermission.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-    private String type;\n+    private final transient String type;\n@@ -273,1 +273,2 @@\n-     * {@code CertPathRep} object.\n+     * {@link CertPathRep CertPathRep} object containing the\n+     * {@code Certificate} type and encoded bytes of the {@code CertPath}.\n@@ -275,1 +276,2 @@\n-     * @return the {@code CertPathRep} to be serialized\n+     * @return a {@code CertPathRep} containing the {@code Certificate} type\n+     *         and encoded bytes of the {@code CertPath}\n@@ -302,1 +304,1 @@\n-        \/** The Certificate type *\/\n+        \/** The type of {@code Certificate}s in the {@code CertPath}. *\/\n@@ -304,1 +306,1 @@\n-        \/** The encoded form of the cert path *\/\n+        \/** The encoded form of the {@code CertPath}. *\/\n@@ -311,1 +313,1 @@\n-         * @param type the standard name of a {@code CertPath} type\n+         * @param type the standard name of a {@code Certificate} type\n@@ -320,1 +322,2 @@\n-         * Returns a {@code CertPath} constructed from the type and data.\n+         * Returns a {@code CertPath} constructed from the type and data of\n+         * this {@code CertPathRep}.\n@@ -324,1 +327,1 @@\n-         * @throws ObjectStreamException if a {@code CertPath} could not\n+         * @throws ObjectStreamException if a {@code CertPath} object could not\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/CertPath.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    private final String type;\n+    private final transient String type;\n@@ -72,1 +72,1 @@\n-    private int hash = -1; \/\/ Default to -1\n+    private transient int hash = -1; \/\/ Default to -1\n@@ -239,1 +239,1 @@\n-     * Alternate Certificate class for serialization.\n+     * Alternate {@code Certificate} class for serialization.\n@@ -254,2 +254,2 @@\n-         * Construct the alternate Certificate class with the Certificate\n-         * type and Certificate encoding bytes.\n+         * Construct the alternate {@code Certificate} class with the\n+         * {@code Certificate} type and {@code Certificate} encoding bytes.\n@@ -257,1 +257,1 @@\n-         * @param type the standard name of the Certificate type.\n+         * @param type the standard name of the {@code Certificate} type.\n@@ -259,1 +259,1 @@\n-         * @param data the Certificate data.\n+         * @param data the {@code Certificate} data.\n@@ -267,1 +267,2 @@\n-         * Resolve the Certificate Object.\n+         * Returns a {@code Certificate} with the type and data of this\n+         * {@code CertificateRep}.\n@@ -269,1 +270,1 @@\n-         * @return the resolved Certificate Object\n+         * @return the resolved {@code Certificate} object\n@@ -271,1 +272,1 @@\n-         * @throws java.io.ObjectStreamException if the Certificate\n+         * @throws java.io.ObjectStreamException if the {@code Certificate}\n@@ -291,1 +292,3 @@\n-     * Replace the Certificate to be serialized.\n+     * Replace the {@code Certificate} to be serialized with a\n+     * {@link CertificateRep CertificateRep} object containing the type and\n+     * encoded bytes of the {@code Certificate}.\n@@ -293,1 +296,2 @@\n-     * @return the alternate Certificate object to be serialized\n+     * @return a {@code CertificateRep} object containing the type and encoded\n+     *         bytes of the {@code Certificate}\n@@ -295,2 +299,2 @@\n-     * @throws java.io.ObjectStreamException if a new object representing\n-     * this Certificate could not be created\n+     * @throws java.io.ObjectStreamException if a {@code CertificateRep} object\n+     *         representing this {@code Certificate} could not be created\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/Certificate.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1065,1 +1065,1 @@\n-    @jdk.internal.ValueBased\n+    \/\/ Not a jdk.internal.ValueBased class; disqualified by fields in superclass AbstractMap\n@@ -1096,1 +1096,1 @@\n-    @jdk.internal.ValueBased\n+    \/\/ Not a jdk.internal.ValueBased class; disqualified by fields in superclass AbstractMap\n@@ -1163,1 +1163,1 @@\n-    @jdk.internal.ValueBased\n+    \/\/ Not a jdk.internal.ValueBased class; disqualified by fields in superclass AbstractMap\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1199,1 +1199,1 @@\n-         * @implSpec The default implementation calls {@link JumpableGenerator#jump jump}().\n+         * @implSpec The default implementation calls {@link JumpableGenerator#jumps jumps}().\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -350,1 +350,3 @@\n- * interface {@link RandomGenerator.LeapableGenerator}. There is also an interface\n+ * interface {@link RandomGenerator.LeapableGenerator}. In this package,\n+ * implementations of this interface include \"Xoroshiro128PlusPlus\" and\n+ * \"Xoshiro256PlusPlus\". There is also an interface\n@@ -352,4 +354,2 @@\n- * jumping along the state cycle by any user-specified distance. In this package,\n- * implementations of these interfaces include\n- * \"Xoroshiro128PlusPlus\", and\n- * \"Xoshiro256PlusPlus\".\n+ * jumping along the state cycle by any user-specified distance; there are currently\n+ * no implementations of this interface in this package.\n@@ -385,2 +385,2 @@\n- * Vigna in \"Scrambled Linear Pseudorandom Number Generators\", ACM Transactions\n- * on Mathematical Software, 2021) with an LCG that uses one of the best\n+ * Vigna in \"Scrambled Linear Pseudorandom Number Generators\", <i>ACM Transactions\n+ * on Mathematical Software<\/i>, 2021) with an LCG that uses one of the best\n@@ -388,4 +388,9 @@\n- * in 2019 by Steele and Vigna), and then applies either a mixing function\n- * identified by Doug Lea or a simple scrambler proposed by Blackman and Vigna.\n- * Testing has confirmed that the LXM algorithm is far superior in quality to\n- * the SplitMix algorithm (2014) used by {@code SplittableRandom}.\n+ * in 2019 by Steele and Vigna, described in \"Computationally Easy, Spectrally\n+ * Good Multipliers for Congruential Pseudorandom Number Generators\",\n+ * <i>Software: Practice and Experience<\/i> (2021), doi:10.1002\/spe.3030),\n+ * and then applies either a mixing function identified by Doug Lea or\n+ * or a simple scrambler proposed by Blackman and Vigna. Testing has\n+ * confirmed that the LXM algorithm is far superior in quality to the\n+ * SplitMix algorithm (2014) used by {@code SplittableRandom}\n+ * (see Steele and Vigna, \"LXM: Better Splittable Pseudorandom Number\n+ * Generators (and Almost as Fast)\", <i>Proc. 2021 ACM OOPSLA Conference<\/i>).\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/package-info.java","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -5608,0 +5608,31 @@\n+    private static CharPredicate and(CharPredicate p1, CharPredicate p2,\n+                                     boolean bmpChar) {\n+        if (bmpChar) {\n+            return (BmpCharPredicate)(ch -> p1.is(ch) && p2.is(ch));\n+        } else {\n+            return (CharPredicate)(ch -> p1.is(ch) && p2.is(ch));\n+        }\n+    }\n+\n+    private static CharPredicate union(CharPredicate p1, CharPredicate p2,\n+                                       boolean bmpChar) {\n+        if (bmpChar) {\n+            return (BmpCharPredicate)(ch -> p1.is(ch) || p2.is(ch));\n+        } else {\n+            return (CharPredicate)(ch -> p1.is(ch) || p2.is(ch));\n+        }\n+    }\n+\n+    private static CharPredicate union(CharPredicate p1, CharPredicate p2,\n+                                       CharPredicate p3, boolean bmpChar) {\n+        if (bmpChar) {\n+            return (BmpCharPredicate)(ch -> p1.is(ch) || p2.is(ch) || p3.is(ch));\n+        } else {\n+            return (CharPredicate)(ch -> p1.is(ch) || p2.is(ch) || p3.is(ch));\n+        }\n+    }\n+\n+    private static CharPredicate negate(CharPredicate p1) {\n+        return (CharPredicate)(ch -> !p1.is(ch));\n+    }\n+\n@@ -5613,1 +5644,1 @@\n-            return ch -> is(ch) && p.is(ch);\n+            return Pattern.and(this, p, false);\n@@ -5616,1 +5647,1 @@\n-            return ch -> is(ch) || p.is(ch);\n+            return Pattern.union(this, p, false);\n@@ -5620,1 +5651,1 @@\n-            return ch -> is(ch) || p1.is(ch) || p2.is(ch);\n+            return Pattern.union(this, p1, p2, false);\n@@ -5623,1 +5654,1 @@\n-            return ch -> !is(ch);\n+            return Pattern.negate(this);\n@@ -5630,3 +5661,1 @@\n-            if (p instanceof BmpCharPredicate)\n-                return (BmpCharPredicate)(ch -> is(ch) && p.is(ch));\n-            return ch -> is(ch) && p.is(ch);\n+            return Pattern.and(this, p, p instanceof BmpCharPredicate);\n@@ -5635,17 +5664,7 @@\n-            if (p instanceof BmpCharPredicate)\n-                return (BmpCharPredicate)(ch -> is(ch) || p.is(ch));\n-            return ch -> is(ch) || p.is(ch);\n-        }\n-        static CharPredicate union(CharPredicate... predicates) {\n-            CharPredicate cp = ch -> {\n-                for (CharPredicate p : predicates) {\n-                    if (!p.is(ch))\n-                        return false;\n-                }\n-                return true;\n-            };\n-            for (CharPredicate p : predicates) {\n-                if (! (p instanceof BmpCharPredicate))\n-                    return cp;\n-            }\n-            return (BmpCharPredicate)cp;\n+            return Pattern.union(this, p, p instanceof BmpCharPredicate);\n+        }\n+        default CharPredicate union(CharPredicate p1,\n+                                    CharPredicate p2) {\n+            return Pattern.union(this, p1, p2,\n+                                 p1 instanceof BmpCharPredicate &&\n+                                 p2 instanceof BmpCharPredicate);\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Pattern.java","additions":43,"deletions":24,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -147,0 +147,1 @@\n+        byte[] bytes = null;\n@@ -148,3 +149,4 @@\n-            this.comment = zc.getBytes(comment);\n-            if (this.comment.length > 0xffff)\n-                throw new IllegalArgumentException(\"ZIP file comment too long.\");\n+            bytes = zc.getBytes(comment);\n+            if (bytes.length > 0xffff) {\n+                throw new IllegalArgumentException(\"ZIP file comment too long\");\n+            }\n@@ -152,0 +154,1 @@\n+        this.comment = bytes;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipOutputStream.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -488,1 +488,1 @@\n-        if (length == 0 || (path.indexOf(\".\/\") == -1 && path.charAt(length - 1) != '.')) {\n+        if (length == 0 || (!path.contains(\".\/\") && path.charAt(length - 1) != '.')) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jrtfs\/JrtPath.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -564,1 +564,1 @@\n-                        perm.getActions().indexOf(\"read\") != -1) {\n+                        perm.getActions().contains(\"read\")) {\n@@ -568,1 +568,1 @@\n-                        perm.getActions().indexOf(\"connect\") != -1) {\n+                        perm.getActions().contains(\"connect\")) {\n@@ -1257,1 +1257,1 @@\n-                if (name.indexOf(\"..\") != -1) {\n+                if (name.contains(\"..\")) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-    private String getQualifiedFieldName() {\n+    protected String getQualifiedFieldName() {\n@@ -226,10 +226,0 @@\n-    protected String getMessage(boolean getter, String attemptedType) {\n-        String err = \"Can not \" + (getter ? \"get\" : \"set\");\n-        if (Modifier.isStatic(field.getModifiers()))\n-            err += \" static\";\n-        if (Modifier.isFinal(field.getModifiers()))\n-            err += \" final\";\n-        err += \" \" + field.getType().getName() + \" field \" + getQualifiedFieldName() + \" on \" + attemptedType;\n-        return err;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/FieldAccessorImpl.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-        ensureObj(obj);\n@@ -69,1 +68,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -125,1 +124,0 @@\n-        ensureObj(obj);\n@@ -127,0 +125,1 @@\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -138,1 +137,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleBooleanFieldAccessorImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -130,1 +130,0 @@\n-        ensureObj(obj);\n@@ -132,0 +131,1 @@\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -143,1 +143,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleByteFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -149,1 +149,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleCharacterFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -198,1 +198,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleDoubleFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.reflect.Modifier;\n@@ -67,0 +68,13 @@\n+    private String getMessage(boolean getter, Class<?> type) {\n+        String err = \"Can not \" + (getter ? \"get\" : \"set\");\n+        if (Modifier.isStatic(field.getModifiers()))\n+            err += \" static\";\n+        if (Modifier.isFinal(field.getModifiers()))\n+            err += \" final\";\n+        err += \" \" + field.getType().getName() + \" field \" + getQualifiedFieldName();\n+        if (type != null) {\n+            err += \" on \" + type.getName();\n+        }\n+        return err;\n+    }\n+\n@@ -71,2 +85,2 @@\n-    protected IllegalArgumentException newGetIllegalArgumentException(Class<?> type) {\n-        return new IllegalArgumentException(getMessage(true, type.getName()));\n+    protected IllegalArgumentException newGetIllegalArgumentException(Object o) {\n+        return new IllegalArgumentException(getMessage(true, o != null ? o.getClass() : null));\n@@ -79,2 +93,2 @@\n-    protected IllegalArgumentException newSetIllegalArgumentException(Class<?> type) {\n-        return new IllegalArgumentException(getMessage(false, type.getName()));\n+    protected IllegalArgumentException newSetIllegalArgumentException(Object o) {\n+        return new IllegalArgumentException(getMessage(false, o != null ? o.getClass() : null));\n@@ -82,2 +96,0 @@\n-\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleFieldAccessorImpl.java","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -189,1 +189,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleFloatFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -171,1 +171,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleIntegerFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -180,1 +180,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleLongFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -101,0 +101,1 @@\n+        ensureObj(obj);\n@@ -102,1 +103,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -114,1 +114,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ already ensure the receiver type.  So this CCE is due to the value.\n+            throwSetIllegalArgumentException(value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleObjectFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-            throw newGetIllegalArgumentException(obj.getClass());\n+            throw newGetIllegalArgumentException(obj);\n@@ -105,0 +105,1 @@\n+        ensureObj(obj);\n@@ -106,1 +107,0 @@\n-            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n@@ -159,1 +159,2 @@\n-            throw newSetIllegalArgumentException(obj.getClass());\n+            \/\/ receiver is of invalid type\n+            throw newSetIllegalArgumentException(obj);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleShortFieldAccessorImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,5 +37,0 @@\n-\/**\n- * A utility package for the java(1), javaw(1) launchers.\n- * The following are helper methods that the native launcher uses\n- * to perform checks etc. using JNI, see src\/share\/bin\/java.c\n- *\/\n@@ -91,1 +86,5 @@\n-\n+\/**\n+ * A utility package for the java(1), javaw(1) launchers.\n+ * The following are helper methods that the native launcher uses\n+ * to perform checks etc. using JNI, see src\/share\/bin\/java.c\n+ *\/\n@@ -157,2 +156,2 @@\n-        String opts[] = optionFlag.split(\":\");\n-        String optStr = (opts.length > 1 && opts[1] != null)\n+        String[] opts = optionFlag.split(\":\");\n+        String optStr = opts.length > 1\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-                if (f.indexOf(\"%d\") >= 0) {\n+                if (f.contains(\"%d\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/HttpCapture.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -648,1 +648,1 @@\n-        if ((cipher != null) && (cipher.indexOf(\"_anon_\") != -1)) {\n+        if ((cipher != null) && (cipher.contains(\"_anon_\"))) {\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/https\/HttpsClient.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -278,1 +278,0 @@\n-        ObjectIdentifier oid;\n@@ -283,0 +282,3 @@\n+            if (PKCS9Attribute.PKCS9_OIDS[i] == null) {\n+                continue;\n+            }\n@@ -326,1 +328,0 @@\n-        ObjectIdentifier oid;\n@@ -331,0 +332,3 @@\n+            if (PKCS9Attribute.PKCS9_OIDS[i] == null) {\n+                continue;\n+            }\n@@ -341,1 +345,1 @@\n-            sb.append(value.toString());\n+            sb.append(value);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS9Attributes.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -79,2 +79,3 @@\n-     * The key is the AlgorithmId of the algorithm, and the value is the name of\n-     * the field or attribute.\n+     * The key is the AlgorithmId of the algorithm, and the value is a record\n+     * containing the name of the field or attribute and whether the key\n+     * should also be checked (ex: if it is a signature algorithm).\n@@ -82,1 +83,2 @@\n-    private Map<AlgorithmId, String> algorithms = new HashMap<>();\n+    private record AlgorithmInfo(String field, boolean checkKey) {}\n+    private Map<AlgorithmId, AlgorithmInfo> algorithms = new HashMap<>();\n@@ -353,1 +355,2 @@\n-            algorithms.put(digestAlgorithmId, \"SignerInfo digestAlgorithm field\");\n+            algorithms.put(digestAlgorithmId,\n+                new AlgorithmInfo(\"SignerInfo digestAlgorithm field\", false));\n@@ -424,1 +427,2 @@\n-                    \"SignerInfo digestEncryptionAlgorithm field\");\n+                    new AlgorithmInfo(\n+                        \"SignerInfo digestEncryptionAlgorithm field\", true));\n@@ -680,1 +684,2 @@\n-        algorithms.put(digestAlgId, \"TimestampToken digestAlgorithm field\");\n+        algorithms.put(digestAlgId,\n+            new AlgorithmInfo(\"TimestampToken digestAlgorithm field\", false));\n@@ -737,1 +742,1 @@\n-        Map<AlgorithmId, String> algorithms = new HashMap<>();\n+        Map<AlgorithmId, AlgorithmInfo> algorithms = new HashMap<>();\n@@ -744,3 +749,4 @@\n-            for (Map.Entry<AlgorithmId, String> algorithm : algorithms.entrySet()) {\n-                params.setExtendedExceptionMsg(name, algorithm.getValue());\n-                AlgorithmId algId = algorithm.getKey();\n+            for (var algEntry : algorithms.entrySet()) {\n+                AlgorithmInfo info = algEntry.getValue();\n+                params.setExtendedExceptionMsg(name, info.field());\n+                AlgorithmId algId = algEntry.getKey();\n@@ -748,1 +754,1 @@\n-                    algId.getParameters(), params);\n+                    algId.getParameters(), params, info.checkKey());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/SignerInfo.java","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -726,1 +726,1 @@\n-                    if (pe.name != null && pe.name.indexOf(SELF) != -1) {\n+                    if (pe.name != null && pe.name.contains(SELF)) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/PolicyFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.security.cert.X509CRL;\n@@ -60,1 +59,0 @@\n-import sun.security.x509.X509CRLImpl;\n@@ -229,1 +227,1 @@\n-                dac.permits(trustedPubKey.getAlgorithm(), cp);\n+                dac.permits(trustedPubKey.getAlgorithm(), cp, true);\n@@ -235,1 +233,1 @@\n-            dac.permits(currSigAlg, currSigAlgParams, cp);\n+            dac.permits(currSigAlg, currSigAlgParams, cp, true);\n@@ -365,23 +363,0 @@\n-    \/**\n-     * Check the signature algorithm with the specified public key.\n-     *\n-     * @param key the public key to verify the CRL signature\n-     * @param crl the target CRL\n-     * @param variant the Validator variant of the operation. A null value\n-     *                passed will set it to Validator.GENERIC.\n-     * @param anchor the trust anchor selected to validate the CRL issuer\n-     *\/\n-    static void check(PublicKey key, X509CRL crl, String variant,\n-                      TrustAnchor anchor) throws CertPathValidatorException {\n-\n-        X509CRLImpl x509CRLImpl = null;\n-        try {\n-            x509CRLImpl = X509CRLImpl.toImpl(crl);\n-        } catch (CRLException ce) {\n-            throw new CertPathValidatorException(ce);\n-        }\n-\n-        AlgorithmId algorithmId = x509CRLImpl.getSigAlgId();\n-        check(key, algorithmId, variant, anchor);\n-    }\n-\n@@ -402,1 +377,1 @@\n-            new CertPathConstraintsParameters(key, variant, anchor, null));\n+            new CertPathConstraintsParameters(key, variant, anchor, null), true);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/AlgorithmChecker.java","additions":3,"deletions":28,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -656,1 +656,2 @@\n-            AlgorithmChecker.check(prevKey, crl, variant, anchor);\n+            AlgorithmChecker.check(prevKey, crlImpl.getSigAlgId(),\n+                                   variant, anchor);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/DistributionPointFetcher.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-        if (givenAlg.indexOf(\"-\") != -1) {\n+        if (givenAlg.contains(\"-\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPSSSignature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.IOException;\n@@ -64,1 +63,1 @@\n-            if (name.indexOf(\"PSS\") != -1) {\n+            if (name.contains(\"PSS\")) {\n@@ -66,1 +65,1 @@\n-            } else if (name.indexOf(\"RSA\") != -1) {\n+            } else if (name.contains(\"RSA\")) {\n@@ -154,1 +153,1 @@\n-            if (algName.indexOf(\"RSA\") != -1) {\n+            if (algName.contains(\"RSA\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAUtil.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1476,1 +1476,1 @@\n-            if (s.startsWith(\"-----BEGIN\") && s.indexOf(\"REQUEST\") >= 0) {\n+            if (s.startsWith(\"-----BEGIN\") && s.contains(\"REQUEST\")) {\n@@ -1479,1 +1479,1 @@\n-            } else if (s.startsWith(\"-----END\") && s.indexOf(\"REQUEST\") >= 0) {\n+            } else if (s.startsWith(\"-----END\") && s.contains(\"REQUEST\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Main.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-            if (transToken == null || transToken.isEmpty()) {\n+            if (transToken.isEmpty()) {\n@@ -73,1 +73,1 @@\n-                if (token == null || token.isEmpty()) {\n+                if (token.isEmpty()) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/AlgorithmDecomposer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-            if (args.indexOf(\"all\") != -1)\n+            if (args.contains(\"all\"))\n@@ -167,1 +167,1 @@\n-                return (args.indexOf(option) != -1);\n+                return (args.contains(option));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Debug.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -195,3 +195,3 @@\n-        ConstraintsParameters cp) throws CertPathValidatorException {\n-\n-        permits(algorithm, cp);\n+            ConstraintsParameters cp, boolean checkKey)\n+            throws CertPathValidatorException {\n+        permits(algorithm, cp, checkKey);\n@@ -222,1 +222,1 @@\n-            permits(digestAlg, cp);\n+            permits(digestAlg, cp, false);\n@@ -228,1 +228,1 @@\n-                    permits(mgfDigestAlg, cp);\n+                    permits(mgfDigestAlg, cp, false);\n@@ -236,8 +236,8 @@\n-    public final void permits(String algorithm, ConstraintsParameters cp)\n-            throws CertPathValidatorException {\n-\n-        \/\/ Check if named curves in the key are disabled.\n-        for (Key key : cp.getKeys()) {\n-            for (String curve : getNamedCurveFromKey(key)) {\n-                if (!checkAlgorithm(disabledAlgorithms, curve, decomposer)) {\n-                    throw new CertPathValidatorException(\n+    public final void permits(String algorithm, ConstraintsParameters cp,\n+            boolean checkKey) throws CertPathValidatorException {\n+        if (checkKey) {\n+            \/\/ Check if named curves in the key are disabled.\n+            for (Key key : cp.getKeys()) {\n+                for (String curve : getNamedCurveFromKey(key)) {\n+                    if (!checkAlgorithm(disabledAlgorithms, curve, decomposer)) {\n+                        throw new CertPathValidatorException(\n@@ -247,0 +247,1 @@\n+                    }\n@@ -250,2 +251,1 @@\n-\n-        algorithmConstraints.permits(algorithm, cp);\n+        algorithmConstraints.permits(algorithm, cp, checkKey);\n@@ -484,2 +484,2 @@\n-        public void permits(String algorithm, ConstraintsParameters cp)\n-                throws CertPathValidatorException {\n+        public void permits(String algorithm, ConstraintsParameters cp,\n+                boolean checkKey) throws CertPathValidatorException {\n@@ -499,2 +499,4 @@\n-            for (Key key : cp.getKeys()) {\n-                algorithms.add(key.getAlgorithm());\n+            if (checkKey) {\n+                for (Key key : cp.getKeys()) {\n+                    algorithms.add(key.getAlgorithm());\n+                }\n@@ -510,0 +512,3 @@\n+                    if (!checkKey && constraint instanceof KeySizeConstraint) {\n+                        continue;\n+                    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DisabledAlgorithmConstraints.java","additions":24,"deletions":19,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-    public JarConstraintsParameters(List<X509Certificate> chain, Timestamp timestamp) {\n+    public JarConstraintsParameters(List<X509Certificate> chain, Date timestamp) {\n@@ -105,6 +105,1 @@\n-        if (timestamp != null) {\n-            addToCertsAndKeys(timestamp.getSignerCertPath());\n-            this.timestamp = timestamp.getTimestamp();\n-        } else {\n-            this.timestamp = null;\n-        }\n+        this.timestamp = timestamp;\n@@ -181,1 +176,1 @@\n-        return message;\n+        return message == null ? \".\" : message;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/JarConstraintsParameters.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -220,1 +220,1 @@\n-                           .permits(digest.getAlgorithm(), params);\n+                           .permits(digest.getAlgorithm(), params, false);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ManifestEntryVerifier.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-                    .jarConstraints().permits(algorithm, params);\n+                    .jarConstraints().permits(algorithm, params, false);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureFileVerifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        if (algName.indexOf(\".\") == -1) {\n+        if (!algName.contains(\".\")) {\n@@ -103,1 +103,1 @@\n-            if (params.getAlgorithm().indexOf(\".\") != -1) {\n+            if (params.getAlgorithm().contains(\".\")) {\n@@ -112,1 +112,1 @@\n-            if (sigName.indexOf(\"RSA\") != -1) {\n+            if (sigName.contains(\"RSA\")) {\n@@ -114,1 +114,1 @@\n-            } else if (sigName.indexOf(\"ECDSA\") != -1) {\n+            } else if (sigName.contains(\"ECDSA\")) {\n@@ -144,1 +144,1 @@\n-            if (sigName.indexOf(\"RSA\") != -1) {\n+            if (sigName.contains(\"RSA\")) {\n@@ -148,1 +148,1 @@\n-            } else if (sigName.indexOf(\"ECDSA\") != -1) {\n+            } else if (sigName.contains(\"ECDSA\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureUtil.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -108,0 +108,1 @@\n+    private static final int KU_NON_REPUDIATION = 1;\n@@ -359,1 +360,3 @@\n-        if (checkKeyUsage(cert, KU_SIGNATURE) == false) {\n+        \/\/ KU and EKU should be consistent\n+        if (!checkKeyUsage(cert, KU_SIGNATURE)\n+                && !checkKeyUsage(cert, KU_NON_REPUDIATION)) {\n@@ -361,1 +364,1 @@\n-                (\"KeyUsage does not allow digital signatures\",\n+                (\"KeyUsage does not allow digital signatures or non repudiation\",\n","filename":"src\/java.base\/share\/classes\/sun\/security\/validator\/EndEntityChecker.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -523,1 +523,1 @@\n-        if (name.indexOf(\".\") == -1) {\n+        if (!name.contains(\".\")) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgorithmId.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-                    || range.indexOf(\"-*\") != -1) { \/\/ Extended range\n+                    || range.contains(\"-*\")) { \/\/ Extended range\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/LocaleMatcher.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -642,15 +642,0 @@\n-static jboolean isJNUEncodingSupported = JNI_FALSE;\n-static jboolean jnuEncodingSupported(JNIEnv *env) {\n-    jboolean exe;\n-    if (isJNUEncodingSupported == JNI_TRUE) {\n-        return JNI_TRUE;\n-    }\n-    isJNUEncodingSupported = (jboolean) JNU_CallStaticMethodByName (\n-                                    env, &exe,\n-                                    \"java\/nio\/charset\/Charset\",\n-                                    \"isSupported\",\n-                                    \"(Ljava\/lang\/String;)Z\",\n-                                    jnuEncoding).z;\n-    return isJNUEncodingSupported;\n-}\n-\n@@ -674,16 +659,2 @@\n-        if (jnuEncodingSupported(env)) {\n-            result = (*env)->NewObject(env, strClazz,\n-                                       String_init_ID, bytes, jnuEncoding);\n-        } else {\n-            \/*If the encoding specified in sun.jnu.encoding is not endorsed\n-              by \"Charset.isSupported\" we have to fall back to use String(byte[])\n-              explicitly here without specifying the encoding name, in which the\n-              StringCoding class will pickup the iso-8859-1 as the fallback\n-              converter for us.\n-             *\/\n-            jmethodID mid = (*env)->GetMethodID(env, strClazz,\n-                                                \"<init>\", \"([B)V\");\n-            if (mid != NULL) {\n-                result = (*env)->NewObject(env, strClazz, mid, bytes);\n-            }\n-        }\n+        result = (*env)->NewObject(env, strClazz,\n+                                   String_init_ID, bytes, jnuEncoding);\n@@ -769,0 +740,1 @@\n+            jboolean exe;\n@@ -772,2 +744,20 @@\n-            fastEncoding = NO_FAST_ENCODING;\n-            jnuEncoding = (jstring)(*env)->NewGlobalRef(env, enc);\n+\n+            if ((jboolean) JNU_CallStaticMethodByName (\n+                                            env, &exe,\n+                                            \"java\/nio\/charset\/Charset\",\n+                                            \"isSupported\",\n+                                            \"(Ljava\/lang\/String;)Z\",\n+                                            enc).z == JNI_TRUE) {\n+                fastEncoding = NO_FAST_ENCODING;\n+                jnuEncoding = (jstring)(*env)->NewGlobalRef(env, enc);\n+            } else {\n+                \/\/ jnuEncoding falls back to UTF-8\n+                jstring utf8 = (*env)->NewStringUTF(env, \"UTF-8\");\n+                if (utf8 == NULL) {\n+                    (*env)->DeleteLocalRef(env, enc);\n+                    return;\n+                }\n+                fastEncoding = FAST_UTF_8;\n+                jnuEncoding = (jstring)(*env)->NewGlobalRef(env, utf8);\n+                (*env)->DeleteLocalRef(env, utf8);\n+            }\n@@ -825,10 +815,12 @@\n-    if (jnuEncodingSupported(env)) {\n-        hab = (*env)->CallObjectMethod(env, jstr, String_getBytes_ID, jnuEncoding);\n-    } else {\n-        jmethodID mid;\n-        jclass strClazz = JNU_ClassString(env);\n-        CHECK_NULL_RETURN(strClazz, 0);\n-        mid = (*env)->GetMethodID(env, strClazz,\n-                                       \"getBytes\", \"()[B\");\n-        if (mid != NULL) {\n-            hab = (*env)->CallObjectMethod(env, jstr, mid);\n+    hab = (*env)->CallObjectMethod(env, jstr, String_getBytes_ID, jnuEncoding);\n+    if (hab != 0) {\n+        if (!(*env)->ExceptionCheck(env)) {\n+            jint len = (*env)->GetArrayLength(env, hab);\n+            result = MALLOC_MIN4(len);\n+            if (result == 0) {\n+                JNU_ThrowOutOfMemoryError(env, 0);\n+                (*env)->DeleteLocalRef(env, hab);\n+                return 0;\n+            }\n+            (*env)->GetByteArrayRegion(env, hab, 0, len, (jbyte *)result);\n+            result[len] = 0; \/* NULL-terminate *\/\n@@ -836,1 +828,0 @@\n-    }\n@@ -838,10 +829,1 @@\n-    if (!(*env)->ExceptionCheck(env)) {\n-        jint len = (*env)->GetArrayLength(env, hab);\n-        result = MALLOC_MIN4(len);\n-        if (result == 0) {\n-            JNU_ThrowOutOfMemoryError(env, 0);\n-            (*env)->DeleteLocalRef(env, hab);\n-            return 0;\n-        }\n-        (*env)->GetByteArrayRegion(env, hab, 0, len, (jbyte *)result);\n-        result[len] = 0; \/* NULL-terminate *\/\n+        (*env)->DeleteLocalRef(env, hab);\n@@ -849,2 +831,0 @@\n-\n-    (*env)->DeleteLocalRef(env, hab);\n","filename":"src\/java.base\/share\/native\/libjava\/jni_util.c","additions":36,"deletions":56,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-                            perm.getActions().indexOf(\"read\") != -1) {\n+                            perm.getActions().contains(\"read\")) {\n@@ -210,1 +210,1 @@\n-                            perm.getActions().indexOf(\"connect\") != -1) {\n+                            perm.getActions().contains(\"connect\")) {\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-                            perm.getActions().indexOf(\"read\") != -1) {\n+                            perm.getActions().contains(\"read\")) {\n@@ -233,1 +233,1 @@\n-                            perm.getActions().indexOf(\"connect\") != -1) {\n+                            perm.getActions().contains(\"connect\")) {\n","filename":"src\/java.base\/windows\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,7 @@\n- * attempt to create a new file.  For example, if an annotation\n+ * attempt to create a new file.\n+ * In other words, the originating elements are intended to have the\n+ * granularity of <em>compilation units<\/em> (JLS section {@jls 7.3}),\n+ * essentially file-level granularity, rather than finer-scale\n+ * granularity of, say, a method or field declaration.\n+ *\n+ * <p>For example, if an annotation\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/Filer.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -315,2 +315,2 @@\n-     * This pattern matches regular identifiers, keywords, restricted\n-     * keywords, restricted identifiers and the literals {@code \"true\"},\n+     * This pattern matches regular identifiers, keywords, contextual\n+     * keywords, and the literals {@code \"true\"},\n@@ -362,2 +362,2 @@\n-     * This method returns {@code true} for <i>restricted\n-     * keywords<\/i> and <i>restricted identifiers<\/i>.\n+     * This method returns {@code true} for <i>contextual\n+     * keywords<\/i>.\n@@ -388,2 +388,2 @@\n-     * This method returns {@code true} for <i>restricted\n-     * keywords<\/i> and <i>restricted identifiers<\/i>.\n+     * This method returns {@code true} for <i>contextual\n+     * keywords<\/i>.\n@@ -412,2 +412,2 @@\n-     * This method returns {@code false} for <i>restricted\n-     * keywords<\/i> and <i>restricted identifiers<\/i>.\n+     * This method returns {@code false} for <i>contextual\n+     * keywords<\/i>.\n@@ -429,2 +429,2 @@\n-     * This method returns {@code false} for <i>restricted\n-     * keywords<\/i> and <i>restricted identifiers<\/i>.\n+     * This method returns {@code false} for <i>contextual\n+     * keywords<\/i>.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,0 +134,6 @@\n+    \/**\n+     * {@return the class or interface defining the executable}\n+     *\/\n+    @Override\n+    Element getEnclosingElement();\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/ExecutableElement.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,13 +39,14 @@\n- * <p>When used in the context of annotation processing, an accurate\n- * model of the element being represented must be returned.  As this\n- * is a language model, the source code provides the fiducial\n- * (reference) representation of the construct in question rather than\n- * a representation in an executable output like a class file.\n- * Executable output may serve as the basis for creating a modeling\n- * element.  However, the process of translating source code to\n- * executable output may not permit recovering some aspects of the\n- * source code representation.  For example, annotations with\n- * {@linkplain java.lang.annotation.RetentionPolicy#SOURCE source}\n- * {@linkplain java.lang.annotation.Retention retention} cannot be\n- * recovered from class files and class files might not be able to\n- * provide source position information.\n+ * <p id=\"accurate_model\">When used in the context of annotation\n+ * processing, an accurate model of the element being represented must\n+ * be returned.  As this is a language model, the source code provides\n+ * the fiducial (reference) representation of the construct in\n+ * question rather than a representation in an executable output like\n+ * a class file.  Executable output may serve as the basis for\n+ * creating a modeling element.  However, the process of translating\n+ * source code to executable output may not permit recovering some\n+ * aspects of the source code representation.  For example,\n+ * annotations with {@linkplain\n+ * java.lang.annotation.RetentionPolicy#SOURCE source} {@linkplain\n+ * java.lang.annotation.Retention retention} cannot be recovered from\n+ * class files and class files might not be able to provide source\n+ * position information.\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/package-info.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-     * If this process leads to a list with a single element,\n-     * the single element is returned, otherwise null is returned.\n+     * If this process leads to a list with a single element, the\n+     * single element is returned, otherwise {@code null} is returned.\n@@ -158,2 +158,2 @@\n-     * If this process leads to a list with a single element,\n-     * the single element is returned, otherwise null is returned.\n+     * If this process leads to a list with a single element, the\n+     * single element is returned, otherwise {@code null} is returned.\n@@ -738,2 +738,3 @@\n-     * Returns the record component for the given accessor. Returns null if the\n-     * given method is not a record component accessor.\n+     * Returns the record component for the given accessor. Returns\n+     * {@code null} if the given method is not a record component\n+     * accessor.\n@@ -750,2 +751,2 @@\n-     * @return the record component, or null if the given method is not a record\n-     * component accessor\n+     * @return the record component, or {@code null} if the given\n+     * method is not a record component accessor\n@@ -764,0 +765,96 @@\n+\n+    \/**\n+     * {@return the file object for this element or {@code null} if\n+     * there is no such file object}\n+     *\n+     * <p>The returned file object is for the <a\n+     * href=\"..\/element\/package-summary.html#accurate_model\">reference\n+     * representation<\/a> of the information used to construct the\n+     * element. For example, if during compilation or annotation\n+     * processing, a source file for class {@code Foo} is compiled\n+     * into a class file, the file object returned for the element\n+     * representing {@code Foo} would be for the source file and\n+     * <em>not<\/em> for the class file.\n+     *\n+     * <p>An implementation may choose to not support the\n+     * functionality of this method, in which case {@link\n+     * UnsupportedOperationException} is thrown.\n+     *\n+     * <p>In the context of annotation processing, a non-{@code null}\n+     * value is returned if the element was included as part of the\n+     * initial inputs or the containing file was created during the\n+     * run of the annotation processing tool. Otherwise, a {@code\n+     * null} may be returned. In annotation processing, if a\n+     * {@linkplain javax.annotation.processing.Filer#createClassFile\n+     * class file is created}, that class file can serve as the\n+     * reference representation for elements.\n+     *\n+     * <p>If it has a file object, the file object for a package will\n+     * be a {@code package-info} file. A package may exist and not\n+     * have any {@code package-info} file even if the package is\n+     * (implicitly) created during an annotation processing run from\n+     * the creation of source or class files in that package.  An\n+     * {@linkplain PackageElement#isUnnamed unnamed package} will have\n+     * a {@code null} file since it cannot be declared in a\n+     * compilation unit.\n+     *\n+     * <p>If it has a file object, the file object for a module will\n+     * be a {@code module-info} file.  An {@linkplain\n+     * ModuleElement#isUnnamed unnamed module} will have a {@code\n+     * null} file since it cannot be declared in a compilation unit.\n+     * An {@linkplain #isAutomaticModule automatic module} will have a\n+     * {@code null} file since it is implicitly declared.\n+     *\n+     * <p>If it has a file object, the file object for a top-level\n+     * {@code public} class or interface will be a source or class\n+     * file corresponding to that class or interface. In this case,\n+     * typically the leading portion of the name of the file will\n+     * match the name of the class or interface. A single compilation\n+     * unit can define multiple top-level classes and interfaces, such\n+     * as a primary {@code public} class or interfaces whose name\n+     * corresponds to the file name and one or more <em>auxiliary<\/em>\n+     * classes or interfaces whose names do not correspond to the file\n+     * name. If a source file is providing the reference\n+     * representation of an auxiliary class or interface, the file for\n+     * the primary class is returned. (An auxiliary class or interface\n+     * can also be defined in a {@code package-info} source file, in\n+     * which case the file for the {@code package-info} file is\n+     * returned.)  If a class file is providing the reference\n+     * representation of an auxiliary class or interface, the separate\n+     * class file for the auxiliary class is returned.\n+     *\n+     * <p>For a nested class or interface, if it has a file object:\n+     *\n+     * <ul>\n+     *\n+     * <li>if a source file is providing the reference representation,\n+     * the file object will be that of the {@linkplain\n+     * #getOutermostTypeElement(Element) outermost enclosing} class or\n+     * interface\n+     *\n+     * <li>if a class file is providing the reference representation,\n+     * the file object will be that of the nested class or interface\n+     * itself\n+     *\n+     * <\/ul>\n+     *\n+     * <p>For other lexically enclosed elements, such as {@linkplain\n+     * VariableElement#getEnclosingElement() variables}, {@linkplain\n+     * ExecutableElement#getEnclosingElement() methods, and\n+     * constructors}, if they have a file object, the file object will\n+     * be the object associated with the {@linkplain\n+     * Element#getEnclosingElement() enclosing element} of the\n+     * lexically enclosed element.\n+     *\n+     * @implSpec The default implementation unconditionally throws\n+     * {@link UnsupportedOperationException}.\n+     *\n+     * @throws UnsupportedOperationException if this functionality is\n+     * not supported\n+     *\n+     * @param e the element to find a file object for\n+     * @since 18\n+     *\/\n+    default javax.tools.JavaFileObject getFileObjectOf(Element e) {\n+        throw new UnsupportedOperationException();\n+    }\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":105,"deletions":8,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -284,1 +284,1 @@\n-    class _PreferencesDispatcher extends _AppEventDispatcher<PreferencesHandler> {\n+    static class _PreferencesDispatcher extends _AppEventDispatcher<PreferencesHandler> {\n@@ -297,1 +297,1 @@\n-    class _OpenAppDispatcher extends _QueuingAppEventDispatcher<com.apple.eawt._OpenAppHandler> {\n+    static class _OpenAppDispatcher extends _QueuingAppEventDispatcher<com.apple.eawt._OpenAppHandler> {\n@@ -303,1 +303,1 @@\n-    class _AppReOpenedDispatcher extends _AppEventMultiplexor<AppReopenedListener> {\n+    static class _AppReOpenedDispatcher extends _AppEventMultiplexor<AppReopenedListener> {\n@@ -310,1 +310,1 @@\n-    class _AppForegroundDispatcher extends _BooleanAppEventMultiplexor<AppForegroundListener, AppForegroundEvent> {\n+    static class _AppForegroundDispatcher extends _BooleanAppEventMultiplexor<AppForegroundListener, AppForegroundEvent> {\n@@ -322,1 +322,1 @@\n-    class _HiddenAppDispatcher extends _BooleanAppEventMultiplexor<AppHiddenListener, AppHiddenEvent> {\n+    static class _HiddenAppDispatcher extends _BooleanAppEventMultiplexor<AppHiddenListener, AppHiddenEvent> {\n@@ -334,1 +334,1 @@\n-    class _UserSessionDispatcher extends _BooleanAppEventMultiplexor<UserSessionListener, UserSessionEvent> {\n+    static class _UserSessionDispatcher extends _BooleanAppEventMultiplexor<UserSessionListener, UserSessionEvent> {\n@@ -352,1 +352,1 @@\n-    class _ScreenSleepDispatcher extends _BooleanAppEventMultiplexor<ScreenSleepListener, ScreenSleepEvent> {\n+    static class _ScreenSleepDispatcher extends _BooleanAppEventMultiplexor<ScreenSleepListener, ScreenSleepEvent> {\n@@ -368,1 +368,1 @@\n-    class _SystemSleepDispatcher extends _BooleanAppEventMultiplexor<SystemSleepListener, SystemSleepEvent> {\n+    static class _SystemSleepDispatcher extends _BooleanAppEventMultiplexor<SystemSleepListener, SystemSleepEvent> {\n@@ -384,1 +384,1 @@\n-    class _OpenFileDispatcher extends _QueuingAppEventDispatcher<OpenFilesHandler> {\n+    static class _OpenFileDispatcher extends _QueuingAppEventDispatcher<OpenFilesHandler> {\n@@ -397,1 +397,1 @@\n-    class _PrintFileDispatcher extends _QueuingAppEventDispatcher<PrintFilesHandler> {\n+    static class _PrintFileDispatcher extends _QueuingAppEventDispatcher<PrintFilesHandler> {\n@@ -409,1 +409,1 @@\n-    class _OpenURIDispatcher extends _QueuingAppEventDispatcher<OpenURIHandler> {\n+    static class _OpenURIDispatcher extends _QueuingAppEventDispatcher<OpenURIHandler> {\n@@ -453,1 +453,1 @@\n-    abstract class _AppEventMultiplexor<L> {\n+    abstract static class _AppEventMultiplexor<L> {\n@@ -506,1 +506,1 @@\n-    abstract class _BooleanAppEventMultiplexor<L, E> extends _AppEventMultiplexor<L> {\n+    abstract static class _BooleanAppEventMultiplexor<L, E> extends _AppEventMultiplexor<L> {\n@@ -533,1 +533,1 @@\n-    abstract class _AppEventDispatcher<H> {\n+    abstract static class _AppEventDispatcher<H> {\n@@ -578,1 +578,1 @@\n-    abstract class _QueuingAppEventDispatcher<H> extends _AppEventDispatcher<H> {\n+    abstract static class _QueuingAppEventDispatcher<H> extends _AppEventDispatcher<H> {\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/eawt\/_AppEventHandler.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2448,1 +2448,1 @@\n-    class JTableExtension extends JTable {\n+    static class JTableExtension extends JTable {\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaFileChooserUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -281,1 +281,1 @@\n-    abstract class QuickSort {\n+    abstract static class QuickSort {\n@@ -341,1 +341,1 @@\n-    class QuickSortNames extends QuickSort {\n+    static class QuickSortNames extends QuickSort {\n@@ -349,1 +349,1 @@\n-    class QuickSortDates extends QuickSort {\n+    static class QuickSortDates extends QuickSort {\n@@ -356,1 +356,1 @@\n-    class SortableFile \/* extends FileView *\/{\n+    static class SortableFile \/* extends FileView *\/{\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaFileSystemModel.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,1 +190,1 @@\n-    class AquaDockingDesktopManager extends AquaInternalFrameManager {\n+    static class AquaDockingDesktopManager extends AquaInternalFrameManager {\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaInternalFramePaneUI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3264,1 +3264,1 @@\n-    private class ScrollableTabButton extends javax.swing.plaf.basic.BasicArrowButton implements UIResource, SwingConstants {\n+    private static class ScrollableTabButton extends javax.swing.plaf.basic.BasicArrowButton implements UIResource, SwingConstants {\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaTabbedPaneCopyFromBasicUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-    private class Tracer extends MTLRenderer {\n+    private static class Tracer extends MTLRenderer {\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLRenderer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,18 +167,12 @@\n-                    \/\/ At least for now don't handle combo box menu state changes.\n-                    \/\/ This may change when later fixing issues which currently\n-                    \/\/ exist for combo boxes, but for now the following is only\n-                    \/\/ for JPopupMenus, not for combobox menus.\n-                    if (parentRole != AccessibleRole.COMBO_BOX) {\n-                        if (thisRole == AccessibleRole.POPUP_MENU) {\n-                            if ( newValue != null &&\n-                                 ((AccessibleState)newValue) == AccessibleState.VISIBLE ) {\n-                                    menuOpened(ptr);\n-                            } else if ( oldValue != null &&\n-                                        ((AccessibleState)oldValue) == AccessibleState.VISIBLE ) {\n-                                menuClosed(ptr);\n-                            }\n-                        } else if (thisRole == AccessibleRole.MENU_ITEM) {\n-                            if ( newValue != null &&\n-                                 ((AccessibleState)newValue) == AccessibleState.FOCUSED ) {\n-                                menuItemSelected(ptr);\n-                            }\n+                    if (thisRole == AccessibleRole.POPUP_MENU) {\n+                        if ( newValue != null &&\n+                                ((AccessibleState)newValue) == AccessibleState.VISIBLE ) {\n+                            menuOpened(ptr);\n+                        } else if ( oldValue != null &&\n+                                ((AccessibleState)oldValue) == AccessibleState.VISIBLE ) {\n+                            menuClosed(ptr);\n+                        }\n+                    } else if (thisRole == AccessibleRole.MENU_ITEM) {\n+                        if ( newValue != null &&\n+                                ((AccessibleState)newValue) == AccessibleState.FOCUSED ) {\n+                            menuItemSelected(ptr);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CAccessible.java","additions":12,"deletions":18,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -429,2 +429,1 @@\n-    class OSXPlatformFont extends sun.awt.PlatformFont\n-    {\n+    static class OSXPlatformFont extends sun.awt.PlatformFont {\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/LWCToolkit.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1519,48 +1519,0 @@\n-\/*\n- * Class:     sun_lwawt_macosx_CAccessible\n- * Method:    menuOpened\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL Java_sun_lwawt_macosx_CAccessible_menuOpened\n-(JNIEnv *env, jclass jklass, jlong element)\n-{\n-JNI_COCOA_ENTER(env);\n-    [ThreadUtilities performOnMainThread:@selector(postMenuOpened)\n-                     on:(JavaComponentAccessibility *)jlong_to_ptr(element)\n-                     withObject:nil\n-                     waitUntilDone:NO];\n-JNI_COCOA_EXIT(env);\n-}\n-\n-\/*\n- * Class:     sun_lwawt_macosx_CAccessible\n- * Method:    menuClosed\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL Java_sun_lwawt_macosx_CAccessible_menuClosed\n-(JNIEnv *env, jclass jklass, jlong element)\n-{\n-JNI_COCOA_ENTER(env);\n-    [ThreadUtilities performOnMainThread:@selector(postMenuClosed)\n-                     on:(JavaComponentAccessibility *)jlong_to_ptr(element)\n-                     withObject:nil\n-                     waitUntilDone:NO];\n-JNI_COCOA_EXIT(env);\n-}\n-\n-\/*\n- * Class:     sun_lwawt_macosx_CAccessible\n- * Method:    menuItemSelected\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL Java_sun_lwawt_macosx_CAccessible_menuItemSelected\n-(JNIEnv *env, jclass jklass, jlong element)\n-{\n-JNI_COCOA_ENTER(env);\n-    [ThreadUtilities performOnMainThread:@selector(postMenuItemSelected)\n-                     on:(JavaComponentAccessibility *)jlong_to_ptr(element)\n-                     withObject:nil\n-                     waitUntilDone:NO];\n-JNI_COCOA_EXIT(env);\n-}\n-\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/JavaComponentAccessibility.m","additions":0,"deletions":48,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-    rolesMap = [[NSMutableDictionary alloc] initWithCapacity:46];\n+    rolesMap = [[NSMutableDictionary alloc] initWithCapacity:51];\n@@ -155,0 +155,5 @@\n+    [rolesMap setObject:@\"MenuBarAccessibility\" forKey:@\"menubar\"];\n+    [rolesMap setObject:@\"MenuAccessibility\" forKey:@\"menu\"];\n+    [rolesMap setObject:@\"MenuItemAccessibility\" forKey:@\"menuitem\"];\n+    [rolesMap setObject:@\"MenuAccessibility\" forKey:@\"popupmenu\"];\n+    [rolesMap setObject:@\"ProgressIndicatorAccessibility\" forKey:@\"progressbar\"];\n@@ -1256,0 +1261,48 @@\n+\n+\/*\n+ * Class:     sun_lwawt_macosx_CAccessible\n+ * Method:    menuOpened\n+ * Signature: (I)V\n+ *\/\n+JNIEXPORT void JNICALL Java_sun_lwawt_macosx_CAccessible_menuOpened\n+    (JNIEnv *env, jclass jklass, jlong element)\n+{\n+    JNI_COCOA_ENTER(env);\n+        [ThreadUtilities performOnMainThread:@selector(postMenuOpened)\n+                         on:(CommonComponentAccessibility *)jlong_to_ptr(element)\n+                         withObject:nil\n+                         waitUntilDone:NO];\n+    JNI_COCOA_EXIT(env);\n+}\n+\n+\/*\n+ * Class:     sun_lwawt_macosx_CAccessible\n+ * Method:    menuClosed\n+ * Signature: (I)V\n+ *\/\n+JNIEXPORT void JNICALL Java_sun_lwawt_macosx_CAccessible_menuClosed\n+    (JNIEnv *env, jclass jklass, jlong element)\n+{\n+    JNI_COCOA_ENTER(env);\n+        [ThreadUtilities performOnMainThread:@selector(postMenuClosed)\n+                         on:(CommonComponentAccessibility *)jlong_to_ptr(element)\n+                         withObject:nil\n+                         waitUntilDone:NO];\n+    JNI_COCOA_EXIT(env);\n+}\n+\n+\/*\n+ * Class:     sun_lwawt_macosx_CAccessible\n+ * Method:    menuItemSelected\n+ * Signature: (I)V\n+ *\/\n+JNIEXPORT void JNICALL Java_sun_lwawt_macosx_CAccessible_menuItemSelected\n+    (JNIEnv *env, jclass jklass, jlong element)\n+{\n+    JNI_COCOA_ENTER(env);\n+        [ThreadUtilities performOnMainThread:@selector(postMenuItemSelected)\n+                         on:(CommonComponentAccessibility *)jlong_to_ptr(element)\n+                         withObject:nil\n+                         waitUntilDone:NO];\n+    JNI_COCOA_EXIT(env);\n+}\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/CommonComponentAccessibility.m","additions":54,"deletions":1,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"CommonComponentAccessibility.h\"\n+#import \"GroupAccessibility.h\"\n+\n+#import <AppKit\/AppKit.h>\n+\n+@interface MenuAccessibility : GroupAccessibility {\n+\n+};\n+- (NSAccessibilityRole _Nonnull)accessibilityRole;\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/MenuAccessibility.h","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"MenuAccessibility.h\"\n+\n+\/*\n+ * Implementing a protocol that represents menus both as submenu and as a\n+ * MenuBar components\n+ *\/\n+@implementation MenuAccessibility\n+- (NSAccessibilityRole _Nonnull)accessibilityRole\n+{\n+        return [[[self parent] javaRole] isEqualToString:@\"combobox\"]\n+               ? NSAccessibilityPopUpButtonRole\n+               : NSAccessibilityMenuRole;\n+}\n+\n+- (BOOL)isAccessibilityElement\n+{\n+    return YES;\n+}\n+\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/MenuAccessibility.m","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"CommonComponentAccessibility.h\"\n+\n+#import <AppKit\/AppKit.h>\n+\n+@interface MenuBarAccessibility : CommonComponentAccessibility {\n+\n+};\n+- (NSAccessibilityRole _Nonnull)accessibilityRole;\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/MenuBarAccessibility.h","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"MenuBarAccessibility.h\"\n+#import \"JNIUtilities.h\"\n+#import \"ThreadUtilities.h\"\n+#import \"sun_lwawt_macosx_CAccessibility.h\"\n+\n+\/*\n+ * This is the protocol for the Menu Bar component\n+ *\/\n+@implementation MenuBarAccessibility\n+- (NSAccessibilityRole _Nonnull)accessibilityRole\n+{\n+    return NSAccessibilityMenuBarRole;\n+}\n+\n+- (BOOL)isAccessibilityElement\n+{\n+    return YES;\n+}\n+\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/MenuBarAccessibility.m","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"CommonComponentAccessibility.h\"\n+#import \"ButtonAccessibility.h\"\n+\n+#import <AppKit\/AppKit.h>\n+\n+@interface MenuItemAccessibility : ButtonAccessibility {\n+\n+};\n+- (NSAccessibilityRole _Nonnull)accessibilityRole;\n+- (void)handleAction:(NSMenuItem * _Nonnull)sender;\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/MenuItemAccessibility.h","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"MenuItemAccessibility.h\"\n+\n+\/*\n+ * This is the protocol for the MenuItem component.\n+ *\/\n+@implementation MenuItemAccessibility\n+- (NSAccessibilityRole _Nonnull)accessibilityRole\n+{\n+    return NSAccessibilityMenuItemRole;\n+}\n+\n+- (BOOL)isAccessibilityElement\n+{\n+    return YES;\n+}\n+\n+- (BOOL)accessibilityPerformPick\n+{\n+    return [self performAccessibleAction:0];\n+}\n+\n+- (BOOL)accessibilityPerformPress\n+{\n+    return [self performAccessibleAction:0];\n+}\n+\n+- (NSString * _Nullable)accessibilityLabel\n+{\n+    return [super accessibilityLabel];\n+}\n+\n+- (id _Nullable)accessibilityValue\n+{\n+    return [super accessibilityValue];\n+}\n+\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/MenuItemAccessibility.m","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"JavaComponentAccessibility.h\"\n+#import \"GroupAccessibility.h\"\n+\n+#import <AppKit\/AppKit.h>\n+\n+@interface ProgressIndicatorAccessibility : GroupAccessibility {\n+\n+};\n+- (NSAccessibilityRole _Nonnull)accessibilityRole;\n+- (NSString * _Nullable)accessibilityValue;\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/ProgressIndicatorAccessibility.h","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"ProgressIndicatorAccessibility.h\"\n+\n+\/*\n+ * Implementation of the accessibility peer for the NSProgressIndicator role.\n+ * Main usage is JProgressBar\n+ *\/\n+@implementation ProgressIndicatorAccessibility\n+\n+- (NSAccessibilityRole _Nonnull)accessibilityRole\n+{\n+    return NSAccessibilityProgressIndicatorRole;\n+}\n+\n+- (NSString * _Nullable)accessibilityValue\n+{\n+    return [super accessibilityValue];\n+}\n+\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/ProgressIndicatorAccessibility.m","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -141,1 +141,1 @@\n-    class Htable implements Cloneable {\n+    static class Htable implements Cloneable {\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/DHTMarkerSegment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-    class Qtable implements Cloneable {\n+    static class Qtable implements Cloneable {\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/DQTMarkerSegment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -555,1 +555,1 @@\n-    private class IllegalThumbException extends Exception {}\n+    private static class IllegalThumbException extends Exception {}\n@@ -797,1 +797,1 @@\n-    abstract class JFIFThumb implements Cloneable {\n+    abstract static class JFIFThumb implements Cloneable {\n@@ -1114,1 +1114,1 @@\n-    class JFIFThumbJPEG extends JFIFThumb {\n+    static class JFIFThumbJPEG extends JFIFThumb {\n@@ -1237,1 +1237,1 @@\n-        private class ThumbnailReadListener\n+        private static class ThumbnailReadListener\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/JFIFMarkerSegment.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -202,1 +202,1 @@\n-    class ComponentSpec implements Cloneable {\n+    static class ComponentSpec implements Cloneable {\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/SOFMarkerSegment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-\/\/import javax.imageio.IIOException;\n@@ -184,1 +183,1 @@\n-    class ScanComponentSpec implements Cloneable {\n+    static class ScanComponentSpec implements Cloneable {\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/SOSMarkerSegment.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1301,1 +1301,1 @@\n-    private class OpaqueLabel extends JLabel {\n+    private static class OpaqueLabel extends JLabel {\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKColorChooserPanel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-    private class DragPane extends JComponent {\n+    private static class DragPane extends JComponent {\n@@ -88,1 +88,1 @@\n-    private class MotifDesktopManager extends DefaultDesktopManager implements Serializable, UIResource {\n+    private static class MotifDesktopManager extends DefaultDesktopManager implements Serializable, UIResource {\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifDesktopPaneUI.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -353,1 +353,1 @@\n-    private class EventInfo {\n+    private static class EventInfo {\n@@ -386,1 +386,1 @@\n-    private class ClipInfo {\n+    private static class ClipInfo {\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/EventDispatcher.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1027,1 +1027,1 @@\n-    private class ControllerListElement {\n+    private static class ControllerListElement {\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/RealTimeSequencer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,2 +51,1 @@\n-    private class SoftChannelMixerContainer\n-    {\n+    private static class SoftChannelMixerContainer {\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SoftMainMixer.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,1 @@\n-    final class NoCloseInputStream extends InputStream {\n+    static final class NoCloseInputStream extends InputStream {\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SunFileWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-    class Card implements Serializable {\n+    static class Card implements Serializable {\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/CardLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3934,1 +3934,1 @@\n-    private class ProxyCapabilities extends ExtendedBufferCapabilities {\n+    private static class ProxyCapabilities extends ExtendedBufferCapabilities {\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Component.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -578,1 +578,1 @@\n-    class PolygonPathIterator implements PathIterator {\n+    static class PolygonPathIterator implements PathIterator {\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Polygon.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -743,2 +743,1 @@\n-    class PeerFixer implements AdjustmentListener, java.io.Serializable\n-    {\n+    static class PeerFixer implements AdjustmentListener, java.io.Serializable {\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/ScrollPane.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2093,1 +2093,1 @@\n-    private class SelectiveAWTEventListener implements AWTEventListener {\n+    private static class SelectiveAWTEventListener implements AWTEventListener {\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Toolkit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -177,1 +177,1 @@\n-    private class BookPage {\n+    private static class BookPage {\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/print\/Book.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -221,1 +221,1 @@\n-    private class ValueData {\n+    private static class ValueData {\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/XMLEncoder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.util.Collection;\n@@ -31,1 +30,0 @@\n-import java.util.Iterator;\n@@ -95,1 +93,1 @@\n-    class Element {\n+    static class Element {\n@@ -116,1 +114,1 @@\n-    class Attribute {\n+    static class Attribute {\n@@ -136,1 +134,1 @@\n-    class ObjectValue<T> {\n+    static class ObjectValue<T> {\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/metadata\/IIOMetadataFormatImpl.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-    private class PrinterStateReasonSet\n+    private static class PrinterStateReasonSet\n@@ -257,1 +257,1 @@\n-    private class PrinterStateReasonSetIterator implements Iterator<PrinterStateReason> {\n+    private static class PrinterStateReasonSetIterator implements Iterator<PrinterStateReason> {\n","filename":"src\/java.desktop\/share\/classes\/javax\/print\/attribute\/standard\/PrinterStateReasons.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -477,1 +477,1 @@\n-    private class TargetDataLineInputStream extends InputStream {\n+    private static class TargetDataLineInputStream extends InputStream {\n","filename":"src\/java.desktop\/share\/classes\/javax\/sound\/sampled\/AudioInputStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1270,1 +1270,1 @@\n-    private abstract class Spring {\n+    private abstract static class Spring {\n@@ -3170,1 +3170,1 @@\n-    private class GapSpring extends Spring {\n+    private static class GapSpring extends Spring {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/GroupLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1558,1 +1558,1 @@\n-    class DefaultKeySelectionManager implements KeySelectionManager, Serializable {\n+    static class DefaultKeySelectionManager implements KeySelectionManager, Serializable {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JComboBox.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3451,1 +3451,1 @@\n-    final class ActionStandin implements Action {\n+    static final class ActionStandin implements Action {\n@@ -5504,2 +5504,1 @@\n-    private class ReadObjectCallback implements ObjectInputValidation\n-    {\n+    private static class ReadObjectCallback implements ObjectInputValidation {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JComponent.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -6582,1 +6582,1 @@\n-    private class ThreadSafePrintable implements Printable {\n+    private static class ThreadSafePrintable implements Printable {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-import java.beans.*;\n-import javax.swing.event.*;\n@@ -374,1 +372,1 @@\n-    class ComponentKeyStrokePair {\n+    static class ComponentKeyStrokePair {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/KeyboardManager.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1815,1 +1815,1 @@\n-    private class DoubleBufferInfo {\n+    private static class DoubleBufferInfo {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/RepaintManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import java.awt.Component;\n+import java.awt.Container;\n@@ -36,0 +38,1 @@\n+import java.awt.FocusTraversalPolicy;\n@@ -38,1 +41,1 @@\n-import java.awt.*;\n+import java.awt.Point;\n@@ -350,1 +353,1 @@\n-    private class BasicDesktopManager extends DefaultDesktopManager\n+    private static class BasicDesktopManager extends DefaultDesktopManager\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicDesktopPaneUI.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,0 @@\n-import sun.swing.SwingUtilities2;\n@@ -1207,1 +1206,1 @@\n-    class GlobFilter extends FileFilter {\n+    static class GlobFilter extends FileFilter {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicFileChooserUI.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -971,1 +971,1 @@\n-    private class NoFocusButton extends JButton {\n+    private static class NoFocusButton extends JButton {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicInternalFrameTitlePane.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import javax.swing.plaf.basic.*;\n-import javax.swing.border.*;\n@@ -37,2 +35,0 @@\n-import java.awt.Container;\n-import java.awt.Dimension;\n@@ -45,3 +41,0 @@\n-import java.beans.PropertyChangeListener;\n-import java.beans.PropertyChangeEvent;\n-\n@@ -50,1 +43,0 @@\n-import sun.swing.DefaultLookup;\n@@ -297,1 +289,1 @@\n-    private class BasicPopupMenuListener implements PopupMenuListener {\n+    private static class BasicPopupMenuListener implements PopupMenuListener {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicPopupMenuUI.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -3948,2 +3948,2 @@\n-    private class ScrollableTabButton extends BasicArrowButton implements UIResource,\n-                                                                            SwingConstants {\n+    private static class ScrollableTabButton extends BasicArrowButton\n+            implements UIResource, SwingConstants {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTabbedPaneUI.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.io.Serializable;\n@@ -32,1 +31,0 @@\n-import java.awt.event.*;\n@@ -92,1 +90,1 @@\n-    class EditorBorder extends AbstractBorder {\n+    static class EditorBorder extends AbstractBorder {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalComboBoxEditor.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -961,1 +959,1 @@\n-    class IndentIcon implements Icon {\n+    static class IndentIcon implements Icon {\n@@ -1364,1 +1362,1 @@\n-    private class AlignedLabel extends JLabel {\n+    private static class AlignedLabel extends JLabel {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalFileChooserUI.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1624,1 +1624,1 @@\n-        class ImageGcPair {\n+        static class ImageGcPair {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalIconFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -498,1 +498,1 @@\n-    private class LinkProperty implements UIDefaults.ActiveValue, UIResource{\n+    private static class LinkProperty implements UIDefaults.ActiveValue, UIResource{\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/nimbus\/NimbusLookAndFeel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1022,1 +1022,1 @@\n-    private final class RuntimeState implements Cloneable {\n+    private static final class RuntimeState implements Cloneable {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/nimbus\/NimbusStyle.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -936,1 +936,1 @@\n-    private class SynthScrollableTabButton extends SynthArrowButton implements\n+    private static class SynthScrollableTabButton extends SynthArrowButton implements\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthTabbedPaneUI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -716,1 +716,1 @@\n-    private class SynthBooleanTableCellRenderer extends JCheckBox implements\n+    private static class SynthBooleanTableCellRenderer extends JCheckBox implements\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthTableUI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -512,1 +512,1 @@\n-    class HighlightInfo implements Highlighter.Highlight {\n+    static class HighlightInfo implements Highlighter.Highlight {\n@@ -536,1 +536,1 @@\n-    class LayeredHighlightInfo extends HighlightInfo {\n+    static class LayeredHighlightInfo extends HighlightInfo {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/DefaultHighlighter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-    private class StackItem implements Cloneable {\n+    private static class StackItem implements Cloneable {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/ElementIterator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,3 +55,0 @@\n-import java.awt.print.Printable;\n-import java.awt.print.PrinterException;\n-\n@@ -59,1 +56,0 @@\n-import javax.print.attribute.PrintRequestAttributeSet;\n@@ -5112,1 +5108,1 @@\n-    private class DoSetCaretPosition implements Runnable {\n+    private static class DoSetCaretPosition implements Runnable {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/JTextComponent.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import javax.swing.SwingUtilities;\n@@ -327,1 +326,1 @@\n-    final class PosRec {\n+    static final class PosRec {\n@@ -372,1 +371,1 @@\n-    final class UndoPosRef {\n+    static final class UndoPosRef {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/StringContent.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1058,1 +1058,1 @@\n-    class KeyEnumeration implements Enumeration<Object> {\n+    static class KeyEnumeration implements Enumeration<Object> {\n@@ -1100,1 +1100,1 @@\n-    class KeyBuilder {\n+    static class KeyBuilder {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/StyleContext.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1059,1 +1059,1 @@\n-    private class ImageLabelView extends InlineView {\n+    private static class ImageLabelView extends InlineView {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/ImageView.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1694,1 +1694,1 @@\n-    class CellView extends BlockView {\n+    static class CellView extends BlockView {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/TableView.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -672,2 +672,1 @@\n-class DiscardingDestination implements Destination\n-{\n+static class DiscardingDestination implements Destination {\n@@ -1074,1 +1073,1 @@\n-class InfoDestination\n+static class InfoDestination\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/rtf\/RTFReader.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1333,1 +1333,1 @@\n-    private final class PreorderEnumeration implements Enumeration<TreeNode> {\n+    private static final class PreorderEnumeration implements Enumeration<TreeNode> {\n@@ -1365,1 +1365,1 @@\n-    final class PostorderEnumeration implements Enumeration<TreeNode> {\n+    static final class PostorderEnumeration implements Enumeration<TreeNode> {\n@@ -1401,1 +1401,1 @@\n-    final class BreadthFirstEnumeration implements Enumeration<TreeNode> {\n+    static final class BreadthFirstEnumeration implements Enumeration<TreeNode> {\n@@ -1433,1 +1433,1 @@\n-        final class Queue {\n+        static final class Queue {\n@@ -1437,1 +1437,1 @@\n-            final class QNode {\n+            static final class QNode {\n@@ -1489,1 +1489,1 @@\n-    final class PathBetweenNodesEnumeration implements Enumeration<TreeNode> {\n+    static final class PathBetweenNodesEnumeration implements Enumeration<TreeNode> {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/tree\/DefaultMutableTreeNode.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -431,2 +431,1 @@\n-    class PlatformFontCache\n-    {\n+    static class PlatformFontCache {\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/PlatformFont.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-    final class Entry {\n+    static final class Entry {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/loops\/RenderCache.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,1 @@\n-    private class Tracer extends OGLRenderer {\n+    private static class Tracer extends OGLRenderer {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/opengl\/OGLRenderer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2002, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    class TileContext {\n+    static class TileContext {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/GeneralCompositePipe.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-    class SCRcontext {\n+    static class SCRcontext {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/SpanClipRenderer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-import javax.print.attribute.ResolutionSyntax;\n@@ -67,1 +66,0 @@\n-import javax.print.attribute.standard.PrinterResolution;\n@@ -75,2 +73,0 @@\n-import sun.print.SunPageSelection;\n-import sun.print.SunMinMaxPage;\n@@ -1036,1 +1032,1 @@\n-    private class MessageQ {\n+    private static class MessageQ {\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/PrintJob2D.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import java.awt.Dialog;\n-import java.awt.Frame;\n@@ -307,1 +305,1 @@\n-    private class GraphicsState {\n+    private static class GraphicsState {\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/RasterPrinterJob.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.awt.Color;\n@@ -38,1 +37,0 @@\n-import java.awt.GridLayout;\n@@ -40,1 +38,0 @@\n-import java.awt.Toolkit;\n@@ -64,1 +61,0 @@\n-import javax.swing.border.Border;\n@@ -66,1 +62,0 @@\n-import javax.swing.border.TitledBorder;\n@@ -69,2 +64,0 @@\n-import javax.swing.event.DocumentEvent;\n-import javax.swing.event.DocumentListener;\n@@ -2838,1 +2831,1 @@\n-    private class IconRadioButton extends JPanel {\n+    private static class IconRadioButton extends JPanel {\n@@ -2892,1 +2885,1 @@\n-    private class ValidatingFileChooser extends JFileChooser {\n+    private static class ValidatingFileChooser extends JFileChooser {\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/ServiceDialog.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -410,1 +410,1 @@\n-    class GlobFilter extends FileFilter {\n+    static class GlobFilter extends FileFilter {\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/plaf\/synth\/SynthFileChooserUI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -700,1 +698,1 @@\n-    class IndentIcon implements Icon {\n+    static class IndentIcon implements Icon {\n@@ -1071,1 +1069,1 @@\n-    private class AlignedLabel extends JLabel {\n+    private static class AlignedLabel extends JLabel {\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/plaf\/synth\/SynthFileChooserUIImpl.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -192,1 +192,1 @@\n-    private class EmptyIcon implements Icon, Serializable {\n+    private static class EmptyIcon implements Icon, Serializable {\n","filename":"src\/java.desktop\/share\/classes\/sun\/swing\/table\/DefaultTableCellHeaderRenderer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.awt.peer.ComponentPeer;\n@@ -529,1 +528,1 @@\n-    final class AWTTextAreaUI extends MotifTextAreaUI {\n+    static final class AWTTextAreaUI extends MotifTextAreaUI {\n@@ -636,1 +635,1 @@\n-    final class XAWTScrollBarButton extends BasicArrowButton {\n+    static final class XAWTScrollBarButton extends BasicArrowButton {\n@@ -807,1 +806,1 @@\n-    final class XAWTScrollBarUI extends BasicScrollBarUI {\n+    static final class XAWTScrollBarUI extends BasicScrollBarUI {\n@@ -897,1 +896,1 @@\n-    final class AWTTextArea extends JTextArea implements DocumentListener {\n+    static final class AWTTextArea extends JTextArea implements DocumentListener {\n@@ -986,1 +985,1 @@\n-    final class XAWTScrollPaneUI extends BasicScrollPaneUI {\n+    static final class XAWTScrollPaneUI extends BasicScrollPaneUI {\n@@ -1096,1 +1095,1 @@\n-    private class AWTTextPane extends JScrollPane implements FocusListener {\n+    private static class AWTTextPane extends JScrollPane implements FocusListener {\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XTextAreaPeer.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,0 @@\n-import java.awt.event.ActionEvent;\n-import java.awt.event.ActionListener;\n-import java.awt.event.TextEvent;\n@@ -43,4 +40,0 @@\n-import java.awt.event.MouseEvent;\n-import java.awt.event.FocusEvent;\n-import java.awt.event.KeyEvent;\n-\n@@ -448,1 +441,1 @@\n-    final class AWTTextFieldUI extends MotifPasswordFieldUI {\n+    static final class AWTTextFieldUI extends MotifPasswordFieldUI {\n@@ -544,1 +537,1 @@\n-    final class XAWTTextField extends JPasswordField\n+    static final class XAWTTextField extends JPasswordField\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XTextFieldPeer.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    private class Encoder extends CharsetEncoder {\n+    private static class Encoder extends CharsetEncoder {\n@@ -101,1 +101,1 @@\n-    private class Decoder extends  CharsetDecoder {\n+    private static class Decoder extends  CharsetDecoder {\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/X11GB2312.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    private class Encoder extends DoubleByte.Encoder {\n+    private static class Encoder extends DoubleByte.Encoder {\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/X11GBK.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    private class Encoder extends CharsetEncoder {\n+    private static class Encoder extends CharsetEncoder {\n@@ -100,1 +100,1 @@\n-    private class Decoder extends  CharsetDecoder {\n+    private static class Decoder extends  CharsetDecoder {\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/X11KSC5601.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -835,1 +835,1 @@\n-    private class ExtFinishing extends Finishings {\n+    private static class ExtFinishing extends Finishings {\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/IPPPrintService.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -596,1 +596,1 @@\n-        private class WindowsComboBoxDashedBorder extends DashedBorder {\n+        private static class WindowsComboBoxDashedBorder extends DashedBorder {\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsComboBoxUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1057,1 +1057,1 @@\n-    class IndentIcon implements Icon {\n+    static class IndentIcon implements Icon {\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsFileChooserUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2116,1 +2116,1 @@\n-    private class ActiveWindowsIcon implements UIDefaults.ActiveValue {\n+    private static class ActiveWindowsIcon implements UIDefaults.ActiveValue {\n@@ -2422,1 +2422,1 @@\n-    private class TriggerDesktopProperty extends WindowsDesktopProperty {\n+    private static class TriggerDesktopProperty extends WindowsDesktopProperty {\n@@ -2439,1 +2439,1 @@\n-    private class FontDesktopProperty extends TriggerDesktopProperty {\n+    private static class FontDesktopProperty extends TriggerDesktopProperty {\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsLookAndFeel.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -304,1 +304,1 @@\n-    private class XPFillBorder extends LineBorder implements UIResource {\n+    private static class XPFillBorder extends LineBorder implements UIResource {\n@@ -401,1 +401,1 @@\n-    private class XPEmptyBorder extends EmptyBorder implements UIResource {\n+    private static class XPEmptyBorder extends EmptyBorder implements UIResource {\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/XPStyle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2300,1 +2300,1 @@\n-class PrintToFileErrorDialog extends Dialog implements ActionListener{\n+static class PrintToFileErrorDialog extends Dialog implements ActionListener {\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WPrinterJob.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -165,1 +165,1 @@\n-    class ScrollEvent extends PeerEvent {\n+    static class ScrollEvent extends PeerEvent {\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WScrollPanePeer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-import sun.java2d.pipe.BufferedPaints;\n@@ -111,1 +110,1 @@\n-    private class Tracer extends D3DRenderer {\n+    private static class Tracer extends D3DRenderer {\n","filename":"src\/java.desktop\/windows\/classes\/sun\/java2d\/d3d\/D3DRenderer.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+#include \"math.h\"\n@@ -2237,2 +2238,2 @@\n-    DWORD i;\n-    for (i = 0; i < rgndata->rdh.nCount; i++, r++) {\n+        DWORD i;\n+        for (i = 0; i < rgndata->rdh.nCount; i++, r++) {\n@@ -2250,0 +2251,9 @@\n+        \/\/ The Windows may request to update the small region of pixels that\n+        \/\/ cannot be represented in the user's space, in this case, we will\n+        \/\/ request to repaint the smallest non-empty bounding box in the user's\n+        \/\/ space\n+        int screen = GetScreenImOn();\n+        Devices::InstanceAccess devices;\n+        AwtWin32GraphicsDevice* device = devices->GetDevice(screen);\n+        float scaleX = (device == NULL) ? 1 : device->GetScaleX();\n+        float scaleY = (device == NULL) ? 1 : device->GetScaleY();\n@@ -2252,5 +2262,5 @@\n-                DoCallback(\"handleExpose\", \"(IIII)V\",\n-                           ScaleDownX(un[i]->left),\n-                           ScaleDownY(un[i]->top),\n-                           ScaleDownX(un[i]->right - un[i]->left),\n-                           ScaleDownY(un[i]->bottom - un[i]->top));\n+                int x1 = floor(un[i]->left \/ scaleX);\n+                int y1 = floor(un[i]->top \/ scaleY);\n+                int x2 = ceil(un[i]->right \/ scaleX);\n+                int y2 = ceil(un[i]->bottom  \/ scaleY);\n+                DoCallback(\"handleExpose\", \"(IIII)V\", x1, y1, x2 - x1, y2 - y1);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Component.cpp","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -259,0 +259,13 @@\n+        \/**\n+         * Sets the request method of this builder to HEAD.\n+         *\n+         * @implSpec The default implementation is expected to have the same behaviour as:\n+         * {@code return method(\"HEAD\", BodyPublishers.noBody());}\n+         *\n+         * @return this builder\n+         * @since 18\n+         *\/\n+        default Builder HEAD() {\n+            return method(\"HEAD\", BodyPublishers.noBody());\n+        }\n+\n@@ -363,1 +376,1 @@\n-                \/\/ otherwise, the body is absent, special case for GET\/DELETE,\n+                \/\/ otherwise, the body is absent, special case for GET\/DELETE\/HEAD,\n@@ -369,0 +382,1 @@\n+                        case \"HEAD\" -> builder.HEAD();\n","filename":"src\/java.net.http\/share\/classes\/java\/net\/http\/HttpRequest.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -112,1 +112,2 @@\n-        systemHeaders = HttpHeaders.of(systemHeaders.map(), (k,v) -> uh.firstValue(k).isEmpty());\n+        final HttpHeaders sh = HttpHeaders.of(systemHeaders.map(),\n+                (k,v) -> uh.firstValue(k).isEmpty());\n@@ -118,1 +119,1 @@\n-        collectHeaders1(sb, systemHeaders, nocookies);\n+        collectHeaders1(sb, sh, nocookies);\n@@ -123,1 +124,1 @@\n-        collectHeaders1(sb, userHeaders, nocookies);\n+        collectHeaders1(sb, uh, nocookies);\n@@ -125,2 +126,2 @@\n-        \/\/ Gather all 'Cookie:' headers and concatenate their\n-        \/\/ values in a single line.\n+        \/\/ Gather all 'Cookie:' headers from the unfiltered system headers,\n+        \/\/ and the user headers, and concatenate their values in a single line\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Request.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -185,0 +185,5 @@\n+    @Override\n+    public HttpRequest.Builder HEAD() {\n+        return method0(\"HEAD\", null);\n+    }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpRequestBuilderImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+    private static final String COOKIE_HEADER = \"Cookie\";\n@@ -248,1 +249,1 @@\n-                Log.logError(\"Subscriber::onError threw exception: {0}\", (Object) t);\n+                Log.logError(\"Subscriber::onError threw exception: {0}\", t);\n@@ -331,4 +332,1 @@\n-        StringBuilder sb = new StringBuilder();\n-        sb.append(\"streamid: \")\n-                .append(streamid);\n-        return sb.toString();\n+        return \"streamid: \" + streamid;\n@@ -401,1 +399,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -458,1 +455,1 @@\n-            default -> throw new IOException(\"Unexpected frame: \" + frame.toString());\n+            default -> throw new IOException(\"Unexpected frame: \" + frame);\n@@ -655,0 +652,1 @@\n+        \/\/ Don't override Cookie values that have been set by the CookieHandler.\n@@ -656,0 +654,3 @@\n+        BiPredicate<String, String> overrides =\n+                (k, v) -> COOKIE_HEADER.equalsIgnoreCase(k)\n+                          || uh.firstValue(k).isEmpty();\n@@ -658,1 +659,3 @@\n-        sysh = HttpHeaders.of(sysh.map(), (k,v) -> uh.firstValue(k).isEmpty());\n+        \/\/   except for \"Cookie:\" - user cookies will be appended to system\n+        \/\/   cookies\n+        sysh = HttpHeaders.of(sysh.map(), overrides);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -697,4 +697,2 @@\n-                Error error = new LinkageError(\n-                    \"provider class not assignable to RMIClassLoaderSpi\");\n-                error.initCause(e);\n-                throw error;\n+                throw new LinkageError(\n+                    \"provider class not assignable to RMIClassLoaderSpi\", e);\n@@ -714,4 +712,2 @@\n-                Error error = new LinkageError(\n-                    \"provider class not assignable to RMIClassLoaderSpi\");\n-                error.initCause(e);\n-                throw error;\n+                throw new LinkageError(\n+                    \"provider class not assignable to RMIClassLoaderSpi\", e);\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/server\/RMIClassLoader.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -224,2 +224,1 @@\n-                    throw (IllegalArgumentException)\n-                        new IllegalArgumentException().initCause(nsme);\n+                    throw new IllegalArgumentException(nsme);\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/server\/RemoteObjectInvocationHandler.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -136,2 +136,1 @@\n-                throw (IOException)\n-                    new IOException(e.getMessage()).initCause(e);\n+                throw new IOException(e.getMessage(), e);\n@@ -154,2 +153,1 @@\n-                throw (IOException)\n-                    new IOException(e.getMessage()).initCause(e);\n+                throw new IOException(e.getMessage(), e);\n","filename":"src\/java.rmi\/share\/classes\/javax\/rmi\/ssl\/SslRMIClientSocketFactory.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -188,2 +188,1 @@\n-                throw (IllegalArgumentException)\n-                new IllegalArgumentException(msg).initCause(e);\n+                throw new IllegalArgumentException(msg, e);\n","filename":"src\/java.rmi\/share\/classes\/javax\/rmi\/ssl\/SslRMIServerSocketFactory.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -288,2 +288,1 @@\n-            throw (IOException)\n-                new IOException(\"write update failed\").initCause(e);\n+            throw new IOException(\"write update failed\", e);\n@@ -550,2 +549,1 @@\n-            throw (IOException) new IOException(\n-                \"unable to construct LogFile instance\").initCause(e);\n+            throw new IOException(\"unable to construct LogFile instance\", e);\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/log\/ReliableLog.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5101,0 +5101,8 @@\n+    @Override\n+    public void visitModifiers(JCModifiers tree) {\n+        \/\/error recovery only:\n+        Assert.check(resultInfo.pkind == KindSelector.ERR);\n+\n+        attribAnnotationTypes(tree.annotations, env);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -379,1 +379,1 @@\n-                c.sourcefile = tree.sourcefile;\n+                c.classfile = c.sourcefile = tree.sourcefile;\n@@ -498,1 +498,1 @@\n-        c.sourcefile = env.toplevel.sourcefile;\n+        c.classfile = c.sourcefile = env.toplevel.sourcefile;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+    private final boolean optimizeOuterThis;\n@@ -122,0 +123,3 @@\n+        optimizeOuterThis =\n+            target.optimizeOuterThis() ||\n+            options.getBoolean(\"optimizeOuterThis\", false);\n@@ -1483,0 +1487,4 @@\n+        \/\/ Set NOOUTERTHIS for all synthetic outer instance variables, and unset\n+        \/\/ it when the variable is accessed. If the variable is never accessed,\n+        \/\/ we skip creating an outer instance field and saving the constructor\n+        \/\/ parameter to it.\n@@ -1484,1 +1492,1 @@\n-            new VarSymbol(flags, outerThisName(target, owner), target, owner);\n+            new VarSymbol(flags | NOOUTERTHIS, outerThisName(target, owner), target, owner);\n@@ -1731,0 +1739,1 @@\n+        ot.flags_field &= ~NOOUTERTHIS;\n@@ -1748,0 +1757,1 @@\n+            ot.flags_field &= ~NOOUTERTHIS;\n@@ -1787,0 +1797,1 @@\n+        ot.flags_field &= ~NOOUTERTHIS;\n@@ -1799,0 +1810,1 @@\n+            ot.flags_field &= ~NOOUTERTHIS;\n@@ -1820,2 +1832,1 @@\n-    JCStatement initOuterThis(int pos) {\n-        VarSymbol rhs = outerThisStack.head;\n+    JCStatement initOuterThis(int pos, VarSymbol rhs) {\n@@ -1823,1 +1834,1 @@\n-        VarSymbol lhs = outerThisStack.tail.head;\n+        VarSymbol lhs = outerThisStack.head;\n@@ -2227,1 +2238,1 @@\n-        \/\/ Add this$n and free variables proxy definitions to class.\n+        \/\/ Add free variables proxy definitions to class.\n@@ -2233,1 +2244,3 @@\n-        if (currentClass.hasOuterInstance()) {\n+        \/\/ If this$n was accessed, add the field definition and\n+        \/\/ update initial constructors to initialize it\n+        if (currentClass.hasOuterInstance() && shouldEmitOuterThis(currentClass)) {\n@@ -2236,0 +2249,8 @@\n+\n+           for (JCTree def : tree.defs) {\n+                if (TreeInfo.isInitialConstructor(def)) {\n+                  JCMethodDecl mdef = (JCMethodDecl) def;\n+                  mdef.body.stats = mdef.body.stats.prepend(\n+                      initOuterThis(mdef.body.pos, mdef.params.head.sym));\n+                }\n+            }\n@@ -2252,0 +2273,33 @@\n+    private boolean shouldEmitOuterThis(ClassSymbol sym) {\n+      if (!optimizeOuterThis) {\n+        \/\/ Optimization is disabled\n+        return true;\n+      }\n+      if ((outerThisStack.head.flags_field & NOOUTERTHIS) == 0)  {\n+        \/\/ Enclosing instance field is used\n+        return true;\n+      }\n+      if (rs.isSerializable(sym.type) && !hasSerialVersionUID(sym)) {\n+        \/\/ Class is serializable and does not have a stable serialVersionUID\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    private boolean hasSerialVersionUID(ClassSymbol sym) {\n+      VarSymbol svuid = (VarSymbol) sym.members().findFirst(names.serialVersionUID, f -> f.kind == VAR);\n+      if (svuid == null) {\n+        return false;\n+      }\n+      if ((svuid.flags() & (STATIC | FINAL)) != (STATIC | FINAL)) {\n+        return false;\n+      }\n+      if (!svuid.type.hasTag(LONG)) {\n+        return false;\n+      }\n+      if (svuid.getConstValue() == null) {\n+        return false;\n+      }\n+      return true;\n+    }\n+\n@@ -2706,5 +2760,0 @@\n-            if (currentClass.hasOuterInstance() &&\n-                TreeInfo.isInitialConstructor(tree))\n-            {\n-                added = added.prepend(initOuterThis(tree.body.pos));\n-            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":60,"deletions":11,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-            sym.module_info.sourcefile = toplevel.sourcefile;\n+            sym.module_info.classfile = sym.module_info.sourcefile = toplevel.sourcefile;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -206,0 +206,7 @@\n+\n+    \/** Omit unused enclosing instance fields from inner classes that don't access enclosing\n+     * instance state.\n+     *\/\n+    public boolean optimizeOuterThis() {\n+        return compareTo(JDK1_18) >= 0;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -730,0 +730,24 @@\n+    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+    public JavaFileObject getFileObjectOf(Element e) {\n+        Symbol sym = (Symbol) e;\n+        return switch(sym.kind) {\n+            case PCK -> {\n+                PackageSymbol psym = (PackageSymbol) sym;\n+                if (psym.package_info == null) {\n+                    yield null;\n+                }\n+                yield psym.package_info.classfile;\n+            }\n+\n+            case MDL -> {\n+                ModuleSymbol msym = (ModuleSymbol) sym;\n+                if (msym.module_info == null) {\n+                    yield null;\n+                }\n+                yield msym.module_info.classfile;\n+            }\n+            case TYP -> ((ClassSymbol) sym).classfile;\n+            default -> sym.enclClass().classfile;\n+        };\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-import sun.jvm.hotspot.memory.SystemDictionary;\n@@ -97,1 +96,0 @@\n-import sun.jvm.hotspot.utilities.CompactHashTable;\n@@ -101,1 +99,0 @@\n-import sun.jvm.hotspot.utilities.ObjectReader;\n@@ -135,1 +132,1 @@\n-                \/\/ together duplicate classes are a possibilty.  For\n+                \/\/ together duplicate classes are a possibility.  For\n@@ -439,1 +436,0 @@\n-                    String format = \"\";\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/CommandProcessor.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import sun.jvm.hotspot.memory.*;\n@@ -1740,1 +1739,0 @@\n-    sun.jvm.hotspot.oops.ObjectHistogram histo = new sun.jvm.hotspot.oops.ObjectHistogram();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HSDB.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -429,1 +429,0 @@\n-    long size = 0;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HotSpotTypeDataBase.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -353,1 +353,0 @@\n-    int RADIX = (1 << LOG2_RADIX);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/NMethod.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.util.*;\n@@ -91,1 +90,0 @@\n-      int i = 0;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/code\/StubQueue.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -420,1 +420,0 @@\n-    int moduleNumber = 0; \/\/ Debugging\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/WindbgCDebugInfoBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -313,1 +313,1 @@\n-  boolean  _got_error;      \/\/ True, if an error occured during interpretation.\n+  boolean  _got_error;      \/\/ True, if an error occurred during interpretation.\n@@ -316,1 +316,1 @@\n-  \/\/  bool     _did_relocation; \/\/ was relocation neccessary\n+  \/\/  bool     _did_relocation; \/\/ was relocation necessary\n@@ -532,1 +532,0 @@\n-    boolean change = false;\n@@ -1897,1 +1896,1 @@\n-  boolean  _report_result_for_send;         \/\/ Unfortunatly, stackmaps for sends are special, so we need some extra\n+  boolean  _report_result_for_send;         \/\/ Unfortunately, stackmaps for sends are special, so we need some extra\n@@ -1950,1 +1949,1 @@\n-  boolean   _conflict;                      \/\/ True, if a conflict occured during interpretation\n+  boolean   _conflict;                      \/\/ True, if a conflict occurred during interpretation\n@@ -2134,1 +2133,1 @@\n-    \/\/ We have to initialize all variables here, that can be queried direcly\n+    \/\/ We have to initialize all variables here, that can be queried directly\n@@ -2207,1 +2206,1 @@\n-      \/\/ an exception thrown in this part of the code is likly to mean that we are executing some\n+      \/\/ an exception thrown in this part of the code is likely to mean that we are executing some\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/GenerateOopMap.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1284,2 +1284,0 @@\n-            boolean isFloat = (type == Location.Type.FLOAT_IN_DBL ||\n-                               type == Location.Type.DBL);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ui\/classbrowser\/HTMLGenerator.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1021,1 +1021,2 @@\n-                                c.setTime(tsTokenInfo.getDate());\n+                                Date tsDate = tsTokenInfo.getDate();\n+                                c.setTime(tsDate);\n@@ -1023,1 +1024,5 @@\n-                                    new JarConstraintsParameters(chain, si.getTimestamp());\n+                                    new JarConstraintsParameters(chain, tsDate);\n+                                JarConstraintsParameters jcpts =\n+                                    new JarConstraintsParameters(\n+                                        tsSi.getCertificateChain(tsToken),\n+                                        tsDate);\n@@ -1032,3 +1037,3 @@\n-                                        verifyWithWeak(tsDigestAlg, DIGEST_PRIMITIVE_SET, true, jcp),\n-                                        verifyWithWeak(tsSigAlg, SIG_PRIMITIVE_SET, true, jcp),\n-                                        verifyWithWeak(tsKey, jcp));\n+                                        verifyWithWeak(tsDigestAlg, DIGEST_PRIMITIVE_SET, true, jcpts),\n+                                        verifyWithWeak(tsSigAlg, SIG_PRIMITIVE_SET, true, jcpts),\n+                                        verifyWithWeak(tsKey, jcpts));\n@@ -1374,1 +1379,1 @@\n-            JAR_DISABLED_CHECK.permits(alg, jcp);\n+            JAR_DISABLED_CHECK.permits(alg, jcp, false);\n@@ -1380,1 +1385,1 @@\n-            LEGACY_CHECK.permits(alg, jcp);\n+            LEGACY_CHECK.permits(alg, jcp, false);\n@@ -1402,1 +1407,1 @@\n-            JAR_DISABLED_CHECK.permits(key.getAlgorithm(), jcp);\n+            JAR_DISABLED_CHECK.permits(key.getAlgorithm(), jcp, true);\n@@ -1408,1 +1413,1 @@\n-            LEGACY_CHECK.permits(key.getAlgorithm(), jcp);\n+            LEGACY_CHECK.permits(key.getAlgorithm(), jcp, true);\n@@ -1425,1 +1430,1 @@\n-            JAR_DISABLED_CHECK.permits(alg, jcp);\n+            JAR_DISABLED_CHECK.permits(alg, jcp, false);\n@@ -1427,1 +1432,1 @@\n-                LEGACY_CHECK.permits(alg, jcp);\n+                LEGACY_CHECK.permits(alg, jcp, false);\n@@ -1454,1 +1459,1 @@\n-            JAR_DISABLED_CHECK.permits(key.getAlgorithm(), jcp);\n+            JAR_DISABLED_CHECK.permits(key.getAlgorithm(), jcp, true);\n@@ -1456,1 +1461,1 @@\n-                LEGACY_CHECK.permits(key.getAlgorithm(), jcp);\n+                LEGACY_CHECK.permits(key.getAlgorithm(), jcp, true);\n@@ -1468,1 +1473,1 @@\n-            CERTPATH_DISABLED_CHECK.permits(key.getAlgorithm(), cpcp);\n+            CERTPATH_DISABLED_CHECK.permits(key.getAlgorithm(), cpcp, true);\n@@ -1473,1 +1478,1 @@\n-            LEGACY_CHECK.permits(key.getAlgorithm(), cpcp);\n+            LEGACY_CHECK.permits(key.getAlgorithm(), cpcp, true);\n@@ -1486,1 +1491,1 @@\n-            CERTPATH_DISABLED_CHECK.permits(alg, cpcp);\n+            CERTPATH_DISABLED_CHECK.permits(alg, cpcp, false);\n@@ -1491,1 +1496,1 @@\n-            LEGACY_CHECK.permits(alg, cpcp);\n+            LEGACY_CHECK.permits(alg, cpcp, false);\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -432,1 +432,1 @@\n-                    Text whitespace = Text.of(line.substring(0, idx));\n+                    Text whitespace = Text.of(utils.normalizeNewlines(line.substring(0, idx)));\n@@ -441,1 +441,1 @@\n-                    c = HtmlTree.SPAN(Text.of(sequence));\n+                    c = HtmlTree.SPAN(Text.of(utils.normalizeNewlines(sequence)));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -364,0 +364,3 @@\n+doclet.tag.attribute.value.missing=\\\n+ missing value for attribute \"{0}\"\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.List;\n@@ -87,0 +86,39 @@\n+        try {\n+            return generateContent(holder, tag, writer);\n+        } catch (BadSnippetException e) {\n+            error(writer, holder, e.tag(), e.key(), e.args());\n+            return badSnippet(writer);\n+        }\n+    }\n+\n+    private static final class BadSnippetException extends Exception {\n+\n+        @java.io.Serial\n+        private static final long serialVersionUID = 1;\n+\n+        private final transient DocTree tag;\n+        private final String key;\n+        private final transient Object[] args;\n+\n+        BadSnippetException(DocTree tag, String key, Object... args) {\n+            this.tag = tag;\n+            this.key = key;\n+            this.args = args;\n+        }\n+\n+        DocTree tag() {\n+            return tag;\n+        }\n+\n+        String key() {\n+            return key;\n+        }\n+\n+        Object[] args() {\n+            return args;\n+        }\n+    }\n+\n+    private Content generateContent(Element holder, DocTree tag, TagletWriter writer)\n+            throws BadSnippetException\n+    {\n@@ -101,3 +139,2 @@\n-            error(writer, holder, a, \"doclet.tag.attribute.repeated\",\n-                a.getName().toString());\n-            return badSnippet(writer);\n+            throw new BadSnippetException(a, \"doclet.tag.attribute.repeated\",\n+                    a.getName().toString());\n@@ -114,3 +151,2 @@\n-            error(writer, holder, attributes.get(CLASS),\n-                \"doclet.snippet.contents.ambiguity.external\");\n-            return badSnippet(writer);\n+            throw new BadSnippetException(attributes.get(CLASS),\n+                    \"doclet.snippet.contents.ambiguity.external\");\n@@ -118,2 +154,1 @@\n-            error(writer, holder, tag, \"doclet.snippet.contents.none\");\n-            return badSnippet(writer);\n+            throw new BadSnippetException(tag, \"doclet.snippet.contents.none\");\n@@ -125,1 +160,1 @@\n-            regionName = stringOf(region.getValue());\n+            regionName = stringValueOf(region);\n@@ -127,3 +162,2 @@\n-                error(writer, holder, region, \"doclet.tag.attribute.value.illegal\",\n-                    \"region\", region.getValue());\n-                return badSnippet(writer);\n+                throw new BadSnippetException(region, \"doclet.tag.attribute.value.illegal\",\n+                        \"region\", region.getValue());\n@@ -144,2 +178,2 @@\n-                ? stringOf((a = attributes.get(FILE)).getValue())\n-                : stringOf((a = attributes.get(CLASS)).getValue()).replace(\".\", \"\/\") + \".java\";\n+                    ? stringValueOf((a = attributes.get(FILE)))\n+                    : stringValueOf((a = attributes.get(CLASS))).replace(\".\", \"\/\") + \".java\";\n@@ -148,2 +182,2 @@\n-                error(writer, holder, a, \"doclet.tag.attribute.value.illegal\",\n-                    containsFile ? FILE : CLASS, v);\n+                throw new BadSnippetException(a, \"doclet.tag.attribute.value.illegal\",\n+                        containsFile ? FILE : CLASS, v);\n@@ -168,1 +202,1 @@\n-            } catch (IOException | IllegalArgumentException e) {\n+            } catch (IOException | IllegalArgumentException e) { \/\/ TODO: test this when JDK-8276892 is integrated\n@@ -170,2 +204,1 @@\n-                error(writer, holder, a, \"doclet.exception.read.file\", v, e.getCause());\n-                return badSnippet(writer);\n+                throw new BadSnippetException(a, \"doclet.exception.read.file\", v, e.getCause());\n@@ -176,2 +209,1 @@\n-                error(writer, holder, a, \"doclet.File_not_found\", v);\n-                return badSnippet(writer);\n+                throw new BadSnippetException(a, \"doclet.File_not_found\", v);\n@@ -182,4 +214,3 @@\n-            } catch (IOException e) {\n-                error(writer, holder, a, \"doclet.exception.read.file\",\n-                    fileObject.getName(), e.getCause());\n-                return badSnippet(writer);\n+            } catch (IOException e) {  \/\/ TODO: test this when JDK-8276892 is integrated\n+                throw new BadSnippetException(a, \"doclet.exception.read.file\",\n+                        fileObject.getName(), e.getCause());\n@@ -200,1 +231,1 @@\n-                .getDocTreePath(snippetTag.getBody());\n+                    .getDocTreePath(snippetTag.getBody());\n@@ -203,1 +234,1 @@\n-                .getText(\"doclet.snippet.markup\", e.getMessage());\n+                    .getText(\"doclet.snippet.markup\", e.getMessage());\n@@ -205,1 +236,1 @@\n-                path, e.getPosition(), e.getPosition(), e.getPosition(), msg);\n+                    path, e.getPosition(), e.getPosition(), e.getPosition(), msg);\n@@ -216,1 +247,1 @@\n-                e.getPosition(), e.getPosition(), \"doclet.snippet.markup\", e.getMessage());\n+                    e.getPosition(), e.getPosition(), \"doclet.snippet.markup\", e.getMessage());\n@@ -238,2 +269,1 @@\n-                error(writer, holder, tag, \"doclet.snippet.region.not_found\", regionName);\n-                return badSnippet(writer);\n+                throw new BadSnippetException(tag, \"doclet.snippet.region.not_found\", regionName);\n@@ -255,3 +285,1 @@\n-                error(writer, holder, tag, \"doclet.snippet.contents.mismatch\", diff(inlineStr, externalStr));\n-                \/\/ output one above the other\n-                return badSnippet(writer);\n+                throw new BadSnippetException(tag, \"doclet.snippet.contents.mismatch\", diff(inlineStr, externalStr));\n@@ -266,2 +294,2 @@\n-        if (langAttr != null && langAttr.getValueKind() != AttributeTree.ValueKind.EMPTY) {\n-            lang = stringOf(langAttr.getValue());\n+        if (langAttr != null) {\n+            lang = stringValueOf(langAttr);\n@@ -274,3 +302,3 @@\n-        String id = idAttr == null || idAttr.getValueKind() == AttributeTree.ValueKind.EMPTY\n-                        ? null\n-                        : stringOf(idAttr.getValue());\n+        String id = idAttr == null\n+                ? null\n+                : stringValueOf(idAttr);\n@@ -307,2 +335,6 @@\n-    private static String stringOf(List<? extends DocTree> value) {\n-        return value.stream()\n+    private static String stringValueOf(AttributeTree at) throws BadSnippetException {\n+        if (at.getValueKind() == AttributeTree.ValueKind.EMPTY) {\n+            throw new BadSnippetException(at, \"doclet.tag.attribute.value.missing\",\n+                    at.getName().toString());\n+        }\n+        return at.getValue().stream()\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SnippetTaglet.java","additions":74,"deletions":42,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -61,2 +61,1 @@\n-\/\/ TODO: uncomment \/* sealed *\/ when minimum boot JDK version >= 17\n-public \/* sealed *\/ abstract class Attribute {\n+public abstract class Attribute {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Attribute.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -70,8 +70,0 @@\n-\n-    public int size() {\n-        return attributes.values().stream().mapToInt(List::size).sum();\n-    }\n-\n-    public boolean isEmpty() {\n-        return attributes.isEmpty();\n-    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Attributes.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-                List<Tag> parsedTags = null;\n+                List<Tag> parsedTags;\n@@ -159,1 +159,1 @@\n-                    \/\/ adjust index\n+                    \/\/ translate error position from markup to file line\n@@ -163,1 +163,1 @@\n-                    t.lineSourceOffset = next.offset;\n+                    t.lineSourceOffset = next.offset();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Parser.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        int off = 0; \/\/ offset because of the replacements (can be negative)\n+        int off = 0; \/\/ cumulative offset caused by replacements (can become negative)\n@@ -82,1 +82,1 @@\n-            text.subText(r.start, r.end).replace(Set.of(), r.value);\n+            text.subText(r.start(), r.end()).replace(Set.of(), r.value());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Replace.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,2 +36,1 @@\n-\/\/ TODO: uncomment \/* sealed *\/ when minimum boot JDK version >= 17\n-public \/* sealed *\/ interface Style {\n+public sealed interface Style {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Style.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -285,1 +285,1 @@\n-    private class LastPoolManager extends ResourcePoolManager {\n+    private static class LastPoolManager extends ResourcePoolManager {\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ImagePluginStack.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-    class ResourcePoolModuleImpl implements ResourcePoolModule {\n+    static class ResourcePoolModuleImpl implements ResourcePoolModule {\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/ResourcePoolManager.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -480,1 +480,1 @@\n-        class ModuleInfoRewriter extends ByteArrayOutputStream {\n+        static class ModuleInfoRewriter extends ByteArrayOutputStream {\n@@ -628,1 +628,1 @@\n-         * Generate byteccode for no-arg constructor\n+         * Generate bytecode for no-arg constructor\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-        try (InputStream resource = getResourceAsStream(\"libjpackageapplauncher.so\")) {\n+        try (InputStream resource = getResourceAsStream(\"libjpackageapplauncheraux.so\")) {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxAppImageBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -277,0 +277,1 @@\n+        ENABLE_NATIVE_ACCESS(\"--enable-native-access\", true, true, false, true, true),\n@@ -366,0 +367,1 @@\n+        private final OptionSpecBuilder  argEnableNativeAccess = parser.accepts(\"enable-native-access\");\n@@ -474,0 +476,4 @@\n+            if (options.has(argEnableNativeAccess)) {\n+                opts.addAll(OptionKind.ENABLE_NATIVE_ACCESS, List.of(\n+                        OptionKind.ENABLE_NATIVE_ACCESS.optionFlag, \"ALL-UNNAMED\"));\n+            }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/JShellTool.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -210,0 +210,2 @@\n+\\    --enable-native-access\\n\\\n+\\                          Allow code to run restricted native methods\\n\\\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/resources\/l10n.properties","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,0 +10,49 @@\n+# These tables are legal immediate logical operands\n+immediates8 \\\n+     = [0x1, 0x0c, 0x3e, 0x60, 0x7c, 0x80, 0x83,\n+        0xe1, 0xbf, 0xef, 0xf3, 0xfe]\n+\n+immediates16 \\\n+     = [0x1, 0x38, 0x7e, 0xff, 0x1fc, 0x1ff, 0x3f0,\n+        0x7e0, 0xfc0, 0x1f80, 0x3ff0, 0x7e00, 0x7e00,\n+        0x8000, 0x81ff, 0xc1ff, 0xc003, 0xc7ff, 0xdfff,\n+        0xe03f, 0xe10f, 0xe1ff, 0xf801, 0xfc00, 0xfc07,\n+        0xff03, 0xfffe]\n+\n+immediates32 \\\n+     = [0x1, 0x3f, 0x1f0, 0x7e0,\n+        0x1c00, 0x3ff0, 0x8000, 0x1e000,\n+        0x3e000, 0x78000, 0xe0000, 0x100000,\n+        0x1fffe0, 0x3fe000, 0x780000, 0x7ffff8,\n+        0xff8000, 0x1800180, 0x1fffc00, 0x3c003c0,\n+        0x3ffff00, 0x7c00000, 0x7fffe00, 0xf000f00,\n+        0xfffe000, 0x18181818, 0x1ffc0000, 0x1ffffffe,\n+        0x3f003f00, 0x3fffe000, 0x60006000, 0x7f807f80,\n+        0x7ffffc00, 0x800001ff, 0x803fffff, 0x9f9f9f9f,\n+        0xc0000fff, 0xc0c0c0c0, 0xe0000000, 0xe003e003,\n+        0xe3ffffff, 0xf0000fff, 0xf0f0f0f0, 0xf80000ff,\n+        0xf83ff83f, 0xfc00007f, 0xfc1fffff, 0xfe0001ff,\n+        0xfe3fffff, 0xff003fff, 0xff800003, 0xff87ff87,\n+        0xffc00fff, 0xffe0000f, 0xffefffef, 0xfff1fff1,\n+        0xfff83fff, 0xfffc0fff, 0xfffe0fff, 0xffff3fff,\n+        0xffffc007, 0xffffe1ff, 0xfffff80f, 0xfffffe07,\n+        0xffffffbf, 0xfffffffd]\n+\n+immediates64 \\\n+     = [0x1, 0x1f80, 0x3fff0, 0x3ffffc,\n+        0x3fe0000, 0x1ffc0000, 0xf8000000, 0x3ffffc000,\n+        0xffffffe00, 0x3ffffff800, 0xffffc00000, 0x3f000000000,\n+        0x7fffffff800, 0x1fe000001fe0, 0x3ffffff80000, 0xc00000000000,\n+        0x1ffc000000000, 0x3ffff0003ffff, 0x7ffffffe00000, 0xfffffffffc000,\n+        0x1ffffffffffc00, 0x3fffffffffff00, 0x7ffffffffffc00, 0xffffffffff8000,\n+        0x1ffffffff800000, 0x3fffffc03fffffc, 0x7fffc0000000000, 0xff80ff80ff80ff8,\n+        0x1c00000000000000, 0x1fffffffffff0000, 0x3fffff803fffff80, 0x7fc000007fc00000,\n+        0x8000000000000000, 0x803fffff803fffff, 0xc000007fc000007f, 0xe00000000000ffff,\n+        0xe3ffffffffffffff, 0xf007f007f007f007, 0xf80003ffffffffff, 0xfc000003fc000003,\n+        0xfe000000007fffff, 0xff00000000007fff, 0xff800000000003ff, 0xffc00000000000ff,\n+        0xffe00000000003ff, 0xfff0000000003fff, 0xfff80000001fffff, 0xfffc0000fffc0000,\n+        0xfffe003fffffffff, 0xffff3fffffffffff, 0xffffc0000007ffff, 0xffffe01fffffe01f,\n+        0xfffff800000007ff, 0xfffffc0fffffffff, 0xffffff00003fffff, 0xffffffc0000007ff,\n+        0xfffffff0000001ff, 0xfffffffc00003fff, 0xffffffff07ffffff, 0xffffffffe003ffff,\n+        0xfffffffffc01ffff, 0xffffffffffc00003, 0xfffffffffffc000f, 0xffffffffffffe07f]\n+\n@@ -354,39 +403,0 @@\n-\n-     # These tables are legal immediate logical operands\n-     immediates32 \\\n-         = [0x1, 0x3f, 0x1f0, 0x7e0,\n-            0x1c00, 0x3ff0, 0x8000, 0x1e000,\n-            0x3e000, 0x78000, 0xe0000, 0x100000,\n-            0x1fffe0, 0x3fe000, 0x780000, 0x7ffff8,\n-            0xff8000, 0x1800180, 0x1fffc00, 0x3c003c0,\n-            0x3ffff00, 0x7c00000, 0x7fffe00, 0xf000f00,\n-            0xfffe000, 0x18181818, 0x1ffc0000, 0x1ffffffe,\n-            0x3f003f00, 0x3fffe000, 0x60006000, 0x7f807f80,\n-            0x7ffffc00, 0x800001ff, 0x803fffff, 0x9f9f9f9f,\n-            0xc0000fff, 0xc0c0c0c0, 0xe0000000, 0xe003e003,\n-            0xe3ffffff, 0xf0000fff, 0xf0f0f0f0, 0xf80000ff,\n-            0xf83ff83f, 0xfc00007f, 0xfc1fffff, 0xfe0001ff,\n-            0xfe3fffff, 0xff003fff, 0xff800003, 0xff87ff87,\n-            0xffc00fff, 0xffe0000f, 0xffefffef, 0xfff1fff1,\n-            0xfff83fff, 0xfffc0fff, 0xfffe0fff, 0xffff3fff,\n-            0xffffc007, 0xffffe1ff, 0xfffff80f, 0xfffffe07,\n-            0xffffffbf, 0xfffffffd]\n-\n-     immediates \\\n-         = [0x1, 0x1f80, 0x3fff0, 0x3ffffc,\n-            0x3fe0000, 0x1ffc0000, 0xf8000000, 0x3ffffc000,\n-            0xffffffe00, 0x3ffffff800, 0xffffc00000, 0x3f000000000,\n-            0x7fffffff800, 0x1fe000001fe0, 0x3ffffff80000, 0xc00000000000,\n-            0x1ffc000000000, 0x3ffff0003ffff, 0x7ffffffe00000, 0xfffffffffc000,\n-            0x1ffffffffffc00, 0x3fffffffffff00, 0x7ffffffffffc00, 0xffffffffff8000,\n-            0x1ffffffff800000, 0x3fffffc03fffffc, 0x7fffc0000000000, 0xff80ff80ff80ff8,\n-            0x1c00000000000000, 0x1fffffffffff0000, 0x3fffff803fffff80, 0x7fc000007fc00000,\n-            0x8000000000000000, 0x803fffff803fffff, 0xc000007fc000007f, 0xe00000000000ffff,\n-            0xe3ffffffffffffff, 0xf007f007f007f007, 0xf80003ffffffffff, 0xfc000003fc000003,\n-            0xfe000000007fffff, 0xff00000000007fff, 0xff800000000003ff, 0xffc00000000000ff,\n-            0xffe00000000003ff, 0xfff0000000003fff, 0xfff80000001fffff, 0xfffc0000fffc0000,\n-            0xfffe003fffffffff, 0xffff3fffffffffff, 0xffffc0000007ffff, 0xffffe01fffffe01f,\n-            0xfffff800000007ff, 0xfffffc0fffffffff, 0xffffff00003fffff, 0xffffffc0000007ff,\n-            0xfffffff0000001ff, 0xfffffffc00003fff, 0xffffffff07ffffff, 0xffffffffe003ffff,\n-            0xfffffffffc01ffff, 0xffffffffffc00003, 0xfffffffffffc000f, 0xffffffffffffe07f]\n-\n@@ -396,1 +406,1 @@\n-              self.immediates32[random.randint(0, len(self.immediates32)-1)] \\\n+              immediates32[random.randint(0, len(immediates32)-1)] \\\n@@ -398,1 +408,1 @@\n-              self.immediates[random.randint(0, len(self.immediates)-1)]\n+              immediates64[random.randint(0, len(immediates64)-1)]\n@@ -409,0 +419,38 @@\n+class SVEBinaryImmOp(Instruction):\n+    def __init__(self, name):\n+        reg = SVEVectorRegister().generate()\n+        self.reg = [reg, reg]\n+        self.numRegs = len(self.reg)\n+        self._width = RegVariant(0, 3)\n+        self._isLogical = False\n+        if name in [\"and\", \"eor\", \"orr\"]:\n+            self._isLogical = True\n+        Instruction.__init__(self, name)\n+\n+    def generate(self):\n+        Instruction.generate(self)\n+        self.immed = random.randint(0, (1<<8)-1)\n+        if self._isLogical:\n+            vectype = self._width.cstr()\n+            if vectype == \"__ B\":\n+                self.immed = immediates8[random.randint(0, len(immediates8)-1)]\n+            elif vectype == \"__ H\":\n+                self.immed = immediates16[random.randint(0, len(immediates16)-1)]\n+            elif vectype == \"__ S\":\n+                self.immed = immediates32[random.randint(0, len(immediates32)-1)]\n+            elif vectype == \"__ D\":\n+                self.immed = immediates64[random.randint(0, len(immediates64)-1)]\n+        return self\n+\n+    def cstr(self):\n+        formatStr = \"%s%s, %s, %su);\"\n+        return (formatStr\n+                % tuple([\"__ sve_\" + self._name + \"(\"] +\n+                        [str(self.reg[0]), self._width.cstr(), self.immed]))\n+\n+    def astr(self):\n+        formatStr = \"%s%s, %s, #0x%x\"\n+        Regs = [str(self.reg[i]) + self._width.astr() for i in range(0, self.numRegs)]\n+        return (formatStr\n+                % tuple([Instruction.astr(self)] + Regs + [self.immed]))\n+\n@@ -1724,0 +1772,3 @@\n+for i in range(6):\n+    generate(SVEBinaryImmOp, [\"add\", \"sub\", \"and\", \"eor\", \"orr\"])\n+\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":92,"deletions":41,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -1018,0 +1018,42 @@\n+\/\/ SVEBinaryImmOp\n+    __ sve_add(z4, __ B, 147u);                        \/\/       add     z4.b, z4.b, #0x93\n+    __ sve_sub(z0, __ B, 124u);                        \/\/       sub     z0.b, z0.b, #0x7c\n+    __ sve_and(z1, __ H, 508u);                        \/\/       and     z1.h, z1.h, #0x1fc\n+    __ sve_eor(z9, __ D, 18374686479671656447u);       \/\/       eor     z9.d, z9.d, #0xff00000000007fff\n+    __ sve_orr(z22, __ S, 251662080u);                 \/\/       orr     z22.s, z22.s, #0xf000f00\n+\n+\/\/ SVEBinaryImmOp\n+    __ sve_add(z8, __ S, 248u);                        \/\/       add     z8.s, z8.s, #0xf8\n+    __ sve_sub(z6, __ S, 16u);                         \/\/       sub     z6.s, z6.s, #0x10\n+    __ sve_and(z11, __ D, 4160749568u);                \/\/       and     z11.d, z11.d, #0xf8000000\n+    __ sve_eor(z26, __ S, 1610637312u);                \/\/       eor     z26.s, z26.s, #0x60006000\n+    __ sve_orr(z13, __ D, 18446181398634037247u);      \/\/       orr     z13.d, z13.d, #0xfffe003fffffffff\n+\n+\/\/ SVEBinaryImmOp\n+    __ sve_add(z5, __ B, 112u);                        \/\/       add     z5.b, z5.b, #0x70\n+    __ sve_sub(z10, __ S, 88u);                        \/\/       sub     z10.s, z10.s, #0x58\n+    __ sve_and(z26, __ S, 253952u);                    \/\/       and     z26.s, z26.s, #0x3e000\n+    __ sve_eor(z22, __ S, 496u);                       \/\/       eor     z22.s, z22.s, #0x1f0\n+    __ sve_orr(z19, __ S, 536870910u);                 \/\/       orr     z19.s, z19.s, #0x1ffffffe\n+\n+\/\/ SVEBinaryImmOp\n+    __ sve_add(z14, __ H, 22u);                        \/\/       add     z14.h, z14.h, #0x16\n+    __ sve_sub(z16, __ B, 172u);                       \/\/       sub     z16.b, z16.b, #0xac\n+    __ sve_and(z23, __ B, 62u);                        \/\/       and     z23.b, z23.b, #0x3e\n+    __ sve_eor(z17, __ H, 33279u);                     \/\/       eor     z17.h, z17.h, #0x81ff\n+    __ sve_orr(z16, __ B, 254u);                       \/\/       orr     z16.b, z16.b, #0xfe\n+\n+\/\/ SVEBinaryImmOp\n+    __ sve_add(z3, __ B, 49u);                         \/\/       add     z3.b, z3.b, #0x31\n+    __ sve_sub(z17, __ S, 110u);                       \/\/       sub     z17.s, z17.s, #0x6e\n+    __ sve_and(z12, __ S, 4290777087u);                \/\/       and     z12.s, z12.s, #0xffc00fff\n+    __ sve_eor(z19, __ S, 134217216u);                 \/\/       eor     z19.s, z19.s, #0x7fffe00\n+    __ sve_orr(z23, __ B, 254u);                       \/\/       orr     z23.b, z23.b, #0xfe\n+\n+\/\/ SVEBinaryImmOp\n+    __ sve_add(z13, __ S, 54u);                        \/\/       add     z13.s, z13.s, #0x36\n+    __ sve_sub(z0, __ B, 120u);                        \/\/       sub     z0.b, z0.b, #0x78\n+    __ sve_and(z17, __ D, 18014398509481728u);         \/\/       and     z17.d, z17.d, #0x3fffffffffff00\n+    __ sve_eor(z22, __ S, 4294709247u);                \/\/       eor     z22.s, z22.s, #0xfffc0fff\n+    __ sve_orr(z2, __ B, 225u);                        \/\/       orr     z2.b, z2.b, #0xe1\n+\n@@ -1019,45 +1061,45 @@\n-    __ sve_add(z4, __ B, z6, z17);                     \/\/       add     z4.b, z6.b, z17.b\n-    __ sve_sub(z3, __ H, z15, z1);                     \/\/       sub     z3.h, z15.h, z1.h\n-    __ sve_fadd(z6, __ D, z5, z9);                     \/\/       fadd    z6.d, z5.d, z9.d\n-    __ sve_fmul(z7, __ D, z20, z22);                   \/\/       fmul    z7.d, z20.d, z22.d\n-    __ sve_fsub(z5, __ D, z10, z8);                    \/\/       fsub    z5.d, z10.d, z8.d\n-    __ sve_abs(z30, __ B, p1, z17);                    \/\/       abs     z30.b, p1\/m, z17.b\n-    __ sve_add(z11, __ B, p7, z28);                    \/\/       add     z11.b, p7\/m, z11.b, z28.b\n-    __ sve_and(z26, __ H, p5, z28);                    \/\/       and     z26.h, p5\/m, z26.h, z28.h\n-    __ sve_asr(z13, __ D, p7, z16);                    \/\/       asr     z13.d, p7\/m, z13.d, z16.d\n-    __ sve_cnt(z5, __ H, p0, z13);                     \/\/       cnt     z5.h, p0\/m, z13.h\n-    __ sve_eor(z15, __ S, p2, z26);                    \/\/       eor     z15.s, p2\/m, z15.s, z26.s\n-    __ sve_lsl(z11, __ S, p1, z22);                    \/\/       lsl     z11.s, p1\/m, z11.s, z22.s\n-    __ sve_lsr(z4, __ S, p0, z19);                     \/\/       lsr     z4.s, p0\/m, z4.s, z19.s\n-    __ sve_mul(z17, __ H, p3, z14);                    \/\/       mul     z17.h, p3\/m, z17.h, z14.h\n-    __ sve_neg(z2, __ S, p4, z3);                      \/\/       neg     z2.s, p4\/m, z3.s\n-    __ sve_not(z23, __ B, p1, z6);                     \/\/       not     z23.b, p1\/m, z6.b\n-    __ sve_orr(z17, __ S, p3, z27);                    \/\/       orr     z17.s, p3\/m, z17.s, z27.s\n-    __ sve_smax(z16, __ D, p1, z2);                    \/\/       smax    z16.d, p1\/m, z16.d, z2.d\n-    __ sve_smin(z3, __ S, p1, z6);                     \/\/       smin    z3.s, p1\/m, z3.s, z6.s\n-    __ sve_sub(z19, __ S, p3, z12);                    \/\/       sub     z19.s, p3\/m, z19.s, z12.s\n-    __ sve_fabs(z8, __ D, p6, z19);                    \/\/       fabs    z8.d, p6\/m, z19.d\n-    __ sve_fadd(z0, __ S, p2, z23);                    \/\/       fadd    z0.s, p2\/m, z0.s, z23.s\n-    __ sve_fdiv(z19, __ D, p7, z13);                   \/\/       fdiv    z19.d, p7\/m, z19.d, z13.d\n-    __ sve_fmax(z6, __ S, p0, z7);                     \/\/       fmax    z6.s, p0\/m, z6.s, z7.s\n-    __ sve_fmin(z17, __ S, p6, z8);                    \/\/       fmin    z17.s, p6\/m, z17.s, z8.s\n-    __ sve_fmul(z22, __ D, p5, z22);                   \/\/       fmul    z22.d, p5\/m, z22.d, z22.d\n-    __ sve_fneg(z2, __ D, p0, z15);                    \/\/       fneg    z2.d, p0\/m, z15.d\n-    __ sve_frintm(z20, __ D, p1, z4);                  \/\/       frintm  z20.d, p1\/m, z4.d\n-    __ sve_frintn(z7, __ D, p0, z8);                   \/\/       frintn  z7.d, p0\/m, z8.d\n-    __ sve_frintp(z19, __ D, p5, z4);                  \/\/       frintp  z19.d, p5\/m, z4.d\n-    __ sve_fsqrt(z9, __ D, p5, z11);                   \/\/       fsqrt   z9.d, p5\/m, z11.d\n-    __ sve_fsub(z5, __ S, p7, z16);                    \/\/       fsub    z5.s, p7\/m, z5.s, z16.s\n-    __ sve_fmad(z22, __ S, p3, z1, z13);               \/\/       fmad    z22.s, p3\/m, z1.s, z13.s\n-    __ sve_fmla(z20, __ S, p4, z25, z15);              \/\/       fmla    z20.s, p4\/m, z25.s, z15.s\n-    __ sve_fmls(z4, __ D, p4, z8, z6);                 \/\/       fmls    z4.d, p4\/m, z8.d, z6.d\n-    __ sve_fnmla(z4, __ D, p7, z16, z29);              \/\/       fnmla   z4.d, p7\/m, z16.d, z29.d\n-    __ sve_fnmls(z9, __ D, p3, z2, z11);               \/\/       fnmls   z9.d, p3\/m, z2.d, z11.d\n-    __ sve_mla(z3, __ S, p1, z1, z26);                 \/\/       mla     z3.s, p1\/m, z1.s, z26.s\n-    __ sve_mls(z17, __ S, p3, z8, z17);                \/\/       mls     z17.s, p3\/m, z8.s, z17.s\n-    __ sve_and(z24, z5, z19);                          \/\/       and     z24.d, z5.d, z19.d\n-    __ sve_eor(z17, z22, z16);                         \/\/       eor     z17.d, z22.d, z16.d\n-    __ sve_orr(z20, z19, z0);                          \/\/       orr     z20.d, z19.d, z0.d\n-    __ sve_bic(z17, z23, z4);                          \/\/       bic     z17.d, z23.d, z4.d\n-    __ sve_uzp1(z4, __ S, z23, z25);                   \/\/       uzp1    z4.s, z23.s, z25.s\n-    __ sve_uzp2(z2, __ H, z8, z8);                     \/\/       uzp2    z2.h, z8.h, z8.h\n+    __ sve_add(z20, __ D, z7, z4);                     \/\/       add     z20.d, z7.d, z4.d\n+    __ sve_sub(z7, __ S, z0, z8);                      \/\/       sub     z7.s, z0.s, z8.s\n+    __ sve_fadd(z19, __ D, z22, z4);                   \/\/       fadd    z19.d, z22.d, z4.d\n+    __ sve_fmul(z9, __ D, z22, z11);                   \/\/       fmul    z9.d, z22.d, z11.d\n+    __ sve_fsub(z5, __ S, z30, z16);                   \/\/       fsub    z5.s, z30.s, z16.s\n+    __ sve_abs(z22, __ H, p3, z1);                     \/\/       abs     z22.h, p3\/m, z1.h\n+    __ sve_add(z8, __ D, p5, z16);                     \/\/       add     z8.d, p5\/m, z8.d, z16.d\n+    __ sve_and(z15, __ S, p1, z4);                     \/\/       and     z15.s, p1\/m, z15.s, z4.s\n+    __ sve_asr(z8, __ B, p1, z29);                     \/\/       asr     z8.b, p1\/m, z8.b, z29.b\n+    __ sve_cnt(z28, __ D, p4, z29);                    \/\/       cnt     z28.d, p4\/m, z29.d\n+    __ sve_eor(z9, __ H, p3, z2);                      \/\/       eor     z9.h, p3\/m, z9.h, z2.h\n+    __ sve_lsl(z28, __ B, p0, z7);                     \/\/       lsl     z28.b, p0\/m, z28.b, z7.b\n+    __ sve_lsr(z26, __ H, p5, z17);                    \/\/       lsr     z26.h, p5\/m, z26.h, z17.h\n+    __ sve_mul(z8, __ D, p4, z21);                     \/\/       mul     z8.d, p4\/m, z8.d, z21.d\n+    __ sve_neg(z5, __ S, p5, z21);                     \/\/       neg     z5.s, p5\/m, z21.s\n+    __ sve_not(z22, __ S, p4, z29);                    \/\/       not     z22.s, p4\/m, z29.s\n+    __ sve_orr(z19, __ S, p0, z4);                     \/\/       orr     z19.s, p0\/m, z19.s, z4.s\n+    __ sve_smax(z23, __ B, p1, z19);                   \/\/       smax    z23.b, p1\/m, z23.b, z19.b\n+    __ sve_smin(z23, __ B, p6, z19);                   \/\/       smin    z23.b, p6\/m, z23.b, z19.b\n+    __ sve_sub(z8, __ D, p2, z14);                     \/\/       sub     z8.d, p2\/m, z8.d, z14.d\n+    __ sve_fabs(z17, __ S, p7, z21);                   \/\/       fabs    z17.s, p7\/m, z21.s\n+    __ sve_fadd(z30, __ D, p0, z10);                   \/\/       fadd    z30.d, p0\/m, z30.d, z10.d\n+    __ sve_fdiv(z12, __ S, p0, z9);                    \/\/       fdiv    z12.s, p0\/m, z12.s, z9.s\n+    __ sve_fmax(z24, __ D, p4, z4);                    \/\/       fmax    z24.d, p4\/m, z24.d, z4.d\n+    __ sve_fmin(z6, __ D, p2, z27);                    \/\/       fmin    z6.d, p2\/m, z6.d, z27.d\n+    __ sve_fmul(z13, __ D, p4, z30);                   \/\/       fmul    z13.d, p4\/m, z13.d, z30.d\n+    __ sve_fneg(z22, __ D, p5, z30);                   \/\/       fneg    z22.d, p5\/m, z30.d\n+    __ sve_frintm(z9, __ S, p3, z19);                  \/\/       frintm  z9.s, p3\/m, z19.s\n+    __ sve_frintn(z20, __ S, p7, z9);                  \/\/       frintn  z20.s, p7\/m, z9.s\n+    __ sve_frintp(z13, __ S, p3, z19);                 \/\/       frintp  z13.s, p3\/m, z19.s\n+    __ sve_fsqrt(z24, __ S, p2, z19);                  \/\/       fsqrt   z24.s, p2\/m, z19.s\n+    __ sve_fsub(z17, __ S, p4, z16);                   \/\/       fsub    z17.s, p4\/m, z17.s, z16.s\n+    __ sve_fmad(z0, __ S, p0, z11, z7);                \/\/       fmad    z0.s, p0\/m, z11.s, z7.s\n+    __ sve_fmla(z14, __ D, p4, z4, z15);               \/\/       fmla    z14.d, p4\/m, z4.d, z15.d\n+    __ sve_fmls(z5, __ D, p0, z10, z21);               \/\/       fmls    z5.d, p0\/m, z10.d, z21.d\n+    __ sve_fnmla(z3, __ D, p0, z9, z19);               \/\/       fnmla   z3.d, p0\/m, z9.d, z19.d\n+    __ sve_fnmls(z10, __ S, p6, z3, z19);              \/\/       fnmls   z10.s, p6\/m, z3.s, z19.s\n+    __ sve_mla(z23, __ H, p7, z13, z21);               \/\/       mla     z23.h, p7\/m, z13.h, z21.h\n+    __ sve_mls(z26, __ S, p3, z17, z30);               \/\/       mls     z26.s, p3\/m, z17.s, z30.s\n+    __ sve_and(z14, z2, z29);                          \/\/       and     z14.d, z2.d, z29.d\n+    __ sve_eor(z21, z20, z7);                          \/\/       eor     z21.d, z20.d, z7.d\n+    __ sve_orr(z2, z1, z26);                           \/\/       orr     z2.d, z1.d, z26.d\n+    __ sve_bic(z9, z16, z17);                          \/\/       bic     z9.d, z16.d, z17.d\n+    __ sve_uzp1(z0, __ D, z4, z2);                     \/\/       uzp1    z0.d, z4.d, z2.d\n+    __ sve_uzp2(z14, __ S, z6, z11);                   \/\/       uzp2    z14.s, z6.s, z11.s\n@@ -1066,9 +1108,9 @@\n-    __ sve_andv(v24, __ S, p4, z30);                   \/\/       andv s24, p4, z30.s\n-    __ sve_orv(v4, __ H, p7, z1);                      \/\/       orv h4, p7, z1.h\n-    __ sve_eorv(v19, __ H, p3, z0);                    \/\/       eorv h19, p3, z0.h\n-    __ sve_smaxv(v7, __ B, p6, z17);                   \/\/       smaxv b7, p6, z17.b\n-    __ sve_sminv(v27, __ D, p1, z9);                   \/\/       sminv d27, p1, z9.d\n-    __ sve_fminv(v23, __ D, p3, z16);                  \/\/       fminv d23, p3, z16.d\n-    __ sve_fmaxv(v22, __ D, p5, z20);                  \/\/       fmaxv d22, p5, z20.d\n-    __ sve_fadda(v28, __ D, p2, z13);                  \/\/       fadda d28, p2, d28, z13.d\n-    __ sve_uaddv(v7, __ H, p5, z28);                   \/\/       uaddv d7, p5, z28.h\n+    __ sve_andv(v14, __ H, p4, z29);                   \/\/       andv h14, p4, z29.h\n+    __ sve_orv(v3, __ H, p0, z22);                     \/\/       orv h3, p0, z22.h\n+    __ sve_eorv(v3, __ B, p6, z27);                    \/\/       eorv b3, p6, z27.b\n+    __ sve_smaxv(v19, __ D, p5, z7);                   \/\/       smaxv d19, p5, z7.d\n+    __ sve_sminv(v21, __ H, p3, z5);                   \/\/       sminv h21, p3, z5.h\n+    __ sve_fminv(v25, __ D, p1, z21);                  \/\/       fminv d25, p1, z21.d\n+    __ sve_fmaxv(v17, __ S, p0, z3);                   \/\/       fmaxv s17, p0, z3.s\n+    __ sve_fadda(v19, __ S, p3, z7);                   \/\/       fadda s19, p3, s19, z7.s\n+    __ sve_uaddv(v14, __ H, p4, z17);                  \/\/       uaddv d14, p4, z17.h\n@@ -1093,7 +1135,7 @@\n-    0x14000000,     0x17ffffd7,     0x1400037c,     0x94000000,\n-    0x97ffffd4,     0x94000379,     0x3400000a,     0x34fffa2a,\n-    0x34006eca,     0x35000008,     0x35fff9c8,     0x35006e68,\n-    0xb400000b,     0xb4fff96b,     0xb4006e0b,     0xb500001d,\n-    0xb5fff91d,     0xb5006dbd,     0x10000013,     0x10fff8b3,\n-    0x10006d53,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36306cd6,     0x3758000c,     0x375ff7cc,     0x37586c6c,\n+    0x14000000,     0x17ffffd7,     0x1400039a,     0x94000000,\n+    0x97ffffd4,     0x94000397,     0x3400000a,     0x34fffa2a,\n+    0x3400728a,     0x35000008,     0x35fff9c8,     0x35007228,\n+    0xb400000b,     0xb4fff96b,     0xb40071cb,     0xb500001d,\n+    0xb5fff91d,     0xb500717d,     0x10000013,     0x10fff8b3,\n+    0x10007113,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36307096,     0x3758000c,     0x375ff7cc,     0x3758702c,\n@@ -1104,13 +1146,13 @@\n-    0x54006a40,     0x54000001,     0x54fff541,     0x540069e1,\n-    0x54000002,     0x54fff4e2,     0x54006982,     0x54000002,\n-    0x54fff482,     0x54006922,     0x54000003,     0x54fff423,\n-    0x540068c3,     0x54000003,     0x54fff3c3,     0x54006863,\n-    0x54000004,     0x54fff364,     0x54006804,     0x54000005,\n-    0x54fff305,     0x540067a5,     0x54000006,     0x54fff2a6,\n-    0x54006746,     0x54000007,     0x54fff247,     0x540066e7,\n-    0x54000008,     0x54fff1e8,     0x54006688,     0x54000009,\n-    0x54fff189,     0x54006629,     0x5400000a,     0x54fff12a,\n-    0x540065ca,     0x5400000b,     0x54fff0cb,     0x5400656b,\n-    0x5400000c,     0x54fff06c,     0x5400650c,     0x5400000d,\n-    0x54fff00d,     0x540064ad,     0x5400000e,     0x54ffefae,\n-    0x5400644e,     0x5400000f,     0x54ffef4f,     0x540063ef,\n+    0x54006e00,     0x54000001,     0x54fff541,     0x54006da1,\n+    0x54000002,     0x54fff4e2,     0x54006d42,     0x54000002,\n+    0x54fff482,     0x54006ce2,     0x54000003,     0x54fff423,\n+    0x54006c83,     0x54000003,     0x54fff3c3,     0x54006c23,\n+    0x54000004,     0x54fff364,     0x54006bc4,     0x54000005,\n+    0x54fff305,     0x54006b65,     0x54000006,     0x54fff2a6,\n+    0x54006b06,     0x54000007,     0x54fff247,     0x54006aa7,\n+    0x54000008,     0x54fff1e8,     0x54006a48,     0x54000009,\n+    0x54fff189,     0x540069e9,     0x5400000a,     0x54fff12a,\n+    0x5400698a,     0x5400000b,     0x54fff0cb,     0x5400692b,\n+    0x5400000c,     0x54fff06c,     0x540068cc,     0x5400000d,\n+    0x54fff00d,     0x5400686d,     0x5400000e,     0x54ffefae,\n+    0x5400680e,     0x5400000f,     0x54ffef4f,     0x540067af,\n@@ -1148,1 +1190,1 @@\n-    0xbd1b1869,     0x5800543b,     0x1800000b,     0xf8945060,\n+    0xbd1b1869,     0x580057fb,     0x1800000b,     0xf8945060,\n@@ -1303,14 +1345,22 @@\n-    0x043100c4,     0x046105e3,     0x65c900a6,     0x65d60a87,\n-    0x65c80545,     0x0416a63e,     0x04001f8b,     0x045a179a,\n-    0x04d09e0d,     0x045aa1a5,     0x04990b4f,     0x049386cb,\n-    0x04918264,     0x04500dd1,     0x0497b062,     0x041ea4d7,\n-    0x04980f71,     0x04c80450,     0x048a04c3,     0x04810d93,\n-    0x04dcba68,     0x65808ae0,     0x65cd9db3,     0x658680e6,\n-    0x65879911,     0x65c296d6,     0x04dda1e2,     0x65c2a494,\n-    0x65c0a107,     0x65c1b493,     0x65cdb569,     0x65819e05,\n-    0x65ad8c36,     0x65af1334,     0x65e63104,     0x65fd5e04,\n-    0x65eb6c49,     0x049a4423,     0x04916d11,     0x043330b8,\n-    0x04b032d1,     0x04603274,     0x04e432f1,     0x05b96ae4,\n-    0x05686d02,     0x049a33d8,     0x04583c24,     0x04592c13,\n-    0x04083a27,     0x04ca253b,     0x65c72e17,     0x65c63696,\n-    0x65d829bc,     0x04413787,\n+    0x2520d264,     0x2521cf80,     0x058074c1,     0x054242c9,\n+    0x05004476,     0x25a0df08,     0x25a1c206,     0x0583288b,\n+    0x05401c3a,     0x05027e8d,     0x2520ce05,     0x25a1cb0a,\n+    0x0580989a,     0x0540e096,     0x0500fb73,     0x2560c2ce,\n+    0x2521d590,     0x05803e97,     0x05400d31,     0x05003ed0,\n+    0x2520c623,     0x25a1cdd1,     0x058052ac,     0x0540ba33,\n+    0x05003ed7,     0x25a0c6cd,     0x2521cf00,     0x0583c5b1,\n+    0x05407336,     0x05001e62,     0x04e400f4,     0x04a80407,\n+    0x65c402d3,     0x65cb0ac9,     0x659007c5,     0x0456ac36,\n+    0x04c01608,     0x049a048f,     0x041087a8,     0x04dab3bc,\n+    0x04590c49,     0x041380fc,     0x0451963a,     0x04d012a8,\n+    0x0497b6a5,     0x049eb3b6,     0x04980093,     0x04080677,\n+    0x040a1a77,     0x04c109c8,     0x049cbeb1,     0x65c0815e,\n+    0x658d812c,     0x65c69098,     0x65c78b66,     0x65c293cd,\n+    0x04ddb7d6,     0x6582ae69,     0x6580bd34,     0x6581ae6d,\n+    0x658daa78,     0x65819211,     0x65a78160,     0x65ef108e,\n+    0x65f52145,     0x65f34123,     0x65b3786a,     0x04555db7,\n+    0x049e6e3a,     0x043d304e,     0x04a73295,     0x047a3022,\n+    0x04f13209,     0x05e26880,     0x05ab6cce,     0x045a33ae,\n+    0x045822c3,     0x04193b63,     0x04c834f3,     0x044a2cb5,\n+    0x65c726b9,     0x65862071,     0x65982cf3,     0x0441322e,\n+\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":139,"deletions":89,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  class G1CountCardsClosure : public G1CardSet::G1CardSetCardIterator {\n+  class G1CountCardsClosure : public G1CardSet::CardClosure {\n@@ -85,1 +85,1 @@\n-  static void iterate_cards(G1CardSet* card_set, G1CardSet::G1CardSetCardIterator* cl);\n+  static void iterate_cards(G1CardSet* card_set, G1CardSet::CardClosure* cl);\n@@ -104,1 +104,1 @@\n-class G1CheckCardClosure : public G1CardSet::G1CardSetCardIterator {\n+class G1CheckCardClosure : public G1CardSet::CardClosure {\n@@ -166,1 +166,1 @@\n-class G1CountCardsOccupied : public G1CardSet::G1CardSetPtrIterator {\n+class G1CountCardsOccupied : public G1CardSet::CardSetPtrClosure {\n@@ -181,1 +181,1 @@\n-  class CheckIterator : public G1CardSet::G1CardSetCardIterator {\n+  class CheckIterator : public G1CardSet::CardClosure {\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CardSet.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/oome\/heap\/Test.java 8273095 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach002a\/TestDescription.java 8265795 generic-all\n-vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach022\/TestDescription.java 8265795 generic-all\n@@ -80,0 +78,2 @@\n+compiler\/onSpinWait\/TestOnSpinWaitAArch64DefaultFlags.java 8277503 linux-aarch64\n+\n@@ -95,0 +95,2 @@\n+applications\/jcstress\/acqrel.java 8277434 linux-aarch64\n+\n@@ -108,0 +110,1 @@\n+runtime\/ErrorHandling\/CreateCoredumpOnCrash.java 8267433 macosx-x64\n@@ -121,4 +124,7 @@\n-serviceability\/sa\/ClhsdbCDSCore.java 8269982 macosx-aarch64\n-serviceability\/sa\/ClhsdbFindPC.java#xcomp-core 8269982 macosx-aarch64\n-serviceability\/sa\/ClhsdbFindPC.java#no-xcomp-core 8269982 macosx-aarch64\n-serviceability\/sa\/ClhsdbPstack.java#core 8269982 macosx-aarch64\n+serviceability\/sa\/ClhsdbCDSCore.java 8269982,8267433 macosx-aarch64,macosx-x64\n+serviceability\/sa\/ClhsdbFindPC.java#xcomp-core 8269982,8267433 macosx-aarch64,macosx-x64\n+serviceability\/sa\/ClhsdbFindPC.java#no-xcomp-core 8269982,8267433 macosx-aarch64,macosx-x64\n+serviceability\/sa\/ClhsdbPmap.java#core 8267433 macosx-x64\n+serviceability\/sa\/ClhsdbPstack.java#core 8269982,8267433 macosx-aarch64,macosx-x64\n+serviceability\/sa\/TestJmapCore.java 8267433 macosx-x64\n+serviceability\/sa\/TestJmapCoreMetaspace.java 8267433 macosx-x64\n@@ -160,2 +166,0 @@\n-vmTestbase\/nsk\/jvmti\/PopFrame\/popframe011\/TestDescription.java 8266593 generic-all\n-vmTestbase\/nsk\/jvmti\/RedefineClasses\/StressRedefineWithoutBytecodeCorruption\/TestDescription.java 8272800 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,2 +27,7 @@\n-import java.io.IOException;\n-import java.io.File;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.util.CoreUtils;\n+\n@@ -30,0 +35,1 @@\n+import java.io.File;\n@@ -31,0 +37,1 @@\n+import java.io.IOException;\n@@ -39,8 +46,0 @@\n-import java.util.regex.Pattern;\n-import java.util.regex.Matcher;\n-import jdk.test.lib.Platform;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.util.CoreUtils;\n@@ -299,0 +298,37 @@\n+\n+    protected void removeVersionFromReplayFile() {\n+        setNewVersionLineInReplayFile(null);\n+    }\n+\n+    protected void setNewVersionInReplayFile(int newVersionNumber) {\n+        setNewVersionLineInReplayFile(\"version \" + newVersionNumber);\n+    }\n+\n+    private void setNewVersionLineInReplayFile(String firstLineString) {\n+        List<String> newLines = new ArrayList<>();\n+        Path replayFilePath = Paths.get(getReplayFileName());\n+        try (var br = Files.newBufferedReader(replayFilePath)) {\n+            String line;\n+            boolean firstLine = true;\n+            while ((line = br.readLine()) != null) {\n+                if (firstLine) {\n+                    firstLine = false;\n+                    Asserts.assertTrue(line.startsWith(\"version\"), \"version number must exist in a proper replay file\");\n+                    if (firstLineString != null) {\n+                        newLines.add(firstLineString);\n+                    }\n+                    \/\/ Else: Remove first line by skipping it.\n+                } else {\n+                    newLines.add(line);\n+                }\n+            }\n+            Asserts.assertFalse(firstLine, replayFilePath + \" should not be empty\");\n+        } catch (IOException e) {\n+            throw new Error(\"Failed to read replay data: \" + e, e);\n+        }\n+        try {\n+            Files.write(replayFilePath, newLines, StandardOpenOption.TRUNCATE_EXISTING);\n+        } catch (IOException e) {\n+            throw new Error(\"Failed to write replay data: \" + e, e);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/CiReplayBase.java","additions":46,"deletions":10,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.ciReplay;\n+\n+import jdk.test.lib.Asserts;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public abstract class InliningBase extends DumpReplayBase {\n+    public static final String LOG_FILE_NORMAL = \"hotspot_normal.log\";\n+    public static final String LOG_FILE_REPLAY = \"hotspot_replay.log\";\n+    protected final String[] commandLineReplay;\n+    protected final List<String> commandLineNormal;\n+    protected final Class<?> testClass;\n+\n+    protected InliningBase(Class<?> testClass) {\n+        this.testClass = testClass;\n+        commandLineNormal = new ArrayList<>(List.of(\"-XX:LogFile=\" + LOG_FILE_NORMAL + \"\", \"-XX:+LogCompilation\", \"-XX:-TieredCompilation\",\n+                                                                 \"-XX:CompileCommand=exclude,\" + testClass.getName() + \"::main\",\n+                                                                 \"-XX:CompileCommand=option,\" + testClass.getName() + \"::test,bool,PrintInlining,true\"));\n+        commandLineReplay = new String[]\n+                {\"-XX:LogFile=\" + LOG_FILE_REPLAY, \"-XX:+LogCompilation\",\n+                 \"-XX:CompileCommand=option,\" + testClass.getName()  + \"::test,bool,PrintInlining,true\"};\n+    }\n+\n+    protected void runTest() {\n+        runTest(commandLineNormal.toArray(new String[0]));\n+    }\n+\n+    @Override\n+    public String getTestClass() {\n+        return testClass.getName();\n+    }\n+\n+    @Override\n+    public void cleanup() {\n+        super.cleanup();\n+        remove(LOG_FILE_NORMAL);\n+        remove(LOG_FILE_REPLAY);\n+    }\n+\n+    static class InlineEntry {\n+        String klass;\n+        String method;\n+        String reason;\n+\n+        public InlineEntry(String klass, String method, String reason) {\n+            this.klass = klass;\n+            this.method = method;\n+            this.reason = reason;\n+        }\n+\n+        public boolean isNormalInline() {\n+            return reason.equals(\"inline (hot)\");\n+        }\n+\n+        public boolean isForcedByReplay() {\n+            return reason.equals(\"force inline by ciReplay\");\n+        }\n+\n+        public boolean isDisallowedByReplay() {\n+            return reason.equals(\"disallowed by ciReplay\");\n+        }\n+\n+        public boolean isUnloadedSignatureClasses() {\n+            return reason.equals(\"unloaded signature classes\");\n+        }\n+\n+        public boolean isForcedIncrementalInlineByReplay() {\n+            return reason.equals(\"force (incremental) inline by ciReplay\");\n+        }\n+\n+        public boolean isForcedInline() {\n+            return reason.equals(\"force inline by annotation\");\n+        }\n+\n+        public boolean isTooDeep() {\n+            return reason.equals(\"inlining too deep\");\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (other == this) {\n+                return true;\n+            }\n+\n+            if (!(other instanceof InlineEntry)) {\n+                return false;\n+            }\n+\n+            InlineEntry e = (InlineEntry)other;\n+            return klass.equals(e.klass) && method.equals(e.method);\n+        }\n+\n+        public boolean compare(String klass, String method, boolean kind) {\n+            return this.klass.equals(klass) && this.method.equals(method) && kind;\n+        }\n+    }\n+\n+    protected static List<InlineEntry> parseLogFile(String logFile, String rootMethod, String nmethodMatch, int inlineeCount) {\n+        String nmethodStart = \"<nmethod\";\n+        List<InlineEntry> inlinees = new ArrayList<>();\n+        int foundLines = 0;\n+        try (var br = Files.newBufferedReader(Paths.get(logFile))) {\n+            String line;\n+            boolean nmethodLine = false;\n+            boolean inlinineLine = false;\n+            while ((line = br.readLine()) != null) {\n+                if (nmethodLine) {\n+                    \/\/ Ignore other entries which could be in between nmethod entry and inlining statements\n+                    if (line.startsWith(\"             \")) {\n+                        inlinineLine = true;\n+                        Pattern p = Pattern.compile(\"(\\\\S+)::(\\\\S+).*bytes\\\\)\\s+(.*)\");\n+                        Matcher matcher = p.matcher(line);\n+                        Asserts.assertTrue(matcher.find(), \"must find inlinee method\");\n+                        inlinees.add(new InlineEntry(matcher.group(1), matcher.group(2), matcher.group(3).trim()));\n+                        foundLines++;\n+                    } else if (inlinineLine) {\n+                        Asserts.assertEQ(foundLines, inlineeCount, \"did not find all inlinees\");\n+                        return inlinees;\n+                    }\n+                } else {\n+                    nmethodLine = line.startsWith(nmethodStart) && line.contains(nmethodMatch);\n+                    if (nmethodLine) {\n+                        Asserts.assertTrue(line.contains(rootMethod), \"should only dump inline information for \" + rootMethod);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new Error(\"Failed to read \" + logFile + \" data: \" + e, e);\n+        }\n+        Asserts.fail(\"Should have found inlinees\");\n+        return inlinees;\n+    }\n+\n+    protected void verifyLists(List<InlineEntry> inlineesNormal, List<InlineEntry> inlineesReplay, int expectedSize) {\n+        if (!inlineesNormal.equals(inlineesReplay)) {\n+            System.err.println(\"Normal entries:\");\n+            inlineesNormal.forEach(System.err::println);\n+            System.err.println(\"Replay entries:\");\n+            inlineesReplay.forEach(System.err::println);\n+            Asserts.fail(\"different inlining decision in normal run vs. replay run\");\n+        }\n+        Asserts.assertEQ(expectedSize, inlineesNormal.size(), \"unexpected number of inlinees found\");\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/InliningBase.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8254108\n+ * @library \/ \/test\/lib\n+ * @summary Testing of ciReplay with incremental inlining.\n+ * @requires vm.flightRecorder != true & vm.compMode != \"Xint\" & vm.compMode != \"Xcomp\" & vm.debug == true & vm.compiler2.enabled\n+ * @modules java.base\/jdk.internal.misc\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      compiler.ciReplay.TestIncrementalInlining\n+ *\/\n+\n+package compiler.ciReplay;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class TestIncrementalInlining extends InliningBase {\n+\n+    private List<InlineEntry> inlineesNormal;\n+    private List<InlineEntry> inlineesReplay;\n+    public static void main(String[] args) {\n+        new TestIncrementalInlining();\n+    }\n+\n+    TestIncrementalInlining() {\n+        super(IncrementalInliningTest.class);\n+        \/\/ Enable Whitebox access for test VM.\n+        commandLineNormal.add(\"-Dtest.jdk=\" + Utils.TEST_JDK);\n+        commandLineNormal.add(\"-cp\");\n+        commandLineNormal.add(Utils.TEST_CLASS_PATH);\n+        commandLineNormal.add(\"-Xbootclasspath\/a:.\");\n+        commandLineNormal.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        commandLineNormal.add(\"-XX:+WhiteBoxAPI\");\n+        commandLineNormal.add(\"-XX:MaxInlineLevel=2\");\n+        commandLineNormal.add(\"-XX:-AlwaysIncrementalInline\");\n+        runTest();\n+    }\n+\n+    @Override\n+    public void testAction() {\n+        positiveTest(commandLineReplay);\n+        inlineesNormal = parseLogFile(LOG_FILE_NORMAL, getTestClass() + \" \" + \"test\", \"compile_id='\" + getCompileIdFromFile(getReplayFileName()), 5);\n+        verify(true);\n+\n+        \/\/ Incremental inlining is supported in version 2+\n+        \/\/ Test replay file version 1.\n+        removeIncrementalInlineInfo();\n+        setNewVersionInReplayFile(1);\n+        positiveTest(commandLineReplay);\n+        verify(false);\n+\n+        \/\/ Test replay file without version.\n+        removeVersionFromReplayFile();\n+        positiveTest(commandLineReplay);\n+        verify(false);\n+    }\n+\n+    private void verify(boolean isNewFormat) {\n+        inlineesReplay = parseLogFile(LOG_FILE_REPLAY, getTestClass() + \" \" + \"test\", \"test ()V\", 5);\n+        verifyLists(inlineesNormal, inlineesReplay, 5);\n+        checkInlining(isNewFormat);\n+    }\n+\n+    \/\/ Check if inlining is done correctly in ciReplay.\n+    private void checkInlining(boolean isNewFormat) {\n+        String klass = getTestClass();\n+        Asserts.assertTrue(inlineesNormal.get(0).compare(klass, \"level0\", inlineesNormal.get(0).isForcedInline()));\n+        Asserts.assertTrue(inlineesReplay.get(0).compare(klass, \"level0\", inlineesReplay.get(0).isForcedByReplay()));\n+        Asserts.assertTrue(inlineesNormal.get(1).compare(klass, \"level1\", inlineesNormal.get(1).isNormalInline()));\n+        Asserts.assertTrue(inlineesReplay.get(1).compare(klass, \"level1\", inlineesReplay.get(1).isForcedByReplay()));\n+        Asserts.assertTrue(inlineesNormal.get(2).compare(klass, \"level2\", inlineesNormal.get(2).isForcedInline()));\n+        Asserts.assertTrue(inlineesReplay.get(2).compare(klass, \"level2\", inlineesReplay.get(2).isForcedByReplay()));\n+        Asserts.assertTrue(inlineesNormal.get(3).compare(klass, \"late\", inlineesNormal.get(3).isForcedInline()));\n+        Asserts.assertTrue(inlineesReplay.get(3).compare(klass, \"late\", isNewFormat ?\n+                inlineesReplay.get(3).isForcedIncrementalInlineByReplay()\n+                : inlineesReplay.get(3).isForcedByReplay()));\n+        Asserts.assertTrue(inlineesNormal.get(4).compare(klass, \"level4\", inlineesNormal.get(4).isTooDeep()));\n+        Asserts.assertTrue(inlineesReplay.get(4).compare(klass, \"level4\", inlineesReplay.get(4).isDisallowedByReplay()));\n+    }\n+\n+    private void removeIncrementalInlineInfo() {\n+        try {\n+            Path replayFilePath = Paths.get(getReplayFileName());\n+            List<String> replayContent = Files.readAllLines(replayFilePath);\n+            for (int i = 0; i < replayContent.size(); i++) {\n+                String line = replayContent.get(i);\n+                if (line.startsWith(\"compile \")) {\n+                    int lastIndex = 0;\n+                    StringBuilder newLine = new StringBuilder();\n+                    Pattern p = Pattern.compile(\"(\\\\d (-?\\\\d)) \\\\d compiler\");\n+                    Matcher m = p.matcher(line);\n+                    boolean firstMatch = true;\n+                    while (m.find()) {\n+                        newLine.append(line, lastIndex, m.start())\n+                              .append(m.group(1))\n+                              .append(\" compiler\");\n+                        lastIndex = m.end();\n+                        String bci = m.group(2);\n+                        Asserts.assertTrue(firstMatch ? bci.equals(\"-1\") : bci.equals(\"0\"), \"only root has -1\");\n+                        firstMatch = false;\n+                    }\n+                    Asserts.assertLessThan(lastIndex, line.length(), \"not reached end of line, yet\");\n+                    newLine.append(line, lastIndex, line.length());\n+                    replayContent.set(i, newLine.toString());\n+                }\n+            }\n+            Files.write(replayFilePath, replayContent, StandardOpenOption.TRUNCATE_EXISTING);\n+        } catch (IOException ioe) {\n+            throw new Error(\"Failed to read\/write replay data: \" + ioe, ioe);\n+        }\n+    }\n+}\n+\n+class IncrementalInliningTest {\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    private static String s;\n+\n+    public static void main(String[] args) throws NoSuchMethodException {\n+        WB.testSetForceInlineMethod(IncrementalInliningTest.class.getDeclaredMethod(\"level0\"), true);\n+        WB.testSetForceInlineMethod(IncrementalInliningTest.class.getDeclaredMethod(\"level2\"), true);\n+        WB.testSetForceInlineMethod(IncrementalInliningTest.class.getDeclaredMethod(\"late\"), true);\n+        for (int i = 0; i < 10000; i++) {\n+            test();\n+        }\n+    }\n+\n+    private static void test() {\n+        level0();\n+    }\n+\n+    public static void level0() {\n+        level1();\n+    }\n+\n+    public static void level1() {\n+        level2();\n+    }\n+\n+    public static void level2() {\n+        late();\n+    }\n+\n+    \/\/ Reached max inline level but forced to be inlined -> inline late.\n+    public static void late() {\n+        level4();\n+    }\n+\n+    \/\/ Reached max inline level and not forced to be inlined -> no inline.\n+    public static void level4() {\n+        s = \"HelloWorld\";\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/TestIncrementalInlining.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -31,4 +31,1 @@\n- * @build sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n- *      compiler.ciReplay.TestInliningProtectionDomain\n+ * @run driver compiler.ciReplay.TestInliningProtectionDomain\n@@ -41,4 +38,0 @@\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.util.ArrayList;\n@@ -46,2 +39,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -49,6 +40,1 @@\n-public class TestInliningProtectionDomain extends DumpReplayBase {\n-    public static final String LOG_FILE_NORMAL = \"hotspot_normal.log\";\n-    public static final String LOG_FILE_REPLAY = \"hotspot_replay.log\";\n-    private final String[] commandLineReplay;\n-\n-    private final String className;\n+public class TestInliningProtectionDomain extends InliningBase {\n@@ -57,4 +43,4 @@\n-        new TestInliningProtectionDomain(\"ProtectionDomainTestCompiledBefore\", true);\n-        new TestInliningProtectionDomain(\"ProtectionDomainTestNoOtherCompilationPublic\", false);\n-        new TestInliningProtectionDomain(\"ProtectionDomainTestNoOtherCompilationPrivate\", false);\n-        new TestInliningProtectionDomain(\"ProtectionDomainTestNoOtherCompilationPrivateString\", false);\n+        new TestInliningProtectionDomain(ProtectionDomainTestCompiledBefore.class, true);\n+        new TestInliningProtectionDomain(ProtectionDomainTestNoOtherCompilationPublic.class, false);\n+        new TestInliningProtectionDomain(ProtectionDomainTestNoOtherCompilationPrivate.class, false);\n+        new TestInliningProtectionDomain(ProtectionDomainTestNoOtherCompilationPrivateString.class, false);\n@@ -63,5 +49,2 @@\n-    public TestInliningProtectionDomain(String className, boolean compileBar) {\n-        this.className = className;\n-        List<String> commandLineNormal = new ArrayList<>(List.of(\"-XX:LogFile=\" + LOG_FILE_NORMAL + \"\", \"-XX:+LogCompilation\", \"-XX:-TieredCompilation\",\n-                                                           \"-XX:CompileCommand=exclude,\" + getTestClass() + \"::main\",\n-                                                           \"-XX:CompileCommand=option,\" + getTestClass()  + \"::test,bool,PrintInlining,true\"));\n+    public TestInliningProtectionDomain(Class<?> testClass, boolean compileBar) {\n+        super(testClass);\n@@ -69,1 +52,1 @@\n-            commandLineNormal.add(\"-XX:CompileCommand=compileonly,\" + getTestClass() + \"::bar\");\n+            commandLineNormal.add(\"-XX:CompileCommand=compileonly,\" + testClass.getName() + \"::bar\");\n@@ -71,4 +54,1 @@\n-        commandLineReplay = new String[]\n-                {\"-XX:LogFile=\" + LOG_FILE_REPLAY + \"\", \"-XX:+LogCompilation\",\n-                 \"-XX:CompileCommand=option,\" + getTestClass()  + \"::test,bool,PrintInlining,true\"};\n-        runTest(commandLineNormal.toArray(new String[0]));\n+        runTest();\n@@ -80,3 +60,2 @@\n-        String klass = \"compiler.ciReplay.\" + className;\n-        String entryString = klass + \" \" + \"test\";\n-        boolean inlineFails = className.equals(\"ProtectionDomainTestNoOtherCompilationPrivate\");\n+        String entryString = getTestClass() + \" \" + \"test\";\n+        boolean inlineFails = testClass == ProtectionDomainTestNoOtherCompilationPrivate.class;\n@@ -85,2 +64,2 @@\n-        List<Entry> inlineesNormal = parseLogFile(LOG_FILE_NORMAL, entryString, \"compile_id='\" + getCompileIdFromFile(getReplayFileName()), inlineeCount);\n-        List<Entry> inlineesReplay = parseLogFile(LOG_FILE_REPLAY, entryString, \"test ()V\", inlineeCount);\n+        List<InlineEntry> inlineesNormal = parseLogFile(LOG_FILE_NORMAL, entryString, \"compile_id='\" + getCompileIdFromFile(getReplayFileName()), inlineeCount);\n+        List<InlineEntry> inlineesReplay = parseLogFile(LOG_FILE_REPLAY, entryString, \"test ()V\", inlineeCount);\n@@ -90,4 +69,2 @@\n-            Asserts.assertTrue(compare(inlineesNormal.get(0), \"compiler.ciReplay.ProtectionDomainTestNoOtherCompilationPrivate\",\n-                                       \"bar\", inlineesNormal.get(0).isUnloadedSignatureClasses()));\n-            Asserts.assertTrue(compare(inlineesReplay.get(0), \"compiler.ciReplay.ProtectionDomainTestNoOtherCompilationPrivate\",\n-                                       \"bar\", inlineesReplay.get(0).isDisallowedByReplay()));\n+            Asserts.assertTrue(inlineesNormal.get(0).compare(\"compiler.ciReplay.ProtectionDomainTestNoOtherCompilationPrivate\", \"bar\", inlineesNormal.get(0).isUnloadedSignatureClasses()));\n+            Asserts.assertTrue(inlineesReplay.get(0).compare(\"compiler.ciReplay.ProtectionDomainTestNoOtherCompilationPrivate\", \"bar\", inlineesReplay.get(0).isDisallowedByReplay()));\n@@ -95,103 +72,2 @@\n-            Asserts.assertTrue(compare(inlineesNormal.get(4), \"compiler.ciReplay.InliningBar\", \"bar2\", inlineesNormal.get(4).isNormalInline()));\n-            Asserts.assertTrue(compare(inlineesReplay.get(4), \"compiler.ciReplay.InliningBar\", \"bar2\", inlineesReplay.get(4).isForcedByReplay()));\n-        }\n-        remove(LOG_FILE_NORMAL);\n-        remove(LOG_FILE_REPLAY);\n-    }\n-\n-    private void verifyLists(List<Entry> inlineesNormal, List<Entry> inlineesReplay, int expectedSize) {\n-        if (!inlineesNormal.equals(inlineesReplay)) {\n-            System.err.println(\"Normal entries:\");\n-            inlineesNormal.forEach(System.err::println);\n-            System.err.println(\"Replay entries:\");\n-            inlineesReplay.forEach(System.err::println);\n-            Asserts.fail(\"different inlining decision in normal run vs. replay run\");\n-        }\n-        Asserts.assertEQ(expectedSize, inlineesNormal.size(), \"unexpected number of inlinees found\");\n-    }\n-\n-    public static boolean compare(Entry e, String klass, String method, boolean kind) {\n-        return e.klass.equals(klass) && e.method.equals(method) && kind;\n-    }\n-\n-    public static List<Entry> parseLogFile(String logFile, String rootMethod, String nmethodMatch, int inlineeCount) {\n-        String nmethodStart = \"<nmethod\";\n-        List<Entry> inlinees = new ArrayList<>();\n-        int foundLines = 0;\n-        try (var br = Files.newBufferedReader(Paths.get(logFile))) {\n-            String line;\n-            boolean nmethodLine = false;\n-            boolean inlinineLine = false;\n-            while ((line = br.readLine()) != null) {\n-                if (nmethodLine) {\n-                    \/\/ Ignore other entries which could be in between nmethod entry and inlining statements\n-                    if (line.startsWith(\"             \")) {\n-                        inlinineLine = true;\n-                        Pattern p = Pattern.compile(\"(\\\\S+)::(\\\\S+).*bytes\\\\)\\s+(.*)\");\n-                        Matcher matcher = p.matcher(line);\n-                        Asserts.assertTrue(matcher.find(), \"must find inlinee method\");\n-                        inlinees.add(new Entry(matcher.group(1), matcher.group(2), matcher.group(3).trim()));\n-                        foundLines++;\n-                    } else if (inlinineLine) {\n-                        Asserts.assertEQ(foundLines, inlineeCount, \"did not find all inlinees\");\n-                        return inlinees;\n-                    }\n-                } else {\n-                    nmethodLine = line.startsWith(nmethodStart) && line.contains(nmethodMatch);\n-                    if (nmethodLine) {\n-                        Asserts.assertTrue(line.contains(rootMethod), \"should only dump inline information for \" + rootMethod);\n-                    }\n-                }\n-            }\n-        } catch (IOException e) {\n-            throw new Error(\"Failed to read \" + logFile + \" data: \" + e, e);\n-        }\n-        Asserts.fail(\"Should have found inlinees\");\n-        return inlinees;\n-    }\n-\n-\n-    @Override\n-    public String getTestClass() {\n-        return \"compiler.ciReplay.\" + className;\n-    }\n-\n-    static class Entry {\n-        String klass;\n-        String method;\n-        String reason;\n-\n-        public Entry(String klass, String method, String reason) {\n-            this.klass = klass;\n-            this.method = method;\n-            this.reason = reason;\n-        }\n-\n-        public boolean isNormalInline() {\n-            return reason.equals(\"inline (hot)\");\n-        }\n-\n-        public boolean isForcedByReplay() {\n-            return reason.equals(\"force inline by ciReplay\");\n-        }\n-\n-        public boolean isDisallowedByReplay() {\n-            return reason.equals(\"disallowed by ciReplay\");\n-        }\n-\n-        public boolean isUnloadedSignatureClasses() {\n-            return reason.equals(\"unloaded signature classes\");\n-        }\n-\n-        @Override\n-        public boolean equals(Object other) {\n-            if (other == this) {\n-                return true;\n-            }\n-\n-            if (!(other instanceof Entry)) {\n-                return false;\n-            }\n-\n-            Entry e = (Entry)other;\n-            return klass.equals(e.klass) && method.equals(e.method);\n+            Asserts.assertTrue(inlineesNormal.get(4).compare(\"compiler.ciReplay.InliningBar\", \"bar2\", inlineesNormal.get(4).isNormalInline()));\n+            Asserts.assertTrue(inlineesReplay.get(4).compare(\"compiler.ciReplay.InliningBar\", \"bar2\", inlineesReplay.get(4).isForcedByReplay()));\n","filename":"test\/hotspot\/jtreg\/compiler\/ciReplay\/TestInliningProtectionDomain.java","additions":18,"deletions":142,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    byte[] a3 = new byte[ARRLEN];\n@@ -97,0 +98,10 @@\n+      test_addImm127(a1, a2);\n+      test_addImm(a1, a2, a3);\n+      test_addImm256(a1, a2);\n+      test_addImmNeg128(a1, a2);\n+      test_addImmNeg129(a1, a2);\n+      test_subImm(a1, a2, a3);\n+      test_andImm21(a1, a2);\n+      test_andImm7(a1, a2);\n+      test_orImm(a1, a2);\n+      test_xorImm(a1, a2, a3);\n@@ -490,0 +501,71 @@\n+      byte base = (byte) 10;\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (byte) 10;\n+      }\n+      byte golden = (byte)(base + 127);\n+      test_addImm127(a1, a2);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm127: a2\", i, a2[i], golden);\n+      }\n+      test_addImm(a1, a2, a3);\n+      golden = (byte)(base + 8);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a2\", i, a2[i], golden);\n+      }\n+      golden = (byte) (base + 255);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a3\", i, a3[i], golden);\n+      }\n+      test_addImm256(a1, a2);\n+      golden = (byte)(base + 256);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm256: a3\", i, a2[i], golden);\n+      }\n+      test_addImmNeg128(a1, a2);\n+      golden = (byte)(base + (-128));\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImmNeg128: a2\", i, a2[i], golden);\n+      }\n+      test_addImmNeg129(a1, a2);\n+      golden = (byte)(base + (-129));\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImmNeg129: a2\", i, a2[i], golden);\n+      }\n+      \/\/ Reset for sub test\n+      base = (byte) 120;\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (byte) 120;\n+      }\n+      test_subImm(a1, a2, a3);\n+      golden = (byte) (base - 56);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm: a2\", i, a2[i], golden);\n+      }\n+      golden = (byte) (base - 256);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm: a3\", i, a3[i], golden);\n+      }\n+      test_andImm21(a1, a2);\n+      golden = (byte) (base & 21);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm21: a2\", i, a2[i], golden);\n+      }\n+      test_andImm7(a1, a2);\n+      golden = (byte) (base & 7);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm7: a2\", i, a2[i], golden);\n+      }\n+      test_orImm(a1, a2);\n+      golden = (byte) (base | 3);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_orImm: a2\", i, a2[i], golden);\n+      }\n+      test_xorImm(a1, a2, a3);\n+      golden = (byte) (base ^ 127);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xorImm: a2\", i, a2[i], golden);\n+      }\n+      golden = (byte) (base ^ 255);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xorImm: a3\", i, a3[i], golden);\n+      }\n@@ -733,0 +815,53 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm127(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm127: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm256(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm256: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImmNeg128(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImmNeg128: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImmNeg129(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImmNeg129: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_andImm7(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_andImm7: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_orImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_orImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_xorImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n@@ -948,0 +1083,53 @@\n+  static void test_addImm127(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] + 127);\n+    }\n+  }\n+  static void test_addImm(byte[] a, byte[] b, byte[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] + 8);\n+      c[i] = (byte) (a[i] + 255);\n+    }\n+  }\n+  static void test_addImm256(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] + 256);\n+    }\n+  }\n+  static void test_addImmNeg128(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] + (-128));\n+    }\n+  }\n+  static void test_addImmNeg129(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] + (-129));\n+    }\n+  }\n+  static void test_subImm(byte[] a, byte[] b, byte[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] - 56);\n+      c[i] = (byte) (a[i] - 256);\n+    }\n+  }\n+  static void test_andImm21(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] & 21);\n+    }\n+  }\n+  static void test_andImm7(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] & 7);\n+    }\n+  }\n+  static void test_orImm(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] | 3);\n+    }\n+  }\n+  static void test_xorImm(byte[] a, byte[] b, byte[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] ^ 127);\n+      c[i] = (byte) (a[i] ^ 255);\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestByteVect.java","additions":189,"deletions":1,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    char[] a3 = new char[ARRLEN];\n@@ -97,0 +98,7 @@\n+      test_addImm129(a1, a2);\n+      test_addImm(a1, a2, a3);\n+      test_subImm56(a1, a2);\n+      test_subImm256(a1, a2);\n+      test_andImm(a1, a2);\n+      test_orImm(a1, a2);\n+      test_xorImm(a1, a2);\n@@ -490,0 +498,50 @@\n+      \/\/ Reset for binary operation with immediate.\n+      char base = (char) 3;\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (char) 3;\n+      }\n+      char golden = (char)(base + 129);\n+      test_addImm129(a1, a2);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm129: a2\", i, a2[i], golden);\n+      }\n+      test_addImm(a1, a2, a3);\n+      golden = (char)(base + 129);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a2\", i, a2[i], golden);\n+      }\n+      golden = (char) (base + 255);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a3\", i, a3[i], golden);\n+      }\n+      \/\/ Reset for sub operation test.\n+      base = (char) 120;\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (char) 120;\n+      }\n+      test_subImm56(a1, a2);\n+      golden = (char) (base - 56);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm56: a2\", i, a2[i], golden);\n+      }\n+      test_subImm256(a1, a2);\n+      golden = (char) (base - 256);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm256: a2\", i, a2[i], golden);\n+      }\n+      test_andImm(a1, a2);\n+      golden = (char) (base & 0xfe);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm: a2\", i, a2[i], golden);\n+      }\n+      test_orImm(a1, a2);\n+      golden = (char) (base | 0xff);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_orImm: a2\", i, a2[i], golden);\n+      }\n+      test_xorImm(a1, a2);\n+      golden = (char) (base ^ 0xc7);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xorImm: a2\", i, a2[i], golden);\n+      }\n+\n@@ -733,0 +791,43 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm129(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm129: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm56(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm56: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm256(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm256: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_andImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_andImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_orImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_orImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_xorImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_xorImm: \" + (end - start));\n+\n@@ -948,0 +1049,41 @@\n+  static void test_addImm129(char[] a, char[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] + 129);\n+    }\n+  }\n+  static void test_addImm(char[] a, char[] b, char[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] + 129);\n+      c[i] = (char) (a[i] + 255);\n+    }\n+  }\n+\n+  static void test_subImm56(char[] a, char[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] - 56);\n+    }\n+  }\n+\n+  static void test_subImm256(char[] a, char[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] - 256);\n+    }\n+  }\n+\n+  static void test_andImm(char[] a, char[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] & 0xfe);\n+    }\n+  }\n+\n+  static void test_orImm(char[] a, char[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] | 0xff);\n+    }\n+  }\n+\n+  static void test_xorImm(char[] a, char[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] ^ 0xc7);\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestCharVect.java","additions":143,"deletions":1,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,2 @@\n+      test_conv_i2f(a1, b1);\n+      test_conv_f2i(a1, b1);\n@@ -341,0 +343,66 @@\n+      \/\/ Reset to test conversion from int to float.\n+      for (int i=0; i<ARRLEN; i++) {\n+        a1[i] = (int)i;\n+      }\n+      test_conv_i2f(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_i2f: a1\", i, b1[i], (float)i);\n+      }\n+      \/\/ Reset to test conversion from float to int.\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = (float)(i+1);\n+      }\n+      test_conv_f2i(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_f2i: a1\", i, a1[i], (i+1));\n+      }\n+      \/\/ Reset to test NAN conversion from int to float.\n+      for (int i=0; i<ARRLEN; i++) {\n+        a1[i] = Integer.MIN_VALUE;\n+      }\n+      test_conv_i2f(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_i2f: a1\", i, b1[i], (float)Integer.MIN_VALUE);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        a1[i] = Integer.MAX_VALUE;\n+      }\n+      test_conv_i2f(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_i2f: a1\", i, b1[i], (float)Integer.MAX_VALUE);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = Float.NaN;\n+      }\n+      test_conv_f2i(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_f2i: a1\", i, a1[i], (int)Float.NaN);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = Float.POSITIVE_INFINITY;\n+      }\n+      test_conv_f2i(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_f2i: a1\", i, a1[i], (int)Float.POSITIVE_INFINITY);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = Float.NEGATIVE_INFINITY;\n+      }\n+      test_conv_f2i(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_f2i: a1\", i, a1[i], (int)Float.NEGATIVE_INFINITY);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = 0.0f;\n+      }\n+      test_conv_f2i(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_f2i: a1\", i, a1[i], (int)0.0);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = -0.0f;\n+      }\n+      test_conv_f2i(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_f2i: a1\", i, a1[i], (int)(-0.0));\n+      }\n@@ -451,0 +519,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_conv_i2f(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_i2f: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_conv_f2i(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_f2i: \" + (end - start));\n@@ -559,0 +639,10 @@\n+  static void test_conv_i2f(int[] a, float[] b){\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (float)a[i];\n+    }\n+  }\n+  static void test_conv_f2i(int[] a, float[] b){\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (int)b[i];\n+    }\n+  }\n@@ -568,1 +658,1 @@\n-    if (elem != val) {\n+    if (elem != val && !(Float.isNaN(elem) && Float.isNaN(val))) {\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestIntFloatVect.java","additions":92,"deletions":2,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    int[] a3 = new int[ARRLEN];\n@@ -97,0 +98,7 @@\n+      test_addImm127(a1, a2);\n+      test_addImm(a1, a2, a3);\n+      test_addImm256(a1, a2);\n+      test_subImm(a1, a2, a3);\n+      test_andImm(a1, a2, a3);\n+      test_orImm(a1, a2);\n+      test_xorImm(a1, a2);\n@@ -490,0 +498,57 @@\n+      \/\/ Reset for binary operation with immediate\n+      int base = 10;\n+      for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = 10;\n+      }\n+      int golden = base + 127;\n+      test_addImm127(a1, a2);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm127: a2\", i, a2[i], golden);\n+      }\n+      test_addImm(a1, a2, a3);\n+      golden = base + 127;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a2\", i, a2[i], golden);\n+      }\n+      golden = base + 255;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a3\", i, a3[i], golden);\n+      }\n+      test_addImm256(a1, a2);\n+      golden = base + 256;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm256: a2\", i, a2[i], golden);\n+      }\n+      \/\/ Reset for sub test\n+      base = 10000;\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = 10000;\n+      }\n+      test_subImm(a1, a2, a3);\n+      golden = base - 2304;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm: a2\", i, a2[i], golden);\n+      }\n+      golden = base - 65280;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm: a3\", i, a3[i], golden);\n+      }\n+      test_andImm(a1, a2, a3);\n+      golden = base + 2560;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm: a2\", i, a2[i], golden);\n+      }\n+      golden = base & 516096;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm: a3\", i, a3[i], golden);\n+      }\n+      test_orImm(a1, a2);\n+      golden = base | 8257536;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_orImm: a2\", i, a2[i], golden);\n+      }\n+      test_xorImm(a1, a2);\n+      golden = base ^ 2032;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xorImm: a2\", i, a2[i], golden);\n+      }\n@@ -733,0 +798,42 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm127(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm127: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm256(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm256: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_andImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_andImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_orImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_orImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_xorImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_xorImm: \" + (end - start));\n@@ -948,0 +1055,44 @@\n+  static void test_addImm127(int[] a, int[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] + 127;\n+    }\n+  }\n+  static void test_addImm(int[] a, int[] b, int[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] + 127;\n+      c[i] = a[i] + 255;\n+    }\n+  }\n+  static void test_addImm256(int[] a, int[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] + 256;\n+    }\n+  }\n+  static void test_subImm(int[] a, int[] b, int[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] - 2304;\n+      c[i] = a[i] - 65280;\n+    }\n+  }\n+  static void test_andImm21(int[] a, int[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] & 21;\n+    }\n+  }\n+  static void test_andImm(int[] a, int[] b, int[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] + 2560;\n+      c[i] = a[i] & 516096;\n+    }\n+  }\n+  static void test_orImm(int[] a, int[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] | 8257536;\n+    }\n+  }\n+  static void test_xorImm(int[] a, int[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] ^ 2032;\n+    }\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestIntVect.java","additions":152,"deletions":1,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,2 @@\n+      test_conv_l2d(a1, b1);\n+      test_conv_d2l(a1, b1);\n@@ -341,0 +343,66 @@\n+      \/\/ Reset to test conversion from int to float.\n+      for (int i=0; i<ARRLEN; i++) {\n+        a1[i] = (long)i;\n+      }\n+      test_conv_l2d(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_l2d: a1\", i, b1[i], (double)i);\n+      }\n+      \/\/ Reset to test conversion from float to int.\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = (double)(i+1);\n+      }\n+      test_conv_d2l(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_d2l: a1\", i, a1[i], (long)(i+1));\n+      }\n+      \/\/ Reset to test special conversion from int to float.\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = Double.NaN;\n+      }\n+      test_conv_d2l(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_d2l: a1\", i, a1[i], (long)Double.NaN);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        a1[i] = Long.MIN_VALUE;\n+      }\n+      test_conv_l2d(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_l2d: a1\", i, b1[i], (double)Long.MIN_VALUE);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        a1[i] = Long.MAX_VALUE;\n+      }\n+      test_conv_l2d(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_l2d: a1\", i, b1[i], (double)Long.MAX_VALUE);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = Double.POSITIVE_INFINITY;\n+      }\n+      test_conv_d2l(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_d2l: a1\", i, a1[i], (long)Double.POSITIVE_INFINITY);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = Double.NEGATIVE_INFINITY;\n+      }\n+      test_conv_d2l(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_d2l: a1\", i, a1[i], (long)Double.NEGATIVE_INFINITY);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = 0.0;\n+      }\n+      test_conv_d2l(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_d2l: a1\", i, a1[i], (long)0.0);\n+      }\n+      for (int i=0; i<ARRLEN; i++) {\n+        b1[i] = -0.0;\n+      }\n+      test_conv_d2l(a1, b1);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_conv_d2l: a1\", i, a1[i], (long)(-0.0));\n+      }\n@@ -451,0 +519,12 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_conv_l2d(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_l2d: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_conv_d2l(a1, b1);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_conv_d2l: \" + (end - start));\n@@ -559,0 +639,10 @@\n+  static void test_conv_l2d(long[] a, double[] b){\n+    for (int i = 0; i < a.length; i+=1) {\n+      b[i] = (double)a[i];\n+    }\n+  }\n+  static void test_conv_d2l(long[] a, double[] b){\n+    for (int i = 0; i < a.length; i+=1) {\n+      a[i] = (long)b[i];\n+    }\n+  }\n@@ -568,1 +658,1 @@\n-    if (elem != val) {\n+    if (elem != val && !(Double.isNaN(elem) && Double.isNaN(val))) {\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestLongDoubleVect.java","additions":92,"deletions":2,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    long[] a3 = new long[ARRLEN];\n@@ -97,0 +98,6 @@\n+      test_addImm(a1, a2, a3);\n+      test_subImm(a1, a2, a3);\n+      test_subImm256(a1, a2);\n+      test_andImm(a1, a2);\n+      test_orImm(a1, a2);\n+      test_xorImm(a1, a2);\n@@ -490,0 +497,47 @@\n+      \/\/ Reset for binary operations with immediate.\n+      for (int i=0; i<ARRLEN; i++) {\n+      a1[i] = 10;\n+      }\n+      long base = 10;\n+      test_addImm(a1, a2, a3);\n+      long golden = base & 516097;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a2\", i, a2[i], golden);\n+      }\n+      golden = base + 65280;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a3\", i, a3[i], golden);\n+      }\n+      base = 120;\n+      for (int i=0; i<ARRLEN; i++) {\n+        a1[i] = 120;\n+      }\n+      test_subImm(a1, a2, a3);\n+      golden = base + 65535;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm: a2\", i, a2[i], golden);\n+      }\n+      golden = base - 2147483647;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm: a3\", i, a3[i], golden);\n+      }\n+      test_subImm256(a1, a2);\n+      golden = base - 256;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm256: a2\", i, a2[i], golden);\n+      }\n+      test_andImm(a1, a2);\n+      golden = base & 132120576;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm: a2\", i, a2[i], golden);\n+      }\n+      test_orImm(a1, a2);\n+      golden = base | 2113929216;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_orImm: a2\", i, a2[i], golden);\n+      }\n+      test_xorImm(a1, a2);\n+      golden = base ^ 516096;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xorImm: a2\", i, a2[i], golden);\n+      }\n@@ -733,0 +787,36 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm256(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm256: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_andImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_andImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_orImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_orImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_xorImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_xorImm: \" + (end - start));\n@@ -949,0 +1039,38 @@\n+  static void test_addImm(long[] a, long[] b, long[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] & 516097;\n+      c[i] = a[i] + 65280;\n+    }\n+  }\n+\n+  static void test_subImm(long[] a, long[] b, long[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] + 65535;\n+      c[i] = a[i] - 2147483647;\n+    }\n+  }\n+\n+  static void test_subImm256(long[] a, long[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] - 256;\n+    }\n+  }\n+\n+  static void test_andImm(long[] a, long[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] & 132120576;\n+    }\n+  }\n+\n+  static void test_orImm(long[] a, long[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] | 2113929216;\n+    }\n+  }\n+\n+  static void test_xorImm(long[] a, long[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] ^ 516096;\n+    }\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestLongVect.java","additions":129,"deletions":1,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    short[] a3 = new short[ARRLEN];\n@@ -97,0 +98,7 @@\n+      test_addImm129(a1, a2);\n+      test_addImm(a1, a2, a3);\n+      test_subImm56(a1, a2);\n+      test_subImm256(a1, a2);\n+      test_andImm(a1, a2);\n+      test_orImm(a1, a2);\n+      test_xorImm(a1, a2);\n@@ -490,0 +498,48 @@\n+      short base = (short) 3;\n+      for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = (short) 3;\n+      }\n+      short golden = (short)(base + 129);\n+      test_addImm129(a1, a2);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm129: a2\", i, a2[i], golden);\n+      }\n+      test_addImm(a1, a2, a3);\n+      golden = (short)(base + 129);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a2\", i, a2[i], golden);\n+      }\n+      golden = (short) (base + 255);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a3\", i, a3[i], golden);\n+      }\n+      \/\/ Reset for sub test\n+      base = (short) 120;\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (short) 120;\n+      }\n+      test_subImm56(a1, a2);\n+      golden = (short) (base - 56);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm56: a2\", i, a2[i], golden);\n+      }\n+      test_subImm256(a1, a2);\n+      golden = (short) (base - 256);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm256: a2\", i, a2[i], golden);\n+      }\n+      test_andImm(a1, a2);\n+      golden = (short) (base & 0xfe);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm: a2\", i, a2[i], golden);\n+      }\n+      test_orImm(a1, a2);\n+      golden = (short) (base | 0xff);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_orImm: a2\", i, a2[i], golden);\n+      }\n+      test_xorImm(a1, a2);\n+      golden = (short) (base ^ 0xc7);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xorImm: a2\", i, a2[i], golden);\n+      }\n@@ -733,0 +789,42 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm129(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm129: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm56(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm56: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm256(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm256: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_andImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_andImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_orImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_orImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_xorImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_xorImm: \" + (end - start));\n@@ -948,0 +1046,37 @@\n+  static void test_addImm129(short[] a, short[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] + 129);\n+    }\n+  }\n+\n+  static void test_addImm(short[] a, short[] b, short[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] + 129);\n+      c[i] = (short) (a[i] + 255);\n+    }\n+  }\n+  static void test_subImm56(short[] a, short[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] - 56);\n+    }\n+  }\n+  static void test_subImm256(short[] a, short[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] - 256);\n+    }\n+  }\n+  static void test_andImm(short[] a, short[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] & 0xfe);\n+    }\n+  }\n+  static void test_orImm(short[] a, short[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] | 0xff);\n+    }\n+  }\n+  static void test_xorImm(short[] a, short[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] ^ 0xc7);\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestShortVect.java","additions":136,"deletions":1,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main\/othervm -ea -XX:-UseSharedSpaces -Diters=30000 -XX:TieredStopAtLevel=1\n+ * @run main\/othervm -ea -Xshare:off -Diters=30000 -XX:TieredStopAtLevel=1\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/klass\/TestIsPrimitive.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -104,1 +104,9 @@\n-        Asserts.assertEQ(str2, str3,\n+        String[] str2Lines = str2.split(System.lineSeparator());\n+        String[] str3Lines = str3.split(System.lineSeparator());\n+        \/\/ skip the first two lines since it contains a timestamp that may vary from different invocations\n+        \/\/ <empty-line>\n+        \/\/ Compiled method (c2)     309  463       4       compiler.jvmci.compilerToVM.CompileCodeTestCase$Dummy::staticMethod (1 bytes)\n+        \/\/ <empty-line>\n+        \/\/ Compiled method (c2)     310  463       4       compiler.jvmci.compilerToVM.CompileCodeTestCase$Dummy::staticMethod (1 bytes)\n+        for (int i = 2; i < str2Lines.length; i++) {\n+            Asserts.assertEQ(str2Lines[i], str3Lines[i],\n@@ -106,0 +114,1 @@\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/DisassembleCodeBlobTest.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test TestOnSpinWaitAArch64DefaultFlags\n+ * @summary Check default values of '-XX:OnSpinWaitInst' and '-XX:OnSpinWaitInstCount' for AArch64 implementations.\n+ * @bug 8277137\n+ * @library \/test\/lib \/\n+ *\n+ * @requires os.arch==\"aarch64\"\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+WhiteBoxAPI\n+ *                   compiler.onSpinWait.TestOnSpinWaitAArch64DefaultFlags\n+ *\/\n+\n+package compiler.onSpinWait;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import sun.hotspot.cpuinfo.CPUInfo;\n+\n+public class TestOnSpinWaitAArch64DefaultFlags {\n+    private static boolean isCPUModelNeoverseN1(String cpuModel) {\n+        return cpuModel.contains(\"0xd0c\");\n+    }\n+\n+    private static void checkFinalFlagsEqualTo(ProcessBuilder pb, String expectedOnSpinWaitInstValue, String expectedOnSpinWaitInstCountValue) throws Exception {\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+        analyzer.shouldHaveExitValue(0);\n+\n+        Iterator<String> iter = analyzer.asLines().listIterator();\n+        String line = null;\n+        boolean hasExpectedOnSpinWaitInstValue = false;\n+        boolean hasExpectedOnSpinWaitInstCountValue = false;\n+        while (iter.hasNext()) {\n+            line = iter.next();\n+            if (!hasExpectedOnSpinWaitInstValue && line.contains(\"ccstr OnSpinWaitInst\")) {\n+                hasExpectedOnSpinWaitInstValue = line.contains(\"= \" + expectedOnSpinWaitInstValue);\n+            }\n+\n+            if (!hasExpectedOnSpinWaitInstCountValue && line.contains(\"uint OnSpinWaitInstCount\")) {\n+                hasExpectedOnSpinWaitInstCountValue = line.contains(\"= \" + expectedOnSpinWaitInstCountValue);\n+            }\n+        }\n+        if (!hasExpectedOnSpinWaitInstValue) {\n+            System.out.println(analyzer.getOutput());\n+            throw new RuntimeException(\"OnSpinWaitInst with the expected value '\" + expectedOnSpinWaitInstValue + \"' not found.\");\n+        }\n+        if (!hasExpectedOnSpinWaitInstCountValue) {\n+            System.out.println(analyzer.getOutput());\n+            throw new RuntimeException(\"OnSpinWaitInstCount with the expected value '\" + expectedOnSpinWaitInstCountValue + \"' not found.\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        List<String> cpuFeatures = CPUInfo.getFeatures();\n+        if (cpuFeatures.isEmpty()) {\n+            System.out.println(\"Skip because no CPU features are available.\");\n+            return;\n+        }\n+\n+        final String cpuModel = cpuFeatures.get(0);\n+\n+        if (isCPUModelNeoverseN1(cpuModel)) {\n+            checkFinalFlagsEqualTo(ProcessTools.createJavaProcessBuilder(\"-XX:+PrintFlagsFinal\", \"-version\"), \"isb\", \"1\");\n+            checkFinalFlagsEqualTo(ProcessTools.createJavaProcessBuilder(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:OnSpinWaitInstCount=2\", \"-XX:+PrintFlagsFinal\", \"-version\"),\n+                \"isb\", \"2\");\n+        } else {\n+            System.out.println(\"Skip because no defaults for CPU model: \" + cpuModel);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/onSpinWait\/TestOnSpinWaitAArch64DefaultFlags.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import jdk.incubator.vector.LongVector;\n+\n+\/*\n+ * @test\n+ * @bug 8275643\n+ * @summary Test that LongVector.neg is properly handled by the _VectorUnaryOp C2 intrinsic\n+ * @modules jdk.incubator.vector\n+ * @requires vm.debug\n+ * @run main\/othervm -XX:-TieredCompilation -XX:+AlwaysIncrementalInline -Xbatch\n+ *                   -XX:CompileCommand=dontinline,compiler.vectorapi.TestLongVectorNeg::test\n+ *                   compiler.vectorapi.TestLongVectorNeg\n+ *\/\n+public class TestLongVectorNeg {\n+\n+    static LongVector test(LongVector v) {\n+        return v.neg();\n+    }\n+\n+    public static void main(String[] args) {\n+        LongVector v = LongVector.zero(LongVector.SPECIES_128);\n+        for (int i = 0; i < 50_000; ++i) {\n+            v.abs(); \/\/ Warmup to make sure the !VO_SPECIAL code path is taken as well\n+            test(v);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestLongVectorNeg.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,4 @@\n+        {\"UseSharedSpaces\",           \"false\"},\n+        {\"RequireSharedSpaces\",       \"false\"},\n+        {\"DumpSharedSpaces\",          \"false\"},\n+        {\"DynamicDumpSharedSpaces\",   \"false\"},\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMDeprecatedOptions.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4,1 +4,0 @@\n-import java.util.ArrayList;\n@@ -6,1 +5,0 @@\n-import java.util.List;\n@@ -143,0 +141,3 @@\n+        System.out.println(\"context used words \" + usageMeasured + \", committed words \" + committedMeasured\n+                + \".\");\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/elastic\/MetaspaceTestContext.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -86,0 +86,13 @@\n+        \/\/ At this point a large number of Arenas will have died (see above), but we probably still have\n+        \/\/  some live arenas left. The chunk freelist will be full of free chunks. Maybe a bit fragmented,\n+        \/\/  with a healthy mixture of larger and smaller chunks, since we still have live arenas.\n+        \/\/ These chunks are all committed still, since we did nothing to reclaim the storage. We now purge\n+        \/\/  the context manually to uncommit those chunks, in order to get a realistic number for\n+        \/\/  committed words (see checkStatistics()).\n+        \/\/ Note: In real metaspace, this happens as part of the same GC which removes class loaders and\n+        \/\/  frees their metaspace arenas. All within CLDG::purge(). But since this test isolates the metaspace\n+        \/\/  context and does test it separately, GC and CLDG are not involved here. We need to purge manually.\n+        \/\/\n+        \/\/ Purging uncommits all free chunks >= 64K\/16K (MetaspaceReclaimPolicy=standard\/aggressive).\n+        context.purge();\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/elastic\/MetaspaceTestManyArenasManyThreads.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-    private static boolean isUseSharedSpacesDisabled() {\n+    public static boolean isUseSharedSpacesDisabled() {\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DynamicArchiveTestBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -183,4 +183,8 @@\n-        run2(null, topArchiveName,\n-             \"-XX:+RecordDynamicDumpInfo\",\n-             \"-cp\", appJar, mainClass)\n-            .assertAbnormalExit(\"-XX:+RecordDynamicDumpInfo is unsupported when a dynamic CDS archive is specified in -XX:SharedArchiveFile:\");\n+        if (isUseSharedSpacesDisabled()) {\n+            System.out.println(\"This test is not applicable when JTREG tests are executed with -Xshare:off, or if the JDK doesn't have a default archive.\");\n+        } else {\n+          run2(null, topArchiveName,\n+               \"-XX:+RecordDynamicDumpInfo\",\n+               \"-cp\", appJar, mainClass)\n+              .assertAbnormalExit(\"-XX:+RecordDynamicDumpInfo is unsupported when a dynamic CDS archive is specified in -XX:SharedArchiveFile:\");\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/SharedArchiveFileOption.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+        pbArgs.add(\"-XX:-CreateCoredumpOnCrash\");\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/TestPrimitiveArrayCriticalWithBadParam.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Verifies that a VMObjectAlloc event is generated for object created using MethodHandle\n+ * @requires vm.jvmti\n+ * @run main\/othervm\/native -agentlib:VMObjectAlloc VMObjectAllocTest\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+\n+public class VMObjectAllocTest {\n+\n+    private static native int getNumberOfAllocation();\n+\n+    public VMObjectAllocTest(String str) {\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+\n+        MethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\n+        MethodType mt = MethodType.methodType(void.class, String.class);\n+        MethodHandle mh = publicLookup.findConstructor(VMObjectAllocTest.class, mt);\n+        mh.invoke(\"str\");\n+\n+        if (getNumberOfAllocation() != 1) {\n+            throw new Exception(\"Number of allocation != 1\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/VMObjectAlloc\/VMObjectAllocTest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include \"jvmti.h\"\n+\n+extern \"C\" {\n+\n+static int number_of_allocation = 0;\n+\n+extern JNIEXPORT void JNICALL\n+VMObjectAlloc(jvmtiEnv *jvmti,\n+              JNIEnv* jni,\n+              jthread thread,\n+              jobject object,\n+              jclass cls,\n+              jlong size) {\n+  char *signature = NULL;\n+  jvmtiError err = jvmti->GetClassSignature(cls, &signature, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    jni->FatalError(\"Failed during the GetClassSignature call\");\n+  }\n+\n+  printf(\"VMObjectAlloc called for %s\\n\", signature);\n+\n+  if (!strcmp(signature, \"LVMObjectAllocTest;\")) {\n+    number_of_allocation++;\n+  }\n+}\n+\n+\n+JNIEXPORT jint JNICALL\n+Java_VMObjectAllocTest_getNumberOfAllocation(JNIEnv *env, jclass cls) {\n+  return number_of_allocation;\n+}\n+\n+extern JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiEnv *jvmti;\n+  jvmtiEventCallbacks callbacks;\n+  jvmtiError err;\n+  jvmtiCapabilities caps;\n+\n+  if (jvm->GetEnv((void **) &jvmti, JVMTI_VERSION) != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.VMObjectAlloc = &VMObjectAlloc;\n+  memset(&caps, 0, sizeof(caps));\n+  caps.can_generate_vm_object_alloc_events = 1;\n+\n+  err = jvmti->AddCapabilities( &caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(jvmtiEventCallbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC , NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+} \/\/extern \"C\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/VMObjectAlloc\/libVMObjectAlloc.cpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,1 @@\n+                                               .addToolArg(\"-J-Xmx1G\")\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/share\/GenClassesBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -151,2 +151,2 @@\n-                } catch (OutOfMemoryError | ClassNotFoundException e) {\n-                    \/\/ just ignore\n+                } catch (OutOfMemoryError | ClassNotFoundException | NoClassDefFoundError e) {\n+                    \/\/ just ignore, note that CNFE and NCDFE can be caused by OOM exceptions.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/sysdict\/share\/SysDictTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-        if (!\"Java heap space\".equals(message)) {\n+        if (!message.startsWith(\"Java heap space\")) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/oome\/heap\/Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-java\/awt\/FullScreen\/FullScreenInsets\/FullScreenInsets.java 7019055,8266245 windows-all,linux-all,macosx-aarch64\n+java\/awt\/FullScreen\/FullScreenInsets\/FullScreenInsets.java 7019055,8266245 windows-all,linux-all,macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,4 @@\n+    \/\/ move away from cursor\n+    private final static int OFFSET_X = -20;\n+    private final static int OFFSET_Y = -20;\n+\n@@ -104,1 +108,1 @@\n-        Color c = r.getPixelColor(p.x + f.getWidth() \/ 2, p.y + f.getHeight() \/ 2);\n+        Color c = r.getPixelColor(p.x + f.getWidth() \/ 2 - OFFSET_X, p.y + f.getHeight() \/ 2 - OFFSET_Y);\n","filename":"test\/jdk\/java\/awt\/Dialog\/MakeWindowAlwaysOnTop\/MakeWindowAlwaysOnTop.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n- * @bug 8147440 8147016\n+ * @bug 8147440 8147016 8270874\n","filename":"test\/jdk\/java\/awt\/Window\/WindowResizingOnDPIChanging\/WindowResizingOnMovingToAnotherDisplay.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+\n+\/**\n+ * @test\n+ * @bug 8276970\n+ * @summary Test to verify the charset in PrintStream is inherited\n+ *      in the OutputStreamWriter\/PrintWriter\n+ * @run testng InheritEncodingTest\n+ *\/\n+@Test\n+public class InheritEncodingTest {\n+\n+    private static final String testString = \"\\u00e9\\u3042\"; \/\/ \"\"\n+\n+    @DataProvider\n+    public Object[][] encodings() {\n+        return new Object[][]{\n+                {StandardCharsets.ISO_8859_1},\n+                {StandardCharsets.US_ASCII},\n+                {StandardCharsets.UTF_8},\n+                {StandardCharsets.UTF_16},\n+                {StandardCharsets.UTF_16BE},\n+                {StandardCharsets.UTF_16LE},\n+        };\n+    }\n+\n+    @Test (dataProvider = \"encodings\")\n+    public void testOutputStreamWriter(Charset stdCharset) throws IOException {\n+        var ba = new ByteArrayOutputStream();\n+        var ps = new PrintStream(ba, true, stdCharset);\n+        var expected = new String(testString.getBytes(stdCharset), stdCharset);\n+\n+        \/\/ tests OutputStreamWriter's encoding explicitly\n+        var osw = new OutputStreamWriter(ps);\n+        assertEquals(Charset.forName(osw.getEncoding()), stdCharset);\n+\n+        \/\/ tests roundtrip result\n+        osw.write(testString);\n+        osw.flush();\n+        var result = ba.toString(stdCharset);\n+        assertEquals(result, expected);\n+    }\n+\n+    @Test (dataProvider = \"encodings\")\n+    public void testPrintWriter(Charset stdCharset) throws IOException {\n+        var ba = new ByteArrayOutputStream();\n+        var ps = new PrintStream(ba, true, stdCharset);\n+        var expected = new String(testString.getBytes(stdCharset), stdCharset);\n+\n+        \/\/ tests roundtrip result\n+        var pw = new PrintWriter(ps);\n+        pw.write(testString);\n+        pw.flush();\n+        var result = ba.toString(stdCharset);\n+        assertEquals(result, expected);\n+    }\n+\n+    @Test (dataProvider = \"encodings\")\n+    public void testPrintStream(Charset stdCharset) throws IOException {\n+        var ba = new ByteArrayOutputStream();\n+        var ps = new PrintStream(ba, true, stdCharset);\n+        var expected = new String(testString.getBytes(stdCharset), stdCharset);\n+\n+        \/\/ tests PrintStream's charset explicitly\n+        var psWrapper = new PrintStream(ps);\n+        assertEquals(psWrapper.charset(), stdCharset);\n+\n+        \/\/ tests roundtrip result\n+        psWrapper.print(testString);\n+        psWrapper.flush();\n+        var result = ba.toString(stdCharset);\n+        assertEquals(result, expected);\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/PrintStream\/InheritEncodingTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,582 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8277451\n+ * @run testng\/othervm -Djdk.reflect.useDirectMethodHandle=true NegativeTest\n+ * @run testng\/othervm -Djdk.reflect.useDirectMethodHandle=false NegativeTest\n+ * @summary Test exception thrown due to bad receiver and bad value on\n+ *          Field with and without setAccessible(true)\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class NegativeTest {\n+    static class Fields {\n+        public static int si;\n+        public static char sc;\n+        public static byte sb;\n+        public static short ss;\n+        public static long sl;\n+        public static double sd;\n+        public static float sf;\n+        public static boolean sz;\n+        public static String so;\n+\n+        public static final int sfi = 10;\n+        public static final char sfc = 'a';\n+        public static final byte sfb = 1;\n+        public static final short sfs = 2;\n+        public static final long sfl = 1000L;\n+        public static final double sfd = 1.0;\n+        public static final float sff = 2.0f;\n+        public static final boolean sfz = true;\n+        public static final String sfo = \"abc\";\n+\n+        public int i;\n+        public char c;\n+        public byte b;\n+        public short s;\n+        public long l;\n+        public double d;\n+        public float f;\n+        public boolean z;\n+        public String o;\n+\n+        public final int fi = 10;\n+        public final char fc = 'a';\n+        public final byte fb = 1;\n+        public final short fs = 2;\n+        public final long fl = 1000L;\n+        public final double fd = 1.0;\n+        public final float ff = 2.0f;\n+        public final boolean fz = true;\n+        public final String fo = \"abc\";\n+    }\n+\n+    static final Field i_field = field(\"i\", false);\n+    static final Field c_field = field(\"c\", false);\n+    static final Field b_field = field(\"b\", false);\n+    static final Field s_field = field(\"s\", false);\n+    static final Field l_field = field(\"l\", false);\n+    static final Field d_field = field(\"d\", false);\n+    static final Field f_field = field(\"f\", false);\n+    static final Field z_field = field(\"z\", false);\n+    static final Field o_field = field(\"o\", false);\n+    static final Field fi_field = field(\"fi\", false);\n+    static final Field fc_field = field(\"fc\", false);\n+    static final Field fb_field = field(\"fb\", false);\n+    static final Field fs_field = field(\"fs\", false);\n+    static final Field fl_field = field(\"fl\", false);\n+    static final Field fd_field = field(\"fd\", false);\n+    static final Field ff_field = field(\"ff\", false);\n+    static final Field fz_field = field(\"fz\", false);\n+    static final Field fo_field = field(\"fo\", false);\n+\n+    static final Field override_i_field = field(\"i\", true);\n+    static final Field override_c_field = field(\"c\", true);\n+    static final Field override_b_field = field(\"b\", true);\n+    static final Field override_s_field = field(\"s\", true);\n+    static final Field override_l_field = field(\"l\", true);\n+    static final Field override_d_field = field(\"d\", true);\n+    static final Field override_f_field = field(\"f\", true);\n+    static final Field override_z_field = field(\"z\", true);\n+    static final Field override_o_field = field(\"o\", true);\n+    static final Field override_fi_field = field(\"fi\", true);\n+    static final Field override_fc_field = field(\"fc\", true);\n+    static final Field override_fb_field = field(\"fb\", true);\n+    static final Field override_fs_field = field(\"fs\", true);\n+    static final Field override_fl_field = field(\"fl\", true);\n+    static final Field override_fd_field = field(\"fd\", true);\n+    static final Field override_ff_field = field(\"ff\", true);\n+    static final Field override_fz_field = field(\"fz\", true);\n+    static final Field override_fo_field = field(\"fo\", true);\n+\n+    static final Field si_field = field(\"si\", false);\n+    static final Field sc_field = field(\"sc\", false);\n+    static final Field sb_field = field(\"sb\", false);\n+    static final Field ss_field = field(\"ss\", false);\n+    static final Field sl_field = field(\"sl\", false);\n+    static final Field sd_field = field(\"sd\", false);\n+    static final Field sf_field = field(\"sf\", false);\n+    static final Field sz_field = field(\"sz\", false);\n+    static final Field so_field = field(\"so\", false);\n+    static final Field sfi_field = field(\"sfi\", false);\n+    static final Field sfc_field = field(\"sfc\", false);\n+    static final Field sfb_field = field(\"sfb\", false);\n+    static final Field sfs_field = field(\"sfs\", false);\n+    static final Field sfl_field = field(\"sfl\", false);\n+    static final Field sfd_field = field(\"sfd\", false);\n+    static final Field sff_field = field(\"sff\", false);\n+    static final Field sfz_field = field(\"sfz\", false);\n+    static final Field sfo_field = field(\"sfo\", false);\n+\n+    static final Field override_si_field = field(\"si\", true);\n+    static final Field override_sc_field = field(\"sc\", true);\n+    static final Field override_sb_field = field(\"sb\", true);\n+    static final Field override_ss_field = field(\"ss\", true);\n+    static final Field override_sl_field = field(\"sl\", true);\n+    static final Field override_sd_field = field(\"sd\", true);\n+    static final Field override_sf_field = field(\"sf\", true);\n+    static final Field override_sz_field = field(\"sz\", true);\n+    static final Field override_so_field = field(\"so\", true);\n+    static final Field override_sfi_field = field(\"sfi\", true);\n+    static final Field override_sfc_field = field(\"sfc\", true);\n+    static final Field override_sfb_field = field(\"sfb\", true);\n+    static final Field override_sfs_field = field(\"sfs\", true);\n+    static final Field override_sfl_field = field(\"sfl\", true);\n+    static final Field override_sfd_field = field(\"sfd\", true);\n+    static final Field override_sff_field = field(\"sff\", true);\n+    static final Field override_sfz_field = field(\"sfz\", true);\n+    static final Field override_sfo_field = field(\"sfo\", true);\n+\n+    private static Field field(String name, boolean suppressAccessCheck) {\n+        try {\n+            Field f = Fields.class.getDeclaredField(name);\n+            if (suppressAccessCheck) {\n+                f.setAccessible(true);\n+            }\n+            return f;\n+        } catch (ReflectiveOperationException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @DataProvider(name = \"instanceFields\")\n+    private Object[][] instanceFields() {\n+        return new Object[][]{\n+                new Object[]{i_field},\n+                new Object[]{c_field},\n+                new Object[]{b_field},\n+                new Object[]{s_field},\n+                new Object[]{l_field},\n+                new Object[]{d_field},\n+                new Object[]{f_field},\n+                new Object[]{z_field},\n+                new Object[]{o_field},\n+                new Object[]{override_i_field},\n+                new Object[]{override_c_field},\n+                new Object[]{override_b_field},\n+                new Object[]{override_s_field},\n+                new Object[]{override_l_field},\n+                new Object[]{override_d_field},\n+                new Object[]{override_f_field},\n+                new Object[]{override_z_field},\n+                new Object[]{override_o_field},\n+                \/\/ final instance fields\n+                new Object[]{fi_field},\n+                new Object[]{fc_field},\n+                new Object[]{fb_field},\n+                new Object[]{fs_field},\n+                new Object[]{fl_field},\n+                new Object[]{fd_field},\n+                new Object[]{ff_field},\n+                new Object[]{fz_field},\n+                new Object[]{fo_field},\n+                new Object[]{override_fi_field},\n+                new Object[]{override_fc_field},\n+                new Object[]{override_fb_field},\n+                new Object[]{override_fs_field},\n+                new Object[]{override_fl_field},\n+                new Object[]{override_fd_field},\n+                new Object[]{override_ff_field},\n+                new Object[]{override_fz_field},\n+                new Object[]{override_fo_field},\n+        };\n+    }\n+    private static Fields INSTANCE = new Fields();\n+\n+    \/*\n+     * Test Field::get on a good receiver, a bad receiver and null.\n+     *\n+     * IllegalArgumentException is thrown if the receiver is of\n+     * a bad type.  NullPointerException is thrown if the receiver is null.\n+     *\/\n+    @Test(dataProvider = \"instanceFields\")\n+    public void testReceiver(Field f) throws ReflectiveOperationException {\n+        f.get(INSTANCE);     \/\/ good receiver\n+\n+        testBadReceiver(f);\n+        testNullReceiver(f);\n+    }\n+\n+    \/*\n+     * IllegalArgumentException should be thrown for bad receiver type\n+     *\/\n+    private void testBadReceiver(Field f) throws ReflectiveOperationException {\n+        assertFalse(Modifier.isStatic(f.getModifiers()));  \/\/ instance field\n+        Object badObj = new NegativeTest();\n+        try {\n+            f.get(badObj);\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            \/\/ expected\n+        }\n+        Class<?> fType = f.getType();\n+        if (fType.isPrimitive()) {\n+            try {\n+                switch (fType.descriptorString()) {\n+                    case \"B\" -> f.getByte(badObj);\n+                    case \"C\" -> f.getChar(badObj);\n+                    case \"D\" -> f.getDouble(badObj);\n+                    case \"F\" -> f.getFloat(badObj);\n+                    case \"I\" -> f.getInt(badObj);\n+                    case \"J\" -> f.getLong(badObj);\n+                    case \"S\" -> f.getShort(badObj);\n+                    case \"Z\" -> f.getBoolean(badObj);\n+                }\n+                fail(\"expected IllegalArgumentException\");\n+            } catch (IllegalArgumentException e) {\n+                \/\/ expected\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * NullPointerException should be thrown for null receiver\n+     *\/\n+    private void testNullReceiver(Field f) throws ReflectiveOperationException {\n+        assertFalse(Modifier.isStatic(f.getModifiers()));  \/\/ instance field\n+        try {\n+            f.get(null);\n+            fail(\"expected NullPointerException\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        }\n+\n+        Class<?> fType = f.getType();\n+        if (fType.isPrimitive()) {\n+            try {\n+                switch (fType.descriptorString()) {\n+                    case \"B\" -> f.getByte(null);\n+                    case \"C\" -> f.getChar(null);\n+                    case \"D\" -> f.getDouble(null);\n+                    case \"F\" -> f.getFloat(null);\n+                    case \"I\" -> f.getInt(null);\n+                    case \"J\" -> f.getLong(null);\n+                    case \"S\" -> f.getShort(null);\n+                    case \"Z\" -> f.getBoolean(null);\n+                }\n+                fail(\"expected NullPointerException\");\n+            } catch (NullPointerException e) {\n+                \/\/ expected\n+            }\n+        }\n+    }\n+\n+    @DataProvider(name = \"writeableFields\")\n+    private Object[][] writeableFields() {\n+        Fields obj = new Fields();\n+        return new Object[][]{\n+                \/\/ instance fields with and without setAccessible(true)\n+                new Object[]{i_field, obj, Integer.valueOf(10)},\n+                new Object[]{c_field, obj, Character.valueOf('c')},\n+                new Object[]{b_field, obj, Byte.valueOf((byte)1)},\n+                new Object[]{s_field, obj, Short.valueOf((short)2)},\n+                new Object[]{l_field, obj, Long.valueOf(1000)},\n+                new Object[]{d_field, obj, Double.valueOf(1.2)},\n+                new Object[]{f_field, obj, Float.valueOf(2.5f)},\n+                new Object[]{z_field, obj, Boolean.valueOf(true)},\n+                new Object[]{o_field, obj, \"good-value\"},\n+                new Object[]{override_i_field, obj, Integer.valueOf(10)},\n+                new Object[]{override_c_field, obj, Character.valueOf('c')},\n+                new Object[]{override_b_field, obj, Byte.valueOf((byte)1)},\n+                new Object[]{override_s_field, obj, Short.valueOf((short)2)},\n+                new Object[]{override_l_field, obj, Long.valueOf(1000)},\n+                new Object[]{override_d_field, obj, Double.valueOf(1.2)},\n+                new Object[]{override_f_field, obj, Float.valueOf(2.5f)},\n+                new Object[]{override_z_field, obj, Boolean.valueOf(true)},\n+                new Object[]{override_o_field, obj, \"good-value\"},\n+                \/\/ instance final fields with setAccessible(true)\n+                new Object[]{override_fi_field, obj, Integer.valueOf(10)},\n+                new Object[]{override_fc_field, obj, Character.valueOf('c')},\n+                new Object[]{override_fb_field, obj, Byte.valueOf((byte)1)},\n+                new Object[]{override_fs_field, obj, Short.valueOf((short)2)},\n+                new Object[]{override_fl_field, obj, Long.valueOf(1000)},\n+                new Object[]{override_fd_field, obj, Double.valueOf(1.2)},\n+                new Object[]{override_ff_field, obj, Float.valueOf(2.5f)},\n+                new Object[]{override_fz_field, obj, Boolean.valueOf(true)},\n+                new Object[]{override_fo_field, obj, \"good-value\"},\n+                \/\/ static fields with and without setAccessible(true)\n+                new Object[]{si_field, null, Integer.valueOf(10)},\n+                new Object[]{sc_field, null, Character.valueOf('c')},\n+                new Object[]{sb_field, null, Byte.valueOf((byte)1)},\n+                new Object[]{ss_field, null, Short.valueOf((short)2)},\n+                new Object[]{sl_field, null, Long.valueOf(1000)},\n+                new Object[]{sd_field, null, Double.valueOf(1.2)},\n+                new Object[]{sf_field, null, Float.valueOf(2.5f)},\n+                new Object[]{sz_field, null, Boolean.valueOf(true)},\n+                new Object[]{so_field, null, \"good-value\"},\n+                new Object[]{override_si_field, null, Integer.valueOf(10)},\n+                new Object[]{override_sc_field, null, Character.valueOf('c')},\n+                new Object[]{override_sb_field, null, Byte.valueOf((byte)1)},\n+                new Object[]{override_ss_field, null, Short.valueOf((short)2)},\n+                new Object[]{override_sl_field, null, Long.valueOf(1000)},\n+                new Object[]{override_sd_field, null, Double.valueOf(1.2)},\n+                new Object[]{override_sf_field, null, Float.valueOf(2.5f)},\n+                new Object[]{override_sz_field, null, Boolean.valueOf(true)},\n+                new Object[]{override_so_field, null, \"good-value\"},\n+        };\n+    }\n+\n+    \/*\n+     * Test Field::set with a good and bad value.\n+     * Test setting to null if the field type is primitive.\n+     *\n+     * IllegalArgumentException is thrown if the value is of a bad type or null.\n+     * NullPointerException is thrown if the receiver of an instance field is null.\n+     * The receiver is checked\n+     *\/\n+    @Test(dataProvider = \"writeableFields\")\n+    public void testSetValue(Field f, Object obj, Object value) throws IllegalAccessException {\n+        f.set(obj, value);\n+        Class<?> fType = f.getType();\n+        if (fType.isPrimitive()) {\n+            switch (fType.descriptorString()) {\n+                case \"B\" -> f.setByte(obj, ((Byte) value).byteValue());\n+                case \"C\" -> f.setChar(obj, ((Character) value).charValue());\n+                case \"D\" -> f.setDouble(obj, ((Double) value).doubleValue());\n+                case \"F\" -> f.setFloat(obj, ((Float) value).floatValue());\n+                case \"I\" -> f.setInt(obj, ((Integer) value).intValue());\n+                case \"J\" -> f.setLong(obj, ((Long) value).longValue());\n+                case \"S\" -> f.setShort(obj, ((Short) value).shortValue());\n+                case \"Z\" -> f.setBoolean(obj, ((Boolean) value).booleanValue());\n+            }\n+\n+            \/\/ test null value only if it's primitive type\n+            try {\n+                f.set(obj, null);\n+                fail(\"expected IllegalArgumentException\");\n+            } catch (IllegalArgumentException e) {\n+                \/\/ expected\n+            }\n+        }\n+\n+        Object badValue = new NegativeTest();\n+        try {\n+            f.set(obj, badValue);\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+    @DataProvider(name = \"readOnlyFinalFields\")\n+    private Object[][] readOnlyFinalFields() {\n+        Object obj = INSTANCE;\n+        return new Object[][]{\n+                \/\/ instance final fields\n+                new Object[]{fi_field, obj, Integer.valueOf(10)},\n+                new Object[]{fc_field, obj, Character.valueOf('c')},\n+                new Object[]{fb_field, obj, Byte.valueOf((byte)1)},\n+                new Object[]{fs_field, obj, Short.valueOf((short)2)},\n+                new Object[]{fl_field, obj, Long.valueOf(1000)},\n+                new Object[]{fd_field, obj, Double.valueOf(1.2)},\n+                new Object[]{ff_field, obj, Float.valueOf(2.5f)},\n+                new Object[]{fz_field, obj, Boolean.valueOf(true)},\n+                new Object[]{fo_field, obj, \"good-value\"},\n+                \/\/ static final fields\n+                new Object[]{sfi_field, null, Integer.valueOf(10)},\n+                new Object[]{sfc_field, null, Character.valueOf('c')},\n+                new Object[]{sfb_field, null, Byte.valueOf((byte)1)},\n+                new Object[]{sfs_field, null, Short.valueOf((short)2)},\n+                new Object[]{sfl_field, null, Long.valueOf(1000)},\n+                new Object[]{sfd_field, null, Double.valueOf(1.2)},\n+                new Object[]{sff_field, null, Float.valueOf(2.5f)},\n+                new Object[]{sfz_field, null, Boolean.valueOf(true)},\n+                new Object[]{sfo_field, null, \"good-value\"},\n+                new Object[]{override_sfi_field, null, Integer.valueOf(10)},\n+                new Object[]{override_sfc_field, null, Character.valueOf('c')},\n+                new Object[]{override_sfb_field, null, Byte.valueOf((byte)1)},\n+                new Object[]{override_sfs_field, null, Short.valueOf((short)2)},\n+                new Object[]{override_sfl_field, null, Long.valueOf(1000)},\n+                new Object[]{override_sfd_field, null, Double.valueOf(1.2)},\n+                new Object[]{override_sff_field, null, Float.valueOf(2.5f)},\n+                new Object[]{override_sfz_field, null, Boolean.valueOf(true)},\n+                new Object[]{override_sfo_field, null, \"good-value\"},\n+        };\n+    }\n+\n+    \/*\n+     * Test Field::set on a read-only final field.\n+     * IllegalAccessException is thrown regardless of whether the value\n+     * is of a bad type or not.\n+     *\/\n+    @Test(dataProvider = \"readOnlyFinalFields\")\n+    public void testSetValueOnFinalField(Field f, Object obj, Object value) {\n+        assertTrue(Modifier.isFinal(f.getModifiers()));\n+        try {\n+            f.set(obj, value);\n+            fail(\"expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            \/\/ expected\n+        }\n+\n+        Class<?> fType = f.getType();\n+        if (fType.isPrimitive()) {\n+            try {\n+                switch (fType.descriptorString()) {\n+                    case \"B\" -> f.setByte(obj, ((Byte)value).byteValue());\n+                    case \"C\" -> f.setChar(obj, ((Character)value).charValue());\n+                    case \"D\" -> f.setDouble(obj, ((Double)value).doubleValue());\n+                    case \"F\" -> f.setFloat(obj, ((Float)value).floatValue());\n+                    case \"I\" -> f.setInt(obj, ((Integer)value).intValue());\n+                    case \"J\" -> f.setLong(obj, ((Long)value).longValue());\n+                    case \"S\" -> f.setShort(obj, ((Short)value).shortValue());\n+                    case \"Z\" -> f.setBoolean(obj, ((Boolean)value).booleanValue());\n+                }\n+                fail(\"expected IllegalAccessException\");\n+            } catch (IllegalAccessException e) {\n+                \/\/ expected\n+            }\n+\n+            \/\/ test null value only if it's primitive type\n+            try {\n+                f.set(obj, null);\n+                fail(\"expected IllegalAccessException\");\n+            } catch (IllegalAccessException e) {\n+                \/\/ expected\n+            }\n+        }\n+\n+        Object badValue = new NegativeTest();\n+        try {\n+            f.set(obj, badValue);\n+            fail(\"expected IllegalAccessException\");\n+        } catch (IllegalAccessException e) {\n+            \/\/ expected\n+        }\n+    }\n+\n+\n+\n+    @DataProvider(name = \"finalInstanceFields\")\n+    private Object[][] finalInstanceFields() {\n+        return new Object[][]{\n+                new Object[]{fi_field, Integer.valueOf(10)},\n+                new Object[]{fc_field, Character.valueOf('c')},\n+                new Object[]{fb_field, Byte.valueOf((byte) 1)},\n+                new Object[]{fs_field, Short.valueOf((short) 2)},\n+                new Object[]{fl_field, Long.valueOf(1000)},\n+                new Object[]{fd_field, Double.valueOf(1.2)},\n+                new Object[]{ff_field, Float.valueOf(2.5f)},\n+                new Object[]{fz_field, Boolean.valueOf(true)},\n+                new Object[]{fo_field, \"good-value\"},\n+        };\n+    }\n+\n+    \/*\n+     * Test Field::set on a final instance field with either a bad receiver\n+     * or null.  IllegalArgumentException is thrown if the receiver is of\n+     * a bad type.  NullPointerException is thrown if the receiver is null.\n+     * The receiver is checked before the access check is performed and\n+     * also before the value is checked.\n+     *\/\n+    @Test(dataProvider = \"finalInstanceFields\")\n+    public void testReceiverOnFinalField(Field f, Object value) {\n+        assertTrue(Modifier.isFinal(f.getModifiers()));\n+        Object badReceiver = new NegativeTest();\n+        \/\/ set the field with a bad receiver with a good value\n+        try {\n+            f.set(badReceiver, value);\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            \/\/ expected\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Expected IllegalArgumentException but got: \" + e.getMessage(), e);\n+        }\n+\n+        \/\/ set the field with a bad receiver with a bad value\n+        Object badValue = new NegativeTest();\n+        try {\n+            f.set(badReceiver, badValue);\n+            fail(\"expected IllegalArgumentException\");\n+        } catch (IllegalArgumentException e) {\n+            \/\/ expected\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Expected IllegalArgumentException but got: \" + e.getMessage(), e);\n+        }\n+\n+        \/\/ set the field with a null receiver with a good value\n+        try {\n+            f.set(null, value);\n+            fail(\"expected NullPointerException\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Expected NullPointerException but got: \" + e.getMessage(), e);\n+        }\n+        \/\/ set the field with a null receiver with a bad value\n+        try {\n+            f.set(null, badValue);\n+            fail(\"expected NullPointerException\");\n+        } catch (NullPointerException e) {\n+            \/\/ expected\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(\"Expected NullPointerException but got: \" + e.getMessage(), e);\n+        }\n+\n+        Class<?> fType = f.getType();\n+        if (fType.isPrimitive()) {\n+            \/\/ test bad receiver\n+            try {\n+                switch (fType.descriptorString()) {\n+                    case \"B\" -> f.setByte(badReceiver, ((Byte) value).byteValue());\n+                    case \"C\" -> f.setChar(badReceiver, ((Character) value).charValue());\n+                    case \"D\" -> f.setDouble(badReceiver, ((Double) value).doubleValue());\n+                    case \"F\" -> f.setFloat(badReceiver, ((Float) value).floatValue());\n+                    case \"I\" -> f.setInt(badReceiver, ((Integer) value).intValue());\n+                    case \"J\" -> f.setLong(badReceiver, ((Long) value).longValue());\n+                    case \"S\" -> f.setShort(badReceiver, ((Short) value).shortValue());\n+                    case \"Z\" -> f.setBoolean(badReceiver, ((Boolean) value).booleanValue());\n+                }\n+            } catch (IllegalArgumentException e) {\n+            } catch (IllegalAccessException e) {\n+                throw new RuntimeException(\"Expected IllegalArgumentException but got: \" + e.getMessage(), e);\n+            }\n+            \/\/ test null receiver\n+            try {\n+                switch (fType.descriptorString()) {\n+                    case \"B\" -> f.setByte(null, ((Byte) value).byteValue());\n+                    case \"C\" -> f.setChar(null, ((Character) value).charValue());\n+                    case \"D\" -> f.setDouble(null, ((Double) value).doubleValue());\n+                    case \"F\" -> f.setFloat(null, ((Float) value).floatValue());\n+                    case \"I\" -> f.setInt(null, ((Integer) value).intValue());\n+                    case \"J\" -> f.setLong(null, ((Long) value).longValue());\n+                    case \"S\" -> f.setShort(null, ((Short) value).shortValue());\n+                    case \"Z\" -> f.setBoolean(null, ((Boolean) value).booleanValue());\n+                }\n+            } catch (NullPointerException e) {\n+                \/\/ expected\n+            } catch (IllegalAccessException e) {\n+                throw new RuntimeException(\"Expected NullPointerException but got: \" + e.getMessage(), e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/NegativeTest.java","additions":582,"deletions":0,"binary":false,"changes":582,"status":"added"},{"patch":"@@ -118,0 +118,2 @@\n+        private static String name = \"name\";\n+        private byte b = 9;\n@@ -133,0 +135,5 @@\n+        public Public(byte b) {\n+            this.b = b;\n+            this.i = 0;\n+            this.s = null;\n+        }\n@@ -165,0 +172,1 @@\n+                   \", b=\" + b +\n@@ -388,2 +396,5 @@\n-    private static final Throwable[] cannot_get_final_field = new Throwable[] {\n-            new IllegalArgumentException(\"Can not get final\")\n+    private static final Throwable[] cannot_get_field = new Throwable[] {\n+            new IllegalArgumentException(\"Can not get\")\n+    };\n+    private static final Throwable[] cannot_set_field = new Throwable[] {\n+            new IllegalArgumentException(\"Can not set\")\n@@ -391,2 +402,2 @@\n-    private static final Throwable[] cannot_set_final_field = new Throwable[] {\n-            new IllegalArgumentException(\"Can not set final\")\n+    private static final Throwable[] mismatched_field_type = new Throwable[] {\n+            new IllegalArgumentException(\"Can not set\")\n@@ -595,0 +606,1 @@\n+        String wrongInst = new String();\n@@ -598,2 +610,0 @@\n-                new Object[]{\"s\", new Object(), \"test\",\n-                             newImpl ? cannot_get_final_field : cannot_set_final_field},\n@@ -601,0 +611,4 @@\n+                new Object[]{\"s\", wrongInst, \"test\",\n+                        newImpl ? cannot_get_field : cannot_set_field},\n+                new Object[]{\"b\", wrongInst, 0,\n+                        newImpl ? cannot_get_field : cannot_set_field},\n@@ -605,0 +619,2 @@\n+        Object o = new Object();\n+        byte b = 1;\n@@ -607,0 +623,1 @@\n+                new Object[]{\"i\", new Public(100), 100, Integer.valueOf(10), noException},\n@@ -608,3 +625,0 @@\n-                \/\/ ## no exception thrown\n-                \/\/ new Object[]{\"i\", new Public(100), 100, new Object(), cannot_set_final_field},\n-                new Object[]{\"s\", new Object(), \"test\", \"dummy\", cannot_set_final_field},\n@@ -612,0 +626,4 @@\n+                new Object[]{\"b\", new Public(b), b, null, mismatched_field_type},\n+                new Object[]{\"b\", new Public(b), b, Long.valueOf(10), mismatched_field_type},\n+                new Object[]{\"name\", null, \"name\", o, mismatched_field_type},\n+                new Object[]{\"i\", new Public(100), 100, o, mismatched_field_type},\n","filename":"test\/jdk\/java\/lang\/reflect\/MethodHandleAccessorsTest.java","additions":27,"deletions":9,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -334,2 +334,2 @@\n-                } else if (cookie.size() == 2 && !cookie.get(1).equals(\"ORDER=BISCUITS\")) {\n-                    String msg = \"Incorrect cookie header value:[\" + cookie.get(0) + \"]\";\n+                } else if (cookie.size() > 1 && !cookie.get(1).equals(\"ORDER=BISCUITS\")) {\n+                    String msg = \"Incorrect cookie header value:[\" + cookie.get(1) + \"]\";\n","filename":"test\/jdk\/java\/net\/httpclient\/CookieHeaderTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8203433\n+ * @bug 8203433 8276559\n@@ -51,1 +51,0 @@\n-import javax.net.ServerSocketFactory;\n@@ -55,4 +54,0 @@\n-import java.io.OutputStream;\n-import java.io.OutputStreamWriter;\n-import java.io.PrintWriter;\n-import java.io.Writer;\n@@ -61,2 +56,0 @@\n-import java.net.ServerSocket;\n-import java.net.Socket;\n@@ -69,13 +62,0 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.StringTokenizer;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.atomic.AtomicLong;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n@@ -84,2 +64,0 @@\n-import static java.nio.charset.StandardCharsets.UTF_8;\n-import static java.net.HttpURLConnection.HTTP_OK;\n@@ -87,1 +65,0 @@\n-import static org.testng.Assert.assertTrue;\n@@ -101,2 +78,0 @@\n-    static final String MESSAGE = \"Basic HeadTest message body\";\n-    static final int ITERATIONS = 3;\n@@ -136,2 +111,0 @@\n-    static final AtomicLong requestCounter = new AtomicLong();\n-\n@@ -142,5 +115,0 @@\n-        HttpClient client = HttpClient.newBuilder()\n-                .followRedirects(Redirect.ALWAYS)\n-                .sslContext(sslContext)\n-                .build();\n-\n@@ -148,1 +116,0 @@\n-\n@@ -152,1 +119,0 @@\n-\n@@ -156,1 +122,21 @@\n-        HttpRequest request = requestBuilder.build();\n+        doTest(requestBuilder.build(), expResp);\n+        \/\/ repeat the test this time by building the request using convenience\n+        \/\/ GET and HEAD methods\n+        requestBuilder = HttpRequest.newBuilder(uri);\n+        if (version != null) {\n+            requestBuilder.version(version);\n+        }\n+        switch (method) {\n+            case \"GET\" -> requestBuilder.GET();\n+            case \"HEAD\" -> requestBuilder.HEAD();\n+            default -> throw new IllegalArgumentException(\"Unexpected method \" + method);\n+        }\n+        doTest(requestBuilder.build(), expResp);\n+    }\n+\n+    \/\/ issue a request with no body and verify the response code is the expected response code\n+    private void doTest(HttpRequest request, int expResp) throws Exception {\n+        HttpClient client = HttpClient.newBuilder()\n+                .followRedirects(Redirect.ALWAYS)\n+                .sslContext(sslContext)\n+                .build();\n","filename":"test\/jdk\/java\/net\/httpclient\/HeadTest.java","additions":23,"deletions":37,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @bug 8170064\n+ * @bug 8170064 8276559\n@@ -159,0 +159,1 @@\n+        test0(\"HEAD\", () -> HttpRequest.newBuilder(TEST_URI).HEAD().build(), null);\n@@ -257,1 +258,3 @@\n-\n+        method(\"newBuilder(TEST_URI).HEAD().build().method() == HEAD\",\n+                () -> HttpRequest.newBuilder(TEST_URI).HEAD(),\n+                \"HEAD\");\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRequestBuilderTest.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-* @bug 8252304\n+* @bug 8252304 8276559\n@@ -123,0 +123,1 @@\n+                { HttpRequest.newBuilder(URI.create(\"https:\/\/method-0\/\")).HEAD().build() },\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpRequestNewBuilderTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8276559\n@@ -163,0 +164,4 @@\n+        request = newBuilder(uri).HEAD().build();\n+        assertEquals(request.method(), \"HEAD\");\n+        assertFalse(request.bodyPublisher().isPresent());\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/RequestBuilderTest.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,3 @@\n- * @bug 8199851\n- * @summary Test for multiple vs single cookie header for HTTP\/2 vs HTTP\/1.1\n+ * @bug 8276774\n+ * @summary Test that user-supplied cookies are appended to\n+ *          server-cookies for HTTP\/2 vs HTTP\/1.1\n@@ -40,1 +41,1 @@\n- *       CookieHeaderTest\n+ *       UserCookieTest\n@@ -43,11 +44,0 @@\n-import com.sun.net.httpserver.HttpServer;\n-import com.sun.net.httpserver.HttpsConfigurator;\n-import com.sun.net.httpserver.HttpsServer;\n-import jdk.test.lib.net.SimpleSSLContext;\n-import org.testng.annotations.AfterTest;\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import javax.net.ServerSocketFactory;\n-import javax.net.ssl.SSLContext;\n@@ -61,1 +51,0 @@\n-import java.net.CookieManager;\n@@ -75,1 +64,0 @@\n-import java.util.HashMap;\n@@ -85,0 +73,11 @@\n+import javax.net.ServerSocketFactory;\n+import javax.net.ssl.SSLContext;\n+\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n@@ -89,1 +88,0 @@\n-import static org.testng.Assert.assertTrue;\n@@ -91,1 +89,1 @@\n-public class CookieHeaderTest implements HttpServerAdapters {\n+public class UserCookieTest implements HttpServerAdapters {\n@@ -156,0 +154,5 @@\n+        String userCookie = \"PRICE=42\";\n+        List<String> expectedCookies =\n+                Stream.concat(cookies.stream(), Stream.of(userCookie)).toList();\n+\n+\n@@ -158,1 +161,2 @@\n-                .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet());\n+                .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                .header(\"Cookie\", userCookie);\n@@ -175,1 +179,1 @@\n-                    cookies.stream()\n+                    expectedCookies.stream()\n@@ -177,1 +181,1 @@\n-                            .collect(Collectors.toList()));\n+                            .toList());\n@@ -179,1 +183,2 @@\n-                    .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet());\n+                    .header(\"X-uuid\", \"uuid-\" + requestCounter.incrementAndGet())\n+                    .header(\"Cookie\", userCookie);\n@@ -245,1 +250,1 @@\n-        @Override\n+        @java.lang.Override\n@@ -252,1 +257,1 @@\n-        @Override\n+        @java.lang.Override\n@@ -263,1 +268,1 @@\n-        @Override\n+        @java.lang.Override\n@@ -334,2 +339,7 @@\n-                } else if (cookie.size() == 2 && !cookie.get(1).equals(\"ORDER=BISCUITS\")) {\n-                    String msg = \"Incorrect cookie header value:[\" + cookie.get(0) + \"]\";\n+                } else if (cookie.size() > 1 && !cookie.get(1).equals(\"ORDER=BISCUITS\")) {\n+                    String msg = \"Incorrect cookie header value:[\" + cookie.get(1) + \"]\";\n+                     (new RuntimeException(msg)).printStackTrace();\n+                    t.sendResponseHeaders(500, -1);\n+                    os.write(msg.getBytes(UTF_8));\n+                } else if (cookie.size() > 2 && !cookie.get(2).equals(\"PRICE=42\")) {\n+                    String msg = \"Incorrect cookie header value:[\" + cookie.get(2) + \"]\";\n@@ -339,1 +349,1 @@\n-                } else if (cookie.size() != 2) {\n+                } else if (cookie.size() != 3) {\n@@ -396,1 +406,1 @@\n-        @Override\n+        @java.lang.Override\n@@ -473,1 +483,1 @@\n-                        if (values.size() != 2) {\n+                        if (values.size() != 3) {\n@@ -482,0 +492,3 @@\n+                        } else if (!values.get(2).equals(\"PRICE=42\")) {\n+                            resp = \"Unexpected cookie: \" + values.get(1) + \" in \" + values;\n+                            status = \"500 Internal Server Error\";\n","filename":"test\/jdk\/java\/net\/httpclient\/UserCookieTest.java","additions":44,"deletions":31,"binary":false,"changes":75,"previous_filename":"test\/jdk\/java\/net\/httpclient\/CookieHeaderTest.java","status":"copied"},{"patch":"@@ -148,0 +148,10 @@\n+                } catch (FileSystemException fse) {\n+                    \/\/ On Linux, ignore the FSE if the path is one of the\n+                    \/\/ \/run\/user\/$UID mounts created by pam_systemd(8) as it\n+                    \/\/ might be mounted as a fuse.portal filesystem and\n+                    \/\/ its access attempt might fail with EPERM\n+                    if (!Platform.isLinux() || store.toString().indexOf(\"\/run\/user\") == -1) {\n+                        throw new RuntimeException(fse);\n+                    } else {\n+                        System.err.format(\"%s error: %s\\n\", store, fse);\n+                    }\n","filename":"test\/jdk\/java\/nio\/file\/FileStore\/Basic.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.function.Consumer;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertThrows;\n+\n+\/**\n+ * @test\n+ * @bug 8277087\n+ * @summary Verifies various use cases when the zip comment should be empty\n+ * @run testng EmptyComment\n+ *\/\n+public final class EmptyComment {\n+\n+    @DataProvider()\n+    Object[][] longLengths() {\n+        return new Object[][]{{0xFFFF + 1}, {0xFFFF + 2}, {0xFFFF * 2}};\n+    }\n+\n+    \/**\n+     * Overflow, the text is too long to be stored as a comment.\n+     *\/\n+    @Test(dataProvider = \"longLengths\")\n+    void testOverflow(int length) throws Exception {\n+        test(zos -> assertThrows(IllegalArgumentException.class, () -> {\n+            zos.setComment(\"X\".repeat(length));\n+        }));\n+    }\n+\n+    \/**\n+     * Simple cases where the comment is set to the empty text.\n+     *\/\n+    @Test\n+    void testSimpleCases() throws Exception {\n+        test(zos -> {\/* do nothing *\/});\n+        test(zos -> zos.setComment(null));\n+        test(zos -> zos.setComment(\"\"));\n+        test(zos -> {\n+            zos.setComment(\"\");\n+            zos.setComment(null);\n+        });\n+        test(zos -> {\n+            zos.setComment(null);\n+            zos.setComment(\"\");\n+        });\n+        test(zos -> {\n+            zos.setComment(\"Comment\");\n+            zos.setComment(null);\n+        });\n+        test(zos -> {\n+            zos.setComment(\"Comment\");\n+            zos.setComment(\"\");\n+        });\n+    }\n+\n+    private static void test(Consumer<ZipOutputStream> test) throws Exception {\n+        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+             ZipOutputStream zos = new ZipOutputStream(baos)) {\n+\n+            test.accept(zos);\n+\n+            zos.putNextEntry(new ZipEntry(\"x\"));\n+            zos.finish();\n+\n+            byte[] data = baos.toByteArray();\n+\n+            if (data.length > 0xFFFF) { \/\/ just in case\n+                throw new RuntimeException(\"data is too big: \" + data.length);\n+            }\n+            int pk = data.length - ZipFile.ENDHDR;\n+            if (data[pk] != 'P' || data[pk + 1] != 'K') {\n+                throw new RuntimeException(\"PK is not found\");\n+            }\n+            \/\/ Since the comment is empty this will be two last bytes\n+            int pos = data.length - ZipFile.ENDHDR + ZipFile.ENDCOM;\n+\n+            int len = (data[pos] & 0xFF) + ((data[pos + 1] & 0xFF) << 8);\n+            if (len != 0) {\n+                throw new RuntimeException(\"zip comment is not empty: \" + len);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipOutputStream\/EmptyComment.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import java.awt.Rectangle;\n@@ -30,0 +31,1 @@\n+import java.awt.Toolkit;\n@@ -59,0 +61,4 @@\n+    private static volatile Point location;\n+    \/\/ move away from cursor\n+    private final static int OFFSET_X = -20;\n+    private final static int OFFSET_Y = -20;\n@@ -62,1 +68,1 @@\n-        robot.setAutoDelay(50);\n+        robot.setAutoDelay(100);\n@@ -66,0 +72,1 @@\n+        robot.delay(1000);\n@@ -70,1 +77,1 @@\n-            Point location = frame.getLocation();\n+            location = frame.getLocation();\n@@ -77,0 +84,2 @@\n+        System.out.println(\"scale \" + scale);\n+\n@@ -78,1 +87,0 @@\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n@@ -80,3 +88,11 @@\n-        Thread.sleep(100);\n-        Color color = robot.getPixelColor(centerX, centerY);\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.waitForIdle();\n+        Color color = robot.getPixelColor(centerX - OFFSET_X, centerY - OFFSET_Y);\n+\n+        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n+        Rectangle screen = new Rectangle(0, 0, (int) screenSize.getWidth(), (int) screenSize.getHeight());\n+        BufferedImage img = robot.createScreenCapture(screen);\n+        javax.imageio.ImageIO.write(img, \"png\", new java.io.File(\"image.png\"));\n+\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n@@ -86,3 +102,7 @@\n-        if ((scale == 1 && !similar(color, COLOR_1X))\n-                || (scale == 2 && !similar(color, COLOR_2X))) {\n-            throw new RuntimeException(\"Colors are different!\");\n+        if (scale == 1 && !similar(color, COLOR_1X)) {\n+            System.out.println(\"color \" + color + \" COLOR_1X \" + COLOR_1X);\n+            throw new RuntimeException(\"Colors is different for scale=1!\");\n+        }\n+        if (scale == 2 && !similar(color, COLOR_2X)) {\n+            System.out.println(\"color \" + color + \" COLOR_2X \" + COLOR_2X);\n+            throw new RuntimeException(\"Colors is different for scale=2!\");\n@@ -90,0 +110,1 @@\n+        System.out.println(\"Test Passed\");\n@@ -111,0 +132,2 @@\n+        frame.setUndecorated(true);\n+        frame.setLocationRelativeTo(null);\n","filename":"test\/jdk\/javax\/swing\/JButton\/8151303\/PressedIconTest.java","additions":32,"deletions":9,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.awt.Dimension;\n@@ -29,0 +30,2 @@\n+import java.awt.Toolkit;\n+import java.awt.image.BufferedImage;\n@@ -55,0 +58,4 @@\n+     \/\/ move away from cursor\n+    private final static int OFFSET_X = -20;\n+    private final static int OFFSET_Y = -20;\n+\n@@ -69,1 +76,1 @@\n-            robot.setAutoDelay(50);\n+            robot.setAutoDelay(100);\n@@ -82,1 +89,1 @@\n-            robot.mousePress(InputEvent.BUTTON1_MASK);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n@@ -84,1 +91,1 @@\n-            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n@@ -91,1 +98,13 @@\n-            if (!FRAME_COLOR.equals(robot.getPixelColor(cx, cy))) {\n+            robot.waitForIdle();\n+            Color color = robot.getPixelColor(cx - OFFSET_X, cy - OFFSET_Y);\n+\n+            if (!FRAME_COLOR.equals(color)) {\n+                System.out.println(\"cx \" + cx + \" cy \" + cy);\n+                System.err.println(\"FRAME_COLOR Red: \" + FRAME_COLOR.getRed() + \"; Green: \" + FRAME_COLOR.getGreen() + \"; Blue: \" + FRAME_COLOR.getBlue());\n+                System.err.println(\"Pixel color Red: \" + color.getRed() + \"; Green: \" + color.getGreen() + \"; Blue: \" + color.getBlue());\n+\n+                Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n+                Rectangle screen = new Rectangle(0, 0, (int) screenSize.getWidth(), (int) screenSize.getHeight());\n+                BufferedImage img = robot.createScreenCapture(screen);\n+                javax.imageio.ImageIO.write(img, \"png\", new java.io.File(\"image.png\"));\n+\n@@ -95,3 +114,5 @@\n-            if (frame != null) {\n-                frame.dispose();\n-            }\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n@@ -99,0 +120,1 @@\n+        System.out.println(\"Test Passed\");\n@@ -103,0 +125,1 @@\n+        System.out.println(\"d3d \" + d3d);\n@@ -141,0 +164,1 @@\n+        frame.setLocationRelativeTo(null);\n","filename":"test\/jdk\/javax\/swing\/JInternalFrame\/8069348\/bug8069348.java","additions":31,"deletions":7,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-public class bug6276188 extends JFrame {\n+public class bug6276188 {\n@@ -44,0 +44,5 @@\n+    private static JFrame testFrame;\n+\n+     \/\/ move away from cursor\n+    private final static int OFFSET_X = -20;\n+    private final static int OFFSET_Y = -20;\n@@ -46,2 +51,3 @@\n-        SynthLookAndFeel lookAndFeel = new SynthLookAndFeel();\n-        lookAndFeel.load(bug6276188.class.getResourceAsStream(\"bug6276188.xml\"), bug6276188.class);\n+        try {\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n@@ -49,7 +55,3 @@\n-        UIManager.setLookAndFeel(lookAndFeel);\n-        SwingUtilities.invokeAndWait(new Runnable() {\n-            public void run() {\n-                JFrame testFrame = new JFrame();\n-                testFrame.setLayout(new BorderLayout());\n-                testFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n-                testFrame.add(BorderLayout.CENTER, button = new JButton());\n+            SynthLookAndFeel lookAndFeel = new SynthLookAndFeel();\n+            lookAndFeel.load(bug6276188.class.getResourceAsStream(\"bug6276188.xml\"), bug6276188.class);\n+            UIManager.setLookAndFeel(lookAndFeel);\n@@ -57,4 +59,6 @@\n-                testFrame.setSize(new Dimension(320, 200));\n-                testFrame.setVisible(true);\n-            }\n-        });\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+                public void run() {\n+                    testFrame = new JFrame();\n+                    testFrame.setLayout(new BorderLayout());\n+                    testFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+                    testFrame.add(BorderLayout.CENTER, button = new JButton());\n@@ -62,4 +66,5 @@\n-        Robot robot = new Robot();\n-        robot.setAutoDelay(50);\n-        robot.waitForIdle();\n-        robot.delay(200);\n+                    testFrame.setSize(new Dimension(320, 200));\n+                    testFrame.setLocationRelativeTo(null);\n+                    testFrame.setVisible(true);\n+                }\n+            });\n@@ -67,1 +72,2 @@\n-        p = Util.getCenterPoint(button);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n@@ -69,4 +75,2 @@\n-        robot.mouseMove(p.x , p.y);\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        robot.waitForIdle();\n-        robot.delay(1000);\n+            p = Util.getCenterPoint(button);\n+            System.out.println(\"Button center point: \" + p);\n@@ -74,6 +78,23 @@\n-        Color color = robot.getPixelColor(p.x, p.y);\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n-        boolean red = color.getRed() > 0 && color.getGreen() == 0 && color.getBlue() == 0;\n-        if (!red) {\n-            System.err.println(\"Red: \" + color.getRed() + \"; Green: \" + color.getGreen() + \"; Blue: \" + color.getBlue());\n-            throw new RuntimeException(\"Synth ButtonUI does not handle PRESSED & MOUSE_OVER state\");\n+            robot.mouseMove(p.x , p.y);\n+            robot.waitForIdle();\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+\n+            Color color = robot.getPixelColor(p.x - OFFSET_X, p.y - OFFSET_Y);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            boolean red = color.getRed() > 0 && color.getGreen() == 0 && color.getBlue() == 0;\n+            if (!red) {\n+                System.err.println(\"Red: \" + color.getRed() + \"; Green: \" + color.getGreen() + \"; Blue: \" + color.getBlue());\n+                Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\n+                Rectangle screen = new Rectangle(0, 0, (int) screenSize.getWidth(), (int) screenSize.getHeight());\n+                BufferedImage img = robot.createScreenCapture(screen);\n+                javax.imageio.ImageIO.write(img, \"png\", new java.io.File(\"image.png\"));\n+                throw new RuntimeException(\"Synth ButtonUI does not handle PRESSED & MOUSE_OVER state\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (testFrame != null) {\n+                    testFrame.dispose();\n+                }\n+            });\n","filename":"test\/jdk\/javax\/swing\/plaf\/synth\/SynthButtonUI\/6276188\/bug6276188.java","additions":50,"deletions":29,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4990825\n+ * @bug 4990825 8251155\n","filename":"test\/jdk\/sun\/jvmstat\/monitor\/HostIdentifier\/HostIdentifierCreate.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -221,0 +221,14 @@\n+<testcase id=\"31\" HostIdentifierInput=\"12345\">\n+<description>\n+Purely numeric\n+<\/description>\n+<HostIdentifier> \/\/12345 <\/HostIdentifier>\n+<\/testcase>\n+\n+<testcase id=\"32\" HostIdentifierInput=\"12345:123\">\n+<description>\n+Purely numeric\n+<\/description>\n+<HostIdentifier> \/\/12345:123 <\/HostIdentifier>\n+<\/testcase>\n+\n","filename":"test\/jdk\/sun\/jvmstat\/monitor\/HostIdentifier\/testcases","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n- *      8247960 8242068 8269039\n+ *      8247960 8242068 8269039 8275887\n@@ -343,0 +343,1 @@\n+                        .shouldNotMatch(\"Signature.*(disabled)\")\n@@ -359,0 +360,2 @@\n+                        .shouldNotContain(\"option is considered a security \" +\n+                            \"risk and is disabled\")\n@@ -422,0 +425,11 @@\n+                        .shouldNotContain(\"The SHA-256 algorithm specified \" +\n+                            \"for the -digestalg option is considered a \" +\n+                            \"security risk\")\n+                        .shouldNotContain(\"The SHA256withRSA algorithm \" +\n+                            \"specified for the -sigalg option is considered \" +\n+                            \"a security risk\")\n+                        .shouldNotContain(\"The SHA-256 algorithm specified \" +\n+                            \"for the -tsadigestalg option is considered a \" +\n+                            \"security risk\")\n+                        .shouldContain(\"The RSA signing key has a keysize \" +\n+                            \"of 1024 which is considered a security risk\")\n@@ -676,1 +690,1 @@\n-                .shouldMatch(\"SignatureException:.*keysize\");\n+                .shouldMatch(\"SignatureException:.*MD5\");\n@@ -848,1 +862,1 @@\n-        gencert(\"ts\", \"-ext eku:critical=ts -validity 500\");\n+        gencert(\"ts\", \"-ext eku:critical=ts -ext ku=nonrep -validity 500\");\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/TimestampCheck.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7180907\n+ * @bug 7180907 8277224\n@@ -63,0 +63,1 @@\n+            new PKCS9Attribute(PKCS9Attribute.SIGNATURE_TIMESTAMP_TOKEN_OID, \"test\".getBytes())\n@@ -65,0 +66,4 @@\n+        \/\/ test PKCS9Attributes.toString(), PKCS9Attributes.getAttributes()\n+        System.out.println(authed);\n+        authed.getAttributes();\n+\n","filename":"test\/jdk\/sun\/security\/x509\/AlgorithmId\/NonStandardNames.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (C) 2020 THL A29 Limited, a Tencent company. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-\/*\n- * @test\n- * @bug 8251155\n- * @summary Test host names starting with digits\n- * @library \/test\/lib\n- * @build JpsHelper\n- * @run driver TestJpsHostName\n- *\/\n-public class TestJpsHostName {\n-\n-    public static void main(String[] args) throws Throwable {\n-        testJpsHostName(\"12345\");\n-        testJpsHostName(\"12345:37266\");\n-    }\n-\n-    private static void testJpsHostName(String hostname) throws Exception {\n-        OutputAnalyzer output = JpsHelper.jps(hostname);\n-        output.shouldNotContain(\"Malformed Host Identifier: \" + hostname);\n-    }\n-\n-}\n","filename":"test\/jdk\/sun\/tools\/jps\/TestJpsHostName.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.ObjIntConsumer;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+public class SnippetTester extends JavadocTester {\n+\n+    protected final ToolBox tb = new ToolBox();\n+\n+    protected void checkOrder(Output output, String... strings) {\n+        new OutputChecker(output).setExpectOrdered(true).check(strings);\n+    }\n+\n+    \/*\n+     * When checking for errors, it is important not to confuse one error with\n+     * another. This method checks that there are no crashes (which are also\n+     * errors) by checking for stack traces. We never expect crashes.\n+     *\/\n+    protected void checkNoCrashes() {\n+        checking(\"check crashes\");\n+        Matcher matcher = Pattern.compile(\"\\\\s*at.*\\\\(.*\\\\.java:\\\\d+\\\\)\")\n+                .matcher(getOutput(Output.STDERR));\n+        if (!matcher.find()) {\n+            passed(\"\");\n+        } else {\n+            failed(\"Looks like a stacktrace: \" + matcher.group());\n+        }\n+    }\n+\n+    \/*\n+     * This is a convenience method to iterate through a list.\n+     * Unlike List.forEach, this method provides the consumer not only with an\n+     * element but also that element's index.\n+     *\n+     * See JDK-8184707.\n+     *\/\n+    protected static <T> void forEachNumbered(List<T> list, ObjIntConsumer<? super T> action) {\n+        for (var iterator = list.listIterator(); iterator.hasNext(); ) {\n+            action.accept(iterator.next(), iterator.previousIndex());\n+        }\n+    }\n+\n+    \/\/ TODO:\n+    \/\/   Explore the toolbox.ToolBox.writeFile and toolbox.ToolBox.writeJavaFiles methods:\n+    \/\/   see if any of them could be used instead of this one\n+    protected static void addSnippetFile(Path srcDir, String packageName, String fileName, String content)\n+            throws UncheckedIOException\n+    {\n+        String[] components = packageName.split(\"\\\\.\");\n+        Path snippetFiles = Path.of(components[0], Arrays.copyOfRange(components, 1, components.length)).resolve(\"snippet-files\");\n+        try {\n+            Path p = Files.createDirectories(srcDir.resolve(snippetFiles));\n+            Files.writeString(p.resolve(fileName), content, StandardOpenOption.CREATE_NEW);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    protected void checkOutputEither(Output out, String first, String... other) {\n+        var strings = Stream.concat(Stream.of(first), Stream.of(other))\n+                .toArray(String[]::new);\n+        new OutputChecker(out).checkAnyOf(strings);\n+    }\n+\n+    protected String getSnippetHtmlRepresentation(String pathToHtmlFile,\n+                                                  String content) {\n+        return getSnippetHtmlRepresentation(pathToHtmlFile, content, Optional.empty(), Optional.empty());\n+    }\n+\n+    protected String getSnippetHtmlRepresentation(String pathToHtmlFile,\n+                                                  String content,\n+                                                  Optional<String> lang,\n+                                                  Optional<String> id) {\n+        \/\/ the further away from the root, the further to reach to common resources\n+        int nComponents = (int) pathToHtmlFile.chars().filter(c -> c == '\/').count();\n+        var svgString = \"..\/\".repeat(nComponents) + \"copy.svg\";\n+        var idString = id.isEmpty() ? \"\" : \" id=\\\"%s\\\"\".formatted(id.get());\n+        var langString = lang.isEmpty() ? \"\" : \" class=\\\"language-%s\\\"\".formatted(lang.get());\n+        return \"\"\"\n+                <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySnippet(this)\">\\\n+                <span data-copied=\"Copied!\">Copy<\/span><img src=\"%s\" alt=\"Copy\"><\/button>\n+                <pre class=\"snippet\"%s><code%s>%s<\/code><\/pre>\n+                <\/div>\"\"\".formatted(svgString, idString, langString, content);\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/SnippetTester.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,574 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266666\n+ * @summary Implementation for snippets\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build javadoc.tester.* toolbox.ToolBox toolbox.ModuleBuilder builder.ClassBuilder\n+ * @run main TestSnippetMarkup\n+ *\/\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Reader;\n+import java.io.StringReader;\n+import java.io.StringWriter;\n+import java.io.UncheckedIOException;\n+import java.io.Writer;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+import java.util.regex.MatchResult;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.lang.model.element.Modifier;\n+import javax.lang.model.element.NestingKind;\n+import javax.tools.FileObject;\n+import javax.tools.JavaFileObject;\n+import javax.tools.StandardJavaFileManager;\n+import javax.tools.ToolProvider;\n+\n+import builder.ClassBuilder;\n+import toolbox.ToolBox;\n+\n+import static javax.tools.DocumentationTool.Location.DOCUMENTATION_OUTPUT;\n+\n+public class TestSnippetMarkup extends SnippetTester {\n+\n+    public static void main(String... args) throws Exception {\n+        new TestSnippetMarkup().runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    \/*\n+     * The semantics of expectedOutput depends on the test case this record is\n+     * used in.\n+     *\/\n+    record TestCase(String region, String input, String expectedOutput) {\n+        TestCase(String input, String expectedOutput) {\n+            this(\"\", input, expectedOutput);\n+        }\n+    }\n+\n+    \/\/ @highlight [region|region=<name>]\n+    \/\/            [regex=<val>|substring=<val>]\n+    \/\/            [type=bold|italics|highlighted]\n+    \/\/            [:]\n+    @Test\n+    public void testHighlight(Path base) throws Exception {\n+        var testCases = List.of(\n+                new TestCase( \/\/ FIXME: newline should not be included\n+                        \"\"\"\n+                                First line  \/\/ @highlight\n+                                  Second line\n+                                \"\"\",\n+                        \"\"\"\n+                                <span class=\"bold\">First line\n+                                <\/span>  Second line\n+                                \"\"\"),\n+                new TestCase(\n+                        \"\"\"\n+                                First line  \/\/ @highlight regex=\"\\\\w\" type=\"bold\"\n+                                  Second line\n+                                \"\"\",\n+                        \"\"\"\n+                                <span class=\"bold\">First<\/span> <span class=\"bold\">line<\/span>\n+                                  Second line\n+                                \"\"\"),\n+                new TestCase( \/\/ FIXME: newline should not be included\n+                        \"\"\"\n+                                First line  \/\/ @highlight @highlight regex=\"\\\\w\" type=\"bold\"\n+                                  Second line\n+                                \"\"\",\n+                        \"\"\"\n+                                <span class=\"bold\">First line\n+                                <\/span>  Second line\n+                                \"\"\"\n+                ));\n+        testPositive(base, testCases);\n+    }\n+\n+    \/\/ @replace [region|region=<name>]\n+    \/\/          [regex=<val>|substring=<val>]\n+    \/\/          [replacement=<val>]\n+    \/\/          [:]\n+    @Test\n+    public void testReplace(Path base) throws Exception {\n+        var testCases = List.of(\n+                new TestCase(\n+                        \"\"\"\n+                                First line  \/\/ @replace regex=\"\\\\w\" replacement=\".\"\n+                                  Second line\n+                                \"\"\",\n+                        \"\"\"\n+                                ..... ....\n+                                  Second line\n+                                \"\"\"),\n+                new TestCase( \/\/ \"substring\" is not treated like \"regex\"\n+                        \"\"\"\n+                                First line  \/\/ @replace substring=\"\\\\w\" replacement=\".\"\n+                                  Second line\n+                                \"\"\",\n+                        \"\"\"\n+                                First line\n+                                  Second line\n+                                \"\"\"\n+                ),\n+                new TestCase(\n+                        \"\"\"\n+                                First line  \/\/ @replace substring=\"i\" replacement=\".\"\n+                                  Second line\n+                                \"\"\",\n+                        \"\"\"\n+                                F.rst l.ne\n+                                  Second line\n+                                \"\"\"\n+                ));\n+        testPositive(base, testCases);\n+    }\n+\n+    \/\/ @link [region|region=<name>]\n+    \/\/       [regex=<val>|substring=<val>]\n+    \/\/       [target=<val>]\n+    \/\/       [type=link|linkplain]\n+    \/\/       [:]\n+    @Test\n+    public void testLink(Path base) throws Exception {\n+        var testCases = List.of(\n+                new TestCase(\n+                        \"\"\"\n+                                First line  \/\/ @link regex=\"\\\\w\" target=\"java.lang.Object#Object\"\n+                                  Second line\n+                                \"\"\",\n+                        replace(\"\"\"\n+                                link(First) link(line)\n+                                  Second line\n+                                \"\"\", \"link\\\\((.+?)\\\\)\", r -> link(true, \"java.lang.Object#Object\", r.group(1)))\n+                ));\n+        testPositive(base, testCases);\n+    }\n+\n+    @Test\n+    public void testCornerCases(Path base) throws Exception {\n+        var testCases = List.of(\n+                new TestCase( \/\/ This is how one might represent a unicode escape sequence uninterpreted, if required.\n+                        \"\"\"\n+                                \\\\$0041  \/\/ @replace substring=\"$\" replacement=\"u\"\n+                                \"\"\",\n+                        \"\"\"\n+                                \\\\u0041\n+                                \"\"\"\n+                ),\n+                new TestCase( \/\/ This is how one might represent `*\/` without ending an enclosing comment, if required.\n+                              \/\/ A non-whitespace character that is also not `*` is needed before `*` so that `*`\n+                              \/\/ is not confused with the optional doc comment decoration.\n+                              \/\/ (We cannot use, for example, `**$` or ` *$`.)\n+                        \"\"\"\n+                                a*$  \/\/ @replace substring=\"$\" replacement=\"\/\"\n+                                \"\"\",\n+                        \"\"\"\n+                                a*\/\n+                                \"\"\"\n+                ),\n+                new TestCase( \/\/ This is how one might output markup, if required.\n+                              \/\/ Append a no-op markup since only the rightmost markup is parsed.\n+                        \"\"\"\n+                                \/\/ @highlight \/\/ @start region=throwaway @end\n+                                \"\"\",\n+                        \"\"\"\n+                                \/\/ @highlight\n+                                \"\"\"\n+                )\n+        );\n+        testPositive(base, testCases);\n+    }\n+\n+    \/*\n+     * For all but the last line of snippet source, next-line markup behaves\n+     * as if that markup without the next-line modifier were put on that\n+     * next line.\n+     *\/\n+\/\/    @Test\n+    public void testPositiveInlineExternalTagMarkup_NextLine(Path base) throws Exception {\n+        throw new RuntimeException(\"Not yet implemented\");\n+    }\n+\n+    \/*\n+     * If next-line markup is put on the last line of a snippet source,\n+     * an error occurs.\n+     *\/\n+    @Test\n+    public void testNegativeInlineExternalHybridTagMarkup_NextLinePutOnLastLine(Path base) throws Exception {\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        var goodFile = \"good.txt\";\n+        var badFile = \"bad.txt\";\n+        var badFile2 = \"bad2.txt\"; \/\/ to workaround error deduplication\n+        new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        ClassBuilder.MethodBuilder\n+                                .parse(\"public void inline() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet :\n+                                             First line \/\/ @highlight :\n+                                             }\n+                                             \"\"\"))\n+                .addMembers(\n+                        ClassBuilder.MethodBuilder\n+                                .parse(\"public void external() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"%s\"}\n+                                             \"\"\".formatted(badFile)))\n+                .addMembers(\n+                        ClassBuilder.MethodBuilder\n+                                .parse(\"public void hybrid1() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"%s\":\n+                                             First line\n+                                             }\n+                                             \"\"\".formatted(badFile2)))\n+                .addMembers(\n+                        ClassBuilder.MethodBuilder\n+                                .parse(\"public void hybrid2() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"%s\":\n+                                             First line \/\/ @highlight :\n+                                             }\n+                                             \"\"\".formatted(goodFile)))\n+                \/\/ TODO: these two hybrids are to test what *this* test should not test.\n+                \/\/  Add a test that checks that an error in either part\n+                \/\/  of a hybrid snippet causes the snippet to fail (property-based testing)\n+                .write(srcDir);\n+        addSnippetFile(srcDir, \"pkg\", goodFile, \"\"\"\n+First line \/\/ @highlight\n+ \"\"\");\n+        addSnippetFile(srcDir, \"pkg\", badFile, \"\"\"\n+First line \/\/ @highlight :\n+ \"\"\");\n+        addSnippetFile(srcDir, \"pkg\", badFile2, \"\"\"\n+First line \/\/ @highlight :\n+ \"\"\");\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+\"\"\"\n+A.java:5: error: snippet markup: tag refers to non-existent lines\n+First line \/\/ @highlight :\n+               ^\"\"\",\n+\"\"\"\n+A.java:24: error: snippet markup: tag refers to non-existent lines\n+First line \/\/ @highlight :\n+               ^\"\"\",\n+\"\"\"\n+%s:1: error: snippet markup: tag refers to non-existent lines\n+First line \/\/ @highlight :\n+               ^\"\"\".formatted(badFile),\n+\"\"\"\n+%s:1: error: snippet markup: tag refers to non-existent lines\n+First line \/\/ @highlight :\n+               ^\"\"\".formatted(badFile2));\n+        checkNoCrashes();\n+    }\n+\n+    private void testPositive(Path base, List<TestCase> testCases)\n+            throws IOException {\n+        StringBuilder methods = new StringBuilder();\n+        forEachNumbered(testCases, (i, n) -> {\n+            String r = i.region.isBlank() ? \"\" : \"region=\" + i.region;\n+            var methodDef = \"\"\"\n+\n+                    \/**\n+                    {@snippet %s:\n+                    %s}*\/\n+                    public void case%s() {}\n+                    \"\"\".formatted(r, i.input, n);\n+            methods.append(methodDef);\n+        });\n+        var classDef = \"\"\"\n+                public class A {\n+                %s\n+                }\n+                \"\"\".formatted(methods.toString());\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.writeJavaFiles(src, classDef);\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"A.java\").toString());\n+        checkExit(Exit.OK);\n+        checkNoCrashes();\n+        forEachNumbered(testCases, (t, index) -> {\n+            String html = \"\"\"\n+                        <span class=\"element-name\">case%s<\/span>()<\/div>\n+                        <div class=\"block\">\n+                        %s\n+                        <\/div>\"\"\".formatted(index, getSnippetHtmlRepresentation(\"A.html\", t.expectedOutput()));\n+            checkOutput(\"A.html\", true, html);\n+        });\n+    }\n+\n+    \/\/ FIXME: move error (i.e. negative) tests from TestSnippetTag to here\n+\n+    \/\/ @start region=<name> ... @end [region|region=<name>]\n+    @Test\n+    public void testStart(Path base) throws Exception {\n+        var testCases = new ArrayList<TestCase>();\n+        for (var variant : generateStartEndVariants()) {\n+            var t = new TestCase(variant.region,\n+                    \"\"\"\n+                            First line\n+                              Second line \/\/ ###START\n+                              Third line\n+                              Fourth line \/\/ ###END\n+                            Fifth line\n+                            \"\"\".replaceFirst(\"###START\", variant.start)\n+                            .replaceFirst(\"###END\", variant.end),\n+                    \"\"\"\n+                            Second line\n+                            Third line\n+                            Fourth line\"\"\");\n+            testCases.add(t);\n+        }\n+        testPositive(base, testCases);\n+    }\n+\n+    private static String link(boolean linkPlain,\n+                               String targetReference,\n+                               String content)\n+            throws UncheckedIOException {\n+\n+        \/\/ The HTML <a> tag generated from the @link snippet markup tag is the\n+        \/\/ same as that of the {@link} Standard doclet tag. This is specified\n+        \/\/ and can be used for comparison and testing.\n+\n+        \/\/ generate documentation for {@link} to grab its HTML <a> tag;\n+        \/\/ generate documentation at low cost and do not interfere with the\n+        \/\/ calling test state; for that, do not create file trees, do not write\n+        \/\/ to std out\/err, and generally try to keep everything in memory\n+\n+        String source = \"\"\"\n+                \/** {@link %s %s} *\/\n+                public interface A { }\n+                \"\"\".formatted(targetReference, content);\n+\n+        JavaFileObject src = new JavaFileObject() {\n+            @Override\n+            public Kind getKind() {return Kind.SOURCE;}\n+\n+            @Override\n+            public boolean isNameCompatible(String simpleName, Kind kind) {\n+                return kind == Kind.SOURCE;\n+            }\n+\n+            @Override\n+            public NestingKind getNestingKind() {return NestingKind.TOP_LEVEL;}\n+\n+            @Override\n+            public Modifier getAccessLevel() {return Modifier.PUBLIC;}\n+\n+            @Override\n+            public URI toUri() {throw new UnsupportedOperationException();}\n+\n+            @Override\n+            public String getName() {return \"A.java\";}\n+\n+            @Override\n+            public InputStream openInputStream() {\n+                return new ByteArrayInputStream(source.getBytes(StandardCharsets.UTF_8));\n+            }\n+\n+            @Override\n+            public OutputStream openOutputStream() {\n+                throw new UnsupportedOperationException(\"Read only\");\n+            }\n+\n+            @Override\n+            public Reader openReader(boolean ignoreEncodingErrors) {\n+                return new StringReader(source);\n+            }\n+\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+                return source;\n+            }\n+\n+            @Override\n+            public Writer openWriter() {\n+                throw new UnsupportedOperationException(\"Read only\");\n+            }\n+\n+            @Override\n+            public long getLastModified() {\n+                return 0;\n+            }\n+\n+            @Override\n+            public boolean delete() {\n+                throw new UnsupportedOperationException(\"Read only\");\n+            }\n+        };\n+\n+        var documentationTool = ToolProvider.getSystemDocumentationTool();\n+        var writer = new StringWriter();\n+\n+        \/\/ FileManager has to be StandardJavaFileManager; JavaDoc is adamant about it\n+        class InMemoryFileManager extends ToolBox.MemoryFileManager\n+                implements StandardJavaFileManager {\n+\n+            private final StandardJavaFileManager delegate = documentationTool\n+                    .getStandardFileManager(null, null, null);\n+\n+            @Override\n+            public Iterable<? extends JavaFileObject> getJavaFileObjectsFromFiles(Iterable<? extends File> files) {\n+                return delegate.getJavaFileObjectsFromFiles(files);\n+            }\n+\n+            @Override\n+            public Iterable<? extends JavaFileObject> getJavaFileObjects(File... files) {\n+                return delegate.getJavaFileObjects(files);\n+            }\n+\n+            @Override\n+            public Iterable<? extends JavaFileObject> getJavaFileObjectsFromStrings(Iterable<String> names) {\n+                return delegate.getJavaFileObjectsFromStrings(names);\n+            }\n+\n+            @Override\n+            public Iterable<? extends JavaFileObject> getJavaFileObjects(String... names) {\n+                return delegate.getJavaFileObjects(names);\n+            }\n+\n+            @Override\n+            public void setLocation(Location location, Iterable<? extends File> files) throws IOException {\n+                delegate.setLocation(location, files);\n+            }\n+\n+            @Override\n+            public Iterable<? extends File> getLocation(Location location) {\n+                return delegate.getLocation(location);\n+            }\n+\n+            @Override\n+            public FileObject getFileForOutput(Location location,\n+                                               String packageName,\n+                                               String relativeName,\n+                                               FileObject sibling) {\n+                return getJavaFileForOutput(location, packageName + relativeName, JavaFileObject.Kind.OTHER, null);\n+            }\n+        }\n+        try {\n+            var fileManager = new InMemoryFileManager();\n+            fileManager.setLocation(DOCUMENTATION_OUTPUT, Collections.singleton(new File(\".\")));\n+            \/\/ exclude extraneous output; we're only after @link\n+            List<String> options = List.of(\"--limit-modules\", \"java.base\",\n+                    \"-quiet\", \"-nohelp\", \"-noindex\", \"-nonavbar\", \"-nosince\",\n+                    \"-notimestamp\", \"-notree\", \"-Xdoclint:none\");\n+            var documentationTask = documentationTool.getTask(null, fileManager,\n+                    null, null, options, List.of(src));\n+            if (!documentationTask.call()) {\n+                throw new IOException(writer.toString());\n+            }\n+            String output = fileManager.getFileString(DOCUMENTATION_OUTPUT, \"A.html\");\n+            \/\/ use the [^<>] regex to select HTML elements that immediately enclose \"content\"\n+            Matcher m = Pattern.compile(\"(?is)<a href=\\\"[^<>]*\\\" title=\\\"[^<>]*\\\" class=\\\"[^<>]*\\\"><code>\"\n+                    + content + \"<\/code><\/a>\").matcher(output);\n+            if (!m.find()) {\n+                throw new IOException(output);\n+            }\n+            return m.group(0);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    private static String replace(String source,\n+                                  String regex,\n+                                  Function<MatchResult, String> replacer) {\n+        return Pattern.compile(regex).matcher(source).replaceAll(replacer);\n+    }\n+\n+    private static final AtomicLong UNIQUE_INTEGER_NUMBER = new AtomicLong();\n+\n+    private static Collection<StartEndVariant> generateStartEndVariants() {\n+        var variants = new ArrayList<StartEndVariant>();\n+        for (var start : startAttributes())\n+            for (var end : endAttributes()) {\n+                var region = uniqueValue();\n+                var v = new StartEndVariant(region,\n+                        \"@start\" + start.apply(region),\n+                        \"@end\" + end.apply(region));\n+                variants.add(v);\n+            }\n+        return variants;\n+    }\n+\n+    private static String uniqueValue() {\n+        return \"auto_generated_value_\" + UNIQUE_INTEGER_NUMBER.incrementAndGet();\n+    }\n+\n+    public static Collection<Function<String, String>> startAttributes() {\n+        return attributes(\"region\");\n+    }\n+\n+    private static Collection<Function<String, String>> endAttributes() {\n+        var variants = new ArrayList<Function<String, String>>();\n+        variants.add(value -> \"\");\n+        variants.add(value -> \" region\");\n+        variants.addAll(attributes(\"region\"));\n+        return variants;\n+    }\n+\n+    private static Collection<Function<String, String>> attributes(String name) {\n+        var variants = new ArrayList<Function<String, String>>();\n+        for (var whitespace1 : List.of(\" \", \"  \"))\n+            for (var whitespace2 : List.of(\"\", \" \"))\n+                for (var quote : List.of(\"\", \"'\", \"\\\"\"))\n+                    for (var whitespace3 : List.of(\"\", \" \")) {\n+                        Function<String, String> f = value ->\n+                                whitespace1 + name + whitespace2\n+                                        + \"=\" + whitespace3 + (quote + value + quote);\n+                        variants.add(f);\n+                    }\n+        return variants;\n+    }\n+\n+    record StartEndVariant(String region, String start, String end) {}\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetMarkup.java","additions":574,"deletions":0,"binary":false,"changes":574,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266666\n+ * @summary Implementation for snippets\n+ * @library \/tools\/lib ..\/..\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build javadoc.tester.* toolbox.ToolBox toolbox.ModuleBuilder builder.ClassBuilder\n+ * @run main TestSnippetPathOption\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class TestSnippetPathOption extends SnippetTester {\n+\n+    public static void main(String... args) throws Exception {\n+        new TestSnippetPathOption().runTests(m -> new Object[]{Paths.get(m.getName())});\n+    }\n+\n+    \/*\n+        #   snippet-files   snippet-path   result\n+       ---+--------------+--------------+---------------------\n+        1         +              +         snippet-files\n+        2         +           invalid      snippet-files\n+        3         -              +         snippet-path\n+        4         -           invalid      error\n+     *\/\n+\n+    @Test\n+    public void test1(Path base) throws Exception {\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.createDirectories(src.resolve(\"directoryA\"), src.resolve(\"directoryB\"));\n+        tb.writeFile(src.resolve(\"directoryA\/mysnippet.txt\"), \"Hello, directoryA!\");\n+        tb.writeFile(src.resolve(\"directoryB\/mysnippet.txt\"), \"Hello, directoryB!\");\n+        tb.writeFile(src.resolve(\"pkg\/snippet-files\/mysnippet.txt\"), \"Hello, snippet-files!\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                               package pkg;\n+\n+                               \/** {@snippet file=\"mysnippet.txt\"} *\/\n+                               public class X { }\n+                               \"\"\");\n+        String snippetPathValue = Stream.of(\"directoryA\", \"directoryB\")\n+                .map(src::resolve)\n+                .map(Path::toAbsolutePath)\n+                .map(Path::toString)\n+                .collect(Collectors.joining(File.pathSeparator));\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--snippet-path\", snippetPathValue,\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/X.html\", true, \"Hello, snippet-files!\");\n+        checkOutput(\"pkg\/X.html\", false, \"Hello, directoryA!\");\n+        checkOutput(\"pkg\/X.html\", false, \"Hello, directoryB!\");\n+    }\n+\n+    @Test\n+    public void test2(Path base) throws Exception {\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.createDirectories(src.resolve(\"directoryA\"), src.resolve(\"directoryB\"));\n+        tb.writeFile(src.resolve(\"pkg\/snippet-files\/mysnippet.txt\"), \"Hello, snippet-files!\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                               package pkg;\n+\n+                               \/** {@snippet file=\"mysnippet.txt\"} *\/\n+                               public class X { }\n+                               \"\"\");\n+        String snippetPathValue = Stream.of(\"directoryA\", \"directoryB\")\n+                .map(src::resolve)\n+                .map(Path::toAbsolutePath)\n+                .map(Path::toString)\n+                .collect(Collectors.joining(File.pathSeparator));\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--snippet-path\", snippetPathValue,\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/X.html\", true, \"Hello, snippet-files!\");\n+    }\n+\n+    @Test\n+    public void test3(Path base) throws Exception {\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.createDirectories(src.resolve(\"directoryA\"), src.resolve(\"directoryB\"));\n+        tb.writeFile(src.resolve(\"directoryA\/mysnippet.txt\"), \"Hello, directoryA!\");\n+        tb.writeFile(src.resolve(\"directoryB\/mysnippet.txt\"), \"Hello, directoryB!\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                               package pkg;\n+\n+                               \/** {@snippet file=\"mysnippet.txt\"} *\/\n+                               public class X { }\n+                               \"\"\");\n+        String snippetPathValue = Stream.of(\"directoryA\", \"directoryB\")\n+                .map(src::resolve)\n+                .map(Path::toAbsolutePath)\n+                .map(Path::toString)\n+                .collect(Collectors.joining(File.pathSeparator));\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--snippet-path\", snippetPathValue,\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/X.html\", true, \"Hello, directoryA!\");\n+        checkOutput(\"pkg\/X.html\", false, \"Hello, directoryB!\");\n+    }\n+\n+    @Test\n+    public void test4(Path base) throws Exception {\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.writeJavaFiles(src, \"\"\"\n+                               package pkg;\n+\n+                               \/** {@snippet file=\"mysnippet.txt\"} *\/\n+                               public class X { }\n+                               \"\"\");\n+        String snippetPathValue = Stream.of(\"directoryA\", \"directoryB\")\n+                .map(src::resolve)\n+                .map(Path::toAbsolutePath)\n+                .map(Path::toString)\n+                .collect(Collectors.joining(File.pathSeparator));\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--snippet-path\", snippetPathValue,\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+    }\n+\n+    \/*\n+     * Tests that the elements of the snippet path are iteratively searched\n+     * until the file is found. In particular, tests that if the file is not\n+     * immediately found, the search is not abandoned.\n+     *\/\n+    @Test\n+    public void testSearchPath(Path base) throws Exception {\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.createDirectories(src.resolve(\"directoryA\"), src.resolve(\"directoryB\"));\n+        \/\/ do not put snippet in directoryA; only put snippet in directoryB\n+        tb.writeFile(src.resolve(\"directoryB\/mysnippet.txt\"), \"Hello, directoryB!\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                               package pkg;\n+\n+                               \/** {@snippet file=\"mysnippet.txt\"} *\/\n+                               public class X { }\n+                               \"\"\");\n+        \/\/ directoryA goes first, assuming that paths are searched in\n+        \/\/ the same order they are specified in\n+        String snippetPathValue = Stream.of(\"directoryA\", \"directoryB\")\n+                .map(src::resolve)\n+                .map(Path::toAbsolutePath)\n+                .map(Path::toString)\n+                .collect(Collectors.joining(File.pathSeparator));\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--snippet-path\", snippetPathValue,\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/X.html\", true, \"Hello, directoryB!\");\n+    }\n+\n+    \/*\n+     * Tests translation from FQN (the \"class\" attribute) to file path\n+     * (the \"file\" attribute).\n+     *\/\n+    @Test\n+    public void testClassToFile(Path base) throws Exception {\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        Path directoryA = Files.createDirectories(src.resolve(\"directoryA\"));\n+        tb.writeJavaFiles(directoryA, \"\"\"\n+                                      package com.example.snippet;\n+\n+                                      public interface Y { }\n+                                      \"\"\");\n+        tb.writeJavaFiles(src, \"\"\"\n+                               package pkg;\n+\n+                               \/** {@snippet class=\"com.example.snippet.Y\"} *\/\n+                               public class X { }\n+                               \"\"\");\n+        String snippetPathValue = Stream.of(\"directoryA\")\n+                .map(src::resolve)\n+                .map(Path::toAbsolutePath)\n+                .map(Path::toString)\n+                .collect(Collectors.joining(File.pathSeparator));\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"--snippet-path\", snippetPathValue,\n+                \"-sourcepath\", src.toString(),\n+                \"pkg\");\n+        checkExit(Exit.OK);\n+        checkOutput(\"pkg\/X.html\", true, \"public interface Y { }\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetPathOption.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -36,6 +36,0 @@\n-import builder.ClassBuilder;\n-import builder.ClassBuilder.MethodBuilder;\n-import javadoc.tester.JavadocTester;\n-import toolbox.ModuleBuilder;\n-import toolbox.ToolBox;\n-\n@@ -43,1 +37,0 @@\n-import java.io.UncheckedIOException;\n@@ -48,1 +41,1 @@\n-import java.util.Arrays;\n+import java.util.ArrayList;\n@@ -53,2 +46,0 @@\n-import java.util.function.ObjIntConsumer;\n-import java.util.regex.Matcher;\n@@ -56,1 +47,4 @@\n-import java.util.stream.Stream;\n+\n+import builder.ClassBuilder;\n+import builder.ClassBuilder.MethodBuilder;\n+import toolbox.ModuleBuilder;\n@@ -66,1 +60,16 @@\n- * General notes.\n+ * General notes\n+ * =============\n+ *\n+ * To simplify maintenance of this test suite, a test name uses a convention.\n+ * By convention, a test name is a concatenation of the following parts:\n+ *\n+ *    1. \"test\"\n+ *    2. (\"Positive\", \"Negative\")\n+ *    3. (\"Inline\", \"External\", \"Hybrid\")\n+ *    4. (\"Tag\", \"Markup\")\n+ *    5. <custom string>\n+ *\n+ * A test can be either positive or negative; it cannot be both or neither.\n+ * A test can exercise inline, external or hybrid variant or any combination\n+ * thereof, including none at all. A test can exercise tag syntax, markup syntax\n+ * or both.\n@@ -76,5 +85,1 @@\n-public class TestSnippetTag extends JavadocTester {\n-\n-    private final ToolBox tb = new ToolBox();\n-\n-    private TestSnippetTag() { }\n+public class TestSnippetTag extends SnippetTester {\n@@ -87,2 +92,4 @@\n-     * Make sure the \"id\" and \"lang\" attributes defined in JEP 413 are rendered\n-     * properly as recommended by the HTML5 specification.\n+     * Make sure the \"id\" and \"lang\" attributes defined in JEP 413 are translated\n+     * to HTML. In particular, verify that the \"lang\" attribute is translated\n+     * to a value added to the \"class\" attribute as recommended by the HTML5 specification:\n+     * https:\/\/html.spec.whatwg.org\/multipage\/text-level-semantics.html#the-code-element\n@@ -91,1 +98,1 @@\n-    public void testIdAndLangAttributes(Path base) throws IOException {\n+    public void testPositiveInlineTag_IdAndLangAttributes(Path base) throws IOException {\n@@ -96,8 +103,1 @@\n-        record SnippetAttributes(String content, String id, String lang) {\n-            public String idAttribute() {\n-                return id == null ? \"\" : \" id=\\\"\" + id + \"\\\"\";\n-            }\n-            public String langAttribute() {\n-                return lang == null ? \"\" : \" class=\\\"language-\" + lang + \"\\\"\";\n-            }\n-        }\n+        record SnippetAttributes(String content, String id, String lang) { }\n@@ -105,0 +105,1 @@\n+        \/\/ TODO: use combinatorial methods, e.g. just like in TestSnippetMarkup\n@@ -221,1 +222,3 @@\n-            SnippetAttributes snippet = snippets.get(j);\n+            var attr = snippets.get(j);\n+            var snippetHtml = getSnippetHtmlRepresentation(\"pkg\/A.html\", \"    Hello, Snippet!\\n\",\n+                    Optional.ofNullable(attr.lang()), Optional.ofNullable(attr.id()));\n@@ -227,7 +230,2 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"%s><code%s>    Hello, Snippet!\n-                        <\/code><\/pre>\n-                        <\/div>\n-                        \"\"\".formatted(j, snippet.idAttribute(), snippet.langAttribute()));\n+                        %s\n+                        \"\"\".formatted(j, snippetHtml));\n@@ -238,3 +236,5 @@\n-     * Make sure the lang attribute is derived correctly from the snippet source file\n-     * for external snippets when it is not defined in the snippet. Defining the lang\n-     * attribute in the snippet should always override this mechanism.\n+     * If the \"lang\" attribute is absent in the snippet tag for an external snippet,\n+     * then the \"class\" attribute is derived from the snippet source file extension.\n+     *\n+     * If the \"class\" attribute can be derived both from the \"lang\" attribute and\n+     * the file extension, then it is derived from the \"lang\" attribute.\n@@ -242,0 +242,1 @@\n+    \/\/ TODO: restructure this as a list of TestCase records\n@@ -243,1 +244,1 @@\n-    public void testExternalImplicitAttributes(Path base) throws IOException {\n+    public void testPositiveInlineExternalTagMarkup_ImplicitAttributes(Path base) throws IOException {\n@@ -279,38 +280,1 @@\n-        checkOutput(\"com\/example\/Cls.html\", true,\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet1\"><code class=\"language-java\">\n-                    System.out.println(msg);\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet2\"><code class=\"language-java\">\n-                    System.out.println(msg);\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet3\"><code class=\"language-none\">\n-                    System.out.println(msg);\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet4\"><code class=\"language-none\">\n-                    System.out.println(msg);\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet5\"><code>\n-                    System.out.println(msg);\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet6\"><code>\n-                    System.out.println(msg);\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet7\"><code class=\"language-properties\">user=jane\n-                    home=\/home\/jane\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet8\"><code class=\"language-none\">user=jane\n-                    home=\/home\/jane\n-                    <\/code><\/pre>\"\"\",\n-                \"\"\"\n-                    <pre class=\"snippet\" id=\"snippet9\"><code>user=jane\n-                    home=\/home\/jane\n-                    <\/code><\/pre>\"\"\");\n-    }\n+        final var javaContent = \"\"\"\n@@ -318,11 +282,16 @@\n-    \/*\n-     * This is a convenience method to iterate through a list.\n-     * Unlike List.forEach, this method provides the consumer not only with an\n-     * element but also that element's index.\n-     *\n-     * See JDK-8184707.\n-     *\/\n-    private static <T> void forEachNumbered(List<T> list, ObjIntConsumer<? super T> action) {\n-        for (var iterator = list.listIterator(); iterator.hasNext(); ) {\n-            action.accept(iterator.next(), iterator.previousIndex());\n-        }\n+                System.out.println(msg);\n+                \"\"\";\n+        final var propertiesContent = \"\"\"\n+                user=jane\n+                home=\/home\/jane\n+                \"\"\";\n+        checkOutput(\"com\/example\/Cls.html\", true,\n+                getSnippetHtmlRepresentation(\"com\/example\/Cls.html\", javaContent, Optional.of(\"java\"), Optional.of(\"snippet1\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/Cls.html\", javaContent, Optional.of(\"java\"), Optional.of(\"snippet2\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/Cls.html\", javaContent, Optional.of(\"none\"), Optional.of(\"snippet3\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/Cls.html\", javaContent, Optional.of(\"none\"), Optional.of(\"snippet4\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/Cls.html\", javaContent, Optional.empty(), Optional.of(\"snippet5\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/Cls.html\", javaContent, Optional.empty(), Optional.of(\"snippet6\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/user.properties\", propertiesContent, Optional.of(\"properties\"), Optional.of(\"snippet7\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/user.properties\", propertiesContent, Optional.of(\"none\"), Optional.of(\"snippet8\")),\n+                getSnippetHtmlRepresentation(\"com\/example\/user.properties\", propertiesContent, Optional.empty(), Optional.of(\"snippet9\")));\n@@ -332,1 +301,1 @@\n-    public void testBadTagSyntax(Path base) throws IOException {\n+    public void testNegativeInlineTag_BadTagSyntax(Path base) throws IOException {\n@@ -669,37 +638,0 @@\n-    \/\/ TODO This is a temporary method; it should be removed after JavadocTester has provided similar functionality (JDK-8273154).\n-    private void checkOrder(Output output, String... strings) {\n-        String outputString = getOutput(output);\n-        int prevIndex = -1;\n-        for (String s : strings) {\n-            s = s.replace(\"\\n\", NL); \/\/ normalize new lines\n-            int currentIndex = outputString.indexOf(s, prevIndex + 1);\n-            checking(\"output: \" + output + \": \" + s + \" at index \" + currentIndex);\n-            if (currentIndex == -1) {\n-                failed(output + \": \" + s + \" not found.\");\n-                continue;\n-            }\n-            if (currentIndex > prevIndex) {\n-                passed(output + \": \" + \" is in the correct order\");\n-            } else {\n-                failed(output + \": \" + \" is in the wrong order.\");\n-            }\n-            prevIndex = currentIndex;\n-        }\n-    }\n-\n-    \/*\n-     * When checking for errors, it is important not to confuse one error with\n-     * another. This method checks that there are no crashes (which are also\n-     * errors) by checking for stack traces. We never expect crashes.\n-     *\/\n-    private void checkNoCrashes() {\n-        checking(\"check crashes\");\n-        Matcher matcher = Pattern.compile(\"\\s*at.*\\\\(.*\\\\.java:\\\\d+\\\\)\")\n-                .matcher(getOutput(Output.STDERR));\n-        if (!matcher.find()) {\n-            passed(\"\");\n-        } else {\n-            failed(\"Looks like a stacktrace: \" + matcher.group());\n-        }\n-    }\n-\n@@ -712,1 +644,1 @@\n-    public void testUnknownTag(Path base) throws IOException {\n+    public void testNegativeInlineTagUnknownTag(Path base) throws IOException {\n@@ -749,1 +681,1 @@\n-    public void testInline(Path base) throws Exception {\n+    public void testPositiveInlineTag(Path base) throws Exception {\n@@ -951,5 +883,1 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"><code>%s<\/code><\/pre>\n-                        <\/div>\"\"\".formatted(id, t.expectedOutput()));\n+                        %s\"\"\".formatted(id, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput())));\n@@ -960,1 +888,1 @@\n-    public void testExternalFile(Path base) throws Exception {\n+    public void testPositiveExternalTag_File(Path base) throws Exception {\n@@ -1047,5 +975,1 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"><code>%s<\/code><\/pre>\n-                        <\/div>\"\"\".formatted(index, expectedOutput));\n+                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", expectedOutput)));\n@@ -1055,14 +979,0 @@\n-    \/\/ TODO:\n-    \/\/   Explore the toolbox.ToolBox.writeFile and toolbox.ToolBox.writeJavaFiles methods:\n-    \/\/   see if any of them could be used instead of this one\n-    private void addSnippetFile(Path srcDir, String packageName, String fileName, String content) throws UncheckedIOException {\n-        String[] components = packageName.split(\"\\\\.\");\n-        Path snippetFiles = Path.of(components[0], Arrays.copyOfRange(components, 1, components.length)).resolve(\"snippet-files\");\n-        try {\n-            Path p = Files.createDirectories(srcDir.resolve(snippetFiles));\n-            Files.writeString(p.resolve(fileName), content, StandardOpenOption.CREATE_NEW);\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    }\n-\n@@ -1070,1 +980,1 @@\n-    public void testInlineSnippetInDocFiles(Path base) throws IOException {\n+    public void testPositiveInlineTag_InDocFiles(Path base) throws IOException {\n@@ -1112,1 +1022,1 @@\n-    public void testExternalSnippetInDocFiles(Path base) throws IOException {\n+    public void testPositiveExternalTag_InDocFiles(Path base) throws IOException {\n@@ -1154,1 +1064,1 @@\n-    public void testExternalFileNotFound(Path base) throws Exception {\n+    public void testNegativeExternalTag_FileNotFound(Path base) throws Exception {\n@@ -1177,2 +1087,2 @@\n-    @Test \/\/ TODO perhaps this could be unified with testExternalFile\n-    public void testExternalFileModuleSourcePath(Path base) throws Exception {\n+    @Test \/\/ TODO perhaps this could be unified with testPositiveExternalTagFile\n+    public void testNegativeExternalTag_FileModuleSourcePath(Path base) throws Exception {\n@@ -1203,2 +1113,2 @@\n-    @Test \/\/ TODO perhaps this could be unified with testExternalFileNotFound\n-    public void testExternalFileNotFoundModuleSourcePath(Path base) throws Exception {\n+    @Test \/\/ TODO perhaps this could be unified with testNegativeExternalTagFileNotFound\n+    public void testNegativeExternalTag_FileNotFoundModuleSourcePath(Path base) throws Exception {\n@@ -1233,1 +1143,1 @@\n-    public void testNoContents(Path base) throws Exception {\n+    public void testNegativeTag_NoContents(Path base) throws Exception {\n@@ -1253,1 +1163,31 @@\n-    public void testConflict20(Path base) throws Exception {\n+    public void testNegativeExternalTagMarkup(Path base) throws Exception {\n+        \/\/ External snippet issues are handled similarly to those of internal snippet\n+        Path srcDir = base.resolve(\"src\");\n+        Path outDir = base.resolve(\"out\");\n+        addSnippetFile(srcDir, \"pkg\", \"file.txt\", \"\"\"\n+                                                  \/\/ @start\n+                                                  \"\"\"\n+        );\n+        ClassBuilder classBuilder = new ClassBuilder(tb, \"pkg.A\")\n+                .setModifiers(\"public\", \"class\")\n+                .addMembers(\n+                        MethodBuilder\n+                                .parse(\"public void case0() { }\")\n+                                .setComments(\"\"\"\n+                                             {@snippet file=\"file.txt\"}\n+                                             \"\"\"));\n+        classBuilder.write(srcDir);\n+        javadoc(\"-d\", outDir.toString(),\n+                \"-sourcepath\", srcDir.toString(),\n+                \"pkg\");\n+        checkExit(Exit.ERROR);\n+        checkOutput(Output.OUT, true,\n+\"\"\"\n+: error: snippet markup: missing attribute \"region\"\n+\/\/ @start\n+    ^\"\"\");\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testNegativeInlineTag_AttributeConflict20(Path base) throws Exception {\n@@ -1279,1 +1219,1 @@\n-    public void testConflict30(Path base) throws Exception {\n+    public void testNegativeInlineTag_AttributeConflict30(Path base) throws Exception {\n@@ -1300,13 +1240,0 @@\n-    \/\/ TODO: perhaps this method could be added to JavadocTester\n-    private void checkOutputEither(Output out, String first, String... other) {\n-        checking(\"checkOutputEither\");\n-        String output = getOutput(out);\n-        Stream<String> strings = Stream.concat(Stream.of(first), Stream.of(other));\n-        Optional<String> any = strings.filter(output::contains).findAny();\n-        if (any.isPresent()) {\n-            passed(\": following text is found:\\n\" + any.get());\n-        } else {\n-            failed(\": nothing found\");\n-        }\n-    }\n-\n@@ -1314,1 +1241,1 @@\n-    public void testConflict60(Path base) throws Exception {\n+    public void testNegativeInlineTag_AttributeConflict60(Path base) throws Exception {\n@@ -1334,1 +1261,1 @@\n-    public void testConflict70(Path base) throws Exception {\n+    public void testNegativeInlineTag_AttributeConflict70(Path base) throws Exception {\n@@ -1354,1 +1281,1 @@\n-    public void testConflict80(Path base) throws Exception {\n+    public void testNegativeInlineTag_AttributeConflict80(Path base) throws Exception {\n@@ -1378,1 +1305,1 @@\n-    public void testConflict90(Path base) throws Exception {\n+    public void testNegativeInlineTag_AttributeConflict90(Path base) throws Exception {\n@@ -1402,1 +1329,1 @@\n-    public void testErrorPositionResolution(Path base) throws Exception {\n+    public void testNegativeTag_PositionResolution(Path base) throws Exception {\n@@ -1430,1 +1357,1 @@\n-    public void testRegion(Path base) throws Exception {\n+    public void testPositiveInlineTag_AttributeConflictRegion(Path base) throws Exception {\n@@ -1608,5 +1535,1 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"><code>%s<\/code><\/pre>\n-                        <\/div>\"\"\".formatted(index, t.expectedOutput()));\n+                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput())));\n@@ -1650,1 +1573,1 @@\n-    public void testAttributeValueSyntaxUnquotedCurly(Path base) throws Exception {\n+    public void testNegativeInlineTagMarkup_AttributeValueSyntaxUnquotedCurly(Path base) throws Exception {\n@@ -1684,1 +1607,1 @@\n-    public void testAttributeValueSyntaxCurly(Path base) throws Exception {\n+    public void testPositiveInlineTagMarkup_SyntaxCurly(Path base) throws Exception {\n@@ -1725,5 +1648,1 @@\n-                    <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySnippet\\\n-                    (this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" alt=\"Copy\"\\\n-                    ><\/button>\n-                    <pre class=\"snippet\"><code><\/code><\/pre>\n-                    <\/div>\"\"\");\n+                    \"\"\" + getSnippetHtmlRepresentation(\"pkg\/A.html\", \"\"));\n@@ -1734,5 +1653,1 @@\n-                    <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySnippet\\\n-                    (this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" alt=\"Copy\"\\\n-                    ><\/button>\n-                    <pre class=\"snippet\"><code><\/code><\/pre>\n-                    <\/div>\"\"\");\n+                    \"\"\" + getSnippetHtmlRepresentation(\"pkg\/A.html\", \"\"));\n@@ -1741,2 +1656,2 @@\n-    @Test\n-    public void testAttributeValueSyntax(Path base) throws Exception {\n+    @Test \/\/ TODO: use combinatorial methods\n+    public void testPositiveExternalTagMarkup_AttributeValueSyntax(Path base) throws Exception {\n@@ -1835,6 +1750,2 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"><code>2<\/code><\/pre>\n-                        <\/div>\n-                        \"\"\".formatted(j));\n+                        %s\n+                        \"\"\".formatted(j, getSnippetHtmlRepresentation(\"pkg\/A.html\", \"2\")));\n@@ -1845,1 +1756,1 @@\n-    public void testComment(Path base) throws Exception {\n+    public void testPositiveInlineTagMarkup_Comment(Path base) throws Exception {\n@@ -1919,5 +1830,1 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"><code>%s<\/code><\/pre>\n-                        <\/div>\"\"\".formatted(index, t.expectedOutput()));\n+                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput())));\n@@ -1928,1 +1835,1 @@\n-    public void testRedundantFileNotFound(Path base) throws Exception {\n+    public void testNegativeHybridTag_FileNotFound(Path base) throws Exception {\n@@ -1953,1 +1860,104 @@\n-    public void testRedundantRegionNotFound(Path base) throws Exception {\n+    public void testNegativeTag_ValuelessAttributes(Path base) throws IOException {\n+        \/\/ none of these attributes should ever be valueless\n+        record TestCase(String input, String expectedError) { }\n+        var testCases = new ArrayList<TestCase>();\n+        for (String attrName : List.of(\"class\", \"file\", \"id\", \"lang\", \"region\")) {\n+            \/\/ special case: valueless region attribute\n+            TestCase t = new TestCase(\"\"\"\n+{@snippet %s:\n+    First line\n+      Second line\n+}\n+\"\"\".formatted(attrName),\n+\"\"\"\n+: error: missing value for attribute \"%s\"\n+{@snippet %s:\n+          ^\"\"\".formatted(attrName, attrName));\n+            testCases.add(t);\n+        }\n+\n+        List<String> inputs = testCases.stream().map(s -> s.input).toList();\n+        StringBuilder methods = new StringBuilder();\n+        forEachNumbered(inputs, (i, n) -> {\n+            methods.append(\n+                    \"\"\"\n+\n+                    \/**\n+                    %s*\/\n+                    public void case%s() {}\n+                    \"\"\".formatted(i, n));\n+        });\n+\n+        String classString =\n+                \"\"\"\n+                public class A {\n+                %s\n+                }\n+                \"\"\".formatted(methods.toString());\n+\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.writeJavaFiles(src, classString);\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"A.java\").toString());\n+        checkExit(Exit.ERROR);\n+        \/\/ use the facility from JDK-8273154 when it becomes available\n+        checkOutput(Output.OUT, true, testCases.stream().map(TestCase::expectedError).toArray(String[]::new));\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testNegativeTag_BlankRegion(Path base) throws Exception {\n+        \/\/ If a blank region were allowed, it could not be used without quotes\n+        record TestCase(String input, String expectedError) { }\n+\n+      var testCases = new ArrayList<TestCase>();\n+      for (String quote : List.of(\"\", \"'\", \"\\\"\"))\n+          for (String value : List.of(\"\", \" \")) {\n+              var t = new TestCase(\"\"\"\n+{@snippet region=%s%s%s:\n+    First line\n+      Second line\n+}\n+\"\"\".formatted(quote, value, quote),\n+                      \"\"\"\n+: error: illegal value for attribute \"region\": \"%s\"\n+{@snippet region=%s%s%s:\n+          ^\"\"\".formatted(quote.isEmpty() ? \"\" : value, quote, value, quote)); \/\/ unquoted whitespace translates to empty string\n+              testCases.add(t);\n+          }\n+\n+        List<String> inputs = testCases.stream().map(s -> s.input).toList();\n+        StringBuilder methods = new StringBuilder();\n+        forEachNumbered(inputs, (i, n) -> {\n+            methods.append(\n+                    \"\"\"\n+\n+                    \/**\n+                    %s*\/\n+                    public void case%s() {}\n+                    \"\"\".formatted(i, n));\n+        });\n+\n+        String classString =\n+                \"\"\"\n+                public class A {\n+                %s\n+                }\n+                \"\"\".formatted(methods.toString());\n+\n+        Path src = Files.createDirectories(base.resolve(\"src\"));\n+        tb.writeJavaFiles(src, classString);\n+\n+        javadoc(\"-d\", base.resolve(\"out\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"A.java\").toString());\n+        checkExit(Exit.ERROR);\n+        \/\/ use the facility from JDK-8273154 when it becomes available\n+        checkOutput(Output.OUT, true, testCases.stream().map(TestCase::expectedError).toArray(String[]::new));\n+        checkNoCrashes();\n+    }\n+\n+    @Test\n+    public void testNegativeHybridTagMarkup_RegionNotFound(Path base) throws Exception {\n@@ -1984,1 +1994,1 @@\n-    public void testRedundantMismatch(Path base) throws Exception {\n+    public void testNegativeHybridTag_Mismatch(Path base) throws Exception {\n@@ -2013,1 +2023,1 @@\n-    public void testRedundantRegionRegionMismatch(Path base) throws Exception {\n+    public void testNegativeHybridTagMarkup_RegionRegionMismatch(Path base) throws Exception {\n@@ -2053,1 +2063,1 @@\n-    public void testRedundantRegion1Mismatch(Path base) throws Exception {\n+    public void testNegativeHybridTagMarkup_Region1Mismatch(Path base) throws Exception {\n@@ -2087,1 +2097,1 @@\n-    public void testRedundantRegion2Mismatch(Path base) throws Exception {\n+    public void testNegativeHybridTagMarkup_Region2Mismatch(Path base) throws Exception {\n@@ -2124,1 +2134,1 @@\n-    public void testRedundant(Path base) throws Exception {\n+    public void testPositiveHybridTagMarkup(Path base) throws Exception {\n@@ -2251,5 +2261,1 @@\n-                        <div class=\"snippet-container\"><button class=\"snippet-copy\" onclick=\"copySni\\\n-                        ppet(this)\"><span data-copied=\"Copied!\">Copy<\/span><img src=\"..\/copy.svg\" al\\\n-                        t=\"Copy\"><\/button>\n-                        <pre class=\"snippet\"><code>%s<\/code><\/pre>\n-                        <\/div>\"\"\".formatted(index, t.expectedOutput()));\n+                        %s\"\"\".formatted(index, getSnippetHtmlRepresentation(\"pkg\/A.html\", t.expectedOutput())));\n@@ -2260,1 +2266,1 @@\n-    public void testInvalidRegexDiagnostics(Path base) throws Exception {\n+    public void testNegativeInlineTagMarkup_InvalidRegexDiagnostics(Path base) throws Exception {\n@@ -2344,1 +2350,1 @@\n-    public void testErrorMessages(Path base) throws Exception {\n+    public void testNegativeInlineTagMarkup_ErrorMessages(Path base) throws Exception {\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSnippetTag\/TestSnippetTag.java","additions":234,"deletions":228,"binary":false,"changes":462,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8270139\n+ * @bug 8270139 8273039\n@@ -40,0 +40,1 @@\n+import static jdk.jshell.Snippet.Status.REJECTED;\n@@ -52,0 +53,7 @@\n+\n+    public void testBrokenName() {\n+        assertEval(\"int strictfp = 0;\",\n+                   DiagCheck.DIAG_ERROR,\n+                   DiagCheck.DIAG_IGNORE,\n+                   ste(MAIN_SNIPPET, NONEXISTENT, REJECTED, false, null));\n+    }\n","filename":"test\/langtools\/jdk\/jshell\/ErrorRecoveryTest.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -556,1 +556,1 @@\n-        test(\n+        test(new String[]{\"-R\", \"-Duser.language=en\", \"-R\", \"-Duser.country=US\"},\n","filename":"test\/langtools\/jdk\/jshell\/ToolBasicTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8268725\n+ * @summary Tests for the --enable-native-access option\n+ * @modules jdk.jshell\n+ * @run testng ToolEnableNativeAccessTest\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertTrue;\n+\n+public class ToolEnableNativeAccessTest extends ReplToolTesting {\n+\n+    @Test\n+    public void testOptionDebug() {\n+        test(\n+                (a) -> assertCommand(a, \"\/debug b\",\n+                        \"RemoteVM Options: []\\n\"\n+                        + \"Compiler options: []\"),\n+                (a) -> assertCommand(a, \"\/env --enable-native-access\",\n+                        \"|  Setting new options and restoring state.\"),\n+                (a) -> assertCommandCheckOutput(a, \"\/debug b\", s -> {\n+                    assertTrue(s.contains(\"RemoteVM Options: [--enable-native-access, ALL-UNNAMED]\"));\n+                    assertTrue(s.contains(\"Compiler options: []\"));\n+                })\n+        );\n+    }\n+\n+    @Test\n+    public void testCommandLineFlag() {\n+        test(new String[] {\"--enable-native-access\"},\n+                (a) -> assertCommandCheckOutput(a, \"\/debug b\", s -> {\n+                    assertTrue(s.contains(\"RemoteVM Options: [--enable-native-access, ALL-UNNAMED]\"));\n+                    assertTrue(s.contains(\"Compiler options: []\"));\n+                })\n+        );\n+    }\n+\n+}\n","filename":"test\/langtools\/jdk\/jshell\/ToolEnableNativeAccessTest.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -747,1 +747,2 @@\n-        test(new String[]{\"--startup\", \"DEFAULT\", \"--startup\", \"PRINTING\"},\n+        test(new String[]{\"-R\", \"-Duser.language=en\", \"-R\", \"-Duser.country=US\",\n+                          \"--startup\", \"DEFAULT\", \"--startup\", \"PRINTING\"},\n","filename":"test\/langtools\/jdk\/jshell\/ToolSimpleTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -10,0 +10,2 @@\n+import java.util.Objects;\n+\n@@ -25,1 +27,6 @@\n-    class Outer {}\n+    class Outer {\n+        {\n+            \/\/ access enclosing instance so this$0 field is generated\n+            Objects.requireNonNull(T6521805.this);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/6521805\/T6521805d.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-T6521805d.java:18:18: compiler.err.cannot.generate.class: T6521805.Inner, (compiler.misc.synthetic.name.conflict: this$0, T6521805.Inner)\n+T6521805d.java:20:18: compiler.err.cannot.generate.class: T6521805.Inner, (compiler.misc.synthetic.name.conflict: this$0, T6521805.Inner)\n","filename":"test\/langtools\/tools\/javac\/6521805\/T6521805d.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5,0 +5,2 @@\n+import java.util.Objects;\n+\n@@ -6,1 +8,6 @@\n-    class Super {}\n+    class Super {\n+        {\n+            \/\/ access enclosing instance so this$0 field is generated\n+            Objects.requireNonNull(Outer.this);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/6521805\/p\/Outer.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4,2 +4,0 @@\n-FIELD  this$0\n---- FINAL\n@@ -23,2 +21,0 @@\n-FIELD  this$1\n---- FINAL\n@@ -32,2 +28,0 @@\n-FIELD  this$0\n---- FINAL\n","filename":"test\/langtools\/tools\/javac\/ClassFileModifiers\/MemberModifiers.out","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-        if (!javapOut.contains(\"0: #22(): CLASS_EXTENDS, type_index=65535\"))\n+        if (!javapOut.contains(\"0: #20(): CLASS_EXTENDS, type_index=65535\"))\n@@ -65,1 +65,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/AnnotatedExtendsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8273039\n+ * @summary Verify error recovery in Attr\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main AttrRecoveryTest\n+*\/\n+\n+import com.sun.source.tree.AnnotationTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.ErroneousTree;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskListener;\n+import com.sun.source.util.TreePath;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import javax.lang.model.element.Element;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class AttrRecoveryTest extends TestRunner {\n+\n+    ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new AttrRecoveryTest().runTests();\n+    }\n+\n+    AttrRecoveryTest() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testModifiers(Path base) throws Exception {\n+        record TestCase(String name, String source, String expectedAnnotation, String... errors) {}\n+        TestCase[] tests = new TestCase[] {\n+            new TestCase(\"a\",\n+                         \"\"\"\n+                         public class Test {\n+                             Object i () { return int strictfp @Deprecated = 0; }\n+                         }\n+                         \"\"\",\n+                         \"java.lang.Deprecated\",\n+                         \"Test.java:2:30: compiler.err.dot.class.expected\",\n+                         \"Test.java:2:51: compiler.err.expected4: class, interface, enum, record\",\n+                         \"Test.java:2:26: compiler.err.unexpected.type: kindname.value, kindname.class\",\n+                         \"3 errors\"),\n+            new TestCase(\"b\",\n+                         \"\"\"\n+                         public class Test {\n+                             Object i () { return int strictfp = 0; }\n+                         }\n+                         \"\"\",\n+                         null,\n+                         \"Test.java:2:30: compiler.err.dot.class.expected\",\n+                         \"Test.java:2:39: compiler.err.expected4: class, interface, enum, record\",\n+                         \"Test.java:2:26: compiler.err.unexpected.type: kindname.value, kindname.class\",\n+                         \"3 errors\")\n+        };\n+        for (TestCase test : tests) {\n+            Path current = base.resolve(\"\" + test.name);\n+            Path src = current.resolve(\"src\");\n+            Path classes = current.resolve(\"classes\");\n+            tb.writeJavaFiles(src,\n+                              test.source);\n+\n+            Files.createDirectories(classes);\n+\n+            var log =\n+                    new JavacTask(tb)\n+                        .options(\"-XDrawDiagnostics\",\n+                                 \"-XDshould-stop.at=FLOW\",\n+                                 \"-Xlint:-preview\")\n+                        .outdir(classes)\n+                        .files(tb.findJavaFiles(src))\n+                        .callback(t -> {\n+                            t.addTaskListener(new TaskListener() {\n+                                CompilationUnitTree parsed;\n+                                @Override\n+                                public void finished(TaskEvent e) {\n+                                    switch (e.getKind()) {\n+                                        case PARSE -> parsed = e.getCompilationUnit();\n+                                        case ANALYZE ->\n+                                            checkAnnotationsValid(t, parsed, test.expectedAnnotation);\n+                                    }\n+                                }\n+                            });\n+                        })\n+                        .run(Task.Expect.FAIL, 1)\n+                        .writeAll()\n+                        .getOutputLines(Task.OutputKind.DIRECT);\n+            if (!List.of(test.errors).equals(log)) {\n+                throw new AssertionError(\"Incorrect errors, expected: \" + List.of(test.errors) +\n+                                          \", actual: \" + log);\n+            }\n+        }\n+    }\n+\n+    private void checkAnnotationsValid(com.sun.source.util.JavacTask task,\n+                                       CompilationUnitTree cut,\n+                                       String expected) {\n+        boolean[] foundAnnotation = new boolean[1];\n+        Trees trees = Trees.instance(task);\n+\n+        new TreePathScanner<Void, Void>() {\n+            @Override\n+            public Void visitAnnotation(AnnotationTree node, Void p) {\n+                TreePath typePath = new TreePath(getCurrentPath(), node.getAnnotationType());\n+                Element el = trees.getElement(typePath);\n+                if (el == null || !el.equals(task.getElements().getTypeElement(expected))) {\n+                    throw new AssertionError();\n+                }\n+                foundAnnotation[0] = true;\n+                return super.visitAnnotation(node, p);\n+            }\n+\n+            @Override\n+            public Void visitErroneous(ErroneousTree node, Void p) {\n+                return scan(node.getErrorTrees(), p);\n+            }\n+        }.scan(cut, null);\n+        if (foundAnnotation[0] ^ (expected != null)) {\n+            throw new AssertionError();\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/attr\/AttrRecoveryTest.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -47,1 +47,0 @@\n-        expectedNumberOfSyntheticFields = 1,\n@@ -50,2 +49,1 @@\n-        expectedMethods = {\"<init>(AccessToPrivateInnerClassConstructorsTest)\"},\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedMethods = {\"<init>(AccessToPrivateInnerClassConstructorsTest)\"})\n@@ -53,2 +51,1 @@\n-        expectedMethods = {\"<init>(AccessToPrivateInnerClassConstructorsTest)\"},\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedMethods = {\"<init>(AccessToPrivateInnerClassConstructorsTest)\"})\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Synthetic\/AccessToPrivateInnerClassConstructorsTest.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,2 +46,1 @@\n- * 6. field this in Inner1.\n- * 7. constructor for Inner*.\n+ * 6. constructor for Inner*.\n@@ -53,2 +52,1 @@\n-        expectedFields = \"var\",\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedFields = \"var\")\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Synthetic\/AccessToPrivateInnerClassMembersTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,2 +46,1 @@\n- * 6. field this in Inner1.\n- * 7. constructor for Inner*.\n+ * 6. constructor for Inner*.\n@@ -52,2 +51,1 @@\n-        expectedFields = \"var\",\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedFields = \"var\")\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Synthetic\/AccessToPrivateSiblingsTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-        expectedNumberOfSyntheticMethods = 1,\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedNumberOfSyntheticMethods = 1)\n@@ -65,2 +64,1 @@\n-        expectedMethods = {\"<init>(BridgeMethodsForLambdaTest)\", \"function()\"},\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedMethods = {\"<init>(BridgeMethodsForLambdaTest)\", \"function()\"})\n@@ -69,2 +67,1 @@\n-        expectedNumberOfSyntheticMethods = 1,\n-        expectedNumberOfSyntheticFields = 1)\n+        expectedNumberOfSyntheticMethods = 1)\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Synthetic\/BridgeMethodsForLambdaTest.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import java.util.Objects;\n+\n@@ -52,0 +54,4 @@\n+            {\n+                \/\/ access enclosing instance so this$0 field is generated\n+                Objects.requireNonNull(ThisFieldTest.this);\n+            }\n@@ -55,0 +61,4 @@\n+            {\n+                \/\/ access enclosing instance so this$0 field is generated\n+                Objects.requireNonNull(ThisFieldTest.this);\n+            }\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/Synthetic\/ThisFieldTest.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.util.Objects;\n+\n@@ -33,1 +35,6 @@\n-    public class Inner extends Outer { }\n+    public class Inner extends Outer {\n+        {\n+            \/\/ access enclosing instance so this$0 field is generated\n+            Objects.requireNonNull(ErrSyntheticNameConflict.this);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ErrSyntheticNameConflict.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng LambdaTranslationTest1\n+ * @run testng\/othervm -Duser.language=en -Duser.country=US LambdaTranslationTest1\n","filename":"test\/langtools\/tools\/javac\/lambda\/lambdaExecution\/LambdaTranslationTest1.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng LambdaTranslationTest2\n+ * @run testng\/othervm -Duser.language=en -Duser.country=US LambdaTranslationTest2\n","filename":"test\/langtools\/tools\/javac\/lambda\/lambdaExecution\/LambdaTranslationTest2.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2021, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+\/**\n+ * @test\n+ * @bug 8271623\n+ *\n+ * @compile --release 17 DontOptimizeOuterThis.java InnerClasses.java\n+ * @run main DontOptimizeOuterThis\n+ *\/\n+public class DontOptimizeOuterThis extends InnerClasses {\n+\n+    public static void main(String[] args) {\n+        new DontOptimizeOuterThis().test();\n+    }\n+\n+    public void test() {\n+        checkInner(localCapturesParameter(0), true);\n+        checkInner(localCapturesLocal(), true);\n+        checkInner(localCapturesEnclosing(), true);\n+\n+        checkInner(anonCapturesParameter(0), true);\n+        checkInner(anonCapturesLocal(), true);\n+        checkInner(anonCapturesEnclosing(), true);\n+\n+        checkInner(StaticMemberClass.class, false); \/\/ static\n+        checkInner(NonStaticMemberClass.class, true);\n+        checkInner(NonStaticMemberClassCapturesEnclosing.class, true);\n+\n+        checkInner(N0.class, false); \/\/ static\n+        checkInner(N0.N1.class, true);\n+        checkInner(N0.N1.N2.class, true);\n+        checkInner(N0.N1.N2.N3.class, true);\n+        checkInner(N0.N1.N2.N3.N4.class, true);\n+        checkInner(N0.N1.N2.N3.N4.N5.class, true);\n+\n+        checkInner(SerializableCapture.class, true);\n+        checkInner(SerializableWithSerialVersionUID.class, true);\n+        checkInner(SerializableWithInvalidSerialVersionUIDType.class, true);\n+        checkInner(SerializableWithInvalidSerialVersionUIDNonFinal.class, true);\n+        checkInner(SerializableWithInvalidSerialVersionUIDNonStatic.class, true);\n+    }\n+\n+    private static void checkInner(Class<?> clazz, boolean expectOuterThis) {\n+        Optional<Field> outerThis = Arrays.stream(clazz.getDeclaredFields())\n+                .filter(f -> f.getName().startsWith(\"this$\")).findFirst();\n+        if (expectOuterThis) {\n+            if (outerThis.isEmpty()) {\n+                throw new AssertionError(\n+                        String.format(\n+                                \"expected %s to have an enclosing instance\", clazz.getName()));\n+            }\n+        } else {\n+            if (outerThis.isPresent()) {\n+                throw new AssertionError(\n+                        String.format(\"%s had an unexpected enclosing instance\", clazz.getName()));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/optimizeOuterThis\/DontOptimizeOuterThis.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2021, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.Serializable;\n+\n+public class InnerClasses {\n+\n+    public Class<?> localCapturesParameter(final int x) {\n+        class Local {\n+            public void f() {\n+                System.err.println(x);\n+            }\n+        }\n+        return Local.class;\n+    }\n+\n+    public Class<?> localCapturesLocal() {\n+        final int x = 0;\n+        class Local {\n+            public void f() {\n+                System.err.println(x);\n+            }\n+        }\n+        return Local.class;\n+    }\n+\n+    public Class<?> localCapturesEnclosing() {\n+        class Local {\n+            public void f() {\n+                System.err.println(InnerClasses.this);\n+            }\n+        }\n+        return Local.class;\n+    }\n+\n+    public Class<?> anonCapturesParameter(final int x) {\n+        return new Object() {\n+            public void f() {\n+                System.err.println(x);\n+            }\n+        }.getClass();\n+    }\n+\n+    public Class<?> anonCapturesLocal() {\n+        final int x = 0;\n+        return new Object() {\n+            public void f() {\n+                System.err.println(x);\n+            }\n+        }.getClass();\n+    }\n+\n+    public Class<?> anonCapturesEnclosing() {\n+        return new Object() {\n+            public void f() {\n+                System.err.println(InnerClasses.this);\n+            }\n+        }.getClass();\n+    }\n+\n+    public static class StaticMemberClass {}\n+\n+    public class NonStaticMemberClass {}\n+\n+    public class NonStaticMemberClassCapturesEnclosing {\n+        public void f() {\n+            System.err.println(InnerClasses.this);\n+        }\n+    }\n+\n+    static class N0 {\n+        int x;\n+\n+        class N1 {\n+            class N2 {\n+                class N3 {\n+                    void f() {\n+                        System.err.println(x);\n+                    }\n+\n+                    class N4 {\n+                        class N5 {}\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    class SerializableCapture implements Serializable {\n+      void f() {\n+        System.err.println(InnerClasses.this);\n+      }\n+    }\n+\n+    class SerializableWithSerialVersionUID implements Serializable {\n+      private static final long serialVersionUID = 0;\n+    }\n+\n+    class SerializableWithInvalidSerialVersionUIDType implements Serializable {\n+      private static final int serialVersionUID = 0;\n+    }\n+\n+    class SerializableWithInvalidSerialVersionUIDNonFinal implements Serializable {\n+      private static long serialVersionUID = 0;\n+    }\n+\n+    class SerializableWithInvalidSerialVersionUIDNonStatic implements Serializable {\n+      private final long serialVersionUID = 0;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/optimizeOuterThis\/InnerClasses.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Google LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+\/**\n+ * @test\n+ * @bug 8271623\n+ *\n+ * @clean *\n+ * @compile OptimizeOuterThis.java InnerClasses.java\n+ * @run main OptimizeOuterThis\n+ *\n+ * @clean *\n+ * @compile -XDoptimizeOuterThis=true --release 17 OptimizeOuterThis.java InnerClasses.java\n+ * @run main OptimizeOuterThis\n+ *\/\n+public class OptimizeOuterThis extends InnerClasses {\n+\n+    public static void main(String[] args) {\n+        new OptimizeOuterThis().test();\n+    }\n+\n+    public void test() {\n+        checkInner(localCapturesParameter(0), false);\n+        checkInner(localCapturesLocal(), false);\n+        checkInner(localCapturesEnclosing(), true);\n+\n+        checkInner(anonCapturesParameter(0), false);\n+        checkInner(anonCapturesLocal(), false);\n+        checkInner(anonCapturesEnclosing(), true);\n+\n+        checkInner(StaticMemberClass.class, false);\n+        checkInner(NonStaticMemberClass.class, false);\n+        checkInner(NonStaticMemberClassCapturesEnclosing.class, true);\n+\n+        checkInner(N0.class, false);\n+        checkInner(N0.N1.class, true);\n+        checkInner(N0.N1.N2.class, true);\n+        checkInner(N0.N1.N2.N3.class, true);\n+        checkInner(N0.N1.N2.N3.N4.class, false);\n+        checkInner(N0.N1.N2.N3.N4.N5.class, false);\n+\n+        checkInner(SerializableCapture.class, true);\n+        checkInner(SerializableWithSerialVersionUID.class, false);\n+        checkInner(SerializableWithInvalidSerialVersionUIDType.class, true);\n+        checkInner(SerializableWithInvalidSerialVersionUIDNonFinal.class, true);\n+        checkInner(SerializableWithInvalidSerialVersionUIDNonStatic.class, true);\n+    }\n+\n+    private static void checkInner(Class<?> clazz, boolean expectOuterThis) {\n+        Optional<Field> outerThis = Arrays.stream(clazz.getDeclaredFields())\n+                .filter(f -> f.getName().startsWith(\"this$\")).findFirst();\n+        if (expectOuterThis) {\n+            if (outerThis.isEmpty()) {\n+                throw new AssertionError(\n+                        String.format(\n+                                \"expected %s to have an enclosing instance\", clazz.getName()));\n+            }\n+        } else {\n+            if (outerThis.isPresent()) {\n+                throw new AssertionError(\n+                        String.format(\"%s had an unexpected enclosing instance %s\", clazz.getName(), outerThis.get()));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/optimizeOuterThis\/OptimizeOuterThis.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,596 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8224922\n+ * @summary Verify the behavior of the Elements.getFileObjectOf\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ * @build toolbox.ToolBox toolbox.JavacTask toolbox.TestRunner\n+ * @build TestFileObjectOf\n+ * @run main TestFileObjectOf\n+ *\/\n+\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TreePath;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayDeque;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.Set;\n+\n+import javax.annotation.processing.*;\n+import javax.lang.model.SourceVersion;\n+import javax.lang.model.element.*;\n+import javax.lang.model.util.Elements;\n+\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n+import javax.tools.JavaFileObject;\n+import toolbox.JarTask;\n+import toolbox.JavacTask;\n+import toolbox.Task;\n+import toolbox.TestRunner;\n+import toolbox.ToolBox;\n+\n+public class TestFileObjectOf extends TestRunner {\n+\n+    private final ToolBox tb;\n+\n+    TestFileObjectOf() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new TestFileObjectOf().runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testSourceFiles(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          module m {}\n+                          \"\"\",\n+                          \"\"\"\n+                          package test;\n+                          \"\"\",\n+                          \"\"\"\n+                          package test;\n+                          public class TestClass {\n+                              int fieldTestClass;\n+                              TestClass() { }\n+                              void methodTestClass(int parameterTestClass) {\n+                                  int localTestClass;\n+                              }\n+                              public static class InnerClass {\n+                                  int fieldInnerClass;\n+                                  InnerClass() {}\n+                                  void methodInnerClass(int parameterInnerClass) {\n+                                      int localInnerClass;\n+                                  }\n+                              }\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package test;\n+                          public enum TestEnum {\n+                              CONSTANT;\n+                          }\n+                          \"\"\",\n+                          \"\"\"\n+                          package test2;\n+                          public class TestClass2 {}\n+                          \"\"\");\n+        Path classes = base.resolve(\"classes\").resolve(\"m\");\n+        tb.createDirectories(classes);\n+\n+        \/\/from source, implicit:\n+        {\n+            String moduleInfoSource = src.resolve(\"module-info.java\").toUri().toString();\n+            String packageInfoSource = src.resolve(\"test\").resolve(\"package-info.java\").toUri().toString();\n+            String testClassSource = src.resolve(\"test\").resolve(\"TestClass.java\").toUri().toString();\n+            String testEnumSource = src.resolve(\"test\").resolve(\"TestEnum.java\").toUri().toString();\n+            String testClass2Source = src.resolve(\"test2\").resolve(\"TestClass2.java\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-Xpkginfo:always\",\n+                         \"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", PrintFiles.class.getName(),\n+                         \"-sourcepath\", src.toString())\n+                .outdir(classes)\n+                .classes(\"java.lang.Object\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \"m: \" + moduleInfoSource,\n+                    \"test: \" + packageInfoSource,\n+                    \"test2: \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"TestEnum: \" + testEnumSource,\n+                    \"TestClass2: \" + testClass2Source,\n+                    \"<init>: \" + testClassSource,\n+                    \"InnerClass: \" + testClassSource,\n+                    \"fieldTestClass: \" + testClassSource,\n+                    \"methodTestClass: \" + testClassSource,\n+                    \"parameterTestClass: \" + testClassSource,\n+                    \"localTestClass: \" + testClassSource,\n+                    \"<init>: \" + testEnumSource,\n+                    \"CONSTANT: \" + testEnumSource,\n+                    \"valueOf: \" + testEnumSource,\n+                    \"values: \" + testEnumSource,\n+                    \"<init>: \" + testClass2Source,\n+                    \"<init>: \" + testClassSource,\n+                    \"fieldInnerClass: \" + testClassSource,\n+                    \"methodInnerClass: \" + testClassSource,\n+                    \"parameterInnerClass: \" + testClassSource,\n+                    \"localInnerClass: \" + testClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+\n+        tb.cleanDirectory(classes);\n+\n+        \/\/from source, explicit:\n+        {\n+            String moduleInfoSource = src.resolve(\"module-info.java\").toUri().toString();\n+            String packageInfoSource = src.resolve(\"test\").resolve(\"package-info.java\").toUri().toString();\n+            String testClassSource = src.resolve(\"test\").resolve(\"TestClass.java\").toUri().toString();\n+            String testEnumSource = src.resolve(\"test\").resolve(\"TestEnum.java\").toUri().toString();\n+            String testClass2Source = src.resolve(\"test2\").resolve(\"TestClass2.java\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-Xpkginfo:always\",\n+                         \"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", PrintFiles.class.getName())\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \"m: \" + moduleInfoSource,\n+                    \"test: \" + packageInfoSource,\n+                    \"test2: \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"TestEnum: \" + testEnumSource,\n+                    \"TestClass2: \" + testClass2Source,\n+                    \"<init>: \" + testClassSource,\n+                    \"InnerClass: \" + testClassSource,\n+                    \"fieldTestClass: \" + testClassSource,\n+                    \"methodTestClass: \" + testClassSource,\n+                    \"parameterTestClass: \" + testClassSource,\n+                    \"localTestClass: \" + testClassSource,\n+                    \"<init>: \" + testEnumSource,\n+                    \"CONSTANT: \" + testEnumSource,\n+                    \"valueOf: \" + testEnumSource,\n+                    \"values: \" + testEnumSource,\n+                    \"<init>: \" + testClass2Source,\n+                    \"<init>: \" + testClassSource,\n+                    \"fieldInnerClass: \" + testClassSource,\n+                    \"methodInnerClass: \" + testClassSource,\n+                    \"parameterInnerClass: \" + testClassSource,\n+                    \"localInnerClass: \" + testClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+\n+        \/\/from class:\n+        {\n+            String moduleInfoSource = classes.resolve(\"module-info.class\").toUri().toString();\n+            String packageInfoSource = classes.resolve(\"test\").resolve(\"package-info.class\").toUri().toString();\n+            String testClassSource = classes.resolve(\"test\").resolve(\"TestClass.class\").toUri().toString();\n+            String testInnerClassSource = classes.resolve(\"test\").resolve(\"TestClass$InnerClass.class\").toUri().toString();\n+            String testEnumSource = classes.resolve(\"test\").resolve(\"TestEnum.class\").toUri().toString();\n+            String testClass2Source = classes.resolve(\"test2\").resolve(\"TestClass2.class\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", PrintFiles.class.getName(),\n+                         \"--module-path\", classes.toString(),\n+                         \"--add-modules\", \"m\")\n+                .outdir(classes)\n+                .classes(\"java.lang.Object\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \"m: \" + moduleInfoSource,\n+                    \"test: \" + packageInfoSource,\n+                    \"test2: \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"TestEnum: \" + testEnumSource,\n+                    \"TestClass2: \" + testClass2Source,\n+                    \"<init>: \" + testClassSource,\n+                    \"InnerClass: \" + testInnerClassSource,\n+                    \"fieldTestClass: \" + testClassSource,\n+                    \"methodTestClass: \" + testClassSource,\n+                    \"<clinit>: \" + testEnumSource,\n+                    \"<init>: \" + testEnumSource,\n+                    \"CONSTANT: \" + testEnumSource,\n+                    \"valueOf: \" + testEnumSource,\n+                    \"values: \" + testEnumSource,\n+                    \"<init>: \" + testClass2Source,\n+                    \"<init>: \" + testInnerClassSource,\n+                    \"fieldInnerClass: \" + testInnerClassSource,\n+                    \"methodInnerClass: \" + testInnerClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    @SupportedOptions(\"fromClass\")\n+    public static final class PrintFiles extends AbstractProcessor {\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            if (!roundEnv.processingOver())\n+                return false;\n+\n+            Elements elements = processingEnv.getElementUtils();\n+            Trees trees = Trees.instance(processingEnv);\n+            Queue<Element> q = new ArrayDeque<>();\n+            q.add(elements.getModuleElement(\"m\"));\n+\n+            while (!q.isEmpty()) {\n+                Element currentElement = q.remove();\n+\n+                handleDeclaration(currentElement);\n+\n+                switch (currentElement.getKind()) {\n+                    case METHOD -> {\n+                        ExecutableElement method = (ExecutableElement) currentElement;\n+                        TreePath tp = trees.getPath(method);\n+                        if (tp != null) {\n+                            new TreePathScanner<>() {\n+                                @Override\n+                                public Object visitVariable(VariableTree node, Object p) {\n+                                    Element el = trees.getElement(getCurrentPath());\n+                                    handleDeclaration(el);\n+                                    return super.visitVariable(node, p);\n+                                }\n+                            }.scan(tp, null);\n+                        }\n+                    }\n+                    case MODULE -> {\n+                        q.add(elements.getPackageElement(\"test\"));\n+                        q.add(elements.getPackageElement(\"test2\"));\n+                    }\n+                    default ->\n+                        currentElement.getEnclosedElements()\n+                                      .stream()\n+                                      .sorted((e1, e2) -> e1.getSimpleName().toString().compareTo(e2.getSimpleName().toString()))\n+                                      .forEach(q::add);\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        void handleDeclaration(Element el) {\n+            Elements elements = processingEnv.getElementUtils();\n+            JavaFileObject fileObjects = elements.getFileObjectOf(el);\n+            System.out.println(el.getSimpleName() + \": \" + (fileObjects != null ? fileObjects.toUri().toString() : \"<null>\"));\n+        }\n+\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latestSupported();\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testUnnamed(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          public class TestClass {\n+                          }\n+                          \"\"\");\n+        Path classes = base.resolve(\"classes\");\n+        tb.createDirectories(classes);\n+\n+        \/\/from source, implicit:\n+        {\n+            String testClassSource = src.resolve(\"TestClass.java\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-Xpkginfo:always\",\n+                         \"-classpath\", \"\",\n+                         \"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", UnnamedPrintFiles.class.getName(),\n+                         \"-sourcepath\", src.toString())\n+                .outdir(classes)\n+                .classes(\"java.lang.Object\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \": \" + \"<null>\",\n+                    \": \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"<init>: \" + testClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+\n+        tb.cleanDirectory(classes);\n+\n+        \/\/from source, explicit:\n+        {\n+            String testClassSource = src.resolve(\"TestClass.java\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-Xpkginfo:always\",\n+                         \"-classpath\", \"\",\n+                         \"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", UnnamedPrintFiles.class.getName())\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \": \" + \"<null>\",\n+                    \": \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"<init>: \" + testClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+\n+        \/\/from class:\n+        {\n+            String testClassSource = classes.resolve(\"TestClass.class\").toUri().toString();\n+\n+            List<String> log;\n+\n+            log = new JavacTask(tb)\n+                .options(\"-processorpath\", System.getProperty(\"test.classes\"),\n+                         \"-processor\", UnnamedPrintFiles.class.getName(),\n+                         \"-classpath\", classes.toString())\n+                .outdir(classes)\n+                .classes(\"java.lang.Object\")\n+                .run()\n+                .writeAll()\n+                .getOutputLines(Task.OutputKind.STDOUT);\n+\n+            List<String> expected = List.of(\n+                    \": \" + \"<null>\",\n+                    \": \" + \"<null>\",\n+                    \"TestClass: \" + testClassSource,\n+                    \"<init>: \" + testClassSource\n+            );\n+\n+            if (!expected.equals(log))\n+                throw new AssertionError(\"expected output not found: \" + log);\n+        }\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    @SupportedOptions(\"fromClass\")\n+    public static final class UnnamedPrintFiles extends AbstractProcessor {\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            if (!roundEnv.processingOver())\n+                return false;\n+\n+            Elements elements = processingEnv.getElementUtils();\n+            Trees trees = Trees.instance(processingEnv);\n+            Queue<Element> q = new ArrayDeque<>();\n+            q.add(elements.getModuleElement(\"\"));\n+\n+            while (!q.isEmpty()) {\n+                Element currentElement = q.remove();\n+\n+                handleDeclaration(currentElement);\n+\n+                switch (currentElement.getKind()) {\n+                    case METHOD -> {\n+                        ExecutableElement method = (ExecutableElement) currentElement;\n+                        TreePath tp = trees.getPath(method);\n+                        if (tp != null) {\n+                            new TreePathScanner<>() {\n+                                @Override\n+                                public Object visitVariable(VariableTree node, Object p) {\n+                                    Element el = trees.getElement(getCurrentPath());\n+                                    handleDeclaration(el);\n+                                    return super.visitVariable(node, p);\n+                                }\n+                            }.scan(tp, null);\n+                        }\n+                    }\n+                    case MODULE -> {\n+                        q.add(elements.getPackageElement(\"\"));\n+                    }\n+                    default ->\n+                        currentElement.getEnclosedElements()\n+                                      .stream()\n+                                      .sorted((e1, e2) -> e1.getSimpleName().toString().compareTo(e2.getSimpleName().toString()))\n+                                      .forEach(q::add);\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        void handleDeclaration(Element el) {\n+            Elements elements = processingEnv.getElementUtils();\n+            JavaFileObject fileObjects = elements.getFileObjectOf(el);\n+            System.out.println(el.getSimpleName() + \": \" + (fileObjects != null ? fileObjects.toUri().toString() : \"<null>\"));\n+        }\n+\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latestSupported();\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testAutomaticModule(Path base) throws Exception {\n+        Path src = base.resolve(\"src\");\n+        tb.writeJavaFiles(src,\n+                          \"\"\"\n+                          package test;\n+                          public class TestClass {\n+                          }\n+                          \"\"\");\n+        Path classes = base.resolve(\"classes\");\n+        tb.createDirectories(classes);\n+\n+        Path module = base.resolve(\"m.jar\");\n+\n+        new JavacTask(tb)\n+            .options(\"-classpath\", \"\")\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run()\n+            .writeAll();\n+        new JarTask(tb, module)\n+            .baseDir(classes)\n+            .files(\".\")\n+            .run();\n+\n+        String testClassSource = \"jar:\" + module.toUri().toString() + \"!\/test\/TestClass.class\";\n+\n+        List<String> log;\n+\n+        log = new JavacTask(tb)\n+            .options(\"-processorpath\", System.getProperty(\"test.classes\"),\n+                     \"-processor\", AutomaticModulePrintFiles.class.getName(),\n+                     \"--module-path\", module.toString(),\n+                     \"--add-modules\", \"m\")\n+            .outdir(classes)\n+            .classes(\"java.lang.Object\")\n+            .run()\n+            .writeAll()\n+            .getOutputLines(Task.OutputKind.STDOUT);\n+\n+        List<String> expected = List.of(\n+                \"m: \" + \"<null>\",\n+                \"test: \" + \"<null>\",\n+                \"TestClass: \" + testClassSource,\n+                \"<init>: \" + testClassSource\n+        );\n+\n+        if (!expected.equals(log))\n+            throw new AssertionError(\"expected output not found: \" + log);\n+    }\n+\n+    @SupportedAnnotationTypes(\"*\")\n+    @SupportedOptions(\"fromClass\")\n+    public static final class AutomaticModulePrintFiles extends AbstractProcessor {\n+\n+        @Override\n+        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n+            if (!roundEnv.processingOver())\n+                return false;\n+\n+            Elements elements = processingEnv.getElementUtils();\n+            Trees trees = Trees.instance(processingEnv);\n+            Queue<Element> q = new ArrayDeque<>();\n+            q.add(elements.getModuleElement(\"m\"));\n+\n+            while (!q.isEmpty()) {\n+                Element currentElement = q.remove();\n+\n+                handleDeclaration(currentElement);\n+\n+                switch (currentElement.getKind()) {\n+                    case METHOD -> {\n+                        ExecutableElement method = (ExecutableElement) currentElement;\n+                        TreePath tp = trees.getPath(method);\n+                        if (tp != null) {\n+                            new TreePathScanner<>() {\n+                                @Override\n+                                public Object visitVariable(VariableTree node, Object p) {\n+                                    Element el = trees.getElement(getCurrentPath());\n+                                    handleDeclaration(el);\n+                                    return super.visitVariable(node, p);\n+                                }\n+                            }.scan(tp, null);\n+                        }\n+                    }\n+                    case MODULE -> {\n+                        q.add(elements.getPackageElement(\"test\"));\n+                    }\n+                    default ->\n+                        currentElement.getEnclosedElements()\n+                                      .stream()\n+                                      .sorted((e1, e2) -> e1.getSimpleName().toString().compareTo(e2.getSimpleName().toString()))\n+                                      .forEach(q::add);\n+                }\n+            }\n+\n+            return false;\n+        }\n+\n+        void handleDeclaration(Element el) {\n+            Elements elements = processingEnv.getElementUtils();\n+            JavaFileObject fileObjects = elements.getFileObjectOf(el);\n+            System.out.println(el.getSimpleName() + \": \" + (fileObjects != null ? fileObjects.toUri().toString() : \"<null>\"));\n+        }\n+\n+        @Override\n+        public SourceVersion getSupportedSourceVersion() {\n+            return SourceVersion.latestSupported();\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/element\/TestFileObjectOf.java","additions":596,"deletions":0,"binary":false,"changes":596,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8261847\n+ * @summary test the output of the toString method of records with a large number of components\n+ * @run testng BigRecordsToStringTest\n+ *\/\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Parameter;\n+import java.util.List;\n+import java.util.function.Supplier;\n+\n+import org.testng.annotations.*;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class BigRecordsToStringTest {\n+    record BigInt(\n+            int i1,int i2,int i3,int i4,int i5,int i6,int i7,int i8,int i9,int i10,\n+            int i11,int i12,int i13,int i14,int i15,int i16,int i17,int i18,int i19,int i20,\n+            int i21,int i22,int i23,int i24,int i25,int i26,int i27,int i28,int i29,int i30,\n+            int i31,int i32,int i33,int i34,int i35,int i36,int i37,int i38,int i39,int i40,\n+            int i41,int i42,int i43,int i44,int i45,int i46,int i47,int i48,int i49,int i50,\n+            int i51,int i52,int i53,int i54,int i55,int i56,int i57,int i58,int i59,int i60,\n+            int i61,int i62,int i63,int i64,int i65,int i66,int i67,int i68,int i69,int i70,\n+            int i71,int i72,int i73,int i74,int i75,int i76,int i77,int i78,int i79,int i80,\n+            int i81,int i82,int i83,int i84,int i85,int i86,int i87,int i88,int i89,int i90,\n+            int i91,int i92,int i93,int i94,int i95,int i96,int i97,int i98,int i99,int i100,\n+            int i101,int i102,int i103,int i104,int i105,int i106,int i107,int i108,int i109,int i110,\n+            int i111,int i112,int i113,int i114,int i115,int i116,int i117,int i118,int i119,int i120,\n+            int i121,int i122,int i123,int i124,int i125,int i126,int i127,int i128,int i129,int i130,\n+            int i131,int i132,int i133,int i134,int i135,int i136,int i137,int i138,int i139,int i140,\n+            int i141,int i142,int i143,int i144,int i145,int i146,int i147,int i148,int i149,int i150,\n+            int i151,int i152,int i153,int i154,int i155,int i156,int i157,int i158,int i159,int i160,\n+            int i161,int i162,int i163,int i164,int i165,int i166,int i167,int i168,int i169,int i170,\n+            int i171,int i172,int i173,int i174,int i175,int i176,int i177,int i178,int i179,int i180,\n+            int i181,int i182,int i183,int i184,int i185,int i186,int i187,int i188,int i189,int i190,\n+            int i191,int i192,int i193,int i194,int i195,int i196,int i197,int i198,int i199, int i200,\n+            int i201,int i202,int i203,int i204,int i205,int i206,int i207,int i208,int i209,int i210,\n+            int i211,int i212,int i213,int i214,int i215,int i216,int i217,int i218,int i219,int i220,\n+            int i221,int i222,int i223,int i224,int i225,int i226,int i227,int i228,int i229,int i230,\n+            int i231,int i232,int i233,int i234,int i235,int i236,int i237,int i238,int i239,int i240,\n+            int i241,int i242,int i243,int i244,int i245,int i246,int i247,int i248,int i249,int i250,\n+            int i251,int i252,int i253,int i254\n+    ) {}\n+\n+    BigInt bigInt= new BigInt(\n+            1,2,3,4,5,6,7,8,9,10,\n+            11,12,13,14,15,16,17,18,19,20,\n+            21,22,23,24,25,26,27,28,29,30,\n+            31,32,33,34,35,36,37,38,39,40,\n+            41,42,43,44,45,46,47,48,49,50,\n+            51,52,53,54,55,56,57,58,59,60,\n+            61,62,63,64,65,66,67,68,69,70,\n+            71,72,73,74,75,76,77,78,79,80,\n+            81,82,83,84,85,86,87,88,89,90,\n+            91,92,93,94,95,96,97,98,99,100,\n+            101,102,103,104,105,106,107,108,109,110,\n+            111,112,113,114,115,116,117,118,119,120,\n+            121,122,123,124,125,126,127,128,129,130,\n+            131,132,133,134,135,136,137,138,139,140,\n+            141,142,143,144,145,146,147,148,149,150,\n+            151,152,153,154,155,156,157,158,159,160,\n+            161,162,163,164,165,166,167,168,169,170,\n+            171,172,173,174,175,176,177,178,179,180,\n+            181,182,183,184,185,186,187,188,189,190,\n+            191,192,193,194,195,196,197,198,199, 200,\n+            201,202,203,204,205,206,207,208,209,210,\n+            211,212,213,214,215,216,217,218,219,220,\n+            221,222,223,224,225,226,227,228,229,230,\n+            231,232,233,234,235,236,237,238,239,240,\n+            241,242,243,244,245,246,247,248,249,250,\n+            251,252,253,254\n+    );\n+\n+    record BigLong(\n+            long i1,long i2,long i3,long i4,long i5,long i6,long i7,long i8,long i9,long i10,\n+            long i11,long i12,long i13,long i14,long i15,long i16,long i17,long i18,long i19,long i20,\n+            long i21,long i22,long i23,long i24,long i25,long i26,long i27,long i28,long i29,long i30,\n+            long i31,long i32,long i33,long i34,long i35,long i36,long i37,long i38,long i39,long i40,\n+            long i41,long i42,long i43,long i44,long i45,long i46,long i47,long i48,long i49,long i50,\n+            long i51,long i52,long i53,long i54,long i55,long i56,long i57,long i58,long i59,long i60,\n+            long i61,long i62,long i63,long i64,long i65,long i66,long i67,long i68,long i69,long i70,\n+            long i71,long i72,long i73,long i74,long i75,long i76,long i77,long i78,long i79,long i80,\n+            long i81,long i82,long i83,long i84,long i85,long i86,long i87,long i88,long i89,long i90,\n+            long i91,long i92,long i93,long i94,long i95,long i96,long i97,long i98,long i99,long i100,\n+            long i101,long i102,long i103,long i104,long i105,long i106,long i107,long i108,long i109,long i110,\n+            long i111,long i112,long i113,long i114,long i115,long i116,long i117,long i118,long i119,long i120,\n+            long i121,long i122,long i123,long i124,long i125,long i126,long i127\n+    ) {}\n+\n+    BigLong bigLong = new BigLong(\n+            1,2,3,4,5,6,7,8,9,10,\n+            11,12,13,14,15,16,17,18,19,20,\n+            21,22,23,24,25,26,27,28,29,30,\n+            31,32,33,34,35,36,37,38,39,40,\n+            41,42,43,44,45,46,47,48,49,50,\n+            51,52,53,54,55,56,57,58,59,60,\n+            61,62,63,64,65,66,67,68,69,70,\n+            71,72,73,74,75,76,77,78,79,80,\n+            81,82,83,84,85,86,87,88,89,90,\n+            91,92,93,94,95,96,97,98,99,100,\n+            101,102,103,104,105,106,107,108,109,110,\n+            111,112,113,114,115,116,117,118,119,120,\n+            121,122,123,124,125,126,127\n+    );\n+\n+    private static final String BIG_INT_TO_STRING_OUTPUT =\n+        \"BigInt[i1=1, i2=2, i3=3, i4=4, i5=5, i6=6, i7=7, i8=8, i9=9, i10=10, i11=11, i12=12, i13=13, i14=14, i15=15, i16=16, \" +\n+            \"i17=17, i18=18, i19=19, i20=20, i21=21, i22=22, i23=23, i24=24, i25=25, i26=26, i27=27, i28=28, i29=29, i30=30, \" +\n+            \"i31=31, i32=32, i33=33, i34=34, i35=35, i36=36, i37=37, i38=38, i39=39, i40=40, i41=41, i42=42, i43=43, i44=44, \" +\n+            \"i45=45, i46=46, i47=47, i48=48, i49=49, i50=50, i51=51, i52=52, i53=53, i54=54, i55=55, i56=56, i57=57, i58=58, \" +\n+            \"i59=59, i60=60, i61=61, i62=62, i63=63, i64=64, i65=65, i66=66, i67=67, i68=68, i69=69, i70=70, i71=71, i72=72, \" +\n+            \"i73=73, i74=74, i75=75, i76=76, i77=77, i78=78, i79=79, i80=80, i81=81, i82=82, i83=83, i84=84, i85=85, i86=86, \" +\n+            \"i87=87, i88=88, i89=89, i90=90, i91=91, i92=92, i93=93, i94=94, i95=95, i96=96, i97=97, i98=98, i99=99, i100=100, \" +\n+            \"i101=101, i102=102, i103=103, i104=104, i105=105, i106=106, i107=107, i108=108, i109=109, i110=110, i111=111, i112=112, \" +\n+            \"i113=113, i114=114, i115=115, i116=116, i117=117, i118=118, i119=119, i120=120, i121=121, i122=122, i123=123, i124=124, \" +\n+            \"i125=125, i126=126, i127=127, i128=128, i129=129, i130=130, i131=131, i132=132, i133=133, i134=134, i135=135, i136=136, \" +\n+            \"i137=137, i138=138, i139=139, i140=140, i141=141, i142=142, i143=143, i144=144, i145=145, i146=146, i147=147, i148=148, \" +\n+            \"i149=149, i150=150, i151=151, i152=152, i153=153, i154=154, i155=155, i156=156, i157=157, i158=158, i159=159, i160=160, \" +\n+            \"i161=161, i162=162, i163=163, i164=164, i165=165, i166=166, i167=167, i168=168, i169=169, i170=170, i171=171, i172=172, \" +\n+            \"i173=173, i174=174, i175=175, i176=176, i177=177, i178=178, i179=179, i180=180, i181=181, i182=182, i183=183, i184=184, \" +\n+            \"i185=185, i186=186, i187=187, i188=188, i189=189, i190=190, i191=191, i192=192, i193=193, i194=194, i195=195, i196=196, \" +\n+            \"i197=197, i198=198, i199=199, i200=200, i201=201, i202=202, i203=203, i204=204, i205=205, i206=206, i207=207, i208=208, \" +\n+            \"i209=209, i210=210, i211=211, i212=212, i213=213, i214=214, i215=215, i216=216, i217=217, i218=218, i219=219, i220=220, \" +\n+            \"i221=221, i222=222, i223=223, i224=224, i225=225, i226=226, i227=227, i228=228, i229=229, i230=230, i231=231, i232=232, \" +\n+            \"i233=233, i234=234, i235=235, i236=236, i237=237, i238=238, i239=239, i240=240, i241=241, i242=242, i243=243, i244=244, \" +\n+            \"i245=245, i246=246, i247=247, i248=248, i249=249, i250=250, i251=251, i252=252, i253=253, i254=254]\";\n+\n+    private static final String BIG_LONG_TO_STRING_OUTPUT =\n+        \"BigLong[i1=1, i2=2, i3=3, i4=4, i5=5, i6=6, i7=7, i8=8, i9=9, i10=10, i11=11, i12=12, i13=13, i14=14, i15=15, i16=16, i17=17, \" +\n+            \"i18=18, i19=19, i20=20, i21=21, i22=22, i23=23, i24=24, i25=25, i26=26, i27=27, i28=28, i29=29, i30=30, i31=31, i32=32, i33=33, \" +\n+            \"i34=34, i35=35, i36=36, i37=37, i38=38, i39=39, i40=40, i41=41, i42=42, i43=43, i44=44, i45=45, i46=46, i47=47, i48=48, i49=49, \" +\n+            \"i50=50, i51=51, i52=52, i53=53, i54=54, i55=55, i56=56, i57=57, i58=58, i59=59, i60=60, i61=61, i62=62, i63=63, i64=64, i65=65, \" +\n+            \"i66=66, i67=67, i68=68, i69=69, i70=70, i71=71, i72=72, i73=73, i74=74, i75=75, i76=76, i77=77, i78=78, i79=79, i80=80, i81=81, \" +\n+            \"i82=82, i83=83, i84=84, i85=85, i86=86, i87=87, i88=88, i89=89, i90=90, i91=91, i92=92, i93=93, i94=94, i95=95, i96=96, i97=97, \" +\n+            \"i98=98, i99=99, i100=100, i101=101, i102=102, i103=103, i104=104, i105=105, i106=106, i107=107, i108=108, i109=109, i110=110, \" +\n+            \"i111=111, i112=112, i113=113, i114=114, i115=115, i116=116, i117=117, i118=118, i119=119, i120=120, i121=121, i122=122, i123=123, \" +\n+            \"i124=124, i125=125, i126=126, i127=127]\";\n+\n+    public void testToStringOutput() {\n+        assertTrue(bigInt.toString().equals(BIG_INT_TO_STRING_OUTPUT));\n+        assertTrue(bigLong.toString().equals(BIG_LONG_TO_STRING_OUTPUT));\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/records\/BigRecordsToStringTest.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -92,1 +92,2 @@\n-            \"javax.annotation.processing.SupportedSourceVersion\"\n+            \"javax.annotation.processing.SupportedSourceVersion\",\n+            \"javax.tools.JavaFileObject\"\n","filename":"test\/langtools\/tools\/javac\/tree\/NoPrivateTypesExported.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-                \"  0: #21(#22=B#23)\\n\" +\n+                \"  0: #17(#18=B#19)\\n\" +\n@@ -56,1 +56,1 @@\n-                \"  1: #24(#22=S#25)\\n\" +\n+                \"  1: #20(#18=S#21)\\n\" +\n@@ -62,1 +62,1 @@\n-                \"  0: #27(#22=[J#28,J#30,J#32,J#34,J#36])\\n\" +\n+                \"  0: #23(#18=[J#24,J#26,J#28,J#30,J#32])\\n\" +\n@@ -66,1 +66,1 @@\n-                \"  1: #38(#22=Z#39)\\n\" +\n+                \"  1: #34(#18=Z#35)\\n\" +\n@@ -70,1 +70,1 @@\n-                \"  2: #40(#41=c#42)\\n\" +\n+                \"  2: #36(#37=c#38)\\n\" +\n@@ -74,1 +74,1 @@\n-                \"  3: #43(#44=e#45.#46)\\n\" +\n+                \"  3: #39(#40=e#41.#42)\\n\" +\n@@ -78,1 +78,1 @@\n-                \"  4: #47(#22=I#48)\\n\" +\n+                \"  4: #43(#18=I#44)\\n\" +\n@@ -82,1 +82,1 @@\n-                \"  5: #49()\\n\" +\n+                \"  5: #45()\\n\" +\n@@ -84,1 +84,1 @@\n-                \"  6: #50(#51=s#52)\\n\" +\n+                \"  6: #46(#47=s#48)\\n\" +\n@@ -88,1 +88,1 @@\n-                \"  7: #53(#54=D#55,#57=F#58)\\n\" +\n+                \"  7: #49(#50=D#51,#53=F#54)\\n\" +\n@@ -93,1 +93,1 @@\n-                \"  8: #59()\\n\" +\n+                \"  8: #55()\\n\" +\n@@ -95,1 +95,1 @@\n-                \"  9: #60(#22=@#47(#22=I#61))\\n\" +\n+                \"  9: #56(#18=@#43(#18=I#57))\\n\" +\n@@ -103,1 +103,1 @@\n-                \"  0: #63(): CLASS_EXTENDS, type_index=0\\n\" +\n+                \"  0: #59(): CLASS_EXTENDS, type_index=0\\n\" +\n","filename":"test\/langtools\/tools\/javap\/AnnoTest.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.arm.benchmarks.intrinsics;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+\/**\n+ * This benchmark modified from test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestStringCompareToDifferentLength.java\n+ * This benchmark can be used to measure performance of compareTo() in\n+ * (Latin1, Latin1), (Latin1, UTF16), (UTF16, Latin1), and (UTF16, UTF16)\n+ * comparisons.\n+ *\/\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Measurement(iterations = 3, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 3, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+public class StringCompareToDifferentLength {\n+\n+    @State(Scope.Benchmark)\n+    public static class Input {\n+        @Param({\"24\", \"36\", \"72\", \"128\", \"256\", \"512\"})\n+        public int size;\n+\n+        @Param({\"2\"})\n+        public int delta;\n+\n+        int count = 100000;\n+        String longLatin1;\n+        String shortLatin1;\n+        String longUTF16FirstChar;\n+        String shortUTF16FirstChar;\n+        String longUTF16LastChar;\n+        String shortUTF16LastChar;\n+\n+        \/**\n+         * Initialize. New array objects and set initial values.\n+         *\/\n+        @Setup(Level.Trial)\n+        public void setup() throws Exception {\n+            char[] strsrc = new char[size + delta];\n+            \/\/ generate ASCII string\n+            for (int i = 0; i < size + delta; i++) {\n+                strsrc[i] = (char) ('a' + (i % 26));\n+            }\n+\n+            longLatin1 = new String(strsrc);\n+            shortLatin1 = longLatin1.substring(0, size);\n+            longUTF16LastChar = longLatin1.substring(0, longLatin1.length() - 1) + '\\ubeef';\n+            longUTF16FirstChar = '\\ubeef' + longLatin1.substring(1, longLatin1.length());\n+            shortUTF16LastChar = shortLatin1.substring(0, shortLatin1.length() - 1) + '\\ubeef';\n+            shortUTF16FirstChar = longUTF16FirstChar.substring(0, size);\n+        }\n+    }\n+\n+    private int runCompareTo(String str2, String str1) {\n+        return str1.compareTo(str2);\n+    }\n+\n+    \/**\n+     * latin1-latin1\n+     *\/\n+    @Benchmark\n+    public void compareToLL(Input in, Blackhole blackhole) {\n+        int res = 0;\n+        for (int i = 0; i < in.count; ++i) {\n+            res += runCompareTo(in.longLatin1, in.shortLatin1);\n+        }\n+        blackhole.consume(res);\n+    }\n+\n+    \/**\n+     * UTF16-UTF16\n+     *\/\n+    @Benchmark\n+    public void compareToUU(Input in, Blackhole blackhole) {\n+        int res = 0;\n+        for (int i = 0; i < in.count; ++i) {\n+            res += runCompareTo(in.longUTF16FirstChar, in.shortUTF16FirstChar);\n+        }\n+        blackhole.consume(res);\n+    }\n+\n+    \/**\n+     * latin1-UTF16\n+     *\/\n+    @Benchmark\n+    public void compareToLU(Input in, Blackhole blackhole) {\n+        int res = 0;\n+        for (int i = 0; i < in.count; ++i) {\n+            res += runCompareTo(in.longUTF16LastChar, in.shortLatin1);\n+        }\n+        blackhole.consume(res);\n+    }\n+\n+    \/**\n+     * UTF16-latin1\n+     *\/\n+    @Benchmark\n+    public void compareToUL(Input in, Blackhole blackhole) {\n+        int res = 0;\n+        for (int i = 0; i < in.count; ++i) {\n+            res += runCompareTo(in.longLatin1, in.shortUTF16LastChar);\n+        }\n+        blackhole.consume(res);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringCompareToDifferentLength.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.runtime;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * Benchmark assesses Record.toString which is implemented by ObjectMethods::makeToString\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class ObjectMethods {\n+    record R0() {}\n+    record R1(int i) {}\n+    record R10(int i1,int i2,int i3,int i4,int i5,int i6,int i7,int i8,int i9,int i10) {}\n+    record R100(int i1,int i2,int i3,int i4,int i5,int i6,int i7,int i8,int i9,int i10,\n+                int i11,int i12,int i13,int i14,int i15,int i16,int i17,int i18,int i19,int i20,\n+                int i21,int i22,int i23,int i24,int i25,int i26,int i27,int i28,int i29,int i30,\n+                int i31,int i32,int i33,int i34,int i35,int i36,int i37,int i38,int i39,int i40,\n+                int i41,int i42,int i43,int i44,int i45,int i46,int i47,int i48,int i49,int i50,\n+                int i51,int i52,int i53,int i54,int i55,int i56,int i57,int i58,int i59,int i60,\n+                int i61,int i62,int i63,int i64,int i65,int i66,int i67,int i68,int i69,int i70,\n+                int i71,int i72,int i73,int i74,int i75,int i76,int i77,int i78,int i79,int i80,\n+                int i81,int i82,int i83,int i84,int i85,int i86,int i87,int i88,int i89,int i90,\n+                int i91,int i92,int i93,int i94,int i95,int i96,int i97,int i98,int i99,int i100) {}\n+    record R254(int i1,int i2,int i3,int i4,int i5,int i6,int i7,int i8,int i9,int i10,\n+                int i11,int i12,int i13,int i14,int i15,int i16,int i17,int i18,int i19,int i20,\n+                int i21,int i22,int i23,int i24,int i25,int i26,int i27,int i28,int i29,int i30,\n+                int i31,int i32,int i33,int i34,int i35,int i36,int i37,int i38,int i39,int i40,\n+                int i41,int i42,int i43,int i44,int i45,int i46,int i47,int i48,int i49,int i50,\n+                int i51,int i52,int i53,int i54,int i55,int i56,int i57,int i58,int i59,int i60,\n+                int i61,int i62,int i63,int i64,int i65,int i66,int i67,int i68,int i69,int i70,\n+                int i71,int i72,int i73,int i74,int i75,int i76,int i77,int i78,int i79,int i80,\n+                int i81,int i82,int i83,int i84,int i85,int i86,int i87,int i88,int i89,int i90,\n+                int i91,int i92,int i93,int i94,int i95,int i96,int i97,int i98,int i99,int i100,\n+                int i101,int i102,int i103,int i104,int i105,int i106,int i107,int i108,int i109,int i110,\n+                int i111,int i112,int i113,int i114,int i115,int i116,int i117,int i118,int i119,int i120,\n+                int i121,int i122,int i123,int i124,int i125,int i126,int i127,int i128,int i129,int i130,\n+                int i131,int i132,int i133,int i134,int i135,int i136,int i137,int i138,int i139,int i140,\n+                int i141,int i142,int i143,int i144,int i145,int i146,int i147,int i148,int i149,int i150,\n+                int i151,int i152,int i153,int i154,int i155,int i156,int i157,int i158,int i159,int i160,\n+                int i161,int i162,int i163,int i164,int i165,int i166,int i167,int i168,int i169,int i170,\n+                int i171,int i172,int i173,int i174,int i175,int i176,int i177,int i178,int i179,int i180,\n+                int i181,int i182,int i183,int i184,int i185,int i186,int i187,int i188,int i189,int i190,\n+                int i191,int i192,int i193,int i194,int i195,int i196,int i197,int i198,int i199, int i200,\n+                int i201,int i202,int i203,int i204,int i205,int i206,int i207,int i208,int i209,int i210,\n+                int i211,int i212,int i213,int i214,int i215,int i216,int i217,int i218,int i219,int i220,\n+                int i221,int i222,int i223,int i224,int i225,int i226,int i227,int i228,int i229,int i230,\n+                int i231,int i232,int i233,int i234,int i235,int i236,int i237,int i238,int i239,int i240,\n+                int i241,int i242,int i243,int i244,int i245,int i246,int i247,int i248,int i249,int i250,\n+                int i251,int i252,int i253,int i254) {}\n+\n+    R0 r0;\n+    R1 r1;\n+    R10 r10;\n+    R100 r100;\n+    R254 r254;\n+\n+    @Setup\n+    public void prepare() {\n+        r0 = new R0();\n+        r1 = new R1(1);\n+        r10 = new R10(1,2,3,4,5,6,7,8,9,10);\n+        r100 = new R100(1,2,3,4,5,6,7,8,9,10,\n+                        11,12,13,14,15,16,17,18,19,20,\n+                        21,22,23,24,25,26,27,28,29,30,\n+                        31,32,33,34,35,36,37,38,39,40,\n+                        41,42,43,44,45,46,47,48,49,50,\n+                        51,52,53,54,55,56,57,58,59,60,\n+                        61,62,63,64,65,66,67,68,69,70,\n+                        71,72,73,74,75,76,77,78,79,80,\n+                        81,82,83,84,85,86,87,88,89,90,\n+                        91,92,93,94,95,96,97,98,99,100);\n+        r254 = new R254(1,2,3,4,5,6,7,8,9,10,\n+                        11,12,13,14,15,16,17,18,19,20,\n+                        21,22,23,24,25,26,27,28,29,30,\n+                        31,32,33,34,35,36,37,38,39,40,\n+                        41,42,43,44,45,46,47,48,49,50,\n+                        51,52,53,54,55,56,57,58,59,60,\n+                        61,62,63,64,65,66,67,68,69,70,\n+                        71,72,73,74,75,76,77,78,79,80,\n+                        81,82,83,84,85,86,87,88,89,90,\n+                        91,92,93,94,95,96,97,98,99,100,\n+                        101,102,103,104,105,106,107,108,109,110,\n+                        111,112,113,114,115,116,117,118,119,120,\n+                        121,122,123,124,125,126,127,128,129,130,\n+                        131,132,133,134,135,136,137,138,139,140,\n+                        141,142,143,144,145,146,147,148,149,150,\n+                        151,152,153,154,155,156,157,158,159,160,\n+                        161,162,163,164,165,166,167,168,169,170,\n+                        171,172,173,174,175,176,177,178,179,180,\n+                        181,182,183,184,185,186,187,188,189,190,\n+                        191,192,193,194,195,196,197,198,199, 200,\n+                        201,202,203,204,205,206,207,208,209,210,\n+                        211,212,213,214,215,216,217,218,219,220,\n+                        221,222,223,224,225,226,227,228,229,230,\n+                        231,232,233,234,235,236,237,238,239,240,\n+                        241,242,243,244,245,246,247,248,249,250,\n+                        251,252,253,254);\n+    }\n+\n+    @Benchmark\n+    public String toString0() {\n+        return r0.toString();\n+    }\n+\n+    @Benchmark\n+    public String toString1() {\n+        return r1.toString();\n+    }\n+\n+    @Benchmark\n+    public String toString10() {\n+        return r10.toString();\n+    }\n+\n+    @Benchmark\n+    public String toString100() {\n+        return r100.toString();\n+    }\n+\n+    @Benchmark\n+    public String toString254() {\n+        return r254.toString();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/runtime\/ObjectMethods.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.util.regex;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value=1, jvmArgs= {\"-showversion\", \"-XX:+UseSerialGC\"})\n+@Warmup(iterations = 1, time = 10, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 10, timeUnit = TimeUnit.SECONDS)\n+public class FindPattern {\n+    @Param({\"[^A-Za-z0-9]\", \"[A-Za-z0-9]\"})\n+    static String patternString;\n+    @Param({\"abcdefghijklmnop1234567890ABCDEFGHIJKLMNOP\",\n+            \",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\"})\n+    static String text;\n+    static Pattern pattern;\n+\n+    @Setup(Level.Trial)\n+    public void setupTrial() {\n+        pattern = Pattern.compile(patternString);\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.AverageTime)\n+    public int testFind() {\n+        int counter = 0;\n+        Matcher m = pattern.matcher(text);\n+        while (m.find()) {\n+            counter++;\n+        }\n+        return counter;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/regex\/FindPattern.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,0 +198,28 @@\n+    @Benchmark\n+    public void convert_i2f() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resF[i] = (float) ints[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convert_f2i() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resI[i] = (int) floats[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convert_l2d() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resD[i] = (double) longs[i];\n+        }\n+    }\n+\n+    @Benchmark\n+    public void convert_d2l() {\n+        for (int i = 0; i < COUNT; i++) {\n+            resL[i] = (long) doubles[i];\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/TypeVectorOperations.java","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"}]}